[{"authorTime":"2019-02-03 14:34:53","codes":[{"authorDate":"2019-02-03 14:34:53","commitOrder":3,"curCode":"  public void testQuantileOnFloatAndLongs() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n\n    final String sql = \"SELECT\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.01),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.5, 50),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.98, 200),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.99),\\n\"\n                       + \"APPROX_QUANTILE(m1 * 2, 0.97),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.99) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.999) FILTER(WHERE dim1 <> 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.999) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(cnt, 0.5)\\n\"\n                       + \"FROM foo\";\n\n    \r\n    final List<Object[]> results = sqlLifecycle.runSimple(sql, QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            1.0,\n            3.0,\n            5.880000114440918,\n            5.940000057220459,\n            11.640000343322754,\n            6.0,\n            4.994999885559082,\n            6.0,\n            1.0\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    \r\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(CalciteTests.DATASOURCE1)\n              .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n              .granularity(Granularities.ALL)\n              .virtualColumns(\n                  new ExpressionVirtualColumn(\n                      \"a4:v\",\n                      \"(\\\"m1\\\" * 2)\",\n                      ValueType.FLOAT,\n                      TestExprMacroTable.INSTANCE\n                  )\n              )\n              .aggregators(ImmutableList.of(\n                  new ApproximateHistogramAggregatorFactory(\"a0:agg\", \"m1\", null, null, null, null),\n                  new ApproximateHistogramAggregatorFactory(\"a2:agg\", \"m1\", 200, null, null, null),\n                  new ApproximateHistogramAggregatorFactory(\"a4:agg\", \"a4:v\", null, null, null, null),\n                  new FilteredAggregatorFactory(\n                      new ApproximateHistogramAggregatorFactory(\"a5:agg\", \"m1\", null, null, null, null),\n                      new SelectorDimFilter(\"dim1\", \"abc\", null)\n                  ),\n                  new FilteredAggregatorFactory(\n                      new ApproximateHistogramAggregatorFactory(\"a6:agg\", \"m1\", null, null, null, null),\n                      new NotDimFilter(new SelectorDimFilter(\"dim1\", \"abc\", null))\n                  ),\n                  new ApproximateHistogramAggregatorFactory(\"a8:agg\", \"cnt\", null, null, null, null)\n              ))\n              .postAggregators(\n                  new QuantilePostAggregator(\"a0\", \"a0:agg\", 0.01f),\n                  new QuantilePostAggregator(\"a1\", \"a0:agg\", 0.50f),\n                  new QuantilePostAggregator(\"a2\", \"a2:agg\", 0.98f),\n                  new QuantilePostAggregator(\"a3\", \"a0:agg\", 0.99f),\n                  new QuantilePostAggregator(\"a4\", \"a4:agg\", 0.97f),\n                  new QuantilePostAggregator(\"a5\", \"a5:agg\", 0.99f),\n                  new QuantilePostAggregator(\"a6\", \"a6:agg\", 0.999f),\n                  new QuantilePostAggregator(\"a7\", \"a5:agg\", 0.999f),\n                  new QuantilePostAggregator(\"a8\", \"a8:agg\", 0.50f)\n              )\n              .context(ImmutableMap.of(\"skipEmptyBuckets\", true, PlannerContext.CTX_SQL_QUERY_ID, \"dummy\"))\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","date":"2019-02-03 14:34:53","endLine":270,"groupId":"7047","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testQuantileOnFloatAndLongs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/ee/354e5baab3897555f04e7ef179b7dec9a7ec49.src","preCode":"  public void testQuantileOnFloatAndLongs() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n\n    final String sql = \"SELECT\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.01),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.5, 50),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.98, 200),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.99),\\n\"\n                       + \"APPROX_QUANTILE(m1 * 2, 0.97),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.99) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.999) FILTER(WHERE dim1 <> 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.999) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(cnt, 0.5)\\n\"\n                       + \"FROM foo\";\n\n    \r\n    final List<Object[]> results = sqlLifecycle.runSimple(sql, QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            1.0,\n            3.0,\n            5.880000114440918,\n            5.940000057220459,\n            11.640000343322754,\n            6.0,\n            4.994999885559082,\n            6.0,\n            1.0\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    \r\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(CalciteTests.DATASOURCE1)\n              .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n              .granularity(Granularities.ALL)\n              .virtualColumns(\n                  new ExpressionVirtualColumn(\n                      \"a4:v\",\n                      \"(\\\"m1\\\" * 2)\",\n                      ValueType.FLOAT,\n                      TestExprMacroTable.INSTANCE\n                  )\n              )\n              .aggregators(ImmutableList.of(\n                  new ApproximateHistogramAggregatorFactory(\"a0:agg\", \"m1\", null, null, null, null),\n                  new ApproximateHistogramAggregatorFactory(\"a2:agg\", \"m1\", 200, null, null, null),\n                  new ApproximateHistogramAggregatorFactory(\"a4:agg\", \"a4:v\", null, null, null, null),\n                  new FilteredAggregatorFactory(\n                      new ApproximateHistogramAggregatorFactory(\"a5:agg\", \"m1\", null, null, null, null),\n                      new SelectorDimFilter(\"dim1\", \"abc\", null)\n                  ),\n                  new FilteredAggregatorFactory(\n                      new ApproximateHistogramAggregatorFactory(\"a6:agg\", \"m1\", null, null, null, null),\n                      new NotDimFilter(new SelectorDimFilter(\"dim1\", \"abc\", null))\n                  ),\n                  new ApproximateHistogramAggregatorFactory(\"a8:agg\", \"cnt\", null, null, null, null)\n              ))\n              .postAggregators(\n                  new QuantilePostAggregator(\"a0\", \"a0:agg\", 0.01f),\n                  new QuantilePostAggregator(\"a1\", \"a0:agg\", 0.50f),\n                  new QuantilePostAggregator(\"a2\", \"a2:agg\", 0.98f),\n                  new QuantilePostAggregator(\"a3\", \"a0:agg\", 0.99f),\n                  new QuantilePostAggregator(\"a4\", \"a4:agg\", 0.97f),\n                  new QuantilePostAggregator(\"a5\", \"a5:agg\", 0.99f),\n                  new QuantilePostAggregator(\"a6\", \"a6:agg\", 0.999f),\n                  new QuantilePostAggregator(\"a7\", \"a5:agg\", 0.999f),\n                  new QuantilePostAggregator(\"a8\", \"a8:agg\", 0.50f)\n              )\n              .context(ImmutableMap.of(\"skipEmptyBuckets\", true, PlannerContext.CTX_SQL_QUERY_ID, \"dummy\"))\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","realPath":"extensions-core/histogram/src/test/java/org/apache/druid/query/aggregation/histogram/sql/QuantileSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":191,"status":"MB"},{"authorDate":"2019-02-03 14:34:53","commitOrder":3,"curCode":"  public void testQuantileOnFloatAndLongs() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.01, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.5, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.98, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.99, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1 * 2, 0.97, 40, 0.0, 20.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.99, 20, 0.0, 10.0) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.999, 20, 0.0, 10.0) FILTER(WHERE dim1 <> 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.999, 20, 0.0, 10.0) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(cnt, 0.5, 20, 0.0, 10.0)\\n\"\n                       + \"FROM foo\";\n\n    \r\n    final List<Object[]> results = sqlLifecycle.runSimple(sql, QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            1.0299999713897705,\n            3.5,\n            6.440000057220459,\n            6.470000267028809,\n            12.40999984741211,\n            6.494999885559082,\n            5.497499942779541,\n            6.499499797821045,\n            1.25\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Query actual = Iterables.getOnlyElement(queryLogHook.getRecordedQueries());\n    Query expected = Druids.newTimeseriesQueryBuilder()\n                           .dataSource(CalciteTests.DATASOURCE1)\n                           .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n                           .granularity(Granularities.ALL)\n                           .virtualColumns(\n                               new ExpressionVirtualColumn(\n                                   \"a4:v\",\n                                   \"(\\\"m1\\\" * 2)\",\n                                   ValueType.FLOAT,\n                                   TestExprMacroTable.INSTANCE\n                               )\n                           )\n                           .aggregators(ImmutableList.of(\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a0:agg\", \"m1\", 20, 0.0d, 10.0d, FixedBucketsHistogram.OutlierHandlingMode.IGNORE\n                               ),\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a4:agg\", \"a4:v\", 40, 0.0d, 20.0d, FixedBucketsHistogram.OutlierHandlingMode.IGNORE\n                               ),\n                               new FilteredAggregatorFactory(\n                                   new FixedBucketsHistogramAggregatorFactory(\n                                       \"a5:agg\", \"m1\", 20, 0.0d, 10.0d, FixedBucketsHistogram.OutlierHandlingMode.IGNORE\n                                   ),\n                                   new SelectorDimFilter(\"dim1\", \"abc\", null)\n                               ),\n                               new FilteredAggregatorFactory(\n                                   new FixedBucketsHistogramAggregatorFactory(\n                                       \"a6:agg\", \"m1\", 20, 0.0d, 10.0d, FixedBucketsHistogram.OutlierHandlingMode.IGNORE\n                                   ),\n                                   new NotDimFilter(new SelectorDimFilter(\"dim1\", \"abc\", null))\n                               ),\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a8:agg\", \"cnt\", 20, 0.0d, 10.0d, FixedBucketsHistogram.OutlierHandlingMode.IGNORE\n                               )\n                           ))\n                           .postAggregators(\n                               new QuantilePostAggregator(\"a0\", \"a0:agg\", 0.01f),\n                               new QuantilePostAggregator(\"a1\", \"a0:agg\", 0.50f),\n                               new QuantilePostAggregator(\"a2\", \"a0:agg\", 0.98f),\n                               new QuantilePostAggregator(\"a3\", \"a0:agg\", 0.99f),\n                               new QuantilePostAggregator(\"a4\", \"a4:agg\", 0.97f),\n                               new QuantilePostAggregator(\"a5\", \"a5:agg\", 0.99f),\n                               new QuantilePostAggregator(\"a6\", \"a6:agg\", 0.999f),\n                               new QuantilePostAggregator(\"a7\", \"a5:agg\", 0.999f),\n                               new QuantilePostAggregator(\"a8\", \"a8:agg\", 0.50f)\n                           )\n                           .context(ImmutableMap.of(\"skipEmptyBuckets\", true, PlannerContext.CTX_SQL_QUERY_ID, \"dummy\"))\n                           .build();\n\n    \r\n    Assert.assertEquals(\n        expected,\n        actual\n    );\n  }\n","date":"2019-02-03 14:34:53","endLine":282,"groupId":"7726","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testQuantileOnFloatAndLongs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/4b/a94fe76d06705da8aa26c321dcae5ffec30f1e.src","preCode":"  public void testQuantileOnFloatAndLongs() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.01, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.5, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.98, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.99, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1 * 2, 0.97, 40, 0.0, 20.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.99, 20, 0.0, 10.0) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.999, 20, 0.0, 10.0) FILTER(WHERE dim1 <> 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.999, 20, 0.0, 10.0) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(cnt, 0.5, 20, 0.0, 10.0)\\n\"\n                       + \"FROM foo\";\n\n    \r\n    final List<Object[]> results = sqlLifecycle.runSimple(sql, QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            1.0299999713897705,\n            3.5,\n            6.440000057220459,\n            6.470000267028809,\n            12.40999984741211,\n            6.494999885559082,\n            5.497499942779541,\n            6.499499797821045,\n            1.25\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Query actual = Iterables.getOnlyElement(queryLogHook.getRecordedQueries());\n    Query expected = Druids.newTimeseriesQueryBuilder()\n                           .dataSource(CalciteTests.DATASOURCE1)\n                           .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n                           .granularity(Granularities.ALL)\n                           .virtualColumns(\n                               new ExpressionVirtualColumn(\n                                   \"a4:v\",\n                                   \"(\\\"m1\\\" * 2)\",\n                                   ValueType.FLOAT,\n                                   TestExprMacroTable.INSTANCE\n                               )\n                           )\n                           .aggregators(ImmutableList.of(\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a0:agg\", \"m1\", 20, 0.0d, 10.0d, FixedBucketsHistogram.OutlierHandlingMode.IGNORE\n                               ),\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a4:agg\", \"a4:v\", 40, 0.0d, 20.0d, FixedBucketsHistogram.OutlierHandlingMode.IGNORE\n                               ),\n                               new FilteredAggregatorFactory(\n                                   new FixedBucketsHistogramAggregatorFactory(\n                                       \"a5:agg\", \"m1\", 20, 0.0d, 10.0d, FixedBucketsHistogram.OutlierHandlingMode.IGNORE\n                                   ),\n                                   new SelectorDimFilter(\"dim1\", \"abc\", null)\n                               ),\n                               new FilteredAggregatorFactory(\n                                   new FixedBucketsHistogramAggregatorFactory(\n                                       \"a6:agg\", \"m1\", 20, 0.0d, 10.0d, FixedBucketsHistogram.OutlierHandlingMode.IGNORE\n                                   ),\n                                   new NotDimFilter(new SelectorDimFilter(\"dim1\", \"abc\", null))\n                               ),\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a8:agg\", \"cnt\", 20, 0.0d, 10.0d, FixedBucketsHistogram.OutlierHandlingMode.IGNORE\n                               )\n                           ))\n                           .postAggregators(\n                               new QuantilePostAggregator(\"a0\", \"a0:agg\", 0.01f),\n                               new QuantilePostAggregator(\"a1\", \"a0:agg\", 0.50f),\n                               new QuantilePostAggregator(\"a2\", \"a0:agg\", 0.98f),\n                               new QuantilePostAggregator(\"a3\", \"a0:agg\", 0.99f),\n                               new QuantilePostAggregator(\"a4\", \"a4:agg\", 0.97f),\n                               new QuantilePostAggregator(\"a5\", \"a5:agg\", 0.99f),\n                               new QuantilePostAggregator(\"a6\", \"a6:agg\", 0.999f),\n                               new QuantilePostAggregator(\"a7\", \"a5:agg\", 0.999f),\n                               new QuantilePostAggregator(\"a8\", \"a8:agg\", 0.50f)\n                           )\n                           .context(ImmutableMap.of(\"skipEmptyBuckets\", true, PlannerContext.CTX_SQL_QUERY_ID, \"dummy\"))\n                           .build();\n\n    \r\n    Assert.assertEquals(\n        expected,\n        actual\n    );\n  }\n","realPath":"extensions-core/histogram/src/test/java/org/apache/druid/query/aggregation/histogram/sql/FixedBucketsHistogramQuantileSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":192,"status":"B"}],"commitId":"953b96d0a436b2bd979c2aa6eecc3f636387633c","commitMessage":"@@@Add more sketch aggregator support in Druid SQL (#6951)\n\n* Add more sketch aggregator support in Druid SQL\n\n* Add docs\n\n* Tweak module serde register\n\n* Fix tests\n\n* Checkstyle\n\n* Test fix\n\n* PR comment\n\n* PR comment\n\n* PR comments\n","date":"2019-02-03 14:34:53","modifiedFileCount":"16","status":"M","submitter":"Jonathan Wei"},{"authorTime":"2019-03-12 02:37:58","codes":[{"authorDate":"2019-03-12 02:37:58","commitOrder":4,"curCode":"  public void testQuantileOnFloatAndLongs() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n\n    final String sql = \"SELECT\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.01),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.5, 50),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.98, 200),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.99),\\n\"\n                       + \"APPROX_QUANTILE(m1 * 2, 0.97),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.99) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.999) FILTER(WHERE dim1 <> 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.999) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(cnt, 0.5)\\n\"\n                       + \"FROM foo\";\n\n    \r\n    final List<Object[]> results = sqlLifecycle.runSimple(sql, QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            1.0,\n            3.0,\n            5.880000114440918,\n            5.940000057220459,\n            11.640000343322754,\n            6.0,\n            4.994999885559082,\n            6.0,\n            1.0\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    \r\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(CalciteTests.DATASOURCE1)\n              .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n              .granularity(Granularities.ALL)\n              .virtualColumns(\n                  new ExpressionVirtualColumn(\n                      \"v0\",\n                      \"(\\\"m1\\\" * 2)\",\n                      ValueType.FLOAT,\n                      TestExprMacroTable.INSTANCE\n                  )\n              )\n              .aggregators(ImmutableList.of(\n                  new ApproximateHistogramAggregatorFactory(\"a0:agg\", \"m1\", null, null, null, null),\n                  new ApproximateHistogramAggregatorFactory(\"a2:agg\", \"m1\", 200, null, null, null),\n                  new ApproximateHistogramAggregatorFactory(\"a4:agg\", \"v0\", null, null, null, null),\n                  new FilteredAggregatorFactory(\n                      new ApproximateHistogramAggregatorFactory(\"a5:agg\", \"m1\", null, null, null, null),\n                      new SelectorDimFilter(\"dim1\", \"abc\", null)\n                  ),\n                  new FilteredAggregatorFactory(\n                      new ApproximateHistogramAggregatorFactory(\"a6:agg\", \"m1\", null, null, null, null),\n                      new NotDimFilter(new SelectorDimFilter(\"dim1\", \"abc\", null))\n                  ),\n                  new ApproximateHistogramAggregatorFactory(\"a8:agg\", \"cnt\", null, null, null, null)\n              ))\n              .postAggregators(\n                  new QuantilePostAggregator(\"a0\", \"a0:agg\", 0.01f),\n                  new QuantilePostAggregator(\"a1\", \"a0:agg\", 0.50f),\n                  new QuantilePostAggregator(\"a2\", \"a2:agg\", 0.98f),\n                  new QuantilePostAggregator(\"a3\", \"a0:agg\", 0.99f),\n                  new QuantilePostAggregator(\"a4\", \"a4:agg\", 0.97f),\n                  new QuantilePostAggregator(\"a5\", \"a5:agg\", 0.99f),\n                  new QuantilePostAggregator(\"a6\", \"a6:agg\", 0.999f),\n                  new QuantilePostAggregator(\"a7\", \"a5:agg\", 0.999f),\n                  new QuantilePostAggregator(\"a8\", \"a8:agg\", 0.50f)\n              )\n              .context(ImmutableMap.of(\"skipEmptyBuckets\", true, PlannerContext.CTX_SQL_QUERY_ID, \"dummy\"))\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","date":"2019-03-12 02:37:58","endLine":270,"groupId":"8957","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testQuantileOnFloatAndLongs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/7b/a5a5c533fbd2e3b91f923774d11e676964e247.src","preCode":"  public void testQuantileOnFloatAndLongs() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n\n    final String sql = \"SELECT\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.01),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.5, 50),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.98, 200),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.99),\\n\"\n                       + \"APPROX_QUANTILE(m1 * 2, 0.97),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.99) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.999) FILTER(WHERE dim1 <> 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.999) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(cnt, 0.5)\\n\"\n                       + \"FROM foo\";\n\n    \r\n    final List<Object[]> results = sqlLifecycle.runSimple(sql, QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            1.0,\n            3.0,\n            5.880000114440918,\n            5.940000057220459,\n            11.640000343322754,\n            6.0,\n            4.994999885559082,\n            6.0,\n            1.0\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    \r\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(CalciteTests.DATASOURCE1)\n              .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n              .granularity(Granularities.ALL)\n              .virtualColumns(\n                  new ExpressionVirtualColumn(\n                      \"a4:v\",\n                      \"(\\\"m1\\\" * 2)\",\n                      ValueType.FLOAT,\n                      TestExprMacroTable.INSTANCE\n                  )\n              )\n              .aggregators(ImmutableList.of(\n                  new ApproximateHistogramAggregatorFactory(\"a0:agg\", \"m1\", null, null, null, null),\n                  new ApproximateHistogramAggregatorFactory(\"a2:agg\", \"m1\", 200, null, null, null),\n                  new ApproximateHistogramAggregatorFactory(\"a4:agg\", \"a4:v\", null, null, null, null),\n                  new FilteredAggregatorFactory(\n                      new ApproximateHistogramAggregatorFactory(\"a5:agg\", \"m1\", null, null, null, null),\n                      new SelectorDimFilter(\"dim1\", \"abc\", null)\n                  ),\n                  new FilteredAggregatorFactory(\n                      new ApproximateHistogramAggregatorFactory(\"a6:agg\", \"m1\", null, null, null, null),\n                      new NotDimFilter(new SelectorDimFilter(\"dim1\", \"abc\", null))\n                  ),\n                  new ApproximateHistogramAggregatorFactory(\"a8:agg\", \"cnt\", null, null, null, null)\n              ))\n              .postAggregators(\n                  new QuantilePostAggregator(\"a0\", \"a0:agg\", 0.01f),\n                  new QuantilePostAggregator(\"a1\", \"a0:agg\", 0.50f),\n                  new QuantilePostAggregator(\"a2\", \"a2:agg\", 0.98f),\n                  new QuantilePostAggregator(\"a3\", \"a0:agg\", 0.99f),\n                  new QuantilePostAggregator(\"a4\", \"a4:agg\", 0.97f),\n                  new QuantilePostAggregator(\"a5\", \"a5:agg\", 0.99f),\n                  new QuantilePostAggregator(\"a6\", \"a6:agg\", 0.999f),\n                  new QuantilePostAggregator(\"a7\", \"a5:agg\", 0.999f),\n                  new QuantilePostAggregator(\"a8\", \"a8:agg\", 0.50f)\n              )\n              .context(ImmutableMap.of(\"skipEmptyBuckets\", true, PlannerContext.CTX_SQL_QUERY_ID, \"dummy\"))\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","realPath":"extensions-core/histogram/src/test/java/org/apache/druid/query/aggregation/histogram/sql/QuantileSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":191,"status":"M"},{"authorDate":"2019-03-12 02:37:58","commitOrder":4,"curCode":"  public void testQuantileOnFloatAndLongs() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.01, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.5, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.98, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.99, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1 * 2, 0.97, 40, 0.0, 20.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.99, 20, 0.0, 10.0) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.999, 20, 0.0, 10.0) FILTER(WHERE dim1 <> 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.999, 20, 0.0, 10.0) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(cnt, 0.5, 20, 0.0, 10.0)\\n\"\n                       + \"FROM foo\";\n\n    \r\n    final List<Object[]> results = sqlLifecycle.runSimple(sql, QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            1.0299999713897705,\n            3.5,\n            6.440000057220459,\n            6.470000267028809,\n            12.40999984741211,\n            6.494999885559082,\n            5.497499942779541,\n            6.499499797821045,\n            1.25\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Query actual = Iterables.getOnlyElement(queryLogHook.getRecordedQueries());\n    Query expected = Druids.newTimeseriesQueryBuilder()\n                           .dataSource(CalciteTests.DATASOURCE1)\n                           .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n                           .granularity(Granularities.ALL)\n                           .virtualColumns(\n                               new ExpressionVirtualColumn(\n                                   \"v0\",\n                                   \"(\\\"m1\\\" * 2)\",\n                                   ValueType.FLOAT,\n                                   TestExprMacroTable.INSTANCE\n                               )\n                           )\n                           .aggregators(ImmutableList.of(\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a0:agg\", \"m1\", 20, 0.0d, 10.0d, FixedBucketsHistogram.OutlierHandlingMode.IGNORE\n                               ),\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a4:agg\", \"v0\", 40, 0.0d, 20.0d, FixedBucketsHistogram.OutlierHandlingMode.IGNORE\n                               ),\n                               new FilteredAggregatorFactory(\n                                   new FixedBucketsHistogramAggregatorFactory(\n                                       \"a5:agg\", \"m1\", 20, 0.0d, 10.0d, FixedBucketsHistogram.OutlierHandlingMode.IGNORE\n                                   ),\n                                   new SelectorDimFilter(\"dim1\", \"abc\", null)\n                               ),\n                               new FilteredAggregatorFactory(\n                                   new FixedBucketsHistogramAggregatorFactory(\n                                       \"a6:agg\", \"m1\", 20, 0.0d, 10.0d, FixedBucketsHistogram.OutlierHandlingMode.IGNORE\n                                   ),\n                                   new NotDimFilter(new SelectorDimFilter(\"dim1\", \"abc\", null))\n                               ),\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a8:agg\", \"cnt\", 20, 0.0d, 10.0d, FixedBucketsHistogram.OutlierHandlingMode.IGNORE\n                               )\n                           ))\n                           .postAggregators(\n                               new QuantilePostAggregator(\"a0\", \"a0:agg\", 0.01f),\n                               new QuantilePostAggregator(\"a1\", \"a0:agg\", 0.50f),\n                               new QuantilePostAggregator(\"a2\", \"a0:agg\", 0.98f),\n                               new QuantilePostAggregator(\"a3\", \"a0:agg\", 0.99f),\n                               new QuantilePostAggregator(\"a4\", \"a4:agg\", 0.97f),\n                               new QuantilePostAggregator(\"a5\", \"a5:agg\", 0.99f),\n                               new QuantilePostAggregator(\"a6\", \"a6:agg\", 0.999f),\n                               new QuantilePostAggregator(\"a7\", \"a5:agg\", 0.999f),\n                               new QuantilePostAggregator(\"a8\", \"a8:agg\", 0.50f)\n                           )\n                           .context(ImmutableMap.of(\"skipEmptyBuckets\", true, PlannerContext.CTX_SQL_QUERY_ID, \"dummy\"))\n                           .build();\n\n    \r\n    Assert.assertEquals(\n        expected,\n        actual\n    );\n  }\n","date":"2019-03-12 02:37:58","endLine":282,"groupId":"14120","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testQuantileOnFloatAndLongs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/c8/f6b3ebafe9b76288e26f7efa8b7d4685d21210.src","preCode":"  public void testQuantileOnFloatAndLongs() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.01, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.5, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.98, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.99, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1 * 2, 0.97, 40, 0.0, 20.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.99, 20, 0.0, 10.0) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.999, 20, 0.0, 10.0) FILTER(WHERE dim1 <> 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.999, 20, 0.0, 10.0) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(cnt, 0.5, 20, 0.0, 10.0)\\n\"\n                       + \"FROM foo\";\n\n    \r\n    final List<Object[]> results = sqlLifecycle.runSimple(sql, QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            1.0299999713897705,\n            3.5,\n            6.440000057220459,\n            6.470000267028809,\n            12.40999984741211,\n            6.494999885559082,\n            5.497499942779541,\n            6.499499797821045,\n            1.25\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Query actual = Iterables.getOnlyElement(queryLogHook.getRecordedQueries());\n    Query expected = Druids.newTimeseriesQueryBuilder()\n                           .dataSource(CalciteTests.DATASOURCE1)\n                           .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n                           .granularity(Granularities.ALL)\n                           .virtualColumns(\n                               new ExpressionVirtualColumn(\n                                   \"a4:v\",\n                                   \"(\\\"m1\\\" * 2)\",\n                                   ValueType.FLOAT,\n                                   TestExprMacroTable.INSTANCE\n                               )\n                           )\n                           .aggregators(ImmutableList.of(\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a0:agg\", \"m1\", 20, 0.0d, 10.0d, FixedBucketsHistogram.OutlierHandlingMode.IGNORE\n                               ),\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a4:agg\", \"a4:v\", 40, 0.0d, 20.0d, FixedBucketsHistogram.OutlierHandlingMode.IGNORE\n                               ),\n                               new FilteredAggregatorFactory(\n                                   new FixedBucketsHistogramAggregatorFactory(\n                                       \"a5:agg\", \"m1\", 20, 0.0d, 10.0d, FixedBucketsHistogram.OutlierHandlingMode.IGNORE\n                                   ),\n                                   new SelectorDimFilter(\"dim1\", \"abc\", null)\n                               ),\n                               new FilteredAggregatorFactory(\n                                   new FixedBucketsHistogramAggregatorFactory(\n                                       \"a6:agg\", \"m1\", 20, 0.0d, 10.0d, FixedBucketsHistogram.OutlierHandlingMode.IGNORE\n                                   ),\n                                   new NotDimFilter(new SelectorDimFilter(\"dim1\", \"abc\", null))\n                               ),\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a8:agg\", \"cnt\", 20, 0.0d, 10.0d, FixedBucketsHistogram.OutlierHandlingMode.IGNORE\n                               )\n                           ))\n                           .postAggregators(\n                               new QuantilePostAggregator(\"a0\", \"a0:agg\", 0.01f),\n                               new QuantilePostAggregator(\"a1\", \"a0:agg\", 0.50f),\n                               new QuantilePostAggregator(\"a2\", \"a0:agg\", 0.98f),\n                               new QuantilePostAggregator(\"a3\", \"a0:agg\", 0.99f),\n                               new QuantilePostAggregator(\"a4\", \"a4:agg\", 0.97f),\n                               new QuantilePostAggregator(\"a5\", \"a5:agg\", 0.99f),\n                               new QuantilePostAggregator(\"a6\", \"a6:agg\", 0.999f),\n                               new QuantilePostAggregator(\"a7\", \"a5:agg\", 0.999f),\n                               new QuantilePostAggregator(\"a8\", \"a8:agg\", 0.50f)\n                           )\n                           .context(ImmutableMap.of(\"skipEmptyBuckets\", true, PlannerContext.CTX_SQL_QUERY_ID, \"dummy\"))\n                           .build();\n\n    \r\n    Assert.assertEquals(\n        expected,\n        actual\n    );\n  }\n","realPath":"extensions-core/histogram/src/test/java/org/apache/druid/query/aggregation/histogram/sql/FixedBucketsHistogramQuantileSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":192,"status":"M"}],"commitId":"d7ba19d477732578fc310831ed28365b36332752","commitMessage":"@@@sql.  filters.  and virtual columns  (#6902)\n\n* refactor sql planning to re-use expression virtual columns when possible when constructing a DruidQuery.  allowing virtual columns to be defined in filter expressions.  and making resulting native druid queries more concise. also minor refactor of built-in sql aggregators to maximize code re-use\n\n* fix it\n\n* fix it in the right place\n\n* fixup for base64 stuff\n\n* fixup tests\n\n* fix merge conflict on import order\n\n* fixup\n\n* fix imports\n\n* fix tests\n\n* review comments\n\n* refactor\n\n* re-arrange\n\n* better javadoc\n\n* fixup merge\n\n* fixup tests\n\n* fix accidental changes\n","date":"2019-03-12 02:37:58","modifiedFileCount":"33","status":"M","submitter":"Clint Wylie"},{"authorTime":"2019-06-22 09:00:19","codes":[{"authorDate":"2019-06-22 09:00:19","commitOrder":5,"curCode":"  public void testQuantileOnFloatAndLongs() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n\n    final String sql = \"SELECT\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.01),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.5, 50),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.98, 200),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.99),\\n\"\n                       + \"APPROX_QUANTILE(m1 * 2, 0.97),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.99) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.999) FILTER(WHERE dim1 <> 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.999) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(cnt, 0.5)\\n\"\n                       + \"FROM foo\";\n\n    \r\n    final List<Object[]> results = sqlLifecycle.runSimple(sql, QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            1.0,\n            3.0,\n            5.880000114440918,\n            5.940000057220459,\n            11.640000343322754,\n            6.0,\n            4.994999885559082,\n            6.0,\n            1.0\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    \r\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(CalciteTests.DATASOURCE1)\n              .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n              .granularity(Granularities.ALL)\n              .virtualColumns(\n                  new ExpressionVirtualColumn(\n                      \"v0\",\n                      \"(\\\"m1\\\" * 2)\",\n                      ValueType.FLOAT,\n                      TestExprMacroTable.INSTANCE\n                  )\n              )\n              .aggregators(ImmutableList.of(\n                  new ApproximateHistogramAggregatorFactory(\"a0:agg\", \"m1\", null, null, null, null, false),\n                  new ApproximateHistogramAggregatorFactory(\"a2:agg\", \"m1\", 200, null, null, null, false),\n                  new ApproximateHistogramAggregatorFactory(\"a4:agg\", \"v0\", null, null, null, null, false),\n                  new FilteredAggregatorFactory(\n                      new ApproximateHistogramAggregatorFactory(\"a5:agg\", \"m1\", null, null, null, null, false),\n                      new SelectorDimFilter(\"dim1\", \"abc\", null)\n                  ),\n                  new FilteredAggregatorFactory(\n                      new ApproximateHistogramAggregatorFactory(\"a6:agg\", \"m1\", null, null, null, null, false),\n                      new NotDimFilter(new SelectorDimFilter(\"dim1\", \"abc\", null))\n                  ),\n                  new ApproximateHistogramAggregatorFactory(\"a8:agg\", \"cnt\", null, null, null, null, false)\n              ))\n              .postAggregators(\n                  new QuantilePostAggregator(\"a0\", \"a0:agg\", 0.01f),\n                  new QuantilePostAggregator(\"a1\", \"a0:agg\", 0.50f),\n                  new QuantilePostAggregator(\"a2\", \"a2:agg\", 0.98f),\n                  new QuantilePostAggregator(\"a3\", \"a0:agg\", 0.99f),\n                  new QuantilePostAggregator(\"a4\", \"a4:agg\", 0.97f),\n                  new QuantilePostAggregator(\"a5\", \"a5:agg\", 0.99f),\n                  new QuantilePostAggregator(\"a6\", \"a6:agg\", 0.999f),\n                  new QuantilePostAggregator(\"a7\", \"a5:agg\", 0.999f),\n                  new QuantilePostAggregator(\"a8\", \"a8:agg\", 0.50f)\n              )\n              .context(ImmutableMap.of(\"skipEmptyBuckets\", true, PlannerContext.CTX_SQL_QUERY_ID, \"dummy\"))\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","date":"2019-06-22 09:00:19","endLine":271,"groupId":"8957","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testQuantileOnFloatAndLongs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/30/f6474d5ae7c92e67d54fbc5ea4888bb92fce3b.src","preCode":"  public void testQuantileOnFloatAndLongs() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n\n    final String sql = \"SELECT\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.01),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.5, 50),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.98, 200),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.99),\\n\"\n                       + \"APPROX_QUANTILE(m1 * 2, 0.97),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.99) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.999) FILTER(WHERE dim1 <> 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.999) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(cnt, 0.5)\\n\"\n                       + \"FROM foo\";\n\n    \r\n    final List<Object[]> results = sqlLifecycle.runSimple(sql, QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            1.0,\n            3.0,\n            5.880000114440918,\n            5.940000057220459,\n            11.640000343322754,\n            6.0,\n            4.994999885559082,\n            6.0,\n            1.0\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    \r\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(CalciteTests.DATASOURCE1)\n              .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n              .granularity(Granularities.ALL)\n              .virtualColumns(\n                  new ExpressionVirtualColumn(\n                      \"v0\",\n                      \"(\\\"m1\\\" * 2)\",\n                      ValueType.FLOAT,\n                      TestExprMacroTable.INSTANCE\n                  )\n              )\n              .aggregators(ImmutableList.of(\n                  new ApproximateHistogramAggregatorFactory(\"a0:agg\", \"m1\", null, null, null, null),\n                  new ApproximateHistogramAggregatorFactory(\"a2:agg\", \"m1\", 200, null, null, null),\n                  new ApproximateHistogramAggregatorFactory(\"a4:agg\", \"v0\", null, null, null, null),\n                  new FilteredAggregatorFactory(\n                      new ApproximateHistogramAggregatorFactory(\"a5:agg\", \"m1\", null, null, null, null),\n                      new SelectorDimFilter(\"dim1\", \"abc\", null)\n                  ),\n                  new FilteredAggregatorFactory(\n                      new ApproximateHistogramAggregatorFactory(\"a6:agg\", \"m1\", null, null, null, null),\n                      new NotDimFilter(new SelectorDimFilter(\"dim1\", \"abc\", null))\n                  ),\n                  new ApproximateHistogramAggregatorFactory(\"a8:agg\", \"cnt\", null, null, null, null)\n              ))\n              .postAggregators(\n                  new QuantilePostAggregator(\"a0\", \"a0:agg\", 0.01f),\n                  new QuantilePostAggregator(\"a1\", \"a0:agg\", 0.50f),\n                  new QuantilePostAggregator(\"a2\", \"a2:agg\", 0.98f),\n                  new QuantilePostAggregator(\"a3\", \"a0:agg\", 0.99f),\n                  new QuantilePostAggregator(\"a4\", \"a4:agg\", 0.97f),\n                  new QuantilePostAggregator(\"a5\", \"a5:agg\", 0.99f),\n                  new QuantilePostAggregator(\"a6\", \"a6:agg\", 0.999f),\n                  new QuantilePostAggregator(\"a7\", \"a5:agg\", 0.999f),\n                  new QuantilePostAggregator(\"a8\", \"a8:agg\", 0.50f)\n              )\n              .context(ImmutableMap.of(\"skipEmptyBuckets\", true, PlannerContext.CTX_SQL_QUERY_ID, \"dummy\"))\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","realPath":"extensions-core/histogram/src/test/java/org/apache/druid/query/aggregation/histogram/sql/QuantileSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":192,"status":"M"},{"authorDate":"2019-06-22 09:00:19","commitOrder":5,"curCode":"  public void testQuantileOnFloatAndLongs() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.01, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.5, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.98, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.99, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1 * 2, 0.97, 40, 0.0, 20.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.99, 20, 0.0, 10.0) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.999, 20, 0.0, 10.0) FILTER(WHERE dim1 <> 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.999, 20, 0.0, 10.0) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(cnt, 0.5, 20, 0.0, 10.0)\\n\"\n                       + \"FROM foo\";\n\n    \r\n    final List<Object[]> results = sqlLifecycle.runSimple(sql, QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            1.0299999713897705,\n            3.5,\n            6.440000057220459,\n            6.470000267028809,\n            12.40999984741211,\n            6.494999885559082,\n            5.497499942779541,\n            6.499499797821045,\n            1.25\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Query actual = Iterables.getOnlyElement(queryLogHook.getRecordedQueries());\n    Query expected = Druids.newTimeseriesQueryBuilder()\n                           .dataSource(CalciteTests.DATASOURCE1)\n                           .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n                           .granularity(Granularities.ALL)\n                           .virtualColumns(\n                               new ExpressionVirtualColumn(\n                                   \"v0\",\n                                   \"(\\\"m1\\\" * 2)\",\n                                   ValueType.FLOAT,\n                                   TestExprMacroTable.INSTANCE\n                               )\n                           )\n                           .aggregators(ImmutableList.of(\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a0:agg\",\n                                   \"m1\",\n                                   20,\n                                   0.0d,\n                                   10.0d,\n                                   FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                   false\n                               ),\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a4:agg\",\n                                   \"v0\",\n                                   40,\n                                   0.0d,\n                                   20.0d,\n                                   FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                   false\n                               ),\n                               new FilteredAggregatorFactory(\n                                   new FixedBucketsHistogramAggregatorFactory(\n                                       \"a5:agg\",\n                                       \"m1\",\n                                       20,\n                                       0.0d,\n                                       10.0d,\n                                       FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                       false\n                                   ),\n                                   new SelectorDimFilter(\"dim1\", \"abc\", null)\n                               ),\n                               new FilteredAggregatorFactory(\n                                   new FixedBucketsHistogramAggregatorFactory(\n                                       \"a6:agg\",\n                                       \"m1\",\n                                       20,\n                                       0.0d,\n                                       10.0d,\n                                       FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                       false\n                                   ),\n                                   new NotDimFilter(new SelectorDimFilter(\"dim1\", \"abc\", null))\n                               ),\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a8:agg\",\n                                   \"cnt\",\n                                   20,\n                                   0.0d,\n                                   10.0d,\n                                   FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                   false\n                               )\n                           ))\n                           .postAggregators(\n                               new QuantilePostAggregator(\"a0\", \"a0:agg\", 0.01f),\n                               new QuantilePostAggregator(\"a1\", \"a0:agg\", 0.50f),\n                               new QuantilePostAggregator(\"a2\", \"a0:agg\", 0.98f),\n                               new QuantilePostAggregator(\"a3\", \"a0:agg\", 0.99f),\n                               new QuantilePostAggregator(\"a4\", \"a4:agg\", 0.97f),\n                               new QuantilePostAggregator(\"a5\", \"a5:agg\", 0.99f),\n                               new QuantilePostAggregator(\"a6\", \"a6:agg\", 0.999f),\n                               new QuantilePostAggregator(\"a7\", \"a5:agg\", 0.999f),\n                               new QuantilePostAggregator(\"a8\", \"a8:agg\", 0.50f)\n                           )\n                           .context(ImmutableMap.of(\"skipEmptyBuckets\", true, PlannerContext.CTX_SQL_QUERY_ID, \"dummy\"))\n                           .build();\n\n    \r\n    Assert.assertEquals(\n        expected,\n        actual\n    );\n  }\n","date":"2019-06-22 09:00:19","endLine":313,"groupId":"14120","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testQuantileOnFloatAndLongs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/86/e87bf0d475cdd6786a6f9ab7a7f169d883700d.src","preCode":"  public void testQuantileOnFloatAndLongs() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.01, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.5, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.98, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.99, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1 * 2, 0.97, 40, 0.0, 20.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.99, 20, 0.0, 10.0) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.999, 20, 0.0, 10.0) FILTER(WHERE dim1 <> 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.999, 20, 0.0, 10.0) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(cnt, 0.5, 20, 0.0, 10.0)\\n\"\n                       + \"FROM foo\";\n\n    \r\n    final List<Object[]> results = sqlLifecycle.runSimple(sql, QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            1.0299999713897705,\n            3.5,\n            6.440000057220459,\n            6.470000267028809,\n            12.40999984741211,\n            6.494999885559082,\n            5.497499942779541,\n            6.499499797821045,\n            1.25\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Query actual = Iterables.getOnlyElement(queryLogHook.getRecordedQueries());\n    Query expected = Druids.newTimeseriesQueryBuilder()\n                           .dataSource(CalciteTests.DATASOURCE1)\n                           .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n                           .granularity(Granularities.ALL)\n                           .virtualColumns(\n                               new ExpressionVirtualColumn(\n                                   \"v0\",\n                                   \"(\\\"m1\\\" * 2)\",\n                                   ValueType.FLOAT,\n                                   TestExprMacroTable.INSTANCE\n                               )\n                           )\n                           .aggregators(ImmutableList.of(\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a0:agg\", \"m1\", 20, 0.0d, 10.0d, FixedBucketsHistogram.OutlierHandlingMode.IGNORE\n                               ),\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a4:agg\", \"v0\", 40, 0.0d, 20.0d, FixedBucketsHistogram.OutlierHandlingMode.IGNORE\n                               ),\n                               new FilteredAggregatorFactory(\n                                   new FixedBucketsHistogramAggregatorFactory(\n                                       \"a5:agg\", \"m1\", 20, 0.0d, 10.0d, FixedBucketsHistogram.OutlierHandlingMode.IGNORE\n                                   ),\n                                   new SelectorDimFilter(\"dim1\", \"abc\", null)\n                               ),\n                               new FilteredAggregatorFactory(\n                                   new FixedBucketsHistogramAggregatorFactory(\n                                       \"a6:agg\", \"m1\", 20, 0.0d, 10.0d, FixedBucketsHistogram.OutlierHandlingMode.IGNORE\n                                   ),\n                                   new NotDimFilter(new SelectorDimFilter(\"dim1\", \"abc\", null))\n                               ),\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a8:agg\", \"cnt\", 20, 0.0d, 10.0d, FixedBucketsHistogram.OutlierHandlingMode.IGNORE\n                               )\n                           ))\n                           .postAggregators(\n                               new QuantilePostAggregator(\"a0\", \"a0:agg\", 0.01f),\n                               new QuantilePostAggregator(\"a1\", \"a0:agg\", 0.50f),\n                               new QuantilePostAggregator(\"a2\", \"a0:agg\", 0.98f),\n                               new QuantilePostAggregator(\"a3\", \"a0:agg\", 0.99f),\n                               new QuantilePostAggregator(\"a4\", \"a4:agg\", 0.97f),\n                               new QuantilePostAggregator(\"a5\", \"a5:agg\", 0.99f),\n                               new QuantilePostAggregator(\"a6\", \"a6:agg\", 0.999f),\n                               new QuantilePostAggregator(\"a7\", \"a5:agg\", 0.999f),\n                               new QuantilePostAggregator(\"a8\", \"a8:agg\", 0.50f)\n                           )\n                           .context(ImmutableMap.of(\"skipEmptyBuckets\", true, PlannerContext.CTX_SQL_QUERY_ID, \"dummy\"))\n                           .build();\n\n    \r\n    Assert.assertEquals(\n        expected,\n        actual\n    );\n  }\n","realPath":"extensions-core/histogram/src/test/java/org/apache/druid/query/aggregation/histogram/sql/FixedBucketsHistogramQuantileSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":193,"status":"M"}],"commitId":"35601bb7a024213a4c8016b0d865984f84257cf4","commitMessage":"@@@Add finalizeAsBase64Binary option to FixedBucketsHistogramAggregatorFactory (#7784)\n\n* Add finalizeAsBase64Binary option to FixedBucketsHistogramAggregatorFactory\n\n* Add finalizeAsBase64Binary option to ApproximateHistogramFactory\n\n* Update approx histogram doc\n","date":"2019-06-22 09:00:19","modifiedFileCount":"13","status":"M","submitter":"Jonathan Wei"},{"authorTime":"2020-02-20 05:09:20","codes":[{"authorDate":"2020-02-20 05:09:20","commitOrder":6,"curCode":"  public void testQuantileOnFloatAndLongs() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n\n    final String sql = \"SELECT\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.01),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.5, 50),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.98, 200),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.99),\\n\"\n                       + \"APPROX_QUANTILE(m1 * 2, 0.97),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.99) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.999) FILTER(WHERE dim1 <> 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.999) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(cnt, 0.5)\\n\"\n                       + \"FROM foo\";\n\n    \r\n    final List<Object[]> results = sqlLifecycle.runSimple(\n        sql,\n        QUERY_CONTEXT_DEFAULT,\n        DEFAULT_PARAMETERS,\n        authenticationResult\n    ).toList();\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            1.0,\n            3.0,\n            5.880000114440918,\n            5.940000057220459,\n            11.640000343322754,\n            6.0,\n            4.994999885559082,\n            6.0,\n            1.0\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    \r\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(CalciteTests.DATASOURCE1)\n              .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n              .granularity(Granularities.ALL)\n              .virtualColumns(\n                  new ExpressionVirtualColumn(\n                      \"v0\",\n                      \"(\\\"m1\\\" * 2)\",\n                      ValueType.FLOAT,\n                      TestExprMacroTable.INSTANCE\n                  )\n              )\n              .aggregators(ImmutableList.of(\n                  new ApproximateHistogramAggregatorFactory(\"a0:agg\", \"m1\", null, null, null, null, false),\n                  new ApproximateHistogramAggregatorFactory(\"a2:agg\", \"m1\", 200, null, null, null, false),\n                  new ApproximateHistogramAggregatorFactory(\"a4:agg\", \"v0\", null, null, null, null, false),\n                  new FilteredAggregatorFactory(\n                      new ApproximateHistogramAggregatorFactory(\"a5:agg\", \"m1\", null, null, null, null, false),\n                      new SelectorDimFilter(\"dim1\", \"abc\", null)\n                  ),\n                  new FilteredAggregatorFactory(\n                      new ApproximateHistogramAggregatorFactory(\"a6:agg\", \"m1\", null, null, null, null, false),\n                      new NotDimFilter(new SelectorDimFilter(\"dim1\", \"abc\", null))\n                  ),\n                  new ApproximateHistogramAggregatorFactory(\"a8:agg\", \"cnt\", null, null, null, null, false)\n              ))\n              .postAggregators(\n                  new QuantilePostAggregator(\"a0\", \"a0:agg\", 0.01f),\n                  new QuantilePostAggregator(\"a1\", \"a0:agg\", 0.50f),\n                  new QuantilePostAggregator(\"a2\", \"a2:agg\", 0.98f),\n                  new QuantilePostAggregator(\"a3\", \"a0:agg\", 0.99f),\n                  new QuantilePostAggregator(\"a4\", \"a4:agg\", 0.97f),\n                  new QuantilePostAggregator(\"a5\", \"a5:agg\", 0.99f),\n                  new QuantilePostAggregator(\"a6\", \"a6:agg\", 0.999f),\n                  new QuantilePostAggregator(\"a7\", \"a5:agg\", 0.999f),\n                  new QuantilePostAggregator(\"a8\", \"a8:agg\", 0.50f)\n              )\n              .context(ImmutableMap.of(\"skipEmptyBuckets\", true, PlannerContext.CTX_SQL_QUERY_ID, \"dummy\"))\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","date":"2020-02-20 05:09:20","endLine":276,"groupId":"8957","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testQuantileOnFloatAndLongs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/0d/ed89c4360824b22a0c9212994cacfb80ce8eba.src","preCode":"  public void testQuantileOnFloatAndLongs() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n\n    final String sql = \"SELECT\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.01),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.5, 50),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.98, 200),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.99),\\n\"\n                       + \"APPROX_QUANTILE(m1 * 2, 0.97),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.99) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.999) FILTER(WHERE dim1 <> 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.999) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(cnt, 0.5)\\n\"\n                       + \"FROM foo\";\n\n    \r\n    final List<Object[]> results = sqlLifecycle.runSimple(sql, QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            1.0,\n            3.0,\n            5.880000114440918,\n            5.940000057220459,\n            11.640000343322754,\n            6.0,\n            4.994999885559082,\n            6.0,\n            1.0\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    \r\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(CalciteTests.DATASOURCE1)\n              .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n              .granularity(Granularities.ALL)\n              .virtualColumns(\n                  new ExpressionVirtualColumn(\n                      \"v0\",\n                      \"(\\\"m1\\\" * 2)\",\n                      ValueType.FLOAT,\n                      TestExprMacroTable.INSTANCE\n                  )\n              )\n              .aggregators(ImmutableList.of(\n                  new ApproximateHistogramAggregatorFactory(\"a0:agg\", \"m1\", null, null, null, null, false),\n                  new ApproximateHistogramAggregatorFactory(\"a2:agg\", \"m1\", 200, null, null, null, false),\n                  new ApproximateHistogramAggregatorFactory(\"a4:agg\", \"v0\", null, null, null, null, false),\n                  new FilteredAggregatorFactory(\n                      new ApproximateHistogramAggregatorFactory(\"a5:agg\", \"m1\", null, null, null, null, false),\n                      new SelectorDimFilter(\"dim1\", \"abc\", null)\n                  ),\n                  new FilteredAggregatorFactory(\n                      new ApproximateHistogramAggregatorFactory(\"a6:agg\", \"m1\", null, null, null, null, false),\n                      new NotDimFilter(new SelectorDimFilter(\"dim1\", \"abc\", null))\n                  ),\n                  new ApproximateHistogramAggregatorFactory(\"a8:agg\", \"cnt\", null, null, null, null, false)\n              ))\n              .postAggregators(\n                  new QuantilePostAggregator(\"a0\", \"a0:agg\", 0.01f),\n                  new QuantilePostAggregator(\"a1\", \"a0:agg\", 0.50f),\n                  new QuantilePostAggregator(\"a2\", \"a2:agg\", 0.98f),\n                  new QuantilePostAggregator(\"a3\", \"a0:agg\", 0.99f),\n                  new QuantilePostAggregator(\"a4\", \"a4:agg\", 0.97f),\n                  new QuantilePostAggregator(\"a5\", \"a5:agg\", 0.99f),\n                  new QuantilePostAggregator(\"a6\", \"a6:agg\", 0.999f),\n                  new QuantilePostAggregator(\"a7\", \"a5:agg\", 0.999f),\n                  new QuantilePostAggregator(\"a8\", \"a8:agg\", 0.50f)\n              )\n              .context(ImmutableMap.of(\"skipEmptyBuckets\", true, PlannerContext.CTX_SQL_QUERY_ID, \"dummy\"))\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","realPath":"extensions-core/histogram/src/test/java/org/apache/druid/query/aggregation/histogram/sql/QuantileSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":192,"status":"M"},{"authorDate":"2020-02-20 05:09:20","commitOrder":6,"curCode":"  public void testQuantileOnFloatAndLongs() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.01, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.5, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.98, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.99, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1 * 2, 0.97, 40, 0.0, 20.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.99, 20, 0.0, 10.0) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.999, 20, 0.0, 10.0) FILTER(WHERE dim1 <> 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.999, 20, 0.0, 10.0) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(cnt, 0.5, 20, 0.0, 10.0)\\n\"\n                       + \"FROM foo\";\n\n    \r\n    final List<Object[]> results = sqlLifecycle.runSimple(\n        sql,\n        QUERY_CONTEXT_DEFAULT,\n        DEFAULT_PARAMETERS,\n        authenticationResult\n    ).toList();\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            1.0299999713897705,\n            3.5,\n            6.440000057220459,\n            6.470000267028809,\n            12.40999984741211,\n            6.494999885559082,\n            5.497499942779541,\n            6.499499797821045,\n            1.25\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Query actual = Iterables.getOnlyElement(queryLogHook.getRecordedQueries());\n    Query expected = Druids.newTimeseriesQueryBuilder()\n                           .dataSource(CalciteTests.DATASOURCE1)\n                           .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n                           .granularity(Granularities.ALL)\n                           .virtualColumns(\n                               new ExpressionVirtualColumn(\n                                   \"v0\",\n                                   \"(\\\"m1\\\" * 2)\",\n                                   ValueType.FLOAT,\n                                   TestExprMacroTable.INSTANCE\n                               )\n                           )\n                           .aggregators(ImmutableList.of(\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a0:agg\",\n                                   \"m1\",\n                                   20,\n                                   0.0d,\n                                   10.0d,\n                                   FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                   false\n                               ),\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a4:agg\",\n                                   \"v0\",\n                                   40,\n                                   0.0d,\n                                   20.0d,\n                                   FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                   false\n                               ),\n                               new FilteredAggregatorFactory(\n                                   new FixedBucketsHistogramAggregatorFactory(\n                                       \"a5:agg\",\n                                       \"m1\",\n                                       20,\n                                       0.0d,\n                                       10.0d,\n                                       FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                       false\n                                   ),\n                                   new SelectorDimFilter(\"dim1\", \"abc\", null)\n                               ),\n                               new FilteredAggregatorFactory(\n                                   new FixedBucketsHistogramAggregatorFactory(\n                                       \"a6:agg\",\n                                       \"m1\",\n                                       20,\n                                       0.0d,\n                                       10.0d,\n                                       FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                       false\n                                   ),\n                                   new NotDimFilter(new SelectorDimFilter(\"dim1\", \"abc\", null))\n                               ),\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a8:agg\",\n                                   \"cnt\",\n                                   20,\n                                   0.0d,\n                                   10.0d,\n                                   FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                   false\n                               )\n                           ))\n                           .postAggregators(\n                               new QuantilePostAggregator(\"a0\", \"a0:agg\", 0.01f),\n                               new QuantilePostAggregator(\"a1\", \"a0:agg\", 0.50f),\n                               new QuantilePostAggregator(\"a2\", \"a0:agg\", 0.98f),\n                               new QuantilePostAggregator(\"a3\", \"a0:agg\", 0.99f),\n                               new QuantilePostAggregator(\"a4\", \"a4:agg\", 0.97f),\n                               new QuantilePostAggregator(\"a5\", \"a5:agg\", 0.99f),\n                               new QuantilePostAggregator(\"a6\", \"a6:agg\", 0.999f),\n                               new QuantilePostAggregator(\"a7\", \"a5:agg\", 0.999f),\n                               new QuantilePostAggregator(\"a8\", \"a8:agg\", 0.50f)\n                           )\n                           .context(ImmutableMap.of(\"skipEmptyBuckets\", true, PlannerContext.CTX_SQL_QUERY_ID, \"dummy\"))\n                           .build();\n\n    \r\n    Assert.assertEquals(\n        expected,\n        actual\n    );\n  }\n","date":"2020-02-20 05:09:20","endLine":318,"groupId":"14120","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testQuantileOnFloatAndLongs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/24/651405bcbda12a3890a0f38009f835c7013c09.src","preCode":"  public void testQuantileOnFloatAndLongs() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.01, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.5, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.98, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.99, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1 * 2, 0.97, 40, 0.0, 20.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.99, 20, 0.0, 10.0) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.999, 20, 0.0, 10.0) FILTER(WHERE dim1 <> 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.999, 20, 0.0, 10.0) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(cnt, 0.5, 20, 0.0, 10.0)\\n\"\n                       + \"FROM foo\";\n\n    \r\n    final List<Object[]> results = sqlLifecycle.runSimple(sql, QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            1.0299999713897705,\n            3.5,\n            6.440000057220459,\n            6.470000267028809,\n            12.40999984741211,\n            6.494999885559082,\n            5.497499942779541,\n            6.499499797821045,\n            1.25\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Query actual = Iterables.getOnlyElement(queryLogHook.getRecordedQueries());\n    Query expected = Druids.newTimeseriesQueryBuilder()\n                           .dataSource(CalciteTests.DATASOURCE1)\n                           .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n                           .granularity(Granularities.ALL)\n                           .virtualColumns(\n                               new ExpressionVirtualColumn(\n                                   \"v0\",\n                                   \"(\\\"m1\\\" * 2)\",\n                                   ValueType.FLOAT,\n                                   TestExprMacroTable.INSTANCE\n                               )\n                           )\n                           .aggregators(ImmutableList.of(\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a0:agg\",\n                                   \"m1\",\n                                   20,\n                                   0.0d,\n                                   10.0d,\n                                   FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                   false\n                               ),\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a4:agg\",\n                                   \"v0\",\n                                   40,\n                                   0.0d,\n                                   20.0d,\n                                   FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                   false\n                               ),\n                               new FilteredAggregatorFactory(\n                                   new FixedBucketsHistogramAggregatorFactory(\n                                       \"a5:agg\",\n                                       \"m1\",\n                                       20,\n                                       0.0d,\n                                       10.0d,\n                                       FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                       false\n                                   ),\n                                   new SelectorDimFilter(\"dim1\", \"abc\", null)\n                               ),\n                               new FilteredAggregatorFactory(\n                                   new FixedBucketsHistogramAggregatorFactory(\n                                       \"a6:agg\",\n                                       \"m1\",\n                                       20,\n                                       0.0d,\n                                       10.0d,\n                                       FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                       false\n                                   ),\n                                   new NotDimFilter(new SelectorDimFilter(\"dim1\", \"abc\", null))\n                               ),\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a8:agg\",\n                                   \"cnt\",\n                                   20,\n                                   0.0d,\n                                   10.0d,\n                                   FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                   false\n                               )\n                           ))\n                           .postAggregators(\n                               new QuantilePostAggregator(\"a0\", \"a0:agg\", 0.01f),\n                               new QuantilePostAggregator(\"a1\", \"a0:agg\", 0.50f),\n                               new QuantilePostAggregator(\"a2\", \"a0:agg\", 0.98f),\n                               new QuantilePostAggregator(\"a3\", \"a0:agg\", 0.99f),\n                               new QuantilePostAggregator(\"a4\", \"a4:agg\", 0.97f),\n                               new QuantilePostAggregator(\"a5\", \"a5:agg\", 0.99f),\n                               new QuantilePostAggregator(\"a6\", \"a6:agg\", 0.999f),\n                               new QuantilePostAggregator(\"a7\", \"a5:agg\", 0.999f),\n                               new QuantilePostAggregator(\"a8\", \"a8:agg\", 0.50f)\n                           )\n                           .context(ImmutableMap.of(\"skipEmptyBuckets\", true, PlannerContext.CTX_SQL_QUERY_ID, \"dummy\"))\n                           .build();\n\n    \r\n    Assert.assertEquals(\n        expected,\n        actual\n    );\n  }\n","realPath":"extensions-core/histogram/src/test/java/org/apache/druid/query/aggregation/histogram/sql/FixedBucketsHistogramQuantileSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":193,"status":"M"}],"commitId":"b408a6d774e43e574bf8092584fae76d582cfd8f","commitMessage":"@@@sql support for dynamic parameters (#6974)\n\n* sql support for dynamic parameters\n\n* fixup\n\n* javadocs\n\n* fixup from merge\n\n* formatting\n\n* fixes\n\n* fix it\n\n* doc fix\n\n* remove druid fallback self-join parameterized test\n\n* unused imports\n\n* ignore test for now\n\n* fix imports\n\n* fixup\n\n* fix merge\n\n* merge fixup\n\n* fix test that cannot vectorize\n\n* fixup and more better\n\n* dependency thingo\n\n* fix docs\n\n* tweaks\n\n* fix docs\n\n* spelling\n\n* unused imports after merge\n\n* review stuffs\n\n* add comment\n\n* add ignore text\n\n* review stuffs\n","date":"2020-02-20 05:09:20","modifiedFileCount":"32","status":"M","submitter":"Clint Wylie"},{"authorTime":"2021-04-13 13:21:24","codes":[{"authorDate":"2021-04-13 13:21:24","commitOrder":7,"curCode":"  public void testQuantileOnFloatAndLongs() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = getSqlLifecycle();\n\n    final String sql = \"SELECT\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.01),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.5, 50),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.98, 200),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.99),\\n\"\n                       + \"APPROX_QUANTILE(m1 * 2, 0.97),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.99) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.999) FILTER(WHERE dim1 <> 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.999) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(cnt, 0.5)\\n\"\n                       + \"FROM foo\";\n\n    \r\n    final List<Object[]> results = sqlLifecycle.runSimple(\n        sql,\n        TIMESERIES_CONTEXT_DEFAULT,\n        DEFAULT_PARAMETERS,\n        AUTH_RESULT\n    ).toList();\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            1.0,\n            3.0,\n            5.880000114440918,\n            5.940000057220459,\n            11.640000343322754,\n            6.0,\n            4.994999885559082,\n            6.0,\n            1.0\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    \r\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(CalciteTests.DATASOURCE1)\n              .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n              .granularity(Granularities.ALL)\n              .virtualColumns(\n                  new ExpressionVirtualColumn(\n                      \"v0\",\n                      \"(\\\"m1\\\" * 2)\",\n                      ValueType.FLOAT,\n                      TestExprMacroTable.INSTANCE\n                  )\n              )\n              .aggregators(ImmutableList.of(\n                  new ApproximateHistogramAggregatorFactory(\"a0:agg\", \"m1\", null, null, null, null, false),\n                  new ApproximateHistogramAggregatorFactory(\"a2:agg\", \"m1\", 200, null, null, null, false),\n                  new ApproximateHistogramAggregatorFactory(\"a4:agg\", \"v0\", null, null, null, null, false),\n                  new FilteredAggregatorFactory(\n                      new ApproximateHistogramAggregatorFactory(\"a5:agg\", \"m1\", null, null, null, null, false),\n                      new SelectorDimFilter(\"dim1\", \"abc\", null)\n                  ),\n                  new FilteredAggregatorFactory(\n                      new ApproximateHistogramAggregatorFactory(\"a6:agg\", \"m1\", null, null, null, null, false),\n                      new NotDimFilter(new SelectorDimFilter(\"dim1\", \"abc\", null))\n                  ),\n                  new ApproximateHistogramAggregatorFactory(\"a8:agg\", \"cnt\", null, null, null, null, false)\n              ))\n              .postAggregators(\n                  new QuantilePostAggregator(\"a0\", \"a0:agg\", 0.01f),\n                  new QuantilePostAggregator(\"a1\", \"a0:agg\", 0.50f),\n                  new QuantilePostAggregator(\"a2\", \"a2:agg\", 0.98f),\n                  new QuantilePostAggregator(\"a3\", \"a0:agg\", 0.99f),\n                  new QuantilePostAggregator(\"a4\", \"a4:agg\", 0.97f),\n                  new QuantilePostAggregator(\"a5\", \"a5:agg\", 0.99f),\n                  new QuantilePostAggregator(\"a6\", \"a6:agg\", 0.999f),\n                  new QuantilePostAggregator(\"a7\", \"a5:agg\", 0.999f),\n                  new QuantilePostAggregator(\"a8\", \"a8:agg\", 0.50f)\n              )\n              .context(TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","date":"2021-04-13 13:21:24","endLine":247,"groupId":"8957","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testQuantileOnFloatAndLongs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/d5/e51c5640a3d4d77b3f76f0ec2f9e3f0ee2325a.src","preCode":"  public void testQuantileOnFloatAndLongs() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n\n    final String sql = \"SELECT\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.01),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.5, 50),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.98, 200),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.99),\\n\"\n                       + \"APPROX_QUANTILE(m1 * 2, 0.97),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.99) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.999) FILTER(WHERE dim1 <> 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.999) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(cnt, 0.5)\\n\"\n                       + \"FROM foo\";\n\n    \r\n    final List<Object[]> results = sqlLifecycle.runSimple(\n        sql,\n        QUERY_CONTEXT_DEFAULT,\n        DEFAULT_PARAMETERS,\n        authenticationResult\n    ).toList();\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            1.0,\n            3.0,\n            5.880000114440918,\n            5.940000057220459,\n            11.640000343322754,\n            6.0,\n            4.994999885559082,\n            6.0,\n            1.0\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    \r\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(CalciteTests.DATASOURCE1)\n              .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n              .granularity(Granularities.ALL)\n              .virtualColumns(\n                  new ExpressionVirtualColumn(\n                      \"v0\",\n                      \"(\\\"m1\\\" * 2)\",\n                      ValueType.FLOAT,\n                      TestExprMacroTable.INSTANCE\n                  )\n              )\n              .aggregators(ImmutableList.of(\n                  new ApproximateHistogramAggregatorFactory(\"a0:agg\", \"m1\", null, null, null, null, false),\n                  new ApproximateHistogramAggregatorFactory(\"a2:agg\", \"m1\", 200, null, null, null, false),\n                  new ApproximateHistogramAggregatorFactory(\"a4:agg\", \"v0\", null, null, null, null, false),\n                  new FilteredAggregatorFactory(\n                      new ApproximateHistogramAggregatorFactory(\"a5:agg\", \"m1\", null, null, null, null, false),\n                      new SelectorDimFilter(\"dim1\", \"abc\", null)\n                  ),\n                  new FilteredAggregatorFactory(\n                      new ApproximateHistogramAggregatorFactory(\"a6:agg\", \"m1\", null, null, null, null, false),\n                      new NotDimFilter(new SelectorDimFilter(\"dim1\", \"abc\", null))\n                  ),\n                  new ApproximateHistogramAggregatorFactory(\"a8:agg\", \"cnt\", null, null, null, null, false)\n              ))\n              .postAggregators(\n                  new QuantilePostAggregator(\"a0\", \"a0:agg\", 0.01f),\n                  new QuantilePostAggregator(\"a1\", \"a0:agg\", 0.50f),\n                  new QuantilePostAggregator(\"a2\", \"a2:agg\", 0.98f),\n                  new QuantilePostAggregator(\"a3\", \"a0:agg\", 0.99f),\n                  new QuantilePostAggregator(\"a4\", \"a4:agg\", 0.97f),\n                  new QuantilePostAggregator(\"a5\", \"a5:agg\", 0.99f),\n                  new QuantilePostAggregator(\"a6\", \"a6:agg\", 0.999f),\n                  new QuantilePostAggregator(\"a7\", \"a5:agg\", 0.999f),\n                  new QuantilePostAggregator(\"a8\", \"a8:agg\", 0.50f)\n              )\n              .context(ImmutableMap.of(\"skipEmptyBuckets\", true, PlannerContext.CTX_SQL_QUERY_ID, \"dummy\"))\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","realPath":"extensions-core/histogram/src/test/java/org/apache/druid/query/aggregation/histogram/sql/QuantileSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"M"},{"authorDate":"2021-04-13 13:21:24","commitOrder":7,"curCode":"  public void testQuantileOnFloatAndLongs() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = getSqlLifecycle();\n    final String sql = \"SELECT\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.01, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.5, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.98, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.99, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1 * 2, 0.97, 40, 0.0, 20.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.99, 20, 0.0, 10.0) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.999, 20, 0.0, 10.0) FILTER(WHERE dim1 <> 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.999, 20, 0.0, 10.0) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(cnt, 0.5, 20, 0.0, 10.0)\\n\"\n                       + \"FROM foo\";\n\n    \r\n    final List<Object[]> results = sqlLifecycle.runSimple(\n        sql,\n        TIMESERIES_CONTEXT_DEFAULT,\n        DEFAULT_PARAMETERS,\n        AUTH_RESULT\n    ).toList();\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            1.0299999713897705,\n            3.5,\n            6.440000057220459,\n            6.470000267028809,\n            12.40999984741211,\n            6.494999885559082,\n            5.497499942779541,\n            6.499499797821045,\n            1.25\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Query actual = Iterables.getOnlyElement(queryLogHook.getRecordedQueries());\n    Query expected = Druids.newTimeseriesQueryBuilder()\n                           .dataSource(CalciteTests.DATASOURCE1)\n                           .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n                           .granularity(Granularities.ALL)\n                           .virtualColumns(\n                               new ExpressionVirtualColumn(\n                                   \"v0\",\n                                   \"(\\\"m1\\\" * 2)\",\n                                   ValueType.FLOAT,\n                                   TestExprMacroTable.INSTANCE\n                               )\n                           )\n                           .aggregators(ImmutableList.of(\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a0:agg\",\n                                   \"m1\",\n                                   20,\n                                   0.0d,\n                                   10.0d,\n                                   FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                   false\n                               ),\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a4:agg\",\n                                   \"v0\",\n                                   40,\n                                   0.0d,\n                                   20.0d,\n                                   FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                   false\n                               ),\n                               new FilteredAggregatorFactory(\n                                   new FixedBucketsHistogramAggregatorFactory(\n                                       \"a5:agg\",\n                                       \"m1\",\n                                       20,\n                                       0.0d,\n                                       10.0d,\n                                       FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                       false\n                                   ),\n                                   new SelectorDimFilter(\"dim1\", \"abc\", null)\n                               ),\n                               new FilteredAggregatorFactory(\n                                   new FixedBucketsHistogramAggregatorFactory(\n                                       \"a6:agg\",\n                                       \"m1\",\n                                       20,\n                                       0.0d,\n                                       10.0d,\n                                       FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                       false\n                                   ),\n                                   new NotDimFilter(new SelectorDimFilter(\"dim1\", \"abc\", null))\n                               ),\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a8:agg\",\n                                   \"cnt\",\n                                   20,\n                                   0.0d,\n                                   10.0d,\n                                   FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                   false\n                               )\n                           ))\n                           .postAggregators(\n                               new QuantilePostAggregator(\"a0\", \"a0:agg\", 0.01f),\n                               new QuantilePostAggregator(\"a1\", \"a0:agg\", 0.50f),\n                               new QuantilePostAggregator(\"a2\", \"a0:agg\", 0.98f),\n                               new QuantilePostAggregator(\"a3\", \"a0:agg\", 0.99f),\n                               new QuantilePostAggregator(\"a4\", \"a4:agg\", 0.97f),\n                               new QuantilePostAggregator(\"a5\", \"a5:agg\", 0.99f),\n                               new QuantilePostAggregator(\"a6\", \"a6:agg\", 0.999f),\n                               new QuantilePostAggregator(\"a7\", \"a5:agg\", 0.999f),\n                               new QuantilePostAggregator(\"a8\", \"a8:agg\", 0.50f)\n                           )\n                           .context(TIMESERIES_CONTEXT_DEFAULT)\n                           .build();\n\n    \r\n    Assert.assertEquals(\n        expected,\n        actual\n    );\n  }\n","date":"2021-04-13 13:21:24","endLine":286,"groupId":"14120","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testQuantileOnFloatAndLongs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/dd/41d753716eda1a21621aae0a007aef86a28b76.src","preCode":"  public void testQuantileOnFloatAndLongs() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.01, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.5, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.98, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.99, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1 * 2, 0.97, 40, 0.0, 20.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.99, 20, 0.0, 10.0) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.999, 20, 0.0, 10.0) FILTER(WHERE dim1 <> 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.999, 20, 0.0, 10.0) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(cnt, 0.5, 20, 0.0, 10.0)\\n\"\n                       + \"FROM foo\";\n\n    \r\n    final List<Object[]> results = sqlLifecycle.runSimple(\n        sql,\n        QUERY_CONTEXT_DEFAULT,\n        DEFAULT_PARAMETERS,\n        authenticationResult\n    ).toList();\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            1.0299999713897705,\n            3.5,\n            6.440000057220459,\n            6.470000267028809,\n            12.40999984741211,\n            6.494999885559082,\n            5.497499942779541,\n            6.499499797821045,\n            1.25\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Query actual = Iterables.getOnlyElement(queryLogHook.getRecordedQueries());\n    Query expected = Druids.newTimeseriesQueryBuilder()\n                           .dataSource(CalciteTests.DATASOURCE1)\n                           .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n                           .granularity(Granularities.ALL)\n                           .virtualColumns(\n                               new ExpressionVirtualColumn(\n                                   \"v0\",\n                                   \"(\\\"m1\\\" * 2)\",\n                                   ValueType.FLOAT,\n                                   TestExprMacroTable.INSTANCE\n                               )\n                           )\n                           .aggregators(ImmutableList.of(\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a0:agg\",\n                                   \"m1\",\n                                   20,\n                                   0.0d,\n                                   10.0d,\n                                   FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                   false\n                               ),\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a4:agg\",\n                                   \"v0\",\n                                   40,\n                                   0.0d,\n                                   20.0d,\n                                   FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                   false\n                               ),\n                               new FilteredAggregatorFactory(\n                                   new FixedBucketsHistogramAggregatorFactory(\n                                       \"a5:agg\",\n                                       \"m1\",\n                                       20,\n                                       0.0d,\n                                       10.0d,\n                                       FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                       false\n                                   ),\n                                   new SelectorDimFilter(\"dim1\", \"abc\", null)\n                               ),\n                               new FilteredAggregatorFactory(\n                                   new FixedBucketsHistogramAggregatorFactory(\n                                       \"a6:agg\",\n                                       \"m1\",\n                                       20,\n                                       0.0d,\n                                       10.0d,\n                                       FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                       false\n                                   ),\n                                   new NotDimFilter(new SelectorDimFilter(\"dim1\", \"abc\", null))\n                               ),\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a8:agg\",\n                                   \"cnt\",\n                                   20,\n                                   0.0d,\n                                   10.0d,\n                                   FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                   false\n                               )\n                           ))\n                           .postAggregators(\n                               new QuantilePostAggregator(\"a0\", \"a0:agg\", 0.01f),\n                               new QuantilePostAggregator(\"a1\", \"a0:agg\", 0.50f),\n                               new QuantilePostAggregator(\"a2\", \"a0:agg\", 0.98f),\n                               new QuantilePostAggregator(\"a3\", \"a0:agg\", 0.99f),\n                               new QuantilePostAggregator(\"a4\", \"a4:agg\", 0.97f),\n                               new QuantilePostAggregator(\"a5\", \"a5:agg\", 0.99f),\n                               new QuantilePostAggregator(\"a6\", \"a6:agg\", 0.999f),\n                               new QuantilePostAggregator(\"a7\", \"a5:agg\", 0.999f),\n                               new QuantilePostAggregator(\"a8\", \"a8:agg\", 0.50f)\n                           )\n                           .context(ImmutableMap.of(\"skipEmptyBuckets\", true, PlannerContext.CTX_SQL_QUERY_ID, \"dummy\"))\n                           .build();\n\n    \r\n    Assert.assertEquals(\n        expected,\n        actual\n    );\n  }\n","realPath":"extensions-core/histogram/src/test/java/org/apache/druid/query/aggregation/histogram/sql/FixedBucketsHistogramQuantileSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":161,"status":"M"}],"commitId":"25db8787b3d7eac87aa3be8e32d48d0e823298af","commitMessage":"@@@Fix CAST being ignored when aggregating on strings after cast (#11083)\n\n* Fix CAST being ignored when aggregating on strings after cast\n\n* fix checkstyle and dependency\n\n* unused import","date":"2021-04-13 13:21:24","modifiedFileCount":"21","status":"M","submitter":"Jihoon Son"},{"authorTime":"2021-05-11 01:13:37","codes":[{"authorDate":"2021-05-11 01:13:37","commitOrder":8,"curCode":"  public void testQuantileOnFloatAndLongs() throws Exception\n  {\n    cannotVectorize();\n    testQuery(\n        \"SELECT\\n\"\n        + \"APPROX_QUANTILE(m1, 0.01),\\n\"\n        + \"APPROX_QUANTILE(m1, 0.5, 50),\\n\"\n        + \"APPROX_QUANTILE(m1, 0.98, 200),\\n\"\n        + \"APPROX_QUANTILE(m1, 0.99),\\n\"\n        + \"APPROX_QUANTILE(m1 * 2, 0.97),\\n\"\n        + \"APPROX_QUANTILE(m1, 0.99) FILTER(WHERE dim1 = 'abc'),\\n\"\n        + \"APPROX_QUANTILE(m1, 0.999) FILTER(WHERE dim1 <> 'abc'),\\n\"\n        + \"APPROX_QUANTILE(m1, 0.999) FILTER(WHERE dim1 = 'abc'),\\n\"\n        + \"APPROX_QUANTILE(cnt, 0.5)\\n\"\n        + \"FROM foo\",\n        ImmutableList.of(\n            Druids.newTimeseriesQueryBuilder()\n                  .dataSource(CalciteTests.DATASOURCE1)\n                  .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n                  .granularity(Granularities.ALL)\n                  .virtualColumns(\n                      new ExpressionVirtualColumn(\n                          \"v0\",\n                          \"(\\\"m1\\\" * 2)\",\n                          ValueType.FLOAT,\n                          TestExprMacroTable.INSTANCE\n                      )\n                  )\n                  .aggregators(ImmutableList.of(\n                      new ApproximateHistogramAggregatorFactory(\"a0:agg\", \"m1\", null, null, null, null, false),\n                      new ApproximateHistogramAggregatorFactory(\"a2:agg\", \"m1\", 200, null, null, null, false),\n                      new ApproximateHistogramAggregatorFactory(\"a4:agg\", \"v0\", null, null, null, null, false),\n                      new FilteredAggregatorFactory(\n                          new ApproximateHistogramAggregatorFactory(\"a5:agg\", \"m1\", null, null, null, null, false),\n                          new SelectorDimFilter(\"dim1\", \"abc\", null)\n                      ),\n                      new FilteredAggregatorFactory(\n                          new ApproximateHistogramAggregatorFactory(\"a6:agg\", \"m1\", null, null, null, null, false),\n                          new NotDimFilter(new SelectorDimFilter(\"dim1\", \"abc\", null))\n                      ),\n                      new ApproximateHistogramAggregatorFactory(\"a8:agg\", \"cnt\", null, null, null, null, false)\n                  ))\n                  .postAggregators(\n                      new QuantilePostAggregator(\"a0\", \"a0:agg\", 0.01f),\n                      new QuantilePostAggregator(\"a1\", \"a0:agg\", 0.50f),\n                      new QuantilePostAggregator(\"a2\", \"a2:agg\", 0.98f),\n                      new QuantilePostAggregator(\"a3\", \"a0:agg\", 0.99f),\n                      new QuantilePostAggregator(\"a4\", \"a4:agg\", 0.97f),\n                      new QuantilePostAggregator(\"a5\", \"a5:agg\", 0.99f),\n                      new QuantilePostAggregator(\"a6\", \"a6:agg\", 0.999f),\n                      new QuantilePostAggregator(\"a7\", \"a5:agg\", 0.999f),\n                      new QuantilePostAggregator(\"a8\", \"a8:agg\", 0.50f)\n                  )\n                  .context(QUERY_CONTEXT_DEFAULT)\n                  .build()\n        ),\n        ImmutableList.of(\n            new Object[]{\n                1.0,\n                3.0,\n                5.880000114440918,\n                5.940000057220459,\n                11.640000343322754,\n                6.0,\n                4.994999885559082,\n                6.0,\n                1.0\n            }\n        )\n    );\n  }\n","date":"2021-05-11 01:13:37","endLine":192,"groupId":"8957","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testQuantileOnFloatAndLongs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/48/993ca9a12288db825781c26c01df8cb629cb4c.src","preCode":"  public void testQuantileOnFloatAndLongs() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = getSqlLifecycle();\n\n    final String sql = \"SELECT\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.01),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.5, 50),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.98, 200),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.99),\\n\"\n                       + \"APPROX_QUANTILE(m1 * 2, 0.97),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.99) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.999) FILTER(WHERE dim1 <> 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(m1, 0.999) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE(cnt, 0.5)\\n\"\n                       + \"FROM foo\";\n\n    \r\n    final List<Object[]> results = sqlLifecycle.runSimple(\n        sql,\n        TIMESERIES_CONTEXT_DEFAULT,\n        DEFAULT_PARAMETERS,\n        AUTH_RESULT\n    ).toList();\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            1.0,\n            3.0,\n            5.880000114440918,\n            5.940000057220459,\n            11.640000343322754,\n            6.0,\n            4.994999885559082,\n            6.0,\n            1.0\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    \r\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(CalciteTests.DATASOURCE1)\n              .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n              .granularity(Granularities.ALL)\n              .virtualColumns(\n                  new ExpressionVirtualColumn(\n                      \"v0\",\n                      \"(\\\"m1\\\" * 2)\",\n                      ValueType.FLOAT,\n                      TestExprMacroTable.INSTANCE\n                  )\n              )\n              .aggregators(ImmutableList.of(\n                  new ApproximateHistogramAggregatorFactory(\"a0:agg\", \"m1\", null, null, null, null, false),\n                  new ApproximateHistogramAggregatorFactory(\"a2:agg\", \"m1\", 200, null, null, null, false),\n                  new ApproximateHistogramAggregatorFactory(\"a4:agg\", \"v0\", null, null, null, null, false),\n                  new FilteredAggregatorFactory(\n                      new ApproximateHistogramAggregatorFactory(\"a5:agg\", \"m1\", null, null, null, null, false),\n                      new SelectorDimFilter(\"dim1\", \"abc\", null)\n                  ),\n                  new FilteredAggregatorFactory(\n                      new ApproximateHistogramAggregatorFactory(\"a6:agg\", \"m1\", null, null, null, null, false),\n                      new NotDimFilter(new SelectorDimFilter(\"dim1\", \"abc\", null))\n                  ),\n                  new ApproximateHistogramAggregatorFactory(\"a8:agg\", \"cnt\", null, null, null, null, false)\n              ))\n              .postAggregators(\n                  new QuantilePostAggregator(\"a0\", \"a0:agg\", 0.01f),\n                  new QuantilePostAggregator(\"a1\", \"a0:agg\", 0.50f),\n                  new QuantilePostAggregator(\"a2\", \"a2:agg\", 0.98f),\n                  new QuantilePostAggregator(\"a3\", \"a0:agg\", 0.99f),\n                  new QuantilePostAggregator(\"a4\", \"a4:agg\", 0.97f),\n                  new QuantilePostAggregator(\"a5\", \"a5:agg\", 0.99f),\n                  new QuantilePostAggregator(\"a6\", \"a6:agg\", 0.999f),\n                  new QuantilePostAggregator(\"a7\", \"a5:agg\", 0.999f),\n                  new QuantilePostAggregator(\"a8\", \"a8:agg\", 0.50f)\n              )\n              .context(TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","realPath":"extensions-core/histogram/src/test/java/org/apache/druid/query/aggregation/histogram/sql/QuantileSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":122,"status":"M"},{"authorDate":"2021-05-11 01:13:37","commitOrder":8,"curCode":"  public void testQuantileOnFloatAndLongs() throws Exception\n  {\n    cannotVectorize();\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            1.0299999713897705,\n            3.5,\n            6.440000057220459,\n            6.470000267028809,\n            12.40999984741211,\n            6.494999885559082,\n            5.497499942779541,\n            6.499499797821045,\n            1.25\n        }\n    );\n\n    testQuery(\n        \"SELECT\\n\"\n        + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.01, 20, 0.0, 10.0),\\n\"\n        + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.5, 20, 0.0, 10.0),\\n\"\n        + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.98, 20, 0.0, 10.0),\\n\"\n        + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.99, 20, 0.0, 10.0),\\n\"\n        + \"APPROX_QUANTILE_FIXED_BUCKETS(m1 * 2, 0.97, 40, 0.0, 20.0),\\n\"\n        + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.99, 20, 0.0, 10.0) FILTER(WHERE dim1 = 'abc'),\\n\"\n        + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.999, 20, 0.0, 10.0) FILTER(WHERE dim1 <> 'abc'),\\n\"\n        + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.999, 20, 0.0, 10.0) FILTER(WHERE dim1 = 'abc'),\\n\"\n        + \"APPROX_QUANTILE_FIXED_BUCKETS(cnt, 0.5, 20, 0.0, 10.0)\\n\"\n        + \"FROM foo\",\n        ImmutableList.of(\n            Druids.newTimeseriesQueryBuilder()\n                  .dataSource(CalciteTests.DATASOURCE1)\n                  .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n                  .granularity(Granularities.ALL)\n                  .virtualColumns(\n                      new ExpressionVirtualColumn(\n                          \"v0\",\n                          \"(\\\"m1\\\" * 2)\",\n                          ValueType.FLOAT,\n                          TestExprMacroTable.INSTANCE\n                      )\n                  )\n                  .aggregators(ImmutableList.of(\n                      new FixedBucketsHistogramAggregatorFactory(\n                          \"a0:agg\",\n                          \"m1\",\n                          20,\n                          0.0d,\n                          10.0d,\n                          FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                          false\n                      ),\n                      new FixedBucketsHistogramAggregatorFactory(\n                          \"a4:agg\",\n                          \"v0\",\n                          40,\n                          0.0d,\n                          20.0d,\n                          FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                          false\n                      ),\n                      new FilteredAggregatorFactory(\n                          new FixedBucketsHistogramAggregatorFactory(\n                              \"a5:agg\",\n                              \"m1\",\n                              20,\n                              0.0d,\n                              10.0d,\n                              FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                              false\n                          ),\n                          new SelectorDimFilter(\"dim1\", \"abc\", null)\n                      ),\n                      new FilteredAggregatorFactory(\n                          new FixedBucketsHistogramAggregatorFactory(\n                              \"a6:agg\",\n                              \"m1\",\n                              20,\n                              0.0d,\n                              10.0d,\n                              FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                              false\n                          ),\n                          new NotDimFilter(new SelectorDimFilter(\"dim1\", \"abc\", null))\n                      ),\n                      new FixedBucketsHistogramAggregatorFactory(\n                          \"a8:agg\",\n                          \"cnt\",\n                          20,\n                          0.0d,\n                          10.0d,\n                          FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                          false\n                      )\n                  ))\n                  .postAggregators(\n                      new QuantilePostAggregator(\"a0\", \"a0:agg\", 0.01f),\n                      new QuantilePostAggregator(\"a1\", \"a0:agg\", 0.50f),\n                      new QuantilePostAggregator(\"a2\", \"a0:agg\", 0.98f),\n                      new QuantilePostAggregator(\"a3\", \"a0:agg\", 0.99f),\n                      new QuantilePostAggregator(\"a4\", \"a4:agg\", 0.97f),\n                      new QuantilePostAggregator(\"a5\", \"a5:agg\", 0.99f),\n                      new QuantilePostAggregator(\"a6\", \"a6:agg\", 0.999f),\n                      new QuantilePostAggregator(\"a7\", \"a5:agg\", 0.999f),\n                      new QuantilePostAggregator(\"a8\", \"a8:agg\", 0.50f)\n                  )\n                  .context(QUERY_CONTEXT_DEFAULT)\n                  .build()\n        ),\n        expectedResults\n    );\n  }\n","date":"2021-05-11 01:13:37","endLine":236,"groupId":"14120","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testQuantileOnFloatAndLongs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/94/8d63dfe0705a706f533451aec1e7fa00ee53e6.src","preCode":"  public void testQuantileOnFloatAndLongs() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = getSqlLifecycle();\n    final String sql = \"SELECT\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.01, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.5, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.98, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.99, 20, 0.0, 10.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1 * 2, 0.97, 40, 0.0, 20.0),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.99, 20, 0.0, 10.0) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.999, 20, 0.0, 10.0) FILTER(WHERE dim1 <> 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.999, 20, 0.0, 10.0) FILTER(WHERE dim1 = 'abc'),\\n\"\n                       + \"APPROX_QUANTILE_FIXED_BUCKETS(cnt, 0.5, 20, 0.0, 10.0)\\n\"\n                       + \"FROM foo\";\n\n    \r\n    final List<Object[]> results = sqlLifecycle.runSimple(\n        sql,\n        TIMESERIES_CONTEXT_DEFAULT,\n        DEFAULT_PARAMETERS,\n        AUTH_RESULT\n    ).toList();\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            1.0299999713897705,\n            3.5,\n            6.440000057220459,\n            6.470000267028809,\n            12.40999984741211,\n            6.494999885559082,\n            5.497499942779541,\n            6.499499797821045,\n            1.25\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Query actual = Iterables.getOnlyElement(queryLogHook.getRecordedQueries());\n    Query expected = Druids.newTimeseriesQueryBuilder()\n                           .dataSource(CalciteTests.DATASOURCE1)\n                           .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n                           .granularity(Granularities.ALL)\n                           .virtualColumns(\n                               new ExpressionVirtualColumn(\n                                   \"v0\",\n                                   \"(\\\"m1\\\" * 2)\",\n                                   ValueType.FLOAT,\n                                   TestExprMacroTable.INSTANCE\n                               )\n                           )\n                           .aggregators(ImmutableList.of(\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a0:agg\",\n                                   \"m1\",\n                                   20,\n                                   0.0d,\n                                   10.0d,\n                                   FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                   false\n                               ),\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a4:agg\",\n                                   \"v0\",\n                                   40,\n                                   0.0d,\n                                   20.0d,\n                                   FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                   false\n                               ),\n                               new FilteredAggregatorFactory(\n                                   new FixedBucketsHistogramAggregatorFactory(\n                                       \"a5:agg\",\n                                       \"m1\",\n                                       20,\n                                       0.0d,\n                                       10.0d,\n                                       FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                       false\n                                   ),\n                                   new SelectorDimFilter(\"dim1\", \"abc\", null)\n                               ),\n                               new FilteredAggregatorFactory(\n                                   new FixedBucketsHistogramAggregatorFactory(\n                                       \"a6:agg\",\n                                       \"m1\",\n                                       20,\n                                       0.0d,\n                                       10.0d,\n                                       FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                       false\n                                   ),\n                                   new NotDimFilter(new SelectorDimFilter(\"dim1\", \"abc\", null))\n                               ),\n                               new FixedBucketsHistogramAggregatorFactory(\n                                   \"a8:agg\",\n                                   \"cnt\",\n                                   20,\n                                   0.0d,\n                                   10.0d,\n                                   FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                                   false\n                               )\n                           ))\n                           .postAggregators(\n                               new QuantilePostAggregator(\"a0\", \"a0:agg\", 0.01f),\n                               new QuantilePostAggregator(\"a1\", \"a0:agg\", 0.50f),\n                               new QuantilePostAggregator(\"a2\", \"a0:agg\", 0.98f),\n                               new QuantilePostAggregator(\"a3\", \"a0:agg\", 0.99f),\n                               new QuantilePostAggregator(\"a4\", \"a4:agg\", 0.97f),\n                               new QuantilePostAggregator(\"a5\", \"a5:agg\", 0.99f),\n                               new QuantilePostAggregator(\"a6\", \"a6:agg\", 0.999f),\n                               new QuantilePostAggregator(\"a7\", \"a5:agg\", 0.999f),\n                               new QuantilePostAggregator(\"a8\", \"a8:agg\", 0.50f)\n                           )\n                           .context(TIMESERIES_CONTEXT_DEFAULT)\n                           .build();\n\n    \r\n    Assert.assertEquals(\n        expected,\n        actual\n    );\n  }\n","realPath":"extensions-core/histogram/src/test/java/org/apache/druid/query/aggregation/histogram/sql/FixedBucketsHistogramQuantileSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":124,"status":"M"}],"commitId":"691d7a1d548909951468005348a603380f4d6d74","commitMessage":"@@@SQL timeseries no longer skip empty buckets with all granularity (#11188)\n\n* SQL timeseries no longer skip empty buckets with all granularity\n\n* add comment.  fix tests\n\n* the ol switcheroo\n\n* revert unintended change\n\n* docs and more tests\n\n* style\n\n* make checkstyle happy\n\n* docs fixes and more tests\n\n* add docs.  tests for array_agg\n\n* fixes\n\n* oops\n\n* doc stuffs\n\n* fix compile.  match doc style","date":"2021-05-11 01:13:37","modifiedFileCount":"16","status":"M","submitter":"Clint Wylie"},{"authorTime":"2021-07-07 02:20:49","codes":[{"authorDate":"2021-07-07 02:20:49","commitOrder":9,"curCode":"  public void testQuantileOnFloatAndLongs() throws Exception\n  {\n    testQuery(\n        \"SELECT\\n\"\n        + \"APPROX_QUANTILE(m1, 0.01),\\n\"\n        + \"APPROX_QUANTILE(m1, 0.5, 50),\\n\"\n        + \"APPROX_QUANTILE(m1, 0.98, 200),\\n\"\n        + \"APPROX_QUANTILE(m1, 0.99),\\n\"\n        + \"APPROX_QUANTILE(m1 * 2, 0.97),\\n\"\n        + \"APPROX_QUANTILE(m1, 0.99) FILTER(WHERE dim1 = 'abc'),\\n\"\n        + \"APPROX_QUANTILE(m1, 0.999) FILTER(WHERE dim1 <> 'abc'),\\n\"\n        + \"APPROX_QUANTILE(m1, 0.999) FILTER(WHERE dim1 = 'abc'),\\n\"\n        + \"APPROX_QUANTILE(cnt, 0.5)\\n\"\n        + \"FROM foo\",\n        ImmutableList.of(\n            Druids.newTimeseriesQueryBuilder()\n                  .dataSource(CalciteTests.DATASOURCE1)\n                  .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n                  .granularity(Granularities.ALL)\n                  .virtualColumns(\n                      new ExpressionVirtualColumn(\n                          \"v0\",\n                          \"(\\\"m1\\\" * 2)\",\n                          ValueType.FLOAT,\n                          TestExprMacroTable.INSTANCE\n                      )\n                  )\n                  .aggregators(ImmutableList.of(\n                      new ApproximateHistogramAggregatorFactory(\"a0:agg\", \"m1\", null, null, null, null, false),\n                      new ApproximateHistogramAggregatorFactory(\"a2:agg\", \"m1\", 200, null, null, null, false),\n                      new ApproximateHistogramAggregatorFactory(\"a4:agg\", \"v0\", null, null, null, null, false),\n                      new FilteredAggregatorFactory(\n                          new ApproximateHistogramAggregatorFactory(\"a5:agg\", \"m1\", null, null, null, null, false),\n                          new SelectorDimFilter(\"dim1\", \"abc\", null)\n                      ),\n                      new FilteredAggregatorFactory(\n                          new ApproximateHistogramAggregatorFactory(\"a6:agg\", \"m1\", null, null, null, null, false),\n                          new NotDimFilter(new SelectorDimFilter(\"dim1\", \"abc\", null))\n                      ),\n                      new ApproximateHistogramAggregatorFactory(\"a8:agg\", \"cnt\", null, null, null, null, false)\n                  ))\n                  .postAggregators(\n                      new QuantilePostAggregator(\"a0\", \"a0:agg\", 0.01f),\n                      new QuantilePostAggregator(\"a1\", \"a0:agg\", 0.50f),\n                      new QuantilePostAggregator(\"a2\", \"a2:agg\", 0.98f),\n                      new QuantilePostAggregator(\"a3\", \"a0:agg\", 0.99f),\n                      new QuantilePostAggregator(\"a4\", \"a4:agg\", 0.97f),\n                      new QuantilePostAggregator(\"a5\", \"a5:agg\", 0.99f),\n                      new QuantilePostAggregator(\"a6\", \"a6:agg\", 0.999f),\n                      new QuantilePostAggregator(\"a7\", \"a5:agg\", 0.999f),\n                      new QuantilePostAggregator(\"a8\", \"a8:agg\", 0.50f)\n                  )\n                  .context(QUERY_CONTEXT_DEFAULT)\n                  .build()\n        ),\n        ImmutableList.of(\n            new Object[]{\n                1.0,\n                3.0,\n                5.880000114440918,\n                5.940000057220459,\n                11.640000343322754,\n                6.0,\n                4.994999885559082,\n                6.0,\n                1.0\n            }\n        )\n    );\n  }\n","date":"2021-07-07 02:20:49","endLine":191,"groupId":"103332","id":13,"instanceNumber":1,"isCurCommit":1,"methodName":"testQuantileOnFloatAndLongs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/72/0d2fa8b1caea135e9346348524026061e4062a.src","preCode":"  public void testQuantileOnFloatAndLongs() throws Exception\n  {\n    cannotVectorize();\n    testQuery(\n        \"SELECT\\n\"\n        + \"APPROX_QUANTILE(m1, 0.01),\\n\"\n        + \"APPROX_QUANTILE(m1, 0.5, 50),\\n\"\n        + \"APPROX_QUANTILE(m1, 0.98, 200),\\n\"\n        + \"APPROX_QUANTILE(m1, 0.99),\\n\"\n        + \"APPROX_QUANTILE(m1 * 2, 0.97),\\n\"\n        + \"APPROX_QUANTILE(m1, 0.99) FILTER(WHERE dim1 = 'abc'),\\n\"\n        + \"APPROX_QUANTILE(m1, 0.999) FILTER(WHERE dim1 <> 'abc'),\\n\"\n        + \"APPROX_QUANTILE(m1, 0.999) FILTER(WHERE dim1 = 'abc'),\\n\"\n        + \"APPROX_QUANTILE(cnt, 0.5)\\n\"\n        + \"FROM foo\",\n        ImmutableList.of(\n            Druids.newTimeseriesQueryBuilder()\n                  .dataSource(CalciteTests.DATASOURCE1)\n                  .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n                  .granularity(Granularities.ALL)\n                  .virtualColumns(\n                      new ExpressionVirtualColumn(\n                          \"v0\",\n                          \"(\\\"m1\\\" * 2)\",\n                          ValueType.FLOAT,\n                          TestExprMacroTable.INSTANCE\n                      )\n                  )\n                  .aggregators(ImmutableList.of(\n                      new ApproximateHistogramAggregatorFactory(\"a0:agg\", \"m1\", null, null, null, null, false),\n                      new ApproximateHistogramAggregatorFactory(\"a2:agg\", \"m1\", 200, null, null, null, false),\n                      new ApproximateHistogramAggregatorFactory(\"a4:agg\", \"v0\", null, null, null, null, false),\n                      new FilteredAggregatorFactory(\n                          new ApproximateHistogramAggregatorFactory(\"a5:agg\", \"m1\", null, null, null, null, false),\n                          new SelectorDimFilter(\"dim1\", \"abc\", null)\n                      ),\n                      new FilteredAggregatorFactory(\n                          new ApproximateHistogramAggregatorFactory(\"a6:agg\", \"m1\", null, null, null, null, false),\n                          new NotDimFilter(new SelectorDimFilter(\"dim1\", \"abc\", null))\n                      ),\n                      new ApproximateHistogramAggregatorFactory(\"a8:agg\", \"cnt\", null, null, null, null, false)\n                  ))\n                  .postAggregators(\n                      new QuantilePostAggregator(\"a0\", \"a0:agg\", 0.01f),\n                      new QuantilePostAggregator(\"a1\", \"a0:agg\", 0.50f),\n                      new QuantilePostAggregator(\"a2\", \"a2:agg\", 0.98f),\n                      new QuantilePostAggregator(\"a3\", \"a0:agg\", 0.99f),\n                      new QuantilePostAggregator(\"a4\", \"a4:agg\", 0.97f),\n                      new QuantilePostAggregator(\"a5\", \"a5:agg\", 0.99f),\n                      new QuantilePostAggregator(\"a6\", \"a6:agg\", 0.999f),\n                      new QuantilePostAggregator(\"a7\", \"a5:agg\", 0.999f),\n                      new QuantilePostAggregator(\"a8\", \"a8:agg\", 0.50f)\n                  )\n                  .context(QUERY_CONTEXT_DEFAULT)\n                  .build()\n        ),\n        ImmutableList.of(\n            new Object[]{\n                1.0,\n                3.0,\n                5.880000114440918,\n                5.940000057220459,\n                11.640000343322754,\n                6.0,\n                4.994999885559082,\n                6.0,\n                1.0\n            }\n        )\n    );\n  }\n","realPath":"extensions-core/histogram/src/test/java/org/apache/druid/query/aggregation/histogram/sql/QuantileSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":122,"status":"M"},{"authorDate":"2021-07-07 02:20:49","commitOrder":9,"curCode":"  public void testQuantileOnFloatAndLongs() throws Exception\n  {\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            1.0299999713897705,\n            3.5,\n            6.440000057220459,\n            6.470000267028809,\n            12.40999984741211,\n            6.494999885559082,\n            5.497499942779541,\n            6.499499797821045,\n            1.25\n        }\n    );\n\n    testQuery(\n        \"SELECT\\n\"\n        + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.01, 20, 0.0, 10.0),\\n\"\n        + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.5, 20, 0.0, 10.0),\\n\"\n        + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.98, 20, 0.0, 10.0),\\n\"\n        + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.99, 20, 0.0, 10.0),\\n\"\n        + \"APPROX_QUANTILE_FIXED_BUCKETS(m1 * 2, 0.97, 40, 0.0, 20.0),\\n\"\n        + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.99, 20, 0.0, 10.0) FILTER(WHERE dim1 = 'abc'),\\n\"\n        + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.999, 20, 0.0, 10.0) FILTER(WHERE dim1 <> 'abc'),\\n\"\n        + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.999, 20, 0.0, 10.0) FILTER(WHERE dim1 = 'abc'),\\n\"\n        + \"APPROX_QUANTILE_FIXED_BUCKETS(cnt, 0.5, 20, 0.0, 10.0)\\n\"\n        + \"FROM foo\",\n        ImmutableList.of(\n            Druids.newTimeseriesQueryBuilder()\n                  .dataSource(CalciteTests.DATASOURCE1)\n                  .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n                  .granularity(Granularities.ALL)\n                  .virtualColumns(\n                      new ExpressionVirtualColumn(\n                          \"v0\",\n                          \"(\\\"m1\\\" * 2)\",\n                          ValueType.FLOAT,\n                          TestExprMacroTable.INSTANCE\n                      )\n                  )\n                  .aggregators(ImmutableList.of(\n                      new FixedBucketsHistogramAggregatorFactory(\n                          \"a0:agg\",\n                          \"m1\",\n                          20,\n                          0.0d,\n                          10.0d,\n                          FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                          false\n                      ),\n                      new FixedBucketsHistogramAggregatorFactory(\n                          \"a4:agg\",\n                          \"v0\",\n                          40,\n                          0.0d,\n                          20.0d,\n                          FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                          false\n                      ),\n                      new FilteredAggregatorFactory(\n                          new FixedBucketsHistogramAggregatorFactory(\n                              \"a5:agg\",\n                              \"m1\",\n                              20,\n                              0.0d,\n                              10.0d,\n                              FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                              false\n                          ),\n                          new SelectorDimFilter(\"dim1\", \"abc\", null)\n                      ),\n                      new FilteredAggregatorFactory(\n                          new FixedBucketsHistogramAggregatorFactory(\n                              \"a6:agg\",\n                              \"m1\",\n                              20,\n                              0.0d,\n                              10.0d,\n                              FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                              false\n                          ),\n                          new NotDimFilter(new SelectorDimFilter(\"dim1\", \"abc\", null))\n                      ),\n                      new FixedBucketsHistogramAggregatorFactory(\n                          \"a8:agg\",\n                          \"cnt\",\n                          20,\n                          0.0d,\n                          10.0d,\n                          FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                          false\n                      )\n                  ))\n                  .postAggregators(\n                      new QuantilePostAggregator(\"a0\", \"a0:agg\", 0.01f),\n                      new QuantilePostAggregator(\"a1\", \"a0:agg\", 0.50f),\n                      new QuantilePostAggregator(\"a2\", \"a0:agg\", 0.98f),\n                      new QuantilePostAggregator(\"a3\", \"a0:agg\", 0.99f),\n                      new QuantilePostAggregator(\"a4\", \"a4:agg\", 0.97f),\n                      new QuantilePostAggregator(\"a5\", \"a5:agg\", 0.99f),\n                      new QuantilePostAggregator(\"a6\", \"a6:agg\", 0.999f),\n                      new QuantilePostAggregator(\"a7\", \"a5:agg\", 0.999f),\n                      new QuantilePostAggregator(\"a8\", \"a8:agg\", 0.50f)\n                  )\n                  .context(QUERY_CONTEXT_DEFAULT)\n                  .build()\n        ),\n        expectedResults\n    );\n  }\n","date":"2021-07-07 02:20:49","endLine":234,"groupId":"103332","id":14,"instanceNumber":2,"isCurCommit":1,"methodName":"testQuantileOnFloatAndLongs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/35/341c24de71b66b3c58607c1a5ea989928e6e60.src","preCode":"  public void testQuantileOnFloatAndLongs() throws Exception\n  {\n    cannotVectorize();\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            1.0299999713897705,\n            3.5,\n            6.440000057220459,\n            6.470000267028809,\n            12.40999984741211,\n            6.494999885559082,\n            5.497499942779541,\n            6.499499797821045,\n            1.25\n        }\n    );\n\n    testQuery(\n        \"SELECT\\n\"\n        + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.01, 20, 0.0, 10.0),\\n\"\n        + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.5, 20, 0.0, 10.0),\\n\"\n        + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.98, 20, 0.0, 10.0),\\n\"\n        + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.99, 20, 0.0, 10.0),\\n\"\n        + \"APPROX_QUANTILE_FIXED_BUCKETS(m1 * 2, 0.97, 40, 0.0, 20.0),\\n\"\n        + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.99, 20, 0.0, 10.0) FILTER(WHERE dim1 = 'abc'),\\n\"\n        + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.999, 20, 0.0, 10.0) FILTER(WHERE dim1 <> 'abc'),\\n\"\n        + \"APPROX_QUANTILE_FIXED_BUCKETS(m1, 0.999, 20, 0.0, 10.0) FILTER(WHERE dim1 = 'abc'),\\n\"\n        + \"APPROX_QUANTILE_FIXED_BUCKETS(cnt, 0.5, 20, 0.0, 10.0)\\n\"\n        + \"FROM foo\",\n        ImmutableList.of(\n            Druids.newTimeseriesQueryBuilder()\n                  .dataSource(CalciteTests.DATASOURCE1)\n                  .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n                  .granularity(Granularities.ALL)\n                  .virtualColumns(\n                      new ExpressionVirtualColumn(\n                          \"v0\",\n                          \"(\\\"m1\\\" * 2)\",\n                          ValueType.FLOAT,\n                          TestExprMacroTable.INSTANCE\n                      )\n                  )\n                  .aggregators(ImmutableList.of(\n                      new FixedBucketsHistogramAggregatorFactory(\n                          \"a0:agg\",\n                          \"m1\",\n                          20,\n                          0.0d,\n                          10.0d,\n                          FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                          false\n                      ),\n                      new FixedBucketsHistogramAggregatorFactory(\n                          \"a4:agg\",\n                          \"v0\",\n                          40,\n                          0.0d,\n                          20.0d,\n                          FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                          false\n                      ),\n                      new FilteredAggregatorFactory(\n                          new FixedBucketsHistogramAggregatorFactory(\n                              \"a5:agg\",\n                              \"m1\",\n                              20,\n                              0.0d,\n                              10.0d,\n                              FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                              false\n                          ),\n                          new SelectorDimFilter(\"dim1\", \"abc\", null)\n                      ),\n                      new FilteredAggregatorFactory(\n                          new FixedBucketsHistogramAggregatorFactory(\n                              \"a6:agg\",\n                              \"m1\",\n                              20,\n                              0.0d,\n                              10.0d,\n                              FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                              false\n                          ),\n                          new NotDimFilter(new SelectorDimFilter(\"dim1\", \"abc\", null))\n                      ),\n                      new FixedBucketsHistogramAggregatorFactory(\n                          \"a8:agg\",\n                          \"cnt\",\n                          20,\n                          0.0d,\n                          10.0d,\n                          FixedBucketsHistogram.OutlierHandlingMode.IGNORE,\n                          false\n                      )\n                  ))\n                  .postAggregators(\n                      new QuantilePostAggregator(\"a0\", \"a0:agg\", 0.01f),\n                      new QuantilePostAggregator(\"a1\", \"a0:agg\", 0.50f),\n                      new QuantilePostAggregator(\"a2\", \"a0:agg\", 0.98f),\n                      new QuantilePostAggregator(\"a3\", \"a0:agg\", 0.99f),\n                      new QuantilePostAggregator(\"a4\", \"a4:agg\", 0.97f),\n                      new QuantilePostAggregator(\"a5\", \"a5:agg\", 0.99f),\n                      new QuantilePostAggregator(\"a6\", \"a6:agg\", 0.999f),\n                      new QuantilePostAggregator(\"a7\", \"a5:agg\", 0.999f),\n                      new QuantilePostAggregator(\"a8\", \"a8:agg\", 0.50f)\n                  )\n                  .context(QUERY_CONTEXT_DEFAULT)\n                  .build()\n        ),\n        expectedResults\n    );\n  }\n","realPath":"extensions-core/histogram/src/test/java/org/apache/druid/query/aggregation/histogram/sql/FixedBucketsHistogramQuantileSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":124,"status":"M"}],"commitId":"17efa6f5569d21fffdbb263d6e12db5982d7529b","commitMessage":"@@@add single input string expression dimension vector selector and better expression planning (#11213)\n\n* add single input string expression dimension vector selector and better expression planning\n\n* better\n\n* fixes\n\n* oops\n\n* rework how vector processor factories choose string processors.  fix to be less aggressive about vectorizing\n\n* oops\n\n* javadocs.  renaming\n\n* more javadocs\n\n* benchmarks\n\n* use string expression vector processor with vector size 1 instead of expr.eval\n\n* better logging\n\n* javadocs.  surprising number of the the\n\n* more\n\n* simplify","date":"2021-07-07 02:20:49","modifiedFileCount":"30","status":"M","submitter":"Clint Wylie"}]
