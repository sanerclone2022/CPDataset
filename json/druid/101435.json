[{"authorTime":"2020-02-14 06:58:32","codes":[{"authorDate":"2020-02-14 06:58:32","commitOrder":1,"curCode":"  public void querySingleIncrementalIndex(Blackhole blackhole)\n  {\n    QueryRunner<ScanResultValue> runner = QueryBenchmarkUtil.makeQueryRunner(\n        factory,\n        SegmentId.dummy(\"incIndex\"),\n        new IncrementalIndexSegment(incIndexes.get(0), SegmentId.dummy(\"incIndex\"))\n    );\n\n    Query effectiveQuery = query\n        .withDataSource(new TableDataSource(\"incIndex\"))\n        .withQuerySegmentSpec(\n            new MultipleSpecificSegmentSpec(\n                ImmutableList.of(\n                    new SegmentDescriptor(\n                        Intervals.ETERNITY,\n                        \"dummy_version\",\n                        0\n                    )\n                )\n            )\n        )\n        .withOverriddenContext(\n            ImmutableMap.of(ScanQuery.CTX_KEY_OUTERMOST, false)\n        );\n\n    List<ScanResultValue> results = ScanBenchmark.runQuery(factory, runner, effectiveQuery);\n    blackhole.consume(results);\n  }\n","date":"2020-02-14 06:58:32","endLine":371,"groupId":"2268","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"querySingleIncrementalIndex","params":"(Blackholeblackhole)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/a2/b0e98fb980c47d353a27e57b76c3d1beaad6a0.src","preCode":"  public void querySingleIncrementalIndex(Blackhole blackhole)\n  {\n    QueryRunner<ScanResultValue> runner = QueryBenchmarkUtil.makeQueryRunner(\n        factory,\n        SegmentId.dummy(\"incIndex\"),\n        new IncrementalIndexSegment(incIndexes.get(0), SegmentId.dummy(\"incIndex\"))\n    );\n\n    Query effectiveQuery = query\n        .withDataSource(new TableDataSource(\"incIndex\"))\n        .withQuerySegmentSpec(\n            new MultipleSpecificSegmentSpec(\n                ImmutableList.of(\n                    new SegmentDescriptor(\n                        Intervals.ETERNITY,\n                        \"dummy_version\",\n                        0\n                    )\n                )\n            )\n        )\n        .withOverriddenContext(\n            ImmutableMap.of(ScanQuery.CTX_KEY_OUTERMOST, false)\n        );\n\n    List<ScanResultValue> results = ScanBenchmark.runQuery(factory, runner, effectiveQuery);\n    blackhole.consume(results);\n  }\n","realPath":"benchmarks/src/test/java/org/apache/druid/benchmark/query/ScanBenchmark.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":344,"status":"B"},{"authorDate":"2020-02-14 06:58:32","commitOrder":1,"curCode":"  public void querySingleQueryableIndex(Blackhole blackhole)\n  {\n    final QueryRunner<Result<ScanResultValue>> runner = QueryBenchmarkUtil.makeQueryRunner(\n        factory,\n        SegmentId.dummy(\"qIndex\"),\n        new QueryableIndexSegment(qIndexes.get(0), SegmentId.dummy(\"qIndex\"))\n    );\n\n    Query effectiveQuery = query\n        .withDataSource(new TableDataSource(\"qIndex\"))\n        .withQuerySegmentSpec(\n            new MultipleSpecificSegmentSpec(\n                ImmutableList.of(\n                    new SegmentDescriptor(\n                        Intervals.ETERNITY,\n                        \"dummy_version\",\n                        0\n                    )\n                )\n            )\n        )\n        .withOverriddenContext(\n            ImmutableMap.of(ScanQuery.CTX_KEY_OUTERMOST, false)\n        );\n\n    List<ScanResultValue> results = ScanBenchmark.runQuery(factory, runner, effectiveQuery);\n    blackhole.consume(results);\n  }\n","date":"2020-02-14 06:58:32","endLine":403,"groupId":"2268","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"querySingleQueryableIndex","params":"(Blackholeblackhole)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/a2/b0e98fb980c47d353a27e57b76c3d1beaad6a0.src","preCode":"  public void querySingleQueryableIndex(Blackhole blackhole)\n  {\n    final QueryRunner<Result<ScanResultValue>> runner = QueryBenchmarkUtil.makeQueryRunner(\n        factory,\n        SegmentId.dummy(\"qIndex\"),\n        new QueryableIndexSegment(qIndexes.get(0), SegmentId.dummy(\"qIndex\"))\n    );\n\n    Query effectiveQuery = query\n        .withDataSource(new TableDataSource(\"qIndex\"))\n        .withQuerySegmentSpec(\n            new MultipleSpecificSegmentSpec(\n                ImmutableList.of(\n                    new SegmentDescriptor(\n                        Intervals.ETERNITY,\n                        \"dummy_version\",\n                        0\n                    )\n                )\n            )\n        )\n        .withOverriddenContext(\n            ImmutableMap.of(ScanQuery.CTX_KEY_OUTERMOST, false)\n        );\n\n    List<ScanResultValue> results = ScanBenchmark.runQuery(factory, runner, effectiveQuery);\n    blackhole.consume(results);\n  }\n","realPath":"benchmarks/src/test/java/org/apache/druid/benchmark/query/ScanBenchmark.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":376,"status":"B"}],"commitId":"e9aebd994aa0e243446b4f76d819a503401104e3","commitMessage":"@@@Fix for building in Eclipse & VS Code. (#7481)\n\nFixes #6866\nReverse dependencies from /main/ to /test/\nAdd generated-test-sources to source path for Eclipse","date":"2020-02-14 06:58:32","modifiedFileCount":"1","status":"B","submitter":"Adam Peck"},{"authorTime":"2021-01-08 14:18:47","codes":[{"authorDate":"2021-01-08 14:18:47","commitOrder":2,"curCode":"  public void querySingleIncrementalIndex(Blackhole blackhole, IncrementalIndexState state)\n  {\n    QueryRunner<ScanResultValue> runner = QueryBenchmarkUtil.makeQueryRunner(\n        factory,\n        SegmentId.dummy(\"incIndex\"),\n        new IncrementalIndexSegment(state.incIndex, SegmentId.dummy(\"incIndex\"))\n    );\n\n    Query effectiveQuery = query\n        .withDataSource(new TableDataSource(\"incIndex\"))\n        .withQuerySegmentSpec(\n            new MultipleSpecificSegmentSpec(\n                ImmutableList.of(\n                    new SegmentDescriptor(\n                        Intervals.ETERNITY,\n                        \"dummy_version\",\n                        0\n                    )\n                )\n            )\n        )\n        .withOverriddenContext(\n            ImmutableMap.of(ScanQuery.CTX_KEY_OUTERMOST, false)\n        );\n\n    List<ScanResultValue> results = ScanBenchmark.runQuery(factory, runner, effectiveQuery);\n    blackhole.consume(results);\n  }\n","date":"2021-01-08 14:18:47","endLine":416,"groupId":"101435","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"querySingleIncrementalIndex","params":"(Blackholeblackhole@IncrementalIndexStatestate)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/10/c31b5cbe4b7802db84770b13dc03c16efe43e4.src","preCode":"  public void querySingleIncrementalIndex(Blackhole blackhole)\n  {\n    QueryRunner<ScanResultValue> runner = QueryBenchmarkUtil.makeQueryRunner(\n        factory,\n        SegmentId.dummy(\"incIndex\"),\n        new IncrementalIndexSegment(incIndexes.get(0), SegmentId.dummy(\"incIndex\"))\n    );\n\n    Query effectiveQuery = query\n        .withDataSource(new TableDataSource(\"incIndex\"))\n        .withQuerySegmentSpec(\n            new MultipleSpecificSegmentSpec(\n                ImmutableList.of(\n                    new SegmentDescriptor(\n                        Intervals.ETERNITY,\n                        \"dummy_version\",\n                        0\n                    )\n                )\n            )\n        )\n        .withOverriddenContext(\n            ImmutableMap.of(ScanQuery.CTX_KEY_OUTERMOST, false)\n        );\n\n    List<ScanResultValue> results = ScanBenchmark.runQuery(factory, runner, effectiveQuery);\n    blackhole.consume(results);\n  }\n","realPath":"benchmarks/src/test/java/org/apache/druid/benchmark/query/ScanBenchmark.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":389,"status":"M"},{"authorDate":"2021-01-08 14:18:47","commitOrder":2,"curCode":"  public void querySingleQueryableIndex(Blackhole blackhole, QueryableIndexState state)\n  {\n    final QueryRunner<Result<ScanResultValue>> runner = QueryBenchmarkUtil.makeQueryRunner(\n        factory,\n        SegmentId.dummy(\"qIndex\"),\n        new QueryableIndexSegment(state.qIndexes.get(0), SegmentId.dummy(\"qIndex\"))\n    );\n\n    Query effectiveQuery = query\n        .withDataSource(new TableDataSource(\"qIndex\"))\n        .withQuerySegmentSpec(\n            new MultipleSpecificSegmentSpec(\n                ImmutableList.of(\n                    new SegmentDescriptor(\n                        Intervals.ETERNITY,\n                        \"dummy_version\",\n                        0\n                    )\n                )\n            )\n        )\n        .withOverriddenContext(\n            ImmutableMap.of(ScanQuery.CTX_KEY_OUTERMOST, false)\n        );\n\n    List<ScanResultValue> results = ScanBenchmark.runQuery(factory, runner, effectiveQuery);\n    blackhole.consume(results);\n  }\n","date":"2021-01-08 14:18:47","endLine":448,"groupId":"101435","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"querySingleQueryableIndex","params":"(Blackholeblackhole@QueryableIndexStatestate)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/10/c31b5cbe4b7802db84770b13dc03c16efe43e4.src","preCode":"  public void querySingleQueryableIndex(Blackhole blackhole)\n  {\n    final QueryRunner<Result<ScanResultValue>> runner = QueryBenchmarkUtil.makeQueryRunner(\n        factory,\n        SegmentId.dummy(\"qIndex\"),\n        new QueryableIndexSegment(qIndexes.get(0), SegmentId.dummy(\"qIndex\"))\n    );\n\n    Query effectiveQuery = query\n        .withDataSource(new TableDataSource(\"qIndex\"))\n        .withQuerySegmentSpec(\n            new MultipleSpecificSegmentSpec(\n                ImmutableList.of(\n                    new SegmentDescriptor(\n                        Intervals.ETERNITY,\n                        \"dummy_version\",\n                        0\n                    )\n                )\n            )\n        )\n        .withOverriddenContext(\n            ImmutableMap.of(ScanQuery.CTX_KEY_OUTERMOST, false)\n        );\n\n    List<ScanResultValue> results = ScanBenchmark.runQuery(factory, runner, effectiveQuery);\n    blackhole.consume(results);\n  }\n","realPath":"benchmarks/src/test/java/org/apache/druid/benchmark/query/ScanBenchmark.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":421,"status":"M"}],"commitId":"08ab82f55ca856d60dfe1088c1c0393428b0bb6d","commitMessage":"@@@IncrementalIndex Tests and Benchmarks Parametrization (#10593)\n\n* Remove redundant IncrementalIndex.Builder\n\n* Parametrize incremental index tests and benchmarks\n\n- Reveal and fix a bug in OffheapIncrementalIndex\n\n* Fix forbiddenapis error: Forbidden method invocation: java.lang.String#format(java.lang.String. java.lang.Object[]) [Uses default locale]\n\n* Fix Intellij errors: declared exception is never thrown\n\n* Add documentation and validate before closing objects on tearDown.\n\n* Add documentation to OffheapIncrementalIndexTestSpec\n\n* Doc corrections and minor changes.\n\n* Add logging for generated rows.\n\n* Refactor new tests/benchmarks.\n\n* Improve IncrementalIndexCreator documentation\n\n* Add required tests for DataGenerator\n\n* Revert \"rollupOpportunity\" to be a string","date":"2021-01-08 14:18:47","modifiedFileCount":"62","status":"M","submitter":"Liran Funaro"}]
