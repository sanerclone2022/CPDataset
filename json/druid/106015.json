[{"authorTime":"2020-01-17 05:14:20","codes":[{"authorDate":"2020-01-17 05:14:20","commitOrder":1,"curCode":"  public void test_forExpression_simpleFlipped()\n  {\n    final String expression = \"\\\"j.y\\\" == x\";\n    final JoinConditionAnalysis analysis = analyze(expression);\n\n    Assert.assertEquals(expression, analysis.getOriginalExpression());\n    Assert.assertTrue(analysis.canHashJoin());\n    Assert.assertFalse(analysis.isAlwaysTrue());\n    Assert.assertFalse(analysis.isAlwaysFalse());\n    Assert.assertEquals(\n        ImmutableList.of(Pair.of(\"x\", \"y\")),\n        equalitiesToPairs(analysis.getEquiConditions())\n    );\n    Assert.assertEquals(\n        ImmutableList.of(),\n        exprsToStrings(analysis.getNonEquiConditions())\n    );\n  }\n","date":"2020-01-17 05:14:20","endLine":83,"groupId":"2089","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"test_forExpression_simpleFlipped","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/f5/ec8b8062ccf38f4c7121358137963498fbc071.src","preCode":"  public void test_forExpression_simpleFlipped()\n  {\n    final String expression = \"\\\"j.y\\\" == x\";\n    final JoinConditionAnalysis analysis = analyze(expression);\n\n    Assert.assertEquals(expression, analysis.getOriginalExpression());\n    Assert.assertTrue(analysis.canHashJoin());\n    Assert.assertFalse(analysis.isAlwaysTrue());\n    Assert.assertFalse(analysis.isAlwaysFalse());\n    Assert.assertEquals(\n        ImmutableList.of(Pair.of(\"x\", \"y\")),\n        equalitiesToPairs(analysis.getEquiConditions())\n    );\n    Assert.assertEquals(\n        ImmutableList.of(),\n        exprsToStrings(analysis.getNonEquiConditions())\n    );\n  }\n","realPath":"processing/src/test/java/org/apache/druid/segment/join/JoinConditionAnalysisTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":66,"status":"B"},{"authorDate":"2020-01-17 05:14:20","commitOrder":1,"curCode":"  public void test_forExpression_andOfThreeConditions()\n  {\n    final String expression = \"(x == \\\"j.y\\\") && (x + y == \\\"j.z\\\") && (z == \\\"j.zz\\\")\";\n    final JoinConditionAnalysis analysis = analyze(expression);\n\n    Assert.assertEquals(expression, analysis.getOriginalExpression());\n    Assert.assertTrue(analysis.canHashJoin());\n    Assert.assertFalse(analysis.isAlwaysTrue());\n    Assert.assertFalse(analysis.isAlwaysFalse());\n    Assert.assertEquals(\n        ImmutableList.of(Pair.of(\"x\", \"y\"), Pair.of(\"(+ x y)\", \"z\"), Pair.of(\"z\", \"zz\")),\n        equalitiesToPairs(analysis.getEquiConditions())\n    );\n    Assert.assertEquals(\n        ImmutableList.of(),\n        exprsToStrings(analysis.getNonEquiConditions())\n    );\n  }\n","date":"2020-01-17 05:14:20","endLine":243,"groupId":"2098","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"test_forExpression_andOfThreeConditions","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/f5/ec8b8062ccf38f4c7121358137963498fbc071.src","preCode":"  public void test_forExpression_andOfThreeConditions()\n  {\n    final String expression = \"(x == \\\"j.y\\\") && (x + y == \\\"j.z\\\") && (z == \\\"j.zz\\\")\";\n    final JoinConditionAnalysis analysis = analyze(expression);\n\n    Assert.assertEquals(expression, analysis.getOriginalExpression());\n    Assert.assertTrue(analysis.canHashJoin());\n    Assert.assertFalse(analysis.isAlwaysTrue());\n    Assert.assertFalse(analysis.isAlwaysFalse());\n    Assert.assertEquals(\n        ImmutableList.of(Pair.of(\"x\", \"y\"), Pair.of(\"(+ x y)\", \"z\"), Pair.of(\"z\", \"zz\")),\n        equalitiesToPairs(analysis.getEquiConditions())\n    );\n    Assert.assertEquals(\n        ImmutableList.of(),\n        exprsToStrings(analysis.getNonEquiConditions())\n    );\n  }\n","realPath":"processing/src/test/java/org/apache/druid/segment/join/JoinConditionAnalysisTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":226,"status":"B"}],"commitId":"a87db7f353cdee4dfa9b541063f59d67706d1b07","commitMessage":"@@@Add HashJoinSegment.  a virtual segment for joins. (#9111)\n\n* Add HashJoinSegment.  a virtual segment for joins.\n\nAn initial step towards #8728. This patch adds enough functionality to implement a joining\ncursor on top of a normal datasource. It does not include enough to actually do a query. For\nthat.  future patches will need to wire this low-level functionality into the query language.\n\n* Fixups.\n\n* Fix missing format argument.\n\n* Various tests and minor improvements.\n\n* Changes.\n\n* Remove or add tests for unused stuff.\n\n* Fix up package locations.\n","date":"2020-01-17 05:14:20","modifiedFileCount":"34","status":"B","submitter":"Gian Merlino"},{"authorTime":"2020-01-30 14:31:29","codes":[{"authorDate":"2020-01-30 14:31:29","commitOrder":2,"curCode":"  public void test_forExpression_simpleFlipped()\n  {\n    final String expression = \"\\\"j.y\\\" == x\";\n    final JoinConditionAnalysis analysis = analyze(expression);\n\n    Assert.assertEquals(expression, analysis.getOriginalExpression());\n    Assert.assertTrue(analysis.canHashJoin());\n    Assert.assertFalse(analysis.isAlwaysTrue());\n    Assert.assertFalse(analysis.isAlwaysFalse());\n    Assert.assertEquals(\n        ImmutableList.of(Pair.of(\"x\", \"y\")),\n        equalitiesToPairs(analysis.getEquiConditions())\n    );\n    Assert.assertEquals(\n        ImmutableList.of(),\n        exprsToStrings(analysis.getNonEquiConditions())\n    );\n    Assert.assertEquals(analysis.getRightEquiConditionKeys(), ImmutableSet.of(\"y\"));\n  }\n","date":"2020-01-30 14:31:29","endLine":86,"groupId":"106015","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"test_forExpression_simpleFlipped","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/87/5f686af57731623dfe6c16e5c5d3c977609c44.src","preCode":"  public void test_forExpression_simpleFlipped()\n  {\n    final String expression = \"\\\"j.y\\\" == x\";\n    final JoinConditionAnalysis analysis = analyze(expression);\n\n    Assert.assertEquals(expression, analysis.getOriginalExpression());\n    Assert.assertTrue(analysis.canHashJoin());\n    Assert.assertFalse(analysis.isAlwaysTrue());\n    Assert.assertFalse(analysis.isAlwaysFalse());\n    Assert.assertEquals(\n        ImmutableList.of(Pair.of(\"x\", \"y\")),\n        equalitiesToPairs(analysis.getEquiConditions())\n    );\n    Assert.assertEquals(\n        ImmutableList.of(),\n        exprsToStrings(analysis.getNonEquiConditions())\n    );\n  }\n","realPath":"processing/src/test/java/org/apache/druid/segment/join/JoinConditionAnalysisTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":68,"status":"M"},{"authorDate":"2020-01-30 14:31:29","commitOrder":2,"curCode":"  public void test_forExpression_andOfThreeConditions()\n  {\n    final String expression = \"(x == \\\"j.y\\\") && (x + y == \\\"j.z\\\") && (z == \\\"j.zz\\\")\";\n    final JoinConditionAnalysis analysis = analyze(expression);\n\n    Assert.assertEquals(expression, analysis.getOriginalExpression());\n    Assert.assertTrue(analysis.canHashJoin());\n    Assert.assertFalse(analysis.isAlwaysTrue());\n    Assert.assertFalse(analysis.isAlwaysFalse());\n    Assert.assertEquals(\n        ImmutableList.of(Pair.of(\"x\", \"y\"), Pair.of(\"(+ x y)\", \"z\"), Pair.of(\"z\", \"zz\")),\n        equalitiesToPairs(analysis.getEquiConditions())\n    );\n    Assert.assertEquals(\n        ImmutableList.of(),\n        exprsToStrings(analysis.getNonEquiConditions())\n    );\n    Assert.assertEquals(analysis.getRightEquiConditionKeys(), ImmutableSet.of(\"y\", \"z\", \"zz\"));\n  }\n","date":"2020-01-30 14:31:29","endLine":254,"groupId":"106015","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"test_forExpression_andOfThreeConditions","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/87/5f686af57731623dfe6c16e5c5d3c977609c44.src","preCode":"  public void test_forExpression_andOfThreeConditions()\n  {\n    final String expression = \"(x == \\\"j.y\\\") && (x + y == \\\"j.z\\\") && (z == \\\"j.zz\\\")\";\n    final JoinConditionAnalysis analysis = analyze(expression);\n\n    Assert.assertEquals(expression, analysis.getOriginalExpression());\n    Assert.assertTrue(analysis.canHashJoin());\n    Assert.assertFalse(analysis.isAlwaysTrue());\n    Assert.assertFalse(analysis.isAlwaysFalse());\n    Assert.assertEquals(\n        ImmutableList.of(Pair.of(\"x\", \"y\"), Pair.of(\"(+ x y)\", \"z\"), Pair.of(\"z\", \"zz\")),\n        equalitiesToPairs(analysis.getEquiConditions())\n    );\n    Assert.assertEquals(\n        ImmutableList.of(),\n        exprsToStrings(analysis.getNonEquiConditions())\n    );\n  }\n","realPath":"processing/src/test/java/org/apache/druid/segment/join/JoinConditionAnalysisTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":236,"status":"M"}],"commitId":"6b44d4aa804997a47545b70ae44e83d3882bf819","commitMessage":"@@@Add getRightEquiConditionKeys to JoinConditionAnalysis (#9287)\n\n* Add getRightColumns to JoinConditionAnalysis\n\nThis change other implementations of JoinableFactory to ask the analysis\nfor the right key columns instead of having to calculate it themselves.\n\n* Address some review comments\n\n* more code review stuff\n","date":"2020-01-30 14:31:29","modifiedFileCount":"9","status":"M","submitter":"Suneet Saldanha"}]
