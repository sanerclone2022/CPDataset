[{"authorTime":"2018-08-31 00:56:26","codes":[{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  public void testJointDimMerge() throws Exception\n  {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    IncrementalIndexSchema rollupIndexSchema = new IncrementalIndexSchema.Builder()\n        .withMetrics(new CountAggregatorFactory(\"count\"))\n        .build();\n\n    IncrementalIndexSchema noRollupIndexSchema = new IncrementalIndexSchema.Builder()\n        .withMetrics(new CountAggregatorFactory(\"count\"))\n        .withRollup(false)\n        .build();\n\n    for (IncrementalIndexSchema indexSchema : Arrays.asList(rollupIndexSchema, noRollupIndexSchema)) {\n\n      IncrementalIndex toPersistA = new IncrementalIndex.Builder()\n          .setIndexSchema(indexSchema)\n          .setMaxRowCount(1000)\n          .buildOnheap();\n\n      toPersistA.add(\n          new MapBasedInputRow(\n              1,\n              Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n              ImmutableMap.of(\"d1\", \"\", \"d2\", \"\", \"d3\", \"310\", \"d7\", \"\", \"d9\", \"910\")\n          )\n      );\n      toPersistA.add(\n          new MapBasedInputRow(\n              2,\n              Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n              ImmutableMap.of(\"d2\", \"210\", \"d3\", \"311\", \"d7\", \"710\", \"d8\", \"810\", \"d9\", \"911\")\n          )\n      );\n\n      IncrementalIndex toPersistB = new IncrementalIndex.Builder()\n          .setIndexSchema(indexSchema)\n          .setMaxRowCount(1000)\n          .buildOnheap();\n\n      toPersistB.add(\n          new MapBasedInputRow(\n              3,\n              Arrays.asList(\"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n              ImmutableMap.of(\"d5\", \"520\", \"d6\", \"620\", \"d7\", \"720\", \"d8\", \"820\", \"d9\", \"920\")\n          )\n      );\n      toPersistB.add(\n          new MapBasedInputRow(\n              4,\n              Arrays.asList(\"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n              ImmutableMap.of(\"d5\", \"\", \"d6\", \"621\", \"d7\", \"\", \"d8\", \"821\", \"d9\", \"921\")\n          )\n      );\n      final File tmpDirA = temporaryFolder.newFolder();\n      final File tmpDirB = temporaryFolder.newFolder();\n      final File tmpDirMerged = temporaryFolder.newFolder();\n\n      QueryableIndex indexA = closer.closeLater(\n          indexIO.loadIndex(indexMerger.persist(toPersistA, tmpDirA, indexSpec, null))\n      );\n\n      QueryableIndex indexB = closer.closeLater(\n          indexIO.loadIndex(indexMerger.persist(toPersistB, tmpDirB, indexSpec, null))\n      );\n\n      final QueryableIndex merged = closer.closeLater(\n          indexIO.loadIndex(\n              indexMerger.mergeQueryableIndex(\n                  Arrays.asList(indexA, indexB),\n                  true,\n                  new AggregatorFactory[]{new CountAggregatorFactory(\"count\")},\n                  tmpDirMerged,\n                  indexSpec,\n                  null\n              )\n          )\n      );\n\n      final QueryableIndexIndexableAdapter adapter = new QueryableIndexIndexableAdapter(merged);\n      final List<DebugRow> rowList = RowIteratorHelper.toList(adapter.getRows());\n\n      if (NullHandling.replaceWithDefault()) {\n        Assert.assertEquals(\n            ImmutableList.of(\"d2\", \"d3\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableList.copyOf(adapter.getDimensionNames())\n        );\n      } else {\n        Assert.assertEquals(\n            ImmutableList.of(\"d1\", \"d2\", \"d3\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableList.copyOf(adapter.getDimensionNames())\n        );\n      }\n      Assert.assertEquals(4, rowList.size());\n      if (NullHandling.replaceWithDefault()) {\n        Assert.assertEquals(\n            Arrays.asList(null, \"310\", null, null, null, null, \"910\"),\n            rowList.get(0).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(\"210\", \"311\", null, null, \"710\", \"810\", \"911\"),\n            rowList.get(1).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, null, \"520\", \"620\", \"720\", \"820\", \"920\"),\n            rowList.get(2).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, null, null, \"621\", null, \"821\", \"921\"),\n            rowList.get(3).dimensionValues()\n        );\n\n        checkBitmapIndex(Arrays.asList(0, 2, 3), adapter.getBitmapIndex(\"d2\", null));\n        checkBitmapIndex(Arrays.asList(0, 1, 3), adapter.getBitmapIndex(\"d5\", null));\n        checkBitmapIndex(Arrays.asList(0, 3), adapter.getBitmapIndex(\"d7\", null));\n      } else {\n        Assert.assertEquals(\n            Arrays.asList(\"\", \"\", \"310\", null, null, \"\", null, \"910\"),\n            rowList.get(0).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, \"210\", \"311\", null, null, \"710\", \"810\", \"911\"),\n            rowList.get(1).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, null, null, \"520\", \"620\", \"720\", \"820\", \"920\"),\n            rowList.get(2).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, null, null, \"\", \"621\", \"\", \"821\", \"921\"),\n            rowList.get(3).dimensionValues()\n        );\n        checkBitmapIndex(Arrays.asList(2, 3), adapter.getBitmapIndex(\"d2\", null));\n        checkBitmapIndex(Arrays.asList(0, 1), adapter.getBitmapIndex(\"d5\", null));\n        checkBitmapIndex(Collections.emptyList(), adapter.getBitmapIndex(\"d7\", null));\n      }\n\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d2\", \"210\"));\n\n      checkBitmapIndex(Arrays.asList(2, 3), adapter.getBitmapIndex(\"d3\", null));\n      checkBitmapIndex(Collections.singletonList(0), adapter.getBitmapIndex(\"d3\", \"310\"));\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d3\", \"311\"));\n\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d5\", \"520\"));\n\n      checkBitmapIndex(Arrays.asList(0, 1), adapter.getBitmapIndex(\"d6\", null));\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d6\", \"620\"));\n      checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d6\", \"621\"));\n\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d7\", \"710\"));\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d7\", \"720\"));\n\n      checkBitmapIndex(Collections.singletonList(0), adapter.getBitmapIndex(\"d8\", null));\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d8\", \"810\"));\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d8\", \"820\"));\n      checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d8\", \"821\"));\n\n      checkBitmapIndex(Collections.emptyList(), adapter.getBitmapIndex(\"d9\", null));\n      checkBitmapIndex(Collections.singletonList(0), adapter.getBitmapIndex(\"d9\", \"910\"));\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d9\", \"911\"));\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d9\", \"920\"));\n      checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d9\", \"921\"));\n    }\n  }\n","date":"2018-08-31 00:56:26","endLine":1171,"groupId":"11353","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testJointDimMerge","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/f6/178958205afa64b09fe57e0ebe46be3d93714c.src","preCode":"  public void testJointDimMerge() throws Exception\n  {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    IncrementalIndexSchema rollupIndexSchema = new IncrementalIndexSchema.Builder()\n        .withMetrics(new CountAggregatorFactory(\"count\"))\n        .build();\n\n    IncrementalIndexSchema noRollupIndexSchema = new IncrementalIndexSchema.Builder()\n        .withMetrics(new CountAggregatorFactory(\"count\"))\n        .withRollup(false)\n        .build();\n\n    for (IncrementalIndexSchema indexSchema : Arrays.asList(rollupIndexSchema, noRollupIndexSchema)) {\n\n      IncrementalIndex toPersistA = new IncrementalIndex.Builder()\n          .setIndexSchema(indexSchema)\n          .setMaxRowCount(1000)\n          .buildOnheap();\n\n      toPersistA.add(\n          new MapBasedInputRow(\n              1,\n              Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n              ImmutableMap.of(\"d1\", \"\", \"d2\", \"\", \"d3\", \"310\", \"d7\", \"\", \"d9\", \"910\")\n          )\n      );\n      toPersistA.add(\n          new MapBasedInputRow(\n              2,\n              Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n              ImmutableMap.of(\"d2\", \"210\", \"d3\", \"311\", \"d7\", \"710\", \"d8\", \"810\", \"d9\", \"911\")\n          )\n      );\n\n      IncrementalIndex toPersistB = new IncrementalIndex.Builder()\n          .setIndexSchema(indexSchema)\n          .setMaxRowCount(1000)\n          .buildOnheap();\n\n      toPersistB.add(\n          new MapBasedInputRow(\n              3,\n              Arrays.asList(\"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n              ImmutableMap.of(\"d5\", \"520\", \"d6\", \"620\", \"d7\", \"720\", \"d8\", \"820\", \"d9\", \"920\")\n          )\n      );\n      toPersistB.add(\n          new MapBasedInputRow(\n              4,\n              Arrays.asList(\"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n              ImmutableMap.of(\"d5\", \"\", \"d6\", \"621\", \"d7\", \"\", \"d8\", \"821\", \"d9\", \"921\")\n          )\n      );\n      final File tmpDirA = temporaryFolder.newFolder();\n      final File tmpDirB = temporaryFolder.newFolder();\n      final File tmpDirMerged = temporaryFolder.newFolder();\n\n      QueryableIndex indexA = closer.closeLater(\n          indexIO.loadIndex(indexMerger.persist(toPersistA, tmpDirA, indexSpec, null))\n      );\n\n      QueryableIndex indexB = closer.closeLater(\n          indexIO.loadIndex(indexMerger.persist(toPersistB, tmpDirB, indexSpec, null))\n      );\n\n      final QueryableIndex merged = closer.closeLater(\n          indexIO.loadIndex(\n              indexMerger.mergeQueryableIndex(\n                  Arrays.asList(indexA, indexB),\n                  true,\n                  new AggregatorFactory[]{new CountAggregatorFactory(\"count\")},\n                  tmpDirMerged,\n                  indexSpec,\n                  null\n              )\n          )\n      );\n\n      final QueryableIndexIndexableAdapter adapter = new QueryableIndexIndexableAdapter(merged);\n      final List<DebugRow> rowList = RowIteratorHelper.toList(adapter.getRows());\n\n      if (NullHandling.replaceWithDefault()) {\n        Assert.assertEquals(\n            ImmutableList.of(\"d2\", \"d3\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableList.copyOf(adapter.getDimensionNames())\n        );\n      } else {\n        Assert.assertEquals(\n            ImmutableList.of(\"d1\", \"d2\", \"d3\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableList.copyOf(adapter.getDimensionNames())\n        );\n      }\n      Assert.assertEquals(4, rowList.size());\n      if (NullHandling.replaceWithDefault()) {\n        Assert.assertEquals(\n            Arrays.asList(null, \"310\", null, null, null, null, \"910\"),\n            rowList.get(0).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(\"210\", \"311\", null, null, \"710\", \"810\", \"911\"),\n            rowList.get(1).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, null, \"520\", \"620\", \"720\", \"820\", \"920\"),\n            rowList.get(2).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, null, null, \"621\", null, \"821\", \"921\"),\n            rowList.get(3).dimensionValues()\n        );\n\n        checkBitmapIndex(Arrays.asList(0, 2, 3), adapter.getBitmapIndex(\"d2\", null));\n        checkBitmapIndex(Arrays.asList(0, 1, 3), adapter.getBitmapIndex(\"d5\", null));\n        checkBitmapIndex(Arrays.asList(0, 3), adapter.getBitmapIndex(\"d7\", null));\n      } else {\n        Assert.assertEquals(\n            Arrays.asList(\"\", \"\", \"310\", null, null, \"\", null, \"910\"),\n            rowList.get(0).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, \"210\", \"311\", null, null, \"710\", \"810\", \"911\"),\n            rowList.get(1).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, null, null, \"520\", \"620\", \"720\", \"820\", \"920\"),\n            rowList.get(2).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, null, null, \"\", \"621\", \"\", \"821\", \"921\"),\n            rowList.get(3).dimensionValues()\n        );\n        checkBitmapIndex(Arrays.asList(2, 3), adapter.getBitmapIndex(\"d2\", null));\n        checkBitmapIndex(Arrays.asList(0, 1), adapter.getBitmapIndex(\"d5\", null));\n        checkBitmapIndex(Collections.emptyList(), adapter.getBitmapIndex(\"d7\", null));\n      }\n\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d2\", \"210\"));\n\n      checkBitmapIndex(Arrays.asList(2, 3), adapter.getBitmapIndex(\"d3\", null));\n      checkBitmapIndex(Collections.singletonList(0), adapter.getBitmapIndex(\"d3\", \"310\"));\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d3\", \"311\"));\n\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d5\", \"520\"));\n\n      checkBitmapIndex(Arrays.asList(0, 1), adapter.getBitmapIndex(\"d6\", null));\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d6\", \"620\"));\n      checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d6\", \"621\"));\n\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d7\", \"710\"));\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d7\", \"720\"));\n\n      checkBitmapIndex(Collections.singletonList(0), adapter.getBitmapIndex(\"d8\", null));\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d8\", \"810\"));\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d8\", \"820\"));\n      checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d8\", \"821\"));\n\n      checkBitmapIndex(Collections.emptyList(), adapter.getBitmapIndex(\"d9\", null));\n      checkBitmapIndex(Collections.singletonList(0), adapter.getBitmapIndex(\"d9\", \"910\"));\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d9\", \"911\"));\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d9\", \"920\"));\n      checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d9\", \"921\"));\n    }\n  }\n","realPath":"processing/src/test/java/org/apache/druid/segment/IndexMergerTestBase.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1002,"status":"B"},{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  public void testNoRollupMergeWithDuplicateRow() throws Exception\n  {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    IncrementalIndexSchema indexSchema = new IncrementalIndexSchema.Builder()\n        .withMetrics(new CountAggregatorFactory(\"count\"))\n        .withRollup(false)\n        .build();\n    IncrementalIndex toPersistA = new IncrementalIndex.Builder()\n        .setIndexSchema(indexSchema)\n        .setMaxRowCount(1000)\n        .buildOnheap();\n\n    toPersistA.add(\n        new MapBasedInputRow(\n            1,\n            Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableMap.of(\n                \"d1\", \"\", \"d2\", \"\", \"d3\", \"310\", \"d7\", \"\", \"d9\", \"910\"\n            )\n        )\n    );\n    toPersistA.add(\n        new MapBasedInputRow(\n            1,\n            Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableMap.of(\n                \"d1\", \"\", \"d2\", \"\", \"d3\", \"310\", \"d7\", \"\", \"d9\", \"910\"\n            )\n        )\n    );\n\n    IncrementalIndex toPersistB = new IncrementalIndex.Builder()\n        .setIndexSchema(indexSchema)\n        .setMaxRowCount(1000)\n        .buildOnheap();\n\n    toPersistB.add(\n        new MapBasedInputRow(\n            1,\n            Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableMap.of(\n                \"d1\", \"\", \"d2\", \"\", \"d3\", \"310\", \"d7\", \"\", \"d9\", \"910\"\n            )\n        )\n    );\n    toPersistB.add(\n        new MapBasedInputRow(\n            4,\n            Arrays.asList(\"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableMap.of(\n                \"d5\", \"\", \"d6\", \"621\", \"d7\", \"\", \"d8\", \"821\", \"d9\", \"921\"\n            )\n        )\n    );\n    final File tmpDirA = temporaryFolder.newFolder();\n    final File tmpDirB = temporaryFolder.newFolder();\n    final File tmpDirMerged = temporaryFolder.newFolder();\n\n    QueryableIndex indexA = closer.closeLater(\n        indexIO.loadIndex(indexMerger.persist(toPersistA, tmpDirA, indexSpec, null))\n    );\n\n    QueryableIndex indexB = closer.closeLater(\n        indexIO.loadIndex(indexMerger.persist(toPersistB, tmpDirB, indexSpec, null))\n    );\n\n    final QueryableIndex merged = closer.closeLater(\n        indexIO.loadIndex(\n            indexMerger.mergeQueryableIndex(\n                Arrays.asList(indexA, indexB),\n                false,\n                new AggregatorFactory[]{new CountAggregatorFactory(\"count\")},\n                tmpDirMerged,\n                indexSpec,\n                null\n            )\n        )\n    );\n\n    final QueryableIndexIndexableAdapter adapter = new QueryableIndexIndexableAdapter(merged);\n    final List<DebugRow> rowList = RowIteratorHelper.toList(adapter.getRows());\n\n    if (NullHandling.replaceWithDefault()) {\n      Assert.assertEquals(\n          ImmutableList.of(\"d3\", \"d6\", \"d8\", \"d9\"),\n          ImmutableList.copyOf(adapter.getDimensionNames())\n      );\n    } else {\n      Assert.assertEquals(\n          ImmutableList.of(\"d1\", \"d2\", \"d3\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n          ImmutableList.copyOf(adapter.getDimensionNames())\n      );\n    }\n\n    Assert.assertEquals(4, rowList.size());\n    if (NullHandling.replaceWithDefault()) {\n      Assert.assertEquals(Arrays.asList(\"310\", null, null, \"910\"), rowList.get(0).dimensionValues());\n      Assert.assertEquals(Arrays.asList(\"310\", null, null, \"910\"), rowList.get(1).dimensionValues());\n      Assert.assertEquals(Arrays.asList(\"310\", null, null, \"910\"), rowList.get(2).dimensionValues());\n      Assert.assertEquals(Arrays.asList(null, \"621\", \"821\", \"921\"), rowList.get(3).dimensionValues());\n    } else {\n      Assert.assertEquals(Arrays.asList(\"\", \"\", \"310\", null, null, \"\", null, \"910\"), rowList.get(0).dimensionValues());\n      Assert.assertEquals(Arrays.asList(\"\", \"\", \"310\", null, null, \"\", null, \"910\"), rowList.get(1).dimensionValues());\n      Assert.assertEquals(Arrays.asList(\"\", \"\", \"310\", null, null, \"\", null, \"910\"), rowList.get(2).dimensionValues());\n      Assert.assertEquals(\n          Arrays.asList(null, null, null, \"\", \"621\", \"\", \"821\", \"921\"),\n          rowList.get(3).dimensionValues()\n      );\n    }\n\n    checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d3\", null));\n    checkBitmapIndex(Arrays.asList(0, 1, 2), adapter.getBitmapIndex(\"d3\", \"310\"));\n\n    checkBitmapIndex(Arrays.asList(0, 1, 2), adapter.getBitmapIndex(\"d6\", null));\n    checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d6\", \"621\"));\n\n    checkBitmapIndex(Arrays.asList(0, 1, 2), adapter.getBitmapIndex(\"d8\", null));\n    checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d8\", \"821\"));\n\n    checkBitmapIndex(Collections.emptyList(), adapter.getBitmapIndex(\"d9\", null));\n    checkBitmapIndex(Arrays.asList(0, 1, 2), adapter.getBitmapIndex(\"d9\", \"910\"));\n    checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d9\", \"921\"));\n  }\n","date":"2018-08-31 00:56:26","endLine":1303,"groupId":"13760","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testNoRollupMergeWithDuplicateRow","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/f6/178958205afa64b09fe57e0ebe46be3d93714c.src","preCode":"  public void testNoRollupMergeWithDuplicateRow() throws Exception\n  {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    IncrementalIndexSchema indexSchema = new IncrementalIndexSchema.Builder()\n        .withMetrics(new CountAggregatorFactory(\"count\"))\n        .withRollup(false)\n        .build();\n    IncrementalIndex toPersistA = new IncrementalIndex.Builder()\n        .setIndexSchema(indexSchema)\n        .setMaxRowCount(1000)\n        .buildOnheap();\n\n    toPersistA.add(\n        new MapBasedInputRow(\n            1,\n            Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableMap.of(\n                \"d1\", \"\", \"d2\", \"\", \"d3\", \"310\", \"d7\", \"\", \"d9\", \"910\"\n            )\n        )\n    );\n    toPersistA.add(\n        new MapBasedInputRow(\n            1,\n            Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableMap.of(\n                \"d1\", \"\", \"d2\", \"\", \"d3\", \"310\", \"d7\", \"\", \"d9\", \"910\"\n            )\n        )\n    );\n\n    IncrementalIndex toPersistB = new IncrementalIndex.Builder()\n        .setIndexSchema(indexSchema)\n        .setMaxRowCount(1000)\n        .buildOnheap();\n\n    toPersistB.add(\n        new MapBasedInputRow(\n            1,\n            Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableMap.of(\n                \"d1\", \"\", \"d2\", \"\", \"d3\", \"310\", \"d7\", \"\", \"d9\", \"910\"\n            )\n        )\n    );\n    toPersistB.add(\n        new MapBasedInputRow(\n            4,\n            Arrays.asList(\"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableMap.of(\n                \"d5\", \"\", \"d6\", \"621\", \"d7\", \"\", \"d8\", \"821\", \"d9\", \"921\"\n            )\n        )\n    );\n    final File tmpDirA = temporaryFolder.newFolder();\n    final File tmpDirB = temporaryFolder.newFolder();\n    final File tmpDirMerged = temporaryFolder.newFolder();\n\n    QueryableIndex indexA = closer.closeLater(\n        indexIO.loadIndex(indexMerger.persist(toPersistA, tmpDirA, indexSpec, null))\n    );\n\n    QueryableIndex indexB = closer.closeLater(\n        indexIO.loadIndex(indexMerger.persist(toPersistB, tmpDirB, indexSpec, null))\n    );\n\n    final QueryableIndex merged = closer.closeLater(\n        indexIO.loadIndex(\n            indexMerger.mergeQueryableIndex(\n                Arrays.asList(indexA, indexB),\n                false,\n                new AggregatorFactory[]{new CountAggregatorFactory(\"count\")},\n                tmpDirMerged,\n                indexSpec,\n                null\n            )\n        )\n    );\n\n    final QueryableIndexIndexableAdapter adapter = new QueryableIndexIndexableAdapter(merged);\n    final List<DebugRow> rowList = RowIteratorHelper.toList(adapter.getRows());\n\n    if (NullHandling.replaceWithDefault()) {\n      Assert.assertEquals(\n          ImmutableList.of(\"d3\", \"d6\", \"d8\", \"d9\"),\n          ImmutableList.copyOf(adapter.getDimensionNames())\n      );\n    } else {\n      Assert.assertEquals(\n          ImmutableList.of(\"d1\", \"d2\", \"d3\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n          ImmutableList.copyOf(adapter.getDimensionNames())\n      );\n    }\n\n    Assert.assertEquals(4, rowList.size());\n    if (NullHandling.replaceWithDefault()) {\n      Assert.assertEquals(Arrays.asList(\"310\", null, null, \"910\"), rowList.get(0).dimensionValues());\n      Assert.assertEquals(Arrays.asList(\"310\", null, null, \"910\"), rowList.get(1).dimensionValues());\n      Assert.assertEquals(Arrays.asList(\"310\", null, null, \"910\"), rowList.get(2).dimensionValues());\n      Assert.assertEquals(Arrays.asList(null, \"621\", \"821\", \"921\"), rowList.get(3).dimensionValues());\n    } else {\n      Assert.assertEquals(Arrays.asList(\"\", \"\", \"310\", null, null, \"\", null, \"910\"), rowList.get(0).dimensionValues());\n      Assert.assertEquals(Arrays.asList(\"\", \"\", \"310\", null, null, \"\", null, \"910\"), rowList.get(1).dimensionValues());\n      Assert.assertEquals(Arrays.asList(\"\", \"\", \"310\", null, null, \"\", null, \"910\"), rowList.get(2).dimensionValues());\n      Assert.assertEquals(\n          Arrays.asList(null, null, null, \"\", \"621\", \"\", \"821\", \"921\"),\n          rowList.get(3).dimensionValues()\n      );\n    }\n\n    checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d3\", null));\n    checkBitmapIndex(Arrays.asList(0, 1, 2), adapter.getBitmapIndex(\"d3\", \"310\"));\n\n    checkBitmapIndex(Arrays.asList(0, 1, 2), adapter.getBitmapIndex(\"d6\", null));\n    checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d6\", \"621\"));\n\n    checkBitmapIndex(Arrays.asList(0, 1, 2), adapter.getBitmapIndex(\"d8\", null));\n    checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d8\", \"821\"));\n\n    checkBitmapIndex(Collections.emptyList(), adapter.getBitmapIndex(\"d9\", null));\n    checkBitmapIndex(Arrays.asList(0, 1, 2), adapter.getBitmapIndex(\"d9\", \"910\"));\n    checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d9\", \"921\"));\n  }\n","realPath":"processing/src/test/java/org/apache/druid/segment/IndexMergerTestBase.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1174,"status":"B"}],"commitId":"431d3d8497f9079857c3baa7ae7ab4cb44a22355","commitMessage":"@@@Rename io.druid to org.apache.druid. (#6266)\n\n* Rename io.druid to org.apache.druid.\n\n* Fix META-INF files and remove some benchmark results.\n\n* MonitorsConfig update for metrics package migration.\n\n* Reorder some dimensions in inner queries for some reason.\n\n* Fix protobuf tests.\n","date":"2018-08-31 00:56:26","modifiedFileCount":"5","status":"B","submitter":"Gian Merlino"},{"authorTime":"2021-01-06 14:19:09","codes":[{"authorDate":"2021-01-06 14:19:09","commitOrder":2,"curCode":"  public void testJointDimMerge() throws Exception\n  {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    IncrementalIndexSchema rollupIndexSchema = new IncrementalIndexSchema.Builder()\n        .withMetrics(new CountAggregatorFactory(\"count\"))\n        .build();\n\n    IncrementalIndexSchema noRollupIndexSchema = new IncrementalIndexSchema.Builder()\n        .withMetrics(new CountAggregatorFactory(\"count\"))\n        .withRollup(false)\n        .build();\n\n    for (IncrementalIndexSchema indexSchema : Arrays.asList(rollupIndexSchema, noRollupIndexSchema)) {\n\n      IncrementalIndex toPersistA = new IncrementalIndex.Builder()\n          .setIndexSchema(indexSchema)\n          .setMaxRowCount(1000)\n          .buildOnheap();\n\n      toPersistA.add(\n          new MapBasedInputRow(\n              1,\n              Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n              ImmutableMap.of(\"d1\", \"\", \"d2\", \"\", \"d3\", \"310\", \"d7\", \"\", \"d9\", \"910\")\n          )\n      );\n      toPersistA.add(\n          new MapBasedInputRow(\n              2,\n              Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n              ImmutableMap.of(\"d2\", \"210\", \"d3\", \"311\", \"d7\", \"710\", \"d8\", \"810\", \"d9\", \"911\")\n          )\n      );\n\n      IncrementalIndex toPersistB = new IncrementalIndex.Builder()\n          .setIndexSchema(indexSchema)\n          .setMaxRowCount(1000)\n          .buildOnheap();\n\n      toPersistB.add(\n          new MapBasedInputRow(\n              3,\n              Arrays.asList(\"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n              ImmutableMap.of(\"d5\", \"520\", \"d6\", \"620\", \"d7\", \"720\", \"d8\", \"820\", \"d9\", \"920\")\n          )\n      );\n      toPersistB.add(\n          new MapBasedInputRow(\n              4,\n              Arrays.asList(\"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n              ImmutableMap.of(\"d5\", \"\", \"d6\", \"621\", \"d7\", \"\", \"d8\", \"821\", \"d9\", \"921\")\n          )\n      );\n      final File tmpDirA = temporaryFolder.newFolder();\n      final File tmpDirB = temporaryFolder.newFolder();\n      final File tmpDirMerged = temporaryFolder.newFolder();\n\n      QueryableIndex indexA = closer.closeLater(\n          indexIO.loadIndex(indexMerger.persist(toPersistA, tmpDirA, indexSpec, null))\n      );\n\n      QueryableIndex indexB = closer.closeLater(\n          indexIO.loadIndex(indexMerger.persist(toPersistB, tmpDirB, indexSpec, null))\n      );\n\n      final QueryableIndex merged = closer.closeLater(\n          indexIO.loadIndex(\n              indexMerger.mergeQueryableIndex(\n                  Arrays.asList(indexA, indexB),\n                  true,\n                  new AggregatorFactory[]{new CountAggregatorFactory(\"count\")},\n                  tmpDirMerged,\n                  indexSpec,\n                  null,\n                  -1\n              )\n          )\n      );\n\n      final QueryableIndexIndexableAdapter adapter = new QueryableIndexIndexableAdapter(merged);\n      final List<DebugRow> rowList = RowIteratorHelper.toList(adapter.getRows());\n\n      if (NullHandling.replaceWithDefault()) {\n        Assert.assertEquals(\n            ImmutableList.of(\"d2\", \"d3\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableList.copyOf(adapter.getDimensionNames())\n        );\n      } else {\n        Assert.assertEquals(\n            ImmutableList.of(\"d1\", \"d2\", \"d3\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableList.copyOf(adapter.getDimensionNames())\n        );\n      }\n      Assert.assertEquals(4, rowList.size());\n      if (NullHandling.replaceWithDefault()) {\n        Assert.assertEquals(\n            Arrays.asList(null, \"310\", null, null, null, null, \"910\"),\n            rowList.get(0).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(\"210\", \"311\", null, null, \"710\", \"810\", \"911\"),\n            rowList.get(1).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, null, \"520\", \"620\", \"720\", \"820\", \"920\"),\n            rowList.get(2).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, null, null, \"621\", null, \"821\", \"921\"),\n            rowList.get(3).dimensionValues()\n        );\n\n        checkBitmapIndex(Arrays.asList(0, 2, 3), adapter.getBitmapIndex(\"d2\", null));\n        checkBitmapIndex(Arrays.asList(0, 1, 3), adapter.getBitmapIndex(\"d5\", null));\n        checkBitmapIndex(Arrays.asList(0, 3), adapter.getBitmapIndex(\"d7\", null));\n      } else {\n        Assert.assertEquals(\n            Arrays.asList(\"\", \"\", \"310\", null, null, \"\", null, \"910\"),\n            rowList.get(0).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, \"210\", \"311\", null, null, \"710\", \"810\", \"911\"),\n            rowList.get(1).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, null, null, \"520\", \"620\", \"720\", \"820\", \"920\"),\n            rowList.get(2).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, null, null, \"\", \"621\", \"\", \"821\", \"921\"),\n            rowList.get(3).dimensionValues()\n        );\n        checkBitmapIndex(Arrays.asList(2, 3), adapter.getBitmapIndex(\"d2\", null));\n        checkBitmapIndex(Arrays.asList(0, 1), adapter.getBitmapIndex(\"d5\", null));\n        checkBitmapIndex(Collections.emptyList(), adapter.getBitmapIndex(\"d7\", null));\n      }\n\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d2\", \"210\"));\n\n      checkBitmapIndex(Arrays.asList(2, 3), adapter.getBitmapIndex(\"d3\", null));\n      checkBitmapIndex(Collections.singletonList(0), adapter.getBitmapIndex(\"d3\", \"310\"));\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d3\", \"311\"));\n\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d5\", \"520\"));\n\n      checkBitmapIndex(Arrays.asList(0, 1), adapter.getBitmapIndex(\"d6\", null));\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d6\", \"620\"));\n      checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d6\", \"621\"));\n\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d7\", \"710\"));\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d7\", \"720\"));\n\n      checkBitmapIndex(Collections.singletonList(0), adapter.getBitmapIndex(\"d8\", null));\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d8\", \"810\"));\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d8\", \"820\"));\n      checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d8\", \"821\"));\n\n      checkBitmapIndex(Collections.emptyList(), adapter.getBitmapIndex(\"d9\", null));\n      checkBitmapIndex(Collections.singletonList(0), adapter.getBitmapIndex(\"d9\", \"910\"));\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d9\", \"911\"));\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d9\", \"920\"));\n      checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d9\", \"921\"));\n    }\n  }\n","date":"2021-01-06 14:19:09","endLine":1179,"groupId":"11353","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testJointDimMerge","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/b1/6429f20ca529bbd9164de23ddb2068e18235fb.src","preCode":"  public void testJointDimMerge() throws Exception\n  {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    IncrementalIndexSchema rollupIndexSchema = new IncrementalIndexSchema.Builder()\n        .withMetrics(new CountAggregatorFactory(\"count\"))\n        .build();\n\n    IncrementalIndexSchema noRollupIndexSchema = new IncrementalIndexSchema.Builder()\n        .withMetrics(new CountAggregatorFactory(\"count\"))\n        .withRollup(false)\n        .build();\n\n    for (IncrementalIndexSchema indexSchema : Arrays.asList(rollupIndexSchema, noRollupIndexSchema)) {\n\n      IncrementalIndex toPersistA = new IncrementalIndex.Builder()\n          .setIndexSchema(indexSchema)\n          .setMaxRowCount(1000)\n          .buildOnheap();\n\n      toPersistA.add(\n          new MapBasedInputRow(\n              1,\n              Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n              ImmutableMap.of(\"d1\", \"\", \"d2\", \"\", \"d3\", \"310\", \"d7\", \"\", \"d9\", \"910\")\n          )\n      );\n      toPersistA.add(\n          new MapBasedInputRow(\n              2,\n              Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n              ImmutableMap.of(\"d2\", \"210\", \"d3\", \"311\", \"d7\", \"710\", \"d8\", \"810\", \"d9\", \"911\")\n          )\n      );\n\n      IncrementalIndex toPersistB = new IncrementalIndex.Builder()\n          .setIndexSchema(indexSchema)\n          .setMaxRowCount(1000)\n          .buildOnheap();\n\n      toPersistB.add(\n          new MapBasedInputRow(\n              3,\n              Arrays.asList(\"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n              ImmutableMap.of(\"d5\", \"520\", \"d6\", \"620\", \"d7\", \"720\", \"d8\", \"820\", \"d9\", \"920\")\n          )\n      );\n      toPersistB.add(\n          new MapBasedInputRow(\n              4,\n              Arrays.asList(\"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n              ImmutableMap.of(\"d5\", \"\", \"d6\", \"621\", \"d7\", \"\", \"d8\", \"821\", \"d9\", \"921\")\n          )\n      );\n      final File tmpDirA = temporaryFolder.newFolder();\n      final File tmpDirB = temporaryFolder.newFolder();\n      final File tmpDirMerged = temporaryFolder.newFolder();\n\n      QueryableIndex indexA = closer.closeLater(\n          indexIO.loadIndex(indexMerger.persist(toPersistA, tmpDirA, indexSpec, null))\n      );\n\n      QueryableIndex indexB = closer.closeLater(\n          indexIO.loadIndex(indexMerger.persist(toPersistB, tmpDirB, indexSpec, null))\n      );\n\n      final QueryableIndex merged = closer.closeLater(\n          indexIO.loadIndex(\n              indexMerger.mergeQueryableIndex(\n                  Arrays.asList(indexA, indexB),\n                  true,\n                  new AggregatorFactory[]{new CountAggregatorFactory(\"count\")},\n                  tmpDirMerged,\n                  indexSpec,\n                  null\n              )\n          )\n      );\n\n      final QueryableIndexIndexableAdapter adapter = new QueryableIndexIndexableAdapter(merged);\n      final List<DebugRow> rowList = RowIteratorHelper.toList(adapter.getRows());\n\n      if (NullHandling.replaceWithDefault()) {\n        Assert.assertEquals(\n            ImmutableList.of(\"d2\", \"d3\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableList.copyOf(adapter.getDimensionNames())\n        );\n      } else {\n        Assert.assertEquals(\n            ImmutableList.of(\"d1\", \"d2\", \"d3\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableList.copyOf(adapter.getDimensionNames())\n        );\n      }\n      Assert.assertEquals(4, rowList.size());\n      if (NullHandling.replaceWithDefault()) {\n        Assert.assertEquals(\n            Arrays.asList(null, \"310\", null, null, null, null, \"910\"),\n            rowList.get(0).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(\"210\", \"311\", null, null, \"710\", \"810\", \"911\"),\n            rowList.get(1).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, null, \"520\", \"620\", \"720\", \"820\", \"920\"),\n            rowList.get(2).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, null, null, \"621\", null, \"821\", \"921\"),\n            rowList.get(3).dimensionValues()\n        );\n\n        checkBitmapIndex(Arrays.asList(0, 2, 3), adapter.getBitmapIndex(\"d2\", null));\n        checkBitmapIndex(Arrays.asList(0, 1, 3), adapter.getBitmapIndex(\"d5\", null));\n        checkBitmapIndex(Arrays.asList(0, 3), adapter.getBitmapIndex(\"d7\", null));\n      } else {\n        Assert.assertEquals(\n            Arrays.asList(\"\", \"\", \"310\", null, null, \"\", null, \"910\"),\n            rowList.get(0).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, \"210\", \"311\", null, null, \"710\", \"810\", \"911\"),\n            rowList.get(1).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, null, null, \"520\", \"620\", \"720\", \"820\", \"920\"),\n            rowList.get(2).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, null, null, \"\", \"621\", \"\", \"821\", \"921\"),\n            rowList.get(3).dimensionValues()\n        );\n        checkBitmapIndex(Arrays.asList(2, 3), adapter.getBitmapIndex(\"d2\", null));\n        checkBitmapIndex(Arrays.asList(0, 1), adapter.getBitmapIndex(\"d5\", null));\n        checkBitmapIndex(Collections.emptyList(), adapter.getBitmapIndex(\"d7\", null));\n      }\n\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d2\", \"210\"));\n\n      checkBitmapIndex(Arrays.asList(2, 3), adapter.getBitmapIndex(\"d3\", null));\n      checkBitmapIndex(Collections.singletonList(0), adapter.getBitmapIndex(\"d3\", \"310\"));\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d3\", \"311\"));\n\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d5\", \"520\"));\n\n      checkBitmapIndex(Arrays.asList(0, 1), adapter.getBitmapIndex(\"d6\", null));\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d6\", \"620\"));\n      checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d6\", \"621\"));\n\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d7\", \"710\"));\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d7\", \"720\"));\n\n      checkBitmapIndex(Collections.singletonList(0), adapter.getBitmapIndex(\"d8\", null));\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d8\", \"810\"));\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d8\", \"820\"));\n      checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d8\", \"821\"));\n\n      checkBitmapIndex(Collections.emptyList(), adapter.getBitmapIndex(\"d9\", null));\n      checkBitmapIndex(Collections.singletonList(0), adapter.getBitmapIndex(\"d9\", \"910\"));\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d9\", \"911\"));\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d9\", \"920\"));\n      checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d9\", \"921\"));\n    }\n  }\n","realPath":"processing/src/test/java/org/apache/druid/segment/IndexMergerTestBase.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1009,"status":"M"},{"authorDate":"2021-01-06 14:19:09","commitOrder":2,"curCode":"  public void testNoRollupMergeWithDuplicateRow() throws Exception\n  {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    IncrementalIndexSchema indexSchema = new IncrementalIndexSchema.Builder()\n        .withMetrics(new CountAggregatorFactory(\"count\"))\n        .withRollup(false)\n        .build();\n    IncrementalIndex toPersistA = new IncrementalIndex.Builder()\n        .setIndexSchema(indexSchema)\n        .setMaxRowCount(1000)\n        .buildOnheap();\n\n    toPersistA.add(\n        new MapBasedInputRow(\n            1,\n            Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableMap.of(\n                \"d1\", \"\", \"d2\", \"\", \"d3\", \"310\", \"d7\", \"\", \"d9\", \"910\"\n            )\n        )\n    );\n    toPersistA.add(\n        new MapBasedInputRow(\n            1,\n            Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableMap.of(\n                \"d1\", \"\", \"d2\", \"\", \"d3\", \"310\", \"d7\", \"\", \"d9\", \"910\"\n            )\n        )\n    );\n\n    IncrementalIndex toPersistB = new IncrementalIndex.Builder()\n        .setIndexSchema(indexSchema)\n        .setMaxRowCount(1000)\n        .buildOnheap();\n\n    toPersistB.add(\n        new MapBasedInputRow(\n            1,\n            Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableMap.of(\n                \"d1\", \"\", \"d2\", \"\", \"d3\", \"310\", \"d7\", \"\", \"d9\", \"910\"\n            )\n        )\n    );\n    toPersistB.add(\n        new MapBasedInputRow(\n            4,\n            Arrays.asList(\"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableMap.of(\n                \"d5\", \"\", \"d6\", \"621\", \"d7\", \"\", \"d8\", \"821\", \"d9\", \"921\"\n            )\n        )\n    );\n    final File tmpDirA = temporaryFolder.newFolder();\n    final File tmpDirB = temporaryFolder.newFolder();\n    final File tmpDirMerged = temporaryFolder.newFolder();\n\n    QueryableIndex indexA = closer.closeLater(\n        indexIO.loadIndex(indexMerger.persist(toPersistA, tmpDirA, indexSpec, null))\n    );\n\n    QueryableIndex indexB = closer.closeLater(\n        indexIO.loadIndex(indexMerger.persist(toPersistB, tmpDirB, indexSpec, null))\n    );\n\n    final QueryableIndex merged = closer.closeLater(\n        indexIO.loadIndex(\n            indexMerger.mergeQueryableIndex(\n                Arrays.asList(indexA, indexB),\n                false,\n                new AggregatorFactory[]{new CountAggregatorFactory(\"count\")},\n                tmpDirMerged,\n                indexSpec,\n                null,\n                -1\n            )\n        )\n    );\n\n    final QueryableIndexIndexableAdapter adapter = new QueryableIndexIndexableAdapter(merged);\n    final List<DebugRow> rowList = RowIteratorHelper.toList(adapter.getRows());\n\n    if (NullHandling.replaceWithDefault()) {\n      Assert.assertEquals(\n          ImmutableList.of(\"d3\", \"d6\", \"d8\", \"d9\"),\n          ImmutableList.copyOf(adapter.getDimensionNames())\n      );\n    } else {\n      Assert.assertEquals(\n          ImmutableList.of(\"d1\", \"d2\", \"d3\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n          ImmutableList.copyOf(adapter.getDimensionNames())\n      );\n    }\n\n    Assert.assertEquals(4, rowList.size());\n    if (NullHandling.replaceWithDefault()) {\n      Assert.assertEquals(Arrays.asList(\"310\", null, null, \"910\"), rowList.get(0).dimensionValues());\n      Assert.assertEquals(Arrays.asList(\"310\", null, null, \"910\"), rowList.get(1).dimensionValues());\n      Assert.assertEquals(Arrays.asList(\"310\", null, null, \"910\"), rowList.get(2).dimensionValues());\n      Assert.assertEquals(Arrays.asList(null, \"621\", \"821\", \"921\"), rowList.get(3).dimensionValues());\n    } else {\n      Assert.assertEquals(Arrays.asList(\"\", \"\", \"310\", null, null, \"\", null, \"910\"), rowList.get(0).dimensionValues());\n      Assert.assertEquals(Arrays.asList(\"\", \"\", \"310\", null, null, \"\", null, \"910\"), rowList.get(1).dimensionValues());\n      Assert.assertEquals(Arrays.asList(\"\", \"\", \"310\", null, null, \"\", null, \"910\"), rowList.get(2).dimensionValues());\n      Assert.assertEquals(\n          Arrays.asList(null, null, null, \"\", \"621\", \"\", \"821\", \"921\"),\n          rowList.get(3).dimensionValues()\n      );\n    }\n\n    checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d3\", null));\n    checkBitmapIndex(Arrays.asList(0, 1, 2), adapter.getBitmapIndex(\"d3\", \"310\"));\n\n    checkBitmapIndex(Arrays.asList(0, 1, 2), adapter.getBitmapIndex(\"d6\", null));\n    checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d6\", \"621\"));\n\n    checkBitmapIndex(Arrays.asList(0, 1, 2), adapter.getBitmapIndex(\"d8\", null));\n    checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d8\", \"821\"));\n\n    checkBitmapIndex(Collections.emptyList(), adapter.getBitmapIndex(\"d9\", null));\n    checkBitmapIndex(Arrays.asList(0, 1, 2), adapter.getBitmapIndex(\"d9\", \"910\"));\n    checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d9\", \"921\"));\n  }\n","date":"2021-01-06 14:19:09","endLine":1312,"groupId":"13760","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testNoRollupMergeWithDuplicateRow","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/b1/6429f20ca529bbd9164de23ddb2068e18235fb.src","preCode":"  public void testNoRollupMergeWithDuplicateRow() throws Exception\n  {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    IncrementalIndexSchema indexSchema = new IncrementalIndexSchema.Builder()\n        .withMetrics(new CountAggregatorFactory(\"count\"))\n        .withRollup(false)\n        .build();\n    IncrementalIndex toPersistA = new IncrementalIndex.Builder()\n        .setIndexSchema(indexSchema)\n        .setMaxRowCount(1000)\n        .buildOnheap();\n\n    toPersistA.add(\n        new MapBasedInputRow(\n            1,\n            Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableMap.of(\n                \"d1\", \"\", \"d2\", \"\", \"d3\", \"310\", \"d7\", \"\", \"d9\", \"910\"\n            )\n        )\n    );\n    toPersistA.add(\n        new MapBasedInputRow(\n            1,\n            Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableMap.of(\n                \"d1\", \"\", \"d2\", \"\", \"d3\", \"310\", \"d7\", \"\", \"d9\", \"910\"\n            )\n        )\n    );\n\n    IncrementalIndex toPersistB = new IncrementalIndex.Builder()\n        .setIndexSchema(indexSchema)\n        .setMaxRowCount(1000)\n        .buildOnheap();\n\n    toPersistB.add(\n        new MapBasedInputRow(\n            1,\n            Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableMap.of(\n                \"d1\", \"\", \"d2\", \"\", \"d3\", \"310\", \"d7\", \"\", \"d9\", \"910\"\n            )\n        )\n    );\n    toPersistB.add(\n        new MapBasedInputRow(\n            4,\n            Arrays.asList(\"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableMap.of(\n                \"d5\", \"\", \"d6\", \"621\", \"d7\", \"\", \"d8\", \"821\", \"d9\", \"921\"\n            )\n        )\n    );\n    final File tmpDirA = temporaryFolder.newFolder();\n    final File tmpDirB = temporaryFolder.newFolder();\n    final File tmpDirMerged = temporaryFolder.newFolder();\n\n    QueryableIndex indexA = closer.closeLater(\n        indexIO.loadIndex(indexMerger.persist(toPersistA, tmpDirA, indexSpec, null))\n    );\n\n    QueryableIndex indexB = closer.closeLater(\n        indexIO.loadIndex(indexMerger.persist(toPersistB, tmpDirB, indexSpec, null))\n    );\n\n    final QueryableIndex merged = closer.closeLater(\n        indexIO.loadIndex(\n            indexMerger.mergeQueryableIndex(\n                Arrays.asList(indexA, indexB),\n                false,\n                new AggregatorFactory[]{new CountAggregatorFactory(\"count\")},\n                tmpDirMerged,\n                indexSpec,\n                null\n            )\n        )\n    );\n\n    final QueryableIndexIndexableAdapter adapter = new QueryableIndexIndexableAdapter(merged);\n    final List<DebugRow> rowList = RowIteratorHelper.toList(adapter.getRows());\n\n    if (NullHandling.replaceWithDefault()) {\n      Assert.assertEquals(\n          ImmutableList.of(\"d3\", \"d6\", \"d8\", \"d9\"),\n          ImmutableList.copyOf(adapter.getDimensionNames())\n      );\n    } else {\n      Assert.assertEquals(\n          ImmutableList.of(\"d1\", \"d2\", \"d3\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n          ImmutableList.copyOf(adapter.getDimensionNames())\n      );\n    }\n\n    Assert.assertEquals(4, rowList.size());\n    if (NullHandling.replaceWithDefault()) {\n      Assert.assertEquals(Arrays.asList(\"310\", null, null, \"910\"), rowList.get(0).dimensionValues());\n      Assert.assertEquals(Arrays.asList(\"310\", null, null, \"910\"), rowList.get(1).dimensionValues());\n      Assert.assertEquals(Arrays.asList(\"310\", null, null, \"910\"), rowList.get(2).dimensionValues());\n      Assert.assertEquals(Arrays.asList(null, \"621\", \"821\", \"921\"), rowList.get(3).dimensionValues());\n    } else {\n      Assert.assertEquals(Arrays.asList(\"\", \"\", \"310\", null, null, \"\", null, \"910\"), rowList.get(0).dimensionValues());\n      Assert.assertEquals(Arrays.asList(\"\", \"\", \"310\", null, null, \"\", null, \"910\"), rowList.get(1).dimensionValues());\n      Assert.assertEquals(Arrays.asList(\"\", \"\", \"310\", null, null, \"\", null, \"910\"), rowList.get(2).dimensionValues());\n      Assert.assertEquals(\n          Arrays.asList(null, null, null, \"\", \"621\", \"\", \"821\", \"921\"),\n          rowList.get(3).dimensionValues()\n      );\n    }\n\n    checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d3\", null));\n    checkBitmapIndex(Arrays.asList(0, 1, 2), adapter.getBitmapIndex(\"d3\", \"310\"));\n\n    checkBitmapIndex(Arrays.asList(0, 1, 2), adapter.getBitmapIndex(\"d6\", null));\n    checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d6\", \"621\"));\n\n    checkBitmapIndex(Arrays.asList(0, 1, 2), adapter.getBitmapIndex(\"d8\", null));\n    checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d8\", \"821\"));\n\n    checkBitmapIndex(Collections.emptyList(), adapter.getBitmapIndex(\"d9\", null));\n    checkBitmapIndex(Arrays.asList(0, 1, 2), adapter.getBitmapIndex(\"d9\", \"910\"));\n    checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d9\", \"921\"));\n  }\n","realPath":"processing/src/test/java/org/apache/druid/segment/IndexMergerTestBase.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1182,"status":"M"}],"commitId":"68bb038b314c26bcc57aa96e1078c22d2f24fd35","commitMessage":"@@@Multiphase segment merge for IndexMergerV9 (#10689)\n\n* Multiphase merge for IndexMergerV9\n\n* JSON fix\n\n* Cleanup temp files\n\n* Docs\n\n* Address logging and add IT\n\n* Fix spelling and test unloader datasource name","date":"2021-01-06 14:19:09","modifiedFileCount":"40","status":"M","submitter":"Jonathan Wei"},{"authorTime":"2021-01-08 14:18:47","codes":[{"authorDate":"2021-01-08 14:18:47","commitOrder":3,"curCode":"  public void testJointDimMerge() throws Exception\n  {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    IncrementalIndexSchema rollupIndexSchema = new IncrementalIndexSchema.Builder()\n        .withMetrics(new CountAggregatorFactory(\"count\"))\n        .build();\n\n    IncrementalIndexSchema noRollupIndexSchema = new IncrementalIndexSchema.Builder()\n        .withMetrics(new CountAggregatorFactory(\"count\"))\n        .withRollup(false)\n        .build();\n\n    for (IncrementalIndexSchema indexSchema : Arrays.asList(rollupIndexSchema, noRollupIndexSchema)) {\n\n      IncrementalIndex toPersistA = new OnheapIncrementalIndex.Builder()\n          .setIndexSchema(indexSchema)\n          .setMaxRowCount(1000)\n          .build();\n\n      toPersistA.add(\n          new MapBasedInputRow(\n              1,\n              Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n              ImmutableMap.of(\"d1\", \"\", \"d2\", \"\", \"d3\", \"310\", \"d7\", \"\", \"d9\", \"910\")\n          )\n      );\n      toPersistA.add(\n          new MapBasedInputRow(\n              2,\n              Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n              ImmutableMap.of(\"d2\", \"210\", \"d3\", \"311\", \"d7\", \"710\", \"d8\", \"810\", \"d9\", \"911\")\n          )\n      );\n\n      IncrementalIndex toPersistB = new OnheapIncrementalIndex.Builder()\n          .setIndexSchema(indexSchema)\n          .setMaxRowCount(1000)\n          .build();\n\n      toPersistB.add(\n          new MapBasedInputRow(\n              3,\n              Arrays.asList(\"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n              ImmutableMap.of(\"d5\", \"520\", \"d6\", \"620\", \"d7\", \"720\", \"d8\", \"820\", \"d9\", \"920\")\n          )\n      );\n      toPersistB.add(\n          new MapBasedInputRow(\n              4,\n              Arrays.asList(\"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n              ImmutableMap.of(\"d5\", \"\", \"d6\", \"621\", \"d7\", \"\", \"d8\", \"821\", \"d9\", \"921\")\n          )\n      );\n      final File tmpDirA = temporaryFolder.newFolder();\n      final File tmpDirB = temporaryFolder.newFolder();\n      final File tmpDirMerged = temporaryFolder.newFolder();\n\n      QueryableIndex indexA = closer.closeLater(\n          indexIO.loadIndex(indexMerger.persist(toPersistA, tmpDirA, indexSpec, null))\n      );\n\n      QueryableIndex indexB = closer.closeLater(\n          indexIO.loadIndex(indexMerger.persist(toPersistB, tmpDirB, indexSpec, null))\n      );\n\n      final QueryableIndex merged = closer.closeLater(\n          indexIO.loadIndex(\n              indexMerger.mergeQueryableIndex(\n                  Arrays.asList(indexA, indexB),\n                  true,\n                  new AggregatorFactory[]{new CountAggregatorFactory(\"count\")},\n                  tmpDirMerged,\n                  indexSpec,\n                  null,\n                  -1\n              )\n          )\n      );\n\n      final QueryableIndexIndexableAdapter adapter = new QueryableIndexIndexableAdapter(merged);\n      final List<DebugRow> rowList = RowIteratorHelper.toList(adapter.getRows());\n\n      if (NullHandling.replaceWithDefault()) {\n        Assert.assertEquals(\n            ImmutableList.of(\"d2\", \"d3\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableList.copyOf(adapter.getDimensionNames())\n        );\n      } else {\n        Assert.assertEquals(\n            ImmutableList.of(\"d1\", \"d2\", \"d3\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableList.copyOf(adapter.getDimensionNames())\n        );\n      }\n      Assert.assertEquals(4, rowList.size());\n      if (NullHandling.replaceWithDefault()) {\n        Assert.assertEquals(\n            Arrays.asList(null, \"310\", null, null, null, null, \"910\"),\n            rowList.get(0).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(\"210\", \"311\", null, null, \"710\", \"810\", \"911\"),\n            rowList.get(1).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, null, \"520\", \"620\", \"720\", \"820\", \"920\"),\n            rowList.get(2).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, null, null, \"621\", null, \"821\", \"921\"),\n            rowList.get(3).dimensionValues()\n        );\n\n        checkBitmapIndex(Arrays.asList(0, 2, 3), adapter.getBitmapIndex(\"d2\", null));\n        checkBitmapIndex(Arrays.asList(0, 1, 3), adapter.getBitmapIndex(\"d5\", null));\n        checkBitmapIndex(Arrays.asList(0, 3), adapter.getBitmapIndex(\"d7\", null));\n      } else {\n        Assert.assertEquals(\n            Arrays.asList(\"\", \"\", \"310\", null, null, \"\", null, \"910\"),\n            rowList.get(0).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, \"210\", \"311\", null, null, \"710\", \"810\", \"911\"),\n            rowList.get(1).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, null, null, \"520\", \"620\", \"720\", \"820\", \"920\"),\n            rowList.get(2).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, null, null, \"\", \"621\", \"\", \"821\", \"921\"),\n            rowList.get(3).dimensionValues()\n        );\n        checkBitmapIndex(Arrays.asList(2, 3), adapter.getBitmapIndex(\"d2\", null));\n        checkBitmapIndex(Arrays.asList(0, 1), adapter.getBitmapIndex(\"d5\", null));\n        checkBitmapIndex(Collections.emptyList(), adapter.getBitmapIndex(\"d7\", null));\n      }\n\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d2\", \"210\"));\n\n      checkBitmapIndex(Arrays.asList(2, 3), adapter.getBitmapIndex(\"d3\", null));\n      checkBitmapIndex(Collections.singletonList(0), adapter.getBitmapIndex(\"d3\", \"310\"));\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d3\", \"311\"));\n\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d5\", \"520\"));\n\n      checkBitmapIndex(Arrays.asList(0, 1), adapter.getBitmapIndex(\"d6\", null));\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d6\", \"620\"));\n      checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d6\", \"621\"));\n\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d7\", \"710\"));\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d7\", \"720\"));\n\n      checkBitmapIndex(Collections.singletonList(0), adapter.getBitmapIndex(\"d8\", null));\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d8\", \"810\"));\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d8\", \"820\"));\n      checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d8\", \"821\"));\n\n      checkBitmapIndex(Collections.emptyList(), adapter.getBitmapIndex(\"d9\", null));\n      checkBitmapIndex(Collections.singletonList(0), adapter.getBitmapIndex(\"d9\", \"910\"));\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d9\", \"911\"));\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d9\", \"920\"));\n      checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d9\", \"921\"));\n    }\n  }\n","date":"2021-01-08 14:18:47","endLine":1180,"groupId":"105794","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testJointDimMerge","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/12/4554ee52ec63d24cddcee360b357f8548903c5.src","preCode":"  public void testJointDimMerge() throws Exception\n  {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    IncrementalIndexSchema rollupIndexSchema = new IncrementalIndexSchema.Builder()\n        .withMetrics(new CountAggregatorFactory(\"count\"))\n        .build();\n\n    IncrementalIndexSchema noRollupIndexSchema = new IncrementalIndexSchema.Builder()\n        .withMetrics(new CountAggregatorFactory(\"count\"))\n        .withRollup(false)\n        .build();\n\n    for (IncrementalIndexSchema indexSchema : Arrays.asList(rollupIndexSchema, noRollupIndexSchema)) {\n\n      IncrementalIndex toPersistA = new IncrementalIndex.Builder()\n          .setIndexSchema(indexSchema)\n          .setMaxRowCount(1000)\n          .buildOnheap();\n\n      toPersistA.add(\n          new MapBasedInputRow(\n              1,\n              Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n              ImmutableMap.of(\"d1\", \"\", \"d2\", \"\", \"d3\", \"310\", \"d7\", \"\", \"d9\", \"910\")\n          )\n      );\n      toPersistA.add(\n          new MapBasedInputRow(\n              2,\n              Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n              ImmutableMap.of(\"d2\", \"210\", \"d3\", \"311\", \"d7\", \"710\", \"d8\", \"810\", \"d9\", \"911\")\n          )\n      );\n\n      IncrementalIndex toPersistB = new IncrementalIndex.Builder()\n          .setIndexSchema(indexSchema)\n          .setMaxRowCount(1000)\n          .buildOnheap();\n\n      toPersistB.add(\n          new MapBasedInputRow(\n              3,\n              Arrays.asList(\"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n              ImmutableMap.of(\"d5\", \"520\", \"d6\", \"620\", \"d7\", \"720\", \"d8\", \"820\", \"d9\", \"920\")\n          )\n      );\n      toPersistB.add(\n          new MapBasedInputRow(\n              4,\n              Arrays.asList(\"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n              ImmutableMap.of(\"d5\", \"\", \"d6\", \"621\", \"d7\", \"\", \"d8\", \"821\", \"d9\", \"921\")\n          )\n      );\n      final File tmpDirA = temporaryFolder.newFolder();\n      final File tmpDirB = temporaryFolder.newFolder();\n      final File tmpDirMerged = temporaryFolder.newFolder();\n\n      QueryableIndex indexA = closer.closeLater(\n          indexIO.loadIndex(indexMerger.persist(toPersistA, tmpDirA, indexSpec, null))\n      );\n\n      QueryableIndex indexB = closer.closeLater(\n          indexIO.loadIndex(indexMerger.persist(toPersistB, tmpDirB, indexSpec, null))\n      );\n\n      final QueryableIndex merged = closer.closeLater(\n          indexIO.loadIndex(\n              indexMerger.mergeQueryableIndex(\n                  Arrays.asList(indexA, indexB),\n                  true,\n                  new AggregatorFactory[]{new CountAggregatorFactory(\"count\")},\n                  tmpDirMerged,\n                  indexSpec,\n                  null,\n                  -1\n              )\n          )\n      );\n\n      final QueryableIndexIndexableAdapter adapter = new QueryableIndexIndexableAdapter(merged);\n      final List<DebugRow> rowList = RowIteratorHelper.toList(adapter.getRows());\n\n      if (NullHandling.replaceWithDefault()) {\n        Assert.assertEquals(\n            ImmutableList.of(\"d2\", \"d3\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableList.copyOf(adapter.getDimensionNames())\n        );\n      } else {\n        Assert.assertEquals(\n            ImmutableList.of(\"d1\", \"d2\", \"d3\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableList.copyOf(adapter.getDimensionNames())\n        );\n      }\n      Assert.assertEquals(4, rowList.size());\n      if (NullHandling.replaceWithDefault()) {\n        Assert.assertEquals(\n            Arrays.asList(null, \"310\", null, null, null, null, \"910\"),\n            rowList.get(0).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(\"210\", \"311\", null, null, \"710\", \"810\", \"911\"),\n            rowList.get(1).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, null, \"520\", \"620\", \"720\", \"820\", \"920\"),\n            rowList.get(2).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, null, null, \"621\", null, \"821\", \"921\"),\n            rowList.get(3).dimensionValues()\n        );\n\n        checkBitmapIndex(Arrays.asList(0, 2, 3), adapter.getBitmapIndex(\"d2\", null));\n        checkBitmapIndex(Arrays.asList(0, 1, 3), adapter.getBitmapIndex(\"d5\", null));\n        checkBitmapIndex(Arrays.asList(0, 3), adapter.getBitmapIndex(\"d7\", null));\n      } else {\n        Assert.assertEquals(\n            Arrays.asList(\"\", \"\", \"310\", null, null, \"\", null, \"910\"),\n            rowList.get(0).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, \"210\", \"311\", null, null, \"710\", \"810\", \"911\"),\n            rowList.get(1).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, null, null, \"520\", \"620\", \"720\", \"820\", \"920\"),\n            rowList.get(2).dimensionValues()\n        );\n        Assert.assertEquals(\n            Arrays.asList(null, null, null, \"\", \"621\", \"\", \"821\", \"921\"),\n            rowList.get(3).dimensionValues()\n        );\n        checkBitmapIndex(Arrays.asList(2, 3), adapter.getBitmapIndex(\"d2\", null));\n        checkBitmapIndex(Arrays.asList(0, 1), adapter.getBitmapIndex(\"d5\", null));\n        checkBitmapIndex(Collections.emptyList(), adapter.getBitmapIndex(\"d7\", null));\n      }\n\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d2\", \"210\"));\n\n      checkBitmapIndex(Arrays.asList(2, 3), adapter.getBitmapIndex(\"d3\", null));\n      checkBitmapIndex(Collections.singletonList(0), adapter.getBitmapIndex(\"d3\", \"310\"));\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d3\", \"311\"));\n\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d5\", \"520\"));\n\n      checkBitmapIndex(Arrays.asList(0, 1), adapter.getBitmapIndex(\"d6\", null));\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d6\", \"620\"));\n      checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d6\", \"621\"));\n\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d7\", \"710\"));\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d7\", \"720\"));\n\n      checkBitmapIndex(Collections.singletonList(0), adapter.getBitmapIndex(\"d8\", null));\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d8\", \"810\"));\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d8\", \"820\"));\n      checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d8\", \"821\"));\n\n      checkBitmapIndex(Collections.emptyList(), adapter.getBitmapIndex(\"d9\", null));\n      checkBitmapIndex(Collections.singletonList(0), adapter.getBitmapIndex(\"d9\", \"910\"));\n      checkBitmapIndex(Collections.singletonList(1), adapter.getBitmapIndex(\"d9\", \"911\"));\n      checkBitmapIndex(Collections.singletonList(2), adapter.getBitmapIndex(\"d9\", \"920\"));\n      checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d9\", \"921\"));\n    }\n  }\n","realPath":"processing/src/test/java/org/apache/druid/segment/IndexMergerTestBase.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1010,"status":"M"},{"authorDate":"2021-01-08 14:18:47","commitOrder":3,"curCode":"  public void testNoRollupMergeWithDuplicateRow() throws Exception\n  {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    IncrementalIndexSchema indexSchema = new IncrementalIndexSchema.Builder()\n        .withMetrics(new CountAggregatorFactory(\"count\"))\n        .withRollup(false)\n        .build();\n    IncrementalIndex toPersistA = new OnheapIncrementalIndex.Builder()\n        .setIndexSchema(indexSchema)\n        .setMaxRowCount(1000)\n        .build();\n\n    toPersistA.add(\n        new MapBasedInputRow(\n            1,\n            Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableMap.of(\n                \"d1\", \"\", \"d2\", \"\", \"d3\", \"310\", \"d7\", \"\", \"d9\", \"910\"\n            )\n        )\n    );\n    toPersistA.add(\n        new MapBasedInputRow(\n            1,\n            Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableMap.of(\n                \"d1\", \"\", \"d2\", \"\", \"d3\", \"310\", \"d7\", \"\", \"d9\", \"910\"\n            )\n        )\n    );\n\n    IncrementalIndex toPersistB = new OnheapIncrementalIndex.Builder()\n        .setIndexSchema(indexSchema)\n        .setMaxRowCount(1000)\n        .build();\n\n    toPersistB.add(\n        new MapBasedInputRow(\n            1,\n            Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableMap.of(\n                \"d1\", \"\", \"d2\", \"\", \"d3\", \"310\", \"d7\", \"\", \"d9\", \"910\"\n            )\n        )\n    );\n    toPersistB.add(\n        new MapBasedInputRow(\n            4,\n            Arrays.asList(\"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableMap.of(\n                \"d5\", \"\", \"d6\", \"621\", \"d7\", \"\", \"d8\", \"821\", \"d9\", \"921\"\n            )\n        )\n    );\n    final File tmpDirA = temporaryFolder.newFolder();\n    final File tmpDirB = temporaryFolder.newFolder();\n    final File tmpDirMerged = temporaryFolder.newFolder();\n\n    QueryableIndex indexA = closer.closeLater(\n        indexIO.loadIndex(indexMerger.persist(toPersistA, tmpDirA, indexSpec, null))\n    );\n\n    QueryableIndex indexB = closer.closeLater(\n        indexIO.loadIndex(indexMerger.persist(toPersistB, tmpDirB, indexSpec, null))\n    );\n\n    final QueryableIndex merged = closer.closeLater(\n        indexIO.loadIndex(\n            indexMerger.mergeQueryableIndex(\n                Arrays.asList(indexA, indexB),\n                false,\n                new AggregatorFactory[]{new CountAggregatorFactory(\"count\")},\n                tmpDirMerged,\n                indexSpec,\n                null,\n                -1\n            )\n        )\n    );\n\n    final QueryableIndexIndexableAdapter adapter = new QueryableIndexIndexableAdapter(merged);\n    final List<DebugRow> rowList = RowIteratorHelper.toList(adapter.getRows());\n\n    if (NullHandling.replaceWithDefault()) {\n      Assert.assertEquals(\n          ImmutableList.of(\"d3\", \"d6\", \"d8\", \"d9\"),\n          ImmutableList.copyOf(adapter.getDimensionNames())\n      );\n    } else {\n      Assert.assertEquals(\n          ImmutableList.of(\"d1\", \"d2\", \"d3\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n          ImmutableList.copyOf(adapter.getDimensionNames())\n      );\n    }\n\n    Assert.assertEquals(4, rowList.size());\n    if (NullHandling.replaceWithDefault()) {\n      Assert.assertEquals(Arrays.asList(\"310\", null, null, \"910\"), rowList.get(0).dimensionValues());\n      Assert.assertEquals(Arrays.asList(\"310\", null, null, \"910\"), rowList.get(1).dimensionValues());\n      Assert.assertEquals(Arrays.asList(\"310\", null, null, \"910\"), rowList.get(2).dimensionValues());\n      Assert.assertEquals(Arrays.asList(null, \"621\", \"821\", \"921\"), rowList.get(3).dimensionValues());\n    } else {\n      Assert.assertEquals(Arrays.asList(\"\", \"\", \"310\", null, null, \"\", null, \"910\"), rowList.get(0).dimensionValues());\n      Assert.assertEquals(Arrays.asList(\"\", \"\", \"310\", null, null, \"\", null, \"910\"), rowList.get(1).dimensionValues());\n      Assert.assertEquals(Arrays.asList(\"\", \"\", \"310\", null, null, \"\", null, \"910\"), rowList.get(2).dimensionValues());\n      Assert.assertEquals(\n          Arrays.asList(null, null, null, \"\", \"621\", \"\", \"821\", \"921\"),\n          rowList.get(3).dimensionValues()\n      );\n    }\n\n    checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d3\", null));\n    checkBitmapIndex(Arrays.asList(0, 1, 2), adapter.getBitmapIndex(\"d3\", \"310\"));\n\n    checkBitmapIndex(Arrays.asList(0, 1, 2), adapter.getBitmapIndex(\"d6\", null));\n    checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d6\", \"621\"));\n\n    checkBitmapIndex(Arrays.asList(0, 1, 2), adapter.getBitmapIndex(\"d8\", null));\n    checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d8\", \"821\"));\n\n    checkBitmapIndex(Collections.emptyList(), adapter.getBitmapIndex(\"d9\", null));\n    checkBitmapIndex(Arrays.asList(0, 1, 2), adapter.getBitmapIndex(\"d9\", \"910\"));\n    checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d9\", \"921\"));\n  }\n","date":"2021-01-08 14:18:47","endLine":1313,"groupId":"105794","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testNoRollupMergeWithDuplicateRow","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/12/4554ee52ec63d24cddcee360b357f8548903c5.src","preCode":"  public void testNoRollupMergeWithDuplicateRow() throws Exception\n  {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    IncrementalIndexSchema indexSchema = new IncrementalIndexSchema.Builder()\n        .withMetrics(new CountAggregatorFactory(\"count\"))\n        .withRollup(false)\n        .build();\n    IncrementalIndex toPersistA = new IncrementalIndex.Builder()\n        .setIndexSchema(indexSchema)\n        .setMaxRowCount(1000)\n        .buildOnheap();\n\n    toPersistA.add(\n        new MapBasedInputRow(\n            1,\n            Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableMap.of(\n                \"d1\", \"\", \"d2\", \"\", \"d3\", \"310\", \"d7\", \"\", \"d9\", \"910\"\n            )\n        )\n    );\n    toPersistA.add(\n        new MapBasedInputRow(\n            1,\n            Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableMap.of(\n                \"d1\", \"\", \"d2\", \"\", \"d3\", \"310\", \"d7\", \"\", \"d9\", \"910\"\n            )\n        )\n    );\n\n    IncrementalIndex toPersistB = new IncrementalIndex.Builder()\n        .setIndexSchema(indexSchema)\n        .setMaxRowCount(1000)\n        .buildOnheap();\n\n    toPersistB.add(\n        new MapBasedInputRow(\n            1,\n            Arrays.asList(\"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableMap.of(\n                \"d1\", \"\", \"d2\", \"\", \"d3\", \"310\", \"d7\", \"\", \"d9\", \"910\"\n            )\n        )\n    );\n    toPersistB.add(\n        new MapBasedInputRow(\n            4,\n            Arrays.asList(\"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n            ImmutableMap.of(\n                \"d5\", \"\", \"d6\", \"621\", \"d7\", \"\", \"d8\", \"821\", \"d9\", \"921\"\n            )\n        )\n    );\n    final File tmpDirA = temporaryFolder.newFolder();\n    final File tmpDirB = temporaryFolder.newFolder();\n    final File tmpDirMerged = temporaryFolder.newFolder();\n\n    QueryableIndex indexA = closer.closeLater(\n        indexIO.loadIndex(indexMerger.persist(toPersistA, tmpDirA, indexSpec, null))\n    );\n\n    QueryableIndex indexB = closer.closeLater(\n        indexIO.loadIndex(indexMerger.persist(toPersistB, tmpDirB, indexSpec, null))\n    );\n\n    final QueryableIndex merged = closer.closeLater(\n        indexIO.loadIndex(\n            indexMerger.mergeQueryableIndex(\n                Arrays.asList(indexA, indexB),\n                false,\n                new AggregatorFactory[]{new CountAggregatorFactory(\"count\")},\n                tmpDirMerged,\n                indexSpec,\n                null,\n                -1\n            )\n        )\n    );\n\n    final QueryableIndexIndexableAdapter adapter = new QueryableIndexIndexableAdapter(merged);\n    final List<DebugRow> rowList = RowIteratorHelper.toList(adapter.getRows());\n\n    if (NullHandling.replaceWithDefault()) {\n      Assert.assertEquals(\n          ImmutableList.of(\"d3\", \"d6\", \"d8\", \"d9\"),\n          ImmutableList.copyOf(adapter.getDimensionNames())\n      );\n    } else {\n      Assert.assertEquals(\n          ImmutableList.of(\"d1\", \"d2\", \"d3\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"),\n          ImmutableList.copyOf(adapter.getDimensionNames())\n      );\n    }\n\n    Assert.assertEquals(4, rowList.size());\n    if (NullHandling.replaceWithDefault()) {\n      Assert.assertEquals(Arrays.asList(\"310\", null, null, \"910\"), rowList.get(0).dimensionValues());\n      Assert.assertEquals(Arrays.asList(\"310\", null, null, \"910\"), rowList.get(1).dimensionValues());\n      Assert.assertEquals(Arrays.asList(\"310\", null, null, \"910\"), rowList.get(2).dimensionValues());\n      Assert.assertEquals(Arrays.asList(null, \"621\", \"821\", \"921\"), rowList.get(3).dimensionValues());\n    } else {\n      Assert.assertEquals(Arrays.asList(\"\", \"\", \"310\", null, null, \"\", null, \"910\"), rowList.get(0).dimensionValues());\n      Assert.assertEquals(Arrays.asList(\"\", \"\", \"310\", null, null, \"\", null, \"910\"), rowList.get(1).dimensionValues());\n      Assert.assertEquals(Arrays.asList(\"\", \"\", \"310\", null, null, \"\", null, \"910\"), rowList.get(2).dimensionValues());\n      Assert.assertEquals(\n          Arrays.asList(null, null, null, \"\", \"621\", \"\", \"821\", \"921\"),\n          rowList.get(3).dimensionValues()\n      );\n    }\n\n    checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d3\", null));\n    checkBitmapIndex(Arrays.asList(0, 1, 2), adapter.getBitmapIndex(\"d3\", \"310\"));\n\n    checkBitmapIndex(Arrays.asList(0, 1, 2), adapter.getBitmapIndex(\"d6\", null));\n    checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d6\", \"621\"));\n\n    checkBitmapIndex(Arrays.asList(0, 1, 2), adapter.getBitmapIndex(\"d8\", null));\n    checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d8\", \"821\"));\n\n    checkBitmapIndex(Collections.emptyList(), adapter.getBitmapIndex(\"d9\", null));\n    checkBitmapIndex(Arrays.asList(0, 1, 2), adapter.getBitmapIndex(\"d9\", \"910\"));\n    checkBitmapIndex(Collections.singletonList(3), adapter.getBitmapIndex(\"d9\", \"921\"));\n  }\n","realPath":"processing/src/test/java/org/apache/druid/segment/IndexMergerTestBase.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1183,"status":"M"}],"commitId":"08ab82f55ca856d60dfe1088c1c0393428b0bb6d","commitMessage":"@@@IncrementalIndex Tests and Benchmarks Parametrization (#10593)\n\n* Remove redundant IncrementalIndex.Builder\n\n* Parametrize incremental index tests and benchmarks\n\n- Reveal and fix a bug in OffheapIncrementalIndex\n\n* Fix forbiddenapis error: Forbidden method invocation: java.lang.String#format(java.lang.String. java.lang.Object[]) [Uses default locale]\n\n* Fix Intellij errors: declared exception is never thrown\n\n* Add documentation and validate before closing objects on tearDown.\n\n* Add documentation to OffheapIncrementalIndexTestSpec\n\n* Doc corrections and minor changes.\n\n* Add logging for generated rows.\n\n* Refactor new tests/benchmarks.\n\n* Improve IncrementalIndexCreator documentation\n\n* Add required tests for DataGenerator\n\n* Revert \"rollupOpportunity\" to be a string","date":"2021-01-08 14:18:47","modifiedFileCount":"62","status":"M","submitter":"Liran Funaro"}]
