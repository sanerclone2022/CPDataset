[{"authorTime":"2020-01-22 05:56:54","codes":[{"authorDate":"2020-01-28 03:24:29","commitOrder":8,"curCode":"  private static ObjectMapper setupInjectablesInObjectMapper(ObjectMapper objectMapper)\n  {\n    final GuiceAnnotationIntrospector guiceIntrospector = new GuiceAnnotationIntrospector();\n    objectMapper.setAnnotationIntrospectors(\n        new AnnotationIntrospectorPair(\n            guiceIntrospector,\n            objectMapper.getSerializationConfig().getAnnotationIntrospector()\n        ),\n        new AnnotationIntrospectorPair(\n            guiceIntrospector,\n            objectMapper.getDeserializationConfig().getAnnotationIntrospector()\n        )\n    );\n    GuiceInjectableValues injectableValues = new GuiceInjectableValues(\n        GuiceInjectors.makeStartupInjectorWithModules(\n            ImmutableList.of(\n                binder -> {\n                  binder.bind(AuthorizerMapper.class).toInstance(AuthTestUtils.TEST_AUTHORIZER_MAPPER);\n                  binder.bind(ChatHandlerProvider.class).toInstance(new NoopChatHandlerProvider());\n                  binder.bind(RowIngestionMetersFactory.class).toInstance(ROW_INGESTION_METERS_FACTORY);\n                  binder.bind(CoordinatorClient.class).toInstance(COORDINATOR_CLIENT);\n                  binder.bind(SegmentLoaderFactory.class).toInstance(new SegmentLoaderFactory(null, objectMapper));\n                  binder.bind(AppenderatorsManager.class).toInstance(APPENDERATORS_MANAGER);\n                  binder.bind(IndexingServiceClient.class).toInstance(new NoopIndexingServiceClient());\n                }\n            )\n        )\n    );\n    objectMapper.setInjectableValues(injectableValues);\n    objectMapper.registerSubtypes(new NamedType(ParallelIndexTuningConfig.class, \"index_parallel\"));\n    return objectMapper;\n  }\n","date":"2020-01-28 03:24:29","endLine":175,"groupId":"19906","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"setupInjectablesInObjectMapper","params":"(ObjectMapperobjectMapper)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/8b/e6b85864df324f887429a91c03b73197c350ee.src","preCode":"  private static ObjectMapper setupInjectablesInObjectMapper(ObjectMapper objectMapper)\n  {\n    final GuiceAnnotationIntrospector guiceIntrospector = new GuiceAnnotationIntrospector();\n    objectMapper.setAnnotationIntrospectors(\n        new AnnotationIntrospectorPair(\n            guiceIntrospector,\n            objectMapper.getSerializationConfig().getAnnotationIntrospector()\n        ),\n        new AnnotationIntrospectorPair(\n            guiceIntrospector,\n            objectMapper.getDeserializationConfig().getAnnotationIntrospector()\n        )\n    );\n    GuiceInjectableValues injectableValues = new GuiceInjectableValues(\n        GuiceInjectors.makeStartupInjectorWithModules(\n            ImmutableList.of(\n                binder -> {\n                  binder.bind(AuthorizerMapper.class).toInstance(AuthTestUtils.TEST_AUTHORIZER_MAPPER);\n                  binder.bind(ChatHandlerProvider.class).toInstance(new NoopChatHandlerProvider());\n                  binder.bind(RowIngestionMetersFactory.class).toInstance(ROW_INGESTION_METERS_FACTORY);\n                  binder.bind(CoordinatorClient.class).toInstance(COORDINATOR_CLIENT);\n                  binder.bind(SegmentLoaderFactory.class).toInstance(new SegmentLoaderFactory(null, objectMapper));\n                  binder.bind(AppenderatorsManager.class).toInstance(APPENDERATORS_MANAGER);\n                  binder.bind(IndexingServiceClient.class).toInstance(new NoopIndexingServiceClient());\n                }\n            )\n        )\n    );\n    objectMapper.setInjectableValues(injectableValues);\n    objectMapper.registerSubtypes(new NamedType(ParallelIndexTuningConfig.class, \"index_parallel\"));\n    return objectMapper;\n  }\n","realPath":"indexing-service/src/test/java/org/apache/druid/indexing/common/task/ClientCompactionTaskQuerySerdeTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":144,"status":"B"},{"authorDate":"2020-01-22 05:56:54","commitOrder":8,"curCode":"  private static ObjectMapper setupInjectablesInObjectMapper(ObjectMapper objectMapper)\n  {\n    final GuiceAnnotationIntrospector guiceIntrospector = new GuiceAnnotationIntrospector();\n    objectMapper.setAnnotationIntrospectors(\n        new AnnotationIntrospectorPair(\n            guiceIntrospector,\n            objectMapper.getSerializationConfig().getAnnotationIntrospector()\n        ),\n        new AnnotationIntrospectorPair(\n            guiceIntrospector,\n            objectMapper.getDeserializationConfig().getAnnotationIntrospector()\n        )\n    );\n    GuiceInjectableValues injectableValues = new GuiceInjectableValues(\n        GuiceInjectors.makeStartupInjectorWithModules(\n            ImmutableList.of(\n                binder -> {\n                  binder.bind(AuthorizerMapper.class).toInstance(AuthTestUtils.TEST_AUTHORIZER_MAPPER);\n                  binder.bind(ChatHandlerProvider.class).toInstance(new NoopChatHandlerProvider());\n                  binder.bind(RowIngestionMetersFactory.class).toInstance(ROW_INGESTION_METERS_FACTORY);\n                  binder.bind(CoordinatorClient.class).toInstance(COORDINATOR_CLIENT);\n                  binder.bind(SegmentLoaderFactory.class).toInstance(new SegmentLoaderFactory(null, objectMapper));\n                  binder.bind(AppenderatorsManager.class).toInstance(APPENDERATORS_MANAGER);\n                  binder.bind(IndexingServiceClient.class).toInstance(INDEXING_SERVICE_CLIENT);\n                }\n            )\n        )\n    );\n    objectMapper.setInjectableValues(injectableValues);\n    objectMapper.registerModule(\n        new SimpleModule().registerSubtypes(new NamedType(NumberedShardSpec.class, \"NumberedShardSpec\"))\n    );\n    objectMapper.registerModules(new IndexingServiceTuningConfigModule().getJacksonModules());\n    return objectMapper;\n  }\n","date":"2020-01-22 05:56:54","endLine":278,"groupId":"19906","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"setupInjectablesInObjectMapper","params":"(ObjectMapperobjectMapper)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/12/89944fa2d4d182bcface1375d58cac47748b48.src","preCode":"  private static ObjectMapper setupInjectablesInObjectMapper(ObjectMapper objectMapper)\n  {\n    final GuiceAnnotationIntrospector guiceIntrospector = new GuiceAnnotationIntrospector();\n    objectMapper.setAnnotationIntrospectors(\n        new AnnotationIntrospectorPair(\n            guiceIntrospector,\n            objectMapper.getSerializationConfig().getAnnotationIntrospector()\n        ),\n        new AnnotationIntrospectorPair(\n            guiceIntrospector,\n            objectMapper.getDeserializationConfig().getAnnotationIntrospector()\n        )\n    );\n    GuiceInjectableValues injectableValues = new GuiceInjectableValues(\n        GuiceInjectors.makeStartupInjectorWithModules(\n            ImmutableList.of(\n                binder -> {\n                  binder.bind(AuthorizerMapper.class).toInstance(AuthTestUtils.TEST_AUTHORIZER_MAPPER);\n                  binder.bind(ChatHandlerProvider.class).toInstance(new NoopChatHandlerProvider());\n                  binder.bind(RowIngestionMetersFactory.class).toInstance(ROW_INGESTION_METERS_FACTORY);\n                  binder.bind(CoordinatorClient.class).toInstance(COORDINATOR_CLIENT);\n                  binder.bind(SegmentLoaderFactory.class).toInstance(new SegmentLoaderFactory(null, objectMapper));\n                  binder.bind(AppenderatorsManager.class).toInstance(APPENDERATORS_MANAGER);\n                  binder.bind(IndexingServiceClient.class).toInstance(INDEXING_SERVICE_CLIENT);\n                }\n            )\n        )\n    );\n    objectMapper.setInjectableValues(injectableValues);\n    objectMapper.registerModule(\n        new SimpleModule().registerSubtypes(new NamedType(NumberedShardSpec.class, \"NumberedShardSpec\"))\n    );\n    objectMapper.registerModules(new IndexingServiceTuningConfigModule().getJacksonModules());\n    return objectMapper;\n  }\n","realPath":"indexing-service/src/test/java/org/apache/druid/indexing/common/task/CompactionTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":244,"status":"NB"}],"commitId":"b9186f8f9ff2ff52aceda42bc5f24ffd47a7d17e","commitMessage":"@@@Reconcile terminology and method naming to 'used/unused segments'; Rename MetadataSegmentManager to MetadataSegmentsManager (#7306)\n\n* Reconcile terminology and method naming to 'used/unused segments'; Don't use terms 'enable/disable data source'; Rename MetadataSegmentManager to MetadataSegments; Make REST API methods which mark segments as used/unused to return server error instead of an empty response in case of error\n\n* Fix brace\n\n* Import order\n\n* Rename withKillDataSourceWhitelist to withSpecificDataSourcesToKill\n\n* Fix tests\n\n* Fix tests by adding proper methods without interval parameters to IndexerMetadataStorageCoordinator instead of hacking with Intervals.ETERNITY\n\n* More aligned names of DruidCoordinatorHelpers.  rename several CoordinatorDynamicConfig parameters\n\n* Rename ClientCompactTaskQuery to ClientCompactionTaskQuery for consistency with CompactionTask; ClientCompactQueryTuningConfig to ClientCompactionTaskQueryTuningConfig\n\n* More variable and method renames\n\n* Rename MetadataSegments to SegmentsMetadata\n\n* Javadoc update\n\n* Simplify SegmentsMetadata.getUnusedSegmentIntervals().  more javadocs\n\n* Update Javadoc of VersionedIntervalTimeline.iterateAllObjects()\n\n* Reorder imports\n\n* Rename SegmentsMetadata.tryMark... methods to mark... and make them to return boolean and the numbers of segments changed and relay exceptions to callers\n\n* Complete merge\n\n* Add CollectionUtils.newTreeSet(); Refactor DruidCoordinatorRuntimeParams creation in tests\n\n* Remove MetadataSegmentManager\n\n* Rename millisLagSinceCoordinatorBecomesLeaderBeforeCanMarkAsUnusedOvershadowedSegments to leadingTimeMillisBeforeCanMarkAsUnusedOvershadowedSegments\n\n* Fix tests.  refactor DruidCluster creation in tests into DruidClusterBuilder\n\n* Fix inspections\n\n* Fix SQLMetadataSegmentManagerEmptyTest and rename it to SqlSegmentsMetadataEmptyTest\n\n* Rename SegmentsAndMetadata to SegmentsAndCommitMetadata to reduce the similarity with SegmentsMetadata; Rename some methods\n\n* Rename DruidCoordinatorHelper to CoordinatorDuty.  refactor DruidCoordinator\n\n* Unused import\n\n* Optimize imports\n\n* Rename IndexerSQLMetadataStorageCoordinator.getDataSourceMetadata() to retrieveDataSourceMetadata()\n\n* Unused import\n\n* Update terminology in datasource-view.tsx\n\n* Fix label in datasource-view.spec.tsx.snap\n\n* Fix lint errors in datasource-view.tsx\n\n* Doc improvements\n\n* Another attempt to please TSLint\n\n* Another attempt to please TSLint\n\n* Style fixes\n\n* Fix IndexerSQLMetadataStorageCoordinator.createUsedSegmentsSqlQueryForIntervals() (wrong merge)\n\n* Try to fix docs build issue\n\n* Javadoc and spelling fixes\n\n* Rename SegmentsMetadata to SegmentsMetadataManager.  address other comments\n\n* Address more comments\n","date":"2020-01-28 03:24:29","modifiedFileCount":"127","status":"M","submitter":"Roman Leventov"},{"authorTime":"2020-08-27 08:08:12","codes":[{"authorDate":"2020-01-28 03:24:29","commitOrder":9,"curCode":"  private static ObjectMapper setupInjectablesInObjectMapper(ObjectMapper objectMapper)\n  {\n    final GuiceAnnotationIntrospector guiceIntrospector = new GuiceAnnotationIntrospector();\n    objectMapper.setAnnotationIntrospectors(\n        new AnnotationIntrospectorPair(\n            guiceIntrospector,\n            objectMapper.getSerializationConfig().getAnnotationIntrospector()\n        ),\n        new AnnotationIntrospectorPair(\n            guiceIntrospector,\n            objectMapper.getDeserializationConfig().getAnnotationIntrospector()\n        )\n    );\n    GuiceInjectableValues injectableValues = new GuiceInjectableValues(\n        GuiceInjectors.makeStartupInjectorWithModules(\n            ImmutableList.of(\n                binder -> {\n                  binder.bind(AuthorizerMapper.class).toInstance(AuthTestUtils.TEST_AUTHORIZER_MAPPER);\n                  binder.bind(ChatHandlerProvider.class).toInstance(new NoopChatHandlerProvider());\n                  binder.bind(RowIngestionMetersFactory.class).toInstance(ROW_INGESTION_METERS_FACTORY);\n                  binder.bind(CoordinatorClient.class).toInstance(COORDINATOR_CLIENT);\n                  binder.bind(SegmentLoaderFactory.class).toInstance(new SegmentLoaderFactory(null, objectMapper));\n                  binder.bind(AppenderatorsManager.class).toInstance(APPENDERATORS_MANAGER);\n                  binder.bind(IndexingServiceClient.class).toInstance(new NoopIndexingServiceClient());\n                }\n            )\n        )\n    );\n    objectMapper.setInjectableValues(injectableValues);\n    objectMapper.registerSubtypes(new NamedType(ParallelIndexTuningConfig.class, \"index_parallel\"));\n    return objectMapper;\n  }\n","date":"2020-01-28 03:24:29","endLine":175,"groupId":"19906","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"setupInjectablesInObjectMapper","params":"(ObjectMapperobjectMapper)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/8b/e6b85864df324f887429a91c03b73197c350ee.src","preCode":"  private static ObjectMapper setupInjectablesInObjectMapper(ObjectMapper objectMapper)\n  {\n    final GuiceAnnotationIntrospector guiceIntrospector = new GuiceAnnotationIntrospector();\n    objectMapper.setAnnotationIntrospectors(\n        new AnnotationIntrospectorPair(\n            guiceIntrospector,\n            objectMapper.getSerializationConfig().getAnnotationIntrospector()\n        ),\n        new AnnotationIntrospectorPair(\n            guiceIntrospector,\n            objectMapper.getDeserializationConfig().getAnnotationIntrospector()\n        )\n    );\n    GuiceInjectableValues injectableValues = new GuiceInjectableValues(\n        GuiceInjectors.makeStartupInjectorWithModules(\n            ImmutableList.of(\n                binder -> {\n                  binder.bind(AuthorizerMapper.class).toInstance(AuthTestUtils.TEST_AUTHORIZER_MAPPER);\n                  binder.bind(ChatHandlerProvider.class).toInstance(new NoopChatHandlerProvider());\n                  binder.bind(RowIngestionMetersFactory.class).toInstance(ROW_INGESTION_METERS_FACTORY);\n                  binder.bind(CoordinatorClient.class).toInstance(COORDINATOR_CLIENT);\n                  binder.bind(SegmentLoaderFactory.class).toInstance(new SegmentLoaderFactory(null, objectMapper));\n                  binder.bind(AppenderatorsManager.class).toInstance(APPENDERATORS_MANAGER);\n                  binder.bind(IndexingServiceClient.class).toInstance(new NoopIndexingServiceClient());\n                }\n            )\n        )\n    );\n    objectMapper.setInjectableValues(injectableValues);\n    objectMapper.registerSubtypes(new NamedType(ParallelIndexTuningConfig.class, \"index_parallel\"));\n    return objectMapper;\n  }\n","realPath":"indexing-service/src/test/java/org/apache/druid/indexing/common/task/ClientCompactionTaskQuerySerdeTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":144,"status":"N"},{"authorDate":"2020-08-27 08:08:12","commitOrder":9,"curCode":"  private static ObjectMapper setupInjectablesInObjectMapper(ObjectMapper objectMapper)\n  {\n    final GuiceAnnotationIntrospector guiceIntrospector = new GuiceAnnotationIntrospector();\n    objectMapper.setAnnotationIntrospectors(\n        new AnnotationIntrospectorPair(\n            guiceIntrospector,\n            objectMapper.getSerializationConfig().getAnnotationIntrospector()\n        ),\n        new AnnotationIntrospectorPair(\n            guiceIntrospector,\n            objectMapper.getDeserializationConfig().getAnnotationIntrospector()\n        )\n    );\n    GuiceInjectableValues injectableValues = new GuiceInjectableValues(\n        GuiceInjectors.makeStartupInjectorWithModules(\n            ImmutableList.of(\n                binder -> {\n                  binder.bind(AuthorizerMapper.class).toInstance(AuthTestUtils.TEST_AUTHORIZER_MAPPER);\n                  binder.bind(ChatHandlerProvider.class).toInstance(new NoopChatHandlerProvider());\n                  binder.bind(RowIngestionMetersFactory.class).toInstance(TEST_UTILS.getRowIngestionMetersFactory());\n                  binder.bind(CoordinatorClient.class).toInstance(COORDINATOR_CLIENT);\n                  binder.bind(SegmentLoaderFactory.class).toInstance(new SegmentLoaderFactory(null, objectMapper));\n                  binder.bind(AppenderatorsManager.class).toInstance(new TestAppenderatorsManager());\n                  binder.bind(IndexingServiceClient.class).toInstance(INDEXING_SERVICE_CLIENT);\n                }\n            )\n        )\n    );\n    objectMapper.setInjectableValues(injectableValues);\n    objectMapper.registerModule(\n        new SimpleModule().registerSubtypes(new NamedType(NumberedShardSpec.class, \"NumberedShardSpec\"))\n    );\n    objectMapper.registerModules(new IndexingServiceTuningConfigModule().getJacksonModules());\n    return objectMapper;\n  }\n","date":"2020-08-27 08:08:12","endLine":285,"groupId":"19906","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"setupInjectablesInObjectMapper","params":"(ObjectMapperobjectMapper)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/e6/35381327075830831d9c03e9520b7941ab304c.src","preCode":"  private static ObjectMapper setupInjectablesInObjectMapper(ObjectMapper objectMapper)\n  {\n    final GuiceAnnotationIntrospector guiceIntrospector = new GuiceAnnotationIntrospector();\n    objectMapper.setAnnotationIntrospectors(\n        new AnnotationIntrospectorPair(\n            guiceIntrospector,\n            objectMapper.getSerializationConfig().getAnnotationIntrospector()\n        ),\n        new AnnotationIntrospectorPair(\n            guiceIntrospector,\n            objectMapper.getDeserializationConfig().getAnnotationIntrospector()\n        )\n    );\n    GuiceInjectableValues injectableValues = new GuiceInjectableValues(\n        GuiceInjectors.makeStartupInjectorWithModules(\n            ImmutableList.of(\n                binder -> {\n                  binder.bind(AuthorizerMapper.class).toInstance(AuthTestUtils.TEST_AUTHORIZER_MAPPER);\n                  binder.bind(ChatHandlerProvider.class).toInstance(new NoopChatHandlerProvider());\n                  binder.bind(RowIngestionMetersFactory.class).toInstance(ROW_INGESTION_METERS_FACTORY);\n                  binder.bind(CoordinatorClient.class).toInstance(COORDINATOR_CLIENT);\n                  binder.bind(SegmentLoaderFactory.class).toInstance(new SegmentLoaderFactory(null, objectMapper));\n                  binder.bind(AppenderatorsManager.class).toInstance(APPENDERATORS_MANAGER);\n                  binder.bind(IndexingServiceClient.class).toInstance(INDEXING_SERVICE_CLIENT);\n                }\n            )\n        )\n    );\n    objectMapper.setInjectableValues(injectableValues);\n    objectMapper.registerModule(\n        new SimpleModule().registerSubtypes(new NamedType(NumberedShardSpec.class, \"NumberedShardSpec\"))\n    );\n    objectMapper.registerModules(new IndexingServiceTuningConfigModule().getJacksonModules());\n    return objectMapper;\n  }\n","realPath":"indexing-service/src/test/java/org/apache/druid/indexing/common/task/CompactionTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":251,"status":"M"}],"commitId":"f82fd22fa7de175200b7127c34c2eb2900bf7317","commitMessage":"@@@Move tools for indexing to TaskToolbox instead of injecting them in constructor (#10308)\n\n* Move tools for indexing to TaskToolbox instead of injecting them in constructor\n\n* oops.  other changes\n\n* fix test\n\n* unnecessary new file\n\n* fix test\n\n* fix build","date":"2020-08-27 08:08:12","modifiedFileCount":"67","status":"M","submitter":"Jihoon Son"},{"authorTime":"2021-07-21 02:44:19","codes":[{"authorDate":"2021-07-21 02:44:19","commitOrder":10,"curCode":"  private static ObjectMapper setupInjectablesInObjectMapper(ObjectMapper objectMapper)\n  {\n    final GuiceAnnotationIntrospector guiceIntrospector = new GuiceAnnotationIntrospector();\n    objectMapper.setAnnotationIntrospectors(\n        new AnnotationIntrospectorPair(\n            guiceIntrospector,\n            objectMapper.getSerializationConfig().getAnnotationIntrospector()\n        ),\n        new AnnotationIntrospectorPair(\n            guiceIntrospector,\n            objectMapper.getDeserializationConfig().getAnnotationIntrospector()\n        )\n    );\n    GuiceInjectableValues injectableValues = new GuiceInjectableValues(\n        GuiceInjectors.makeStartupInjectorWithModules(\n            ImmutableList.of(\n                binder -> {\n                  binder.bind(AuthorizerMapper.class).toInstance(AuthTestUtils.TEST_AUTHORIZER_MAPPER);\n                  binder.bind(ChatHandlerProvider.class).toInstance(new NoopChatHandlerProvider());\n                  binder.bind(RowIngestionMetersFactory.class).toInstance(ROW_INGESTION_METERS_FACTORY);\n                  binder.bind(CoordinatorClient.class).toInstance(COORDINATOR_CLIENT);\n                  binder.bind(SegmentCacheManagerFactory.class).toInstance(new SegmentCacheManagerFactory(objectMapper));\n                  binder.bind(AppenderatorsManager.class).toInstance(APPENDERATORS_MANAGER);\n                  binder.bind(IndexingServiceClient.class).toInstance(new NoopIndexingServiceClient());\n                }\n            )\n        )\n    );\n    objectMapper.setInjectableValues(injectableValues);\n    objectMapper.registerSubtypes(new NamedType(ParallelIndexTuningConfig.class, \"index_parallel\"));\n    return objectMapper;\n  }\n","date":"2021-07-21 02:44:19","endLine":351,"groupId":"104422","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"setupInjectablesInObjectMapper","params":"(ObjectMapperobjectMapper)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/fd/7b69957a9bc9d94edb719f7624a9a6db905189.src","preCode":"  private static ObjectMapper setupInjectablesInObjectMapper(ObjectMapper objectMapper)\n  {\n    final GuiceAnnotationIntrospector guiceIntrospector = new GuiceAnnotationIntrospector();\n    objectMapper.setAnnotationIntrospectors(\n        new AnnotationIntrospectorPair(\n            guiceIntrospector,\n            objectMapper.getSerializationConfig().getAnnotationIntrospector()\n        ),\n        new AnnotationIntrospectorPair(\n            guiceIntrospector,\n            objectMapper.getDeserializationConfig().getAnnotationIntrospector()\n        )\n    );\n    GuiceInjectableValues injectableValues = new GuiceInjectableValues(\n        GuiceInjectors.makeStartupInjectorWithModules(\n            ImmutableList.of(\n                binder -> {\n                  binder.bind(AuthorizerMapper.class).toInstance(AuthTestUtils.TEST_AUTHORIZER_MAPPER);\n                  binder.bind(ChatHandlerProvider.class).toInstance(new NoopChatHandlerProvider());\n                  binder.bind(RowIngestionMetersFactory.class).toInstance(ROW_INGESTION_METERS_FACTORY);\n                  binder.bind(CoordinatorClient.class).toInstance(COORDINATOR_CLIENT);\n                  binder.bind(SegmentLoaderFactory.class).toInstance(new SegmentLoaderFactory(null, objectMapper));\n                  binder.bind(AppenderatorsManager.class).toInstance(APPENDERATORS_MANAGER);\n                  binder.bind(IndexingServiceClient.class).toInstance(new NoopIndexingServiceClient());\n                }\n            )\n        )\n    );\n    objectMapper.setInjectableValues(injectableValues);\n    objectMapper.registerSubtypes(new NamedType(ParallelIndexTuningConfig.class, \"index_parallel\"));\n    return objectMapper;\n  }\n","realPath":"indexing-service/src/test/java/org/apache/druid/indexing/common/task/ClientCompactionTaskQuerySerdeTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":320,"status":"M"},{"authorDate":"2021-07-21 02:44:19","commitOrder":10,"curCode":"  private static ObjectMapper setupInjectablesInObjectMapper(ObjectMapper objectMapper)\n  {\n    final GuiceAnnotationIntrospector guiceIntrospector = new GuiceAnnotationIntrospector();\n    objectMapper.setAnnotationIntrospectors(\n        new AnnotationIntrospectorPair(\n            guiceIntrospector,\n            objectMapper.getSerializationConfig().getAnnotationIntrospector()\n        ),\n        new AnnotationIntrospectorPair(\n            guiceIntrospector,\n            objectMapper.getDeserializationConfig().getAnnotationIntrospector()\n        )\n    );\n    GuiceInjectableValues injectableValues = new GuiceInjectableValues(\n        GuiceInjectors.makeStartupInjectorWithModules(\n            ImmutableList.of(\n                binder -> {\n                  binder.bind(AuthorizerMapper.class).toInstance(AuthTestUtils.TEST_AUTHORIZER_MAPPER);\n                  binder.bind(ChatHandlerProvider.class).toInstance(new NoopChatHandlerProvider());\n                  binder.bind(RowIngestionMetersFactory.class).toInstance(TEST_UTILS.getRowIngestionMetersFactory());\n                  binder.bind(CoordinatorClient.class).toInstance(COORDINATOR_CLIENT);\n                  binder.bind(SegmentCacheManagerFactory.class).toInstance(new SegmentCacheManagerFactory(objectMapper));\n                  binder.bind(AppenderatorsManager.class).toInstance(new TestAppenderatorsManager());\n                  binder.bind(IndexingServiceClient.class).toInstance(INDEXING_SERVICE_CLIENT);\n                }\n            )\n        )\n    );\n    objectMapper.setInjectableValues(injectableValues);\n    objectMapper.registerModule(\n        new SimpleModule().registerSubtypes(new NamedType(NumberedShardSpec.class, \"NumberedShardSpec\"))\n    );\n    objectMapper.registerModules(new IndexingServiceTuningConfigModule().getJacksonModules());\n    return objectMapper;\n  }\n","date":"2021-07-21 02:44:19","endLine":293,"groupId":"104422","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"setupInjectablesInObjectMapper","params":"(ObjectMapperobjectMapper)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/ac/9e3d011aef9e7655bf6426661366cead8b80e9.src","preCode":"  private static ObjectMapper setupInjectablesInObjectMapper(ObjectMapper objectMapper)\n  {\n    final GuiceAnnotationIntrospector guiceIntrospector = new GuiceAnnotationIntrospector();\n    objectMapper.setAnnotationIntrospectors(\n        new AnnotationIntrospectorPair(\n            guiceIntrospector,\n            objectMapper.getSerializationConfig().getAnnotationIntrospector()\n        ),\n        new AnnotationIntrospectorPair(\n            guiceIntrospector,\n            objectMapper.getDeserializationConfig().getAnnotationIntrospector()\n        )\n    );\n    GuiceInjectableValues injectableValues = new GuiceInjectableValues(\n        GuiceInjectors.makeStartupInjectorWithModules(\n            ImmutableList.of(\n                binder -> {\n                  binder.bind(AuthorizerMapper.class).toInstance(AuthTestUtils.TEST_AUTHORIZER_MAPPER);\n                  binder.bind(ChatHandlerProvider.class).toInstance(new NoopChatHandlerProvider());\n                  binder.bind(RowIngestionMetersFactory.class).toInstance(TEST_UTILS.getRowIngestionMetersFactory());\n                  binder.bind(CoordinatorClient.class).toInstance(COORDINATOR_CLIENT);\n                  binder.bind(SegmentLoaderFactory.class).toInstance(new SegmentLoaderFactory(null, objectMapper));\n                  binder.bind(AppenderatorsManager.class).toInstance(new TestAppenderatorsManager());\n                  binder.bind(IndexingServiceClient.class).toInstance(INDEXING_SERVICE_CLIENT);\n                }\n            )\n        )\n    );\n    objectMapper.setInjectableValues(injectableValues);\n    objectMapper.registerModule(\n        new SimpleModule().registerSubtypes(new NamedType(NumberedShardSpec.class, \"NumberedShardSpec\"))\n    );\n    objectMapper.registerModules(new IndexingServiceTuningConfigModule().getJacksonModules());\n    return objectMapper;\n  }\n","realPath":"indexing-service/src/test/java/org/apache/druid/indexing/common/task/CompactionTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":259,"status":"M"}],"commitId":"94c1671eaf7b050972602fdedcb1971cdbde692d","commitMessage":"@@@Split SegmentLoader into SegmentLoader and SegmentCacheManager (#11466)\n\nThis PR splits current SegmentLoader into SegmentLoader and SegmentCacheManager.\n\nSegmentLoader - this class is responsible for building the segment object but does not expose any methods for downloading.  cache space management.  etc. Default implementation delegates the download operations to SegmentCacheManager and only contains the logic for building segments once downloaded. . This class will be used in SegmentManager to construct Segment objects.\n\nSegmentCacheManager - this class manages the segment cache on the local disk. It fetches the segment files to the local disk.  can clean up the cache.  and in the future.  support reserve and release on cache space. [See https://github.com/Make SegmentLoader extensible and customizable #11398]. This class will be used in ingestion tasks such as compaction.  re-indexing where segment files need to be downloaded locally.","date":"2021-07-21 02:44:19","modifiedFileCount":"41","status":"M","submitter":"Abhishek Agarwal"}]
