[{"authorTime":"2018-08-31 00:56:26","codes":[{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  private boolean tryAssignTask(final Task task, final RemoteTaskRunnerWorkItem taskRunnerWorkItem) throws Exception\n  {\n    Preconditions.checkNotNull(task, \"task\");\n    Preconditions.checkNotNull(taskRunnerWorkItem, \"taskRunnerWorkItem\");\n    Preconditions.checkArgument(task.getId().equals(taskRunnerWorkItem.getTaskId()), \"task id != workItem id\");\n\n    if (runningTasks.containsKey(task.getId()) || findWorkerRunningTask(task.getId()) != null) {\n      log.info(\"Task[%s] already running.\", task.getId());\n      return true;\n    } else {\n      \r\n      WorkerBehaviorConfig workerConfig = workerConfigRef.get();\n      WorkerSelectStrategy strategy;\n      if (workerConfig == null || workerConfig.getSelectStrategy() == null) {\n        strategy = WorkerBehaviorConfig.DEFAULT_STRATEGY;\n        log.debug(\"No worker selection strategy set. Using default of [%s]\", strategy.getClass().getSimpleName());\n      } else {\n        strategy = workerConfig.getSelectStrategy();\n      }\n\n      ZkWorker assignedWorker = null;\n      final ImmutableWorkerInfo immutableZkWorker;\n      try {\n        synchronized (workersWithUnacknowledgedTask) {\n          immutableZkWorker = strategy.findWorkerForTask(\n              config,\n              ImmutableMap.copyOf(\n                  Maps.transformEntries(\n                      Maps.filterEntries(\n                          zkWorkers, new Predicate<Map.Entry<String, ZkWorker>>()\n                          {\n                            @Override\n                            public boolean apply(Map.Entry<String, ZkWorker> input)\n                            {\n                              return !lazyWorkers.containsKey(input.getKey()) &&\n                                     !workersWithUnacknowledgedTask.containsKey(input.getKey()) &&\n                                     !blackListedWorkers.contains(input.getValue());\n                            }\n                          }\n                      ),\n                      new Maps.EntryTransformer<String, ZkWorker, ImmutableWorkerInfo>()\n                      {\n                        @Override\n                        public ImmutableWorkerInfo transformEntry(\n                            String key, ZkWorker value\n                        )\n                        {\n                          return value.toImmutable();\n                        }\n                      }\n                  )\n              ),\n              task\n          );\n\n          if (immutableZkWorker != null &&\n              workersWithUnacknowledgedTask.putIfAbsent(immutableZkWorker.getWorker().getHost(), task.getId())\n                == null) {\n            assignedWorker = zkWorkers.get(immutableZkWorker.getWorker().getHost());\n          }\n        }\n\n        if (assignedWorker != null) {\n          return announceTask(task, assignedWorker, taskRunnerWorkItem);\n        } else {\n          log.debug(\n              \"Unsuccessful task-assign attempt for task [%s] on workers [%s]. Workers to ack tasks are [%s].\",\n              task.getId(),\n              zkWorkers.values(),\n              workersWithUnacknowledgedTask\n          );\n        }\n\n        return false;\n      }\n      finally {\n        if (assignedWorker != null) {\n          workersWithUnacknowledgedTask.remove(assignedWorker.getWorker().getHost());\n          \r\n          runPendingTasks();\n        }\n      }\n    }\n  }\n","date":"2018-08-31 00:56:26","endLine":845,"groupId":"4659","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"tryAssignTask","params":"(finalTasktask@finalRemoteTaskRunnerWorkItemtaskRunnerWorkItem)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/73/6cab6e3b7ae5c9e9bdc4b45c26d4717b988859.src","preCode":"  private boolean tryAssignTask(final Task task, final RemoteTaskRunnerWorkItem taskRunnerWorkItem) throws Exception\n  {\n    Preconditions.checkNotNull(task, \"task\");\n    Preconditions.checkNotNull(taskRunnerWorkItem, \"taskRunnerWorkItem\");\n    Preconditions.checkArgument(task.getId().equals(taskRunnerWorkItem.getTaskId()), \"task id != workItem id\");\n\n    if (runningTasks.containsKey(task.getId()) || findWorkerRunningTask(task.getId()) != null) {\n      log.info(\"Task[%s] already running.\", task.getId());\n      return true;\n    } else {\n      \r\n      WorkerBehaviorConfig workerConfig = workerConfigRef.get();\n      WorkerSelectStrategy strategy;\n      if (workerConfig == null || workerConfig.getSelectStrategy() == null) {\n        strategy = WorkerBehaviorConfig.DEFAULT_STRATEGY;\n        log.debug(\"No worker selection strategy set. Using default of [%s]\", strategy.getClass().getSimpleName());\n      } else {\n        strategy = workerConfig.getSelectStrategy();\n      }\n\n      ZkWorker assignedWorker = null;\n      final ImmutableWorkerInfo immutableZkWorker;\n      try {\n        synchronized (workersWithUnacknowledgedTask) {\n          immutableZkWorker = strategy.findWorkerForTask(\n              config,\n              ImmutableMap.copyOf(\n                  Maps.transformEntries(\n                      Maps.filterEntries(\n                          zkWorkers, new Predicate<Map.Entry<String, ZkWorker>>()\n                          {\n                            @Override\n                            public boolean apply(Map.Entry<String, ZkWorker> input)\n                            {\n                              return !lazyWorkers.containsKey(input.getKey()) &&\n                                     !workersWithUnacknowledgedTask.containsKey(input.getKey()) &&\n                                     !blackListedWorkers.contains(input.getValue());\n                            }\n                          }\n                      ),\n                      new Maps.EntryTransformer<String, ZkWorker, ImmutableWorkerInfo>()\n                      {\n                        @Override\n                        public ImmutableWorkerInfo transformEntry(\n                            String key, ZkWorker value\n                        )\n                        {\n                          return value.toImmutable();\n                        }\n                      }\n                  )\n              ),\n              task\n          );\n\n          if (immutableZkWorker != null &&\n              workersWithUnacknowledgedTask.putIfAbsent(immutableZkWorker.getWorker().getHost(), task.getId())\n                == null) {\n            assignedWorker = zkWorkers.get(immutableZkWorker.getWorker().getHost());\n          }\n        }\n\n        if (assignedWorker != null) {\n          return announceTask(task, assignedWorker, taskRunnerWorkItem);\n        } else {\n          log.debug(\n              \"Unsuccessful task-assign attempt for task [%s] on workers [%s]. Workers to ack tasks are [%s].\",\n              task.getId(),\n              zkWorkers.values(),\n              workersWithUnacknowledgedTask\n          );\n        }\n\n        return false;\n      }\n      finally {\n        if (assignedWorker != null) {\n          workersWithUnacknowledgedTask.remove(assignedWorker.getWorker().getHost());\n          \r\n          runPendingTasks();\n        }\n      }\n    }\n  }\n","realPath":"indexing-service/src/main/java/org/apache/druid/indexing/overlord/RemoteTaskRunner.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":762,"status":"B"},{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  private ImmutableWorkerInfo findWorkerToRunTask(Task task)\n  {\n    WorkerBehaviorConfig workerConfig = workerConfigRef.get();\n    WorkerSelectStrategy strategy;\n    if (workerConfig == null || workerConfig.getSelectStrategy() == null) {\n      strategy = WorkerBehaviorConfig.DEFAULT_STRATEGY;\n      log.debug(\"No worker selection strategy set. Using default of [%s]\", strategy.getClass().getSimpleName());\n    } else {\n      strategy = workerConfig.getSelectStrategy();\n    }\n\n    return strategy.findWorkerForTask(\n        config,\n        ImmutableMap.copyOf(\n            Maps.transformEntries(\n                Maps.filterEntries(\n                    workers, new Predicate<Map.Entry<String, WorkerHolder>>()\n                    {\n                      @Override\n                      public boolean apply(Map.Entry<String, WorkerHolder> input)\n                      {\n                        return !lazyWorkers.containsKey(input.getKey()) &&\n                               !workersWithUnacknowledgedTask.containsKey(input.getKey()) &&\n                               !blackListedWorkers.containsKey(input.getKey());\n                      }\n                    }\n                ),\n                new Maps.EntryTransformer<String, WorkerHolder, ImmutableWorkerInfo>()\n                {\n                  @Override\n                  public ImmutableWorkerInfo transformEntry(\n                      String key, WorkerHolder value\n                  )\n                  {\n                    return value.toImmutable();\n                  }\n                }\n            )\n        ),\n        task\n    );\n  }\n","date":"2018-08-31 00:56:26","endLine":357,"groupId":"22933","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"findWorkerToRunTask","params":"(Tasktask)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/ae/8cd0ddd86c2ac57c4b82064904af624e730c5e.src","preCode":"  private ImmutableWorkerInfo findWorkerToRunTask(Task task)\n  {\n    WorkerBehaviorConfig workerConfig = workerConfigRef.get();\n    WorkerSelectStrategy strategy;\n    if (workerConfig == null || workerConfig.getSelectStrategy() == null) {\n      strategy = WorkerBehaviorConfig.DEFAULT_STRATEGY;\n      log.debug(\"No worker selection strategy set. Using default of [%s]\", strategy.getClass().getSimpleName());\n    } else {\n      strategy = workerConfig.getSelectStrategy();\n    }\n\n    return strategy.findWorkerForTask(\n        config,\n        ImmutableMap.copyOf(\n            Maps.transformEntries(\n                Maps.filterEntries(\n                    workers, new Predicate<Map.Entry<String, WorkerHolder>>()\n                    {\n                      @Override\n                      public boolean apply(Map.Entry<String, WorkerHolder> input)\n                      {\n                        return !lazyWorkers.containsKey(input.getKey()) &&\n                               !workersWithUnacknowledgedTask.containsKey(input.getKey()) &&\n                               !blackListedWorkers.containsKey(input.getKey());\n                      }\n                    }\n                ),\n                new Maps.EntryTransformer<String, WorkerHolder, ImmutableWorkerInfo>()\n                {\n                  @Override\n                  public ImmutableWorkerInfo transformEntry(\n                      String key, WorkerHolder value\n                  )\n                  {\n                    return value.toImmutable();\n                  }\n                }\n            )\n        ),\n        task\n    );\n  }\n","realPath":"indexing-service/src/main/java/org/apache/druid/indexing/overlord/hrtr/HttpRemoteTaskRunner.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":316,"status":"B"}],"commitId":"431d3d8497f9079857c3baa7ae7ab4cb44a22355","commitMessage":"@@@Rename io.druid to org.apache.druid. (#6266)\n\n* Rename io.druid to org.apache.druid.\n\n* Fix META-INF files and remove some benchmark results.\n\n* MonitorsConfig update for metrics package migration.\n\n* Reorder some dimensions in inner queries for some reason.\n\n* Fix protobuf tests.\n","date":"2018-08-31 00:56:26","modifiedFileCount":"5","status":"B","submitter":"Gian Merlino"},{"authorTime":"2018-10-23 18:17:38","codes":[{"authorDate":"2018-10-23 18:17:38","commitOrder":2,"curCode":"  private boolean tryAssignTask(final Task task, final RemoteTaskRunnerWorkItem taskRunnerWorkItem) throws Exception\n  {\n    Preconditions.checkNotNull(task, \"task\");\n    Preconditions.checkNotNull(taskRunnerWorkItem, \"taskRunnerWorkItem\");\n    Preconditions.checkArgument(task.getId().equals(taskRunnerWorkItem.getTaskId()), \"task id != workItem id\");\n\n    if (runningTasks.containsKey(task.getId()) || findWorkerRunningTask(task.getId()) != null) {\n      log.info(\"Task[%s] already running.\", task.getId());\n      return true;\n    } else {\n      \r\n      WorkerBehaviorConfig workerConfig = workerConfigRef.get();\n      WorkerSelectStrategy strategy;\n      if (workerConfig == null || workerConfig.getSelectStrategy() == null) {\n        strategy = WorkerBehaviorConfig.DEFAULT_STRATEGY;\n        log.debug(\"No worker selection strategy set. Using default of [%s]\", strategy.getClass().getSimpleName());\n      } else {\n        strategy = workerConfig.getSelectStrategy();\n      }\n\n      ZkWorker assignedWorker = null;\n      final ImmutableWorkerInfo immutableZkWorker;\n      try {\n        synchronized (workersWithUnacknowledgedTask) {\n          immutableZkWorker = strategy.findWorkerForTask(\n              config,\n              ImmutableMap.copyOf(\n                  Maps.transformEntries(\n                      Maps.filterEntries(\n                          zkWorkers,\n                          new Predicate<Map.Entry<String, ZkWorker>>()\n                          {\n                            @Override\n                            public boolean apply(Map.Entry<String, ZkWorker> input)\n                            {\n                              return !lazyWorkers.containsKey(input.getKey()) &&\n                                     !workersWithUnacknowledgedTask.containsKey(input.getKey()) &&\n                                     !blackListedWorkers.contains(input.getValue());\n                            }\n                          }\n                      ),\n                      (String key, ZkWorker value) -> value.toImmutable()\n                  )\n              ),\n              task\n          );\n\n          if (immutableZkWorker != null &&\n              workersWithUnacknowledgedTask.putIfAbsent(immutableZkWorker.getWorker().getHost(), task.getId())\n              == null) {\n            assignedWorker = zkWorkers.get(immutableZkWorker.getWorker().getHost());\n          }\n        }\n\n        if (assignedWorker != null) {\n          return announceTask(task, assignedWorker, taskRunnerWorkItem);\n        } else {\n          log.debug(\n              \"Unsuccessful task-assign attempt for task [%s] on workers [%s]. Workers to ack tasks are [%s].\",\n              task.getId(),\n              zkWorkers.values(),\n              workersWithUnacknowledgedTask\n          );\n        }\n\n        return false;\n      }\n      finally {\n        if (assignedWorker != null) {\n          workersWithUnacknowledgedTask.remove(assignedWorker.getWorker().getHost());\n          \r\n          runPendingTasks();\n        }\n      }\n    }\n  }\n","date":"2018-10-23 18:17:38","endLine":829,"groupId":"19329","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"tryAssignTask","params":"(finalTasktask@finalRemoteTaskRunnerWorkItemtaskRunnerWorkItem)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/bd/e17ef25dc3bfd3f4aa5c8fe2f0c06b0452aa75.src","preCode":"  private boolean tryAssignTask(final Task task, final RemoteTaskRunnerWorkItem taskRunnerWorkItem) throws Exception\n  {\n    Preconditions.checkNotNull(task, \"task\");\n    Preconditions.checkNotNull(taskRunnerWorkItem, \"taskRunnerWorkItem\");\n    Preconditions.checkArgument(task.getId().equals(taskRunnerWorkItem.getTaskId()), \"task id != workItem id\");\n\n    if (runningTasks.containsKey(task.getId()) || findWorkerRunningTask(task.getId()) != null) {\n      log.info(\"Task[%s] already running.\", task.getId());\n      return true;\n    } else {\n      \r\n      WorkerBehaviorConfig workerConfig = workerConfigRef.get();\n      WorkerSelectStrategy strategy;\n      if (workerConfig == null || workerConfig.getSelectStrategy() == null) {\n        strategy = WorkerBehaviorConfig.DEFAULT_STRATEGY;\n        log.debug(\"No worker selection strategy set. Using default of [%s]\", strategy.getClass().getSimpleName());\n      } else {\n        strategy = workerConfig.getSelectStrategy();\n      }\n\n      ZkWorker assignedWorker = null;\n      final ImmutableWorkerInfo immutableZkWorker;\n      try {\n        synchronized (workersWithUnacknowledgedTask) {\n          immutableZkWorker = strategy.findWorkerForTask(\n              config,\n              ImmutableMap.copyOf(\n                  Maps.transformEntries(\n                      Maps.filterEntries(\n                          zkWorkers, new Predicate<Map.Entry<String, ZkWorker>>()\n                          {\n                            @Override\n                            public boolean apply(Map.Entry<String, ZkWorker> input)\n                            {\n                              return !lazyWorkers.containsKey(input.getKey()) &&\n                                     !workersWithUnacknowledgedTask.containsKey(input.getKey()) &&\n                                     !blackListedWorkers.contains(input.getValue());\n                            }\n                          }\n                      ),\n                      new Maps.EntryTransformer<String, ZkWorker, ImmutableWorkerInfo>()\n                      {\n                        @Override\n                        public ImmutableWorkerInfo transformEntry(\n                            String key, ZkWorker value\n                        )\n                        {\n                          return value.toImmutable();\n                        }\n                      }\n                  )\n              ),\n              task\n          );\n\n          if (immutableZkWorker != null &&\n              workersWithUnacknowledgedTask.putIfAbsent(immutableZkWorker.getWorker().getHost(), task.getId())\n              == null) {\n            assignedWorker = zkWorkers.get(immutableZkWorker.getWorker().getHost());\n          }\n        }\n\n        if (assignedWorker != null) {\n          return announceTask(task, assignedWorker, taskRunnerWorkItem);\n        } else {\n          log.debug(\n              \"Unsuccessful task-assign attempt for task [%s] on workers [%s]. Workers to ack tasks are [%s].\",\n              task.getId(),\n              zkWorkers.values(),\n              workersWithUnacknowledgedTask\n          );\n        }\n\n        return false;\n      }\n      finally {\n        if (assignedWorker != null) {\n          workersWithUnacknowledgedTask.remove(assignedWorker.getWorker().getHost());\n          \r\n          runPendingTasks();\n        }\n      }\n    }\n  }\n","realPath":"indexing-service/src/main/java/org/apache/druid/indexing/overlord/RemoteTaskRunner.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":754,"status":"M"},{"authorDate":"2018-10-23 18:17:38","commitOrder":2,"curCode":"  private ImmutableWorkerInfo findWorkerToRunTask(Task task)\n  {\n    WorkerBehaviorConfig workerConfig = workerConfigRef.get();\n    WorkerSelectStrategy strategy;\n    if (workerConfig == null || workerConfig.getSelectStrategy() == null) {\n      strategy = WorkerBehaviorConfig.DEFAULT_STRATEGY;\n      log.debug(\"No worker selection strategy set. Using default of [%s]\", strategy.getClass().getSimpleName());\n    } else {\n      strategy = workerConfig.getSelectStrategy();\n    }\n\n    return strategy.findWorkerForTask(\n        config,\n        ImmutableMap.copyOf(\n            Maps.transformEntries(\n                Maps.filterEntries(\n                    workers,\n                    new Predicate<Map.Entry<String, WorkerHolder>>()\n                    {\n                      @Override\n                      public boolean apply(Map.Entry<String, WorkerHolder> input)\n                      {\n                        return !lazyWorkers.containsKey(input.getKey()) &&\n                               !workersWithUnacknowledgedTask.containsKey(input.getKey()) &&\n                               !blackListedWorkers.containsKey(input.getKey());\n                      }\n                    }\n                ),\n                (String key, WorkerHolder value) -> value.toImmutable()\n            )\n        ),\n        task\n    );\n  }\n","date":"2018-10-23 18:17:38","endLine":349,"groupId":"22933","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"findWorkerToRunTask","params":"(Tasktask)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/89/9be15789abd171b9ef92073a3578f62f31c075.src","preCode":"  private ImmutableWorkerInfo findWorkerToRunTask(Task task)\n  {\n    WorkerBehaviorConfig workerConfig = workerConfigRef.get();\n    WorkerSelectStrategy strategy;\n    if (workerConfig == null || workerConfig.getSelectStrategy() == null) {\n      strategy = WorkerBehaviorConfig.DEFAULT_STRATEGY;\n      log.debug(\"No worker selection strategy set. Using default of [%s]\", strategy.getClass().getSimpleName());\n    } else {\n      strategy = workerConfig.getSelectStrategy();\n    }\n\n    return strategy.findWorkerForTask(\n        config,\n        ImmutableMap.copyOf(\n            Maps.transformEntries(\n                Maps.filterEntries(\n                    workers, new Predicate<Map.Entry<String, WorkerHolder>>()\n                    {\n                      @Override\n                      public boolean apply(Map.Entry<String, WorkerHolder> input)\n                      {\n                        return !lazyWorkers.containsKey(input.getKey()) &&\n                               !workersWithUnacknowledgedTask.containsKey(input.getKey()) &&\n                               !blackListedWorkers.containsKey(input.getKey());\n                      }\n                    }\n                ),\n                new Maps.EntryTransformer<String, WorkerHolder, ImmutableWorkerInfo>()\n                {\n                  @Override\n                  public ImmutableWorkerInfo transformEntry(\n                      String key, WorkerHolder value\n                  )\n                  {\n                    return value.toImmutable();\n                  }\n                }\n            )\n        ),\n        task\n    );\n  }\n","realPath":"indexing-service/src/main/java/org/apache/druid/indexing/overlord/hrtr/HttpRemoteTaskRunner.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":316,"status":"M"}],"commitId":"84ac18dc1bce14afe88ebcccd46da21baefae73d","commitMessage":"@@@Catch some incorrect method parameter or call argument formatting patterns with checkstyle (#6461)\n\n* Catch some incorrect method parameter or call argument formatting patterns with checkstyle\n\n* Fix DiscoveryModule\n\n* Inline parameters_and_arguments.txt\n\n* Fix a bug in PolyBind\n\n* Fix formatting\n","date":"2018-10-23 18:17:38","modifiedFileCount":"339","status":"M","submitter":"Roman Leventov"},{"authorTime":"2019-07-31 00:51:53","codes":[{"authorDate":"2019-07-31 00:51:53","commitOrder":3,"curCode":"  private boolean tryAssignTask(final Task task, final RemoteTaskRunnerWorkItem taskRunnerWorkItem) throws Exception\n  {\n    Preconditions.checkNotNull(task, \"task\");\n    Preconditions.checkNotNull(taskRunnerWorkItem, \"taskRunnerWorkItem\");\n    Preconditions.checkArgument(task.getId().equals(taskRunnerWorkItem.getTaskId()), \"task id != workItem id\");\n\n    if (runningTasks.containsKey(task.getId()) || findWorkerRunningTask(task.getId()) != null) {\n      log.info(\"Task[%s] already running.\", task.getId());\n      return true;\n    } else {\n      \r\n      WorkerBehaviorConfig workerConfig = workerConfigRef.get();\n      WorkerSelectStrategy strategy;\n      if (workerConfig == null || workerConfig.getSelectStrategy() == null) {\n        strategy = WorkerBehaviorConfig.DEFAULT_STRATEGY;\n        log.debug(\"No worker selection strategy set. Using default of [%s]\", strategy.getClass().getSimpleName());\n      } else {\n        strategy = workerConfig.getSelectStrategy();\n      }\n\n      ZkWorker assignedWorker = null;\n      final ImmutableWorkerInfo immutableZkWorker;\n      try {\n        synchronized (workersWithUnacknowledgedTask) {\n          immutableZkWorker = strategy.findWorkerForTask(\n              config,\n              ImmutableMap.copyOf(\n                  Maps.transformEntries(\n                      Maps.filterEntries(\n                          zkWorkers,\n                          input -> !lazyWorkers.containsKey(input.getKey()) &&\n                                 !workersWithUnacknowledgedTask.containsKey(input.getKey()) &&\n                                 !blackListedWorkers.contains(input.getValue())\n                      ),\n                      (String key, ZkWorker value) -> value.toImmutable()\n                  )\n              ),\n              task\n          );\n\n          if (immutableZkWorker != null &&\n              workersWithUnacknowledgedTask.putIfAbsent(immutableZkWorker.getWorker().getHost(), task.getId())\n              == null) {\n            assignedWorker = zkWorkers.get(immutableZkWorker.getWorker().getHost());\n          }\n        }\n\n        if (assignedWorker != null) {\n          return announceTask(task, assignedWorker, taskRunnerWorkItem);\n        } else {\n          log.debug(\n              \"Unsuccessful task-assign attempt for task [%s] on workers [%s]. Workers to ack tasks are [%s].\",\n              task.getId(),\n              zkWorkers.values(),\n              workersWithUnacknowledgedTask\n          );\n        }\n\n        return false;\n      }\n      finally {\n        if (assignedWorker != null) {\n          workersWithUnacknowledgedTask.remove(assignedWorker.getWorker().getHost());\n          \r\n          runPendingTasks();\n        }\n      }\n    }\n  }\n","date":"2019-07-31 00:51:53","endLine":811,"groupId":"142","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"tryAssignTask","params":"(finalTasktask@finalRemoteTaskRunnerWorkItemtaskRunnerWorkItem)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/aa/9a582edf40a7b02a803dd4b8383e43e90109ce.src","preCode":"  private boolean tryAssignTask(final Task task, final RemoteTaskRunnerWorkItem taskRunnerWorkItem) throws Exception\n  {\n    Preconditions.checkNotNull(task, \"task\");\n    Preconditions.checkNotNull(taskRunnerWorkItem, \"taskRunnerWorkItem\");\n    Preconditions.checkArgument(task.getId().equals(taskRunnerWorkItem.getTaskId()), \"task id != workItem id\");\n\n    if (runningTasks.containsKey(task.getId()) || findWorkerRunningTask(task.getId()) != null) {\n      log.info(\"Task[%s] already running.\", task.getId());\n      return true;\n    } else {\n      \r\n      WorkerBehaviorConfig workerConfig = workerConfigRef.get();\n      WorkerSelectStrategy strategy;\n      if (workerConfig == null || workerConfig.getSelectStrategy() == null) {\n        strategy = WorkerBehaviorConfig.DEFAULT_STRATEGY;\n        log.debug(\"No worker selection strategy set. Using default of [%s]\", strategy.getClass().getSimpleName());\n      } else {\n        strategy = workerConfig.getSelectStrategy();\n      }\n\n      ZkWorker assignedWorker = null;\n      final ImmutableWorkerInfo immutableZkWorker;\n      try {\n        synchronized (workersWithUnacknowledgedTask) {\n          immutableZkWorker = strategy.findWorkerForTask(\n              config,\n              ImmutableMap.copyOf(\n                  Maps.transformEntries(\n                      Maps.filterEntries(\n                          zkWorkers,\n                          new Predicate<Map.Entry<String, ZkWorker>>()\n                          {\n                            @Override\n                            public boolean apply(Map.Entry<String, ZkWorker> input)\n                            {\n                              return !lazyWorkers.containsKey(input.getKey()) &&\n                                     !workersWithUnacknowledgedTask.containsKey(input.getKey()) &&\n                                     !blackListedWorkers.contains(input.getValue());\n                            }\n                          }\n                      ),\n                      (String key, ZkWorker value) -> value.toImmutable()\n                  )\n              ),\n              task\n          );\n\n          if (immutableZkWorker != null &&\n              workersWithUnacknowledgedTask.putIfAbsent(immutableZkWorker.getWorker().getHost(), task.getId())\n              == null) {\n            assignedWorker = zkWorkers.get(immutableZkWorker.getWorker().getHost());\n          }\n        }\n\n        if (assignedWorker != null) {\n          return announceTask(task, assignedWorker, taskRunnerWorkItem);\n        } else {\n          log.debug(\n              \"Unsuccessful task-assign attempt for task [%s] on workers [%s]. Workers to ack tasks are [%s].\",\n              task.getId(),\n              zkWorkers.values(),\n              workersWithUnacknowledgedTask\n          );\n        }\n\n        return false;\n      }\n      finally {\n        if (assignedWorker != null) {\n          workersWithUnacknowledgedTask.remove(assignedWorker.getWorker().getHost());\n          \r\n          runPendingTasks();\n        }\n      }\n    }\n  }\n","realPath":"indexing-service/src/main/java/org/apache/druid/indexing/overlord/RemoteTaskRunner.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":743,"status":"M"},{"authorDate":"2019-07-31 00:51:53","commitOrder":3,"curCode":"  private ImmutableWorkerInfo findWorkerToRunTask(Task task)\n  {\n    WorkerBehaviorConfig workerConfig = workerConfigRef.get();\n    WorkerSelectStrategy strategy;\n    if (workerConfig == null || workerConfig.getSelectStrategy() == null) {\n      strategy = WorkerBehaviorConfig.DEFAULT_STRATEGY;\n      log.debug(\"No worker selection strategy set. Using default of [%s]\", strategy.getClass().getSimpleName());\n    } else {\n      strategy = workerConfig.getSelectStrategy();\n    }\n\n    return strategy.findWorkerForTask(\n        config,\n        ImmutableMap.copyOf(\n            Maps.transformEntries(\n                Maps.filterEntries(\n                    workers,\n                    input -> !lazyWorkers.containsKey(input.getKey()) &&\n                           !workersWithUnacknowledgedTask.containsKey(input.getKey()) &&\n                           !blackListedWorkers.containsKey(input.getKey())\n                ),\n                (String key, WorkerHolder value) -> value.toImmutable()\n            )\n        ),\n        task\n    );\n  }\n","date":"2019-07-31 00:51:53","endLine":341,"groupId":"19329","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"findWorkerToRunTask","params":"(Tasktask)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/e5/fa3758e0db1819b7b92c2e32dca363d5703bf7.src","preCode":"  private ImmutableWorkerInfo findWorkerToRunTask(Task task)\n  {\n    WorkerBehaviorConfig workerConfig = workerConfigRef.get();\n    WorkerSelectStrategy strategy;\n    if (workerConfig == null || workerConfig.getSelectStrategy() == null) {\n      strategy = WorkerBehaviorConfig.DEFAULT_STRATEGY;\n      log.debug(\"No worker selection strategy set. Using default of [%s]\", strategy.getClass().getSimpleName());\n    } else {\n      strategy = workerConfig.getSelectStrategy();\n    }\n\n    return strategy.findWorkerForTask(\n        config,\n        ImmutableMap.copyOf(\n            Maps.transformEntries(\n                Maps.filterEntries(\n                    workers,\n                    new Predicate<Map.Entry<String, WorkerHolder>>()\n                    {\n                      @Override\n                      public boolean apply(Map.Entry<String, WorkerHolder> input)\n                      {\n                        return !lazyWorkers.containsKey(input.getKey()) &&\n                               !workersWithUnacknowledgedTask.containsKey(input.getKey()) &&\n                               !blackListedWorkers.containsKey(input.getKey());\n                      }\n                    }\n                ),\n                (String key, WorkerHolder value) -> value.toImmutable()\n            )\n        ),\n        task\n    );\n  }\n","realPath":"indexing-service/src/main/java/org/apache/druid/indexing/overlord/hrtr/HttpRemoteTaskRunner.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":315,"status":"M"}],"commitId":"e016995d1fb6085a48e2e0d0a28504ed955f0293","commitMessage":"@@@Enable Spotbugs: WMI_WRONG_MAP_ITERATOR (#8005)\n\n* WMI_WRONG_MAP_ITERATOR\n\n* Fixed missing loop\n","date":"2019-07-31 00:51:53","modifiedFileCount":"7","status":"M","submitter":"Fokko Driesprong"},{"authorTime":"2019-12-13 06:58:52","codes":[{"authorDate":"2019-07-31 00:51:53","commitOrder":4,"curCode":"  private boolean tryAssignTask(final Task task, final RemoteTaskRunnerWorkItem taskRunnerWorkItem) throws Exception\n  {\n    Preconditions.checkNotNull(task, \"task\");\n    Preconditions.checkNotNull(taskRunnerWorkItem, \"taskRunnerWorkItem\");\n    Preconditions.checkArgument(task.getId().equals(taskRunnerWorkItem.getTaskId()), \"task id != workItem id\");\n\n    if (runningTasks.containsKey(task.getId()) || findWorkerRunningTask(task.getId()) != null) {\n      log.info(\"Task[%s] already running.\", task.getId());\n      return true;\n    } else {\n      \r\n      WorkerBehaviorConfig workerConfig = workerConfigRef.get();\n      WorkerSelectStrategy strategy;\n      if (workerConfig == null || workerConfig.getSelectStrategy() == null) {\n        strategy = WorkerBehaviorConfig.DEFAULT_STRATEGY;\n        log.debug(\"No worker selection strategy set. Using default of [%s]\", strategy.getClass().getSimpleName());\n      } else {\n        strategy = workerConfig.getSelectStrategy();\n      }\n\n      ZkWorker assignedWorker = null;\n      final ImmutableWorkerInfo immutableZkWorker;\n      try {\n        synchronized (workersWithUnacknowledgedTask) {\n          immutableZkWorker = strategy.findWorkerForTask(\n              config,\n              ImmutableMap.copyOf(\n                  Maps.transformEntries(\n                      Maps.filterEntries(\n                          zkWorkers,\n                          input -> !lazyWorkers.containsKey(input.getKey()) &&\n                                 !workersWithUnacknowledgedTask.containsKey(input.getKey()) &&\n                                 !blackListedWorkers.contains(input.getValue())\n                      ),\n                      (String key, ZkWorker value) -> value.toImmutable()\n                  )\n              ),\n              task\n          );\n\n          if (immutableZkWorker != null &&\n              workersWithUnacknowledgedTask.putIfAbsent(immutableZkWorker.getWorker().getHost(), task.getId())\n              == null) {\n            assignedWorker = zkWorkers.get(immutableZkWorker.getWorker().getHost());\n          }\n        }\n\n        if (assignedWorker != null) {\n          return announceTask(task, assignedWorker, taskRunnerWorkItem);\n        } else {\n          log.debug(\n              \"Unsuccessful task-assign attempt for task [%s] on workers [%s]. Workers to ack tasks are [%s].\",\n              task.getId(),\n              zkWorkers.values(),\n              workersWithUnacknowledgedTask\n          );\n        }\n\n        return false;\n      }\n      finally {\n        if (assignedWorker != null) {\n          workersWithUnacknowledgedTask.remove(assignedWorker.getWorker().getHost());\n          \r\n          runPendingTasks();\n        }\n      }\n    }\n  }\n","date":"2019-07-31 00:51:53","endLine":811,"groupId":"142","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"tryAssignTask","params":"(finalTasktask@finalRemoteTaskRunnerWorkItemtaskRunnerWorkItem)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/aa/9a582edf40a7b02a803dd4b8383e43e90109ce.src","preCode":"  private boolean tryAssignTask(final Task task, final RemoteTaskRunnerWorkItem taskRunnerWorkItem) throws Exception\n  {\n    Preconditions.checkNotNull(task, \"task\");\n    Preconditions.checkNotNull(taskRunnerWorkItem, \"taskRunnerWorkItem\");\n    Preconditions.checkArgument(task.getId().equals(taskRunnerWorkItem.getTaskId()), \"task id != workItem id\");\n\n    if (runningTasks.containsKey(task.getId()) || findWorkerRunningTask(task.getId()) != null) {\n      log.info(\"Task[%s] already running.\", task.getId());\n      return true;\n    } else {\n      \r\n      WorkerBehaviorConfig workerConfig = workerConfigRef.get();\n      WorkerSelectStrategy strategy;\n      if (workerConfig == null || workerConfig.getSelectStrategy() == null) {\n        strategy = WorkerBehaviorConfig.DEFAULT_STRATEGY;\n        log.debug(\"No worker selection strategy set. Using default of [%s]\", strategy.getClass().getSimpleName());\n      } else {\n        strategy = workerConfig.getSelectStrategy();\n      }\n\n      ZkWorker assignedWorker = null;\n      final ImmutableWorkerInfo immutableZkWorker;\n      try {\n        synchronized (workersWithUnacknowledgedTask) {\n          immutableZkWorker = strategy.findWorkerForTask(\n              config,\n              ImmutableMap.copyOf(\n                  Maps.transformEntries(\n                      Maps.filterEntries(\n                          zkWorkers,\n                          input -> !lazyWorkers.containsKey(input.getKey()) &&\n                                 !workersWithUnacknowledgedTask.containsKey(input.getKey()) &&\n                                 !blackListedWorkers.contains(input.getValue())\n                      ),\n                      (String key, ZkWorker value) -> value.toImmutable()\n                  )\n              ),\n              task\n          );\n\n          if (immutableZkWorker != null &&\n              workersWithUnacknowledgedTask.putIfAbsent(immutableZkWorker.getWorker().getHost(), task.getId())\n              == null) {\n            assignedWorker = zkWorkers.get(immutableZkWorker.getWorker().getHost());\n          }\n        }\n\n        if (assignedWorker != null) {\n          return announceTask(task, assignedWorker, taskRunnerWorkItem);\n        } else {\n          log.debug(\n              \"Unsuccessful task-assign attempt for task [%s] on workers [%s]. Workers to ack tasks are [%s].\",\n              task.getId(),\n              zkWorkers.values(),\n              workersWithUnacknowledgedTask\n          );\n        }\n\n        return false;\n      }\n      finally {\n        if (assignedWorker != null) {\n          workersWithUnacknowledgedTask.remove(assignedWorker.getWorker().getHost());\n          \r\n          runPendingTasks();\n        }\n      }\n    }\n  }\n","realPath":"indexing-service/src/main/java/org/apache/druid/indexing/overlord/RemoteTaskRunner.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":743,"status":"N"},{"authorDate":"2019-12-13 06:58:52","commitOrder":4,"curCode":"  private ImmutableWorkerInfo findWorkerToRunTask(Task task)\n  {\n    WorkerBehaviorConfig workerConfig = workerConfigRef.get();\n    WorkerSelectStrategy strategy;\n    if (workerConfig == null || workerConfig.getSelectStrategy() == null) {\n      strategy = WorkerBehaviorConfig.DEFAULT_STRATEGY;\n      log.debug(\"No worker selection strategy set. Using default of [%s]\", strategy.getClass().getSimpleName());\n    } else {\n      strategy = workerConfig.getSelectStrategy();\n    }\n\n    return strategy.findWorkerForTask(\n        config,\n        ImmutableMap.copyOf(getWorkersEligibleToRunTasks()),\n        task\n    );\n  }\n","date":"2019-12-13 06:58:52","endLine":370,"groupId":"19329","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"findWorkerToRunTask","params":"(Tasktask)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/e5/549f6c032d9bdebd2152b65987e0488a0f2fb7.src","preCode":"  private ImmutableWorkerInfo findWorkerToRunTask(Task task)\n  {\n    WorkerBehaviorConfig workerConfig = workerConfigRef.get();\n    WorkerSelectStrategy strategy;\n    if (workerConfig == null || workerConfig.getSelectStrategy() == null) {\n      strategy = WorkerBehaviorConfig.DEFAULT_STRATEGY;\n      log.debug(\"No worker selection strategy set. Using default of [%s]\", strategy.getClass().getSimpleName());\n    } else {\n      strategy = workerConfig.getSelectStrategy();\n    }\n\n    return strategy.findWorkerForTask(\n        config,\n        ImmutableMap.copyOf(\n            Maps.transformEntries(\n                Maps.filterEntries(\n                    workers,\n                    input -> !lazyWorkers.containsKey(input.getKey()) &&\n                             !workersWithUnacknowledgedTask.containsKey(input.getKey()) &&\n                             !blackListedWorkers.containsKey(input.getKey())\n                ),\n                (String key, WorkerHolder value) -> value.toImmutable()\n            )\n        ),\n        task\n    );\n  }\n","realPath":"indexing-service/src/main/java/org/apache/druid/indexing/overlord/hrtr/HttpRemoteTaskRunner.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":354,"status":"M"}],"commitId":"45101183bc76639c86e4eaa59cbf401f6fe90c18","commitMessage":"@@@HRTR: make pending task execution handling to go through all tasks on not finding worker slots (#8697)\n\n* HRTR: make pending task execution handling to go through all tasks on\nnot finding worker slots\n\n* make HRTR methods package private that are meant to be used only in HttpRemoteTaskRunnerResource\n\n* mark HttpRemoteTaskRunnerWorkItem.State global variables final\n\n* hrtr: move immutableWorker NULL check outside of try-catch or finally block could have NPE\n\n* add some explanatory comments\n\n* add comment on explaining mechanics around hand off of pending tasks from submission to it getting picked up by a task execution thread\n\n* fix spelling\n","date":"2019-12-13 06:58:52","modifiedFileCount":"7","status":"M","submitter":"Himanshu"},{"authorTime":"2019-12-13 06:58:52","codes":[{"authorDate":"2020-09-29 14:50:38","commitOrder":5,"curCode":"  private boolean tryAssignTask(final Task task, final RemoteTaskRunnerWorkItem taskRunnerWorkItem) throws Exception\n  {\n    Preconditions.checkNotNull(task, \"task\");\n    Preconditions.checkNotNull(taskRunnerWorkItem, \"taskRunnerWorkItem\");\n    Preconditions.checkArgument(task.getId().equals(taskRunnerWorkItem.getTaskId()), \"task id != workItem id\");\n\n    if (runningTasks.containsKey(task.getId()) || findWorkerRunningTask(task.getId()) != null) {\n      log.info(\"Task[%s] already running.\", task.getId());\n      return true;\n    } else {\n      \r\n      WorkerBehaviorConfig workerConfig = workerConfigRef.get();\n      WorkerSelectStrategy strategy;\n      if (workerConfig == null || workerConfig.getSelectStrategy() == null) {\n        strategy = WorkerBehaviorConfig.DEFAULT_STRATEGY;\n        log.debug(\"No worker selection strategy set. Using default of [%s]\", strategy.getClass().getSimpleName());\n      } else {\n        strategy = workerConfig.getSelectStrategy();\n      }\n\n      ZkWorker assignedWorker = null;\n      final ImmutableWorkerInfo immutableZkWorker;\n      try {\n        synchronized (workersWithUnacknowledgedTask) {\n          immutableZkWorker = strategy.findWorkerForTask(\n              config,\n              ImmutableMap.copyOf(getWorkersEligibleToRunTasks()),\n              task\n          );\n\n          if (immutableZkWorker != null &&\n              workersWithUnacknowledgedTask.putIfAbsent(immutableZkWorker.getWorker().getHost(), task.getId())\n              == null) {\n            assignedWorker = zkWorkers.get(immutableZkWorker.getWorker().getHost());\n          }\n        }\n\n        if (assignedWorker != null) {\n          return announceTask(task, assignedWorker, taskRunnerWorkItem);\n        } else {\n          log.debug(\n              \"Unsuccessful task-assign attempt for task [%s] on workers [%s]. Workers to ack tasks are [%s].\",\n              task.getId(),\n              zkWorkers.values(),\n              workersWithUnacknowledgedTask\n          );\n        }\n\n        return false;\n      }\n      finally {\n        if (assignedWorker != null) {\n          workersWithUnacknowledgedTask.remove(assignedWorker.getWorker().getHost());\n          \r\n          runPendingTasks();\n        }\n      }\n    }\n  }\n","date":"2020-09-29 14:50:38","endLine":858,"groupId":"104703","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"tryAssignTask","params":"(finalTasktask@finalRemoteTaskRunnerWorkItemtaskRunnerWorkItem)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/6f/d3f7fa32815aa92f417a521b2dbb7e09896b97.src","preCode":"  private boolean tryAssignTask(final Task task, final RemoteTaskRunnerWorkItem taskRunnerWorkItem) throws Exception\n  {\n    Preconditions.checkNotNull(task, \"task\");\n    Preconditions.checkNotNull(taskRunnerWorkItem, \"taskRunnerWorkItem\");\n    Preconditions.checkArgument(task.getId().equals(taskRunnerWorkItem.getTaskId()), \"task id != workItem id\");\n\n    if (runningTasks.containsKey(task.getId()) || findWorkerRunningTask(task.getId()) != null) {\n      log.info(\"Task[%s] already running.\", task.getId());\n      return true;\n    } else {\n      \r\n      WorkerBehaviorConfig workerConfig = workerConfigRef.get();\n      WorkerSelectStrategy strategy;\n      if (workerConfig == null || workerConfig.getSelectStrategy() == null) {\n        strategy = WorkerBehaviorConfig.DEFAULT_STRATEGY;\n        log.debug(\"No worker selection strategy set. Using default of [%s]\", strategy.getClass().getSimpleName());\n      } else {\n        strategy = workerConfig.getSelectStrategy();\n      }\n\n      ZkWorker assignedWorker = null;\n      final ImmutableWorkerInfo immutableZkWorker;\n      try {\n        synchronized (workersWithUnacknowledgedTask) {\n          immutableZkWorker = strategy.findWorkerForTask(\n              config,\n              ImmutableMap.copyOf(\n                  Maps.transformEntries(\n                      Maps.filterEntries(\n                          zkWorkers,\n                          input -> !lazyWorkers.containsKey(input.getKey()) &&\n                                   !workersWithUnacknowledgedTask.containsKey(input.getKey()) &&\n                                   !blackListedWorkers.contains(input.getValue())\n                      ),\n                      (String key, ZkWorker value) -> value.toImmutable()\n                  )\n              ),\n              task\n          );\n\n          if (immutableZkWorker != null &&\n              workersWithUnacknowledgedTask.putIfAbsent(immutableZkWorker.getWorker().getHost(), task.getId())\n              == null) {\n            assignedWorker = zkWorkers.get(immutableZkWorker.getWorker().getHost());\n          }\n        }\n\n        if (assignedWorker != null) {\n          return announceTask(task, assignedWorker, taskRunnerWorkItem);\n        } else {\n          log.debug(\n              \"Unsuccessful task-assign attempt for task [%s] on workers [%s]. Workers to ack tasks are [%s].\",\n              task.getId(),\n              zkWorkers.values(),\n              workersWithUnacknowledgedTask\n          );\n        }\n\n        return false;\n      }\n      finally {\n        if (assignedWorker != null) {\n          workersWithUnacknowledgedTask.remove(assignedWorker.getWorker().getHost());\n          \r\n          runPendingTasks();\n        }\n      }\n    }\n  }\n","realPath":"indexing-service/src/main/java/org/apache/druid/indexing/overlord/RemoteTaskRunner.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":800,"status":"M"},{"authorDate":"2019-12-13 06:58:52","commitOrder":5,"curCode":"  private ImmutableWorkerInfo findWorkerToRunTask(Task task)\n  {\n    WorkerBehaviorConfig workerConfig = workerConfigRef.get();\n    WorkerSelectStrategy strategy;\n    if (workerConfig == null || workerConfig.getSelectStrategy() == null) {\n      strategy = WorkerBehaviorConfig.DEFAULT_STRATEGY;\n      log.debug(\"No worker selection strategy set. Using default of [%s]\", strategy.getClass().getSimpleName());\n    } else {\n      strategy = workerConfig.getSelectStrategy();\n    }\n\n    return strategy.findWorkerForTask(\n        config,\n        ImmutableMap.copyOf(getWorkersEligibleToRunTasks()),\n        task\n    );\n  }\n","date":"2019-12-13 06:58:52","endLine":370,"groupId":"104703","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"findWorkerToRunTask","params":"(Tasktask)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/e5/549f6c032d9bdebd2152b65987e0488a0f2fb7.src","preCode":"  private ImmutableWorkerInfo findWorkerToRunTask(Task task)\n  {\n    WorkerBehaviorConfig workerConfig = workerConfigRef.get();\n    WorkerSelectStrategy strategy;\n    if (workerConfig == null || workerConfig.getSelectStrategy() == null) {\n      strategy = WorkerBehaviorConfig.DEFAULT_STRATEGY;\n      log.debug(\"No worker selection strategy set. Using default of [%s]\", strategy.getClass().getSimpleName());\n    } else {\n      strategy = workerConfig.getSelectStrategy();\n    }\n\n    return strategy.findWorkerForTask(\n        config,\n        ImmutableMap.copyOf(getWorkersEligibleToRunTasks()),\n        task\n    );\n  }\n","realPath":"indexing-service/src/main/java/org/apache/druid/indexing/overlord/hrtr/HttpRemoteTaskRunner.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":354,"status":"N"}],"commitId":"8168e14e9224c9459efda07b038269815975cf50","commitMessage":"@@@Adding task slot count metrics to Druid Overlord (#10379)\n\n* Adding more worker metrics to Druid Overlord\n\n* Changing the nomenclature from worker to peon as that represents the metrics that we want to monitor better\n\n* Few more instance of worker usage replaced with peon\n\n* Modifying the peon idle count logic to only use eligible workers available capacity\n\n* Changing the naming to task slot count instead of peon\n\n* Adding some unit test coverage for the new test runner apis\n\n* Addressing Review Comments\n\n* Modifying the TaskSlotCountStatsProvider apis so that overlords which are not leader do not emit these metrics\n\n* Fixing the spelling issue in the docs\n\n* Setting the annotation Nullable on the TaskSlotCountStatsProvider methods","date":"2020-09-29 14:50:38","modifiedFileCount":"14","status":"M","submitter":"Mainak Ghosh"}]
