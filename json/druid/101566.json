[{"authorTime":"2020-06-04 07:46:28","codes":[{"authorDate":"2020-06-04 07:46:28","commitOrder":1,"curCode":"  public void testJoinOuterGroupByAndSubqueryNoLimit() throws Exception\n  {\n    \r\n    cannotVectorize();\n\n    testQuery(\n        \"SELECT dim2, AVG(m2) FROM (SELECT * FROM foo AS t1 INNER JOIN foo AS t2 ON t1.m1 = t2.m1) AS t3 GROUP BY dim2\",\n        ImmutableList.of(\n            GroupByQuery.builder()\n                        .setDataSource(\n                            join(\n                                new TableDataSource(CalciteTests.DATASOURCE1),\n                                new QueryDataSource(\n                                    newScanQueryBuilder()\n                                        .dataSource(CalciteTests.DATASOURCE1)\n                                        .intervals(querySegmentSpec(Filtration.eternity()))\n                                        .columns(ImmutableList.of(\"m1\"))\n                                        .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                                        .context(QUERY_CONTEXT_DEFAULT)\n                                        .build()\n                                ),\n                                \"j0.\",\n                                equalsCondition(\n                                    DruidExpression.fromColumn(\"m1\"),\n                                    DruidExpression.fromColumn(\"j0.m1\")\n                                ),\n                                JoinType.INNER\n                            )\n                        )\n                        .setInterval(querySegmentSpec(Filtration.eternity()))\n                        .setDimensions(new DefaultDimensionSpec(\"dim2\", \"d0\", ValueType.STRING))\n                        .setGranularity(Granularities.ALL)\n                        .setAggregatorSpecs(aggregators(\n                            new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                            new CountAggregatorFactory(\"a0:count\")\n                                            )\n                        )\n                        .setPostAggregatorSpecs(\n                            ImmutableList.of(\n                                new ArithmeticPostAggregator(\n                                    \"a0\",\n                                    \"quotient\",\n                                    ImmutableList.of(\n                                        new FieldAccessPostAggregator(null, \"a0:sum\"),\n                                        new FieldAccessPostAggregator(null, \"a0:count\")\n                                    )\n                                )\n\n                            )\n                        )\n                        .setContext(QUERY_CONTEXT_DEFAULT)\n                        .build()\n        ),\n        NullHandling.sqlCompatible()\n        ? ImmutableList.of(\n            new Object[]{null, 4.0},\n            new Object[]{\"\", 3.0},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n        : ImmutableList.of(\n            new Object[]{\"\", 3.6666666666666665},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n    );\n  }\n","date":"2020-06-04 07:46:28","endLine":308,"groupId":"13697","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoinOuterGroupByAndSubqueryNoLimit","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/80/68a0d9e38b7f8629d5cf759c2492a4d2cb8fd4.src","preCode":"  public void testJoinOuterGroupByAndSubqueryNoLimit() throws Exception\n  {\n    \r\n    cannotVectorize();\n\n    testQuery(\n        \"SELECT dim2, AVG(m2) FROM (SELECT * FROM foo AS t1 INNER JOIN foo AS t2 ON t1.m1 = t2.m1) AS t3 GROUP BY dim2\",\n        ImmutableList.of(\n            GroupByQuery.builder()\n                        .setDataSource(\n                            join(\n                                new TableDataSource(CalciteTests.DATASOURCE1),\n                                new QueryDataSource(\n                                    newScanQueryBuilder()\n                                        .dataSource(CalciteTests.DATASOURCE1)\n                                        .intervals(querySegmentSpec(Filtration.eternity()))\n                                        .columns(ImmutableList.of(\"m1\"))\n                                        .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                                        .context(QUERY_CONTEXT_DEFAULT)\n                                        .build()\n                                ),\n                                \"j0.\",\n                                equalsCondition(\n                                    DruidExpression.fromColumn(\"m1\"),\n                                    DruidExpression.fromColumn(\"j0.m1\")\n                                ),\n                                JoinType.INNER\n                            )\n                        )\n                        .setInterval(querySegmentSpec(Filtration.eternity()))\n                        .setDimensions(new DefaultDimensionSpec(\"dim2\", \"d0\", ValueType.STRING))\n                        .setGranularity(Granularities.ALL)\n                        .setAggregatorSpecs(aggregators(\n                            new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                            new CountAggregatorFactory(\"a0:count\")\n                                            )\n                        )\n                        .setPostAggregatorSpecs(\n                            ImmutableList.of(\n                                new ArithmeticPostAggregator(\n                                    \"a0\",\n                                    \"quotient\",\n                                    ImmutableList.of(\n                                        new FieldAccessPostAggregator(null, \"a0:sum\"),\n                                        new FieldAccessPostAggregator(null, \"a0:count\")\n                                    )\n                                )\n\n                            )\n                        )\n                        .setContext(QUERY_CONTEXT_DEFAULT)\n                        .build()\n        ),\n        NullHandling.sqlCompatible()\n        ? ImmutableList.of(\n            new Object[]{null, 4.0},\n            new Object[]{\"\", 3.0},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n        : ImmutableList.of(\n            new Object[]{\"\", 3.6666666666666665},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n    );\n  }\n","realPath":"sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":242,"status":"B"},{"authorDate":"2020-06-04 07:46:28","commitOrder":1,"curCode":"  public void testJoinWithLimitBeforeJoining() throws Exception\n  {\n    \r\n    cannotVectorize();\n\n    testQuery(\n        \"SELECT t1.dim2, AVG(t1.m2) FROM (SELECT * FROM foo LIMIT 10) AS t1 INNER JOIN foo AS t2 ON t1.m1 = t2.m1 GROUP BY t1.dim2\",\n        ImmutableList.of(\n            GroupByQuery.builder()\n                        .setDataSource(\n                            join(\n                                new QueryDataSource(\n                                  newScanQueryBuilder()\n                                      .dataSource(CalciteTests.DATASOURCE1)\n                                      .intervals(querySegmentSpec(Filtration.eternity()))\n                                      .columns(\"dim2\", \"m1\", \"m2\")\n                                      .context(QUERY_CONTEXT_DEFAULT)\n                                      .limit(10)\n                                      .build()\n                                ),\n                                new QueryDataSource(\n                                    newScanQueryBuilder()\n                                        .dataSource(CalciteTests.DATASOURCE1)\n                                        .intervals(querySegmentSpec(Filtration.eternity()))\n                                        .columns(ImmutableList.of(\"m1\"))\n                                        .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                                        .context(QUERY_CONTEXT_DEFAULT)\n                                        .build()\n                                ),\n                                \"j0.\",\n                                equalsCondition(\n                                    DruidExpression.fromColumn(\"m1\"),\n                                    DruidExpression.fromColumn(\"j0.m1\")\n                                ),\n                                JoinType.INNER\n                            )\n                        )\n                        .setInterval(querySegmentSpec(Filtration.eternity()))\n                        .setDimensions(new DefaultDimensionSpec(\"dim2\", \"d0\", ValueType.STRING))\n                        .setGranularity(Granularities.ALL)\n                        .setAggregatorSpecs(aggregators(\n                            new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                            new CountAggregatorFactory(\"a0:count\")\n                                            )\n                        )\n                        .setPostAggregatorSpecs(\n                            ImmutableList.of(\n                                new ArithmeticPostAggregator(\n                                    \"a0\",\n                                    \"quotient\",\n                                    ImmutableList.of(\n                                        new FieldAccessPostAggregator(null, \"a0:sum\"),\n                                        new FieldAccessPostAggregator(null, \"a0:count\")\n                                    )\n                                )\n\n                            )\n                        )\n                        .setContext(QUERY_CONTEXT_DEFAULT)\n                        .build()\n        ),\n        NullHandling.sqlCompatible()\n        ? ImmutableList.of(\n            new Object[]{null, 4.0},\n            new Object[]{\"\", 3.0},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n        : ImmutableList.of(\n            new Object[]{\"\", 3.6666666666666665},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n    );\n  }\n","date":"2020-06-04 07:46:28","endLine":385,"groupId":"13697","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoinWithLimitBeforeJoining","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/80/68a0d9e38b7f8629d5cf759c2492a4d2cb8fd4.src","preCode":"  public void testJoinWithLimitBeforeJoining() throws Exception\n  {\n    \r\n    cannotVectorize();\n\n    testQuery(\n        \"SELECT t1.dim2, AVG(t1.m2) FROM (SELECT * FROM foo LIMIT 10) AS t1 INNER JOIN foo AS t2 ON t1.m1 = t2.m1 GROUP BY t1.dim2\",\n        ImmutableList.of(\n            GroupByQuery.builder()\n                        .setDataSource(\n                            join(\n                                new QueryDataSource(\n                                  newScanQueryBuilder()\n                                      .dataSource(CalciteTests.DATASOURCE1)\n                                      .intervals(querySegmentSpec(Filtration.eternity()))\n                                      .columns(\"dim2\", \"m1\", \"m2\")\n                                      .context(QUERY_CONTEXT_DEFAULT)\n                                      .limit(10)\n                                      .build()\n                                ),\n                                new QueryDataSource(\n                                    newScanQueryBuilder()\n                                        .dataSource(CalciteTests.DATASOURCE1)\n                                        .intervals(querySegmentSpec(Filtration.eternity()))\n                                        .columns(ImmutableList.of(\"m1\"))\n                                        .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                                        .context(QUERY_CONTEXT_DEFAULT)\n                                        .build()\n                                ),\n                                \"j0.\",\n                                equalsCondition(\n                                    DruidExpression.fromColumn(\"m1\"),\n                                    DruidExpression.fromColumn(\"j0.m1\")\n                                ),\n                                JoinType.INNER\n                            )\n                        )\n                        .setInterval(querySegmentSpec(Filtration.eternity()))\n                        .setDimensions(new DefaultDimensionSpec(\"dim2\", \"d0\", ValueType.STRING))\n                        .setGranularity(Granularities.ALL)\n                        .setAggregatorSpecs(aggregators(\n                            new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                            new CountAggregatorFactory(\"a0:count\")\n                                            )\n                        )\n                        .setPostAggregatorSpecs(\n                            ImmutableList.of(\n                                new ArithmeticPostAggregator(\n                                    \"a0\",\n                                    \"quotient\",\n                                    ImmutableList.of(\n                                        new FieldAccessPostAggregator(null, \"a0:sum\"),\n                                        new FieldAccessPostAggregator(null, \"a0:count\")\n                                    )\n                                )\n\n                            )\n                        )\n                        .setContext(QUERY_CONTEXT_DEFAULT)\n                        .build()\n        ),\n        NullHandling.sqlCompatible()\n        ? ImmutableList.of(\n            new Object[]{null, 4.0},\n            new Object[]{\"\", 3.0},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n        : ImmutableList.of(\n            new Object[]{\"\", 3.6666666666666665},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n    );\n  }\n","realPath":"sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":311,"status":"B"}],"commitId":"790e9482ea18d87d59eeeeab4ceec14e4b1e192d","commitMessage":"@@@Fix Subquery could not be converted to groupBy query (#9959)\n\n* Fix join\n\n* Fix Subquery could not be converted to groupBy query\n\n* Fix Subquery could not be converted to groupBy query\n\n* Fix Subquery could not be converted to groupBy query\n\n* Fix Subquery could not be converted to groupBy query\n\n* Fix Subquery could not be converted to groupBy query\n\n* Fix Subquery could not be converted to groupBy query\n\n* Fix Subquery could not be converted to groupBy query\n\n* Fix Subquery could not be converted to groupBy query\n\n* add tests\n\n* address comments\n\n* fix failing tests","date":"2020-06-04 07:46:28","modifiedFileCount":"12","status":"B","submitter":"Maytas Monsereenusorn"},{"authorTime":"2020-07-08 23:38:56","codes":[{"authorDate":"2020-07-08 23:38:56","commitOrder":2,"curCode":"  public void testJoinOuterGroupByAndSubqueryNoLimit() throws Exception\n  {\n    \r\n    cannotVectorize();\n\n    testQuery(\n        \"SELECT dim2, AVG(m2) FROM (SELECT * FROM foo AS t1 INNER JOIN foo AS t2 ON t1.m1 = t2.m1) AS t3 GROUP BY dim2\",\n        ImmutableList.of(\n            GroupByQuery.builder()\n                        .setDataSource(\n                            join(\n                                new TableDataSource(CalciteTests.DATASOURCE1),\n                                new QueryDataSource(\n                                    newScanQueryBuilder()\n                                        .dataSource(CalciteTests.DATASOURCE1)\n                                        .intervals(querySegmentSpec(Filtration.eternity()))\n                                        .columns(ImmutableList.of(\"m1\"))\n                                        .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                                        .context(QUERY_CONTEXT_DEFAULT)\n                                        .build()\n                                ),\n                                \"j0.\",\n                                equalsCondition(\n                                    DruidExpression.fromColumn(\"m1\"),\n                                    DruidExpression.fromColumn(\"j0.m1\")\n                                ),\n                                JoinType.INNER\n                            )\n                        )\n                        .setInterval(querySegmentSpec(Filtration.eternity()))\n                        .setDimensions(new DefaultDimensionSpec(\"dim2\", \"d0\", ValueType.STRING))\n                        .setGranularity(Granularities.ALL)\n                        .setAggregatorSpecs(\n                            useDefault\n                            ? aggregators(\n                                new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                                new CountAggregatorFactory(\"a0:count\")\n                            )\n                            : aggregators(\n                                new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                                new FilteredAggregatorFactory(\n                                    new CountAggregatorFactory(\"a0:count\"),\n                                    not(selector(\"m2\", null, null))\n                                )\n                            )\n                        )\n                        .setPostAggregatorSpecs(\n                            ImmutableList.of(\n                                new ArithmeticPostAggregator(\n                                    \"a0\",\n                                    \"quotient\",\n                                    ImmutableList.of(\n                                        new FieldAccessPostAggregator(null, \"a0:sum\"),\n                                        new FieldAccessPostAggregator(null, \"a0:count\")\n                                    )\n                                )\n\n                            )\n                        )\n                        .setContext(QUERY_CONTEXT_DEFAULT)\n                        .build()\n        ),\n        NullHandling.sqlCompatible()\n        ? ImmutableList.of(\n            new Object[]{null, 4.0},\n            new Object[]{\"\", 3.0},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n        : ImmutableList.of(\n            new Object[]{\"\", 3.6666666666666665},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n    );\n  }\n","date":"2020-07-08 23:38:56","endLine":368,"groupId":"13697","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoinOuterGroupByAndSubqueryNoLimit","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/de/ffe204d42ebe73c27bc4d0353e239d4c1ab61d.src","preCode":"  public void testJoinOuterGroupByAndSubqueryNoLimit() throws Exception\n  {\n    \r\n    cannotVectorize();\n\n    testQuery(\n        \"SELECT dim2, AVG(m2) FROM (SELECT * FROM foo AS t1 INNER JOIN foo AS t2 ON t1.m1 = t2.m1) AS t3 GROUP BY dim2\",\n        ImmutableList.of(\n            GroupByQuery.builder()\n                        .setDataSource(\n                            join(\n                                new TableDataSource(CalciteTests.DATASOURCE1),\n                                new QueryDataSource(\n                                    newScanQueryBuilder()\n                                        .dataSource(CalciteTests.DATASOURCE1)\n                                        .intervals(querySegmentSpec(Filtration.eternity()))\n                                        .columns(ImmutableList.of(\"m1\"))\n                                        .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                                        .context(QUERY_CONTEXT_DEFAULT)\n                                        .build()\n                                ),\n                                \"j0.\",\n                                equalsCondition(\n                                    DruidExpression.fromColumn(\"m1\"),\n                                    DruidExpression.fromColumn(\"j0.m1\")\n                                ),\n                                JoinType.INNER\n                            )\n                        )\n                        .setInterval(querySegmentSpec(Filtration.eternity()))\n                        .setDimensions(new DefaultDimensionSpec(\"dim2\", \"d0\", ValueType.STRING))\n                        .setGranularity(Granularities.ALL)\n                        .setAggregatorSpecs(aggregators(\n                            new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                            new CountAggregatorFactory(\"a0:count\")\n                                            )\n                        )\n                        .setPostAggregatorSpecs(\n                            ImmutableList.of(\n                                new ArithmeticPostAggregator(\n                                    \"a0\",\n                                    \"quotient\",\n                                    ImmutableList.of(\n                                        new FieldAccessPostAggregator(null, \"a0:sum\"),\n                                        new FieldAccessPostAggregator(null, \"a0:count\")\n                                    )\n                                )\n\n                            )\n                        )\n                        .setContext(QUERY_CONTEXT_DEFAULT)\n                        .build()\n        ),\n        NullHandling.sqlCompatible()\n        ? ImmutableList.of(\n            new Object[]{null, 4.0},\n            new Object[]{\"\", 3.0},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n        : ImmutableList.of(\n            new Object[]{\"\", 3.6666666666666665},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n    );\n  }\n","realPath":"sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":293,"status":"M"},{"authorDate":"2020-07-08 23:38:56","commitOrder":2,"curCode":"  public void testJoinWithLimitBeforeJoining() throws Exception\n  {\n    \r\n    cannotVectorize();\n\n    testQuery(\n        \"SELECT t1.dim2, AVG(t1.m2) FROM (SELECT * FROM foo LIMIT 10) AS t1 INNER JOIN foo AS t2 ON t1.m1 = t2.m1 GROUP BY t1.dim2\",\n        ImmutableList.of(\n            GroupByQuery.builder()\n                        .setDataSource(\n                            join(\n                                new QueryDataSource(\n                                  newScanQueryBuilder()\n                                      .dataSource(CalciteTests.DATASOURCE1)\n                                      .intervals(querySegmentSpec(Filtration.eternity()))\n                                      .columns(\"dim2\", \"m1\", \"m2\")\n                                      .context(QUERY_CONTEXT_DEFAULT)\n                                      .limit(10)\n                                      .build()\n                                ),\n                                new QueryDataSource(\n                                    newScanQueryBuilder()\n                                        .dataSource(CalciteTests.DATASOURCE1)\n                                        .intervals(querySegmentSpec(Filtration.eternity()))\n                                        .columns(ImmutableList.of(\"m1\"))\n                                        .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                                        .context(QUERY_CONTEXT_DEFAULT)\n                                        .build()\n                                ),\n                                \"j0.\",\n                                equalsCondition(\n                                    DruidExpression.fromColumn(\"m1\"),\n                                    DruidExpression.fromColumn(\"j0.m1\")\n                                ),\n                                JoinType.INNER\n                            )\n                        )\n                        .setInterval(querySegmentSpec(Filtration.eternity()))\n                        .setDimensions(new DefaultDimensionSpec(\"dim2\", \"d0\", ValueType.STRING))\n                        .setGranularity(Granularities.ALL)\n                        .setAggregatorSpecs(\n                            useDefault\n                            ? aggregators(\n                                new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                                new CountAggregatorFactory(\"a0:count\")\n                            )\n                            : aggregators(\n                                new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                                new FilteredAggregatorFactory(\n                                    new CountAggregatorFactory(\"a0:count\"),\n                                    not(selector(\"m2\", null, null))\n                                )\n                            )\n                        )\n                        .setPostAggregatorSpecs(\n                            ImmutableList.of(\n                                new ArithmeticPostAggregator(\n                                    \"a0\",\n                                    \"quotient\",\n                                    ImmutableList.of(\n                                        new FieldAccessPostAggregator(null, \"a0:sum\"),\n                                        new FieldAccessPostAggregator(null, \"a0:count\")\n                                    )\n                                )\n\n                            )\n                        )\n                        .setContext(QUERY_CONTEXT_DEFAULT)\n                        .build()\n        ),\n        NullHandling.sqlCompatible()\n        ? ImmutableList.of(\n            new Object[]{null, 4.0},\n            new Object[]{\"\", 3.0},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n        : ImmutableList.of(\n            new Object[]{\"\", 3.6666666666666665},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n    );\n  }\n","date":"2020-07-08 23:38:56","endLine":454,"groupId":"13697","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoinWithLimitBeforeJoining","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/de/ffe204d42ebe73c27bc4d0353e239d4c1ab61d.src","preCode":"  public void testJoinWithLimitBeforeJoining() throws Exception\n  {\n    \r\n    cannotVectorize();\n\n    testQuery(\n        \"SELECT t1.dim2, AVG(t1.m2) FROM (SELECT * FROM foo LIMIT 10) AS t1 INNER JOIN foo AS t2 ON t1.m1 = t2.m1 GROUP BY t1.dim2\",\n        ImmutableList.of(\n            GroupByQuery.builder()\n                        .setDataSource(\n                            join(\n                                new QueryDataSource(\n                                  newScanQueryBuilder()\n                                      .dataSource(CalciteTests.DATASOURCE1)\n                                      .intervals(querySegmentSpec(Filtration.eternity()))\n                                      .columns(\"dim2\", \"m1\", \"m2\")\n                                      .context(QUERY_CONTEXT_DEFAULT)\n                                      .limit(10)\n                                      .build()\n                                ),\n                                new QueryDataSource(\n                                    newScanQueryBuilder()\n                                        .dataSource(CalciteTests.DATASOURCE1)\n                                        .intervals(querySegmentSpec(Filtration.eternity()))\n                                        .columns(ImmutableList.of(\"m1\"))\n                                        .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                                        .context(QUERY_CONTEXT_DEFAULT)\n                                        .build()\n                                ),\n                                \"j0.\",\n                                equalsCondition(\n                                    DruidExpression.fromColumn(\"m1\"),\n                                    DruidExpression.fromColumn(\"j0.m1\")\n                                ),\n                                JoinType.INNER\n                            )\n                        )\n                        .setInterval(querySegmentSpec(Filtration.eternity()))\n                        .setDimensions(new DefaultDimensionSpec(\"dim2\", \"d0\", ValueType.STRING))\n                        .setGranularity(Granularities.ALL)\n                        .setAggregatorSpecs(aggregators(\n                            new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                            new CountAggregatorFactory(\"a0:count\")\n                                            )\n                        )\n                        .setPostAggregatorSpecs(\n                            ImmutableList.of(\n                                new ArithmeticPostAggregator(\n                                    \"a0\",\n                                    \"quotient\",\n                                    ImmutableList.of(\n                                        new FieldAccessPostAggregator(null, \"a0:sum\"),\n                                        new FieldAccessPostAggregator(null, \"a0:count\")\n                                    )\n                                )\n\n                            )\n                        )\n                        .setContext(QUERY_CONTEXT_DEFAULT)\n                        .build()\n        ),\n        NullHandling.sqlCompatible()\n        ? ImmutableList.of(\n            new Object[]{null, 4.0},\n            new Object[]{\"\", 3.0},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n        : ImmutableList.of(\n            new Object[]{\"\", 3.6666666666666665},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n    );\n  }\n","realPath":"sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":371,"status":"M"}],"commitId":"1b9aacb1cd1d16b23de2f4485e1398640e97f8bd","commitMessage":"@@@Fix avg sql aggregator (#10135)\n\n* new average aggregator\n\n* method to create count aggregator factory\n\n* test everything\n\n* update other usages\n\n* fix style\n\n* fix more tests\n\n* fix datasketches tests","date":"2020-07-08 23:38:56","modifiedFileCount":"5","status":"M","submitter":"Franklyn Dsouza"},{"authorTime":"2020-07-08 23:38:56","codes":[{"authorDate":"2021-04-15 01:49:27","commitOrder":3,"curCode":"  public void testJoinOuterGroupByAndSubqueryNoLimit(Map<String, Object> queryContext) throws Exception\n  {\n    \r\n    if (!isRewriteJoinToFilter(queryContext)) {\n      cannotVectorize();\n    }\n\n    testQuery(\n        \"SELECT dim2, AVG(m2) FROM (SELECT * FROM foo AS t1 INNER JOIN foo AS t2 ON t1.m1 = t2.m1) AS t3 GROUP BY dim2\",\n        queryContext,\n        ImmutableList.of(\n            GroupByQuery.builder()\n                        .setDataSource(\n                            join(\n                                new TableDataSource(CalciteTests.DATASOURCE1),\n                                new QueryDataSource(\n                                    newScanQueryBuilder()\n                                        .dataSource(CalciteTests.DATASOURCE1)\n                                        .intervals(querySegmentSpec(Filtration.eternity()))\n                                        .columns(ImmutableList.of(\"m1\"))\n                                        .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                                        .context(QUERY_CONTEXT_DEFAULT)\n                                        .build()\n                                        .withOverriddenContext(queryContext)\n                                ),\n                                \"j0.\",\n                                equalsCondition(\n                                    DruidExpression.fromColumn(\"m1\"),\n                                    DruidExpression.fromColumn(\"j0.m1\")\n                                ),\n                                JoinType.INNER\n                            )\n                        )\n                        .setInterval(querySegmentSpec(Filtration.eternity()))\n                        .setDimensions(new DefaultDimensionSpec(\"dim2\", \"d0\", ValueType.STRING))\n                        .setGranularity(Granularities.ALL)\n                        .setAggregatorSpecs(\n                            useDefault\n                            ? aggregators(\n                                new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                                new CountAggregatorFactory(\"a0:count\")\n                            )\n                            : aggregators(\n                                new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                                new FilteredAggregatorFactory(\n                                    new CountAggregatorFactory(\"a0:count\"),\n                                    not(selector(\"m2\", null, null))\n                                )\n                            )\n                        )\n                        .setPostAggregatorSpecs(\n                            ImmutableList.of(\n                                new ArithmeticPostAggregator(\n                                    \"a0\",\n                                    \"quotient\",\n                                    ImmutableList.of(\n                                        new FieldAccessPostAggregator(null, \"a0:sum\"),\n                                        new FieldAccessPostAggregator(null, \"a0:count\")\n                                    )\n                                )\n\n                            )\n                        )\n                        .setContext(QUERY_CONTEXT_DEFAULT)\n                        .build()\n                        .withOverriddenContext(queryContext)\n        ),\n        NullHandling.sqlCompatible()\n        ? ImmutableList.of(\n            new Object[]{null, 4.0},\n            new Object[]{\"\", 3.0},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n        : ImmutableList.of(\n            new Object[]{\"\", 3.6666666666666665},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n    );\n  }\n","date":"2021-04-15 01:49:27","endLine":454,"groupId":"101566","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoinOuterGroupByAndSubqueryNoLimit","params":"(Map<String@Object>queryContext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/e4/7a89a5f784d8e7b5f15645a5dacf38a7460d1d.src","preCode":"  public void testJoinOuterGroupByAndSubqueryNoLimit() throws Exception\n  {\n    \r\n    cannotVectorize();\n\n    testQuery(\n        \"SELECT dim2, AVG(m2) FROM (SELECT * FROM foo AS t1 INNER JOIN foo AS t2 ON t1.m1 = t2.m1) AS t3 GROUP BY dim2\",\n        ImmutableList.of(\n            GroupByQuery.builder()\n                        .setDataSource(\n                            join(\n                                new TableDataSource(CalciteTests.DATASOURCE1),\n                                new QueryDataSource(\n                                    newScanQueryBuilder()\n                                        .dataSource(CalciteTests.DATASOURCE1)\n                                        .intervals(querySegmentSpec(Filtration.eternity()))\n                                        .columns(ImmutableList.of(\"m1\"))\n                                        .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                                        .context(QUERY_CONTEXT_DEFAULT)\n                                        .build()\n                                ),\n                                \"j0.\",\n                                equalsCondition(\n                                    DruidExpression.fromColumn(\"m1\"),\n                                    DruidExpression.fromColumn(\"j0.m1\")\n                                ),\n                                JoinType.INNER\n                            )\n                        )\n                        .setInterval(querySegmentSpec(Filtration.eternity()))\n                        .setDimensions(new DefaultDimensionSpec(\"dim2\", \"d0\", ValueType.STRING))\n                        .setGranularity(Granularities.ALL)\n                        .setAggregatorSpecs(\n                            useDefault\n                            ? aggregators(\n                                new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                                new CountAggregatorFactory(\"a0:count\")\n                            )\n                            : aggregators(\n                                new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                                new FilteredAggregatorFactory(\n                                    new CountAggregatorFactory(\"a0:count\"),\n                                    not(selector(\"m2\", null, null))\n                                )\n                            )\n                        )\n                        .setPostAggregatorSpecs(\n                            ImmutableList.of(\n                                new ArithmeticPostAggregator(\n                                    \"a0\",\n                                    \"quotient\",\n                                    ImmutableList.of(\n                                        new FieldAccessPostAggregator(null, \"a0:sum\"),\n                                        new FieldAccessPostAggregator(null, \"a0:count\")\n                                    )\n                                )\n\n                            )\n                        )\n                        .setContext(QUERY_CONTEXT_DEFAULT)\n                        .build()\n        ),\n        NullHandling.sqlCompatible()\n        ? ImmutableList.of(\n            new Object[]{null, 4.0},\n            new Object[]{\"\", 3.0},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n        : ImmutableList.of(\n            new Object[]{\"\", 3.6666666666666665},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n    );\n  }\n","realPath":"sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":374,"status":"M"},{"authorDate":"2020-07-08 23:38:56","commitOrder":3,"curCode":"  public void testJoinWithLimitBeforeJoining() throws Exception\n  {\n    \r\n    cannotVectorize();\n\n    testQuery(\n        \"SELECT t1.dim2, AVG(t1.m2) FROM (SELECT * FROM foo LIMIT 10) AS t1 INNER JOIN foo AS t2 ON t1.m1 = t2.m1 GROUP BY t1.dim2\",\n        ImmutableList.of(\n            GroupByQuery.builder()\n                        .setDataSource(\n                            join(\n                                new QueryDataSource(\n                                  newScanQueryBuilder()\n                                      .dataSource(CalciteTests.DATASOURCE1)\n                                      .intervals(querySegmentSpec(Filtration.eternity()))\n                                      .columns(\"dim2\", \"m1\", \"m2\")\n                                      .context(QUERY_CONTEXT_DEFAULT)\n                                      .limit(10)\n                                      .build()\n                                ),\n                                new QueryDataSource(\n                                    newScanQueryBuilder()\n                                        .dataSource(CalciteTests.DATASOURCE1)\n                                        .intervals(querySegmentSpec(Filtration.eternity()))\n                                        .columns(ImmutableList.of(\"m1\"))\n                                        .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                                        .context(QUERY_CONTEXT_DEFAULT)\n                                        .build()\n                                ),\n                                \"j0.\",\n                                equalsCondition(\n                                    DruidExpression.fromColumn(\"m1\"),\n                                    DruidExpression.fromColumn(\"j0.m1\")\n                                ),\n                                JoinType.INNER\n                            )\n                        )\n                        .setInterval(querySegmentSpec(Filtration.eternity()))\n                        .setDimensions(new DefaultDimensionSpec(\"dim2\", \"d0\", ValueType.STRING))\n                        .setGranularity(Granularities.ALL)\n                        .setAggregatorSpecs(\n                            useDefault\n                            ? aggregators(\n                                new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                                new CountAggregatorFactory(\"a0:count\")\n                            )\n                            : aggregators(\n                                new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                                new FilteredAggregatorFactory(\n                                    new CountAggregatorFactory(\"a0:count\"),\n                                    not(selector(\"m2\", null, null))\n                                )\n                            )\n                        )\n                        .setPostAggregatorSpecs(\n                            ImmutableList.of(\n                                new ArithmeticPostAggregator(\n                                    \"a0\",\n                                    \"quotient\",\n                                    ImmutableList.of(\n                                        new FieldAccessPostAggregator(null, \"a0:sum\"),\n                                        new FieldAccessPostAggregator(null, \"a0:count\")\n                                    )\n                                )\n\n                            )\n                        )\n                        .setContext(QUERY_CONTEXT_DEFAULT)\n                        .build()\n        ),\n        NullHandling.sqlCompatible()\n        ? ImmutableList.of(\n            new Object[]{null, 4.0},\n            new Object[]{\"\", 3.0},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n        : ImmutableList.of(\n            new Object[]{\"\", 3.6666666666666665},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n    );\n  }\n","date":"2020-07-08 23:38:56","endLine":454,"groupId":"101566","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoinWithLimitBeforeJoining","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/de/ffe204d42ebe73c27bc4d0353e239d4c1ab61d.src","preCode":"  public void testJoinWithLimitBeforeJoining() throws Exception\n  {\n    \r\n    cannotVectorize();\n\n    testQuery(\n        \"SELECT t1.dim2, AVG(t1.m2) FROM (SELECT * FROM foo LIMIT 10) AS t1 INNER JOIN foo AS t2 ON t1.m1 = t2.m1 GROUP BY t1.dim2\",\n        ImmutableList.of(\n            GroupByQuery.builder()\n                        .setDataSource(\n                            join(\n                                new QueryDataSource(\n                                  newScanQueryBuilder()\n                                      .dataSource(CalciteTests.DATASOURCE1)\n                                      .intervals(querySegmentSpec(Filtration.eternity()))\n                                      .columns(\"dim2\", \"m1\", \"m2\")\n                                      .context(QUERY_CONTEXT_DEFAULT)\n                                      .limit(10)\n                                      .build()\n                                ),\n                                new QueryDataSource(\n                                    newScanQueryBuilder()\n                                        .dataSource(CalciteTests.DATASOURCE1)\n                                        .intervals(querySegmentSpec(Filtration.eternity()))\n                                        .columns(ImmutableList.of(\"m1\"))\n                                        .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                                        .context(QUERY_CONTEXT_DEFAULT)\n                                        .build()\n                                ),\n                                \"j0.\",\n                                equalsCondition(\n                                    DruidExpression.fromColumn(\"m1\"),\n                                    DruidExpression.fromColumn(\"j0.m1\")\n                                ),\n                                JoinType.INNER\n                            )\n                        )\n                        .setInterval(querySegmentSpec(Filtration.eternity()))\n                        .setDimensions(new DefaultDimensionSpec(\"dim2\", \"d0\", ValueType.STRING))\n                        .setGranularity(Granularities.ALL)\n                        .setAggregatorSpecs(\n                            useDefault\n                            ? aggregators(\n                                new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                                new CountAggregatorFactory(\"a0:count\")\n                            )\n                            : aggregators(\n                                new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                                new FilteredAggregatorFactory(\n                                    new CountAggregatorFactory(\"a0:count\"),\n                                    not(selector(\"m2\", null, null))\n                                )\n                            )\n                        )\n                        .setPostAggregatorSpecs(\n                            ImmutableList.of(\n                                new ArithmeticPostAggregator(\n                                    \"a0\",\n                                    \"quotient\",\n                                    ImmutableList.of(\n                                        new FieldAccessPostAggregator(null, \"a0:sum\"),\n                                        new FieldAccessPostAggregator(null, \"a0:count\")\n                                    )\n                                )\n\n                            )\n                        )\n                        .setContext(QUERY_CONTEXT_DEFAULT)\n                        .build()\n        ),\n        NullHandling.sqlCompatible()\n        ? ImmutableList.of(\n            new Object[]{null, 4.0},\n            new Object[]{\"\", 3.0},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n        : ImmutableList.of(\n            new Object[]{\"\", 3.6666666666666665},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n    );\n  }\n","realPath":"sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":371,"status":"N"}],"commitId":"202c78c8f32bd3ec5e70e021b1494d878f38d678","commitMessage":"@@@Enable rewriting certain inner joins as filters. (#11068)\n\n* Enable rewriting certain inner joins as filters.\n\nThe main logic for doing the rewrite is in JoinableFactoryWrapper's\nsegmentMapFn method. The requirements are:\n\n- It must be an inner equi-join.\n- The right-hand columns referenced by the condition must not contain any\n  duplicate values. (If they did.  the inner join would not be guaranteed\n  to return at most one row for each left-hand-side row.)\n- No columns from the right-hand side can be used by anything other than\n  the join condition itself.\n\nHashJoinSegmentStorageAdapter is also modified to pass through to\nthe base adapter (even allowing vectorization!) in the case where 100%\nof join clauses could be rewritten as filters.\n\nIn support of this goal:\n\n- Add Query getRequiredColumns() method to help us figure out whether\n  the right-hand side of a join datasource is being used or not.\n- Add JoinConditionAnalysis getRequiredColumns() method to help us\n  figure out if the right-hand side of a join is being used by later\n  join clauses acting on the same base.\n- Add Joinable getNonNullColumnValuesIfAllUnique method to enable\n  retrieving the set of values that will form the \"in\" filter.\n- Add LookupExtractor canGetKeySet() and keySet() methods to support\n  LookupJoinable in its efforts to implement the new Joinable method.\n- Add \"enableRewriteJoinToFilter\" feature flag to\n  JoinFilterRewriteConfig. The default is disabled.\n\n* Test improvements.\n\n* Test fixes.\n\n* Avoid slow size() call.\n\n* Remove invalid test.\n\n* Fix style.\n\n* Fix mistaken default.\n\n* Small fixes.\n\n* Fix logic error.","date":"2021-04-15 01:49:27","modifiedFileCount":"38","status":"M","submitter":"Gian Merlino"}]
