[{"authorTime":"2021-09-06 01:57:45","codes":[{"authorDate":"2021-09-06 01:57:45","commitOrder":1,"curCode":"  public void testCancelBetweenValidateAndPlan() throws Exception\n  {\n    final String sqlQueryId = \"toCancel\";\n    lifecycleAddLatch = new CountDownLatch(1);\n    CountDownLatch validateAndAuthorizeLatch = new CountDownLatch(1);\n    validateAndAuthorizeLatchSupplier.set(new NonnullPair<>(validateAndAuthorizeLatch, true));\n    CountDownLatch planLatch = new CountDownLatch(1);\n    planLatchSupplier.set(new NonnullPair<>(planLatch, false));\n    Future<Response> future = executorService.submit(\n        () -> resource.doPost(\n            createSimpleQueryWithId(sqlQueryId, \"SELECT DISTINCT dim1 FROM foo\"),\n            makeExpectedReq()\n        )\n    );\n    Assert.assertTrue(validateAndAuthorizeLatch.await(1, TimeUnit.SECONDS));\n    Assert.assertTrue(lifecycleAddLatch.await(1, TimeUnit.SECONDS));\n    Response response = resource.cancelQuery(sqlQueryId, mockRequestForCancel());\n    planLatch.countDown();\n    Assert.assertEquals(Status.ACCEPTED.getStatusCode(), response.getStatus());\n\n    Assert.assertTrue(lifecycleManager.getAll(sqlQueryId).isEmpty());\n\n    response = future.get();\n    Assert.assertEquals(Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());\n    QueryException exception = JSON_MAPPER.readValue((byte[]) response.getEntity(), QueryException.class);\n    Assert.assertEquals(\n        QueryInterruptedException.QUERY_CANCELLED,\n        exception.getErrorCode()\n    );\n  }\n","date":"2021-09-06 01:57:45","endLine":1000,"groupId":"17533","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testCancelBetweenValidateAndPlan","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/02/f596adbdaab2d96bcd83e41fc1de166d07cb8a.src","preCode":"  public void testCancelBetweenValidateAndPlan() throws Exception\n  {\n    final String sqlQueryId = \"toCancel\";\n    lifecycleAddLatch = new CountDownLatch(1);\n    CountDownLatch validateAndAuthorizeLatch = new CountDownLatch(1);\n    validateAndAuthorizeLatchSupplier.set(new NonnullPair<>(validateAndAuthorizeLatch, true));\n    CountDownLatch planLatch = new CountDownLatch(1);\n    planLatchSupplier.set(new NonnullPair<>(planLatch, false));\n    Future<Response> future = executorService.submit(\n        () -> resource.doPost(\n            createSimpleQueryWithId(sqlQueryId, \"SELECT DISTINCT dim1 FROM foo\"),\n            makeExpectedReq()\n        )\n    );\n    Assert.assertTrue(validateAndAuthorizeLatch.await(1, TimeUnit.SECONDS));\n    Assert.assertTrue(lifecycleAddLatch.await(1, TimeUnit.SECONDS));\n    Response response = resource.cancelQuery(sqlQueryId, mockRequestForCancel());\n    planLatch.countDown();\n    Assert.assertEquals(Status.ACCEPTED.getStatusCode(), response.getStatus());\n\n    Assert.assertTrue(lifecycleManager.getAll(sqlQueryId).isEmpty());\n\n    response = future.get();\n    Assert.assertEquals(Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());\n    QueryException exception = JSON_MAPPER.readValue((byte[]) response.getEntity(), QueryException.class);\n    Assert.assertEquals(\n        QueryInterruptedException.QUERY_CANCELLED,\n        exception.getErrorCode()\n    );\n  }\n","realPath":"sql/src/test/java/org/apache/druid/sql/http/SqlResourceTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":971,"status":"B"},{"authorDate":"2021-09-06 01:57:45","commitOrder":1,"curCode":"  public void testCancelBetweenPlanAndExecute() throws Exception\n  {\n    final String sqlQueryId = \"toCancel\";\n    CountDownLatch planLatch = new CountDownLatch(1);\n    planLatchSupplier.set(new NonnullPair<>(planLatch, true));\n    CountDownLatch execLatch = new CountDownLatch(1);\n    executeLatchSupplier.set(new NonnullPair<>(execLatch, false));\n    Future<Response> future = executorService.submit(\n        () -> resource.doPost(\n            createSimpleQueryWithId(sqlQueryId, \"SELECT DISTINCT dim1 FROM foo\"),\n            makeExpectedReq()\n        )\n    );\n    Assert.assertTrue(planLatch.await(1, TimeUnit.SECONDS));\n    Response response = resource.cancelQuery(sqlQueryId, mockRequestForCancel());\n    execLatch.countDown();\n    Assert.assertEquals(Status.ACCEPTED.getStatusCode(), response.getStatus());\n\n    Assert.assertTrue(lifecycleManager.getAll(sqlQueryId).isEmpty());\n\n    response = future.get();\n    Assert.assertEquals(Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());\n    QueryException exception = JSON_MAPPER.readValue((byte[]) response.getEntity(), QueryException.class);\n    Assert.assertEquals(\n        QueryInterruptedException.QUERY_CANCELLED,\n        exception.getErrorCode()\n    );\n  }\n","date":"2021-09-06 01:57:45","endLine":1030,"groupId":"17533","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testCancelBetweenPlanAndExecute","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/02/f596adbdaab2d96bcd83e41fc1de166d07cb8a.src","preCode":"  public void testCancelBetweenPlanAndExecute() throws Exception\n  {\n    final String sqlQueryId = \"toCancel\";\n    CountDownLatch planLatch = new CountDownLatch(1);\n    planLatchSupplier.set(new NonnullPair<>(planLatch, true));\n    CountDownLatch execLatch = new CountDownLatch(1);\n    executeLatchSupplier.set(new NonnullPair<>(execLatch, false));\n    Future<Response> future = executorService.submit(\n        () -> resource.doPost(\n            createSimpleQueryWithId(sqlQueryId, \"SELECT DISTINCT dim1 FROM foo\"),\n            makeExpectedReq()\n        )\n    );\n    Assert.assertTrue(planLatch.await(1, TimeUnit.SECONDS));\n    Response response = resource.cancelQuery(sqlQueryId, mockRequestForCancel());\n    execLatch.countDown();\n    Assert.assertEquals(Status.ACCEPTED.getStatusCode(), response.getStatus());\n\n    Assert.assertTrue(lifecycleManager.getAll(sqlQueryId).isEmpty());\n\n    response = future.get();\n    Assert.assertEquals(Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());\n    QueryException exception = JSON_MAPPER.readValue((byte[]) response.getEntity(), QueryException.class);\n    Assert.assertEquals(\n        QueryInterruptedException.QUERY_CANCELLED,\n        exception.getErrorCode()\n    );\n  }\n","realPath":"sql/src/test/java/org/apache/druid/sql/http/SqlResourceTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1003,"status":"B"}],"commitId":"82049bbf0a6409c09889ba9b3ea6131c9da86705","commitMessage":"@@@Cancel API for sqls (#11643)\n\n* initial work\n\n* reduce lock in sqlLifecycle\n\n* Integration test for sql canceling\n\n* javadoc.  cleanup.  more tests\n\n* log level to debug\n\n* fix test\n\n* checkstyle\n\n* fix flaky test; address comments\n\n* rowTransformer\n\n* cancelled state\n\n* use lock\n\n* explode instead of noop\n\n* oops\n\n* unused import\n\n* less aggressive with state\n\n* fix calcite charset\n\n* don't emit metrics when you are not authorized","date":"2021-09-06 01:57:45","modifiedFileCount":"17","status":"B","submitter":"Jihoon Son"},{"authorTime":"2021-09-15 18:32:19","codes":[{"authorDate":"2021-09-15 18:32:19","commitOrder":2,"curCode":"  public void testCancelBetweenValidateAndPlan() throws Exception\n  {\n    final String sqlQueryId = \"toCancel\";\n    lifecycleAddLatch = new CountDownLatch(1);\n    CountDownLatch validateAndAuthorizeLatch = new CountDownLatch(1);\n    validateAndAuthorizeLatchSupplier.set(new NonnullPair<>(validateAndAuthorizeLatch, true));\n    CountDownLatch planLatch = new CountDownLatch(1);\n    planLatchSupplier.set(new NonnullPair<>(planLatch, false));\n    Future<Response> future = executorService.submit(\n        () -> resource.doPost(\n            createSimpleQueryWithId(sqlQueryId, \"SELECT DISTINCT dim1 FROM foo\"),\n            makeRegularUserReq()\n        )\n    );\n    Assert.assertTrue(validateAndAuthorizeLatch.await(1, TimeUnit.SECONDS));\n    Assert.assertTrue(lifecycleAddLatch.await(1, TimeUnit.SECONDS));\n    Response response = resource.cancelQuery(sqlQueryId, mockRequestForCancel());\n    planLatch.countDown();\n    Assert.assertEquals(Status.ACCEPTED.getStatusCode(), response.getStatus());\n\n    Assert.assertTrue(lifecycleManager.getAll(sqlQueryId).isEmpty());\n\n    response = future.get();\n    Assert.assertEquals(Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());\n    QueryException exception = JSON_MAPPER.readValue((byte[]) response.getEntity(), QueryException.class);\n    Assert.assertEquals(\n        QueryInterruptedException.QUERY_CANCELLED,\n        exception.getErrorCode()\n    );\n  }\n","date":"2021-09-15 18:32:19","endLine":1075,"groupId":"101556","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testCancelBetweenValidateAndPlan","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/87/0342afb5c1a3f98595648f19620c2c9286a19b.src","preCode":"  public void testCancelBetweenValidateAndPlan() throws Exception\n  {\n    final String sqlQueryId = \"toCancel\";\n    lifecycleAddLatch = new CountDownLatch(1);\n    CountDownLatch validateAndAuthorizeLatch = new CountDownLatch(1);\n    validateAndAuthorizeLatchSupplier.set(new NonnullPair<>(validateAndAuthorizeLatch, true));\n    CountDownLatch planLatch = new CountDownLatch(1);\n    planLatchSupplier.set(new NonnullPair<>(planLatch, false));\n    Future<Response> future = executorService.submit(\n        () -> resource.doPost(\n            createSimpleQueryWithId(sqlQueryId, \"SELECT DISTINCT dim1 FROM foo\"),\n            makeExpectedReq()\n        )\n    );\n    Assert.assertTrue(validateAndAuthorizeLatch.await(1, TimeUnit.SECONDS));\n    Assert.assertTrue(lifecycleAddLatch.await(1, TimeUnit.SECONDS));\n    Response response = resource.cancelQuery(sqlQueryId, mockRequestForCancel());\n    planLatch.countDown();\n    Assert.assertEquals(Status.ACCEPTED.getStatusCode(), response.getStatus());\n\n    Assert.assertTrue(lifecycleManager.getAll(sqlQueryId).isEmpty());\n\n    response = future.get();\n    Assert.assertEquals(Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());\n    QueryException exception = JSON_MAPPER.readValue((byte[]) response.getEntity(), QueryException.class);\n    Assert.assertEquals(\n        QueryInterruptedException.QUERY_CANCELLED,\n        exception.getErrorCode()\n    );\n  }\n","realPath":"sql/src/test/java/org/apache/druid/sql/http/SqlResourceTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1046,"status":"M"},{"authorDate":"2021-09-15 18:32:19","commitOrder":2,"curCode":"  public void testCancelBetweenPlanAndExecute() throws Exception\n  {\n    final String sqlQueryId = \"toCancel\";\n    CountDownLatch planLatch = new CountDownLatch(1);\n    planLatchSupplier.set(new NonnullPair<>(planLatch, true));\n    CountDownLatch execLatch = new CountDownLatch(1);\n    executeLatchSupplier.set(new NonnullPair<>(execLatch, false));\n    Future<Response> future = executorService.submit(\n        () -> resource.doPost(\n            createSimpleQueryWithId(sqlQueryId, \"SELECT DISTINCT dim1 FROM foo\"),\n            makeRegularUserReq()\n        )\n    );\n    Assert.assertTrue(planLatch.await(1, TimeUnit.SECONDS));\n    Response response = resource.cancelQuery(sqlQueryId, mockRequestForCancel());\n    execLatch.countDown();\n    Assert.assertEquals(Status.ACCEPTED.getStatusCode(), response.getStatus());\n\n    Assert.assertTrue(lifecycleManager.getAll(sqlQueryId).isEmpty());\n\n    response = future.get();\n    Assert.assertEquals(Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());\n    QueryException exception = JSON_MAPPER.readValue((byte[]) response.getEntity(), QueryException.class);\n    Assert.assertEquals(\n        QueryInterruptedException.QUERY_CANCELLED,\n        exception.getErrorCode()\n    );\n  }\n","date":"2021-09-15 18:32:19","endLine":1105,"groupId":"101556","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testCancelBetweenPlanAndExecute","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/87/0342afb5c1a3f98595648f19620c2c9286a19b.src","preCode":"  public void testCancelBetweenPlanAndExecute() throws Exception\n  {\n    final String sqlQueryId = \"toCancel\";\n    CountDownLatch planLatch = new CountDownLatch(1);\n    planLatchSupplier.set(new NonnullPair<>(planLatch, true));\n    CountDownLatch execLatch = new CountDownLatch(1);\n    executeLatchSupplier.set(new NonnullPair<>(execLatch, false));\n    Future<Response> future = executorService.submit(\n        () -> resource.doPost(\n            createSimpleQueryWithId(sqlQueryId, \"SELECT DISTINCT dim1 FROM foo\"),\n            makeExpectedReq()\n        )\n    );\n    Assert.assertTrue(planLatch.await(1, TimeUnit.SECONDS));\n    Response response = resource.cancelQuery(sqlQueryId, mockRequestForCancel());\n    execLatch.countDown();\n    Assert.assertEquals(Status.ACCEPTED.getStatusCode(), response.getStatus());\n\n    Assert.assertTrue(lifecycleManager.getAll(sqlQueryId).isEmpty());\n\n    response = future.get();\n    Assert.assertEquals(Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());\n    QueryException exception = JSON_MAPPER.readValue((byte[]) response.getEntity(), QueryException.class);\n    Assert.assertEquals(\n        QueryInterruptedException.QUERY_CANCELLED,\n        exception.getErrorCode()\n    );\n  }\n","realPath":"sql/src/test/java/org/apache/druid/sql/http/SqlResourceTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":1078,"status":"M"}],"commitId":"0cbd71ebda5888a1decafbbd1269cfa50a1c8065","commitMessage":"@@@Return forbidden when authorization fails for sql query canceling (#11710)\n\nSwitching http response code for authorization failures for sql query canceling to match to sql query posting.","date":"2021-09-15 18:32:19","modifiedFileCount":"2","status":"M","submitter":"Jihoon Son"}]
