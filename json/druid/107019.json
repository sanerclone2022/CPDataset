[{"authorTime":"2020-01-17 13:02:02","codes":[{"authorDate":"2020-01-17 13:02:02","commitOrder":4,"curCode":"  public void testBufferAggregateWithFoldCheck()\n  {\n    final long[] timestamps = {1526724600L, 1526724700L, 1526724800L, 1526725900L, 1526725000L};\n    final String[] strings = {\"AAAA\", \"BBBB\", \"CCCC\", \"DDDD\", \"EEEE\"};\n    Integer maxStringBytes = 1024;\n\n    TestLongColumnSelector longColumnSelector = new TestLongColumnSelector(timestamps);\n    TestObjectColumnSelector<String> objectColumnSelector = new TestObjectColumnSelector<>(strings);\n\n    StringFirstAggregatorFactory factory = new StringFirstAggregatorFactory(\n        \"billy\", \"billy\", maxStringBytes\n    );\n\n    StringFirstBufferAggregator agg = new StringFirstBufferAggregator(\n        longColumnSelector,\n        objectColumnSelector,\n        maxStringBytes,\n        true\n    );\n\n    ByteBuffer buf = ByteBuffer.allocate(factory.getMaxIntermediateSize());\n    int position = 0;\n\n    agg.init(buf, position);\n    \r\n    for (int i = 0; i < timestamps.length; i++) {\n      aggregateBuffer(longColumnSelector, objectColumnSelector, agg, buf, position);\n    }\n\n    SerializablePairLongString sp = ((SerializablePairLongString) agg.get(buf, position));\n\n\n    Assert.assertEquals(\"expected last string value\", strings[0], sp.rhs);\n    Assert.assertEquals(\"last string timestamp is the biggest\", new Long(timestamps[0]), new Long(sp.lhs));\n  }\n","date":"2020-01-17 13:02:02","endLine":118,"groupId":"6562","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testBufferAggregateWithFoldCheck","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/3b/4ef692bf5238c53369a22a299cbc3a5c4e8efa.src","preCode":"  public void testBufferAggregateWithFoldCheck()\n  {\n    final long[] timestamps = {1526724600L, 1526724700L, 1526724800L, 1526725900L, 1526725000L};\n    final String[] strings = {\"AAAA\", \"BBBB\", \"CCCC\", \"DDDD\", \"EEEE\"};\n    Integer maxStringBytes = 1024;\n\n    TestLongColumnSelector longColumnSelector = new TestLongColumnSelector(timestamps);\n    TestObjectColumnSelector<String> objectColumnSelector = new TestObjectColumnSelector<>(strings);\n\n    StringFirstAggregatorFactory factory = new StringFirstAggregatorFactory(\n        \"billy\", \"billy\", maxStringBytes\n    );\n\n    StringFirstBufferAggregator agg = new StringFirstBufferAggregator(\n        longColumnSelector,\n        objectColumnSelector,\n        maxStringBytes,\n        true\n    );\n\n    ByteBuffer buf = ByteBuffer.allocate(factory.getMaxIntermediateSize());\n    int position = 0;\n\n    agg.init(buf, position);\n    \r\n    for (int i = 0; i < timestamps.length; i++) {\n      aggregateBuffer(longColumnSelector, objectColumnSelector, agg, buf, position);\n    }\n\n    SerializablePairLongString sp = ((SerializablePairLongString) agg.get(buf, position));\n\n\n    Assert.assertEquals(\"expected last string value\", strings[0], sp.rhs);\n    Assert.assertEquals(\"last string timestamp is the biggest\", new Long(timestamps[0]), new Long(sp.lhs));\n  }\n","realPath":"processing/src/test/java/org/apache/druid/query/aggregation/first/StringFirstBufferAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"B"},{"authorDate":"2020-01-17 13:02:02","commitOrder":4,"curCode":"  public void testNullBufferAggregate()\n  {\n\n    final long[] timestamps = {2222L, 1111L, 3333L, 4444L, 5555L};\n    final String[] strings = {null, \"AAAA\", \"BBBB\", \"DDDD\", \"EEEE\"};\n    Integer maxStringBytes = 1024;\n\n    TestLongColumnSelector longColumnSelector = new TestLongColumnSelector(timestamps);\n    TestObjectColumnSelector<String> objectColumnSelector = new TestObjectColumnSelector<>(strings);\n\n    StringFirstAggregatorFactory factory = new StringFirstAggregatorFactory(\n        \"billy\", \"billy\", maxStringBytes\n    );\n\n    StringFirstBufferAggregator agg = new StringFirstBufferAggregator(\n        longColumnSelector,\n        objectColumnSelector,\n        maxStringBytes,\n        false\n    );\n\n    ByteBuffer buf = ByteBuffer.allocate(factory.getMaxIntermediateSize());\n    int position = 0;\n\n    agg.init(buf, position);\n    \r\n    for (int i = 0; i < timestamps.length; i++) {\n      aggregateBuffer(longColumnSelector, objectColumnSelector, agg, buf, position);\n    }\n\n    SerializablePairLongString sp = ((SerializablePairLongString) agg.get(buf, position));\n\n\n    Assert.assertEquals(\"expected last string value\", strings[1], sp.rhs);\n    Assert.assertEquals(\"last string timestamp is the biggest\", new Long(timestamps[1]), new Long(sp.lhs));\n\n  }\n","date":"2020-01-17 13:02:02","endLine":157,"groupId":"13154","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testNullBufferAggregate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/3b/4ef692bf5238c53369a22a299cbc3a5c4e8efa.src","preCode":"  public void testNullBufferAggregate()\n  {\n\n    final long[] timestamps = {2222L, 1111L, 3333L, 4444L, 5555L};\n    final String[] strings = {null, \"AAAA\", \"BBBB\", \"DDDD\", \"EEEE\"};\n    Integer maxStringBytes = 1024;\n\n    TestLongColumnSelector longColumnSelector = new TestLongColumnSelector(timestamps);\n    TestObjectColumnSelector<String> objectColumnSelector = new TestObjectColumnSelector<>(strings);\n\n    StringFirstAggregatorFactory factory = new StringFirstAggregatorFactory(\n        \"billy\", \"billy\", maxStringBytes\n    );\n\n    StringFirstBufferAggregator agg = new StringFirstBufferAggregator(\n        longColumnSelector,\n        objectColumnSelector,\n        maxStringBytes,\n        false\n    );\n\n    ByteBuffer buf = ByteBuffer.allocate(factory.getMaxIntermediateSize());\n    int position = 0;\n\n    agg.init(buf, position);\n    \r\n    for (int i = 0; i < timestamps.length; i++) {\n      aggregateBuffer(longColumnSelector, objectColumnSelector, agg, buf, position);\n    }\n\n    SerializablePairLongString sp = ((SerializablePairLongString) agg.get(buf, position));\n\n\n    Assert.assertEquals(\"expected last string value\", strings[1], sp.rhs);\n    Assert.assertEquals(\"last string timestamp is the biggest\", new Long(timestamps[1]), new Long(sp.lhs));\n\n  }\n","realPath":"processing/src/test/java/org/apache/druid/query/aggregation/first/StringFirstBufferAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":121,"status":"MB"}],"commitId":"448da787654ef6ebcab7bb5cba340b931c454320","commitMessage":"@@@Speed up String first/last aggregators when folding isn't needed. (#9181)\n\n* Speed up String first/last aggregators when folding isn't needed.\n\nExamines the value column.  and disables fold checking via a needsFoldCheck\nflag if that column can't possibly contain SerializableLongStringPairs. This\nis helpful because it avoids calling getObject on the value selector when\nunnecessary; say.  because the time selector didn't yield an earlier or later\nvalue.\n\n* PR comments.\n\n* Move fastLooseChop to StringUtils.\n","date":"2020-01-17 13:02:02","modifiedFileCount":"13","status":"M","submitter":"Gian Merlino"},{"authorTime":"2020-01-30 03:50:52","codes":[{"authorDate":"2020-01-30 03:50:52","commitOrder":5,"curCode":"  public void testBufferAggregateWithFoldCheck()\n  {\n    final long[] timestamps = {1526724600L, 1526724700L, 1526724800L, 1526725900L, 1526725000L};\n    final String[] strings = {\"AAAA\", \"BBBB\", \"CCCC\", \"DDDD\", \"EEEE\"};\n    Integer maxStringBytes = 1024;\n\n    TestLongColumnSelector longColumnSelector = new TestLongColumnSelector(timestamps);\n    TestObjectColumnSelector<String> objectColumnSelector = new TestObjectColumnSelector<>(strings);\n\n    StringFirstAggregatorFactory factory = new StringFirstAggregatorFactory(\n        \"billy\", \"billy\", maxStringBytes\n    );\n\n    StringFirstBufferAggregator agg = new StringFirstBufferAggregator(\n        longColumnSelector,\n        objectColumnSelector,\n        maxStringBytes,\n        true\n    );\n\n    ByteBuffer buf = ByteBuffer.allocate(factory.getMaxIntermediateSize());\n    int position = 0;\n\n    agg.init(buf, position);\n    \r\n    for (int i = 0; i < timestamps.length; i++) {\n      aggregateBuffer(longColumnSelector, objectColumnSelector, agg, buf, position);\n    }\n\n    SerializablePairLongString sp = ((SerializablePairLongString) agg.get(buf, position));\n\n\n    Assert.assertEquals(\"expected last string value\", strings[0], sp.rhs);\n    Assert.assertEquals(\"last string timestamp is the biggest\", new Long(timestamps[0]), sp.lhs);\n  }\n","date":"2020-01-30 03:50:52","endLine":118,"groupId":"107019","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"testBufferAggregateWithFoldCheck","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/36/8bad99fe6def11570aa45c0f26e46f9a8a76da.src","preCode":"  public void testBufferAggregateWithFoldCheck()\n  {\n    final long[] timestamps = {1526724600L, 1526724700L, 1526724800L, 1526725900L, 1526725000L};\n    final String[] strings = {\"AAAA\", \"BBBB\", \"CCCC\", \"DDDD\", \"EEEE\"};\n    Integer maxStringBytes = 1024;\n\n    TestLongColumnSelector longColumnSelector = new TestLongColumnSelector(timestamps);\n    TestObjectColumnSelector<String> objectColumnSelector = new TestObjectColumnSelector<>(strings);\n\n    StringFirstAggregatorFactory factory = new StringFirstAggregatorFactory(\n        \"billy\", \"billy\", maxStringBytes\n    );\n\n    StringFirstBufferAggregator agg = new StringFirstBufferAggregator(\n        longColumnSelector,\n        objectColumnSelector,\n        maxStringBytes,\n        true\n    );\n\n    ByteBuffer buf = ByteBuffer.allocate(factory.getMaxIntermediateSize());\n    int position = 0;\n\n    agg.init(buf, position);\n    \r\n    for (int i = 0; i < timestamps.length; i++) {\n      aggregateBuffer(longColumnSelector, objectColumnSelector, agg, buf, position);\n    }\n\n    SerializablePairLongString sp = ((SerializablePairLongString) agg.get(buf, position));\n\n\n    Assert.assertEquals(\"expected last string value\", strings[0], sp.rhs);\n    Assert.assertEquals(\"last string timestamp is the biggest\", new Long(timestamps[0]), new Long(sp.lhs));\n  }\n","realPath":"processing/src/test/java/org/apache/druid/query/aggregation/first/StringFirstBufferAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"M"},{"authorDate":"2020-01-30 03:50:52","commitOrder":5,"curCode":"  public void testNullBufferAggregate()\n  {\n\n    final long[] timestamps = {2222L, 1111L, 3333L, 4444L, 5555L};\n    final String[] strings = {null, \"AAAA\", \"BBBB\", \"DDDD\", \"EEEE\"};\n    Integer maxStringBytes = 1024;\n\n    TestLongColumnSelector longColumnSelector = new TestLongColumnSelector(timestamps);\n    TestObjectColumnSelector<String> objectColumnSelector = new TestObjectColumnSelector<>(strings);\n\n    StringFirstAggregatorFactory factory = new StringFirstAggregatorFactory(\n        \"billy\", \"billy\", maxStringBytes\n    );\n\n    StringFirstBufferAggregator agg = new StringFirstBufferAggregator(\n        longColumnSelector,\n        objectColumnSelector,\n        maxStringBytes,\n        false\n    );\n\n    ByteBuffer buf = ByteBuffer.allocate(factory.getMaxIntermediateSize());\n    int position = 0;\n\n    agg.init(buf, position);\n    \r\n    for (int i = 0; i < timestamps.length; i++) {\n      aggregateBuffer(longColumnSelector, objectColumnSelector, agg, buf, position);\n    }\n\n    SerializablePairLongString sp = ((SerializablePairLongString) agg.get(buf, position));\n\n\n    Assert.assertEquals(\"expected last string value\", strings[1], sp.rhs);\n    Assert.assertEquals(\"last string timestamp is the biggest\", new Long(timestamps[1]), sp.lhs);\n\n  }\n","date":"2020-01-30 03:50:52","endLine":157,"groupId":"107019","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"testNullBufferAggregate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/36/8bad99fe6def11570aa45c0f26e46f9a8a76da.src","preCode":"  public void testNullBufferAggregate()\n  {\n\n    final long[] timestamps = {2222L, 1111L, 3333L, 4444L, 5555L};\n    final String[] strings = {null, \"AAAA\", \"BBBB\", \"DDDD\", \"EEEE\"};\n    Integer maxStringBytes = 1024;\n\n    TestLongColumnSelector longColumnSelector = new TestLongColumnSelector(timestamps);\n    TestObjectColumnSelector<String> objectColumnSelector = new TestObjectColumnSelector<>(strings);\n\n    StringFirstAggregatorFactory factory = new StringFirstAggregatorFactory(\n        \"billy\", \"billy\", maxStringBytes\n    );\n\n    StringFirstBufferAggregator agg = new StringFirstBufferAggregator(\n        longColumnSelector,\n        objectColumnSelector,\n        maxStringBytes,\n        false\n    );\n\n    ByteBuffer buf = ByteBuffer.allocate(factory.getMaxIntermediateSize());\n    int position = 0;\n\n    agg.init(buf, position);\n    \r\n    for (int i = 0; i < timestamps.length; i++) {\n      aggregateBuffer(longColumnSelector, objectColumnSelector, agg, buf, position);\n    }\n\n    SerializablePairLongString sp = ((SerializablePairLongString) agg.get(buf, position));\n\n\n    Assert.assertEquals(\"expected last string value\", strings[1], sp.rhs);\n    Assert.assertEquals(\"last string timestamp is the biggest\", new Long(timestamps[1]), new Long(sp.lhs));\n\n  }\n","realPath":"processing/src/test/java/org/apache/druid/query/aggregation/first/StringFirstBufferAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":121,"status":"M"}],"commitId":"303b02eba16bb639e5adee37cc7ecbab89b00b64","commitMessage":"@@@intelliJ inspections cleanup (#9260)\n\n* intelliJ inspections cleanup\n\n- remove redundant escapes\n- performance warnings\n- access static member via instance reference\n- static method declared final\n- inner class may be static\n\nMost of these changes are aesthetic.  however.  they will allow inspections to\nbe enabled as part of CI checks going forward\n\nThe valuable changes in this delta are:\n- using StringBuilder instead of string addition in a loop\n    indexing-hadoop/.../Utils.java\n    processing/.../ByteBufferMinMaxOffsetHeap.java\n- Use class variables instead of static variables for parameterized test\n    processing/src/.../ScanQueryLimitRowIteratorTest.java\n\n* Add intelliJ inspection warnings as errors to druid profile\n\n* one more static inner class\n","date":"2020-01-30 03:50:52","modifiedFileCount":"43","status":"M","submitter":"Suneet Saldanha"}]
