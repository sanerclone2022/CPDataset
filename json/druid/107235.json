[{"authorTime":"2018-08-31 00:56:26","codes":[{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  public SingleLongInputCachingExpressionColumnValueSelector(\n      final ColumnValueSelector selector,\n      final Expr expression\n  )\n  {\n    \r\n    if (Parser.findRequiredBindings(expression).size() != 1) {\n      throw new ISE(\"WTF?! Expected expression with just one binding\");\n    }\n\n    this.selector = Preconditions.checkNotNull(selector, \"selector\");\n    this.expression = Preconditions.checkNotNull(expression, \"expression\");\n  }\n","date":"2018-08-31 00:56:26","endLine":71,"groupId":"10161","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"SingleLongInputCachingExpressionColumnValueSelector","params":"(finalColumnValueSelectorselector@finalExprexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/f3/ffe8318612aea24edc873c70a36fed07ecd4e2.src","preCode":"  public SingleLongInputCachingExpressionColumnValueSelector(\n      final ColumnValueSelector selector,\n      final Expr expression\n  )\n  {\n    \r\n    if (Parser.findRequiredBindings(expression).size() != 1) {\n      throw new ISE(\"WTF?! Expected expression with just one binding\");\n    }\n\n    this.selector = Preconditions.checkNotNull(selector, \"selector\");\n    this.expression = Preconditions.checkNotNull(expression, \"expression\");\n  }\n","realPath":"processing/src/main/java/org/apache/druid/segment/virtual/SingleLongInputCachingExpressionColumnValueSelector.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":59,"status":"B"},{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  public SingleStringInputCachingExpressionColumnValueSelector(\n      final DimensionSelector selector,\n      final Expr expression\n  )\n  {\n    \r\n    if (Parser.findRequiredBindings(expression).size() != 1) {\n      throw new ISE(\"WTF?! Expected expression with just one binding\");\n    }\n\n    this.selector = Preconditions.checkNotNull(selector, \"selector\");\n    this.expression = Preconditions.checkNotNull(expression, \"expression\");\n\n    final Supplier<Object> inputSupplier = ExpressionSelectors.supplierFromDimensionSelector(selector);\n    this.bindings = name -> inputSupplier.get();\n\n    if (selector.getValueCardinality() == DimensionSelector.CARDINALITY_UNKNOWN) {\n      throw new ISE(\"Selector must have a dictionary\");\n    } else if (selector.getValueCardinality() <= CACHE_SIZE) {\n      arrayEvalCache = new ExprEval[selector.getValueCardinality()];\n      lruEvalCache = null;\n    } else {\n      arrayEvalCache = null;\n      lruEvalCache = new LruEvalCache(expression, bindings);\n    }\n  }\n","date":"2018-08-31 00:56:26","endLine":75,"groupId":"10161","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"SingleStringInputCachingExpressionColumnValueSelector","params":"(finalDimensionSelectorselector@finalExprexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/ce/f8436efd14efd99d29e9afcf94794e8ce2ec01.src","preCode":"  public SingleStringInputCachingExpressionColumnValueSelector(\n      final DimensionSelector selector,\n      final Expr expression\n  )\n  {\n    \r\n    if (Parser.findRequiredBindings(expression).size() != 1) {\n      throw new ISE(\"WTF?! Expected expression with just one binding\");\n    }\n\n    this.selector = Preconditions.checkNotNull(selector, \"selector\");\n    this.expression = Preconditions.checkNotNull(expression, \"expression\");\n\n    final Supplier<Object> inputSupplier = ExpressionSelectors.supplierFromDimensionSelector(selector);\n    this.bindings = name -> inputSupplier.get();\n\n    if (selector.getValueCardinality() == DimensionSelector.CARDINALITY_UNKNOWN) {\n      throw new ISE(\"Selector must have a dictionary\");\n    } else if (selector.getValueCardinality() <= CACHE_SIZE) {\n      arrayEvalCache = new ExprEval[selector.getValueCardinality()];\n      lruEvalCache = null;\n    } else {\n      arrayEvalCache = null;\n      lruEvalCache = new LruEvalCache(expression, bindings);\n    }\n  }\n","realPath":"processing/src/main/java/org/apache/druid/segment/virtual/SingleStringInputCachingExpressionColumnValueSelector.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":50,"status":"B"}],"commitId":"431d3d8497f9079857c3baa7ae7ab4cb44a22355","commitMessage":"@@@Rename io.druid to org.apache.druid. (#6266)\n\n* Rename io.druid to org.apache.druid.\n\n* Fix META-INF files and remove some benchmark results.\n\n* MonitorsConfig update for metrics package migration.\n\n* Reorder some dimensions in inner queries for some reason.\n\n* Fix protobuf tests.\n","date":"2018-08-31 00:56:26","modifiedFileCount":"5","status":"B","submitter":"Gian Merlino"},{"authorTime":"2018-08-31 00:56:26","codes":[{"authorDate":"2018-11-14 01:36:32","commitOrder":2,"curCode":"  public SingleLongInputCachingExpressionColumnValueSelector(\n      final ColumnValueSelector selector,\n      final Expr expression,\n      final boolean useLruCache\n  )\n  {\n    \r\n    if (Parser.findRequiredBindings(expression).size() != 1) {\n      throw new ISE(\"WTF?! Expected expression with just one binding\");\n    }\n\n    this.selector = Preconditions.checkNotNull(selector, \"selector\");\n    this.expression = Preconditions.checkNotNull(expression, \"expression\");\n    this.lruEvalCache = useLruCache ? new LruEvalCache() : null;\n  }\n","date":"2018-11-14 01:36:32","endLine":70,"groupId":"10161","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"SingleLongInputCachingExpressionColumnValueSelector","params":"(finalColumnValueSelectorselector@finalExprexpression@finalbooleanuseLruCache)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/fa/002c0220362fefc2cf6db9094cab7542710e15.src","preCode":"  public SingleLongInputCachingExpressionColumnValueSelector(\n      final ColumnValueSelector selector,\n      final Expr expression\n  )\n  {\n    \r\n    if (Parser.findRequiredBindings(expression).size() != 1) {\n      throw new ISE(\"WTF?! Expected expression with just one binding\");\n    }\n\n    this.selector = Preconditions.checkNotNull(selector, \"selector\");\n    this.expression = Preconditions.checkNotNull(expression, \"expression\");\n  }\n","realPath":"processing/src/main/java/org/apache/druid/segment/virtual/SingleLongInputCachingExpressionColumnValueSelector.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":56,"status":"M"},{"authorDate":"2018-08-31 00:56:26","commitOrder":2,"curCode":"  public SingleStringInputCachingExpressionColumnValueSelector(\n      final DimensionSelector selector,\n      final Expr expression\n  )\n  {\n    \r\n    if (Parser.findRequiredBindings(expression).size() != 1) {\n      throw new ISE(\"WTF?! Expected expression with just one binding\");\n    }\n\n    this.selector = Preconditions.checkNotNull(selector, \"selector\");\n    this.expression = Preconditions.checkNotNull(expression, \"expression\");\n\n    final Supplier<Object> inputSupplier = ExpressionSelectors.supplierFromDimensionSelector(selector);\n    this.bindings = name -> inputSupplier.get();\n\n    if (selector.getValueCardinality() == DimensionSelector.CARDINALITY_UNKNOWN) {\n      throw new ISE(\"Selector must have a dictionary\");\n    } else if (selector.getValueCardinality() <= CACHE_SIZE) {\n      arrayEvalCache = new ExprEval[selector.getValueCardinality()];\n      lruEvalCache = null;\n    } else {\n      arrayEvalCache = null;\n      lruEvalCache = new LruEvalCache(expression, bindings);\n    }\n  }\n","date":"2018-08-31 00:56:26","endLine":75,"groupId":"10161","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"SingleStringInputCachingExpressionColumnValueSelector","params":"(finalDimensionSelectorselector@finalExprexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/ce/f8436efd14efd99d29e9afcf94794e8ce2ec01.src","preCode":"  public SingleStringInputCachingExpressionColumnValueSelector(\n      final DimensionSelector selector,\n      final Expr expression\n  )\n  {\n    \r\n    if (Parser.findRequiredBindings(expression).size() != 1) {\n      throw new ISE(\"WTF?! Expected expression with just one binding\");\n    }\n\n    this.selector = Preconditions.checkNotNull(selector, \"selector\");\n    this.expression = Preconditions.checkNotNull(expression, \"expression\");\n\n    final Supplier<Object> inputSupplier = ExpressionSelectors.supplierFromDimensionSelector(selector);\n    this.bindings = name -> inputSupplier.get();\n\n    if (selector.getValueCardinality() == DimensionSelector.CARDINALITY_UNKNOWN) {\n      throw new ISE(\"Selector must have a dictionary\");\n    } else if (selector.getValueCardinality() <= CACHE_SIZE) {\n      arrayEvalCache = new ExprEval[selector.getValueCardinality()];\n      lruEvalCache = null;\n    } else {\n      arrayEvalCache = null;\n      lruEvalCache = new LruEvalCache(expression, bindings);\n    }\n  }\n","realPath":"processing/src/main/java/org/apache/druid/segment/virtual/SingleStringInputCachingExpressionColumnValueSelector.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":50,"status":"N"}],"commitId":"52f6bdc1ebfd37329cd98e4e5e0a9c6ca2205582","commitMessage":"@@@Optimization for expressions that hit a single long column. (#6599)\n\n* Optimization for expressions that hit a single long column.\n\nThere was previously a single-long-input optimization that applied only\nto the time column. These have been combined together. Also adds\ntype-specific value caching to ExprEval.  which allowed simplifying\nthe SingleLongInputCachingExpressionColumnValueSelector code.\n\n* Add more benchmarks.\n\n* Don't use LRU cache for __time.\n\n* Simplify a bit.\n\n* Let the cache grow.\n","date":"2018-11-14 01:36:32","modifiedFileCount":"5","status":"M","submitter":"Gian Merlino"},{"authorTime":"2019-06-20 04:57:37","codes":[{"authorDate":"2019-06-20 04:57:37","commitOrder":3,"curCode":"  public SingleLongInputCachingExpressionColumnValueSelector(\n      final ColumnValueSelector selector,\n      final Expr expression,\n      final boolean useLruCache\n  )\n  {\n    \r\n    if (expression.analyzeInputs().getFreeVariables().size() != 1) {\n      throw new ISE(\"WTF?! Expected expression with just one binding\");\n    }\n\n    this.selector = Preconditions.checkNotNull(selector, \"selector\");\n    this.expression = Preconditions.checkNotNull(expression, \"expression\");\n    this.lruEvalCache = useLruCache ? new LruEvalCache() : null;\n  }\n","date":"2019-06-20 04:57:37","endLine":69,"groupId":"10161","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"SingleLongInputCachingExpressionColumnValueSelector","params":"(finalColumnValueSelectorselector@finalExprexpression@finalbooleanuseLruCache)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/af/71a9979b1ea7db8cd900890c3d1f14d0de8b26.src","preCode":"  public SingleLongInputCachingExpressionColumnValueSelector(\n      final ColumnValueSelector selector,\n      final Expr expression,\n      final boolean useLruCache\n  )\n  {\n    \r\n    if (Parser.findRequiredBindings(expression).size() != 1) {\n      throw new ISE(\"WTF?! Expected expression with just one binding\");\n    }\n\n    this.selector = Preconditions.checkNotNull(selector, \"selector\");\n    this.expression = Preconditions.checkNotNull(expression, \"expression\");\n    this.lruEvalCache = useLruCache ? new LruEvalCache() : null;\n  }\n","realPath":"processing/src/main/java/org/apache/druid/segment/virtual/SingleLongInputCachingExpressionColumnValueSelector.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"M"},{"authorDate":"2019-06-20 04:57:37","commitOrder":3,"curCode":"  public SingleStringInputCachingExpressionColumnValueSelector(\n      final DimensionSelector selector,\n      final Expr expression\n  )\n  {\n    \r\n    if (expression.analyzeInputs().getFreeVariables().size() != 1) {\n      throw new ISE(\"WTF?! Expected expression with just one binding\");\n    }\n\n    this.selector = Preconditions.checkNotNull(selector, \"selector\");\n    this.expression = Preconditions.checkNotNull(expression, \"expression\");\n\n    final Supplier<Object> inputSupplier = ExpressionSelectors.supplierFromDimensionSelector(selector, false);\n    this.bindings = name -> inputSupplier.get();\n\n    if (selector.getValueCardinality() == DimensionSelector.CARDINALITY_UNKNOWN) {\n      throw new ISE(\"Selector must have a dictionary\");\n    } else if (selector.getValueCardinality() <= CACHE_SIZE) {\n      arrayEvalCache = new ExprEval[selector.getValueCardinality()];\n      lruEvalCache = null;\n    } else {\n      arrayEvalCache = null;\n      lruEvalCache = new LruEvalCache(expression, bindings);\n    }\n  }\n","date":"2019-06-20 04:57:37","endLine":76,"groupId":"10161","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"SingleStringInputCachingExpressionColumnValueSelector","params":"(finalDimensionSelectorselector@finalExprexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/4d/358e08a90be963c8efef39603cd0e53a06daa3.src","preCode":"  public SingleStringInputCachingExpressionColumnValueSelector(\n      final DimensionSelector selector,\n      final Expr expression\n  )\n  {\n    \r\n    if (Parser.findRequiredBindings(expression).size() != 1) {\n      throw new ISE(\"WTF?! Expected expression with just one binding\");\n    }\n\n    this.selector = Preconditions.checkNotNull(selector, \"selector\");\n    this.expression = Preconditions.checkNotNull(expression, \"expression\");\n\n    final Supplier<Object> inputSupplier = ExpressionSelectors.supplierFromDimensionSelector(selector);\n    this.bindings = name -> inputSupplier.get();\n\n    if (selector.getValueCardinality() == DimensionSelector.CARDINALITY_UNKNOWN) {\n      throw new ISE(\"Selector must have a dictionary\");\n    } else if (selector.getValueCardinality() <= CACHE_SIZE) {\n      arrayEvalCache = new ExprEval[selector.getValueCardinality()];\n      lruEvalCache = null;\n    } else {\n      arrayEvalCache = null;\n      lruEvalCache = new LruEvalCache(expression, bindings);\n    }\n  }\n","realPath":"processing/src/main/java/org/apache/druid/segment/virtual/SingleStringInputCachingExpressionColumnValueSelector.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":51,"status":"M"}],"commitId":"494b8ebe56308fe69c2a758f80f1ae56bf17d54d","commitMessage":"@@@multi-value string column support for expressions (#7588)\n\n* array support for expression language for multi-value string columns\n\n* fix tests?\n\n* fixes\n\n* more tests\n\n* fixes\n\n* cleanup\n\n* more better.  more test\n\n* ignore inspection\n\n* license\n\n* license fix\n\n* inspection\n\n* remove dumb import\n\n* more better\n\n* some comments\n\n* add expr rewrite for arrayfn args for more magic.  tests\n\n* test stuff\n\n* more tests\n\n* fix test\n\n* fix test\n\n* castfunc can deal with arrays\n\n* needs more empty array\n\n* more tests.  make cast to long array more forgiving\n\n* refactor\n\n* simplify ExprMacro Expr implementations with base classes in core\n\n* oops\n\n* more test\n\n* use Shuttle for Parser.flatten.  javadoc.  cleanup\n\n* fixes and more tests\n\n* unused import\n\n* fixes\n\n* javadocs.  cleanup.  refactors\n\n* fix imports\n\n* more javadoc\n\n* more javadoc\n\n* more\n\n* more javadocs.  nonnullbydefault.  minor refactor\n\n* markdown fix\n\n* adjustments\n\n* more doc\n\n* move initial filter out\n\n* docs\n\n* map empty arg lambda.  apply function argument validation\n\n* check function args at parse time instead of eval time\n\n* more immutable\n\n* more more immutable\n\n* clarify grammar\n\n* fix docs\n\n* empty array is string test.  we need a way to make arrays better maybe in the future.  or define empty arrays as other types..\n","date":"2019-06-20 04:57:37","modifiedFileCount":"43","status":"M","submitter":"Clint Wylie"},{"authorTime":"2019-07-04 14:03:47","codes":[{"authorDate":"2019-07-04 14:03:47","commitOrder":4,"curCode":"  public SingleLongInputCachingExpressionColumnValueSelector(\n      final ColumnValueSelector selector,\n      final Expr expression,\n      final boolean useLruCache\n  )\n  {\n    \r\n    if (expression.analyzeInputs().getRequiredColumns().size() != 1) {\n      throw new ISE(\"WTF?! Expected expression with just one binding\");\n    }\n\n    this.selector = Preconditions.checkNotNull(selector, \"selector\");\n    this.expression = Preconditions.checkNotNull(expression, \"expression\");\n    this.lruEvalCache = useLruCache ? new LruEvalCache() : null;\n  }\n","date":"2019-07-04 14:03:47","endLine":69,"groupId":"10161","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"SingleLongInputCachingExpressionColumnValueSelector","params":"(finalColumnValueSelectorselector@finalExprexpression@finalbooleanuseLruCache)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/8f/b9cdc9132107fbbed7d9bac903d4a8be705b8a.src","preCode":"  public SingleLongInputCachingExpressionColumnValueSelector(\n      final ColumnValueSelector selector,\n      final Expr expression,\n      final boolean useLruCache\n  )\n  {\n    \r\n    if (expression.analyzeInputs().getFreeVariables().size() != 1) {\n      throw new ISE(\"WTF?! Expected expression with just one binding\");\n    }\n\n    this.selector = Preconditions.checkNotNull(selector, \"selector\");\n    this.expression = Preconditions.checkNotNull(expression, \"expression\");\n    this.lruEvalCache = useLruCache ? new LruEvalCache() : null;\n  }\n","realPath":"processing/src/main/java/org/apache/druid/segment/virtual/SingleLongInputCachingExpressionColumnValueSelector.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"M"},{"authorDate":"2019-07-04 14:03:47","commitOrder":4,"curCode":"  public SingleStringInputCachingExpressionColumnValueSelector(\n      final DimensionSelector selector,\n      final Expr expression\n  )\n  {\n    \r\n    if (expression.analyzeInputs().getRequiredColumns().size() != 1) {\n      throw new ISE(\"WTF?! Expected expression with just one binding\");\n    }\n\n    this.selector = Preconditions.checkNotNull(selector, \"selector\");\n    this.expression = Preconditions.checkNotNull(expression, \"expression\");\n\n    final Supplier<Object> inputSupplier = ExpressionSelectors.supplierFromDimensionSelector(selector, false);\n    this.bindings = name -> inputSupplier.get();\n\n    if (selector.getValueCardinality() == DimensionSelector.CARDINALITY_UNKNOWN) {\n      throw new ISE(\"Selector must have a dictionary\");\n    } else if (selector.getValueCardinality() <= CACHE_SIZE) {\n      arrayEvalCache = new ExprEval[selector.getValueCardinality()];\n      lruEvalCache = null;\n    } else {\n      arrayEvalCache = null;\n      lruEvalCache = new LruEvalCache(expression, bindings);\n    }\n  }\n","date":"2019-07-04 14:03:47","endLine":76,"groupId":"10161","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"SingleStringInputCachingExpressionColumnValueSelector","params":"(finalDimensionSelectorselector@finalExprexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/d9/581e798a85ed6c5f4130c229d49d62a0838f99.src","preCode":"  public SingleStringInputCachingExpressionColumnValueSelector(\n      final DimensionSelector selector,\n      final Expr expression\n  )\n  {\n    \r\n    if (expression.analyzeInputs().getFreeVariables().size() != 1) {\n      throw new ISE(\"WTF?! Expected expression with just one binding\");\n    }\n\n    this.selector = Preconditions.checkNotNull(selector, \"selector\");\n    this.expression = Preconditions.checkNotNull(expression, \"expression\");\n\n    final Supplier<Object> inputSupplier = ExpressionSelectors.supplierFromDimensionSelector(selector, false);\n    this.bindings = name -> inputSupplier.get();\n\n    if (selector.getValueCardinality() == DimensionSelector.CARDINALITY_UNKNOWN) {\n      throw new ISE(\"Selector must have a dictionary\");\n    } else if (selector.getValueCardinality() <= CACHE_SIZE) {\n      arrayEvalCache = new ExprEval[selector.getValueCardinality()];\n      lruEvalCache = null;\n    } else {\n      arrayEvalCache = null;\n      lruEvalCache = new LruEvalCache(expression, bindings);\n    }\n  }\n","realPath":"processing/src/main/java/org/apache/druid/segment/virtual/SingleStringInputCachingExpressionColumnValueSelector.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":51,"status":"M"}],"commitId":"e6ba258197468bfc8691b939fe00bd378139a095","commitMessage":"@@@multi-value string expression transformation fix (#8019)\n\n* multi-value string expression transformation fix\n\n* fixes\n\n* more docs and test\n\n* revert unintended doc change\n\n* formatting\n\n* change tostring to print binding identifier\n\n* review fixup\n\n* oops\n","date":"2019-07-04 14:03:47","modifiedFileCount":"21","status":"M","submitter":"Clint Wylie"},{"authorTime":"2019-07-13 03:54:07","codes":[{"authorDate":"2019-07-04 14:03:47","commitOrder":5,"curCode":"  public SingleLongInputCachingExpressionColumnValueSelector(\n      final ColumnValueSelector selector,\n      final Expr expression,\n      final boolean useLruCache\n  )\n  {\n    \r\n    if (expression.analyzeInputs().getRequiredColumns().size() != 1) {\n      throw new ISE(\"WTF?! Expected expression with just one binding\");\n    }\n\n    this.selector = Preconditions.checkNotNull(selector, \"selector\");\n    this.expression = Preconditions.checkNotNull(expression, \"expression\");\n    this.lruEvalCache = useLruCache ? new LruEvalCache() : null;\n  }\n","date":"2019-07-04 14:03:47","endLine":69,"groupId":"10161","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"SingleLongInputCachingExpressionColumnValueSelector","params":"(finalColumnValueSelectorselector@finalExprexpression@finalbooleanuseLruCache)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/8f/b9cdc9132107fbbed7d9bac903d4a8be705b8a.src","preCode":"  public SingleLongInputCachingExpressionColumnValueSelector(\n      final ColumnValueSelector selector,\n      final Expr expression,\n      final boolean useLruCache\n  )\n  {\n    \r\n    if (expression.analyzeInputs().getRequiredColumns().size() != 1) {\n      throw new ISE(\"WTF?! Expected expression with just one binding\");\n    }\n\n    this.selector = Preconditions.checkNotNull(selector, \"selector\");\n    this.expression = Preconditions.checkNotNull(expression, \"expression\");\n    this.lruEvalCache = useLruCache ? new LruEvalCache() : null;\n  }\n","realPath":"processing/src/main/java/org/apache/druid/segment/virtual/SingleLongInputCachingExpressionColumnValueSelector.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"N"},{"authorDate":"2019-07-13 03:54:07","commitOrder":5,"curCode":"  public SingleStringInputCachingExpressionColumnValueSelector(\n      final DimensionSelector selector,\n      final Expr expression\n  )\n  {\n    \r\n    if (expression.analyzeInputs().getRequiredColumns().size() != 1) {\n      throw new ISE(\"WTF?! Expected expression with just one binding\");\n    }\n\n    this.selector = Preconditions.checkNotNull(selector, \"selector\");\n    this.expression = Preconditions.checkNotNull(expression, \"expression\");\n\n    final Supplier<Object> inputSupplier = ExpressionSelectors.supplierFromDimensionSelector(selector, false);\n    this.bindings = name -> inputSupplier.get();\n\n    if (selector.getValueCardinality() == DimensionDictionarySelector.CARDINALITY_UNKNOWN) {\n      throw new ISE(\"Selector must have a dictionary\");\n    } else if (selector.getValueCardinality() <= CACHE_SIZE) {\n      arrayEvalCache = new ExprEval[selector.getValueCardinality()];\n      lruEvalCache = null;\n    } else {\n      arrayEvalCache = null;\n      lruEvalCache = new LruEvalCache(expression, bindings);\n    }\n  }\n","date":"2019-07-13 03:54:07","endLine":77,"groupId":"10161","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"SingleStringInputCachingExpressionColumnValueSelector","params":"(finalDimensionSelectorselector@finalExprexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/0b/8c443536243a6a7a04fec146e032b18a520b10.src","preCode":"  public SingleStringInputCachingExpressionColumnValueSelector(\n      final DimensionSelector selector,\n      final Expr expression\n  )\n  {\n    \r\n    if (expression.analyzeInputs().getRequiredColumns().size() != 1) {\n      throw new ISE(\"WTF?! Expected expression with just one binding\");\n    }\n\n    this.selector = Preconditions.checkNotNull(selector, \"selector\");\n    this.expression = Preconditions.checkNotNull(expression, \"expression\");\n\n    final Supplier<Object> inputSupplier = ExpressionSelectors.supplierFromDimensionSelector(selector, false);\n    this.bindings = name -> inputSupplier.get();\n\n    if (selector.getValueCardinality() == DimensionSelector.CARDINALITY_UNKNOWN) {\n      throw new ISE(\"Selector must have a dictionary\");\n    } else if (selector.getValueCardinality() <= CACHE_SIZE) {\n      arrayEvalCache = new ExprEval[selector.getValueCardinality()];\n      lruEvalCache = null;\n    } else {\n      arrayEvalCache = null;\n      lruEvalCache = new LruEvalCache(expression, bindings);\n    }\n  }\n","realPath":"processing/src/main/java/org/apache/druid/segment/virtual/SingleStringInputCachingExpressionColumnValueSelector.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":52,"status":"M"}],"commitId":"ffa25b78321a56b210a8ad5b6c9ca61b3b737153","commitMessage":"@@@Query vectorization. (#6794)\n\n* Benchmarks: New SqlBenchmark.  add caching & vectorization to some others.\n\n- Introduce a new SqlBenchmark geared towards benchmarking a wide\n  variety of SQL queries. Rename the old SqlBenchmark to\n  SqlVsNativeBenchmark.\n- Add (optional) caching to SegmentGenerator to enable easier\n  benchmarking of larger segments.\n- Add vectorization to FilteredAggregatorBenchmark and GroupByBenchmark.\n\n* Query vectorization.\n\nThis patch includes vectorized timeseries and groupBy engines.  as well\nas some analogs of your favorite Druid classes:\n\n- VectorCursor is like Cursor. (It comes from StorageAdapter.makeVectorCursor.)\n- VectorColumnSelectorFactory is like ColumnSelectorFactory.  and it has\n  methods to create analogs of the column selectors you know and love.\n- VectorOffset and ReadableVectorOffset are like Offset and ReadableOffset.\n- VectorAggregator is like BufferAggregator.\n- VectorValueMatcher is like ValueMatcher.\n\nThere are some noticeable differences between vectorized and regular\nexecution:\n\n- Unlike regular cursors.  vector cursors do not understand time\n  granularity. They expect query engines to handle this on their own. \n  which a new VectorCursorGranularizer class helps with. This is to\n  avoid too much batch-splitting and to respect the fact that vector\n  selectors are somewhat more heavyweight than regular selectors.\n- Unlike FilteredOffset.  FilteredVectorOffset does not leverage indexes\n  for filters that might partially support them (like an OR of one\n  filter that supports indexing and another that doesn't). I'm not sure\n  that this behavior is desirable anyway (it is potentially too eager)\n  but.  at any rate.  it'd be better to harmonize it between the two\n  classes. Potentially they should both do some different thing that\n  is smarter than what either of them is doing right now.\n- When vector cursors are created by QueryableIndexCursorSequenceBuilder. \n  they use a morphing binary-then-linear search to find their start and\n  end rows.  rather than linear search.\n\nLimitations in this patch are:\n\n- Only timeseries and groupBy have vectorized engines.\n- GroupBy doesn't handle multi-value dimensions yet.\n- Vector cursors cannot handle virtual columns or descending order.\n- Only some filters have vectorized matchers: \"selector\".  \"bound\".  \"in\". \n  \"like\".  \"regex\".  \"search\".  \"and\".  \"or\".  and \"not\".\n- Only some aggregators have vectorized implementations: \"count\". \n  \"doubleSum\".  \"floatSum\".  \"longSum\".  \"hyperUnique\".  and \"filtered\".\n- Dimension specs other than \"default\" don't work yet (no extraction\n  functions or filtered dimension specs).\n\nCurrently.  the testing strategy includes adding vectorization-enabled\ntests to TimeseriesQueryRunnerTest.  GroupByQueryRunnerTest. \nGroupByTimeseriesQueryRunnerTest.  CalciteQueryTest.  and all of the\nfiltering tests that extend BaseFilterTest. In all of those classes. \nthere are some test cases that don't support vectorization. They are\nmarked by special function calls like \"cannotVectorize\" or \"skipVectorize\"\nthat tell the test harness to either expect an exception or to skip the\ntest case.\n\nTesting should be expanded in the future -- a project in and of itself.\n\nRelated to #3011.\n\n* WIP\n\n* Adjustments for unused things.\n\n* Adjust javadocs.\n\n* DimensionDictionarySelector adjustments.\n\n* Add \"clone\" to BatchIteratorAdapter.\n\n* ValueMatcher javadocs.\n\n* Fix benchmark.\n\n* Fixups post-merge.\n\n* Expect exception on testGroupByWithStringVirtualColumn for IncrementalIndex.\n\n* BloomDimFilterSqlTest: Tag two non-vectorizable tests.\n\n* Minor adjustments.\n\n* Update surefire.  bump up Xmx in Travis.\n\n* Some more adjustments.\n\n* Javadoc adjustments\n\n* AggregatorAdapters adjustments.\n\n* Additional comments.\n\n* Remove switching search.\n\n* Only missiles.\n","date":"2019-07-13 03:54:07","modifiedFileCount":"143","status":"M","submitter":"Gian Merlino"},{"authorTime":"2019-08-03 04:21:25","codes":[{"authorDate":"2019-08-03 04:21:25","commitOrder":6,"curCode":"  public SingleLongInputCachingExpressionColumnValueSelector(\n      final ColumnValueSelector selector,\n      final Expr expression,\n      final boolean useLruCache\n  )\n  {\n    \r\n    if (expression.analyzeInputs().getRequiredBindings().size() != 1) {\n      throw new ISE(\"WTF?! Expected expression with just one binding\");\n    }\n\n    this.selector = Preconditions.checkNotNull(selector, \"selector\");\n    this.expression = Preconditions.checkNotNull(expression, \"expression\");\n    this.lruEvalCache = useLruCache ? new LruEvalCache() : null;\n  }\n","date":"2019-08-03 04:21:25","endLine":69,"groupId":"10161","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"SingleLongInputCachingExpressionColumnValueSelector","params":"(finalColumnValueSelectorselector@finalExprexpression@finalbooleanuseLruCache)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/df/9241b9eead5956f8d490bc9f7c0b9a78a46897.src","preCode":"  public SingleLongInputCachingExpressionColumnValueSelector(\n      final ColumnValueSelector selector,\n      final Expr expression,\n      final boolean useLruCache\n  )\n  {\n    \r\n    if (expression.analyzeInputs().getRequiredColumns().size() != 1) {\n      throw new ISE(\"WTF?! Expected expression with just one binding\");\n    }\n\n    this.selector = Preconditions.checkNotNull(selector, \"selector\");\n    this.expression = Preconditions.checkNotNull(expression, \"expression\");\n    this.lruEvalCache = useLruCache ? new LruEvalCache() : null;\n  }\n","realPath":"processing/src/main/java/org/apache/druid/segment/virtual/SingleLongInputCachingExpressionColumnValueSelector.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"M"},{"authorDate":"2019-08-03 04:21:25","commitOrder":6,"curCode":"  public SingleStringInputCachingExpressionColumnValueSelector(\n      final DimensionSelector selector,\n      final Expr expression\n  )\n  {\n    \r\n    if (expression.analyzeInputs().getRequiredBindings().size() != 1) {\n      throw new ISE(\"WTF?! Expected expression with just one binding\");\n    }\n\n    this.selector = Preconditions.checkNotNull(selector, \"selector\");\n    this.expression = Preconditions.checkNotNull(expression, \"expression\");\n\n    final Supplier<Object> inputSupplier = ExpressionSelectors.supplierFromDimensionSelector(selector, false);\n    this.bindings = name -> inputSupplier.get();\n\n    if (selector.getValueCardinality() == DimensionDictionarySelector.CARDINALITY_UNKNOWN) {\n      throw new ISE(\"Selector must have a dictionary\");\n    } else if (selector.getValueCardinality() <= CACHE_SIZE) {\n      arrayEvalCache = new ExprEval[selector.getValueCardinality()];\n      lruEvalCache = null;\n    } else {\n      arrayEvalCache = null;\n      lruEvalCache = new LruEvalCache(expression, bindings);\n    }\n  }\n","date":"2019-08-03 04:21:25","endLine":77,"groupId":"10161","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"SingleStringInputCachingExpressionColumnValueSelector","params":"(finalDimensionSelectorselector@finalExprexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/a3/bf08c8f6f5196dbba7c1efe0d2366e2f736964.src","preCode":"  public SingleStringInputCachingExpressionColumnValueSelector(\n      final DimensionSelector selector,\n      final Expr expression\n  )\n  {\n    \r\n    if (expression.analyzeInputs().getRequiredColumns().size() != 1) {\n      throw new ISE(\"WTF?! Expected expression with just one binding\");\n    }\n\n    this.selector = Preconditions.checkNotNull(selector, \"selector\");\n    this.expression = Preconditions.checkNotNull(expression, \"expression\");\n\n    final Supplier<Object> inputSupplier = ExpressionSelectors.supplierFromDimensionSelector(selector, false);\n    this.bindings = name -> inputSupplier.get();\n\n    if (selector.getValueCardinality() == DimensionDictionarySelector.CARDINALITY_UNKNOWN) {\n      throw new ISE(\"Selector must have a dictionary\");\n    } else if (selector.getValueCardinality() <= CACHE_SIZE) {\n      arrayEvalCache = new ExprEval[selector.getValueCardinality()];\n      lruEvalCache = null;\n    } else {\n      arrayEvalCache = null;\n      lruEvalCache = new LruEvalCache(expression, bindings);\n    }\n  }\n","realPath":"processing/src/main/java/org/apache/druid/segment/virtual/SingleStringInputCachingExpressionColumnValueSelector.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":52,"status":"M"}],"commitId":"e7c6deac768d66c12b71daecae12ecb5a7db2380","commitMessage":"@@@optimize single input column multi-value expressions (#8047)\n\n* optimize single input column multi-value expressions\n\n* javadocs\n\n* merge fixup\n\n* vectorization fixup\n\n* more fixes\n\n* more docs\n\n* more links\n\n* empty\n\n* javadocs are hard\n\n* suppress javadoc refs issue\n\n* fix it\n","date":"2019-08-03 04:21:25","modifiedFileCount":"24","status":"M","submitter":"Clint Wylie"},{"authorTime":"2020-08-29 02:38:50","codes":[{"authorDate":"2020-08-29 02:38:50","commitOrder":7,"curCode":"  public SingleLongInputCachingExpressionColumnValueSelector(\n      final ColumnValueSelector selector,\n      final Expr expression,\n      final boolean useLruCache\n  )\n  {\n    \r\n    if (expression.analyzeInputs().getRequiredBindings().size() != 1) {\n      throw new ISE(\"Expected expression with just one binding\");\n    }\n\n    this.selector = Preconditions.checkNotNull(selector, \"selector\");\n    this.expression = Preconditions.checkNotNull(expression, \"expression\");\n    this.lruEvalCache = useLruCache ? new LruEvalCache() : null;\n  }\n","date":"2020-08-29 02:38:50","endLine":69,"groupId":"107235","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"SingleLongInputCachingExpressionColumnValueSelector","params":"(finalColumnValueSelectorselector@finalExprexpression@finalbooleanuseLruCache)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/76/bbb628fecf613c93895fae2ef40f255c6207c1.src","preCode":"  public SingleLongInputCachingExpressionColumnValueSelector(\n      final ColumnValueSelector selector,\n      final Expr expression,\n      final boolean useLruCache\n  )\n  {\n    \r\n    if (expression.analyzeInputs().getRequiredBindings().size() != 1) {\n      throw new ISE(\"WTF?! Expected expression with just one binding\");\n    }\n\n    this.selector = Preconditions.checkNotNull(selector, \"selector\");\n    this.expression = Preconditions.checkNotNull(expression, \"expression\");\n    this.lruEvalCache = useLruCache ? new LruEvalCache() : null;\n  }\n","realPath":"processing/src/main/java/org/apache/druid/segment/virtual/SingleLongInputCachingExpressionColumnValueSelector.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"M"},{"authorDate":"2020-08-29 02:38:50","commitOrder":7,"curCode":"  public SingleStringInputCachingExpressionColumnValueSelector(\n      final DimensionSelector selector,\n      final Expr expression\n  )\n  {\n    \r\n    if (expression.analyzeInputs().getRequiredBindings().size() != 1) {\n      throw new ISE(\"Expected expression with just one binding\");\n    }\n\n    this.selector = Preconditions.checkNotNull(selector, \"selector\");\n    this.expression = Preconditions.checkNotNull(expression, \"expression\");\n\n    final Supplier<Object> inputSupplier = ExpressionSelectors.supplierFromDimensionSelector(selector, false);\n    this.bindings = name -> inputSupplier.get();\n\n    if (selector.getValueCardinality() == DimensionDictionarySelector.CARDINALITY_UNKNOWN) {\n      throw new ISE(\"Selector must have a dictionary\");\n    } else if (selector.getValueCardinality() <= CACHE_SIZE) {\n      arrayEvalCache = new ExprEval[selector.getValueCardinality()];\n      lruEvalCache = null;\n    } else {\n      arrayEvalCache = null;\n      lruEvalCache = new LruEvalCache(expression, bindings);\n    }\n  }\n","date":"2020-08-29 02:38:50","endLine":77,"groupId":"107235","id":14,"instanceNumber":2,"isCurCommit":1,"methodName":"SingleStringInputCachingExpressionColumnValueSelector","params":"(finalDimensionSelectorselector@finalExprexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/cb/d98cfb095bfa668d624efc00ea71add35bde42.src","preCode":"  public SingleStringInputCachingExpressionColumnValueSelector(\n      final DimensionSelector selector,\n      final Expr expression\n  )\n  {\n    \r\n    if (expression.analyzeInputs().getRequiredBindings().size() != 1) {\n      throw new ISE(\"WTF?! Expected expression with just one binding\");\n    }\n\n    this.selector = Preconditions.checkNotNull(selector, \"selector\");\n    this.expression = Preconditions.checkNotNull(expression, \"expression\");\n\n    final Supplier<Object> inputSupplier = ExpressionSelectors.supplierFromDimensionSelector(selector, false);\n    this.bindings = name -> inputSupplier.get();\n\n    if (selector.getValueCardinality() == DimensionDictionarySelector.CARDINALITY_UNKNOWN) {\n      throw new ISE(\"Selector must have a dictionary\");\n    } else if (selector.getValueCardinality() <= CACHE_SIZE) {\n      arrayEvalCache = new ExprEval[selector.getValueCardinality()];\n      lruEvalCache = null;\n    } else {\n      arrayEvalCache = null;\n      lruEvalCache = new LruEvalCache(expression, bindings);\n    }\n  }\n","realPath":"processing/src/main/java/org/apache/druid/segment/virtual/SingleStringInputCachingExpressionColumnValueSelector.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":52,"status":"M"}],"commitId":"8ab19793043c65bd79315de6fb26683f561a8a58","commitMessage":"@@@Remove implied profanity from error messages. (#10270)\n\ni.e. WTF.  WTH.","date":"2020-08-29 02:38:50","modifiedFileCount":"76","status":"M","submitter":"Gian Merlino"}]
