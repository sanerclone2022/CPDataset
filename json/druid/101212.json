[{"authorTime":"2020-02-01 15:51:16","codes":[{"authorDate":"2020-03-23 07:43:55","commitOrder":4,"curCode":"  private DataSource inlineIfNecessary(\n      final DataSource dataSource,\n      @Nullable final QueryToolChest toolChestIfOutermost,\n      final AtomicInteger subqueryRowLimitAccumulator,\n      final int maxSubqueryRows,\n      final boolean dryRun\n  )\n  {\n    if (dataSource instanceof QueryDataSource) {\n      \r\n      final Query subQuery = ((QueryDataSource) dataSource).getQuery();\n      final QueryToolChest toolChest = warehouse.getToolChest(subQuery);\n\n      if (toolChestIfOutermost != null && toolChestIfOutermost.canPerformSubquery(subQuery)) {\n        \r\n        \r\n        final Stack<DataSource> stack = new Stack<>();\n\n        DataSource current = dataSource;\n        while (current instanceof QueryDataSource) {\n          stack.push(current);\n          current = Iterables.getOnlyElement(current.getChildren());\n        }\n\n        assert !(current instanceof QueryDataSource);\n\n        current = inlineIfNecessary(current, null, subqueryRowLimitAccumulator, maxSubqueryRows, dryRun);\n\n        while (!stack.isEmpty()) {\n          current = stack.pop().withChildren(Collections.singletonList(current));\n        }\n\n        assert current instanceof QueryDataSource;\n\n        if (toolChest.canPerformSubquery(((QueryDataSource) current).getQuery())) {\n          return current;\n        } else {\n          \r\n          \r\n          return inlineIfNecessary(current, toolChestIfOutermost, subqueryRowLimitAccumulator, maxSubqueryRows, dryRun);\n        }\n      } else if (canRunQueryUsingLocalWalker(subQuery) || canRunQueryUsingClusterWalker(subQuery)) {\n        \r\n        final Query subQueryWithId = subQuery.withSubQueryId(UUID.randomUUID().toString());\n\n        final Sequence<?> queryResults;\n\n        if (dryRun) {\n          queryResults = Sequences.empty();\n        } else {\n          final QueryRunner subqueryRunner = subQueryWithId.getRunner(this);\n          queryResults = subqueryRunner.run(QueryPlus.wrap(subQueryWithId));\n        }\n\n        return toInlineDataSource(\n            subQueryWithId,\n            queryResults,\n            warehouse.getToolChest(subQueryWithId),\n            subqueryRowLimitAccumulator,\n            maxSubqueryRows\n        );\n      } else {\n        \r\n        return inlineIfNecessary(\n            dataSource.withChildren(\n                Collections.singletonList(\n                    inlineIfNecessary(\n                        Iterables.getOnlyElement(dataSource.getChildren()),\n                        null,\n                        subqueryRowLimitAccumulator,\n                        maxSubqueryRows,\n                        dryRun\n                    )\n                )\n            ),\n            toolChestIfOutermost,\n            subqueryRowLimitAccumulator,\n            maxSubqueryRows,\n            dryRun\n        );\n      }\n    } else {\n      \r\n      return dataSource.withChildren(\n          dataSource.getChildren()\n                    .stream()\n                    .map(child -> inlineIfNecessary(child, null, subqueryRowLimitAccumulator, maxSubqueryRows, dryRun))\n                    .collect(Collectors.toList())\n      );\n    }\n  }\n","date":"2020-03-23 07:43:55","endLine":343,"groupId":"16263","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"inlineIfNecessary","params":"(finalDataSourcedataSource@@NullablefinalQueryToolChesttoolChestIfOutermost@finalAtomicIntegersubqueryRowLimitAccumulator@finalintmaxSubqueryRows@finalbooleandryRun)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/c3/379bab021414a8c1237011385213c4bf309ba3.src","preCode":"  private DataSource inlineIfNecessary(\n      final DataSource dataSource,\n      @Nullable final QueryToolChest toolChestIfOutermost,\n      final AtomicInteger subqueryRowLimitAccumulator,\n      final int maxSubqueryRows,\n      final boolean dryRun\n  )\n  {\n    if (dataSource instanceof QueryDataSource) {\n      \r\n      final Query subQuery = ((QueryDataSource) dataSource).getQuery();\n      final QueryToolChest toolChest = warehouse.getToolChest(subQuery);\n\n      if (toolChestIfOutermost != null && toolChestIfOutermost.canPerformSubquery(subQuery)) {\n        \r\n        \r\n        final Stack<DataSource> stack = new Stack<>();\n\n        DataSource current = dataSource;\n        while (current instanceof QueryDataSource) {\n          stack.push(current);\n          current = Iterables.getOnlyElement(current.getChildren());\n        }\n\n        assert !(current instanceof QueryDataSource);\n\n        current = inlineIfNecessary(current, null, subqueryRowLimitAccumulator, maxSubqueryRows, dryRun);\n\n        while (!stack.isEmpty()) {\n          current = stack.pop().withChildren(Collections.singletonList(current));\n        }\n\n        assert current instanceof QueryDataSource;\n\n        if (toolChest.canPerformSubquery(((QueryDataSource) current).getQuery())) {\n          return current;\n        } else {\n          \r\n          \r\n          return inlineIfNecessary(current, toolChestIfOutermost, subqueryRowLimitAccumulator, maxSubqueryRows, dryRun);\n        }\n      } else if (canRunQueryUsingLocalWalker(subQuery) || canRunQueryUsingClusterWalker(subQuery)) {\n        \r\n        final Query subQueryWithId = subQuery.withSubQueryId(UUID.randomUUID().toString());\n\n        final Sequence<?> queryResults;\n\n        if (dryRun) {\n          queryResults = Sequences.empty();\n        } else {\n          final QueryRunner subqueryRunner = subQueryWithId.getRunner(this);\n          queryResults = subqueryRunner.run(QueryPlus.wrap(subQueryWithId));\n        }\n\n        return toInlineDataSource(\n            subQueryWithId,\n            queryResults,\n            warehouse.getToolChest(subQueryWithId),\n            subqueryRowLimitAccumulator,\n            maxSubqueryRows\n        );\n      } else {\n        \r\n        return inlineIfNecessary(\n            dataSource.withChildren(\n                Collections.singletonList(\n                    inlineIfNecessary(\n                        Iterables.getOnlyElement(dataSource.getChildren()),\n                        null,\n                        subqueryRowLimitAccumulator,\n                        maxSubqueryRows,\n                        dryRun\n                    )\n                )\n            ),\n            toolChestIfOutermost,\n            subqueryRowLimitAccumulator,\n            maxSubqueryRows,\n            dryRun\n        );\n      }\n    } else {\n      \r\n      return dataSource.withChildren(\n          dataSource.getChildren()\n                    .stream()\n                    .map(child -> inlineIfNecessary(child, null, subqueryRowLimitAccumulator, maxSubqueryRows, dryRun))\n                    .collect(Collectors.toList())\n      );\n    }\n  }\n","realPath":"server/src/main/java/org/apache/druid/server/ClientQuerySegmentWalker.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":253,"status":"MB"},{"authorDate":"2020-02-01 15:51:16","commitOrder":4,"curCode":"  private DataSource recursivelyOverrideContext(final DataSource dataSource, final Map<String, Object> context)\n  {\n    if (dataSource instanceof QueryDataSource) {\n      final Query subquery = ((QueryDataSource) dataSource).getQuery();\n      return new QueryDataSource(recursivelyOverrideContext(subquery, context));\n    } else {\n      return dataSource.withChildren(\n          dataSource.getChildren()\n                    .stream()\n                    .map(ds -> recursivelyOverrideContext(ds, context))\n                    .collect(Collectors.toList())\n      );\n    }\n  }\n","date":"2020-02-01 15:51:16","endLine":559,"groupId":"10530","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"recursivelyOverrideContext","params":"(finalDataSourcedataSource@finalMap<String@Object>context)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/44/6f94626f807eaf4692bd394464791bb511e409.src","preCode":"  private DataSource recursivelyOverrideContext(final DataSource dataSource, final Map<String, Object> context)\n  {\n    if (dataSource instanceof QueryDataSource) {\n      final Query subquery = ((QueryDataSource) dataSource).getQuery();\n      return new QueryDataSource(recursivelyOverrideContext(subquery, context));\n    } else {\n      return dataSource.withChildren(\n          dataSource.getChildren()\n                    .stream()\n                    .map(ds -> recursivelyOverrideContext(ds, context))\n                    .collect(Collectors.toList())\n      );\n    }\n  }\n","realPath":"sql/src/test/java/org/apache/druid/sql/calcite/BaseCalciteQueryTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":546,"status":"NB"}],"commitId":"54c9325256c33622bc8d198dc0252a157f68f196","commitMessage":"@@@SQL support for joins on subqueries. (#9545)\n\n* SQL support for joins on subqueries.\n\nChanges to SQL module:\n\n- DruidJoinRule: Allow joins on subqueries (left/right are no longer\n  required to be scans or mappings).\n- DruidJoinRel: Add cost estimation code for joins on subqueries.\n- DruidSemiJoinRule.  DruidSemiJoinRel: Removed.  since DruidJoinRule can\n  handle this case now.\n- DruidRel: Remove Nullable annotation from toDruidQuery.  because\n  it is no longer needed (it was used by DruidSemiJoinRel).\n- Update Rules constants to reflect new rules available in our current\n  version of Calcite. Some of these are useful for optimizing joins on\n  subqueries.\n- Rework cost estimation to be in terms of cost per row.  and place all\n  relevant constants in CostEstimates.\n\nOther changes:\n\n- RowBasedColumnSelectorFactory: Don't set hasMultipleValues. The lack\n  of isComplete is enough to let callers know that columns might have\n  multiple values.  and explicitly setting it to true causes\n  ExpressionSelectors to think it definitely has multiple values.  and\n  treat the inputs as arrays. This behavior interfered with some of the\n  new tests that involved queries on lookups.\n- QueryContexts: Add maxSubqueryRows parameter.  and use it in druid-sql\n  tests.\n\n* Fixes for tests.\n\n* Adjustments.","date":"2020-03-23 07:43:55","modifiedFileCount":"24","status":"M","submitter":"Gian Merlino"},{"authorTime":"2020-02-01 15:51:16","codes":[{"authorDate":"2020-07-02 05:02:21","commitOrder":5,"curCode":"  private DataSource inlineIfNecessary(\n      final DataSource dataSource,\n      @Nullable final QueryToolChest toolChestIfOutermost,\n      final AtomicInteger subqueryRowLimitAccumulator,\n      final int maxSubqueryRows,\n      final boolean dryRun\n  )\n  {\n    if (dataSource instanceof QueryDataSource) {\n      \r\n      final Query subQuery = ((QueryDataSource) dataSource).getQuery();\n      final QueryToolChest toolChest = warehouse.getToolChest(subQuery);\n\n      if (toolChestIfOutermost != null && toolChestIfOutermost.canPerformSubquery(subQuery)) {\n        \r\n        \r\n        final Stack<DataSource> stack = new Stack<>();\n\n        DataSource current = dataSource;\n        while (current instanceof QueryDataSource) {\n          stack.push(current);\n          current = Iterables.getOnlyElement(current.getChildren());\n        }\n\n        assert !(current instanceof QueryDataSource); \r\n        current = inlineIfNecessary(current, null, subqueryRowLimitAccumulator, maxSubqueryRows, dryRun);\n\n        while (!stack.isEmpty()) {\n          current = stack.pop().withChildren(Collections.singletonList(current));\n        }\n\n        assert current instanceof QueryDataSource;\n\n        if (toolChest.canPerformSubquery(((QueryDataSource) current).getQuery())) {\n          return current;\n        } else {\n          \r\n          \r\n          return inlineIfNecessary(current, toolChestIfOutermost, subqueryRowLimitAccumulator, maxSubqueryRows, dryRun);\n        }\n      } else if (canRunQueryUsingLocalWalker(subQuery) || canRunQueryUsingClusterWalker(subQuery)) {\n        \r\n        final Query subQueryWithId = subQuery.withDefaultSubQueryId();\n\n        final Sequence<?> queryResults;\n\n        if (dryRun) {\n          queryResults = Sequences.empty();\n        } else {\n          final QueryRunner subqueryRunner = subQueryWithId.getRunner(this);\n          queryResults = subqueryRunner.run(\n              QueryPlus.wrap(subQueryWithId),\n              DirectDruidClient.makeResponseContextForQuery()\n          );\n        }\n\n        return toInlineDataSource(\n            subQueryWithId,\n            queryResults,\n            warehouse.getToolChest(subQueryWithId),\n            subqueryRowLimitAccumulator,\n            maxSubqueryRows\n        );\n      } else {\n        \r\n        return inlineIfNecessary(\n            dataSource.withChildren(\n                Collections.singletonList(\n                    inlineIfNecessary(\n                        Iterables.getOnlyElement(dataSource.getChildren()),\n                        null,\n                        subqueryRowLimitAccumulator,\n                        maxSubqueryRows,\n                        dryRun\n                    )\n                )\n            ),\n            toolChestIfOutermost,\n            subqueryRowLimitAccumulator,\n            maxSubqueryRows,\n            dryRun\n        );\n      }\n    } else {\n      \r\n      return dataSource.withChildren(\n          dataSource.getChildren()\n                    .stream()\n                    .map(child -> inlineIfNecessary(child, null, subqueryRowLimitAccumulator, maxSubqueryRows, dryRun))\n                    .collect(Collectors.toList())\n      );\n    }\n  }\n","date":"2020-07-02 05:02:21","endLine":382,"groupId":"101212","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"inlineIfNecessary","params":"(finalDataSourcedataSource@@NullablefinalQueryToolChesttoolChestIfOutermost@finalAtomicIntegersubqueryRowLimitAccumulator@finalintmaxSubqueryRows@finalbooleandryRun)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/85/da1ff41c7a18d4691a2b2d77599dacf1f179a1.src","preCode":"  private DataSource inlineIfNecessary(\n      final DataSource dataSource,\n      @Nullable final QueryToolChest toolChestIfOutermost,\n      final AtomicInteger subqueryRowLimitAccumulator,\n      final int maxSubqueryRows,\n      final boolean dryRun\n  )\n  {\n    if (dataSource instanceof QueryDataSource) {\n      \r\n      final Query subQuery = ((QueryDataSource) dataSource).getQuery();\n      final QueryToolChest toolChest = warehouse.getToolChest(subQuery);\n\n      if (toolChestIfOutermost != null && toolChestIfOutermost.canPerformSubquery(subQuery)) {\n        \r\n        \r\n        final Stack<DataSource> stack = new Stack<>();\n\n        DataSource current = dataSource;\n        while (current instanceof QueryDataSource) {\n          stack.push(current);\n          current = Iterables.getOnlyElement(current.getChildren());\n        }\n\n        assert !(current instanceof QueryDataSource); \r\n        current = inlineIfNecessary(current, null, subqueryRowLimitAccumulator, maxSubqueryRows, dryRun);\n\n        while (!stack.isEmpty()) {\n          current = stack.pop().withChildren(Collections.singletonList(current));\n        }\n\n        assert current instanceof QueryDataSource;\n\n        if (toolChest.canPerformSubquery(((QueryDataSource) current).getQuery())) {\n          return current;\n        } else {\n          \r\n          \r\n          return inlineIfNecessary(current, toolChestIfOutermost, subqueryRowLimitAccumulator, maxSubqueryRows, dryRun);\n        }\n      } else if (canRunQueryUsingLocalWalker(subQuery) || canRunQueryUsingClusterWalker(subQuery)) {\n        \r\n        final Query subQueryWithId = subQuery.withSubQueryId(UUID.randomUUID().toString());\n\n        final Sequence<?> queryResults;\n\n        if (dryRun) {\n          queryResults = Sequences.empty();\n        } else {\n          final QueryRunner subqueryRunner = subQueryWithId.getRunner(this);\n          queryResults = subqueryRunner.run(QueryPlus.wrap(subQueryWithId));\n        }\n\n        return toInlineDataSource(\n            subQueryWithId,\n            queryResults,\n            warehouse.getToolChest(subQueryWithId),\n            subqueryRowLimitAccumulator,\n            maxSubqueryRows\n        );\n      } else {\n        \r\n        return inlineIfNecessary(\n            dataSource.withChildren(\n                Collections.singletonList(\n                    inlineIfNecessary(\n                        Iterables.getOnlyElement(dataSource.getChildren()),\n                        null,\n                        subqueryRowLimitAccumulator,\n                        maxSubqueryRows,\n                        dryRun\n                    )\n                )\n            ),\n            toolChestIfOutermost,\n            subqueryRowLimitAccumulator,\n            maxSubqueryRows,\n            dryRun\n        );\n      }\n    } else {\n      \r\n      return dataSource.withChildren(\n          dataSource.getChildren()\n                    .stream()\n                    .map(child -> inlineIfNecessary(child, null, subqueryRowLimitAccumulator, maxSubqueryRows, dryRun))\n                    .collect(Collectors.toList())\n      );\n    }\n  }\n","realPath":"server/src/main/java/org/apache/druid/server/ClientQuerySegmentWalker.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":290,"status":"M"},{"authorDate":"2020-02-01 15:51:16","commitOrder":5,"curCode":"  private DataSource recursivelyOverrideContext(final DataSource dataSource, final Map<String, Object> context)\n  {\n    if (dataSource instanceof QueryDataSource) {\n      final Query subquery = ((QueryDataSource) dataSource).getQuery();\n      return new QueryDataSource(recursivelyOverrideContext(subquery, context));\n    } else {\n      return dataSource.withChildren(\n          dataSource.getChildren()\n                    .stream()\n                    .map(ds -> recursivelyOverrideContext(ds, context))\n                    .collect(Collectors.toList())\n      );\n    }\n  }\n","date":"2020-02-01 15:51:16","endLine":559,"groupId":"101212","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"recursivelyOverrideContext","params":"(finalDataSourcedataSource@finalMap<String@Object>context)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/44/6f94626f807eaf4692bd394464791bb511e409.src","preCode":"  private DataSource recursivelyOverrideContext(final DataSource dataSource, final Map<String, Object> context)\n  {\n    if (dataSource instanceof QueryDataSource) {\n      final Query subquery = ((QueryDataSource) dataSource).getQuery();\n      return new QueryDataSource(recursivelyOverrideContext(subquery, context));\n    } else {\n      return dataSource.withChildren(\n          dataSource.getChildren()\n                    .stream()\n                    .map(ds -> recursivelyOverrideContext(ds, context))\n                    .collect(Collectors.toList())\n      );\n    }\n  }\n","realPath":"sql/src/test/java/org/apache/druid/sql/calcite/BaseCalciteQueryTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":546,"status":"N"}],"commitId":"657f8ee80fa86779cf26a01072814b1530277aa7","commitMessage":"@@@Fix RetryQueryRunner to actually do the job (#10082)\n\n* Fix RetryQueryRunner to actually do the job\n\n* more javadoc\n\n* fix test and checkstyle\n\n* don't combine for testing\n\n* address comments\n\n* fix unit tests\n\n* always initialize response context in cachingClusteredClient\n\n* fix subquery\n\n* address comments\n\n* fix test\n\n* query id for builders\n\n* make queryId optional in the builders and ClusterQueryResult\n\n* fix test\n\n* suppress tests and unused methods\n\n* exclude groupBy builder\n\n* fix jacoco exclusion\n\n* add tests for builders\n\n* address comments\n\n* don't truncate","date":"2020-07-02 05:02:21","modifiedFileCount":"33","status":"M","submitter":"Jihoon Son"}]
