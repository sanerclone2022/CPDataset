[{"authorTime":"2018-08-31 00:56:26","codes":[{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  public byte[] get(NamedKey key)\n  {\n    try (ResourceHolder<MemcachedClientIF> clientHolder = client.get()) {\n      Future<Object> future;\n      try {\n        future = clientHolder.get().asyncGet(computeKeyHash(memcachedPrefix, key));\n      }\n      catch (IllegalStateException e) {\n        \r\n        errorCount.incrementAndGet();\n        log.warn(e, \"Unable to queue cache operation\");\n        return null;\n      }\n      try {\n        byte[] bytes = (byte[]) future.get(timeout, TimeUnit.MILLISECONDS);\n        if (bytes != null) {\n          hitCount.incrementAndGet();\n        } else {\n          missCount.incrementAndGet();\n        }\n        return bytes == null ? null : deserializeValue(key, bytes);\n      }\n      catch (TimeoutException e) {\n        timeoutCount.incrementAndGet();\n        future.cancel(false);\n        return null;\n      }\n      catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw Throwables.propagate(e);\n      }\n      catch (ExecutionException e) {\n        errorCount.incrementAndGet();\n        log.warn(e, \"Exception pulling item from cache\");\n        return null;\n      }\n    }\n  }\n","date":"2018-08-31 00:56:26","endLine":481,"groupId":"10516","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"get","params":"(NamedKeykey)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/05/3c2970571a2e266e174185f5cd66f841e1f3b8.src","preCode":"  public byte[] get(NamedKey key)\n  {\n    try (ResourceHolder<MemcachedClientIF> clientHolder = client.get()) {\n      Future<Object> future;\n      try {\n        future = clientHolder.get().asyncGet(computeKeyHash(memcachedPrefix, key));\n      }\n      catch (IllegalStateException e) {\n        \r\n        errorCount.incrementAndGet();\n        log.warn(e, \"Unable to queue cache operation\");\n        return null;\n      }\n      try {\n        byte[] bytes = (byte[]) future.get(timeout, TimeUnit.MILLISECONDS);\n        if (bytes != null) {\n          hitCount.incrementAndGet();\n        } else {\n          missCount.incrementAndGet();\n        }\n        return bytes == null ? null : deserializeValue(key, bytes);\n      }\n      catch (TimeoutException e) {\n        timeoutCount.incrementAndGet();\n        future.cancel(false);\n        return null;\n      }\n      catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw Throwables.propagate(e);\n      }\n      catch (ExecutionException e) {\n        errorCount.incrementAndGet();\n        log.warn(e, \"Exception pulling item from cache\");\n        return null;\n      }\n    }\n  }\n","realPath":"server/src/main/java/org/apache/druid/client/cache/MemcachedCache.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":444,"status":"B"},{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  public void put(NamedKey key, byte[] value)\n  {\n    try (final ResourceHolder<MemcachedClientIF> clientHolder = client.get()) {\n      clientHolder.get().set(\n          computeKeyHash(memcachedPrefix, key),\n          expiration,\n          serializeValue(key, value)\n      );\n    }\n    catch (IllegalStateException e) {\n      \r\n      errorCount.incrementAndGet();\n      log.warn(e, \"Unable to queue cache operation\");\n    }\n  }\n","date":"2018-08-31 00:56:26","endLine":498,"groupId":"19362","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"put","params":"(NamedKeykey@byte[]value)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/05/3c2970571a2e266e174185f5cd66f841e1f3b8.src","preCode":"  public void put(NamedKey key, byte[] value)\n  {\n    try (final ResourceHolder<MemcachedClientIF> clientHolder = client.get()) {\n      clientHolder.get().set(\n          computeKeyHash(memcachedPrefix, key),\n          expiration,\n          serializeValue(key, value)\n      );\n    }\n    catch (IllegalStateException e) {\n      \r\n      errorCount.incrementAndGet();\n      log.warn(e, \"Unable to queue cache operation\");\n    }\n  }\n","realPath":"server/src/main/java/org/apache/druid/client/cache/MemcachedCache.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":484,"status":"B"}],"commitId":"431d3d8497f9079857c3baa7ae7ab4cb44a22355","commitMessage":"@@@Rename io.druid to org.apache.druid. (#6266)\n\n* Rename io.druid to org.apache.druid.\n\n* Fix META-INF files and remove some benchmark results.\n\n* MonitorsConfig update for metrics package migration.\n\n* Reorder some dimensions in inner queries for some reason.\n\n* Fix protobuf tests.\n","date":"2018-08-31 00:56:26","modifiedFileCount":"5","status":"B","submitter":"Gian Merlino"},{"authorTime":"2018-08-31 00:56:26","codes":[{"authorDate":"2019-03-15 05:28:33","commitOrder":2,"curCode":"  public byte[] get(NamedKey key)\n  {\n    try (ResourceHolder<MemcachedClientIF> clientHolder = client.get()) {\n      Future<Object> future;\n      try {\n        future = clientHolder.get().asyncGet(computeKeyHash(memcachedPrefix, key));\n      }\n      catch (IllegalStateException e) {\n        \r\n        errorCount.incrementAndGet();\n        log.warn(e, \"Unable to queue cache operation\");\n        return null;\n      }\n      try {\n        byte[] bytes = (byte[]) future.get(timeout, TimeUnit.MILLISECONDS);\n        if (bytes != null) {\n          hitCount.incrementAndGet();\n        } else {\n          missCount.incrementAndGet();\n        }\n        return bytes == null ? null : deserializeValue(key, bytes);\n      }\n      catch (TimeoutException e) {\n        timeoutCount.incrementAndGet();\n        future.cancel(false);\n        return null;\n      }\n      catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new RuntimeException(e);\n      }\n      catch (ExecutionException e) {\n        errorCount.incrementAndGet();\n        log.warn(e, \"Exception pulling item from cache\");\n        return null;\n      }\n    }\n  }\n","date":"2019-03-15 05:28:33","endLine":481,"groupId":"101265","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"get","params":"(NamedKeykey)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/df/318a08da3fbb2c51f89fe8866daadcf70e739d.src","preCode":"  public byte[] get(NamedKey key)\n  {\n    try (ResourceHolder<MemcachedClientIF> clientHolder = client.get()) {\n      Future<Object> future;\n      try {\n        future = clientHolder.get().asyncGet(computeKeyHash(memcachedPrefix, key));\n      }\n      catch (IllegalStateException e) {\n        \r\n        errorCount.incrementAndGet();\n        log.warn(e, \"Unable to queue cache operation\");\n        return null;\n      }\n      try {\n        byte[] bytes = (byte[]) future.get(timeout, TimeUnit.MILLISECONDS);\n        if (bytes != null) {\n          hitCount.incrementAndGet();\n        } else {\n          missCount.incrementAndGet();\n        }\n        return bytes == null ? null : deserializeValue(key, bytes);\n      }\n      catch (TimeoutException e) {\n        timeoutCount.incrementAndGet();\n        future.cancel(false);\n        return null;\n      }\n      catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw Throwables.propagate(e);\n      }\n      catch (ExecutionException e) {\n        errorCount.incrementAndGet();\n        log.warn(e, \"Exception pulling item from cache\");\n        return null;\n      }\n    }\n  }\n","realPath":"server/src/main/java/org/apache/druid/client/cache/MemcachedCache.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":444,"status":"M"},{"authorDate":"2018-08-31 00:56:26","commitOrder":2,"curCode":"  public void put(NamedKey key, byte[] value)\n  {\n    try (final ResourceHolder<MemcachedClientIF> clientHolder = client.get()) {\n      clientHolder.get().set(\n          computeKeyHash(memcachedPrefix, key),\n          expiration,\n          serializeValue(key, value)\n      );\n    }\n    catch (IllegalStateException e) {\n      \r\n      errorCount.incrementAndGet();\n      log.warn(e, \"Unable to queue cache operation\");\n    }\n  }\n","date":"2018-08-31 00:56:26","endLine":498,"groupId":"101265","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"put","params":"(NamedKeykey@byte[]value)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/05/3c2970571a2e266e174185f5cd66f841e1f3b8.src","preCode":"  public void put(NamedKey key, byte[] value)\n  {\n    try (final ResourceHolder<MemcachedClientIF> clientHolder = client.get()) {\n      clientHolder.get().set(\n          computeKeyHash(memcachedPrefix, key),\n          expiration,\n          serializeValue(key, value)\n      );\n    }\n    catch (IllegalStateException e) {\n      \r\n      errorCount.incrementAndGet();\n      log.warn(e, \"Unable to queue cache operation\");\n    }\n  }\n","realPath":"server/src/main/java/org/apache/druid/client/cache/MemcachedCache.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":484,"status":"N"}],"commitId":"7ada1c49f9735a37808f3ed7656d93ae88b8b925","commitMessage":"@@@Prohibit Throwables.propagate() (#7121)\n\n* Throw caught exception.\n\n* Throw caught exceptions.\n\n* Related checkstyle rule is added to prevent further bugs.\n\n* RuntimeException() is used instead of Throwables.propagate().\n\n* Missing import is added.\n\n* Throwables are propogated if possible.\n\n* Throwables are propogated if possible.\n\n* Throwables are propogated if possible.\n\n* Throwables are propogated if possible.\n\n* * Checkstyle definition is improved.\n* Throwables.propagate() usages are removed.\n\n* Checkstyle pattern is changed for only scanning \"Throwables.propagate(\" instead of checking lookbehind.\n\n* Throwable is kept before firing a Runtime Exception.\n\n* Fix unused assignments.\n","date":"2019-03-15 05:28:33","modifiedFileCount":"228","status":"M","submitter":"Furkan KAMACI"}]
