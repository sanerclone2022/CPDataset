[{"authorTime":"2020-03-23 07:43:55","codes":[{"authorDate":"2020-04-10 07:21:43","commitOrder":2,"curCode":"  public void testCommaJoinLeftFunction() throws Exception\n  {\n    testQuery(\n        \"SELECT foo.dim1, foo.dim2, l.k, l.v\\n\"\n        + \"FROM foo, lookup.lookyloo l\\n\"\n        + \"WHERE SUBSTRING(foo.dim2, 1, 1) = l.k\\n\",\n        ImmutableList.of(\n            newScanQueryBuilder()\n                .dataSource(\n                    join(\n                        new TableDataSource(CalciteTests.DATASOURCE1),\n                        new LookupDataSource(\"lookyloo\"),\n                        \"j0.\",\n                        equalsCondition(\n                            DruidExpression.fromExpression(\"substring(\\\"dim2\\\", 0, 1)\"),\n                            DruidExpression.fromColumn(\"j0.k\")\n                        ),\n                        JoinType.INNER\n                    )\n                )\n                .intervals(querySegmentSpec(Filtration.eternity()))\n                .columns(\"dim1\", \"dim2\", \"j0.k\", \"j0.v\")\n                .context(QUERY_CONTEXT_DEFAULT)\n                .build()\n        ),\n        ImmutableList.of(\n            new Object[]{\"\", \"a\", \"a\", \"xa\"},\n            new Object[]{\"1\", \"a\", \"a\", \"xa\"},\n            new Object[]{\"def\", \"abc\", \"a\", \"xa\"}\n        )\n    );\n  }\n","date":"2020-04-10 07:21:43","endLine":8709,"groupId":"10374","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testCommaJoinLeftFunction","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/fc/b55301befe022d83ea51db773a7b47ec95b922.src","preCode":"  public void testCommaJoinLeftFunction() throws Exception\n  {\n    testQuery(\n        \"SELECT foo.dim1, foo.dim2, l.k, l.v\\n\"\n        + \"FROM foo, lookup.lookyloo l\\n\"\n        + \"WHERE SUBSTRING(foo.dim2, 1, 1) = l.k\\n\",\n        ImmutableList.of(\n            newScanQueryBuilder()\n                .dataSource(\n                    join(\n                        new TableDataSource(CalciteTests.DATASOURCE1),\n                        new LookupDataSource(\"lookyloo\"),\n                        \"j0.\",\n                        equalsCondition(\n                            DruidExpression.fromExpression(\"substring(\\\"dim2\\\", 0, 1)\"),\n                            DruidExpression.fromColumn(\"j0.k\")\n                        ),\n                        JoinType.INNER\n                    )\n                )\n                .intervals(querySegmentSpec(Filtration.eternity()))\n                .columns(\"dim1\", \"dim2\", \"j0.k\", \"j0.v\")\n                .context(QUERY_CONTEXT_DEFAULT)\n                .build()\n        ),\n        ImmutableList.of(\n            new Object[]{\"\", \"a\", \"a\", \"xa\"},\n            new Object[]{\"1\", \"a\", \"a\", \"xa\"},\n            new Object[]{\"def\", \"abc\", \"a\", \"xa\"}\n        )\n    );\n  }\n","realPath":"sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":8678,"status":"B"},{"authorDate":"2020-03-23 07:43:55","commitOrder":2,"curCode":"  public void testInnerJoinCastLeft() throws Exception\n  {\n    \r\n\n    testQuery(\n        \"SELECT foo.m1, l.k, l.v\\n\"\n        + \"FROM foo\\n\"\n        + \"INNER JOIN lookup.lookyloo l ON CAST(foo.m1 AS VARCHAR) = l.k\\n\",\n        ImmutableList.of(\n            newScanQueryBuilder()\n                .dataSource(\n                    join(\n                        new TableDataSource(CalciteTests.DATASOURCE1),\n                        new LookupDataSource(\"lookyloo\"),\n                        \"j0.\",\n                        equalsCondition(\n                            DruidExpression.fromExpression(\"CAST(\\\"m1\\\", 'STRING')\"),\n                            DruidExpression.fromColumn(\"j0.k\")\n                        ),\n                        JoinType.INNER\n                    )\n                )\n                .intervals(querySegmentSpec(Filtration.eternity()))\n                .columns(\"j0.k\", \"j0.v\", \"m1\")\n                .context(QUERY_CONTEXT_DEFAULT)\n                .build()\n        ),\n        ImmutableList.of()\n    );\n  }\n","date":"2020-03-23 07:43:55","endLine":8413,"groupId":"10374","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testInnerJoinCastLeft","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/bf/4aae4768404224949ecf6cb280109ad12228a1.src","preCode":"  public void testInnerJoinCastLeft() throws Exception\n  {\n    \r\n\n    testQuery(\n        \"SELECT foo.m1, l.k, l.v\\n\"\n        + \"FROM foo\\n\"\n        + \"INNER JOIN lookup.lookyloo l ON CAST(foo.m1 AS VARCHAR) = l.k\\n\",\n        ImmutableList.of(\n            newScanQueryBuilder()\n                .dataSource(\n                    join(\n                        new TableDataSource(CalciteTests.DATASOURCE1),\n                        new LookupDataSource(\"lookyloo\"),\n                        \"j0.\",\n                        equalsCondition(\n                            DruidExpression.fromExpression(\"CAST(\\\"m1\\\", 'STRING')\"),\n                            DruidExpression.fromColumn(\"j0.k\")\n                        ),\n                        JoinType.INNER\n                    )\n                )\n                .intervals(querySegmentSpec(Filtration.eternity()))\n                .columns(\"j0.k\", \"j0.v\", \"m1\")\n                .context(QUERY_CONTEXT_DEFAULT)\n                .build()\n        ),\n        ImmutableList.of()\n    );\n  }\n","realPath":"sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":8384,"status":"NB"}],"commitId":"75c543b50f40d7b6739ff0d6e10a81315be29736","commitMessage":"@@@SQL: More straightforward handling of join planning. (#9648)\n\n* SQL: More straightforward handling of join planning.\n\nTwo changes that simplify how joins are planned:\n\n1) Stop using JoinProjectTransposeRule as a way of guiding subquery\nremoval. Instead.  add logic to DruidJoinRule that identifies removable\nsubqueries and removes them at the point of creating a DruidJoinQueryRel.\nThis approach reduces the size of the planning space and allows the\nplanner to complete quickly.\n\n2) Remove rules that reorder joins. Not because of an impact on the\nplanning time (it seems minimal).  but because the decisions that the\nplanner was making in the new tests were sometimes worse than the\nuser-provided order. I think we'll need to go with the user-provided\norder for now.  and revisit reordering when we can add more smarts to\nthe cost estimator.\n\nA third change updates numeric ExprEval classes to store their\nvalue as a boxed type that corresponds to what it is supposed to be.\nThis is useful because it affects the behavior of \"asString\".  and\nis included in this patch because it is needed for the new test\n\"testInnerJoinTwoLookupsToTableUsingNumericColumnInReverse\". This\ntest relies on CAST('6'.  'DOUBLE') stringifying to \"6.0\" like an\nactual double would.\n\nFixes #9646.\n\n* Fix comments.\n\n* Fix tests.","date":"2020-04-10 07:21:43","modifiedFileCount":"12","status":"M","submitter":"Gian Merlino"},{"authorTime":"2020-05-29 10:10:26","codes":[{"authorDate":"2020-04-10 07:21:43","commitOrder":3,"curCode":"  public void testCommaJoinLeftFunction() throws Exception\n  {\n    testQuery(\n        \"SELECT foo.dim1, foo.dim2, l.k, l.v\\n\"\n        + \"FROM foo, lookup.lookyloo l\\n\"\n        + \"WHERE SUBSTRING(foo.dim2, 1, 1) = l.k\\n\",\n        ImmutableList.of(\n            newScanQueryBuilder()\n                .dataSource(\n                    join(\n                        new TableDataSource(CalciteTests.DATASOURCE1),\n                        new LookupDataSource(\"lookyloo\"),\n                        \"j0.\",\n                        equalsCondition(\n                            DruidExpression.fromExpression(\"substring(\\\"dim2\\\", 0, 1)\"),\n                            DruidExpression.fromColumn(\"j0.k\")\n                        ),\n                        JoinType.INNER\n                    )\n                )\n                .intervals(querySegmentSpec(Filtration.eternity()))\n                .columns(\"dim1\", \"dim2\", \"j0.k\", \"j0.v\")\n                .context(QUERY_CONTEXT_DEFAULT)\n                .build()\n        ),\n        ImmutableList.of(\n            new Object[]{\"\", \"a\", \"a\", \"xa\"},\n            new Object[]{\"1\", \"a\", \"a\", \"xa\"},\n            new Object[]{\"def\", \"abc\", \"a\", \"xa\"}\n        )\n    );\n  }\n","date":"2020-04-10 07:21:43","endLine":8709,"groupId":"101758","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testCommaJoinLeftFunction","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/fc/b55301befe022d83ea51db773a7b47ec95b922.src","preCode":"  public void testCommaJoinLeftFunction() throws Exception\n  {\n    testQuery(\n        \"SELECT foo.dim1, foo.dim2, l.k, l.v\\n\"\n        + \"FROM foo, lookup.lookyloo l\\n\"\n        + \"WHERE SUBSTRING(foo.dim2, 1, 1) = l.k\\n\",\n        ImmutableList.of(\n            newScanQueryBuilder()\n                .dataSource(\n                    join(\n                        new TableDataSource(CalciteTests.DATASOURCE1),\n                        new LookupDataSource(\"lookyloo\"),\n                        \"j0.\",\n                        equalsCondition(\n                            DruidExpression.fromExpression(\"substring(\\\"dim2\\\", 0, 1)\"),\n                            DruidExpression.fromColumn(\"j0.k\")\n                        ),\n                        JoinType.INNER\n                    )\n                )\n                .intervals(querySegmentSpec(Filtration.eternity()))\n                .columns(\"dim1\", \"dim2\", \"j0.k\", \"j0.v\")\n                .context(QUERY_CONTEXT_DEFAULT)\n                .build()\n        ),\n        ImmutableList.of(\n            new Object[]{\"\", \"a\", \"a\", \"xa\"},\n            new Object[]{\"1\", \"a\", \"a\", \"xa\"},\n            new Object[]{\"def\", \"abc\", \"a\", \"xa\"}\n        )\n    );\n  }\n","realPath":"sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":8678,"status":"N"},{"authorDate":"2020-05-29 10:10:26","commitOrder":3,"curCode":"  public void testInnerJoinCastLeft(Map<String, Object> queryContext) throws Exception\n  {\n    \r\n\n    testQuery(\n        \"SELECT foo.m1, l.k, l.v\\n\"\n        + \"FROM foo\\n\"\n        + \"INNER JOIN lookup.lookyloo l ON CAST(foo.m1 AS VARCHAR) = l.k\\n\",\n        queryContext,\n        ImmutableList.of(\n            newScanQueryBuilder()\n                .dataSource(\n                    join(\n                        new TableDataSource(CalciteTests.DATASOURCE1),\n                        new LookupDataSource(\"lookyloo\"),\n                        \"j0.\",\n                        equalsCondition(\n                            DruidExpression.fromExpression(\"CAST(\\\"m1\\\", 'STRING')\"),\n                            DruidExpression.fromColumn(\"j0.k\")\n                        ),\n                        JoinType.INNER\n                    )\n                )\n                .intervals(querySegmentSpec(Filtration.eternity()))\n                .columns(\"j0.k\", \"j0.v\", \"m1\")\n                .context(queryContext)\n                .build()\n        ),\n        ImmutableList.of()\n    );\n  }\n","date":"2020-05-29 10:10:26","endLine":9338,"groupId":"101758","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testInnerJoinCastLeft","params":"(Map<String@Object>queryContext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/80/330453aa846b49e23c181b6395fcd75bea46f5.src","preCode":"  public void testInnerJoinCastLeft() throws Exception\n  {\n    \r\n\n    testQuery(\n        \"SELECT foo.m1, l.k, l.v\\n\"\n        + \"FROM foo\\n\"\n        + \"INNER JOIN lookup.lookyloo l ON CAST(foo.m1 AS VARCHAR) = l.k\\n\",\n        ImmutableList.of(\n            newScanQueryBuilder()\n                .dataSource(\n                    join(\n                        new TableDataSource(CalciteTests.DATASOURCE1),\n                        new LookupDataSource(\"lookyloo\"),\n                        \"j0.\",\n                        equalsCondition(\n                            DruidExpression.fromExpression(\"CAST(\\\"m1\\\", 'STRING')\"),\n                            DruidExpression.fromColumn(\"j0.k\")\n                        ),\n                        JoinType.INNER\n                    )\n                )\n                .intervals(querySegmentSpec(Filtration.eternity()))\n                .columns(\"j0.k\", \"j0.v\", \"m1\")\n                .context(QUERY_CONTEXT_DEFAULT)\n                .build()\n        ),\n        ImmutableList.of()\n    );\n  }\n","realPath":"sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":9308,"status":"M"}],"commitId":"cbd587dbd64ea7e5b1a316d19752786f01e50dec","commitMessage":"@@@Add parameterized Calcite tests for join queries (#9923)\n\n* Add parameterized Calcite tests for join queries\n\n* new tests\n\n* review comments","date":"2020-05-29 10:10:26","modifiedFileCount":"2","status":"M","submitter":"Suneet Saldanha"}]
