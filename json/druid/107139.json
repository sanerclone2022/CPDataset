[{"authorTime":"2018-08-31 00:56:26","codes":[{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  public void showBenchmarks()\n  {\n    final int start = 1;\n    final int factor = 10;\n    final int end = 10000000;\n    final int radius = 10;\n\n    for (int numPoints = start; numPoints <= end; numPoints *= factor) {\n      try {\n        BitmapFactory bf = new ConciseBitmapFactory();\n        RTree tree = new RTree(2, new LinearGutmanSplitStrategy(0, 50, bf), bf);\n\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        Random rand = new Random();\n        for (int i = 0; i < numPoints; i++) {\n          tree.insert(new float[]{(float) (rand.nextDouble() * 100), (float) (rand.nextDouble() * 100)}, i);\n        }\n        long stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: insert = %,d ms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n        ImmutableRTree searchTree = ImmutableRTree.newImmutableFromMutable(tree);\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: size = %,d bytes%n\", numPoints, searchTree.toBytes().length);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: buildImmutable = %,d ms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n\n        Iterable<ImmutableBitmap> points = searchTree.search(new RadiusBound(new float[]{50, 50}, radius));\n\n        Iterables.size(points);\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n\n        System.out.printf(Locale.ENGLISH, \"[%,d]: search = %,dms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n\n        ImmutableBitmap finalSet = bf.union(points);\n\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: union of %,d points in %,d ms%n\", numPoints, finalSet.size(), stop);\n      }\n      catch (Exception e) {\n        throw Throwables.propagate(e);\n      }\n    }\n  }\n","date":"2018-08-31 00:56:26","endLine":598,"groupId":"19001","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"showBenchmarks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/1d/12d379ab20a8f8a648329ef40a6366b6b54810.src","preCode":"  public void showBenchmarks()\n  {\n    final int start = 1;\n    final int factor = 10;\n    final int end = 10000000;\n    final int radius = 10;\n\n    for (int numPoints = start; numPoints <= end; numPoints *= factor) {\n      try {\n        BitmapFactory bf = new ConciseBitmapFactory();\n        RTree tree = new RTree(2, new LinearGutmanSplitStrategy(0, 50, bf), bf);\n\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        Random rand = new Random();\n        for (int i = 0; i < numPoints; i++) {\n          tree.insert(new float[]{(float) (rand.nextDouble() * 100), (float) (rand.nextDouble() * 100)}, i);\n        }\n        long stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: insert = %,d ms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n        ImmutableRTree searchTree = ImmutableRTree.newImmutableFromMutable(tree);\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: size = %,d bytes%n\", numPoints, searchTree.toBytes().length);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: buildImmutable = %,d ms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n\n        Iterable<ImmutableBitmap> points = searchTree.search(new RadiusBound(new float[]{50, 50}, radius));\n\n        Iterables.size(points);\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n\n        System.out.printf(Locale.ENGLISH, \"[%,d]: search = %,dms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n\n        ImmutableBitmap finalSet = bf.union(points);\n\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: union of %,d points in %,d ms%n\", numPoints, finalSet.size(), stop);\n      }\n      catch (Exception e) {\n        throw Throwables.propagate(e);\n      }\n    }\n  }\n","realPath":"processing/src/test/java/org/apache/druid/collections/spatial/ImmutableRTreeTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":552,"status":"B"},{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  public void showBenchmarksBoundWithLimits()\n  {\n    \r\n    final int start = 10000000;\n    final int factor = 10;\n    final int end = 10000000;\n    \r\n\n    for (int numPoints = start; numPoints <= end; numPoints *= factor) {\n      try {\n        BitmapFactory bf = new ConciseBitmapFactory();\n        RTree tree = new RTree(2, new LinearGutmanSplitStrategy(0, 50, bf), bf);\n\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        Random rand = new Random();\n        for (int i = 0; i < numPoints; i++) {\n          tree.insert(new float[]{(float) (rand.nextDouble() * 100), (float) (rand.nextDouble() * 100)}, i);\n        }\n        long stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: insert = %,d ms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n        ImmutableRTree searchTree = ImmutableRTree.newImmutableFromMutable(tree);\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: size = %,d bytes%n\", numPoints, searchTree.toBytes().length);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: buildImmutable = %,d ms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n\n        Iterable<ImmutableBitmap> points = searchTree.search(\n            new RectangularBound(\n                new float[]{40, 40},\n                new float[]{60, 60},\n                100\n            )\n        );\n\n        Iterables.size(points);\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n\n        System.out.printf(Locale.ENGLISH, \"[%,d]: search = %,dms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n\n        ImmutableBitmap finalSet = bf.union(points);\n\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: union of %,d points in %,d ms%n\", numPoints, finalSet.size(), stop);\n      }\n      catch (Exception e) {\n        throw Throwables.propagate(e);\n      }\n    }\n  }\n","date":"2018-08-31 00:56:26","endLine":654,"groupId":"376","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"showBenchmarksBoundWithLimits","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/1d/12d379ab20a8f8a648329ef40a6366b6b54810.src","preCode":"  public void showBenchmarksBoundWithLimits()\n  {\n    \r\n    final int start = 10000000;\n    final int factor = 10;\n    final int end = 10000000;\n    \r\n\n    for (int numPoints = start; numPoints <= end; numPoints *= factor) {\n      try {\n        BitmapFactory bf = new ConciseBitmapFactory();\n        RTree tree = new RTree(2, new LinearGutmanSplitStrategy(0, 50, bf), bf);\n\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        Random rand = new Random();\n        for (int i = 0; i < numPoints; i++) {\n          tree.insert(new float[]{(float) (rand.nextDouble() * 100), (float) (rand.nextDouble() * 100)}, i);\n        }\n        long stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: insert = %,d ms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n        ImmutableRTree searchTree = ImmutableRTree.newImmutableFromMutable(tree);\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: size = %,d bytes%n\", numPoints, searchTree.toBytes().length);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: buildImmutable = %,d ms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n\n        Iterable<ImmutableBitmap> points = searchTree.search(\n            new RectangularBound(\n                new float[]{40, 40},\n                new float[]{60, 60},\n                100\n            )\n        );\n\n        Iterables.size(points);\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n\n        System.out.printf(Locale.ENGLISH, \"[%,d]: search = %,dms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n\n        ImmutableBitmap finalSet = bf.union(points);\n\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: union of %,d points in %,d ms%n\", numPoints, finalSet.size(), stop);\n      }\n      catch (Exception e) {\n        throw Throwables.propagate(e);\n      }\n    }\n  }\n","realPath":"processing/src/test/java/org/apache/druid/collections/spatial/ImmutableRTreeTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":601,"status":"B"}],"commitId":"431d3d8497f9079857c3baa7ae7ab4cb44a22355","commitMessage":"@@@Rename io.druid to org.apache.druid. (#6266)\n\n* Rename io.druid to org.apache.druid.\n\n* Fix META-INF files and remove some benchmark results.\n\n* MonitorsConfig update for metrics package migration.\n\n* Reorder some dimensions in inner queries for some reason.\n\n* Fix protobuf tests.\n","date":"2018-08-31 00:56:26","modifiedFileCount":"5","status":"B","submitter":"Gian Merlino"},{"authorTime":"2018-09-15 04:35:51","codes":[{"authorDate":"2018-09-15 04:35:51","commitOrder":2,"curCode":"  public void showBenchmarks()\n  {\n    final int start = 1;\n    final int factor = 10;\n    final int end = 10000000;\n    final int radius = 10;\n\n    for (int numPoints = start; numPoints <= end; numPoints *= factor) {\n      try {\n        BitmapFactory bf = new ConciseBitmapFactory();\n        RTree tree = new RTree(2, new LinearGutmanSplitStrategy(0, 50, bf), bf);\n\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        Random rand = ThreadLocalRandom.current();\n        for (int i = 0; i < numPoints; i++) {\n          tree.insert(new float[]{(float) (rand.nextDouble() * 100), (float) (rand.nextDouble() * 100)}, i);\n        }\n        long stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: insert = %,d ms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n        ImmutableRTree searchTree = ImmutableRTree.newImmutableFromMutable(tree);\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: size = %,d bytes%n\", numPoints, searchTree.toBytes().length);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: buildImmutable = %,d ms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n\n        Iterable<ImmutableBitmap> points = searchTree.search(new RadiusBound(new float[]{50, 50}, radius));\n\n        Iterables.size(points);\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n\n        System.out.printf(Locale.ENGLISH, \"[%,d]: search = %,dms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n\n        ImmutableBitmap finalSet = bf.union(points);\n\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: union of %,d points in %,d ms%n\", numPoints, finalSet.size(), stop);\n      }\n      catch (Exception e) {\n        throw Throwables.propagate(e);\n      }\n    }\n  }\n","date":"2018-09-15 04:35:51","endLine":599,"groupId":"19001","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"showBenchmarks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/2c/c5099efe6d59157673a3c75d4ed53dfce68f49.src","preCode":"  public void showBenchmarks()\n  {\n    final int start = 1;\n    final int factor = 10;\n    final int end = 10000000;\n    final int radius = 10;\n\n    for (int numPoints = start; numPoints <= end; numPoints *= factor) {\n      try {\n        BitmapFactory bf = new ConciseBitmapFactory();\n        RTree tree = new RTree(2, new LinearGutmanSplitStrategy(0, 50, bf), bf);\n\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        Random rand = new Random();\n        for (int i = 0; i < numPoints; i++) {\n          tree.insert(new float[]{(float) (rand.nextDouble() * 100), (float) (rand.nextDouble() * 100)}, i);\n        }\n        long stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: insert = %,d ms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n        ImmutableRTree searchTree = ImmutableRTree.newImmutableFromMutable(tree);\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: size = %,d bytes%n\", numPoints, searchTree.toBytes().length);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: buildImmutable = %,d ms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n\n        Iterable<ImmutableBitmap> points = searchTree.search(new RadiusBound(new float[]{50, 50}, radius));\n\n        Iterables.size(points);\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n\n        System.out.printf(Locale.ENGLISH, \"[%,d]: search = %,dms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n\n        ImmutableBitmap finalSet = bf.union(points);\n\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: union of %,d points in %,d ms%n\", numPoints, finalSet.size(), stop);\n      }\n      catch (Exception e) {\n        throw Throwables.propagate(e);\n      }\n    }\n  }\n","realPath":"processing/src/test/java/org/apache/druid/collections/spatial/ImmutableRTreeTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":553,"status":"M"},{"authorDate":"2018-09-15 04:35:51","commitOrder":2,"curCode":"  public void showBenchmarksBoundWithLimits()\n  {\n    \r\n    final int start = 10000000;\n    final int factor = 10;\n    final int end = 10000000;\n    \r\n\n    for (int numPoints = start; numPoints <= end; numPoints *= factor) {\n      try {\n        BitmapFactory bf = new ConciseBitmapFactory();\n        RTree tree = new RTree(2, new LinearGutmanSplitStrategy(0, 50, bf), bf);\n\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        Random rand = ThreadLocalRandom.current();\n        for (int i = 0; i < numPoints; i++) {\n          tree.insert(new float[]{(float) (rand.nextDouble() * 100), (float) (rand.nextDouble() * 100)}, i);\n        }\n        long stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: insert = %,d ms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n        ImmutableRTree searchTree = ImmutableRTree.newImmutableFromMutable(tree);\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: size = %,d bytes%n\", numPoints, searchTree.toBytes().length);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: buildImmutable = %,d ms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n\n        Iterable<ImmutableBitmap> points = searchTree.search(\n            new RectangularBound(\n                new float[]{40, 40},\n                new float[]{60, 60},\n                100\n            )\n        );\n\n        Iterables.size(points);\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n\n        System.out.printf(Locale.ENGLISH, \"[%,d]: search = %,dms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n\n        ImmutableBitmap finalSet = bf.union(points);\n\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: union of %,d points in %,d ms%n\", numPoints, finalSet.size(), stop);\n      }\n      catch (Exception e) {\n        throw Throwables.propagate(e);\n      }\n    }\n  }\n","date":"2018-09-15 04:35:51","endLine":655,"groupId":"376","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"showBenchmarksBoundWithLimits","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/2c/c5099efe6d59157673a3c75d4ed53dfce68f49.src","preCode":"  public void showBenchmarksBoundWithLimits()\n  {\n    \r\n    final int start = 10000000;\n    final int factor = 10;\n    final int end = 10000000;\n    \r\n\n    for (int numPoints = start; numPoints <= end; numPoints *= factor) {\n      try {\n        BitmapFactory bf = new ConciseBitmapFactory();\n        RTree tree = new RTree(2, new LinearGutmanSplitStrategy(0, 50, bf), bf);\n\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        Random rand = new Random();\n        for (int i = 0; i < numPoints; i++) {\n          tree.insert(new float[]{(float) (rand.nextDouble() * 100), (float) (rand.nextDouble() * 100)}, i);\n        }\n        long stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: insert = %,d ms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n        ImmutableRTree searchTree = ImmutableRTree.newImmutableFromMutable(tree);\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: size = %,d bytes%n\", numPoints, searchTree.toBytes().length);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: buildImmutable = %,d ms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n\n        Iterable<ImmutableBitmap> points = searchTree.search(\n            new RectangularBound(\n                new float[]{40, 40},\n                new float[]{60, 60},\n                100\n            )\n        );\n\n        Iterables.size(points);\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n\n        System.out.printf(Locale.ENGLISH, \"[%,d]: search = %,dms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n\n        ImmutableBitmap finalSet = bf.union(points);\n\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: union of %,d points in %,d ms%n\", numPoints, finalSet.size(), stop);\n      }\n      catch (Exception e) {\n        throw Throwables.propagate(e);\n      }\n    }\n  }\n","realPath":"processing/src/test/java/org/apache/druid/collections/spatial/ImmutableRTreeTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":602,"status":"M"}],"commitId":"0c4bd2b57b19bcbd9a275fad412960aa0a39ca5f","commitMessage":"@@@Prohibit some Random usage patterns (#6226)\n\n* Prohibit Random usage patterns\n\n* Fix FlattenJSONBenchmarkUtil\n","date":"2018-09-15 04:35:51","modifiedFileCount":"44","status":"M","submitter":"Roman Leventov"},{"authorTime":"2019-03-15 05:28:33","codes":[{"authorDate":"2019-03-15 05:28:33","commitOrder":3,"curCode":"  public void showBenchmarks()\n  {\n    final int start = 1;\n    final int factor = 10;\n    final int end = 10000000;\n    final int radius = 10;\n\n    for (int numPoints = start; numPoints <= end; numPoints *= factor) {\n      try {\n        BitmapFactory bf = new ConciseBitmapFactory();\n        RTree tree = new RTree(2, new LinearGutmanSplitStrategy(0, 50, bf), bf);\n\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        Random rand = ThreadLocalRandom.current();\n        for (int i = 0; i < numPoints; i++) {\n          tree.insert(new float[]{(float) (rand.nextDouble() * 100), (float) (rand.nextDouble() * 100)}, i);\n        }\n        long stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: insert = %,d ms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n        ImmutableRTree searchTree = ImmutableRTree.newImmutableFromMutable(tree);\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: size = %,d bytes%n\", numPoints, searchTree.toBytes().length);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: buildImmutable = %,d ms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n\n        Iterable<ImmutableBitmap> points = searchTree.search(new RadiusBound(new float[]{50, 50}, radius));\n\n        Iterables.size(points);\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n\n        System.out.printf(Locale.ENGLISH, \"[%,d]: search = %,dms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n\n        ImmutableBitmap finalSet = bf.union(points);\n\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: union of %,d points in %,d ms%n\", numPoints, finalSet.size(), stop);\n      }\n      catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n","date":"2019-03-15 05:28:33","endLine":599,"groupId":"107139","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"showBenchmarks","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/cb/a7eaff2094bd7a870781a248ecea2f6d63c995.src","preCode":"  public void showBenchmarks()\n  {\n    final int start = 1;\n    final int factor = 10;\n    final int end = 10000000;\n    final int radius = 10;\n\n    for (int numPoints = start; numPoints <= end; numPoints *= factor) {\n      try {\n        BitmapFactory bf = new ConciseBitmapFactory();\n        RTree tree = new RTree(2, new LinearGutmanSplitStrategy(0, 50, bf), bf);\n\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        Random rand = ThreadLocalRandom.current();\n        for (int i = 0; i < numPoints; i++) {\n          tree.insert(new float[]{(float) (rand.nextDouble() * 100), (float) (rand.nextDouble() * 100)}, i);\n        }\n        long stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: insert = %,d ms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n        ImmutableRTree searchTree = ImmutableRTree.newImmutableFromMutable(tree);\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: size = %,d bytes%n\", numPoints, searchTree.toBytes().length);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: buildImmutable = %,d ms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n\n        Iterable<ImmutableBitmap> points = searchTree.search(new RadiusBound(new float[]{50, 50}, radius));\n\n        Iterables.size(points);\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n\n        System.out.printf(Locale.ENGLISH, \"[%,d]: search = %,dms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n\n        ImmutableBitmap finalSet = bf.union(points);\n\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: union of %,d points in %,d ms%n\", numPoints, finalSet.size(), stop);\n      }\n      catch (Exception e) {\n        throw Throwables.propagate(e);\n      }\n    }\n  }\n","realPath":"processing/src/test/java/org/apache/druid/collections/spatial/ImmutableRTreeTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":553,"status":"M"},{"authorDate":"2019-03-15 05:28:33","commitOrder":3,"curCode":"  public void showBenchmarksBoundWithLimits()\n  {\n    \r\n    final int start = 10000000;\n    final int factor = 10;\n    final int end = 10000000;\n    \r\n\n    for (int numPoints = start; numPoints <= end; numPoints *= factor) {\n      try {\n        BitmapFactory bf = new ConciseBitmapFactory();\n        RTree tree = new RTree(2, new LinearGutmanSplitStrategy(0, 50, bf), bf);\n\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        Random rand = ThreadLocalRandom.current();\n        for (int i = 0; i < numPoints; i++) {\n          tree.insert(new float[]{(float) (rand.nextDouble() * 100), (float) (rand.nextDouble() * 100)}, i);\n        }\n        long stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: insert = %,d ms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n        ImmutableRTree searchTree = ImmutableRTree.newImmutableFromMutable(tree);\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: size = %,d bytes%n\", numPoints, searchTree.toBytes().length);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: buildImmutable = %,d ms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n\n        Iterable<ImmutableBitmap> points = searchTree.search(\n            new RectangularBound(\n                new float[]{40, 40},\n                new float[]{60, 60},\n                100\n            )\n        );\n\n        Iterables.size(points);\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n\n        System.out.printf(Locale.ENGLISH, \"[%,d]: search = %,dms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n\n        ImmutableBitmap finalSet = bf.union(points);\n\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: union of %,d points in %,d ms%n\", numPoints, finalSet.size(), stop);\n      }\n      catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n","date":"2019-03-15 05:28:33","endLine":655,"groupId":"107139","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"showBenchmarksBoundWithLimits","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/cb/a7eaff2094bd7a870781a248ecea2f6d63c995.src","preCode":"  public void showBenchmarksBoundWithLimits()\n  {\n    \r\n    final int start = 10000000;\n    final int factor = 10;\n    final int end = 10000000;\n    \r\n\n    for (int numPoints = start; numPoints <= end; numPoints *= factor) {\n      try {\n        BitmapFactory bf = new ConciseBitmapFactory();\n        RTree tree = new RTree(2, new LinearGutmanSplitStrategy(0, 50, bf), bf);\n\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        Random rand = ThreadLocalRandom.current();\n        for (int i = 0; i < numPoints; i++) {\n          tree.insert(new float[]{(float) (rand.nextDouble() * 100), (float) (rand.nextDouble() * 100)}, i);\n        }\n        long stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: insert = %,d ms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n        ImmutableRTree searchTree = ImmutableRTree.newImmutableFromMutable(tree);\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: size = %,d bytes%n\", numPoints, searchTree.toBytes().length);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: buildImmutable = %,d ms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n\n        Iterable<ImmutableBitmap> points = searchTree.search(\n            new RectangularBound(\n                new float[]{40, 40},\n                new float[]{60, 60},\n                100\n            )\n        );\n\n        Iterables.size(points);\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n\n        System.out.printf(Locale.ENGLISH, \"[%,d]: search = %,dms%n\", numPoints, stop);\n\n        stopwatch.reset().start();\n\n        ImmutableBitmap finalSet = bf.union(points);\n\n        stop = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n        System.out.printf(Locale.ENGLISH, \"[%,d]: union of %,d points in %,d ms%n\", numPoints, finalSet.size(), stop);\n      }\n      catch (Exception e) {\n        throw Throwables.propagate(e);\n      }\n    }\n  }\n","realPath":"processing/src/test/java/org/apache/druid/collections/spatial/ImmutableRTreeTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":602,"status":"M"}],"commitId":"7ada1c49f9735a37808f3ed7656d93ae88b8b925","commitMessage":"@@@Prohibit Throwables.propagate() (#7121)\n\n* Throw caught exception.\n\n* Throw caught exceptions.\n\n* Related checkstyle rule is added to prevent further bugs.\n\n* RuntimeException() is used instead of Throwables.propagate().\n\n* Missing import is added.\n\n* Throwables are propogated if possible.\n\n* Throwables are propogated if possible.\n\n* Throwables are propogated if possible.\n\n* Throwables are propogated if possible.\n\n* * Checkstyle definition is improved.\n* Throwables.propagate() usages are removed.\n\n* Checkstyle pattern is changed for only scanning \"Throwables.propagate(\" instead of checking lookbehind.\n\n* Throwable is kept before firing a Runtime Exception.\n\n* Fix unused assignments.\n","date":"2019-03-15 05:28:33","modifiedFileCount":"228","status":"M","submitter":"Furkan KAMACI"}]
