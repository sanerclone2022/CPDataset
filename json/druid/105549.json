[{"authorTime":"2019-08-08 04:51:21","codes":[{"authorDate":"2019-08-08 04:51:21","commitOrder":1,"curCode":"  private List<AtomicUpdateGroup<T>> findLatestNonFullyAvailableAtomicUpdateGroups(List<AtomicUpdateGroup<T>> groups)\n  {\n    if (groups.isEmpty()) {\n      return Collections.emptyList();\n    }\n\n    final OvershadowableManager<T> manager = new OvershadowableManager<>(groups);\n    if (!manager.standbyGroups.isEmpty()) {\n      throw new ISE(\"This method should be called only when there is no fully available group in the given state.\");\n    }\n\n    final List<AtomicUpdateGroup<T>> visibles = new ArrayList<>();\n    for (Short2ObjectSortedMap<AtomicUpdateGroup<T>> map : manager.visibleGroup.values()) {\n      visibles.addAll(map.values());\n    }\n    return visibles;\n  }\n","date":"2019-08-08 04:51:21","endLine":792,"groupId":"17852","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"findLatestNonFullyAvailableAtomicUpdateGroups","params":"(List<AtomicUpdateGroup<T>>groups)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/d3/f090f1f1a1bf7ea21f6c095b71e132c3ad0d79.src","preCode":"  private List<AtomicUpdateGroup<T>> findLatestNonFullyAvailableAtomicUpdateGroups(List<AtomicUpdateGroup<T>> groups)\n  {\n    if (groups.isEmpty()) {\n      return Collections.emptyList();\n    }\n\n    final OvershadowableManager<T> manager = new OvershadowableManager<>(groups);\n    if (!manager.standbyGroups.isEmpty()) {\n      throw new ISE(\"This method should be called only when there is no fully available group in the given state.\");\n    }\n\n    final List<AtomicUpdateGroup<T>> visibles = new ArrayList<>();\n    for (Short2ObjectSortedMap<AtomicUpdateGroup<T>> map : manager.visibleGroup.values()) {\n      visibles.addAll(map.values());\n    }\n    return visibles;\n  }\n","realPath":"core/src/main/java/org/apache/druid/timeline/partition/OvershadowableManager.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":776,"status":"B"},{"authorDate":"2019-08-08 04:51:21","commitOrder":1,"curCode":"  private List<AtomicUpdateGroup<T>> findLatestFullyAvailableOvershadowedAtomicUpdateGroups(\n      RootPartitionRange rangeOfAug,\n      short minorVersion\n  )\n  {\n    final List<AtomicUpdateGroup<T>> overshadowedGroups = findOvershadowedBy(\n        rangeOfAug,\n        minorVersion,\n        State.OVERSHADOWED\n    );\n    if (overshadowedGroups.isEmpty()) {\n      return Collections.emptyList();\n    }\n\n    final OvershadowableManager<T> manager = new OvershadowableManager<>(overshadowedGroups);\n    final List<AtomicUpdateGroup<T>> visibles = new ArrayList<>();\n    for (Short2ObjectSortedMap<AtomicUpdateGroup<T>> map : manager.visibleGroup.values()) {\n      for (AtomicUpdateGroup<T> atomicUpdateGroup : map.values()) {\n        if (!atomicUpdateGroup.isFull()) {\n          return Collections.emptyList();\n        }\n        visibles.add(atomicUpdateGroup);\n      }\n    }\n    final RootPartitionRange foundRange = RootPartitionRange.of(\n        visibles.get(0).getStartRootPartitionId(),\n        visibles.get(visibles.size() - 1).getEndRootPartitionId()\n    );\n    if (!rangeOfAug.equals(foundRange)) {\n      return Collections.emptyList();\n    }\n    return visibles;\n  }\n","date":"2019-08-08 04:51:21","endLine":826,"groupId":"17851","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"findLatestFullyAvailableOvershadowedAtomicUpdateGroups","params":"(RootPartitionRangerangeOfAug@shortminorVersion)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/d3/f090f1f1a1bf7ea21f6c095b71e132c3ad0d79.src","preCode":"  private List<AtomicUpdateGroup<T>> findLatestFullyAvailableOvershadowedAtomicUpdateGroups(\n      RootPartitionRange rangeOfAug,\n      short minorVersion\n  )\n  {\n    final List<AtomicUpdateGroup<T>> overshadowedGroups = findOvershadowedBy(\n        rangeOfAug,\n        minorVersion,\n        State.OVERSHADOWED\n    );\n    if (overshadowedGroups.isEmpty()) {\n      return Collections.emptyList();\n    }\n\n    final OvershadowableManager<T> manager = new OvershadowableManager<>(overshadowedGroups);\n    final List<AtomicUpdateGroup<T>> visibles = new ArrayList<>();\n    for (Short2ObjectSortedMap<AtomicUpdateGroup<T>> map : manager.visibleGroup.values()) {\n      for (AtomicUpdateGroup<T> atomicUpdateGroup : map.values()) {\n        if (!atomicUpdateGroup.isFull()) {\n          return Collections.emptyList();\n        }\n        visibles.add(atomicUpdateGroup);\n      }\n    }\n    final RootPartitionRange foundRange = RootPartitionRange.of(\n        visibles.get(0).getStartRootPartitionId(),\n        visibles.get(visibles.size() - 1).getEndRootPartitionId()\n    );\n    if (!rangeOfAug.equals(foundRange)) {\n      return Collections.emptyList();\n    }\n    return visibles;\n  }\n","realPath":"core/src/main/java/org/apache/druid/timeline/partition/OvershadowableManager.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":794,"status":"B"}],"commitId":"8fa114c34965e4ad19a3782b60f19ee2036ccb5a","commitMessage":"@@@Fix bugs in overshadowableManager and add unit tests (#8222)\n\n* Fix bugs in overshadowableManager and add unit tests\n\n* Fix SegmentManager\n\n* add segment manager test\n\n* Address comments\n\n* Address comments\n","date":"2019-08-08 04:51:21","modifiedFileCount":"13","status":"B","submitter":"Jihoon Son"},{"authorTime":"2020-01-28 03:24:29","codes":[{"authorDate":"2020-01-28 03:24:29","commitOrder":2,"curCode":"  private List<AtomicUpdateGroup<T>> findLatestNonFullyAvailableAtomicUpdateGroups(List<AtomicUpdateGroup<T>> groups)\n  {\n    if (groups.isEmpty()) {\n      return Collections.emptyList();\n    }\n\n    final OvershadowableManager<T> manager = new OvershadowableManager<>(groups);\n    if (!manager.standbyGroups.isEmpty()) {\n      throw new ISE(\"This method should be called only when there is no fully available group in the given state.\");\n    }\n\n    final List<AtomicUpdateGroup<T>> visibles = new ArrayList<>();\n    for (Short2ObjectSortedMap<AtomicUpdateGroup<T>> map : manager.visibleGroupPerRange.values()) {\n      visibles.addAll(map.values());\n    }\n    return visibles;\n  }\n","date":"2020-01-28 03:24:29","endLine":798,"groupId":"17852","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"findLatestNonFullyAvailableAtomicUpdateGroups","params":"(List<AtomicUpdateGroup<T>>groups)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/fc/c77ddcd852109130881f27e3d08d48cca9ca11.src","preCode":"  private List<AtomicUpdateGroup<T>> findLatestNonFullyAvailableAtomicUpdateGroups(List<AtomicUpdateGroup<T>> groups)\n  {\n    if (groups.isEmpty()) {\n      return Collections.emptyList();\n    }\n\n    final OvershadowableManager<T> manager = new OvershadowableManager<>(groups);\n    if (!manager.standbyGroups.isEmpty()) {\n      throw new ISE(\"This method should be called only when there is no fully available group in the given state.\");\n    }\n\n    final List<AtomicUpdateGroup<T>> visibles = new ArrayList<>();\n    for (Short2ObjectSortedMap<AtomicUpdateGroup<T>> map : manager.visibleGroup.values()) {\n      visibles.addAll(map.values());\n    }\n    return visibles;\n  }\n","realPath":"core/src/main/java/org/apache/druid/timeline/partition/OvershadowableManager.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":782,"status":"M"},{"authorDate":"2020-01-28 03:24:29","commitOrder":2,"curCode":"  private List<AtomicUpdateGroup<T>> findLatestFullyAvailableOvershadowedAtomicUpdateGroups(\n      RootPartitionRange rangeOfAug,\n      short minorVersion\n  )\n  {\n    final List<AtomicUpdateGroup<T>> overshadowedGroups = findOvershadowedBy(\n        rangeOfAug,\n        minorVersion,\n        State.OVERSHADOWED\n    );\n    if (overshadowedGroups.isEmpty()) {\n      return Collections.emptyList();\n    }\n\n    final OvershadowableManager<T> manager = new OvershadowableManager<>(overshadowedGroups);\n    final List<AtomicUpdateGroup<T>> visibles = new ArrayList<>();\n    for (Short2ObjectSortedMap<AtomicUpdateGroup<T>> map : manager.visibleGroupPerRange.values()) {\n      for (AtomicUpdateGroup<T> atomicUpdateGroup : map.values()) {\n        if (!atomicUpdateGroup.isFull()) {\n          return Collections.emptyList();\n        }\n        visibles.add(atomicUpdateGroup);\n      }\n    }\n    final RootPartitionRange foundRange = RootPartitionRange.of(\n        visibles.get(0).getStartRootPartitionId(),\n        visibles.get(visibles.size() - 1).getEndRootPartitionId()\n    );\n    if (!rangeOfAug.equals(foundRange)) {\n      return Collections.emptyList();\n    }\n    return visibles;\n  }\n","date":"2020-01-28 03:24:29","endLine":832,"groupId":"17851","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"findLatestFullyAvailableOvershadowedAtomicUpdateGroups","params":"(RootPartitionRangerangeOfAug@shortminorVersion)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/fc/c77ddcd852109130881f27e3d08d48cca9ca11.src","preCode":"  private List<AtomicUpdateGroup<T>> findLatestFullyAvailableOvershadowedAtomicUpdateGroups(\n      RootPartitionRange rangeOfAug,\n      short minorVersion\n  )\n  {\n    final List<AtomicUpdateGroup<T>> overshadowedGroups = findOvershadowedBy(\n        rangeOfAug,\n        minorVersion,\n        State.OVERSHADOWED\n    );\n    if (overshadowedGroups.isEmpty()) {\n      return Collections.emptyList();\n    }\n\n    final OvershadowableManager<T> manager = new OvershadowableManager<>(overshadowedGroups);\n    final List<AtomicUpdateGroup<T>> visibles = new ArrayList<>();\n    for (Short2ObjectSortedMap<AtomicUpdateGroup<T>> map : manager.visibleGroup.values()) {\n      for (AtomicUpdateGroup<T> atomicUpdateGroup : map.values()) {\n        if (!atomicUpdateGroup.isFull()) {\n          return Collections.emptyList();\n        }\n        visibles.add(atomicUpdateGroup);\n      }\n    }\n    final RootPartitionRange foundRange = RootPartitionRange.of(\n        visibles.get(0).getStartRootPartitionId(),\n        visibles.get(visibles.size() - 1).getEndRootPartitionId()\n    );\n    if (!rangeOfAug.equals(foundRange)) {\n      return Collections.emptyList();\n    }\n    return visibles;\n  }\n","realPath":"core/src/main/java/org/apache/druid/timeline/partition/OvershadowableManager.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":800,"status":"M"}],"commitId":"b9186f8f9ff2ff52aceda42bc5f24ffd47a7d17e","commitMessage":"@@@Reconcile terminology and method naming to 'used/unused segments'; Rename MetadataSegmentManager to MetadataSegmentsManager (#7306)\n\n* Reconcile terminology and method naming to 'used/unused segments'; Don't use terms 'enable/disable data source'; Rename MetadataSegmentManager to MetadataSegments; Make REST API methods which mark segments as used/unused to return server error instead of an empty response in case of error\n\n* Fix brace\n\n* Import order\n\n* Rename withKillDataSourceWhitelist to withSpecificDataSourcesToKill\n\n* Fix tests\n\n* Fix tests by adding proper methods without interval parameters to IndexerMetadataStorageCoordinator instead of hacking with Intervals.ETERNITY\n\n* More aligned names of DruidCoordinatorHelpers.  rename several CoordinatorDynamicConfig parameters\n\n* Rename ClientCompactTaskQuery to ClientCompactionTaskQuery for consistency with CompactionTask; ClientCompactQueryTuningConfig to ClientCompactionTaskQueryTuningConfig\n\n* More variable and method renames\n\n* Rename MetadataSegments to SegmentsMetadata\n\n* Javadoc update\n\n* Simplify SegmentsMetadata.getUnusedSegmentIntervals().  more javadocs\n\n* Update Javadoc of VersionedIntervalTimeline.iterateAllObjects()\n\n* Reorder imports\n\n* Rename SegmentsMetadata.tryMark... methods to mark... and make them to return boolean and the numbers of segments changed and relay exceptions to callers\n\n* Complete merge\n\n* Add CollectionUtils.newTreeSet(); Refactor DruidCoordinatorRuntimeParams creation in tests\n\n* Remove MetadataSegmentManager\n\n* Rename millisLagSinceCoordinatorBecomesLeaderBeforeCanMarkAsUnusedOvershadowedSegments to leadingTimeMillisBeforeCanMarkAsUnusedOvershadowedSegments\n\n* Fix tests.  refactor DruidCluster creation in tests into DruidClusterBuilder\n\n* Fix inspections\n\n* Fix SQLMetadataSegmentManagerEmptyTest and rename it to SqlSegmentsMetadataEmptyTest\n\n* Rename SegmentsAndMetadata to SegmentsAndCommitMetadata to reduce the similarity with SegmentsMetadata; Rename some methods\n\n* Rename DruidCoordinatorHelper to CoordinatorDuty.  refactor DruidCoordinator\n\n* Unused import\n\n* Optimize imports\n\n* Rename IndexerSQLMetadataStorageCoordinator.getDataSourceMetadata() to retrieveDataSourceMetadata()\n\n* Unused import\n\n* Update terminology in datasource-view.tsx\n\n* Fix label in datasource-view.spec.tsx.snap\n\n* Fix lint errors in datasource-view.tsx\n\n* Doc improvements\n\n* Another attempt to please TSLint\n\n* Another attempt to please TSLint\n\n* Style fixes\n\n* Fix IndexerSQLMetadataStorageCoordinator.createUsedSegmentsSqlQueryForIntervals() (wrong merge)\n\n* Try to fix docs build issue\n\n* Javadoc and spelling fixes\n\n* Rename SegmentsMetadata to SegmentsMetadataManager.  address other comments\n\n* Address more comments\n","date":"2020-01-28 03:24:29","modifiedFileCount":"127","status":"M","submitter":"Roman Leventov"},{"authorTime":"2020-03-11 04:22:19","codes":[{"authorDate":"2020-03-11 04:22:19","commitOrder":3,"curCode":"  private List<AtomicUpdateGroup<T>> findLatestNonFullyAvailableAtomicUpdateGroups(List<AtomicUpdateGroup<T>> groups)\n  {\n    if (groups.isEmpty()) {\n      return Collections.emptyList();\n    }\n\n    final TreeMap<RootPartitionRange, AtomicUpdateGroup<T>> rangeToGroup = new TreeMap<>();\n    for (AtomicUpdateGroup<T> group : groups) {\n      rangeToGroup.put(RootPartitionRange.of(group), group);\n    }\n    final List<AtomicUpdateGroup<T>> visibles = new ArrayList<>();\n    \r\n    \r\n    \r\n    Entry<RootPartitionRange, AtomicUpdateGroup<T>> currEntry = rangeToGroup.lastEntry();\n    while (currEntry != null) {\n      final Entry<RootPartitionRange, AtomicUpdateGroup<T>> lowerEntry = rangeToGroup.lowerEntry(currEntry.getKey());\n      if (lowerEntry != null) {\n        if (lowerEntry.getKey().endPartitionId != currEntry.getKey().startPartitionId) {\n          return Collections.emptyList();\n        }\n      }\n      visibles.add(currEntry.getValue());\n      currEntry = lowerEntry;\n    }\n    \r\n    visibles.sort(Comparator.comparing(RootPartitionRange::of));\n    return visibles;\n  }\n","date":"2020-03-11 04:22:19","endLine":816,"groupId":"105549","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"findLatestNonFullyAvailableAtomicUpdateGroups","params":"(List<AtomicUpdateGroup<T>>groups)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/a4/529f31cefb2e9ee6ecef3d2e439b6b7454ca05.src","preCode":"  private List<AtomicUpdateGroup<T>> findLatestNonFullyAvailableAtomicUpdateGroups(List<AtomicUpdateGroup<T>> groups)\n  {\n    if (groups.isEmpty()) {\n      return Collections.emptyList();\n    }\n\n    final OvershadowableManager<T> manager = new OvershadowableManager<>(groups);\n    if (!manager.standbyGroups.isEmpty()) {\n      throw new ISE(\"This method should be called only when there is no fully available group in the given state.\");\n    }\n\n    final List<AtomicUpdateGroup<T>> visibles = new ArrayList<>();\n    for (Short2ObjectSortedMap<AtomicUpdateGroup<T>> map : manager.visibleGroupPerRange.values()) {\n      visibles.addAll(map.values());\n    }\n    return visibles;\n  }\n","realPath":"core/src/main/java/org/apache/druid/timeline/partition/OvershadowableManager.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":788,"status":"M"},{"authorDate":"2020-03-11 04:22:19","commitOrder":3,"curCode":"  private List<AtomicUpdateGroup<T>> findLatestFullyAvailableOvershadowedAtomicUpdateGroups(\n      RootPartitionRange rangeOfAug,\n      short minorVersion\n  )\n  {\n    final List<AtomicUpdateGroup<T>> overshadowedGroups = findOvershadowedBy(\n        rangeOfAug,\n        minorVersion,\n        State.OVERSHADOWED\n    );\n\n    \r\n    final TreeMap<RootPartitionRange, AtomicUpdateGroup<T>> fullGroups = new TreeMap<>();\n    for (AtomicUpdateGroup<T> group : FluentIterable.from(overshadowedGroups).filter(AtomicUpdateGroup::isFull)) {\n      fullGroups.put(RootPartitionRange.of(group), group);\n    }\n    if (fullGroups.isEmpty()) {\n      return Collections.emptyList();\n    }\n    if (fullGroups.firstKey().startPartitionId != rangeOfAug.startPartitionId\n        || fullGroups.lastKey().endPartitionId != rangeOfAug.endPartitionId) {\n      return Collections.emptyList();\n    }\n\n    \r\n    final List<AtomicUpdateGroup<T>> visibles = new ArrayList<>();\n    \r\n    \r\n    \r\n    Entry<RootPartitionRange, AtomicUpdateGroup<T>> currEntry = fullGroups.lastEntry();\n    while (currEntry != null) {\n      final Entry<RootPartitionRange, AtomicUpdateGroup<T>> lowerEntry = fullGroups.lowerEntry(currEntry.getKey());\n      if (lowerEntry != null) {\n        if (lowerEntry.getKey().endPartitionId != currEntry.getKey().startPartitionId) {\n          return Collections.emptyList();\n        }\n      }\n      visibles.add(currEntry.getValue());\n      currEntry = lowerEntry;\n    }\n    \r\n    visibles.sort(Comparator.comparing(RootPartitionRange::of));\n    return visibles;\n  }\n","date":"2020-03-11 04:22:19","endLine":861,"groupId":"105549","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"findLatestFullyAvailableOvershadowedAtomicUpdateGroups","params":"(RootPartitionRangerangeOfAug@shortminorVersion)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/a4/529f31cefb2e9ee6ecef3d2e439b6b7454ca05.src","preCode":"  private List<AtomicUpdateGroup<T>> findLatestFullyAvailableOvershadowedAtomicUpdateGroups(\n      RootPartitionRange rangeOfAug,\n      short minorVersion\n  )\n  {\n    final List<AtomicUpdateGroup<T>> overshadowedGroups = findOvershadowedBy(\n        rangeOfAug,\n        minorVersion,\n        State.OVERSHADOWED\n    );\n    if (overshadowedGroups.isEmpty()) {\n      return Collections.emptyList();\n    }\n\n    final OvershadowableManager<T> manager = new OvershadowableManager<>(overshadowedGroups);\n    final List<AtomicUpdateGroup<T>> visibles = new ArrayList<>();\n    for (Short2ObjectSortedMap<AtomicUpdateGroup<T>> map : manager.visibleGroupPerRange.values()) {\n      for (AtomicUpdateGroup<T> atomicUpdateGroup : map.values()) {\n        if (!atomicUpdateGroup.isFull()) {\n          return Collections.emptyList();\n        }\n        visibles.add(atomicUpdateGroup);\n      }\n    }\n    final RootPartitionRange foundRange = RootPartitionRange.of(\n        visibles.get(0).getStartRootPartitionId(),\n        visibles.get(visibles.size() - 1).getEndRootPartitionId()\n    );\n    if (!rangeOfAug.equals(foundRange)) {\n      return Collections.emptyList();\n    }\n    return visibles;\n  }\n","realPath":"core/src/main/java/org/apache/druid/timeline/partition/OvershadowableManager.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":818,"status":"M"}],"commitId":"7401bb3f9315bf0622b6e0fe7c7fd855d1c65052","commitMessage":"@@@Improve OvershadowableManager performance (#9441)\n\n* Use the iterator instead of higherKey(); use the iterator API instead of stream\n\n* Fix tests; fix a concurrency bug in timeline\n\n* fix test\n\n* add tests for findNonOvershadowedObjectsInInterval\n\n* fix test\n\n* add missing tests; fix a bug in QueueEntry\n\n* equals tests\n\n* fix test","date":"2020-03-11 04:22:19","modifiedFileCount":"18","status":"M","submitter":"Jihoon Son"}]
