[{"authorTime":"2020-03-17 13:16:14","codes":[{"authorDate":"2020-03-12 02:32:27","commitOrder":4,"curCode":"      new LookupExtractorFactoryContainerProvider()\n      {\n        @Override\n        public Set<String> getAllLookupNames()\n        {\n          return ImmutableSet.of(LookupSegmentTest.LOOKUP_NAME);\n        }\n\n        @Override\n        public Optional<LookupExtractorFactoryContainer> get(final String lookupName)\n        {\n          if (LookupSegmentTest.LOOKUP_NAME.equals(lookupName)) {\n            return Optional.of(\n                new LookupExtractorFactoryContainer(\n                    \"v0\",\n                    LookupSegmentTest.LOOKUP_EXTRACTOR_FACTORY\n                )\n            );\n          } else {\n            return Optional.empty();\n          }\n        }\n      }\n","date":"2020-03-12 02:32:27","endLine":70,"groupId":"20004","id":1,"instanceNumber":1,"isCurCommit":1,"methodName":"LookupExtractorFactoryContainerProvider","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/22/8b17c4b67ee68675b7d58b30292c8cd76dfdb0.src","preCode":"      new LookupExtractorFactoryContainerProvider()\n      {\n        @Override\n        public Set<String> getAllLookupNames()\n        {\n          return ImmutableSet.of(LookupSegmentTest.LOOKUP_NAME);\n        }\n\n        @Override\n        public Optional<LookupExtractorFactoryContainer> get(final String lookupName)\n        {\n          if (LookupSegmentTest.LOOKUP_NAME.equals(lookupName)) {\n            return Optional.of(\n                new LookupExtractorFactoryContainer(\n                    \"v0\",\n                    LookupSegmentTest.LOOKUP_EXTRACTOR_FACTORY\n                )\n            );\n          } else {\n            return Optional.empty();\n          }\n        }\n      }\n","realPath":"server/src/test/java/org/apache/druid/segment/LookupSegmentWranglerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":48,"status":"NB"},{"authorDate":"2020-03-17 13:16:14","commitOrder":4,"curCode":"  public void setup() throws IOException\n  {\n    tmpDir = FileUtils.createTempDir();\n    ColumnConfig columnConfig = () -> columnCacheSizeBytes;\n    index = JoinTestHelper.createFactIndexBuilder(tmpDir, rows).buildMMappedIndex(columnConfig);\n\n    final String prefix = \"c.\";\n\n    baseSegment = new QueryableIndexSegment(index, SegmentId.dummy(\"join\"));\n\n    List<JoinableClause> joinableClausesLookupStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysis preAnalysisLookupStringKey = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n        joinableClausesLookupStringKey,\n        VirtualColumns.EMPTY,\n        null,\n        false,\n        false,\n        false,\n        0\n    );\n    hashJoinLookupStringKeySegment = new HashJoinSegment(\n        baseSegment,\n        joinableClausesLookupStringKey,\n        preAnalysisLookupStringKey\n    );\n\n    List<JoinableClause> joinableClausesLookupLongKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysis preAnalysisLookupLongKey = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n        joinableClausesLookupLongKey,\n        VirtualColumns.EMPTY,\n        null,\n        false,\n        false,\n        false,\n        0\n    );\n    hashJoinLookupLongKeySegment = new HashJoinSegment(\n        baseSegment,\n        joinableClausesLookupLongKey,\n        preAnalysisLookupLongKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%scountryIsoCode\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysis preAnalysisIndexedTableStringKey = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n        joinableClausesIndexedTableStringKey,\n        VirtualColumns.EMPTY,\n        null,\n        false,\n        false,\n        false,\n        0\n    );\n    hashJoinIndexedTableStringKeySegment = new HashJoinSegment(\n        baseSegment,\n        joinableClausesIndexedTableStringKey,\n        preAnalysisIndexedTableStringKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableLonggKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryNumber == \\\"%scountryNumber\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysis preAnalysisIndexedTableLongKey = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n        joinableClausesIndexedTableLonggKey,\n        VirtualColumns.EMPTY,\n        null,\n        false,\n        false,\n        false,\n        0\n    );\n    hashJoinIndexedTableLongKeySegment = new HashJoinSegment(\n        baseSegment,\n        joinableClausesIndexedTableLonggKey,\n        preAnalysisIndexedTableLongKey\n    );\n\n    final Map<String, String> countryCodeToNameMap = JoinTestHelper.createCountryIsoCodeToNameLookup().getMap();\n    final Map<String, String> countryNumberToNameMap = JoinTestHelper.createCountryNumberToNameLookup().getMap();\n\n    final ExprMacroTable exprMacroTable = new ExprMacroTable(\n        ImmutableList.of(\n            new LookupExprMacro(\n                new LookupExtractorFactoryContainerProvider()\n                {\n                  @Override\n                  public Set<String> getAllLookupNames()\n                  {\n                    return ImmutableSet.of(LOOKUP_COUNTRY_CODE_TO_NAME, LOOKUP_COUNTRY_NUMBER_TO_NAME);\n                  }\n\n                  @Override\n                  public Optional<LookupExtractorFactoryContainer> get(String lookupName)\n                  {\n                    if (LOOKUP_COUNTRY_CODE_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryCodeToNameMap, false)\n                          )\n                      );\n                    } else if (LOOKUP_COUNTRY_NUMBER_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryNumberToNameMap, false)\n                          )\n                      );\n                    } else {\n                      return Optional.empty();\n                    }\n                  }\n                }\n            )\n        )\n    );\n\n    lookupVirtualColumns = VirtualColumns.create(\n        ImmutableList.of(\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_CODE_TO_NAME,\n                \"lookup(countryIsoCode, '\" + LOOKUP_COUNTRY_CODE_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            ),\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_NUMBER_TO_NAME,\n                \"lookup(countryNumber, '\" + LOOKUP_COUNTRY_NUMBER_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            )\n        )\n    );\n  }\n","date":"2020-03-17 13:16:14","endLine":294,"groupId":"19027","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"setup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/90/98953fbe97a242800f1124bee9ca9ba154d552.src","preCode":"  public void setup() throws IOException\n  {\n    tmpDir = FileUtils.createTempDir();\n    ColumnConfig columnConfig = () -> columnCacheSizeBytes;\n    index = JoinTestHelper.createFactIndexBuilder(tmpDir, rows).buildMMappedIndex(columnConfig);\n\n    final String prefix = \"c.\";\n\n    baseSegment = new QueryableIndexSegment(index, SegmentId.dummy(\"join\"));\n\n    List<JoinableClause> joinableClausesLookupStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysis preAnalysisLookupStringKey = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n        joinableClausesLookupStringKey,\n        VirtualColumns.EMPTY,\n        null,\n        false,\n        false,\n        false,\n        0\n    );\n    hashJoinLookupStringKeySegment = new HashJoinSegment(\n        baseSegment,\n        joinableClausesLookupStringKey,\n        preAnalysisLookupStringKey\n    );\n\n    List<JoinableClause> joinableClausesLookupLongKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysis preAnalysisLookupLongKey = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n        joinableClausesLookupLongKey,\n        VirtualColumns.EMPTY,\n        null,\n        false,\n        false,\n        false,\n        0\n    );\n    hashJoinLookupLongKeySegment = new HashJoinSegment(\n        baseSegment,\n        joinableClausesLookupLongKey,\n        preAnalysisLookupLongKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%scountryIsoCode\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysis preAnalysisIndexedTableStringKey = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n        joinableClausesIndexedTableStringKey,\n        VirtualColumns.EMPTY,\n        null,\n        false,\n        false,\n        false,\n        0\n    );\n    hashJoinIndexedTableStringKeySegment = new HashJoinSegment(\n        baseSegment,\n        joinableClausesIndexedTableStringKey,\n        preAnalysisIndexedTableStringKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableLonggKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryNumber == \\\"%scountryNumber\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysis preAnalysisIndexedTableLongKey = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n        joinableClausesIndexedTableLonggKey,\n        VirtualColumns.EMPTY,\n        null,\n        false,\n        false,\n        false,\n        0\n    );\n    hashJoinIndexedTableLongKeySegment = new HashJoinSegment(\n        baseSegment,\n        joinableClausesIndexedTableLonggKey,\n        preAnalysisIndexedTableLongKey\n    );\n\n    final Map<String, String> countryCodeToNameMap = JoinTestHelper.createCountryIsoCodeToNameLookup().getMap();\n    final Map<String, String> countryNumberToNameMap = JoinTestHelper.createCountryNumberToNameLookup().getMap();\n\n    final ExprMacroTable exprMacroTable = new ExprMacroTable(\n        ImmutableList.of(\n            new LookupExprMacro(\n                new LookupExtractorFactoryContainerProvider()\n                {\n                  @Override\n                  public Set<String> getAllLookupNames()\n                  {\n                    return ImmutableSet.of(LOOKUP_COUNTRY_CODE_TO_NAME, LOOKUP_COUNTRY_NUMBER_TO_NAME);\n                  }\n\n                  @Override\n                  public Optional<LookupExtractorFactoryContainer> get(String lookupName)\n                  {\n                    if (LOOKUP_COUNTRY_CODE_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryCodeToNameMap, false)\n                          )\n                      );\n                    } else if (LOOKUP_COUNTRY_NUMBER_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryNumberToNameMap, false)\n                          )\n                      );\n                    } else {\n                      return Optional.empty();\n                    }\n                  }\n                }\n            )\n        )\n    );\n\n    lookupVirtualColumns = VirtualColumns.create(\n        ImmutableList.of(\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_CODE_TO_NAME,\n                \"lookup(countryIsoCode, '\" + LOOKUP_COUNTRY_CODE_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            ),\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_NUMBER_TO_NAME,\n                \"lookup(countryNumber, '\" + LOOKUP_COUNTRY_NUMBER_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            )\n        )\n    );\n  }\n","realPath":"benchmarks/src/test/java/org/apache/druid/benchmark/JoinAndLookupBenchmark.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":120,"status":"MB"}],"commitId":"b1847364b0816cfc3c2ac376cd888033a06fb93f","commitMessage":"@@@More efficient join filter rewrites (#9516)\n\n* More efficient join filter rewrites\n\n* Rebase\n\n* Remove unused functions\n\n* PR comments.  fix compile\n\n* Adjust comment\n\n* Allow filter rewrite when join condition has LHS expression\n\n* Fix inspections\n\n* Fix tests","date":"2020-03-17 13:16:14","modifiedFileCount":"24","status":"M","submitter":"Jonathan Wei"},{"authorTime":"2020-05-30 06:03:35","codes":[{"authorDate":"2020-03-12 02:32:27","commitOrder":5,"curCode":"      new LookupExtractorFactoryContainerProvider()\n      {\n        @Override\n        public Set<String> getAllLookupNames()\n        {\n          return ImmutableSet.of(LookupSegmentTest.LOOKUP_NAME);\n        }\n\n        @Override\n        public Optional<LookupExtractorFactoryContainer> get(final String lookupName)\n        {\n          if (LookupSegmentTest.LOOKUP_NAME.equals(lookupName)) {\n            return Optional.of(\n                new LookupExtractorFactoryContainer(\n                    \"v0\",\n                    LookupSegmentTest.LOOKUP_EXTRACTOR_FACTORY\n                )\n            );\n          } else {\n            return Optional.empty();\n          }\n        }\n      }\n","date":"2020-03-12 02:32:27","endLine":70,"groupId":"20004","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"LookupExtractorFactoryContainerProvider","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/22/8b17c4b67ee68675b7d58b30292c8cd76dfdb0.src","preCode":"      new LookupExtractorFactoryContainerProvider()\n      {\n        @Override\n        public Set<String> getAllLookupNames()\n        {\n          return ImmutableSet.of(LookupSegmentTest.LOOKUP_NAME);\n        }\n\n        @Override\n        public Optional<LookupExtractorFactoryContainer> get(final String lookupName)\n        {\n          if (LookupSegmentTest.LOOKUP_NAME.equals(lookupName)) {\n            return Optional.of(\n                new LookupExtractorFactoryContainer(\n                    \"v0\",\n                    LookupSegmentTest.LOOKUP_EXTRACTOR_FACTORY\n                )\n            );\n          } else {\n            return Optional.empty();\n          }\n        }\n      }\n","realPath":"server/src/test/java/org/apache/druid/segment/LookupSegmentWranglerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":48,"status":"N"},{"authorDate":"2020-05-30 06:03:35","commitOrder":5,"curCode":"  public void setup() throws IOException\n  {\n    tmpDir = FileUtils.createTempDir();\n    ColumnConfig columnConfig = () -> columnCacheSizeBytes;\n    index = JoinTestHelper.createFactIndexBuilder(tmpDir, rows).buildMMappedIndex(columnConfig);\n\n    final String prefix = \"c.\";\n\n    baseSegment = new QueryableIndexSegment(index, SegmentId.dummy(\"join\"));\n\n    List<JoinableClause> joinableClausesLookupStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysis preAnalysisLookupStringKey = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n        JoinableClauses.fromList(joinableClausesLookupStringKey),\n        VirtualColumns.EMPTY,\n        null,\n        false,\n        false,\n        false,\n        0\n    );\n    hashJoinLookupStringKeySegment = new HashJoinSegment(\n        baseSegment,\n        joinableClausesLookupStringKey,\n        preAnalysisLookupStringKey\n    );\n\n    List<JoinableClause> joinableClausesLookupLongKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysis preAnalysisLookupLongKey = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n        JoinableClauses.fromList(joinableClausesLookupLongKey),\n        VirtualColumns.EMPTY,\n        null,\n        false,\n        false,\n        false,\n        0\n    );\n    hashJoinLookupLongKeySegment = new HashJoinSegment(\n        baseSegment,\n        joinableClausesLookupLongKey,\n        preAnalysisLookupLongKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%scountryIsoCode\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysis preAnalysisIndexedTableStringKey = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n        JoinableClauses.fromList(joinableClausesIndexedTableStringKey),\n        VirtualColumns.EMPTY,\n        null,\n        false,\n        false,\n        false,\n        0\n    );\n    hashJoinIndexedTableStringKeySegment = new HashJoinSegment(\n        baseSegment,\n        joinableClausesIndexedTableStringKey,\n        preAnalysisIndexedTableStringKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableLonggKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryNumber == \\\"%scountryNumber\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysis preAnalysisIndexedTableLongKey = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n        JoinableClauses.fromList(joinableClausesIndexedTableLonggKey),\n        VirtualColumns.EMPTY,\n        null,\n        false,\n        false,\n        false,\n        0\n    );\n    hashJoinIndexedTableLongKeySegment = new HashJoinSegment(\n        baseSegment,\n        joinableClausesIndexedTableLonggKey,\n        preAnalysisIndexedTableLongKey\n    );\n\n    final Map<String, String> countryCodeToNameMap = JoinTestHelper.createCountryIsoCodeToNameLookup().getMap();\n    final Map<String, String> countryNumberToNameMap = JoinTestHelper.createCountryNumberToNameLookup().getMap();\n\n    final ExprMacroTable exprMacroTable = new ExprMacroTable(\n        ImmutableList.of(\n            new LookupExprMacro(\n                new LookupExtractorFactoryContainerProvider()\n                {\n                  @Override\n                  public Set<String> getAllLookupNames()\n                  {\n                    return ImmutableSet.of(LOOKUP_COUNTRY_CODE_TO_NAME, LOOKUP_COUNTRY_NUMBER_TO_NAME);\n                  }\n\n                  @Override\n                  public Optional<LookupExtractorFactoryContainer> get(String lookupName)\n                  {\n                    if (LOOKUP_COUNTRY_CODE_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryCodeToNameMap, false)\n                          )\n                      );\n                    } else if (LOOKUP_COUNTRY_NUMBER_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryNumberToNameMap, false)\n                          )\n                      );\n                    } else {\n                      return Optional.empty();\n                    }\n                  }\n                }\n            )\n        )\n    );\n\n    lookupVirtualColumns = VirtualColumns.create(\n        ImmutableList.of(\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_CODE_TO_NAME,\n                \"lookup(countryIsoCode, '\" + LOOKUP_COUNTRY_CODE_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            ),\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_NUMBER_TO_NAME,\n                \"lookup(countryNumber, '\" + LOOKUP_COUNTRY_NUMBER_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            )\n        )\n    );\n  }\n","date":"2020-05-30 06:03:35","endLine":295,"groupId":"19027","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"setup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/cb/630a2e400bff849fc6a3694440ae51d94c8021.src","preCode":"  public void setup() throws IOException\n  {\n    tmpDir = FileUtils.createTempDir();\n    ColumnConfig columnConfig = () -> columnCacheSizeBytes;\n    index = JoinTestHelper.createFactIndexBuilder(tmpDir, rows).buildMMappedIndex(columnConfig);\n\n    final String prefix = \"c.\";\n\n    baseSegment = new QueryableIndexSegment(index, SegmentId.dummy(\"join\"));\n\n    List<JoinableClause> joinableClausesLookupStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysis preAnalysisLookupStringKey = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n        joinableClausesLookupStringKey,\n        VirtualColumns.EMPTY,\n        null,\n        false,\n        false,\n        false,\n        0\n    );\n    hashJoinLookupStringKeySegment = new HashJoinSegment(\n        baseSegment,\n        joinableClausesLookupStringKey,\n        preAnalysisLookupStringKey\n    );\n\n    List<JoinableClause> joinableClausesLookupLongKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysis preAnalysisLookupLongKey = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n        joinableClausesLookupLongKey,\n        VirtualColumns.EMPTY,\n        null,\n        false,\n        false,\n        false,\n        0\n    );\n    hashJoinLookupLongKeySegment = new HashJoinSegment(\n        baseSegment,\n        joinableClausesLookupLongKey,\n        preAnalysisLookupLongKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%scountryIsoCode\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysis preAnalysisIndexedTableStringKey = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n        joinableClausesIndexedTableStringKey,\n        VirtualColumns.EMPTY,\n        null,\n        false,\n        false,\n        false,\n        0\n    );\n    hashJoinIndexedTableStringKeySegment = new HashJoinSegment(\n        baseSegment,\n        joinableClausesIndexedTableStringKey,\n        preAnalysisIndexedTableStringKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableLonggKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryNumber == \\\"%scountryNumber\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysis preAnalysisIndexedTableLongKey = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n        joinableClausesIndexedTableLonggKey,\n        VirtualColumns.EMPTY,\n        null,\n        false,\n        false,\n        false,\n        0\n    );\n    hashJoinIndexedTableLongKeySegment = new HashJoinSegment(\n        baseSegment,\n        joinableClausesIndexedTableLonggKey,\n        preAnalysisIndexedTableLongKey\n    );\n\n    final Map<String, String> countryCodeToNameMap = JoinTestHelper.createCountryIsoCodeToNameLookup().getMap();\n    final Map<String, String> countryNumberToNameMap = JoinTestHelper.createCountryNumberToNameLookup().getMap();\n\n    final ExprMacroTable exprMacroTable = new ExprMacroTable(\n        ImmutableList.of(\n            new LookupExprMacro(\n                new LookupExtractorFactoryContainerProvider()\n                {\n                  @Override\n                  public Set<String> getAllLookupNames()\n                  {\n                    return ImmutableSet.of(LOOKUP_COUNTRY_CODE_TO_NAME, LOOKUP_COUNTRY_NUMBER_TO_NAME);\n                  }\n\n                  @Override\n                  public Optional<LookupExtractorFactoryContainer> get(String lookupName)\n                  {\n                    if (LOOKUP_COUNTRY_CODE_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryCodeToNameMap, false)\n                          )\n                      );\n                    } else if (LOOKUP_COUNTRY_NUMBER_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryNumberToNameMap, false)\n                          )\n                      );\n                    } else {\n                      return Optional.empty();\n                    }\n                  }\n                }\n            )\n        )\n    );\n\n    lookupVirtualColumns = VirtualColumns.create(\n        ImmutableList.of(\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_CODE_TO_NAME,\n                \"lookup(countryIsoCode, '\" + LOOKUP_COUNTRY_CODE_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            ),\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_NUMBER_TO_NAME,\n                \"lookup(countryNumber, '\" + LOOKUP_COUNTRY_NUMBER_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            )\n        )\n    );\n  }\n","realPath":"benchmarks/src/test/java/org/apache/druid/benchmark/JoinAndLookupBenchmark.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":121,"status":"M"}],"commitId":"9c40bebc02dfd13e1bd58f2f45fd24424e4530a4","commitMessage":"@@@Refactor JoinFilterAnalyzer - part 2 (#9929)\n\n* Refactor JoinFilterAnalyzer\n\nThis patch attempts to make it easier to follow the join filter analysis code\nwith the hope of making it easier to add rewrite optimizations in the future.\n\nTo keep the patch small and easy to review.  this is the first of at least 2\npatches that are planned.\n\nThis patch adds a builder to the Pre-Analysis.  so that it is easier to\ninstantiate the preAnalysis. It also moves some of the filter normalization\ncode out to Fitlers with associated tests.\n\n* fix tests\n\n* Refactor JoinFilterAnalyzer - part 2\n\nThis change introduces the following components:\n * RhsRewriteCandidates - a wrapper for a list of candidates and associated\n     functions to operate on the set of candidates.\n * JoinableClauses - a wrapper for the list of JoinableClause that represent\n     a join condition and the associated functions to operate on the clauses.\n * Equiconditions - a wrapper representing the equiconditions that are used\n     in the join condition.\n\nAnd associated test changes.\n\nThis refactoring surfaced 2 bugs:\n - Missing equals and hashcode implementation for RhsRewriteCandidate.  thus\n   allowing potential duplicates in the rhs rewrite candidates\n - Missing Filter#supportsRequiredColumnRewrite check in\n   analyzeJoinFilterClause.  which could result in UnsupportedOperationException\n   being thrown by the filter\n\n* fix compile error\n\n* remove unused class","date":"2020-05-30 06:03:35","modifiedFileCount":"10","status":"M","submitter":"Suneet Saldanha"},{"authorTime":"2020-06-10 11:12:36","codes":[{"authorDate":"2020-03-12 02:32:27","commitOrder":6,"curCode":"      new LookupExtractorFactoryContainerProvider()\n      {\n        @Override\n        public Set<String> getAllLookupNames()\n        {\n          return ImmutableSet.of(LookupSegmentTest.LOOKUP_NAME);\n        }\n\n        @Override\n        public Optional<LookupExtractorFactoryContainer> get(final String lookupName)\n        {\n          if (LookupSegmentTest.LOOKUP_NAME.equals(lookupName)) {\n            return Optional.of(\n                new LookupExtractorFactoryContainer(\n                    \"v0\",\n                    LookupSegmentTest.LOOKUP_EXTRACTOR_FACTORY\n                )\n            );\n          } else {\n            return Optional.empty();\n          }\n        }\n      }\n","date":"2020-03-12 02:32:27","endLine":70,"groupId":"20004","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"LookupExtractorFactoryContainerProvider","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/22/8b17c4b67ee68675b7d58b30292c8cd76dfdb0.src","preCode":"      new LookupExtractorFactoryContainerProvider()\n      {\n        @Override\n        public Set<String> getAllLookupNames()\n        {\n          return ImmutableSet.of(LookupSegmentTest.LOOKUP_NAME);\n        }\n\n        @Override\n        public Optional<LookupExtractorFactoryContainer> get(final String lookupName)\n        {\n          if (LookupSegmentTest.LOOKUP_NAME.equals(lookupName)) {\n            return Optional.of(\n                new LookupExtractorFactoryContainer(\n                    \"v0\",\n                    LookupSegmentTest.LOOKUP_EXTRACTOR_FACTORY\n                )\n            );\n          } else {\n            return Optional.empty();\n          }\n        }\n      }\n","realPath":"server/src/test/java/org/apache/druid/segment/LookupSegmentWranglerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":48,"status":"N"},{"authorDate":"2020-06-10 11:12:36","commitOrder":6,"curCode":"  public void setup() throws IOException\n  {\n    tmpDir = FileUtils.createTempDir();\n    ColumnConfig columnConfig = () -> columnCacheSizeBytes;\n    index = JoinTestHelper.createFactIndexBuilder(tmpDir, rows).buildMMappedIndex(columnConfig);\n\n    final String prefix = \"c.\";\n\n    baseSegment = new QueryableIndexSegment(index, SegmentId.dummy(\"join\"));\n\n    List<JoinableClause> joinableClausesLookupStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysis preAnalysisLookupStringKey = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n        JoinableClauses.fromList(joinableClausesLookupStringKey),\n        VirtualColumns.EMPTY,\n        null,\n        false,\n        false,\n        false,\n        0\n    );\n    hashJoinLookupStringKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        joinableClausesLookupStringKey,\n        preAnalysisLookupStringKey\n    );\n\n    List<JoinableClause> joinableClausesLookupLongKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysis preAnalysisLookupLongKey = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n        JoinableClauses.fromList(joinableClausesLookupLongKey),\n        VirtualColumns.EMPTY,\n        null,\n        false,\n        false,\n        false,\n        0\n    );\n    hashJoinLookupLongKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        joinableClausesLookupLongKey,\n        preAnalysisLookupLongKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%scountryIsoCode\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysis preAnalysisIndexedTableStringKey = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n        JoinableClauses.fromList(joinableClausesIndexedTableStringKey),\n        VirtualColumns.EMPTY,\n        null,\n        false,\n        false,\n        false,\n        0\n    );\n    hashJoinIndexedTableStringKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        joinableClausesIndexedTableStringKey,\n        preAnalysisIndexedTableStringKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableLonggKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryNumber == \\\"%scountryNumber\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysis preAnalysisIndexedTableLongKey = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n        JoinableClauses.fromList(joinableClausesIndexedTableLonggKey),\n        VirtualColumns.EMPTY,\n        null,\n        false,\n        false,\n        false,\n        0\n    );\n    hashJoinIndexedTableLongKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        joinableClausesIndexedTableLonggKey,\n        preAnalysisIndexedTableLongKey\n    );\n\n    final Map<String, String> countryCodeToNameMap = JoinTestHelper.createCountryIsoCodeToNameLookup().getMap();\n    final Map<String, String> countryNumberToNameMap = JoinTestHelper.createCountryNumberToNameLookup().getMap();\n\n    final ExprMacroTable exprMacroTable = new ExprMacroTable(\n        ImmutableList.of(\n            new LookupExprMacro(\n                new LookupExtractorFactoryContainerProvider()\n                {\n                  @Override\n                  public Set<String> getAllLookupNames()\n                  {\n                    return ImmutableSet.of(LOOKUP_COUNTRY_CODE_TO_NAME, LOOKUP_COUNTRY_NUMBER_TO_NAME);\n                  }\n\n                  @Override\n                  public Optional<LookupExtractorFactoryContainer> get(String lookupName)\n                  {\n                    if (LOOKUP_COUNTRY_CODE_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryCodeToNameMap, false)\n                          )\n                      );\n                    } else if (LOOKUP_COUNTRY_NUMBER_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryNumberToNameMap, false)\n                          )\n                      );\n                    } else {\n                      return Optional.empty();\n                    }\n                  }\n                }\n            )\n        )\n    );\n\n    lookupVirtualColumns = VirtualColumns.create(\n        ImmutableList.of(\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_CODE_TO_NAME,\n                \"lookup(countryIsoCode, '\" + LOOKUP_COUNTRY_CODE_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            ),\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_NUMBER_TO_NAME,\n                \"lookup(countryNumber, '\" + LOOKUP_COUNTRY_NUMBER_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            )\n        )\n    );\n  }\n","date":"2020-06-10 11:12:36","endLine":296,"groupId":"0","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"setup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/56/7a34842c901c2f968d471dd0e79b06a715b728.src","preCode":"  public void setup() throws IOException\n  {\n    tmpDir = FileUtils.createTempDir();\n    ColumnConfig columnConfig = () -> columnCacheSizeBytes;\n    index = JoinTestHelper.createFactIndexBuilder(tmpDir, rows).buildMMappedIndex(columnConfig);\n\n    final String prefix = \"c.\";\n\n    baseSegment = new QueryableIndexSegment(index, SegmentId.dummy(\"join\"));\n\n    List<JoinableClause> joinableClausesLookupStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysis preAnalysisLookupStringKey = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n        JoinableClauses.fromList(joinableClausesLookupStringKey),\n        VirtualColumns.EMPTY,\n        null,\n        false,\n        false,\n        false,\n        0\n    );\n    hashJoinLookupStringKeySegment = new HashJoinSegment(\n        baseSegment,\n        joinableClausesLookupStringKey,\n        preAnalysisLookupStringKey\n    );\n\n    List<JoinableClause> joinableClausesLookupLongKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysis preAnalysisLookupLongKey = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n        JoinableClauses.fromList(joinableClausesLookupLongKey),\n        VirtualColumns.EMPTY,\n        null,\n        false,\n        false,\n        false,\n        0\n    );\n    hashJoinLookupLongKeySegment = new HashJoinSegment(\n        baseSegment,\n        joinableClausesLookupLongKey,\n        preAnalysisLookupLongKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%scountryIsoCode\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysis preAnalysisIndexedTableStringKey = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n        JoinableClauses.fromList(joinableClausesIndexedTableStringKey),\n        VirtualColumns.EMPTY,\n        null,\n        false,\n        false,\n        false,\n        0\n    );\n    hashJoinIndexedTableStringKeySegment = new HashJoinSegment(\n        baseSegment,\n        joinableClausesIndexedTableStringKey,\n        preAnalysisIndexedTableStringKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableLonggKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryNumber == \\\"%scountryNumber\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysis preAnalysisIndexedTableLongKey = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n        JoinableClauses.fromList(joinableClausesIndexedTableLonggKey),\n        VirtualColumns.EMPTY,\n        null,\n        false,\n        false,\n        false,\n        0\n    );\n    hashJoinIndexedTableLongKeySegment = new HashJoinSegment(\n        baseSegment,\n        joinableClausesIndexedTableLonggKey,\n        preAnalysisIndexedTableLongKey\n    );\n\n    final Map<String, String> countryCodeToNameMap = JoinTestHelper.createCountryIsoCodeToNameLookup().getMap();\n    final Map<String, String> countryNumberToNameMap = JoinTestHelper.createCountryNumberToNameLookup().getMap();\n\n    final ExprMacroTable exprMacroTable = new ExprMacroTable(\n        ImmutableList.of(\n            new LookupExprMacro(\n                new LookupExtractorFactoryContainerProvider()\n                {\n                  @Override\n                  public Set<String> getAllLookupNames()\n                  {\n                    return ImmutableSet.of(LOOKUP_COUNTRY_CODE_TO_NAME, LOOKUP_COUNTRY_NUMBER_TO_NAME);\n                  }\n\n                  @Override\n                  public Optional<LookupExtractorFactoryContainer> get(String lookupName)\n                  {\n                    if (LOOKUP_COUNTRY_CODE_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryCodeToNameMap, false)\n                          )\n                      );\n                    } else if (LOOKUP_COUNTRY_NUMBER_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryNumberToNameMap, false)\n                          )\n                      );\n                    } else {\n                      return Optional.empty();\n                    }\n                  }\n                }\n            )\n        )\n    );\n\n    lookupVirtualColumns = VirtualColumns.create(\n        ImmutableList.of(\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_CODE_TO_NAME,\n                \"lookup(countryIsoCode, '\" + LOOKUP_COUNTRY_CODE_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            ),\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_NUMBER_TO_NAME,\n                \"lookup(countryNumber, '\" + LOOKUP_COUNTRY_NUMBER_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            )\n        )\n    );\n  }\n","realPath":"benchmarks/src/test/java/org/apache/druid/benchmark/JoinAndLookupBenchmark.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":122,"status":"M"}],"commitId":"f8b643ec720bf34acf84fda01a3d876f98e81bb9","commitMessage":"@@@make joinables closeable (#9982)\n\n* make joinables closeable\n\n* tests and adjustments\n\n* refactor to make join stuffs impelement ReferenceCountedObject instead of Closable.  more tests\n\n* fixes\n\n* javadocs and stuff\n\n* fix bugs\n\n* more test\n\n* fix lgtm alert\n\n* simplify\n\n* fixup javadoc\n\n* review stuffs\n\n* safeguard against exceptions\n\n* i hate this checkstyle rule\n\n* make IndexedTable extend Closeable","date":"2020-06-10 11:12:36","modifiedFileCount":"37","status":"M","submitter":"Clint Wylie"},{"authorTime":"2020-06-19 12:32:29","codes":[{"authorDate":"2020-03-12 02:32:27","commitOrder":7,"curCode":"      new LookupExtractorFactoryContainerProvider()\n      {\n        @Override\n        public Set<String> getAllLookupNames()\n        {\n          return ImmutableSet.of(LookupSegmentTest.LOOKUP_NAME);\n        }\n\n        @Override\n        public Optional<LookupExtractorFactoryContainer> get(final String lookupName)\n        {\n          if (LookupSegmentTest.LOOKUP_NAME.equals(lookupName)) {\n            return Optional.of(\n                new LookupExtractorFactoryContainer(\n                    \"v0\",\n                    LookupSegmentTest.LOOKUP_EXTRACTOR_FACTORY\n                )\n            );\n          } else {\n            return Optional.empty();\n          }\n        }\n      }\n","date":"2020-03-12 02:32:27","endLine":70,"groupId":"20004","id":7,"instanceNumber":1,"isCurCommit":1,"methodName":"LookupExtractorFactoryContainerProvider","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/22/8b17c4b67ee68675b7d58b30292c8cd76dfdb0.src","preCode":"      new LookupExtractorFactoryContainerProvider()\n      {\n        @Override\n        public Set<String> getAllLookupNames()\n        {\n          return ImmutableSet.of(LookupSegmentTest.LOOKUP_NAME);\n        }\n\n        @Override\n        public Optional<LookupExtractorFactoryContainer> get(final String lookupName)\n        {\n          if (LookupSegmentTest.LOOKUP_NAME.equals(lookupName)) {\n            return Optional.of(\n                new LookupExtractorFactoryContainer(\n                    \"v0\",\n                    LookupSegmentTest.LOOKUP_EXTRACTOR_FACTORY\n                )\n            );\n          } else {\n            return Optional.empty();\n          }\n        }\n      }\n","realPath":"server/src/test/java/org/apache/druid/segment/LookupSegmentWranglerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":48,"status":"N"},{"authorDate":"2020-06-19 12:32:29","commitOrder":7,"curCode":"  public void setup() throws IOException\n  {\n    tmpDir = FileUtils.createTempDir();\n    ColumnConfig columnConfig = () -> columnCacheSizeBytes;\n    index = JoinTestHelper.createFactIndexBuilder(tmpDir, rows).buildMMappedIndex(columnConfig);\n\n    final String prefix = \"c.\";\n\n    baseSegment = new QueryableIndexSegment(index, SegmentId.dummy(\"join\"));\n\n    List<JoinableClause> joinableClausesLookupStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysisGroup preAnalysisGroupLookupStringKey = new JoinFilterPreAnalysisGroup(\n        new JoinFilterRewriteConfig(\n            false,\n            false,\n            false,\n            0\n        ),\n        true\n    );\n\n    hashJoinLookupStringKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        joinableClausesLookupStringKey,\n        preAnalysisGroupLookupStringKey\n    );\n\n    List<JoinableClause> joinableClausesLookupLongKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysisGroup preAnalysisGroupLookupLongKey = new JoinFilterPreAnalysisGroup(\n        new JoinFilterRewriteConfig(\n            false,\n            false,\n            false,\n            0\n        ),\n        true\n    );\n    hashJoinLookupLongKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        joinableClausesLookupLongKey,\n        preAnalysisGroupLookupLongKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%scountryIsoCode\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysisGroup preAnalysisGroupIndexedStringKey = new JoinFilterPreAnalysisGroup(\n        new JoinFilterRewriteConfig(\n            false,\n            false,\n            false,\n            0\n        ),\n        true\n    );\n    hashJoinIndexedTableStringKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        joinableClausesIndexedTableStringKey,\n        preAnalysisGroupIndexedStringKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableLonggKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryNumber == \\\"%scountryNumber\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysisGroup preAnalysisGroupIndexedLongKey = new JoinFilterPreAnalysisGroup(\n        new JoinFilterRewriteConfig(\n            false,\n            false,\n            false,\n            0\n        ),\n        true\n    );\n    hashJoinIndexedTableLongKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        joinableClausesIndexedTableLonggKey,\n        preAnalysisGroupIndexedLongKey\n    );\n\n    final Map<String, String> countryCodeToNameMap = JoinTestHelper.createCountryIsoCodeToNameLookup().getMap();\n    final Map<String, String> countryNumberToNameMap = JoinTestHelper.createCountryNumberToNameLookup().getMap();\n\n    final ExprMacroTable exprMacroTable = new ExprMacroTable(\n        ImmutableList.of(\n            new LookupExprMacro(\n                new LookupExtractorFactoryContainerProvider()\n                {\n                  @Override\n                  public Set<String> getAllLookupNames()\n                  {\n                    return ImmutableSet.of(LOOKUP_COUNTRY_CODE_TO_NAME, LOOKUP_COUNTRY_NUMBER_TO_NAME);\n                  }\n\n                  @Override\n                  public Optional<LookupExtractorFactoryContainer> get(String lookupName)\n                  {\n                    if (LOOKUP_COUNTRY_CODE_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryCodeToNameMap, false)\n                          )\n                      );\n                    } else if (LOOKUP_COUNTRY_NUMBER_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryNumberToNameMap, false)\n                          )\n                      );\n                    } else {\n                      return Optional.empty();\n                    }\n                  }\n                }\n            )\n        )\n    );\n\n    lookupVirtualColumns = VirtualColumns.create(\n        ImmutableList.of(\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_CODE_TO_NAME,\n                \"lookup(countryIsoCode, '\" + LOOKUP_COUNTRY_CODE_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            ),\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_NUMBER_TO_NAME,\n                \"lookup(countryNumber, '\" + LOOKUP_COUNTRY_NUMBER_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            )\n        )\n    );\n  }\n","date":"2020-06-19 12:32:29","endLine":298,"groupId":"0","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"setup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/13/2a3215927b549fbbd134e1ab5b2e8c80f0f80b.src","preCode":"  public void setup() throws IOException\n  {\n    tmpDir = FileUtils.createTempDir();\n    ColumnConfig columnConfig = () -> columnCacheSizeBytes;\n    index = JoinTestHelper.createFactIndexBuilder(tmpDir, rows).buildMMappedIndex(columnConfig);\n\n    final String prefix = \"c.\";\n\n    baseSegment = new QueryableIndexSegment(index, SegmentId.dummy(\"join\"));\n\n    List<JoinableClause> joinableClausesLookupStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysis preAnalysisLookupStringKey = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n        JoinableClauses.fromList(joinableClausesLookupStringKey),\n        VirtualColumns.EMPTY,\n        null,\n        false,\n        false,\n        false,\n        0\n    );\n    hashJoinLookupStringKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        joinableClausesLookupStringKey,\n        preAnalysisLookupStringKey\n    );\n\n    List<JoinableClause> joinableClausesLookupLongKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysis preAnalysisLookupLongKey = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n        JoinableClauses.fromList(joinableClausesLookupLongKey),\n        VirtualColumns.EMPTY,\n        null,\n        false,\n        false,\n        false,\n        0\n    );\n    hashJoinLookupLongKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        joinableClausesLookupLongKey,\n        preAnalysisLookupLongKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%scountryIsoCode\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysis preAnalysisIndexedTableStringKey = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n        JoinableClauses.fromList(joinableClausesIndexedTableStringKey),\n        VirtualColumns.EMPTY,\n        null,\n        false,\n        false,\n        false,\n        0\n    );\n    hashJoinIndexedTableStringKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        joinableClausesIndexedTableStringKey,\n        preAnalysisIndexedTableStringKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableLonggKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryNumber == \\\"%scountryNumber\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysis preAnalysisIndexedTableLongKey = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n        JoinableClauses.fromList(joinableClausesIndexedTableLonggKey),\n        VirtualColumns.EMPTY,\n        null,\n        false,\n        false,\n        false,\n        0\n    );\n    hashJoinIndexedTableLongKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        joinableClausesIndexedTableLonggKey,\n        preAnalysisIndexedTableLongKey\n    );\n\n    final Map<String, String> countryCodeToNameMap = JoinTestHelper.createCountryIsoCodeToNameLookup().getMap();\n    final Map<String, String> countryNumberToNameMap = JoinTestHelper.createCountryNumberToNameLookup().getMap();\n\n    final ExprMacroTable exprMacroTable = new ExprMacroTable(\n        ImmutableList.of(\n            new LookupExprMacro(\n                new LookupExtractorFactoryContainerProvider()\n                {\n                  @Override\n                  public Set<String> getAllLookupNames()\n                  {\n                    return ImmutableSet.of(LOOKUP_COUNTRY_CODE_TO_NAME, LOOKUP_COUNTRY_NUMBER_TO_NAME);\n                  }\n\n                  @Override\n                  public Optional<LookupExtractorFactoryContainer> get(String lookupName)\n                  {\n                    if (LOOKUP_COUNTRY_CODE_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryCodeToNameMap, false)\n                          )\n                      );\n                    } else if (LOOKUP_COUNTRY_NUMBER_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryNumberToNameMap, false)\n                          )\n                      );\n                    } else {\n                      return Optional.empty();\n                    }\n                  }\n                }\n            )\n        )\n    );\n\n    lookupVirtualColumns = VirtualColumns.create(\n        ImmutableList.of(\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_CODE_TO_NAME,\n                \"lookup(countryIsoCode, '\" + LOOKUP_COUNTRY_CODE_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            ),\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_NUMBER_TO_NAME,\n                \"lookup(countryNumber, '\" + LOOKUP_COUNTRY_NUMBER_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            )\n        )\n    );\n  }\n","realPath":"benchmarks/src/test/java/org/apache/druid/benchmark/JoinAndLookupBenchmark.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":121,"status":"M"}],"commitId":"37e150c0755c0efba609601b1122cd6bc8a271fb","commitMessage":"@@@Fix join filter rewrites with nested queries (#10015)\n\n* Fix join filter rewrites with nested queries\n\n* Fix test.  inspection.  coverage\n\n* Remove clauses from group key\n\n* Fix import order\n\nCo-authored-by: Gian Merlino <gianmerlino@gmail.com>","date":"2020-06-19 12:32:29","modifiedFileCount":"20","status":"M","submitter":"Jonathan Wei"},{"authorTime":"2020-07-01 10:14:22","codes":[{"authorDate":"2020-03-12 02:32:27","commitOrder":8,"curCode":"      new LookupExtractorFactoryContainerProvider()\n      {\n        @Override\n        public Set<String> getAllLookupNames()\n        {\n          return ImmutableSet.of(LookupSegmentTest.LOOKUP_NAME);\n        }\n\n        @Override\n        public Optional<LookupExtractorFactoryContainer> get(final String lookupName)\n        {\n          if (LookupSegmentTest.LOOKUP_NAME.equals(lookupName)) {\n            return Optional.of(\n                new LookupExtractorFactoryContainer(\n                    \"v0\",\n                    LookupSegmentTest.LOOKUP_EXTRACTOR_FACTORY\n                )\n            );\n          } else {\n            return Optional.empty();\n          }\n        }\n      }\n","date":"2020-03-12 02:32:27","endLine":70,"groupId":"20004","id":9,"instanceNumber":1,"isCurCommit":1,"methodName":"LookupExtractorFactoryContainerProvider","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/22/8b17c4b67ee68675b7d58b30292c8cd76dfdb0.src","preCode":"      new LookupExtractorFactoryContainerProvider()\n      {\n        @Override\n        public Set<String> getAllLookupNames()\n        {\n          return ImmutableSet.of(LookupSegmentTest.LOOKUP_NAME);\n        }\n\n        @Override\n        public Optional<LookupExtractorFactoryContainer> get(final String lookupName)\n        {\n          if (LookupSegmentTest.LOOKUP_NAME.equals(lookupName)) {\n            return Optional.of(\n                new LookupExtractorFactoryContainer(\n                    \"v0\",\n                    LookupSegmentTest.LOOKUP_EXTRACTOR_FACTORY\n                )\n            );\n          } else {\n            return Optional.empty();\n          }\n        }\n      }\n","realPath":"server/src/test/java/org/apache/druid/segment/LookupSegmentWranglerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":48,"status":"N"},{"authorDate":"2020-07-01 10:14:22","commitOrder":8,"curCode":"  public void setup() throws IOException\n  {\n    tmpDir = FileUtils.createTempDir();\n    ColumnConfig columnConfig = () -> columnCacheSizeBytes;\n    index = JoinTestHelper.createFactIndexBuilder(tmpDir, rows).buildMMappedIndex(columnConfig);\n\n    final String prefix = \"c.\";\n\n    baseSegment = new QueryableIndexSegment(index, SegmentId.dummy(\"join\"));\n\n    List<JoinableClause> joinableClausesLookupStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysis preAnalysisLookupStringKey =\n        JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n            new JoinFilterPreAnalysisKey(\n                new JoinFilterRewriteConfig(\n                    false,\n                    false,\n                    false,\n                    0\n                ),\n                joinableClausesLookupStringKey,\n                VirtualColumns.EMPTY,\n                null\n            )\n        );\n\n    hashJoinLookupStringKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        joinableClausesLookupStringKey,\n        preAnalysisLookupStringKey\n    );\n\n    List<JoinableClause> joinableClausesLookupLongKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysis preAnalysisLookupLongKey =\n        JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n            new JoinFilterPreAnalysisKey(\n                new JoinFilterRewriteConfig(\n                    false,\n                    false,\n                    false,\n                    0\n                ),\n                joinableClausesLookupLongKey,\n                VirtualColumns.EMPTY,\n                null\n            )\n        );\n\n    hashJoinLookupLongKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        joinableClausesLookupLongKey,\n        preAnalysisLookupLongKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%scountryIsoCode\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysis preAnalysisIndexedStringKey =\n        JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n            new JoinFilterPreAnalysisKey(\n                new JoinFilterRewriteConfig(\n                    false,\n                    false,\n                    false,\n                    0\n                ),\n                joinableClausesLookupLongKey,\n                VirtualColumns.EMPTY,\n                null\n            )\n        );\n\n    hashJoinIndexedTableStringKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        joinableClausesIndexedTableStringKey,\n        preAnalysisIndexedStringKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableLongKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryNumber == \\\"%scountryNumber\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysis preAnalysisIndexedLongKey =\n        JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n            new JoinFilterPreAnalysisKey(\n                new JoinFilterRewriteConfig(\n                    false,\n                    false,\n                    false,\n                    0\n                ),\n                joinableClausesIndexedTableLongKey,\n                VirtualColumns.EMPTY,\n                null\n            )\n        );\n\n    hashJoinIndexedTableLongKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        joinableClausesIndexedTableLongKey,\n        preAnalysisIndexedLongKey\n    );\n\n    final Map<String, String> countryCodeToNameMap = JoinTestHelper.createCountryIsoCodeToNameLookup().getMap();\n    final Map<String, String> countryNumberToNameMap = JoinTestHelper.createCountryNumberToNameLookup().getMap();\n\n    final ExprMacroTable exprMacroTable = new ExprMacroTable(\n        ImmutableList.of(\n            new LookupExprMacro(\n                new LookupExtractorFactoryContainerProvider()\n                {\n                  @Override\n                  public Set<String> getAllLookupNames()\n                  {\n                    return ImmutableSet.of(LOOKUP_COUNTRY_CODE_TO_NAME, LOOKUP_COUNTRY_NUMBER_TO_NAME);\n                  }\n\n                  @Override\n                  public Optional<LookupExtractorFactoryContainer> get(String lookupName)\n                  {\n                    if (LOOKUP_COUNTRY_CODE_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryCodeToNameMap, false)\n                          )\n                      );\n                    } else if (LOOKUP_COUNTRY_NUMBER_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryNumberToNameMap, false)\n                          )\n                      );\n                    } else {\n                      return Optional.empty();\n                    }\n                  }\n                }\n            )\n        )\n    );\n\n    lookupVirtualColumns = VirtualColumns.create(\n        ImmutableList.of(\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_CODE_TO_NAME,\n                \"lookup(countryIsoCode, '\" + LOOKUP_COUNTRY_CODE_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            ),\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_NUMBER_TO_NAME,\n                \"lookup(countryNumber, '\" + LOOKUP_COUNTRY_NUMBER_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            )\n        )\n    );\n  }\n","date":"2020-07-01 10:14:22","endLine":325,"groupId":"0","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"setup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/72/b92ff711fc28abf909b9ae366787ae6a1ddca3.src","preCode":"  public void setup() throws IOException\n  {\n    tmpDir = FileUtils.createTempDir();\n    ColumnConfig columnConfig = () -> columnCacheSizeBytes;\n    index = JoinTestHelper.createFactIndexBuilder(tmpDir, rows).buildMMappedIndex(columnConfig);\n\n    final String prefix = \"c.\";\n\n    baseSegment = new QueryableIndexSegment(index, SegmentId.dummy(\"join\"));\n\n    List<JoinableClause> joinableClausesLookupStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysisGroup preAnalysisGroupLookupStringKey = new JoinFilterPreAnalysisGroup(\n        new JoinFilterRewriteConfig(\n            false,\n            false,\n            false,\n            0\n        ),\n        true\n    );\n\n    hashJoinLookupStringKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        joinableClausesLookupStringKey,\n        preAnalysisGroupLookupStringKey\n    );\n\n    List<JoinableClause> joinableClausesLookupLongKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysisGroup preAnalysisGroupLookupLongKey = new JoinFilterPreAnalysisGroup(\n        new JoinFilterRewriteConfig(\n            false,\n            false,\n            false,\n            0\n        ),\n        true\n    );\n    hashJoinLookupLongKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        joinableClausesLookupLongKey,\n        preAnalysisGroupLookupLongKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%scountryIsoCode\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysisGroup preAnalysisGroupIndexedStringKey = new JoinFilterPreAnalysisGroup(\n        new JoinFilterRewriteConfig(\n            false,\n            false,\n            false,\n            0\n        ),\n        true\n    );\n    hashJoinIndexedTableStringKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        joinableClausesIndexedTableStringKey,\n        preAnalysisGroupIndexedStringKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableLonggKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryNumber == \\\"%scountryNumber\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n    JoinFilterPreAnalysisGroup preAnalysisGroupIndexedLongKey = new JoinFilterPreAnalysisGroup(\n        new JoinFilterRewriteConfig(\n            false,\n            false,\n            false,\n            0\n        ),\n        true\n    );\n    hashJoinIndexedTableLongKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        joinableClausesIndexedTableLonggKey,\n        preAnalysisGroupIndexedLongKey\n    );\n\n    final Map<String, String> countryCodeToNameMap = JoinTestHelper.createCountryIsoCodeToNameLookup().getMap();\n    final Map<String, String> countryNumberToNameMap = JoinTestHelper.createCountryNumberToNameLookup().getMap();\n\n    final ExprMacroTable exprMacroTable = new ExprMacroTable(\n        ImmutableList.of(\n            new LookupExprMacro(\n                new LookupExtractorFactoryContainerProvider()\n                {\n                  @Override\n                  public Set<String> getAllLookupNames()\n                  {\n                    return ImmutableSet.of(LOOKUP_COUNTRY_CODE_TO_NAME, LOOKUP_COUNTRY_NUMBER_TO_NAME);\n                  }\n\n                  @Override\n                  public Optional<LookupExtractorFactoryContainer> get(String lookupName)\n                  {\n                    if (LOOKUP_COUNTRY_CODE_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryCodeToNameMap, false)\n                          )\n                      );\n                    } else if (LOOKUP_COUNTRY_NUMBER_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryNumberToNameMap, false)\n                          )\n                      );\n                    } else {\n                      return Optional.empty();\n                    }\n                  }\n                }\n            )\n        )\n    );\n\n    lookupVirtualColumns = VirtualColumns.create(\n        ImmutableList.of(\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_CODE_TO_NAME,\n                \"lookup(countryIsoCode, '\" + LOOKUP_COUNTRY_CODE_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            ),\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_NUMBER_TO_NAME,\n                \"lookup(countryNumber, '\" + LOOKUP_COUNTRY_NUMBER_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            )\n        )\n    );\n  }\n","realPath":"benchmarks/src/test/java/org/apache/druid/benchmark/JoinAndLookupBenchmark.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":123,"status":"M"}],"commitId":"5faa897a342096b2ac88587ad62e6e15022b01dd","commitMessage":"@@@Join filter pre-analysis simplifications and sanity checks. (#10104)\n\n* Join filter pre-analysis simplifications and sanity checks.\n\n- At pre-analysis time.  only compute pre-analysis for the innermost\n  root query.  since this is the one that will run on the join that involves\n  the base datasource. Previously.  pre-analyses were computed for multiple\n  levels of the query.  some of which were unnecessary.\n- Remove JoinFilterPreAnalysisGroup and join query level gathering code. \n  since they existed to support precomputation of multiple pre-analyses.\n- Embed JoinFilterPreAnalysisKey into JoinFilterPreAnalysis and use it to\n  sanity check?at processing time that the correct pre-analysis was done.\n\nTangentially related changes:\n\n- Remove prioritizeAndLaneQuery functionality from LocalQuerySegmentWalker.\n  The computed priority and lanes were not being used.\n- Add \"getBaseQuery\" method to DataSourceAnalysis to support identification\n  of the proper subquery for filter pre-analysis.\n\n* Fix compilation errors.\n\n* Adjust tests.","date":"2020-07-01 10:14:22","modifiedFileCount":"20","status":"M","submitter":"Gian Merlino"},{"authorTime":"2021-03-05 02:39:21","codes":[{"authorDate":"2020-03-12 02:32:27","commitOrder":9,"curCode":"      new LookupExtractorFactoryContainerProvider()\n      {\n        @Override\n        public Set<String> getAllLookupNames()\n        {\n          return ImmutableSet.of(LookupSegmentTest.LOOKUP_NAME);\n        }\n\n        @Override\n        public Optional<LookupExtractorFactoryContainer> get(final String lookupName)\n        {\n          if (LookupSegmentTest.LOOKUP_NAME.equals(lookupName)) {\n            return Optional.of(\n                new LookupExtractorFactoryContainer(\n                    \"v0\",\n                    LookupSegmentTest.LOOKUP_EXTRACTOR_FACTORY\n                )\n            );\n          } else {\n            return Optional.empty();\n          }\n        }\n      }\n","date":"2020-03-12 02:32:27","endLine":70,"groupId":"20004","id":11,"instanceNumber":1,"isCurCommit":1,"methodName":"LookupExtractorFactoryContainerProvider","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/22/8b17c4b67ee68675b7d58b30292c8cd76dfdb0.src","preCode":"      new LookupExtractorFactoryContainerProvider()\n      {\n        @Override\n        public Set<String> getAllLookupNames()\n        {\n          return ImmutableSet.of(LookupSegmentTest.LOOKUP_NAME);\n        }\n\n        @Override\n        public Optional<LookupExtractorFactoryContainer> get(final String lookupName)\n        {\n          if (LookupSegmentTest.LOOKUP_NAME.equals(lookupName)) {\n            return Optional.of(\n                new LookupExtractorFactoryContainer(\n                    \"v0\",\n                    LookupSegmentTest.LOOKUP_EXTRACTOR_FACTORY\n                )\n            );\n          } else {\n            return Optional.empty();\n          }\n        }\n      }\n","realPath":"server/src/test/java/org/apache/druid/segment/LookupSegmentWranglerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":48,"status":"N"},{"authorDate":"2021-03-05 02:39:21","commitOrder":9,"curCode":"  public void setup() throws IOException\n  {\n    tmpDir = FileUtils.createTempDir();\n    ColumnConfig columnConfig = () -> columnCacheSizeBytes;\n    index = JoinTestHelper.createFactIndexBuilder(tmpDir, rows).buildMMappedIndex(columnConfig);\n\n    final String prefix = \"c.\";\n\n    baseSegment = new QueryableIndexSegment(index, SegmentId.dummy(\"join\"));\n\n    List<JoinableClause> joinableClausesLookupStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysis preAnalysisLookupStringKey =\n        JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n            new JoinFilterPreAnalysisKey(\n                new JoinFilterRewriteConfig(\n                    false,\n                    false,\n                    false,\n                    0\n                ),\n                joinableClausesLookupStringKey,\n                VirtualColumns.EMPTY,\n                null\n            )\n        );\n\n    hashJoinLookupStringKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        null,\n        joinableClausesLookupStringKey,\n        preAnalysisLookupStringKey\n    );\n\n    List<JoinableClause> joinableClausesLookupLongKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysis preAnalysisLookupLongKey =\n        JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n            new JoinFilterPreAnalysisKey(\n                new JoinFilterRewriteConfig(\n                    false,\n                    false,\n                    false,\n                    0\n                ),\n                joinableClausesLookupLongKey,\n                VirtualColumns.EMPTY,\n                null\n            )\n        );\n\n    hashJoinLookupLongKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        null,\n        joinableClausesLookupLongKey,\n        preAnalysisLookupLongKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%scountryIsoCode\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysis preAnalysisIndexedStringKey =\n        JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n            new JoinFilterPreAnalysisKey(\n                new JoinFilterRewriteConfig(\n                    false,\n                    false,\n                    false,\n                    0\n                ),\n                joinableClausesLookupLongKey,\n                VirtualColumns.EMPTY,\n                null\n            )\n        );\n\n    hashJoinIndexedTableStringKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        null,\n        joinableClausesIndexedTableStringKey,\n        preAnalysisIndexedStringKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableLongKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryNumber == \\\"%scountryNumber\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysis preAnalysisIndexedLongKey =\n        JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n            new JoinFilterPreAnalysisKey(\n                new JoinFilterRewriteConfig(\n                    false,\n                    false,\n                    false,\n                    0\n                ),\n                joinableClausesIndexedTableLongKey,\n                VirtualColumns.EMPTY,\n                null\n            )\n        );\n\n    hashJoinIndexedTableLongKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        null,\n        joinableClausesIndexedTableLongKey,\n        preAnalysisIndexedLongKey\n    );\n\n    final Map<String, String> countryCodeToNameMap = JoinTestHelper.createCountryIsoCodeToNameLookup().getMap();\n    final Map<String, String> countryNumberToNameMap = JoinTestHelper.createCountryNumberToNameLookup().getMap();\n\n    final ExprMacroTable exprMacroTable = new ExprMacroTable(\n        ImmutableList.of(\n            new LookupExprMacro(\n                new LookupExtractorFactoryContainerProvider()\n                {\n                  @Override\n                  public Set<String> getAllLookupNames()\n                  {\n                    return ImmutableSet.of(LOOKUP_COUNTRY_CODE_TO_NAME, LOOKUP_COUNTRY_NUMBER_TO_NAME);\n                  }\n\n                  @Override\n                  public Optional<LookupExtractorFactoryContainer> get(String lookupName)\n                  {\n                    if (LOOKUP_COUNTRY_CODE_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryCodeToNameMap, false)\n                          )\n                      );\n                    } else if (LOOKUP_COUNTRY_NUMBER_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryNumberToNameMap, false)\n                          )\n                      );\n                    } else {\n                      return Optional.empty();\n                    }\n                  }\n                }\n            )\n        )\n    );\n\n    lookupVirtualColumns = VirtualColumns.create(\n        ImmutableList.of(\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_CODE_TO_NAME,\n                \"lookup(countryIsoCode, '\" + LOOKUP_COUNTRY_CODE_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            ),\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_NUMBER_TO_NAME,\n                \"lookup(countryNumber, '\" + LOOKUP_COUNTRY_NUMBER_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            )\n        )\n    );\n  }\n","date":"2021-03-05 02:39:21","endLine":329,"groupId":"14184","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"setup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/8d/68e6b79c5f4013e3e38deab6fad60892ce6d20.src","preCode":"  public void setup() throws IOException\n  {\n    tmpDir = FileUtils.createTempDir();\n    ColumnConfig columnConfig = () -> columnCacheSizeBytes;\n    index = JoinTestHelper.createFactIndexBuilder(tmpDir, rows).buildMMappedIndex(columnConfig);\n\n    final String prefix = \"c.\";\n\n    baseSegment = new QueryableIndexSegment(index, SegmentId.dummy(\"join\"));\n\n    List<JoinableClause> joinableClausesLookupStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysis preAnalysisLookupStringKey =\n        JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n            new JoinFilterPreAnalysisKey(\n                new JoinFilterRewriteConfig(\n                    false,\n                    false,\n                    false,\n                    0\n                ),\n                joinableClausesLookupStringKey,\n                VirtualColumns.EMPTY,\n                null\n            )\n        );\n\n    hashJoinLookupStringKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        joinableClausesLookupStringKey,\n        preAnalysisLookupStringKey\n    );\n\n    List<JoinableClause> joinableClausesLookupLongKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysis preAnalysisLookupLongKey =\n        JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n            new JoinFilterPreAnalysisKey(\n                new JoinFilterRewriteConfig(\n                    false,\n                    false,\n                    false,\n                    0\n                ),\n                joinableClausesLookupLongKey,\n                VirtualColumns.EMPTY,\n                null\n            )\n        );\n\n    hashJoinLookupLongKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        joinableClausesLookupLongKey,\n        preAnalysisLookupLongKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%scountryIsoCode\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysis preAnalysisIndexedStringKey =\n        JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n            new JoinFilterPreAnalysisKey(\n                new JoinFilterRewriteConfig(\n                    false,\n                    false,\n                    false,\n                    0\n                ),\n                joinableClausesLookupLongKey,\n                VirtualColumns.EMPTY,\n                null\n            )\n        );\n\n    hashJoinIndexedTableStringKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        joinableClausesIndexedTableStringKey,\n        preAnalysisIndexedStringKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableLongKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryNumber == \\\"%scountryNumber\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysis preAnalysisIndexedLongKey =\n        JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n            new JoinFilterPreAnalysisKey(\n                new JoinFilterRewriteConfig(\n                    false,\n                    false,\n                    false,\n                    0\n                ),\n                joinableClausesIndexedTableLongKey,\n                VirtualColumns.EMPTY,\n                null\n            )\n        );\n\n    hashJoinIndexedTableLongKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        joinableClausesIndexedTableLongKey,\n        preAnalysisIndexedLongKey\n    );\n\n    final Map<String, String> countryCodeToNameMap = JoinTestHelper.createCountryIsoCodeToNameLookup().getMap();\n    final Map<String, String> countryNumberToNameMap = JoinTestHelper.createCountryNumberToNameLookup().getMap();\n\n    final ExprMacroTable exprMacroTable = new ExprMacroTable(\n        ImmutableList.of(\n            new LookupExprMacro(\n                new LookupExtractorFactoryContainerProvider()\n                {\n                  @Override\n                  public Set<String> getAllLookupNames()\n                  {\n                    return ImmutableSet.of(LOOKUP_COUNTRY_CODE_TO_NAME, LOOKUP_COUNTRY_NUMBER_TO_NAME);\n                  }\n\n                  @Override\n                  public Optional<LookupExtractorFactoryContainer> get(String lookupName)\n                  {\n                    if (LOOKUP_COUNTRY_CODE_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryCodeToNameMap, false)\n                          )\n                      );\n                    } else if (LOOKUP_COUNTRY_NUMBER_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryNumberToNameMap, false)\n                          )\n                      );\n                    } else {\n                      return Optional.empty();\n                    }\n                  }\n                }\n            )\n        )\n    );\n\n    lookupVirtualColumns = VirtualColumns.create(\n        ImmutableList.of(\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_CODE_TO_NAME,\n                \"lookup(countryIsoCode, '\" + LOOKUP_COUNTRY_CODE_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            ),\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_NUMBER_TO_NAME,\n                \"lookup(countryNumber, '\" + LOOKUP_COUNTRY_NUMBER_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            )\n        )\n    );\n  }\n","realPath":"benchmarks/src/test/java/org/apache/druid/benchmark/JoinAndLookupBenchmark.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":123,"status":"M"}],"commitId":"1a15987432fab044fc83a99af8ab497d887aeda1","commitMessage":"@@@Supporting filters in the left base table for join datasources (#10697)\n\n* where filter left first draft\n\n* Revert changes in calcite test\n\n* Refactor a bit\n\n* Fixing the Tests\n\n* Changes\n\n* Adding tests\n\n* Add tests for correlated queries\n\n* Add comment\n\n* Fix typos","date":"2021-03-05 02:39:21","modifiedFileCount":"26","status":"M","submitter":"Abhishek Agarwal"},{"authorTime":"2021-04-13 13:21:24","codes":[{"authorDate":"2020-03-12 02:32:27","commitOrder":10,"curCode":"      new LookupExtractorFactoryContainerProvider()\n      {\n        @Override\n        public Set<String> getAllLookupNames()\n        {\n          return ImmutableSet.of(LookupSegmentTest.LOOKUP_NAME);\n        }\n\n        @Override\n        public Optional<LookupExtractorFactoryContainer> get(final String lookupName)\n        {\n          if (LookupSegmentTest.LOOKUP_NAME.equals(lookupName)) {\n            return Optional.of(\n                new LookupExtractorFactoryContainer(\n                    \"v0\",\n                    LookupSegmentTest.LOOKUP_EXTRACTOR_FACTORY\n                )\n            );\n          } else {\n            return Optional.empty();\n          }\n        }\n      }\n","date":"2020-03-12 02:32:27","endLine":70,"groupId":"20004","id":13,"instanceNumber":1,"isCurCommit":1,"methodName":"LookupExtractorFactoryContainerProvider","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/22/8b17c4b67ee68675b7d58b30292c8cd76dfdb0.src","preCode":"      new LookupExtractorFactoryContainerProvider()\n      {\n        @Override\n        public Set<String> getAllLookupNames()\n        {\n          return ImmutableSet.of(LookupSegmentTest.LOOKUP_NAME);\n        }\n\n        @Override\n        public Optional<LookupExtractorFactoryContainer> get(final String lookupName)\n        {\n          if (LookupSegmentTest.LOOKUP_NAME.equals(lookupName)) {\n            return Optional.of(\n                new LookupExtractorFactoryContainer(\n                    \"v0\",\n                    LookupSegmentTest.LOOKUP_EXTRACTOR_FACTORY\n                )\n            );\n          } else {\n            return Optional.empty();\n          }\n        }\n      }\n","realPath":"server/src/test/java/org/apache/druid/segment/LookupSegmentWranglerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":48,"status":"N"},{"authorDate":"2021-04-13 13:21:24","commitOrder":10,"curCode":"  public void setup() throws IOException\n  {\n    tmpDir = FileUtils.createTempDir();\n    ColumnConfig columnConfig = () -> columnCacheSizeBytes;\n    index = JoinTestHelper.createFactIndexBuilder(columnConfig, tmpDir, rows).buildMMappedIndex();\n\n    final String prefix = \"c.\";\n\n    baseSegment = new QueryableIndexSegment(index, SegmentId.dummy(\"join\"));\n\n    List<JoinableClause> joinableClausesLookupStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysis preAnalysisLookupStringKey =\n        JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n            new JoinFilterPreAnalysisKey(\n                new JoinFilterRewriteConfig(\n                    false,\n                    false,\n                    false,\n                    0\n                ),\n                joinableClausesLookupStringKey,\n                VirtualColumns.EMPTY,\n                null\n            )\n        );\n\n    hashJoinLookupStringKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        null,\n        joinableClausesLookupStringKey,\n        preAnalysisLookupStringKey\n    );\n\n    List<JoinableClause> joinableClausesLookupLongKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysis preAnalysisLookupLongKey =\n        JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n            new JoinFilterPreAnalysisKey(\n                new JoinFilterRewriteConfig(\n                    false,\n                    false,\n                    false,\n                    0\n                ),\n                joinableClausesLookupLongKey,\n                VirtualColumns.EMPTY,\n                null\n            )\n        );\n\n    hashJoinLookupLongKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        null,\n        joinableClausesLookupLongKey,\n        preAnalysisLookupLongKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%scountryIsoCode\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysis preAnalysisIndexedStringKey =\n        JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n            new JoinFilterPreAnalysisKey(\n                new JoinFilterRewriteConfig(\n                    false,\n                    false,\n                    false,\n                    0\n                ),\n                joinableClausesLookupLongKey,\n                VirtualColumns.EMPTY,\n                null\n            )\n        );\n\n    hashJoinIndexedTableStringKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        null,\n        joinableClausesIndexedTableStringKey,\n        preAnalysisIndexedStringKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableLongKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryNumber == \\\"%scountryNumber\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysis preAnalysisIndexedLongKey =\n        JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n            new JoinFilterPreAnalysisKey(\n                new JoinFilterRewriteConfig(\n                    false,\n                    false,\n                    false,\n                    0\n                ),\n                joinableClausesIndexedTableLongKey,\n                VirtualColumns.EMPTY,\n                null\n            )\n        );\n\n    hashJoinIndexedTableLongKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        null,\n        joinableClausesIndexedTableLongKey,\n        preAnalysisIndexedLongKey\n    );\n\n    final Map<String, String> countryCodeToNameMap = JoinTestHelper.createCountryIsoCodeToNameLookup().getMap();\n    final Map<String, String> countryNumberToNameMap = JoinTestHelper.createCountryNumberToNameLookup().getMap();\n\n    final ExprMacroTable exprMacroTable = new ExprMacroTable(\n        ImmutableList.of(\n            new LookupExprMacro(\n                new LookupExtractorFactoryContainerProvider()\n                {\n                  @Override\n                  public Set<String> getAllLookupNames()\n                  {\n                    return ImmutableSet.of(LOOKUP_COUNTRY_CODE_TO_NAME, LOOKUP_COUNTRY_NUMBER_TO_NAME);\n                  }\n\n                  @Override\n                  public Optional<LookupExtractorFactoryContainer> get(String lookupName)\n                  {\n                    if (LOOKUP_COUNTRY_CODE_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryCodeToNameMap, false)\n                          )\n                      );\n                    } else if (LOOKUP_COUNTRY_NUMBER_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryNumberToNameMap, false)\n                          )\n                      );\n                    } else {\n                      return Optional.empty();\n                    }\n                  }\n                }\n            )\n        )\n    );\n\n    lookupVirtualColumns = VirtualColumns.create(\n        ImmutableList.of(\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_CODE_TO_NAME,\n                \"lookup(countryIsoCode, '\" + LOOKUP_COUNTRY_CODE_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            ),\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_NUMBER_TO_NAME,\n                \"lookup(countryNumber, '\" + LOOKUP_COUNTRY_NUMBER_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            )\n        )\n    );\n  }\n","date":"2021-04-13 13:21:24","endLine":329,"groupId":"14184","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"setup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/bf/257fd81df03800d95e800e17e50f60bef7b491.src","preCode":"  public void setup() throws IOException\n  {\n    tmpDir = FileUtils.createTempDir();\n    ColumnConfig columnConfig = () -> columnCacheSizeBytes;\n    index = JoinTestHelper.createFactIndexBuilder(tmpDir, rows).buildMMappedIndex(columnConfig);\n\n    final String prefix = \"c.\";\n\n    baseSegment = new QueryableIndexSegment(index, SegmentId.dummy(\"join\"));\n\n    List<JoinableClause> joinableClausesLookupStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysis preAnalysisLookupStringKey =\n        JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n            new JoinFilterPreAnalysisKey(\n                new JoinFilterRewriteConfig(\n                    false,\n                    false,\n                    false,\n                    0\n                ),\n                joinableClausesLookupStringKey,\n                VirtualColumns.EMPTY,\n                null\n            )\n        );\n\n    hashJoinLookupStringKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        null,\n        joinableClausesLookupStringKey,\n        preAnalysisLookupStringKey\n    );\n\n    List<JoinableClause> joinableClausesLookupLongKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysis preAnalysisLookupLongKey =\n        JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n            new JoinFilterPreAnalysisKey(\n                new JoinFilterRewriteConfig(\n                    false,\n                    false,\n                    false,\n                    0\n                ),\n                joinableClausesLookupLongKey,\n                VirtualColumns.EMPTY,\n                null\n            )\n        );\n\n    hashJoinLookupLongKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        null,\n        joinableClausesLookupLongKey,\n        preAnalysisLookupLongKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%scountryIsoCode\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysis preAnalysisIndexedStringKey =\n        JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n            new JoinFilterPreAnalysisKey(\n                new JoinFilterRewriteConfig(\n                    false,\n                    false,\n                    false,\n                    0\n                ),\n                joinableClausesLookupLongKey,\n                VirtualColumns.EMPTY,\n                null\n            )\n        );\n\n    hashJoinIndexedTableStringKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        null,\n        joinableClausesIndexedTableStringKey,\n        preAnalysisIndexedStringKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableLongKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryNumber == \\\"%scountryNumber\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysis preAnalysisIndexedLongKey =\n        JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n            new JoinFilterPreAnalysisKey(\n                new JoinFilterRewriteConfig(\n                    false,\n                    false,\n                    false,\n                    0\n                ),\n                joinableClausesIndexedTableLongKey,\n                VirtualColumns.EMPTY,\n                null\n            )\n        );\n\n    hashJoinIndexedTableLongKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        null,\n        joinableClausesIndexedTableLongKey,\n        preAnalysisIndexedLongKey\n    );\n\n    final Map<String, String> countryCodeToNameMap = JoinTestHelper.createCountryIsoCodeToNameLookup().getMap();\n    final Map<String, String> countryNumberToNameMap = JoinTestHelper.createCountryNumberToNameLookup().getMap();\n\n    final ExprMacroTable exprMacroTable = new ExprMacroTable(\n        ImmutableList.of(\n            new LookupExprMacro(\n                new LookupExtractorFactoryContainerProvider()\n                {\n                  @Override\n                  public Set<String> getAllLookupNames()\n                  {\n                    return ImmutableSet.of(LOOKUP_COUNTRY_CODE_TO_NAME, LOOKUP_COUNTRY_NUMBER_TO_NAME);\n                  }\n\n                  @Override\n                  public Optional<LookupExtractorFactoryContainer> get(String lookupName)\n                  {\n                    if (LOOKUP_COUNTRY_CODE_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryCodeToNameMap, false)\n                          )\n                      );\n                    } else if (LOOKUP_COUNTRY_NUMBER_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryNumberToNameMap, false)\n                          )\n                      );\n                    } else {\n                      return Optional.empty();\n                    }\n                  }\n                }\n            )\n        )\n    );\n\n    lookupVirtualColumns = VirtualColumns.create(\n        ImmutableList.of(\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_CODE_TO_NAME,\n                \"lookup(countryIsoCode, '\" + LOOKUP_COUNTRY_CODE_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            ),\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_NUMBER_TO_NAME,\n                \"lookup(countryNumber, '\" + LOOKUP_COUNTRY_NUMBER_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            )\n        )\n    );\n  }\n","realPath":"benchmarks/src/test/java/org/apache/druid/benchmark/JoinAndLookupBenchmark.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":123,"status":"M"}],"commitId":"25db8787b3d7eac87aa3be8e32d48d0e823298af","commitMessage":"@@@Fix CAST being ignored when aggregating on strings after cast (#11083)\n\n* Fix CAST being ignored when aggregating on strings after cast\n\n* fix checkstyle and dependency\n\n* unused import","date":"2021-04-13 13:21:24","modifiedFileCount":"21","status":"M","submitter":"Jihoon Son"},{"authorTime":"2021-04-15 01:49:27","codes":[{"authorDate":"2020-03-12 02:32:27","commitOrder":11,"curCode":"      new LookupExtractorFactoryContainerProvider()\n      {\n        @Override\n        public Set<String> getAllLookupNames()\n        {\n          return ImmutableSet.of(LookupSegmentTest.LOOKUP_NAME);\n        }\n\n        @Override\n        public Optional<LookupExtractorFactoryContainer> get(final String lookupName)\n        {\n          if (LookupSegmentTest.LOOKUP_NAME.equals(lookupName)) {\n            return Optional.of(\n                new LookupExtractorFactoryContainer(\n                    \"v0\",\n                    LookupSegmentTest.LOOKUP_EXTRACTOR_FACTORY\n                )\n            );\n          } else {\n            return Optional.empty();\n          }\n        }\n      }\n","date":"2020-03-12 02:32:27","endLine":70,"groupId":"1072","id":15,"instanceNumber":1,"isCurCommit":1,"methodName":"LookupExtractorFactoryContainerProvider","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/22/8b17c4b67ee68675b7d58b30292c8cd76dfdb0.src","preCode":"      new LookupExtractorFactoryContainerProvider()\n      {\n        @Override\n        public Set<String> getAllLookupNames()\n        {\n          return ImmutableSet.of(LookupSegmentTest.LOOKUP_NAME);\n        }\n\n        @Override\n        public Optional<LookupExtractorFactoryContainer> get(final String lookupName)\n        {\n          if (LookupSegmentTest.LOOKUP_NAME.equals(lookupName)) {\n            return Optional.of(\n                new LookupExtractorFactoryContainer(\n                    \"v0\",\n                    LookupSegmentTest.LOOKUP_EXTRACTOR_FACTORY\n                )\n            );\n          } else {\n            return Optional.empty();\n          }\n        }\n      }\n","realPath":"server/src/test/java/org/apache/druid/segment/LookupSegmentWranglerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":48,"status":"N"},{"authorDate":"2021-04-15 01:49:27","commitOrder":11,"curCode":"  public void setup() throws IOException\n  {\n    tmpDir = FileUtils.createTempDir();\n    ColumnConfig columnConfig = () -> columnCacheSizeBytes;\n    index = JoinTestHelper.createFactIndexBuilder(columnConfig, tmpDir, rows).buildMMappedIndex();\n\n    final String prefix = \"c.\";\n\n    baseSegment = new QueryableIndexSegment(index, SegmentId.dummy(\"join\"));\n\n    List<JoinableClause> joinableClausesLookupStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysis preAnalysisLookupStringKey =\n        JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n            new JoinFilterPreAnalysisKey(\n                new JoinFilterRewriteConfig(\n                    false,\n                    false,\n                    false,\n                    false,\n                    0\n                ),\n                joinableClausesLookupStringKey,\n                VirtualColumns.EMPTY,\n                null\n            )\n        );\n\n    hashJoinLookupStringKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        null,\n        joinableClausesLookupStringKey,\n        preAnalysisLookupStringKey\n    );\n\n    List<JoinableClause> joinableClausesLookupLongKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysis preAnalysisLookupLongKey =\n        JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n            new JoinFilterPreAnalysisKey(\n                new JoinFilterRewriteConfig(\n                    false,\n                    false,\n                    false,\n                    false,\n                    0\n                ),\n                joinableClausesLookupLongKey,\n                VirtualColumns.EMPTY,\n                null\n            )\n        );\n\n    hashJoinLookupLongKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        null,\n        joinableClausesLookupLongKey,\n        preAnalysisLookupLongKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%scountryIsoCode\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysis preAnalysisIndexedStringKey =\n        JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n            new JoinFilterPreAnalysisKey(\n                new JoinFilterRewriteConfig(\n                    false,\n                    false,\n                    false,\n                    false,\n                    0\n                ),\n                joinableClausesLookupLongKey,\n                VirtualColumns.EMPTY,\n                null\n            )\n        );\n\n    hashJoinIndexedTableStringKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        null,\n        joinableClausesIndexedTableStringKey,\n        preAnalysisIndexedStringKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableLongKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryNumber == \\\"%scountryNumber\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysis preAnalysisIndexedLongKey =\n        JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n            new JoinFilterPreAnalysisKey(\n                new JoinFilterRewriteConfig(\n                    false,\n                    false,\n                    false,\n                    false,\n                    0\n                ),\n                joinableClausesIndexedTableLongKey,\n                VirtualColumns.EMPTY,\n                null\n            )\n        );\n\n    hashJoinIndexedTableLongKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        null,\n        joinableClausesIndexedTableLongKey,\n        preAnalysisIndexedLongKey\n    );\n\n    final Map<String, String> countryCodeToNameMap = JoinTestHelper.createCountryIsoCodeToNameLookup().getMap();\n    final Map<String, String> countryNumberToNameMap = JoinTestHelper.createCountryNumberToNameLookup().getMap();\n\n    final ExprMacroTable exprMacroTable = new ExprMacroTable(\n        ImmutableList.of(\n            new LookupExprMacro(\n                new LookupExtractorFactoryContainerProvider()\n                {\n                  @Override\n                  public Set<String> getAllLookupNames()\n                  {\n                    return ImmutableSet.of(LOOKUP_COUNTRY_CODE_TO_NAME, LOOKUP_COUNTRY_NUMBER_TO_NAME);\n                  }\n\n                  @Override\n                  public Optional<LookupExtractorFactoryContainer> get(String lookupName)\n                  {\n                    if (LOOKUP_COUNTRY_CODE_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryCodeToNameMap, false)\n                          )\n                      );\n                    } else if (LOOKUP_COUNTRY_NUMBER_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryNumberToNameMap, false)\n                          )\n                      );\n                    } else {\n                      return Optional.empty();\n                    }\n                  }\n                }\n            )\n        )\n    );\n\n    lookupVirtualColumns = VirtualColumns.create(\n        ImmutableList.of(\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_CODE_TO_NAME,\n                \"lookup(countryIsoCode, '\" + LOOKUP_COUNTRY_CODE_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            ),\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_NUMBER_TO_NAME,\n                \"lookup(countryNumber, '\" + LOOKUP_COUNTRY_NUMBER_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            )\n        )\n    );\n  }\n","date":"2021-04-15 01:49:27","endLine":333,"groupId":"1072","id":16,"instanceNumber":2,"isCurCommit":1,"methodName":"setup","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/ee/6b7e3c8e94b444b0a1d4c89bf267c1a776aeb0.src","preCode":"  public void setup() throws IOException\n  {\n    tmpDir = FileUtils.createTempDir();\n    ColumnConfig columnConfig = () -> columnCacheSizeBytes;\n    index = JoinTestHelper.createFactIndexBuilder(columnConfig, tmpDir, rows).buildMMappedIndex();\n\n    final String prefix = \"c.\";\n\n    baseSegment = new QueryableIndexSegment(index, SegmentId.dummy(\"join\"));\n\n    List<JoinableClause> joinableClausesLookupStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysis preAnalysisLookupStringKey =\n        JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n            new JoinFilterPreAnalysisKey(\n                new JoinFilterRewriteConfig(\n                    false,\n                    false,\n                    false,\n                    0\n                ),\n                joinableClausesLookupStringKey,\n                VirtualColumns.EMPTY,\n                null\n            )\n        );\n\n    hashJoinLookupStringKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        null,\n        joinableClausesLookupStringKey,\n        preAnalysisLookupStringKey\n    );\n\n    List<JoinableClause> joinableClausesLookupLongKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            LookupJoinable.wrap(JoinTestHelper.createCountryIsoCodeToNameLookup()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%sk\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysis preAnalysisLookupLongKey =\n        JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n            new JoinFilterPreAnalysisKey(\n                new JoinFilterRewriteConfig(\n                    false,\n                    false,\n                    false,\n                    0\n                ),\n                joinableClausesLookupLongKey,\n                VirtualColumns.EMPTY,\n                null\n            )\n        );\n\n    hashJoinLookupLongKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        null,\n        joinableClausesLookupLongKey,\n        preAnalysisLookupLongKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableStringKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryIsoCode == \\\"%scountryIsoCode\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysis preAnalysisIndexedStringKey =\n        JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n            new JoinFilterPreAnalysisKey(\n                new JoinFilterRewriteConfig(\n                    false,\n                    false,\n                    false,\n                    0\n                ),\n                joinableClausesLookupLongKey,\n                VirtualColumns.EMPTY,\n                null\n            )\n        );\n\n    hashJoinIndexedTableStringKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        null,\n        joinableClausesIndexedTableStringKey,\n        preAnalysisIndexedStringKey\n    );\n\n    List<JoinableClause> joinableClausesIndexedTableLongKey = ImmutableList.of(\n        new JoinableClause(\n            prefix,\n            new IndexedTableJoinable(JoinTestHelper.createCountriesIndexedTable()),\n            JoinType.LEFT,\n            JoinConditionAnalysis.forExpression(\n                StringUtils.format(\"countryNumber == \\\"%scountryNumber\\\"\", prefix),\n                prefix,\n                ExprMacroTable.nil()\n            )\n        )\n    );\n\n    JoinFilterPreAnalysis preAnalysisIndexedLongKey =\n        JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n            new JoinFilterPreAnalysisKey(\n                new JoinFilterRewriteConfig(\n                    false,\n                    false,\n                    false,\n                    0\n                ),\n                joinableClausesIndexedTableLongKey,\n                VirtualColumns.EMPTY,\n                null\n            )\n        );\n\n    hashJoinIndexedTableLongKeySegment = new HashJoinSegment(\n        ReferenceCountingSegment.wrapRootGenerationSegment(baseSegment),\n        null,\n        joinableClausesIndexedTableLongKey,\n        preAnalysisIndexedLongKey\n    );\n\n    final Map<String, String> countryCodeToNameMap = JoinTestHelper.createCountryIsoCodeToNameLookup().getMap();\n    final Map<String, String> countryNumberToNameMap = JoinTestHelper.createCountryNumberToNameLookup().getMap();\n\n    final ExprMacroTable exprMacroTable = new ExprMacroTable(\n        ImmutableList.of(\n            new LookupExprMacro(\n                new LookupExtractorFactoryContainerProvider()\n                {\n                  @Override\n                  public Set<String> getAllLookupNames()\n                  {\n                    return ImmutableSet.of(LOOKUP_COUNTRY_CODE_TO_NAME, LOOKUP_COUNTRY_NUMBER_TO_NAME);\n                  }\n\n                  @Override\n                  public Optional<LookupExtractorFactoryContainer> get(String lookupName)\n                  {\n                    if (LOOKUP_COUNTRY_CODE_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryCodeToNameMap, false)\n                          )\n                      );\n                    } else if (LOOKUP_COUNTRY_NUMBER_TO_NAME.equals(lookupName)) {\n                      return Optional.of(\n                          new LookupExtractorFactoryContainer(\n                              \"0\",\n                              new MapLookupExtractorFactory(countryNumberToNameMap, false)\n                          )\n                      );\n                    } else {\n                      return Optional.empty();\n                    }\n                  }\n                }\n            )\n        )\n    );\n\n    lookupVirtualColumns = VirtualColumns.create(\n        ImmutableList.of(\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_CODE_TO_NAME,\n                \"lookup(countryIsoCode, '\" + LOOKUP_COUNTRY_CODE_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            ),\n            new ExpressionVirtualColumn(\n                LOOKUP_COUNTRY_NUMBER_TO_NAME,\n                \"lookup(countryNumber, '\" + LOOKUP_COUNTRY_NUMBER_TO_NAME + \"')\",\n                ValueType.STRING,\n                exprMacroTable\n            )\n        )\n    );\n  }\n","realPath":"benchmarks/src/test/java/org/apache/druid/benchmark/JoinAndLookupBenchmark.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":123,"status":"M"}],"commitId":"202c78c8f32bd3ec5e70e021b1494d878f38d678","commitMessage":"@@@Enable rewriting certain inner joins as filters. (#11068)\n\n* Enable rewriting certain inner joins as filters.\n\nThe main logic for doing the rewrite is in JoinableFactoryWrapper's\nsegmentMapFn method. The requirements are:\n\n- It must be an inner equi-join.\n- The right-hand columns referenced by the condition must not contain any\n  duplicate values. (If they did.  the inner join would not be guaranteed\n  to return at most one row for each left-hand-side row.)\n- No columns from the right-hand side can be used by anything other than\n  the join condition itself.\n\nHashJoinSegmentStorageAdapter is also modified to pass through to\nthe base adapter (even allowing vectorization!) in the case where 100%\nof join clauses could be rewritten as filters.\n\nIn support of this goal:\n\n- Add Query getRequiredColumns() method to help us figure out whether\n  the right-hand side of a join datasource is being used or not.\n- Add JoinConditionAnalysis getRequiredColumns() method to help us\n  figure out if the right-hand side of a join is being used by later\n  join clauses acting on the same base.\n- Add Joinable getNonNullColumnValuesIfAllUnique method to enable\n  retrieving the set of values that will form the \"in\" filter.\n- Add LookupExtractor canGetKeySet() and keySet() methods to support\n  LookupJoinable in its efforts to implement the new Joinable method.\n- Add \"enableRewriteJoinToFilter\" feature flag to\n  JoinFilterRewriteConfig. The default is disabled.\n\n* Test improvements.\n\n* Test fixes.\n\n* Avoid slow size() call.\n\n* Remove invalid test.\n\n* Fix style.\n\n* Fix mistaken default.\n\n* Small fixes.\n\n* Fix logic error.","date":"2021-04-15 01:49:27","modifiedFileCount":"38","status":"M","submitter":"Gian Merlino"}]
