[{"authorTime":"2018-08-31 00:56:26","codes":[{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  public void testPostProcess()\n  {\n    QueryRunner<Result<TimeseriesResultValue>> queryRunner = testOperator.postProcess(\n        new QueryRunner<Result<TimeseriesResultValue>>()\n        {\n          @Override\n          public Sequence<Result<TimeseriesResultValue>> run(\n              QueryPlus<Result<TimeseriesResultValue>> queryPlus,\n              Map<String, Object> responseContext\n          )\n          {\n            return Sequences.simple(\n                ImmutableList.of(\n                    new Result<>(\n                        DateTimes.of(\"2014-01-09\"),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 2))\n                    ),\n                    new Result<>(\n                        DateTimes.of(\"2014-01-11\"),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 3))\n                    ),\n                    new Result<>(\n                        queryPlus.getQuery().getIntervals().get(0).getEnd(),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 5))\n                    )\n                )\n            );\n          }\n        },\n        DateTimes.of(\"2014-08-02\").getMillis()\n    );\n\n    final Query<Result<TimeseriesResultValue>> query =\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(\"dummy\")\n              .intervals(\"2014-07-31/2014-08-05\")\n              .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n              .build();\n\n    Assert.assertEquals(\n        Lists.newArrayList(\n            new Result<>(\n                DateTimes.of(\"2014-07-31\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 2))\n            ),\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 3))\n            ),\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 5))\n            )\n        ),\n        queryRunner.run(QueryPlus.wrap(query), CONTEXT).toList()\n    );\n\n\n    TimewarpOperator<Result<TimeBoundaryResultValue>> timeBoundaryOperator = new TimewarpOperator<>(\n        new Interval(DateTimes.of(\"2014-01-01\"), DateTimes.of(\"2014-01-15\")),\n        new Period(\"P1W\"),\n        DateTimes.of(\"2014-01-06\") \r\n    );\n\n    QueryRunner<Result<TimeBoundaryResultValue>> timeBoundaryRunner = timeBoundaryOperator.postProcess(\n        new QueryRunner<Result<TimeBoundaryResultValue>>()\n        {\n          @Override\n          public Sequence<Result<TimeBoundaryResultValue>> run(\n              QueryPlus<Result<TimeBoundaryResultValue>> queryPlus,\n              Map<String, Object> responseContext\n          )\n          {\n            return Sequences.simple(\n                ImmutableList.of(\n                    new Result<>(\n                        DateTimes.of(\"2014-01-12\"),\n                        new TimeBoundaryResultValue(\n                            ImmutableMap.<String, Object>of(\n                                \"maxTime\",\n                                DateTimes.of(\"2014-01-12\")\n                            )\n                        )\n                    )\n                )\n            );\n          }\n        },\n        DateTimes.of(\"2014-08-02\").getMillis()\n    );\n\n    final Query<Result<TimeBoundaryResultValue>> timeBoundaryQuery =\n        Druids.newTimeBoundaryQueryBuilder()\n              .dataSource(\"dummy\")\n              .build();\n\n    Assert.assertEquals(\n        Collections.singletonList(\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeBoundaryResultValue(ImmutableMap.<String, Object>of(\"maxTime\", DateTimes.of(\"2014-08-02\")))\n            )\n        ),\n        timeBoundaryRunner.run(QueryPlus.wrap(timeBoundaryQuery), CONTEXT).toList()\n    );\n\n  }\n","date":"2018-08-31 00:56:26","endLine":189,"groupId":"16290","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testPostProcess","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/97/f5d253ab0c3c1764b1ff3e9564e982b8e8ccbc.src","preCode":"  public void testPostProcess()\n  {\n    QueryRunner<Result<TimeseriesResultValue>> queryRunner = testOperator.postProcess(\n        new QueryRunner<Result<TimeseriesResultValue>>()\n        {\n          @Override\n          public Sequence<Result<TimeseriesResultValue>> run(\n              QueryPlus<Result<TimeseriesResultValue>> queryPlus,\n              Map<String, Object> responseContext\n          )\n          {\n            return Sequences.simple(\n                ImmutableList.of(\n                    new Result<>(\n                        DateTimes.of(\"2014-01-09\"),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 2))\n                    ),\n                    new Result<>(\n                        DateTimes.of(\"2014-01-11\"),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 3))\n                    ),\n                    new Result<>(\n                        queryPlus.getQuery().getIntervals().get(0).getEnd(),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 5))\n                    )\n                )\n            );\n          }\n        },\n        DateTimes.of(\"2014-08-02\").getMillis()\n    );\n\n    final Query<Result<TimeseriesResultValue>> query =\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(\"dummy\")\n              .intervals(\"2014-07-31/2014-08-05\")\n              .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n              .build();\n\n    Assert.assertEquals(\n        Lists.newArrayList(\n            new Result<>(\n                DateTimes.of(\"2014-07-31\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 2))\n            ),\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 3))\n            ),\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 5))\n            )\n        ),\n        queryRunner.run(QueryPlus.wrap(query), CONTEXT).toList()\n    );\n\n\n    TimewarpOperator<Result<TimeBoundaryResultValue>> timeBoundaryOperator = new TimewarpOperator<>(\n        new Interval(DateTimes.of(\"2014-01-01\"), DateTimes.of(\"2014-01-15\")),\n        new Period(\"P1W\"),\n        DateTimes.of(\"2014-01-06\") \r\n    );\n\n    QueryRunner<Result<TimeBoundaryResultValue>> timeBoundaryRunner = timeBoundaryOperator.postProcess(\n        new QueryRunner<Result<TimeBoundaryResultValue>>()\n        {\n          @Override\n          public Sequence<Result<TimeBoundaryResultValue>> run(\n              QueryPlus<Result<TimeBoundaryResultValue>> queryPlus,\n              Map<String, Object> responseContext\n          )\n          {\n            return Sequences.simple(\n                ImmutableList.of(\n                    new Result<>(\n                        DateTimes.of(\"2014-01-12\"),\n                        new TimeBoundaryResultValue(\n                            ImmutableMap.<String, Object>of(\n                                \"maxTime\",\n                                DateTimes.of(\"2014-01-12\")\n                            )\n                        )\n                    )\n                )\n            );\n          }\n        },\n        DateTimes.of(\"2014-08-02\").getMillis()\n    );\n\n    final Query<Result<TimeBoundaryResultValue>> timeBoundaryQuery =\n        Druids.newTimeBoundaryQueryBuilder()\n              .dataSource(\"dummy\")\n              .build();\n\n    Assert.assertEquals(\n        Collections.singletonList(\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeBoundaryResultValue(ImmutableMap.<String, Object>of(\"maxTime\", DateTimes.of(\"2014-08-02\")))\n            )\n        ),\n        timeBoundaryRunner.run(QueryPlus.wrap(timeBoundaryQuery), CONTEXT).toList()\n    );\n\n  }\n","realPath":"processing/src/test/java/org/apache/druid/query/TimewarpOperatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":83,"status":"B"},{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  public void testEmptyFutureInterval()\n  {\n    QueryRunner<Result<TimeseriesResultValue>> queryRunner = testOperator.postProcess(\n        new QueryRunner<Result<TimeseriesResultValue>>()\n        {\n          @Override\n          public Sequence<Result<TimeseriesResultValue>> run(\n              QueryPlus<Result<TimeseriesResultValue>> queryPlus,\n              Map<String, Object> responseContext\n          )\n          {\n            final Query<Result<TimeseriesResultValue>> query = queryPlus.getQuery();\n            return Sequences.simple(\n                ImmutableList.of(\n                    new Result<>(\n                        query.getIntervals().get(0).getStart(),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 2))\n                    ),\n                    new Result<>(\n                        query.getIntervals().get(0).getEnd(),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 3))\n                    )\n                )\n            );\n          }\n        },\n        DateTimes.of(\"2014-08-02\").getMillis()\n    );\n\n    final Query<Result<TimeseriesResultValue>> query =\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(\"dummy\")\n              .intervals(\"2014-08-06/2014-08-08\")\n              .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n              .build();\n\n    Assert.assertEquals(\n        Lists.newArrayList(\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 2))\n            ),\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 3))\n            )\n        ),\n        queryRunner.run(QueryPlus.wrap(query), Maps.newHashMap()).toList()\n    );\n  }\n","date":"2018-08-31 00:56:26","endLine":361,"groupId":"17554","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testEmptyFutureInterval","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/97/f5d253ab0c3c1764b1ff3e9564e982b8e8ccbc.src","preCode":"  public void testEmptyFutureInterval()\n  {\n    QueryRunner<Result<TimeseriesResultValue>> queryRunner = testOperator.postProcess(\n        new QueryRunner<Result<TimeseriesResultValue>>()\n        {\n          @Override\n          public Sequence<Result<TimeseriesResultValue>> run(\n              QueryPlus<Result<TimeseriesResultValue>> queryPlus,\n              Map<String, Object> responseContext\n          )\n          {\n            final Query<Result<TimeseriesResultValue>> query = queryPlus.getQuery();\n            return Sequences.simple(\n                ImmutableList.of(\n                    new Result<>(\n                        query.getIntervals().get(0).getStart(),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 2))\n                    ),\n                    new Result<>(\n                        query.getIntervals().get(0).getEnd(),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 3))\n                    )\n                )\n            );\n          }\n        },\n        DateTimes.of(\"2014-08-02\").getMillis()\n    );\n\n    final Query<Result<TimeseriesResultValue>> query =\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(\"dummy\")\n              .intervals(\"2014-08-06/2014-08-08\")\n              .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n              .build();\n\n    Assert.assertEquals(\n        Lists.newArrayList(\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 2))\n            ),\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 3))\n            )\n        ),\n        queryRunner.run(QueryPlus.wrap(query), Maps.newHashMap()).toList()\n    );\n  }\n","realPath":"processing/src/test/java/org/apache/druid/query/TimewarpOperatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":312,"status":"B"}],"commitId":"431d3d8497f9079857c3baa7ae7ab4cb44a22355","commitMessage":"@@@Rename io.druid to org.apache.druid. (#6266)\n\n* Rename io.druid to org.apache.druid.\n\n* Fix META-INF files and remove some benchmark results.\n\n* MonitorsConfig update for metrics package migration.\n\n* Reorder some dimensions in inner queries for some reason.\n\n* Fix protobuf tests.\n","date":"2018-08-31 00:56:26","modifiedFileCount":"5","status":"B","submitter":"Gian Merlino"},{"authorTime":"2018-10-29 20:02:43","codes":[{"authorDate":"2018-08-31 00:56:26","commitOrder":2,"curCode":"  public void testPostProcess()\n  {\n    QueryRunner<Result<TimeseriesResultValue>> queryRunner = testOperator.postProcess(\n        new QueryRunner<Result<TimeseriesResultValue>>()\n        {\n          @Override\n          public Sequence<Result<TimeseriesResultValue>> run(\n              QueryPlus<Result<TimeseriesResultValue>> queryPlus,\n              Map<String, Object> responseContext\n          )\n          {\n            return Sequences.simple(\n                ImmutableList.of(\n                    new Result<>(\n                        DateTimes.of(\"2014-01-09\"),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 2))\n                    ),\n                    new Result<>(\n                        DateTimes.of(\"2014-01-11\"),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 3))\n                    ),\n                    new Result<>(\n                        queryPlus.getQuery().getIntervals().get(0).getEnd(),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 5))\n                    )\n                )\n            );\n          }\n        },\n        DateTimes.of(\"2014-08-02\").getMillis()\n    );\n\n    final Query<Result<TimeseriesResultValue>> query =\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(\"dummy\")\n              .intervals(\"2014-07-31/2014-08-05\")\n              .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n              .build();\n\n    Assert.assertEquals(\n        Lists.newArrayList(\n            new Result<>(\n                DateTimes.of(\"2014-07-31\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 2))\n            ),\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 3))\n            ),\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 5))\n            )\n        ),\n        queryRunner.run(QueryPlus.wrap(query), CONTEXT).toList()\n    );\n\n\n    TimewarpOperator<Result<TimeBoundaryResultValue>> timeBoundaryOperator = new TimewarpOperator<>(\n        new Interval(DateTimes.of(\"2014-01-01\"), DateTimes.of(\"2014-01-15\")),\n        new Period(\"P1W\"),\n        DateTimes.of(\"2014-01-06\") \r\n    );\n\n    QueryRunner<Result<TimeBoundaryResultValue>> timeBoundaryRunner = timeBoundaryOperator.postProcess(\n        new QueryRunner<Result<TimeBoundaryResultValue>>()\n        {\n          @Override\n          public Sequence<Result<TimeBoundaryResultValue>> run(\n              QueryPlus<Result<TimeBoundaryResultValue>> queryPlus,\n              Map<String, Object> responseContext\n          )\n          {\n            return Sequences.simple(\n                ImmutableList.of(\n                    new Result<>(\n                        DateTimes.of(\"2014-01-12\"),\n                        new TimeBoundaryResultValue(\n                            ImmutableMap.<String, Object>of(\n                                \"maxTime\",\n                                DateTimes.of(\"2014-01-12\")\n                            )\n                        )\n                    )\n                )\n            );\n          }\n        },\n        DateTimes.of(\"2014-08-02\").getMillis()\n    );\n\n    final Query<Result<TimeBoundaryResultValue>> timeBoundaryQuery =\n        Druids.newTimeBoundaryQueryBuilder()\n              .dataSource(\"dummy\")\n              .build();\n\n    Assert.assertEquals(\n        Collections.singletonList(\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeBoundaryResultValue(ImmutableMap.<String, Object>of(\"maxTime\", DateTimes.of(\"2014-08-02\")))\n            )\n        ),\n        timeBoundaryRunner.run(QueryPlus.wrap(timeBoundaryQuery), CONTEXT).toList()\n    );\n\n  }\n","date":"2018-08-31 00:56:26","endLine":189,"groupId":"16290","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testPostProcess","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/97/f5d253ab0c3c1764b1ff3e9564e982b8e8ccbc.src","preCode":"  public void testPostProcess()\n  {\n    QueryRunner<Result<TimeseriesResultValue>> queryRunner = testOperator.postProcess(\n        new QueryRunner<Result<TimeseriesResultValue>>()\n        {\n          @Override\n          public Sequence<Result<TimeseriesResultValue>> run(\n              QueryPlus<Result<TimeseriesResultValue>> queryPlus,\n              Map<String, Object> responseContext\n          )\n          {\n            return Sequences.simple(\n                ImmutableList.of(\n                    new Result<>(\n                        DateTimes.of(\"2014-01-09\"),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 2))\n                    ),\n                    new Result<>(\n                        DateTimes.of(\"2014-01-11\"),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 3))\n                    ),\n                    new Result<>(\n                        queryPlus.getQuery().getIntervals().get(0).getEnd(),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 5))\n                    )\n                )\n            );\n          }\n        },\n        DateTimes.of(\"2014-08-02\").getMillis()\n    );\n\n    final Query<Result<TimeseriesResultValue>> query =\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(\"dummy\")\n              .intervals(\"2014-07-31/2014-08-05\")\n              .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n              .build();\n\n    Assert.assertEquals(\n        Lists.newArrayList(\n            new Result<>(\n                DateTimes.of(\"2014-07-31\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 2))\n            ),\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 3))\n            ),\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 5))\n            )\n        ),\n        queryRunner.run(QueryPlus.wrap(query), CONTEXT).toList()\n    );\n\n\n    TimewarpOperator<Result<TimeBoundaryResultValue>> timeBoundaryOperator = new TimewarpOperator<>(\n        new Interval(DateTimes.of(\"2014-01-01\"), DateTimes.of(\"2014-01-15\")),\n        new Period(\"P1W\"),\n        DateTimes.of(\"2014-01-06\") \r\n    );\n\n    QueryRunner<Result<TimeBoundaryResultValue>> timeBoundaryRunner = timeBoundaryOperator.postProcess(\n        new QueryRunner<Result<TimeBoundaryResultValue>>()\n        {\n          @Override\n          public Sequence<Result<TimeBoundaryResultValue>> run(\n              QueryPlus<Result<TimeBoundaryResultValue>> queryPlus,\n              Map<String, Object> responseContext\n          )\n          {\n            return Sequences.simple(\n                ImmutableList.of(\n                    new Result<>(\n                        DateTimes.of(\"2014-01-12\"),\n                        new TimeBoundaryResultValue(\n                            ImmutableMap.<String, Object>of(\n                                \"maxTime\",\n                                DateTimes.of(\"2014-01-12\")\n                            )\n                        )\n                    )\n                )\n            );\n          }\n        },\n        DateTimes.of(\"2014-08-02\").getMillis()\n    );\n\n    final Query<Result<TimeBoundaryResultValue>> timeBoundaryQuery =\n        Druids.newTimeBoundaryQueryBuilder()\n              .dataSource(\"dummy\")\n              .build();\n\n    Assert.assertEquals(\n        Collections.singletonList(\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeBoundaryResultValue(ImmutableMap.<String, Object>of(\"maxTime\", DateTimes.of(\"2014-08-02\")))\n            )\n        ),\n        timeBoundaryRunner.run(QueryPlus.wrap(timeBoundaryQuery), CONTEXT).toList()\n    );\n\n  }\n","realPath":"processing/src/test/java/org/apache/druid/query/TimewarpOperatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":83,"status":"N"},{"authorDate":"2018-10-29 20:02:43","commitOrder":2,"curCode":"  public void testEmptyFutureInterval()\n  {\n    QueryRunner<Result<TimeseriesResultValue>> queryRunner = testOperator.postProcess(\n        new QueryRunner<Result<TimeseriesResultValue>>()\n        {\n          @Override\n          public Sequence<Result<TimeseriesResultValue>> run(\n              QueryPlus<Result<TimeseriesResultValue>> queryPlus,\n              Map<String, Object> responseContext\n          )\n          {\n            final Query<Result<TimeseriesResultValue>> query = queryPlus.getQuery();\n            return Sequences.simple(\n                ImmutableList.of(\n                    new Result<>(\n                        query.getIntervals().get(0).getStart(),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 2))\n                    ),\n                    new Result<>(\n                        query.getIntervals().get(0).getEnd(),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 3))\n                    )\n                )\n            );\n          }\n        },\n        DateTimes.of(\"2014-08-02\").getMillis()\n    );\n\n    final Query<Result<TimeseriesResultValue>> query =\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(\"dummy\")\n              .intervals(\"2014-08-06/2014-08-08\")\n              .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n              .build();\n\n    Assert.assertEquals(\n        Lists.newArrayList(\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 2))\n            ),\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 3))\n            )\n        ),\n        queryRunner.run(QueryPlus.wrap(query), new HashMap<>()).toList()\n    );\n  }\n","date":"2018-10-29 20:02:43","endLine":361,"groupId":"17554","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testEmptyFutureInterval","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/98/2ad1ddd608e0b3393c509c136794ae67c4bb4e.src","preCode":"  public void testEmptyFutureInterval()\n  {\n    QueryRunner<Result<TimeseriesResultValue>> queryRunner = testOperator.postProcess(\n        new QueryRunner<Result<TimeseriesResultValue>>()\n        {\n          @Override\n          public Sequence<Result<TimeseriesResultValue>> run(\n              QueryPlus<Result<TimeseriesResultValue>> queryPlus,\n              Map<String, Object> responseContext\n          )\n          {\n            final Query<Result<TimeseriesResultValue>> query = queryPlus.getQuery();\n            return Sequences.simple(\n                ImmutableList.of(\n                    new Result<>(\n                        query.getIntervals().get(0).getStart(),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 2))\n                    ),\n                    new Result<>(\n                        query.getIntervals().get(0).getEnd(),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 3))\n                    )\n                )\n            );\n          }\n        },\n        DateTimes.of(\"2014-08-02\").getMillis()\n    );\n\n    final Query<Result<TimeseriesResultValue>> query =\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(\"dummy\")\n              .intervals(\"2014-08-06/2014-08-08\")\n              .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n              .build();\n\n    Assert.assertEquals(\n        Lists.newArrayList(\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 2))\n            ),\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 3))\n            )\n        ),\n        queryRunner.run(QueryPlus.wrap(query), Maps.newHashMap()).toList()\n    );\n  }\n","realPath":"processing/src/test/java/org/apache/druid/query/TimewarpOperatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":312,"status":"M"}],"commitId":"676f5e6d7f184101b8763e4249b18b237bbe0ec7","commitMessage":"@@@Prohibit some guava collection APIs and use JDK collection APIs directly (#6511)\n\n* Prohibit some guava collection APIs and use JDK APIs directly\n\n* reset files that changed by accident\n\n* sort codestyle/druid-forbidden-apis.txt alphabetically\n","date":"2018-10-29 20:02:43","modifiedFileCount":"427","status":"M","submitter":"QiuMM"},{"authorTime":"2019-07-24 23:29:03","codes":[{"authorDate":"2019-07-24 23:29:03","commitOrder":3,"curCode":"  public void testPostProcess()\n  {\n    QueryRunner<Result<TimeseriesResultValue>> queryRunner = testOperator.postProcess(\n        new QueryRunner<Result<TimeseriesResultValue>>()\n        {\n          @Override\n          public Sequence<Result<TimeseriesResultValue>> run(\n              QueryPlus<Result<TimeseriesResultValue>> queryPlus,\n              ResponseContext responseContext\n          )\n          {\n            return Sequences.simple(\n                ImmutableList.of(\n                    new Result<>(\n                        DateTimes.of(\"2014-01-09\"),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 2))\n                    ),\n                    new Result<>(\n                        DateTimes.of(\"2014-01-11\"),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 3))\n                    ),\n                    new Result<>(\n                        queryPlus.getQuery().getIntervals().get(0).getEnd(),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 5))\n                    )\n                )\n            );\n          }\n        },\n        DateTimes.of(\"2014-08-02\").getMillis()\n    );\n\n    final Query<Result<TimeseriesResultValue>> query =\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(\"dummy\")\n              .intervals(\"2014-07-31/2014-08-05\")\n              .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n              .build();\n\n    Assert.assertEquals(\n        Lists.newArrayList(\n            new Result<>(\n                DateTimes.of(\"2014-07-31\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 2))\n            ),\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 3))\n            ),\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 5))\n            )\n        ),\n        queryRunner.run(QueryPlus.wrap(query)).toList()\n    );\n\n\n    TimewarpOperator<Result<TimeBoundaryResultValue>> timeBoundaryOperator = new TimewarpOperator<>(\n        new Interval(DateTimes.of(\"2014-01-01\"), DateTimes.of(\"2014-01-15\")),\n        new Period(\"P1W\"),\n        DateTimes.of(\"2014-01-06\") \r\n    );\n\n    QueryRunner<Result<TimeBoundaryResultValue>> timeBoundaryRunner = timeBoundaryOperator.postProcess(\n        new QueryRunner<Result<TimeBoundaryResultValue>>()\n        {\n          @Override\n          public Sequence<Result<TimeBoundaryResultValue>> run(\n              QueryPlus<Result<TimeBoundaryResultValue>> queryPlus,\n              ResponseContext responseContext\n          )\n          {\n            return Sequences.simple(\n                ImmutableList.of(\n                    new Result<>(\n                        DateTimes.of(\"2014-01-12\"),\n                        new TimeBoundaryResultValue(\n                            ImmutableMap.<String, Object>of(\n                                \"maxTime\",\n                                DateTimes.of(\"2014-01-12\")\n                            )\n                        )\n                    )\n                )\n            );\n          }\n        },\n        DateTimes.of(\"2014-08-02\").getMillis()\n    );\n\n    final Query<Result<TimeBoundaryResultValue>> timeBoundaryQuery =\n        Druids.newTimeBoundaryQueryBuilder()\n              .dataSource(\"dummy\")\n              .build();\n\n    Assert.assertEquals(\n        Collections.singletonList(\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeBoundaryResultValue(ImmutableMap.<String, Object>of(\"maxTime\", DateTimes.of(\"2014-08-02\")))\n            )\n        ),\n        timeBoundaryRunner.run(QueryPlus.wrap(timeBoundaryQuery)).toList()\n    );\n\n  }\n","date":"2019-07-24 23:29:03","endLine":186,"groupId":"106293","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"testPostProcess","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/10/d788e1ac5690423ce67656beb5cf2ed09918cd.src","preCode":"  public void testPostProcess()\n  {\n    QueryRunner<Result<TimeseriesResultValue>> queryRunner = testOperator.postProcess(\n        new QueryRunner<Result<TimeseriesResultValue>>()\n        {\n          @Override\n          public Sequence<Result<TimeseriesResultValue>> run(\n              QueryPlus<Result<TimeseriesResultValue>> queryPlus,\n              Map<String, Object> responseContext\n          )\n          {\n            return Sequences.simple(\n                ImmutableList.of(\n                    new Result<>(\n                        DateTimes.of(\"2014-01-09\"),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 2))\n                    ),\n                    new Result<>(\n                        DateTimes.of(\"2014-01-11\"),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 3))\n                    ),\n                    new Result<>(\n                        queryPlus.getQuery().getIntervals().get(0).getEnd(),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 5))\n                    )\n                )\n            );\n          }\n        },\n        DateTimes.of(\"2014-08-02\").getMillis()\n    );\n\n    final Query<Result<TimeseriesResultValue>> query =\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(\"dummy\")\n              .intervals(\"2014-07-31/2014-08-05\")\n              .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n              .build();\n\n    Assert.assertEquals(\n        Lists.newArrayList(\n            new Result<>(\n                DateTimes.of(\"2014-07-31\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 2))\n            ),\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 3))\n            ),\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 5))\n            )\n        ),\n        queryRunner.run(QueryPlus.wrap(query), CONTEXT).toList()\n    );\n\n\n    TimewarpOperator<Result<TimeBoundaryResultValue>> timeBoundaryOperator = new TimewarpOperator<>(\n        new Interval(DateTimes.of(\"2014-01-01\"), DateTimes.of(\"2014-01-15\")),\n        new Period(\"P1W\"),\n        DateTimes.of(\"2014-01-06\") \r\n    );\n\n    QueryRunner<Result<TimeBoundaryResultValue>> timeBoundaryRunner = timeBoundaryOperator.postProcess(\n        new QueryRunner<Result<TimeBoundaryResultValue>>()\n        {\n          @Override\n          public Sequence<Result<TimeBoundaryResultValue>> run(\n              QueryPlus<Result<TimeBoundaryResultValue>> queryPlus,\n              Map<String, Object> responseContext\n          )\n          {\n            return Sequences.simple(\n                ImmutableList.of(\n                    new Result<>(\n                        DateTimes.of(\"2014-01-12\"),\n                        new TimeBoundaryResultValue(\n                            ImmutableMap.<String, Object>of(\n                                \"maxTime\",\n                                DateTimes.of(\"2014-01-12\")\n                            )\n                        )\n                    )\n                )\n            );\n          }\n        },\n        DateTimes.of(\"2014-08-02\").getMillis()\n    );\n\n    final Query<Result<TimeBoundaryResultValue>> timeBoundaryQuery =\n        Druids.newTimeBoundaryQueryBuilder()\n              .dataSource(\"dummy\")\n              .build();\n\n    Assert.assertEquals(\n        Collections.singletonList(\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeBoundaryResultValue(ImmutableMap.<String, Object>of(\"maxTime\", DateTimes.of(\"2014-08-02\")))\n            )\n        ),\n        timeBoundaryRunner.run(QueryPlus.wrap(timeBoundaryQuery), CONTEXT).toList()\n    );\n\n  }\n","realPath":"processing/src/test/java/org/apache/druid/query/TimewarpOperatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":80,"status":"M"},{"authorDate":"2019-07-24 23:29:03","commitOrder":3,"curCode":"  public void testEmptyFutureInterval()\n  {\n    QueryRunner<Result<TimeseriesResultValue>> queryRunner = testOperator.postProcess(\n        new QueryRunner<Result<TimeseriesResultValue>>()\n        {\n          @Override\n          public Sequence<Result<TimeseriesResultValue>> run(\n              QueryPlus<Result<TimeseriesResultValue>> queryPlus,\n              ResponseContext responseContext\n          )\n          {\n            final Query<Result<TimeseriesResultValue>> query = queryPlus.getQuery();\n            return Sequences.simple(\n                ImmutableList.of(\n                    new Result<>(\n                        query.getIntervals().get(0).getStart(),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 2))\n                    ),\n                    new Result<>(\n                        query.getIntervals().get(0).getEnd(),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 3))\n                    )\n                )\n            );\n          }\n        },\n        DateTimes.of(\"2014-08-02\").getMillis()\n    );\n\n    final Query<Result<TimeseriesResultValue>> query =\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(\"dummy\")\n              .intervals(\"2014-08-06/2014-08-08\")\n              .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n              .build();\n\n    Assert.assertEquals(\n        Lists.newArrayList(\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 2))\n            ),\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 3))\n            )\n        ),\n        queryRunner.run(QueryPlus.wrap(query)).toList()\n    );\n  }\n","date":"2019-07-24 23:29:03","endLine":358,"groupId":"106293","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"testEmptyFutureInterval","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/10/d788e1ac5690423ce67656beb5cf2ed09918cd.src","preCode":"  public void testEmptyFutureInterval()\n  {\n    QueryRunner<Result<TimeseriesResultValue>> queryRunner = testOperator.postProcess(\n        new QueryRunner<Result<TimeseriesResultValue>>()\n        {\n          @Override\n          public Sequence<Result<TimeseriesResultValue>> run(\n              QueryPlus<Result<TimeseriesResultValue>> queryPlus,\n              Map<String, Object> responseContext\n          )\n          {\n            final Query<Result<TimeseriesResultValue>> query = queryPlus.getQuery();\n            return Sequences.simple(\n                ImmutableList.of(\n                    new Result<>(\n                        query.getIntervals().get(0).getStart(),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 2))\n                    ),\n                    new Result<>(\n                        query.getIntervals().get(0).getEnd(),\n                        new TimeseriesResultValue(ImmutableMap.of(\"metric\", 3))\n                    )\n                )\n            );\n          }\n        },\n        DateTimes.of(\"2014-08-02\").getMillis()\n    );\n\n    final Query<Result<TimeseriesResultValue>> query =\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(\"dummy\")\n              .intervals(\"2014-08-06/2014-08-08\")\n              .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n              .build();\n\n    Assert.assertEquals(\n        Lists.newArrayList(\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 2))\n            ),\n            new Result<>(\n                DateTimes.of(\"2014-08-02\"),\n                new TimeseriesResultValue(ImmutableMap.of(\"metric\", 3))\n            )\n        ),\n        queryRunner.run(QueryPlus.wrap(query), new HashMap<>()).toList()\n    );\n  }\n","realPath":"processing/src/test/java/org/apache/druid/query/TimewarpOperatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":309,"status":"M"}],"commitId":"799d20249fe6333ea86b020f6d09c91fa4d3f998","commitMessage":"@@@Response context refactoring (#8110)\n\n* Response context refactoring\n\n* Serialization/Deserialization of ResponseContext\n\n* Added java doc comments\n\n* Renamed vars related to ResponseContext\n\n* Renamed empty() methods to createEmpty()\n\n* Fixed ResponseContext usage\n\n* Renamed multiple ResponseContext static fields\n\n* Added PublicApi annotations\n\n* Renamed QueryResponseContext class to ResourceIOReaderWriter\n\n* Moved the protected method below public static constants\n\n* Added createEmpty method to ResponseContext with DefaultResponseContext creation\n\n* Fixed inspection error\n\n* Added comments to the ResponseContext length limit and ResponseContext\nhttp header name\n\n* Added a comment of possible future refactoring\n\n* Removed .gitignore file of indexing-service\n\n* Removed a never-used method\n\n* VisibleForTesting method reducing boilerplate\n\nCo-Authored-By: Clint Wylie <cjwylie@gmail.com>\n\n* Reduced boilerplate\n\n* Renamed the method serialize to serializeWith\n\n* Removed unused import\n\n* Fixed incorrectly refactored test method\n\n* Added comments for ResponseContext keys\n\n* Fixed incorrectly refactored test method\n\n* Fixed IntervalChunkingQueryRunnerTest mocks\n","date":"2019-07-24 23:29:03","modifiedFileCount":"142","status":"M","submitter":"Eugene Sevastianov"}]
