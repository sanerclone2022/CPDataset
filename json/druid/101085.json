[{"authorTime":"2018-08-31 00:56:26","codes":[{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  private void startPersistThread()\n  {\n    final Granularity segmentGranularity = schema.getGranularitySpec().getSegmentGranularity();\n    final Period windowPeriod = config.getWindowPeriod();\n\n    final DateTime truncatedNow = segmentGranularity.bucketStart(DateTimes.nowUtc());\n    final long windowMillis = windowPeriod.toStandardDuration().getMillis();\n\n    log.info(\n        \"Expect to run at [%s]\",\n        DateTimes.nowUtc().plus(\n            new Duration(\n                System.currentTimeMillis(),\n                segmentGranularity.increment(truncatedNow).getMillis() + windowMillis\n            )\n        )\n    );\n\n    String threadName = StringUtils.format(\n        \"%s-overseer-%d\",\n        schema.getDataSource(),\n        config.getShardSpec().getPartitionNum()\n    );\n    ThreadRenamingCallable<ScheduledExecutors.Signal> threadRenamingCallable =\n        new ThreadRenamingCallable<ScheduledExecutors.Signal>(threadName)\n        {\n          @Override\n          public ScheduledExecutors.Signal doCall()\n          {\n            if (stopped) {\n              log.info(\"Stopping merge-n-push overseer thread\");\n              return ScheduledExecutors.Signal.STOP;\n            }\n\n            mergeAndPush();\n\n            if (stopped) {\n              log.info(\"Stopping merge-n-push overseer thread\");\n              return ScheduledExecutors.Signal.STOP;\n            } else {\n              return ScheduledExecutors.Signal.REPEAT;\n            }\n          }\n        };\n    Duration initialDelay = new Duration(\n        System.currentTimeMillis(),\n        segmentGranularity.increment(truncatedNow).getMillis() + windowMillis\n    );\n    Duration rate = new Duration(truncatedNow, segmentGranularity.increment(truncatedNow));\n    ScheduledExecutors.scheduleAtFixedRate(scheduledExecutor, initialDelay, rate, threadRenamingCallable);\n  }\n","date":"2018-08-31 00:56:26","endLine":384,"groupId":"14331","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"startPersistThread","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/d0/e72e3d6d1f985379cdbd64cbed93e6321016a4.src","preCode":"  private void startPersistThread()\n  {\n    final Granularity segmentGranularity = schema.getGranularitySpec().getSegmentGranularity();\n    final Period windowPeriod = config.getWindowPeriod();\n\n    final DateTime truncatedNow = segmentGranularity.bucketStart(DateTimes.nowUtc());\n    final long windowMillis = windowPeriod.toStandardDuration().getMillis();\n\n    log.info(\n        \"Expect to run at [%s]\",\n        DateTimes.nowUtc().plus(\n            new Duration(\n                System.currentTimeMillis(),\n                segmentGranularity.increment(truncatedNow).getMillis() + windowMillis\n            )\n        )\n    );\n\n    String threadName = StringUtils.format(\n        \"%s-overseer-%d\",\n        schema.getDataSource(),\n        config.getShardSpec().getPartitionNum()\n    );\n    ThreadRenamingCallable<ScheduledExecutors.Signal> threadRenamingCallable =\n        new ThreadRenamingCallable<ScheduledExecutors.Signal>(threadName)\n        {\n          @Override\n          public ScheduledExecutors.Signal doCall()\n          {\n            if (stopped) {\n              log.info(\"Stopping merge-n-push overseer thread\");\n              return ScheduledExecutors.Signal.STOP;\n            }\n\n            mergeAndPush();\n\n            if (stopped) {\n              log.info(\"Stopping merge-n-push overseer thread\");\n              return ScheduledExecutors.Signal.STOP;\n            } else {\n              return ScheduledExecutors.Signal.REPEAT;\n            }\n          }\n        };\n    Duration initialDelay = new Duration(\n        System.currentTimeMillis(),\n        segmentGranularity.increment(truncatedNow).getMillis() + windowMillis\n    );\n    Duration rate = new Duration(truncatedNow, segmentGranularity.increment(truncatedNow));\n    ScheduledExecutors.scheduleAtFixedRate(scheduledExecutor, initialDelay, rate, threadRenamingCallable);\n  }\n","realPath":"server/src/main/java/org/apache/druid/segment/realtime/appenderator/AppenderatorPlumber.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":334,"status":"B"},{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  private void startFlushThread()\n  {\n    final Granularity segmentGranularity = schema.getGranularitySpec().getSegmentGranularity();\n    final DateTime truncatedNow = segmentGranularity.bucketStart(DateTimes.nowUtc());\n    final long windowMillis = config.getWindowPeriod().toStandardDuration().getMillis();\n\n    log.info(\n        \"Expect to run at [%s]\",\n        DateTimes.nowUtc().plus(\n            new Duration(\n                System.currentTimeMillis(),\n                schema.getGranularitySpec().getSegmentGranularity().increment(truncatedNow).getMillis() + windowMillis\n            )\n        )\n    );\n\n    String threadName = StringUtils.format(\n        \"%s-flusher-%d\",\n        getSchema().getDataSource(),\n        getConfig().getShardSpec().getPartitionNum()\n    );\n    ThreadRenamingCallable<ScheduledExecutors.Signal> threadRenamingCallable =\n        new ThreadRenamingCallable<ScheduledExecutors.Signal>(threadName)\n        {\n          @Override\n          public ScheduledExecutors.Signal doCall()\n          {\n            if (stopped) {\n              log.info(\"Stopping flusher thread\");\n              return ScheduledExecutors.Signal.STOP;\n            }\n\n            long minTimestamp = segmentGranularity.bucketStart(\n                getRejectionPolicy().getCurrMaxTime().minus(windowMillis)\n            ).getMillis();\n\n            List<Map.Entry<Long, Sink>> sinksToPush = Lists.newArrayList();\n            for (Map.Entry<Long, Sink> entry : getSinks().entrySet()) {\n              final Long intervalStart = entry.getKey();\n              if (intervalStart < minTimestamp) {\n                log.info(\"Adding entry[%s] to flush.\", entry);\n                sinksToPush.add(entry);\n              }\n            }\n\n            for (final Map.Entry<Long, Sink> entry : sinksToPush) {\n              flushAfterDuration(entry.getKey(), entry.getValue());\n            }\n\n            if (stopped) {\n              log.info(\"Stopping flusher thread\");\n              return ScheduledExecutors.Signal.STOP;\n            } else {\n              return ScheduledExecutors.Signal.REPEAT;\n            }\n          }\n        };\n    Duration initialDelay = new Duration(\n        System.currentTimeMillis(),\n        schema.getGranularitySpec().getSegmentGranularity().increment(truncatedNow).getMillis() + windowMillis\n    );\n    Duration rate = new Duration(truncatedNow, segmentGranularity.increment(truncatedNow));\n    ScheduledExecutors.scheduleAtFixedRate(flushScheduledExec, initialDelay, rate, threadRenamingCallable);\n  }\n","date":"2018-08-31 00:56:26","endLine":210,"groupId":"8512","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"startFlushThread","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/ce/ecde5d040e3f32ba5a5dba34597647bab50a86.src","preCode":"  private void startFlushThread()\n  {\n    final Granularity segmentGranularity = schema.getGranularitySpec().getSegmentGranularity();\n    final DateTime truncatedNow = segmentGranularity.bucketStart(DateTimes.nowUtc());\n    final long windowMillis = config.getWindowPeriod().toStandardDuration().getMillis();\n\n    log.info(\n        \"Expect to run at [%s]\",\n        DateTimes.nowUtc().plus(\n            new Duration(\n                System.currentTimeMillis(),\n                schema.getGranularitySpec().getSegmentGranularity().increment(truncatedNow).getMillis() + windowMillis\n            )\n        )\n    );\n\n    String threadName = StringUtils.format(\n        \"%s-flusher-%d\",\n        getSchema().getDataSource(),\n        getConfig().getShardSpec().getPartitionNum()\n    );\n    ThreadRenamingCallable<ScheduledExecutors.Signal> threadRenamingCallable =\n        new ThreadRenamingCallable<ScheduledExecutors.Signal>(threadName)\n        {\n          @Override\n          public ScheduledExecutors.Signal doCall()\n          {\n            if (stopped) {\n              log.info(\"Stopping flusher thread\");\n              return ScheduledExecutors.Signal.STOP;\n            }\n\n            long minTimestamp = segmentGranularity.bucketStart(\n                getRejectionPolicy().getCurrMaxTime().minus(windowMillis)\n            ).getMillis();\n\n            List<Map.Entry<Long, Sink>> sinksToPush = Lists.newArrayList();\n            for (Map.Entry<Long, Sink> entry : getSinks().entrySet()) {\n              final Long intervalStart = entry.getKey();\n              if (intervalStart < minTimestamp) {\n                log.info(\"Adding entry[%s] to flush.\", entry);\n                sinksToPush.add(entry);\n              }\n            }\n\n            for (final Map.Entry<Long, Sink> entry : sinksToPush) {\n              flushAfterDuration(entry.getKey(), entry.getValue());\n            }\n\n            if (stopped) {\n              log.info(\"Stopping flusher thread\");\n              return ScheduledExecutors.Signal.STOP;\n            } else {\n              return ScheduledExecutors.Signal.REPEAT;\n            }\n          }\n        };\n    Duration initialDelay = new Duration(\n        System.currentTimeMillis(),\n        schema.getGranularitySpec().getSegmentGranularity().increment(truncatedNow).getMillis() + windowMillis\n    );\n    Duration rate = new Duration(truncatedNow, segmentGranularity.increment(truncatedNow));\n    ScheduledExecutors.scheduleAtFixedRate(flushScheduledExec, initialDelay, rate, threadRenamingCallable);\n  }\n","realPath":"server/src/main/java/org/apache/druid/segment/realtime/plumber/FlushingPlumber.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":147,"status":"B"}],"commitId":"431d3d8497f9079857c3baa7ae7ab4cb44a22355","commitMessage":"@@@Rename io.druid to org.apache.druid. (#6266)\n\n* Rename io.druid to org.apache.druid.\n\n* Fix META-INF files and remove some benchmark results.\n\n* MonitorsConfig update for metrics package migration.\n\n* Reorder some dimensions in inner queries for some reason.\n\n* Fix protobuf tests.\n","date":"2018-08-31 00:56:26","modifiedFileCount":"5","status":"B","submitter":"Gian Merlino"},{"authorTime":"2018-10-29 20:02:43","codes":[{"authorDate":"2018-08-31 00:56:26","commitOrder":2,"curCode":"  private void startPersistThread()\n  {\n    final Granularity segmentGranularity = schema.getGranularitySpec().getSegmentGranularity();\n    final Period windowPeriod = config.getWindowPeriod();\n\n    final DateTime truncatedNow = segmentGranularity.bucketStart(DateTimes.nowUtc());\n    final long windowMillis = windowPeriod.toStandardDuration().getMillis();\n\n    log.info(\n        \"Expect to run at [%s]\",\n        DateTimes.nowUtc().plus(\n            new Duration(\n                System.currentTimeMillis(),\n                segmentGranularity.increment(truncatedNow).getMillis() + windowMillis\n            )\n        )\n    );\n\n    String threadName = StringUtils.format(\n        \"%s-overseer-%d\",\n        schema.getDataSource(),\n        config.getShardSpec().getPartitionNum()\n    );\n    ThreadRenamingCallable<ScheduledExecutors.Signal> threadRenamingCallable =\n        new ThreadRenamingCallable<ScheduledExecutors.Signal>(threadName)\n        {\n          @Override\n          public ScheduledExecutors.Signal doCall()\n          {\n            if (stopped) {\n              log.info(\"Stopping merge-n-push overseer thread\");\n              return ScheduledExecutors.Signal.STOP;\n            }\n\n            mergeAndPush();\n\n            if (stopped) {\n              log.info(\"Stopping merge-n-push overseer thread\");\n              return ScheduledExecutors.Signal.STOP;\n            } else {\n              return ScheduledExecutors.Signal.REPEAT;\n            }\n          }\n        };\n    Duration initialDelay = new Duration(\n        System.currentTimeMillis(),\n        segmentGranularity.increment(truncatedNow).getMillis() + windowMillis\n    );\n    Duration rate = new Duration(truncatedNow, segmentGranularity.increment(truncatedNow));\n    ScheduledExecutors.scheduleAtFixedRate(scheduledExecutor, initialDelay, rate, threadRenamingCallable);\n  }\n","date":"2018-08-31 00:56:26","endLine":384,"groupId":"101085","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"startPersistThread","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/d0/e72e3d6d1f985379cdbd64cbed93e6321016a4.src","preCode":"  private void startPersistThread()\n  {\n    final Granularity segmentGranularity = schema.getGranularitySpec().getSegmentGranularity();\n    final Period windowPeriod = config.getWindowPeriod();\n\n    final DateTime truncatedNow = segmentGranularity.bucketStart(DateTimes.nowUtc());\n    final long windowMillis = windowPeriod.toStandardDuration().getMillis();\n\n    log.info(\n        \"Expect to run at [%s]\",\n        DateTimes.nowUtc().plus(\n            new Duration(\n                System.currentTimeMillis(),\n                segmentGranularity.increment(truncatedNow).getMillis() + windowMillis\n            )\n        )\n    );\n\n    String threadName = StringUtils.format(\n        \"%s-overseer-%d\",\n        schema.getDataSource(),\n        config.getShardSpec().getPartitionNum()\n    );\n    ThreadRenamingCallable<ScheduledExecutors.Signal> threadRenamingCallable =\n        new ThreadRenamingCallable<ScheduledExecutors.Signal>(threadName)\n        {\n          @Override\n          public ScheduledExecutors.Signal doCall()\n          {\n            if (stopped) {\n              log.info(\"Stopping merge-n-push overseer thread\");\n              return ScheduledExecutors.Signal.STOP;\n            }\n\n            mergeAndPush();\n\n            if (stopped) {\n              log.info(\"Stopping merge-n-push overseer thread\");\n              return ScheduledExecutors.Signal.STOP;\n            } else {\n              return ScheduledExecutors.Signal.REPEAT;\n            }\n          }\n        };\n    Duration initialDelay = new Duration(\n        System.currentTimeMillis(),\n        segmentGranularity.increment(truncatedNow).getMillis() + windowMillis\n    );\n    Duration rate = new Duration(truncatedNow, segmentGranularity.increment(truncatedNow));\n    ScheduledExecutors.scheduleAtFixedRate(scheduledExecutor, initialDelay, rate, threadRenamingCallable);\n  }\n","realPath":"server/src/main/java/org/apache/druid/segment/realtime/appenderator/AppenderatorPlumber.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":334,"status":"N"},{"authorDate":"2018-10-29 20:02:43","commitOrder":2,"curCode":"  private void startFlushThread()\n  {\n    final Granularity segmentGranularity = schema.getGranularitySpec().getSegmentGranularity();\n    final DateTime truncatedNow = segmentGranularity.bucketStart(DateTimes.nowUtc());\n    final long windowMillis = config.getWindowPeriod().toStandardDuration().getMillis();\n\n    log.info(\n        \"Expect to run at [%s]\",\n        DateTimes.nowUtc().plus(\n            new Duration(\n                System.currentTimeMillis(),\n                schema.getGranularitySpec().getSegmentGranularity().increment(truncatedNow).getMillis() + windowMillis\n            )\n        )\n    );\n\n    String threadName = StringUtils.format(\n        \"%s-flusher-%d\",\n        getSchema().getDataSource(),\n        getConfig().getShardSpec().getPartitionNum()\n    );\n    ThreadRenamingCallable<ScheduledExecutors.Signal> threadRenamingCallable =\n        new ThreadRenamingCallable<ScheduledExecutors.Signal>(threadName)\n        {\n          @Override\n          public ScheduledExecutors.Signal doCall()\n          {\n            if (stopped) {\n              log.info(\"Stopping flusher thread\");\n              return ScheduledExecutors.Signal.STOP;\n            }\n\n            long minTimestamp = segmentGranularity.bucketStart(\n                getRejectionPolicy().getCurrMaxTime().minus(windowMillis)\n            ).getMillis();\n\n            List<Map.Entry<Long, Sink>> sinksToPush = new ArrayList<>();\n            for (Map.Entry<Long, Sink> entry : getSinks().entrySet()) {\n              final Long intervalStart = entry.getKey();\n              if (intervalStart < minTimestamp) {\n                log.info(\"Adding entry[%s] to flush.\", entry);\n                sinksToPush.add(entry);\n              }\n            }\n\n            for (final Map.Entry<Long, Sink> entry : sinksToPush) {\n              flushAfterDuration(entry.getKey(), entry.getValue());\n            }\n\n            if (stopped) {\n              log.info(\"Stopping flusher thread\");\n              return ScheduledExecutors.Signal.STOP;\n            } else {\n              return ScheduledExecutors.Signal.REPEAT;\n            }\n          }\n        };\n    Duration initialDelay = new Duration(\n        System.currentTimeMillis(),\n        schema.getGranularitySpec().getSegmentGranularity().increment(truncatedNow).getMillis() + windowMillis\n    );\n    Duration rate = new Duration(truncatedNow, segmentGranularity.increment(truncatedNow));\n    ScheduledExecutors.scheduleAtFixedRate(flushScheduledExec, initialDelay, rate, threadRenamingCallable);\n  }\n","date":"2018-10-29 20:02:43","endLine":210,"groupId":"101085","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"startFlushThread","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/d5/52b10170e2355846dea98f0e62c08ea67f2884.src","preCode":"  private void startFlushThread()\n  {\n    final Granularity segmentGranularity = schema.getGranularitySpec().getSegmentGranularity();\n    final DateTime truncatedNow = segmentGranularity.bucketStart(DateTimes.nowUtc());\n    final long windowMillis = config.getWindowPeriod().toStandardDuration().getMillis();\n\n    log.info(\n        \"Expect to run at [%s]\",\n        DateTimes.nowUtc().plus(\n            new Duration(\n                System.currentTimeMillis(),\n                schema.getGranularitySpec().getSegmentGranularity().increment(truncatedNow).getMillis() + windowMillis\n            )\n        )\n    );\n\n    String threadName = StringUtils.format(\n        \"%s-flusher-%d\",\n        getSchema().getDataSource(),\n        getConfig().getShardSpec().getPartitionNum()\n    );\n    ThreadRenamingCallable<ScheduledExecutors.Signal> threadRenamingCallable =\n        new ThreadRenamingCallable<ScheduledExecutors.Signal>(threadName)\n        {\n          @Override\n          public ScheduledExecutors.Signal doCall()\n          {\n            if (stopped) {\n              log.info(\"Stopping flusher thread\");\n              return ScheduledExecutors.Signal.STOP;\n            }\n\n            long minTimestamp = segmentGranularity.bucketStart(\n                getRejectionPolicy().getCurrMaxTime().minus(windowMillis)\n            ).getMillis();\n\n            List<Map.Entry<Long, Sink>> sinksToPush = Lists.newArrayList();\n            for (Map.Entry<Long, Sink> entry : getSinks().entrySet()) {\n              final Long intervalStart = entry.getKey();\n              if (intervalStart < minTimestamp) {\n                log.info(\"Adding entry[%s] to flush.\", entry);\n                sinksToPush.add(entry);\n              }\n            }\n\n            for (final Map.Entry<Long, Sink> entry : sinksToPush) {\n              flushAfterDuration(entry.getKey(), entry.getValue());\n            }\n\n            if (stopped) {\n              log.info(\"Stopping flusher thread\");\n              return ScheduledExecutors.Signal.STOP;\n            } else {\n              return ScheduledExecutors.Signal.REPEAT;\n            }\n          }\n        };\n    Duration initialDelay = new Duration(\n        System.currentTimeMillis(),\n        schema.getGranularitySpec().getSegmentGranularity().increment(truncatedNow).getMillis() + windowMillis\n    );\n    Duration rate = new Duration(truncatedNow, segmentGranularity.increment(truncatedNow));\n    ScheduledExecutors.scheduleAtFixedRate(flushScheduledExec, initialDelay, rate, threadRenamingCallable);\n  }\n","realPath":"server/src/main/java/org/apache/druid/segment/realtime/plumber/FlushingPlumber.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":147,"status":"M"}],"commitId":"676f5e6d7f184101b8763e4249b18b237bbe0ec7","commitMessage":"@@@Prohibit some guava collection APIs and use JDK collection APIs directly (#6511)\n\n* Prohibit some guava collection APIs and use JDK APIs directly\n\n* reset files that changed by accident\n\n* sort codestyle/druid-forbidden-apis.txt alphabetically\n","date":"2018-10-29 20:02:43","modifiedFileCount":"427","status":"M","submitter":"QiuMM"}]
