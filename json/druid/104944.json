[{"authorTime":"2019-06-20 04:57:37","codes":[{"authorDate":"2019-06-20 04:57:37","commitOrder":1,"curCode":"  public void testMap()\n  {\n    assertExpr(\"map((x) -> concat(x, 'foo'), ['foo', 'bar', 'baz', 'foobar'])\", new String[] {\"foofoo\", \"barfoo\", \"bazfoo\", \"foobarfoo\"});\n    assertExpr(\"map((x) -> concat(x, 'foo'), a)\", new String[] {\"foofoo\", \"barfoo\", \"bazfoo\", \"foobarfoo\"});\n\n    assertExpr(\"map((x) -> x + 1, [1, 2, 3, 4, 5])\", new Long[] {2L, 3L, 4L, 5L, 6L});\n    assertExpr(\"map((x) -> x + 1, b)\", new Long[] {2L, 3L, 4L, 5L, 6L});\n\n    assertExpr(\"map((c) -> c + z, [3.1, 4.2, 5.3])\", new Double[]{6.2, 7.3, 8.4});\n    assertExpr(\"map((c) -> c + z, c)\", new Double[]{6.2, 7.3, 8.4});\n\n    assertExpr(\"map((x) -> x + 1, map((x) -> x + 1, [1, 2, 3, 4, 5]))\", new Long[] {3L, 4L, 5L, 6L, 7L});\n    assertExpr(\"map((x) -> x + 1, map((x) -> x + 1, b))\", new Long[] {3L, 4L, 5L, 6L, 7L});\n    assertExpr(\"map(() -> 1, [1, 2, 3, 4, 5])\", new Long[] {1L, 1L, 1L, 1L, 1L});\n  }\n","date":"2019-06-20 04:57:37","endLine":68,"groupId":"10896","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testMap","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/57/c937df6ca3ed03d10bd6ed6f771ce8e2d18df8.src","preCode":"  public void testMap()\n  {\n    assertExpr(\"map((x) -> concat(x, 'foo'), ['foo', 'bar', 'baz', 'foobar'])\", new String[] {\"foofoo\", \"barfoo\", \"bazfoo\", \"foobarfoo\"});\n    assertExpr(\"map((x) -> concat(x, 'foo'), a)\", new String[] {\"foofoo\", \"barfoo\", \"bazfoo\", \"foobarfoo\"});\n\n    assertExpr(\"map((x) -> x + 1, [1, 2, 3, 4, 5])\", new Long[] {2L, 3L, 4L, 5L, 6L});\n    assertExpr(\"map((x) -> x + 1, b)\", new Long[] {2L, 3L, 4L, 5L, 6L});\n\n    assertExpr(\"map((c) -> c + z, [3.1, 4.2, 5.3])\", new Double[]{6.2, 7.3, 8.4});\n    assertExpr(\"map((c) -> c + z, c)\", new Double[]{6.2, 7.3, 8.4});\n\n    assertExpr(\"map((x) -> x + 1, map((x) -> x + 1, [1, 2, 3, 4, 5]))\", new Long[] {3L, 4L, 5L, 6L, 7L});\n    assertExpr(\"map((x) -> x + 1, map((x) -> x + 1, b))\", new Long[] {3L, 4L, 5L, 6L, 7L});\n    assertExpr(\"map(() -> 1, [1, 2, 3, 4, 5])\", new Long[] {1L, 1L, 1L, 1L, 1L});\n  }\n","realPath":"core/src/test/java/org/apache/druid/math/expr/ApplyFunctionTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":54,"status":"B"},{"authorDate":"2019-06-20 04:57:37","commitOrder":1,"curCode":"  public void testFold()\n  {\n    assertExpr(\"fold((x, y) -> x + y, [1, 1, 1, 1, 1], 0)\", 5L);\n    assertExpr(\"fold((b, acc) -> b * acc, map((b) -> b * 2, filter(b -> b > 3, b)), 1)\", 80L);\n    assertExpr(\"fold((a, acc) -> concat(a, acc), a, '')\", \"foobarbazbarfoo\");\n    assertExpr(\"fold((a, acc) -> array_append(acc, a), a, [])\", new String[]{\"foo\", \"bar\", \"baz\", \"foobar\"});\n    assertExpr(\"fold((a, acc) -> array_append(acc, a), b, cast([], 'LONG_ARRAY'))\", new Long[]{1L, 2L, 3L, 4L, 5L});\n  }\n","date":"2019-06-20 04:57:37","endLine":105,"groupId":"872","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testFold","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/57/c937df6ca3ed03d10bd6ed6f771ce8e2d18df8.src","preCode":"  public void testFold()\n  {\n    assertExpr(\"fold((x, y) -> x + y, [1, 1, 1, 1, 1], 0)\", 5L);\n    assertExpr(\"fold((b, acc) -> b * acc, map((b) -> b * 2, filter(b -> b > 3, b)), 1)\", 80L);\n    assertExpr(\"fold((a, acc) -> concat(a, acc), a, '')\", \"foobarbazbarfoo\");\n    assertExpr(\"fold((a, acc) -> array_append(acc, a), a, [])\", new String[]{\"foo\", \"bar\", \"baz\", \"foobar\"});\n    assertExpr(\"fold((a, acc) -> array_append(acc, a), b, cast([], 'LONG_ARRAY'))\", new Long[]{1L, 2L, 3L, 4L, 5L});\n  }\n","realPath":"core/src/test/java/org/apache/druid/math/expr/ApplyFunctionTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":98,"status":"B"}],"commitId":"494b8ebe56308fe69c2a758f80f1ae56bf17d54d","commitMessage":"@@@multi-value string column support for expressions (#7588)\n\n* array support for expression language for multi-value string columns\n\n* fix tests?\n\n* fixes\n\n* more tests\n\n* fixes\n\n* cleanup\n\n* more better.  more test\n\n* ignore inspection\n\n* license\n\n* license fix\n\n* inspection\n\n* remove dumb import\n\n* more better\n\n* some comments\n\n* add expr rewrite for arrayfn args for more magic.  tests\n\n* test stuff\n\n* more tests\n\n* fix test\n\n* fix test\n\n* castfunc can deal with arrays\n\n* needs more empty array\n\n* more tests.  make cast to long array more forgiving\n\n* refactor\n\n* simplify ExprMacro Expr implementations with base classes in core\n\n* oops\n\n* more test\n\n* use Shuttle for Parser.flatten.  javadoc.  cleanup\n\n* fixes and more tests\n\n* unused import\n\n* fixes\n\n* javadocs.  cleanup.  refactors\n\n* fix imports\n\n* more javadoc\n\n* more javadoc\n\n* more\n\n* more javadocs.  nonnullbydefault.  minor refactor\n\n* markdown fix\n\n* adjustments\n\n* more doc\n\n* move initial filter out\n\n* docs\n\n* map empty arg lambda.  apply function argument validation\n\n* check function args at parse time instead of eval time\n\n* more immutable\n\n* more more immutable\n\n* clarify grammar\n\n* fix docs\n\n* empty array is string test.  we need a way to make arrays better maybe in the future.  or define empty arrays as other types..\n","date":"2019-06-20 04:57:37","modifiedFileCount":"43","status":"B","submitter":"Clint Wylie"},{"authorTime":"2020-02-22 07:43:02","codes":[{"authorDate":"2019-06-20 04:57:37","commitOrder":2,"curCode":"  public void testMap()\n  {\n    assertExpr(\"map((x) -> concat(x, 'foo'), ['foo', 'bar', 'baz', 'foobar'])\", new String[] {\"foofoo\", \"barfoo\", \"bazfoo\", \"foobarfoo\"});\n    assertExpr(\"map((x) -> concat(x, 'foo'), a)\", new String[] {\"foofoo\", \"barfoo\", \"bazfoo\", \"foobarfoo\"});\n\n    assertExpr(\"map((x) -> x + 1, [1, 2, 3, 4, 5])\", new Long[] {2L, 3L, 4L, 5L, 6L});\n    assertExpr(\"map((x) -> x + 1, b)\", new Long[] {2L, 3L, 4L, 5L, 6L});\n\n    assertExpr(\"map((c) -> c + z, [3.1, 4.2, 5.3])\", new Double[]{6.2, 7.3, 8.4});\n    assertExpr(\"map((c) -> c + z, c)\", new Double[]{6.2, 7.3, 8.4});\n\n    assertExpr(\"map((x) -> x + 1, map((x) -> x + 1, [1, 2, 3, 4, 5]))\", new Long[] {3L, 4L, 5L, 6L, 7L});\n    assertExpr(\"map((x) -> x + 1, map((x) -> x + 1, b))\", new Long[] {3L, 4L, 5L, 6L, 7L});\n    assertExpr(\"map(() -> 1, [1, 2, 3, 4, 5])\", new Long[] {1L, 1L, 1L, 1L, 1L});\n  }\n","date":"2019-06-20 04:57:37","endLine":68,"groupId":"104944","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testMap","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/57/c937df6ca3ed03d10bd6ed6f771ce8e2d18df8.src","preCode":"  public void testMap()\n  {\n    assertExpr(\"map((x) -> concat(x, 'foo'), ['foo', 'bar', 'baz', 'foobar'])\", new String[] {\"foofoo\", \"barfoo\", \"bazfoo\", \"foobarfoo\"});\n    assertExpr(\"map((x) -> concat(x, 'foo'), a)\", new String[] {\"foofoo\", \"barfoo\", \"bazfoo\", \"foobarfoo\"});\n\n    assertExpr(\"map((x) -> x + 1, [1, 2, 3, 4, 5])\", new Long[] {2L, 3L, 4L, 5L, 6L});\n    assertExpr(\"map((x) -> x + 1, b)\", new Long[] {2L, 3L, 4L, 5L, 6L});\n\n    assertExpr(\"map((c) -> c + z, [3.1, 4.2, 5.3])\", new Double[]{6.2, 7.3, 8.4});\n    assertExpr(\"map((c) -> c + z, c)\", new Double[]{6.2, 7.3, 8.4});\n\n    assertExpr(\"map((x) -> x + 1, map((x) -> x + 1, [1, 2, 3, 4, 5]))\", new Long[] {3L, 4L, 5L, 6L, 7L});\n    assertExpr(\"map((x) -> x + 1, map((x) -> x + 1, b))\", new Long[] {3L, 4L, 5L, 6L, 7L});\n    assertExpr(\"map(() -> 1, [1, 2, 3, 4, 5])\", new Long[] {1L, 1L, 1L, 1L, 1L});\n  }\n","realPath":"core/src/test/java/org/apache/druid/math/expr/ApplyFunctionTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":54,"status":"N"},{"authorDate":"2020-02-22 07:43:02","commitOrder":2,"curCode":"  public void testFold()\n  {\n    assertExpr(\"fold((x, y) -> x + y, [1, 1, 1, 1, 1], 0)\", 5L);\n    assertExpr(\"fold((b, acc) -> b * acc, map((b) -> b * 2, filter(b -> b > 3, b)), 1)\", 80L);\n    assertExpr(\"fold((a, acc) -> concat(a, acc), a, '')\", \"foobarbazbarfoo\");\n    assertExpr(\"fold((a, acc) -> array_append(acc, a), a, [])\", new String[]{\"foo\", \"bar\", \"baz\", \"foobar\"});\n    assertExpr(\"fold((a, acc) -> array_append(acc, a), b, <LONG>[])\", new Long[]{1L, 2L, 3L, 4L, 5L});\n  }\n","date":"2020-02-22 07:43:02","endLine":106,"groupId":"104944","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testFold","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/8d/ea860b33cb7a3f9915d1ece4fcef3d11899147.src","preCode":"  public void testFold()\n  {\n    assertExpr(\"fold((x, y) -> x + y, [1, 1, 1, 1, 1], 0)\", 5L);\n    assertExpr(\"fold((b, acc) -> b * acc, map((b) -> b * 2, filter(b -> b > 3, b)), 1)\", 80L);\n    assertExpr(\"fold((a, acc) -> concat(a, acc), a, '')\", \"foobarbazbarfoo\");\n    assertExpr(\"fold((a, acc) -> array_append(acc, a), a, [])\", new String[]{\"foo\", \"bar\", \"baz\", \"foobar\"});\n    assertExpr(\"fold((a, acc) -> array_append(acc, a), b, cast([], 'LONG_ARRAY'))\", new Long[]{1L, 2L, 3L, 4L, 5L});\n  }\n","realPath":"core/src/test/java/org/apache/druid/math/expr/ApplyFunctionTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":99,"status":"M"}],"commitId":"6d8dd5ec10042a827aca20429b3ea19dd39b5827","commitMessage":"@@@string -> expression -> string -> expression (#9367)\n\n* add Expr.stringify which produces parseable expression strings.  parser support for null values in arrays.  and parser support for empty numeric arrays\n\n* oops.  macros are expressions too\n\n* style\n\n* spotbugs\n\n* qualified type arrays\n\n* review stuffs\n\n* simplify grammar\n\n* more permissive array parsing\n\n* reuse expr joiner\n\n* fix it\n","date":"2020-02-22 07:43:02","modifiedFileCount":"28","status":"M","submitter":"Clint Wylie"}]
