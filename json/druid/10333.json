[{"authorTime":"2020-01-28 03:24:29","codes":[{"authorDate":"2020-01-28 03:24:29","commitOrder":1,"curCode":"  public void testMoveDecommissioningMaxPercentOfMaxSegmentsToMove()\n  {\n    mockDruidServer(druidServer1, \"1\", \"normal\", 30L, 100L, Arrays.asList(segment1, segment2));\n    mockDruidServer(druidServer2, \"2\", \"normal\", 30L, 100L, Arrays.asList(segment3, segment4));\n    mockDruidServer(druidServer3, \"3\", \"normal\", 0L, 100L, Collections.emptyList());\n\n    EasyMock.replay(druidServer4);\n\n    mockCoordinator(coordinator);\n\n    BalancerStrategy strategy = EasyMock.createMock(BalancerStrategy.class);\n    EasyMock.expect(strategy.pickSegmentToMove(ImmutableList.of(new ServerHolder(druidServer2, peon2, false))))\n            .andReturn(new BalancerSegmentHolder(druidServer2, segment3))\n            .andReturn(new BalancerSegmentHolder(druidServer2, segment4));\n    EasyMock.expect(strategy.pickSegmentToMove(EasyMock.anyObject()))\n            .andReturn(new BalancerSegmentHolder(druidServer1, segment1))\n            .andReturn(new BalancerSegmentHolder(druidServer1, segment2));\n\n    EasyMock.expect(strategy.findNewSegmentHomeBalancer(EasyMock.anyObject(), EasyMock.anyObject()))\n            .andReturn(new ServerHolder(druidServer3, peon3))\n            .anyTimes();\n    EasyMock.replay(strategy);\n\n    DruidCoordinatorRuntimeParams params = defaultRuntimeParamsBuilder(\n        ImmutableList.of(druidServer1, druidServer2, druidServer3),\n        ImmutableList.of(peon1, peon2, peon3),\n        ImmutableList.of(false, true, false)\n    )\n        .withDynamicConfigs(\n            CoordinatorDynamicConfig.builder()\n                                    .withMaxSegmentsToMove(3)\n                                    .withDecommissioningMaxPercentOfMaxSegmentsToMove(60)\n                                    .build() \r\n        )\n        .withBalancerStrategy(strategy)\n        .build();\n\n    params = new BalanceSegmentsTester(coordinator).run(params);\n    Assert.assertEquals(3L, params.getCoordinatorStats().getTieredStat(\"movedCount\", \"normal\"));\n    Assert.assertThat(\n        peon3.getSegmentsToLoad(),\n        Matchers.is(Matchers.equalTo(ImmutableSet.of(segment1, segment3, segment4)))\n    );\n  }\n","date":"2020-01-28 03:24:29","endLine":248,"groupId":"823","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testMoveDecommissioningMaxPercentOfMaxSegmentsToMove","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/08/4a119ebe76699a11d118edab55ecb57e199ccd.src","preCode":"  public void testMoveDecommissioningMaxPercentOfMaxSegmentsToMove()\n  {\n    mockDruidServer(druidServer1, \"1\", \"normal\", 30L, 100L, Arrays.asList(segment1, segment2));\n    mockDruidServer(druidServer2, \"2\", \"normal\", 30L, 100L, Arrays.asList(segment3, segment4));\n    mockDruidServer(druidServer3, \"3\", \"normal\", 0L, 100L, Collections.emptyList());\n\n    EasyMock.replay(druidServer4);\n\n    mockCoordinator(coordinator);\n\n    BalancerStrategy strategy = EasyMock.createMock(BalancerStrategy.class);\n    EasyMock.expect(strategy.pickSegmentToMove(ImmutableList.of(new ServerHolder(druidServer2, peon2, false))))\n            .andReturn(new BalancerSegmentHolder(druidServer2, segment3))\n            .andReturn(new BalancerSegmentHolder(druidServer2, segment4));\n    EasyMock.expect(strategy.pickSegmentToMove(EasyMock.anyObject()))\n            .andReturn(new BalancerSegmentHolder(druidServer1, segment1))\n            .andReturn(new BalancerSegmentHolder(druidServer1, segment2));\n\n    EasyMock.expect(strategy.findNewSegmentHomeBalancer(EasyMock.anyObject(), EasyMock.anyObject()))\n            .andReturn(new ServerHolder(druidServer3, peon3))\n            .anyTimes();\n    EasyMock.replay(strategy);\n\n    DruidCoordinatorRuntimeParams params = defaultRuntimeParamsBuilder(\n        ImmutableList.of(druidServer1, druidServer2, druidServer3),\n        ImmutableList.of(peon1, peon2, peon3),\n        ImmutableList.of(false, true, false)\n    )\n        .withDynamicConfigs(\n            CoordinatorDynamicConfig.builder()\n                                    .withMaxSegmentsToMove(3)\n                                    .withDecommissioningMaxPercentOfMaxSegmentsToMove(60)\n                                    .build() \r\n        )\n        .withBalancerStrategy(strategy)\n        .build();\n\n    params = new BalanceSegmentsTester(coordinator).run(params);\n    Assert.assertEquals(3L, params.getCoordinatorStats().getTieredStat(\"movedCount\", \"normal\"));\n    Assert.assertThat(\n        peon3.getSegmentsToLoad(),\n        Matchers.is(Matchers.equalTo(ImmutableSet.of(segment1, segment3, segment4)))\n    );\n  }\n","realPath":"server/src/test/java/org/apache/druid/server/coordinator/BalanceSegmentsTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":205,"status":"B"},{"authorDate":"2020-01-28 03:24:29","commitOrder":1,"curCode":"  private DruidCoordinatorRuntimeParams setupParamsForDecommissioningMaxPercentOfMaxSegmentsToMove(int percent)\n  {\n    mockDruidServer(druidServer1, \"1\", \"normal\", 30L, 100L, Arrays.asList(segment1, segment3));\n    mockDruidServer(druidServer2, \"2\", \"normal\", 30L, 100L, Arrays.asList(segment2, segment3));\n    mockDruidServer(druidServer3, \"3\", \"normal\", 0L, 100L, Collections.emptyList());\n\n    EasyMock.replay(druidServer4);\n\n    mockCoordinator(coordinator);\n\n    \r\n    BalancerStrategy strategy = EasyMock.createMock(BalancerStrategy.class);\n    EasyMock.expect(strategy.pickSegmentToMove(ImmutableList.of(new ServerHolder(druidServer2, peon2, true))))\n            .andReturn(new BalancerSegmentHolder(druidServer2, segment2));\n    EasyMock.expect(strategy.pickSegmentToMove(EasyMock.anyObject()))\n            .andReturn(new BalancerSegmentHolder(druidServer1, segment1));\n    EasyMock.expect(strategy.findNewSegmentHomeBalancer(EasyMock.anyObject(), EasyMock.anyObject()))\n            .andReturn(new ServerHolder(druidServer3, peon3))\n            .anyTimes();\n    EasyMock.replay(strategy);\n\n    return defaultRuntimeParamsBuilder(\n        ImmutableList.of(druidServer1, druidServer2, druidServer3),\n        ImmutableList.of(peon1, peon2, peon3),\n        ImmutableList.of(false, true, false)\n    )\n        .withDynamicConfigs(\n            CoordinatorDynamicConfig.builder()\n                                    .withMaxSegmentsToMove(1)\n                                    .withDecommissioningMaxPercentOfMaxSegmentsToMove(percent)\n                                    .build()\n        )\n        .withBalancerStrategy(strategy)\n        .build();\n  }\n","date":"2020-01-28 03:24:29","endLine":660,"groupId":"832","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"setupParamsForDecommissioningMaxPercentOfMaxSegmentsToMove","params":"(intpercent)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/08/4a119ebe76699a11d118edab55ecb57e199ccd.src","preCode":"  private DruidCoordinatorRuntimeParams setupParamsForDecommissioningMaxPercentOfMaxSegmentsToMove(int percent)\n  {\n    mockDruidServer(druidServer1, \"1\", \"normal\", 30L, 100L, Arrays.asList(segment1, segment3));\n    mockDruidServer(druidServer2, \"2\", \"normal\", 30L, 100L, Arrays.asList(segment2, segment3));\n    mockDruidServer(druidServer3, \"3\", \"normal\", 0L, 100L, Collections.emptyList());\n\n    EasyMock.replay(druidServer4);\n\n    mockCoordinator(coordinator);\n\n    \r\n    BalancerStrategy strategy = EasyMock.createMock(BalancerStrategy.class);\n    EasyMock.expect(strategy.pickSegmentToMove(ImmutableList.of(new ServerHolder(druidServer2, peon2, true))))\n            .andReturn(new BalancerSegmentHolder(druidServer2, segment2));\n    EasyMock.expect(strategy.pickSegmentToMove(EasyMock.anyObject()))\n            .andReturn(new BalancerSegmentHolder(druidServer1, segment1));\n    EasyMock.expect(strategy.findNewSegmentHomeBalancer(EasyMock.anyObject(), EasyMock.anyObject()))\n            .andReturn(new ServerHolder(druidServer3, peon3))\n            .anyTimes();\n    EasyMock.replay(strategy);\n\n    return defaultRuntimeParamsBuilder(\n        ImmutableList.of(druidServer1, druidServer2, druidServer3),\n        ImmutableList.of(peon1, peon2, peon3),\n        ImmutableList.of(false, true, false)\n    )\n        .withDynamicConfigs(\n            CoordinatorDynamicConfig.builder()\n                                    .withMaxSegmentsToMove(1)\n                                    .withDecommissioningMaxPercentOfMaxSegmentsToMove(percent)\n                                    .build()\n        )\n        .withBalancerStrategy(strategy)\n        .build();\n  }\n","realPath":"server/src/test/java/org/apache/druid/server/coordinator/BalanceSegmentsTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":626,"status":"B"}],"commitId":"b9186f8f9ff2ff52aceda42bc5f24ffd47a7d17e","commitMessage":"@@@Reconcile terminology and method naming to 'used/unused segments'; Rename MetadataSegmentManager to MetadataSegmentsManager (#7306)\n\n* Reconcile terminology and method naming to 'used/unused segments'; Don't use terms 'enable/disable data source'; Rename MetadataSegmentManager to MetadataSegments; Make REST API methods which mark segments as used/unused to return server error instead of an empty response in case of error\n\n* Fix brace\n\n* Import order\n\n* Rename withKillDataSourceWhitelist to withSpecificDataSourcesToKill\n\n* Fix tests\n\n* Fix tests by adding proper methods without interval parameters to IndexerMetadataStorageCoordinator instead of hacking with Intervals.ETERNITY\n\n* More aligned names of DruidCoordinatorHelpers.  rename several CoordinatorDynamicConfig parameters\n\n* Rename ClientCompactTaskQuery to ClientCompactionTaskQuery for consistency with CompactionTask; ClientCompactQueryTuningConfig to ClientCompactionTaskQueryTuningConfig\n\n* More variable and method renames\n\n* Rename MetadataSegments to SegmentsMetadata\n\n* Javadoc update\n\n* Simplify SegmentsMetadata.getUnusedSegmentIntervals().  more javadocs\n\n* Update Javadoc of VersionedIntervalTimeline.iterateAllObjects()\n\n* Reorder imports\n\n* Rename SegmentsMetadata.tryMark... methods to mark... and make them to return boolean and the numbers of segments changed and relay exceptions to callers\n\n* Complete merge\n\n* Add CollectionUtils.newTreeSet(); Refactor DruidCoordinatorRuntimeParams creation in tests\n\n* Remove MetadataSegmentManager\n\n* Rename millisLagSinceCoordinatorBecomesLeaderBeforeCanMarkAsUnusedOvershadowedSegments to leadingTimeMillisBeforeCanMarkAsUnusedOvershadowedSegments\n\n* Fix tests.  refactor DruidCluster creation in tests into DruidClusterBuilder\n\n* Fix inspections\n\n* Fix SQLMetadataSegmentManagerEmptyTest and rename it to SqlSegmentsMetadataEmptyTest\n\n* Rename SegmentsAndMetadata to SegmentsAndCommitMetadata to reduce the similarity with SegmentsMetadata; Rename some methods\n\n* Rename DruidCoordinatorHelper to CoordinatorDuty.  refactor DruidCoordinator\n\n* Unused import\n\n* Optimize imports\n\n* Rename IndexerSQLMetadataStorageCoordinator.getDataSourceMetadata() to retrieveDataSourceMetadata()\n\n* Unused import\n\n* Update terminology in datasource-view.tsx\n\n* Fix label in datasource-view.spec.tsx.snap\n\n* Fix lint errors in datasource-view.tsx\n\n* Doc improvements\n\n* Another attempt to please TSLint\n\n* Another attempt to please TSLint\n\n* Style fixes\n\n* Fix IndexerSQLMetadataStorageCoordinator.createUsedSegmentsSqlQueryForIntervals() (wrong merge)\n\n* Try to fix docs build issue\n\n* Javadoc and spelling fixes\n\n* Rename SegmentsMetadata to SegmentsMetadataManager.  address other comments\n\n* Address more comments\n","date":"2020-01-28 03:24:29","modifiedFileCount":"127","status":"B","submitter":"Roman Leventov"},{"authorTime":"2020-06-09 11:15:59","codes":[{"authorDate":"2020-06-09 11:15:59","commitOrder":2,"curCode":"  public void testMoveDecommissioningMaxPercentOfMaxSegmentsToMove()\n  {\n    mockDruidServer(druidServer1, \"1\", \"normal\", 30L, 100L, Arrays.asList(segment1, segment2));\n    mockDruidServer(druidServer2, \"2\", \"normal\", 30L, 100L, Arrays.asList(segment3, segment4));\n    mockDruidServer(druidServer3, \"3\", \"normal\", 0L, 100L, Collections.emptyList());\n\n    EasyMock.replay(druidServer4);\n\n    mockCoordinator(coordinator);\n\n    BalancerStrategy strategy = EasyMock.createMock(BalancerStrategy.class);\n    EasyMock.expect(strategy.pickSegmentToMove(ImmutableList.of(new ServerHolder(druidServer2, peon2, false)), broadcastDatasources))\n            .andReturn(new BalancerSegmentHolder(druidServer2, segment3))\n            .andReturn(new BalancerSegmentHolder(druidServer2, segment4));\n    EasyMock.expect(strategy.pickSegmentToMove(EasyMock.anyObject(), EasyMock.anyObject()))\n            .andReturn(new BalancerSegmentHolder(druidServer1, segment1))\n            .andReturn(new BalancerSegmentHolder(druidServer1, segment2));\n\n    EasyMock.expect(strategy.findNewSegmentHomeBalancer(EasyMock.anyObject(), EasyMock.anyObject()))\n            .andReturn(new ServerHolder(druidServer3, peon3))\n            .anyTimes();\n    EasyMock.replay(strategy);\n\n    DruidCoordinatorRuntimeParams params = defaultRuntimeParamsBuilder(\n        ImmutableList.of(druidServer1, druidServer2, druidServer3),\n        ImmutableList.of(peon1, peon2, peon3),\n        ImmutableList.of(false, true, false)\n    )\n        .withDynamicConfigs(\n            CoordinatorDynamicConfig.builder()\n                                    .withMaxSegmentsToMove(3)\n                                    .withDecommissioningMaxPercentOfMaxSegmentsToMove(60)\n                                    .build() \r\n        )\n        .withBalancerStrategy(strategy)\n        .withBroadcastDatasources(broadcastDatasources)\n        .build();\n\n    params = new BalanceSegmentsTester(coordinator).run(params);\n    Assert.assertEquals(3L, params.getCoordinatorStats().getTieredStat(\"movedCount\", \"normal\"));\n    Assert.assertThat(\n        peon3.getSegmentsToLoad(),\n        Matchers.is(Matchers.equalTo(ImmutableSet.of(segment1, segment3, segment4)))\n    );\n  }\n","date":"2020-06-09 11:15:59","endLine":268,"groupId":"21234","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testMoveDecommissioningMaxPercentOfMaxSegmentsToMove","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/f3/7c92cb1056d5ae797c8c3cdc376a95384208fa.src","preCode":"  public void testMoveDecommissioningMaxPercentOfMaxSegmentsToMove()\n  {\n    mockDruidServer(druidServer1, \"1\", \"normal\", 30L, 100L, Arrays.asList(segment1, segment2));\n    mockDruidServer(druidServer2, \"2\", \"normal\", 30L, 100L, Arrays.asList(segment3, segment4));\n    mockDruidServer(druidServer3, \"3\", \"normal\", 0L, 100L, Collections.emptyList());\n\n    EasyMock.replay(druidServer4);\n\n    mockCoordinator(coordinator);\n\n    BalancerStrategy strategy = EasyMock.createMock(BalancerStrategy.class);\n    EasyMock.expect(strategy.pickSegmentToMove(ImmutableList.of(new ServerHolder(druidServer2, peon2, false))))\n            .andReturn(new BalancerSegmentHolder(druidServer2, segment3))\n            .andReturn(new BalancerSegmentHolder(druidServer2, segment4));\n    EasyMock.expect(strategy.pickSegmentToMove(EasyMock.anyObject()))\n            .andReturn(new BalancerSegmentHolder(druidServer1, segment1))\n            .andReturn(new BalancerSegmentHolder(druidServer1, segment2));\n\n    EasyMock.expect(strategy.findNewSegmentHomeBalancer(EasyMock.anyObject(), EasyMock.anyObject()))\n            .andReturn(new ServerHolder(druidServer3, peon3))\n            .anyTimes();\n    EasyMock.replay(strategy);\n\n    DruidCoordinatorRuntimeParams params = defaultRuntimeParamsBuilder(\n        ImmutableList.of(druidServer1, druidServer2, druidServer3),\n        ImmutableList.of(peon1, peon2, peon3),\n        ImmutableList.of(false, true, false)\n    )\n        .withDynamicConfigs(\n            CoordinatorDynamicConfig.builder()\n                                    .withMaxSegmentsToMove(3)\n                                    .withDecommissioningMaxPercentOfMaxSegmentsToMove(60)\n                                    .build() \r\n        )\n        .withBalancerStrategy(strategy)\n        .build();\n\n    params = new BalanceSegmentsTester(coordinator).run(params);\n    Assert.assertEquals(3L, params.getCoordinatorStats().getTieredStat(\"movedCount\", \"normal\"));\n    Assert.assertThat(\n        peon3.getSegmentsToLoad(),\n        Matchers.is(Matchers.equalTo(ImmutableSet.of(segment1, segment3, segment4)))\n    );\n  }\n","realPath":"server/src/test/java/org/apache/druid/server/coordinator/BalanceSegmentsTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":224,"status":"M"},{"authorDate":"2020-06-09 11:15:59","commitOrder":2,"curCode":"  private DruidCoordinatorRuntimeParams setupParamsForDecommissioningMaxPercentOfMaxSegmentsToMove(int percent)\n  {\n    mockDruidServer(druidServer1, \"1\", \"normal\", 30L, 100L, Arrays.asList(segment1, segment3));\n    mockDruidServer(druidServer2, \"2\", \"normal\", 30L, 100L, Arrays.asList(segment2, segment3));\n    mockDruidServer(druidServer3, \"3\", \"normal\", 0L, 100L, Collections.emptyList());\n\n    EasyMock.replay(druidServer4);\n\n    mockCoordinator(coordinator);\n\n    \r\n    BalancerStrategy strategy = EasyMock.createMock(BalancerStrategy.class);\n    EasyMock.expect(strategy.pickSegmentToMove(ImmutableList.of(new ServerHolder(druidServer2, peon2, true)), broadcastDatasources))\n            .andReturn(new BalancerSegmentHolder(druidServer2, segment2));\n    EasyMock.expect(strategy.pickSegmentToMove(EasyMock.anyObject(), EasyMock.anyObject()))\n            .andReturn(new BalancerSegmentHolder(druidServer1, segment1));\n    EasyMock.expect(strategy.findNewSegmentHomeBalancer(EasyMock.anyObject(), EasyMock.anyObject()))\n            .andReturn(new ServerHolder(druidServer3, peon3))\n            .anyTimes();\n    EasyMock.replay(strategy);\n\n    return defaultRuntimeParamsBuilder(\n        ImmutableList.of(druidServer1, druidServer2, druidServer3),\n        ImmutableList.of(peon1, peon2, peon3),\n        ImmutableList.of(false, true, false)\n    )\n        .withDynamicConfigs(\n            CoordinatorDynamicConfig.builder()\n                                    .withMaxSegmentsToMove(1)\n                                    .withDecommissioningMaxPercentOfMaxSegmentsToMove(percent)\n                                    .build()\n        )\n        .withBalancerStrategy(strategy)\n        .withBroadcastDatasources(broadcastDatasources)\n        .build();\n  }\n","date":"2020-06-09 11:15:59","endLine":687,"groupId":"15751","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"setupParamsForDecommissioningMaxPercentOfMaxSegmentsToMove","params":"(intpercent)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/f3/7c92cb1056d5ae797c8c3cdc376a95384208fa.src","preCode":"  private DruidCoordinatorRuntimeParams setupParamsForDecommissioningMaxPercentOfMaxSegmentsToMove(int percent)\n  {\n    mockDruidServer(druidServer1, \"1\", \"normal\", 30L, 100L, Arrays.asList(segment1, segment3));\n    mockDruidServer(druidServer2, \"2\", \"normal\", 30L, 100L, Arrays.asList(segment2, segment3));\n    mockDruidServer(druidServer3, \"3\", \"normal\", 0L, 100L, Collections.emptyList());\n\n    EasyMock.replay(druidServer4);\n\n    mockCoordinator(coordinator);\n\n    \r\n    BalancerStrategy strategy = EasyMock.createMock(BalancerStrategy.class);\n    EasyMock.expect(strategy.pickSegmentToMove(ImmutableList.of(new ServerHolder(druidServer2, peon2, true))))\n            .andReturn(new BalancerSegmentHolder(druidServer2, segment2));\n    EasyMock.expect(strategy.pickSegmentToMove(EasyMock.anyObject()))\n            .andReturn(new BalancerSegmentHolder(druidServer1, segment1));\n    EasyMock.expect(strategy.findNewSegmentHomeBalancer(EasyMock.anyObject(), EasyMock.anyObject()))\n            .andReturn(new ServerHolder(druidServer3, peon3))\n            .anyTimes();\n    EasyMock.replay(strategy);\n\n    return defaultRuntimeParamsBuilder(\n        ImmutableList.of(druidServer1, druidServer2, druidServer3),\n        ImmutableList.of(peon1, peon2, peon3),\n        ImmutableList.of(false, true, false)\n    )\n        .withDynamicConfigs(\n            CoordinatorDynamicConfig.builder()\n                                    .withMaxSegmentsToMove(1)\n                                    .withDecommissioningMaxPercentOfMaxSegmentsToMove(percent)\n                                    .build()\n        )\n        .withBalancerStrategy(strategy)\n        .build();\n  }\n","realPath":"server/src/test/java/org/apache/druid/server/coordinator/BalanceSegmentsTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":652,"status":"M"}],"commitId":"771870ae2d312d643e6d98f3d0af8a9618af9681","commitMessage":"@@@Load broadcast datasources on broker and tasks (#9971)\n\n* Load broadcast datasources on broker and tasks\n\n* Add javadocs\n\n* Support HTTP segment management\n\n* Fix indexer maxSize\n\n* inspection fix\n\n* Make segment cache optional on non-historicals\n\n* Fix build\n\n* Fix inspections.  some coverage.  failed tests\n\n* More tests\n\n* Add CliIndexer to MainTest\n\n* Fix inspection\n\n* Rename UnprunedDataSegment to LoadableDataSegment\n\n* Address PR comments\n\n* Fix","date":"2020-06-09 11:15:59","modifiedFileCount":"52","status":"M","submitter":"Jonathan Wei"},{"authorTime":"2020-12-23 00:27:55","codes":[{"authorDate":"2020-12-23 00:27:55","commitOrder":3,"curCode":"  public void testMoveDecommissioningMaxPercentOfMaxSegmentsToMove()\n  {\n    mockDruidServer(druidServer1, \"1\", \"normal\", 30L, 100L, Arrays.asList(segment1, segment2));\n    mockDruidServer(druidServer2, \"2\", \"normal\", 30L, 100L, Arrays.asList(segment3, segment4));\n    mockDruidServer(druidServer3, \"3\", \"normal\", 0L, 100L, Collections.emptyList());\n\n    EasyMock.replay(druidServer4);\n\n    mockCoordinator(coordinator);\n\n    BalancerStrategy strategy = EasyMock.createMock(BalancerStrategy.class);\n    EasyMock.expect(\n        strategy.pickSegmentToMove(\n            ImmutableList.of(\n                new ServerHolder(druidServer2, peon2, false)\n            ),\n            broadcastDatasources,\n            100\n        )\n    ).andReturn(\n        new BalancerSegmentHolder(druidServer2, segment3)).andReturn(new BalancerSegmentHolder(druidServer2, segment4)\n    );\n\n    EasyMock.expect(strategy.pickSegmentToMove(EasyMock.anyObject(), EasyMock.anyObject(), EasyMock.anyInt()))\n            .andReturn(new BalancerSegmentHolder(druidServer1, segment1))\n            .andReturn(new BalancerSegmentHolder(druidServer1, segment2));\n\n    EasyMock.expect(strategy.findNewSegmentHomeBalancer(EasyMock.anyObject(), EasyMock.anyObject()))\n            .andReturn(new ServerHolder(druidServer3, peon3))\n            .anyTimes();\n    EasyMock.replay(strategy);\n\n    DruidCoordinatorRuntimeParams params = defaultRuntimeParamsBuilder(\n        ImmutableList.of(druidServer1, druidServer2, druidServer3),\n        ImmutableList.of(peon1, peon2, peon3),\n        ImmutableList.of(false, true, false)\n    )\n        .withDynamicConfigs(\n            CoordinatorDynamicConfig.builder()\n                                    .withMaxSegmentsToMove(3)\n                                    .withDecommissioningMaxPercentOfMaxSegmentsToMove(60)\n                                    .build() \r\n        )\n        .withBalancerStrategy(strategy)\n        .withBroadcastDatasources(broadcastDatasources)\n        .build();\n\n    params = new BalanceSegmentsTester(coordinator).run(params);\n    Assert.assertEquals(3L, params.getCoordinatorStats().getTieredStat(\"movedCount\", \"normal\"));\n    Assert.assertThat(\n        peon3.getSegmentsToLoad(),\n        Matchers.is(Matchers.equalTo(ImmutableSet.of(segment1, segment3, segment4)))\n    );\n  }\n","date":"2020-12-23 00:27:55","endLine":277,"groupId":"21234","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testMoveDecommissioningMaxPercentOfMaxSegmentsToMove","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/26/175f613216b51827ba8d0d16540429ce0a1e4a.src","preCode":"  public void testMoveDecommissioningMaxPercentOfMaxSegmentsToMove()\n  {\n    mockDruidServer(druidServer1, \"1\", \"normal\", 30L, 100L, Arrays.asList(segment1, segment2));\n    mockDruidServer(druidServer2, \"2\", \"normal\", 30L, 100L, Arrays.asList(segment3, segment4));\n    mockDruidServer(druidServer3, \"3\", \"normal\", 0L, 100L, Collections.emptyList());\n\n    EasyMock.replay(druidServer4);\n\n    mockCoordinator(coordinator);\n\n    BalancerStrategy strategy = EasyMock.createMock(BalancerStrategy.class);\n    EasyMock.expect(strategy.pickSegmentToMove(ImmutableList.of(new ServerHolder(druidServer2, peon2, false)), broadcastDatasources))\n            .andReturn(new BalancerSegmentHolder(druidServer2, segment3))\n            .andReturn(new BalancerSegmentHolder(druidServer2, segment4));\n    EasyMock.expect(strategy.pickSegmentToMove(EasyMock.anyObject(), EasyMock.anyObject()))\n            .andReturn(new BalancerSegmentHolder(druidServer1, segment1))\n            .andReturn(new BalancerSegmentHolder(druidServer1, segment2));\n\n    EasyMock.expect(strategy.findNewSegmentHomeBalancer(EasyMock.anyObject(), EasyMock.anyObject()))\n            .andReturn(new ServerHolder(druidServer3, peon3))\n            .anyTimes();\n    EasyMock.replay(strategy);\n\n    DruidCoordinatorRuntimeParams params = defaultRuntimeParamsBuilder(\n        ImmutableList.of(druidServer1, druidServer2, druidServer3),\n        ImmutableList.of(peon1, peon2, peon3),\n        ImmutableList.of(false, true, false)\n    )\n        .withDynamicConfigs(\n            CoordinatorDynamicConfig.builder()\n                                    .withMaxSegmentsToMove(3)\n                                    .withDecommissioningMaxPercentOfMaxSegmentsToMove(60)\n                                    .build() \r\n        )\n        .withBalancerStrategy(strategy)\n        .withBroadcastDatasources(broadcastDatasources)\n        .build();\n\n    params = new BalanceSegmentsTester(coordinator).run(params);\n    Assert.assertEquals(3L, params.getCoordinatorStats().getTieredStat(\"movedCount\", \"normal\"));\n    Assert.assertThat(\n        peon3.getSegmentsToLoad(),\n        Matchers.is(Matchers.equalTo(ImmutableSet.of(segment1, segment3, segment4)))\n    );\n  }\n","realPath":"server/src/test/java/org/apache/druid/server/coordinator/BalanceSegmentsTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":224,"status":"M"},{"authorDate":"2020-12-23 00:27:55","commitOrder":3,"curCode":"  private DruidCoordinatorRuntimeParams setupParamsForDecommissioningMaxPercentOfMaxSegmentsToMove(int percent)\n  {\n    mockDruidServer(druidServer1, \"1\", \"normal\", 30L, 100L, Arrays.asList(segment1, segment3));\n    mockDruidServer(druidServer2, \"2\", \"normal\", 30L, 100L, Arrays.asList(segment2, segment3));\n    mockDruidServer(druidServer3, \"3\", \"normal\", 0L, 100L, Collections.emptyList());\n\n    EasyMock.replay(druidServer4);\n\n    mockCoordinator(coordinator);\n\n    \r\n    BalancerStrategy strategy = EasyMock.createMock(BalancerStrategy.class);\n    EasyMock.expect(\n        strategy.pickSegmentToMove(\n            ImmutableList.of(\n                new ServerHolder(druidServer2, peon2, true)\n            ),\n            broadcastDatasources,\n            100\n        )\n    ).andReturn(\n        new BalancerSegmentHolder(druidServer2, segment2)\n    );\n    EasyMock.expect(strategy.pickSegmentToMove(EasyMock.anyObject(), EasyMock.anyObject(), EasyMock.anyInt()))\n            .andReturn(new BalancerSegmentHolder(druidServer1, segment1));\n    EasyMock.expect(strategy.findNewSegmentHomeBalancer(EasyMock.anyObject(), EasyMock.anyObject()))\n            .andReturn(new ServerHolder(druidServer3, peon3))\n            .anyTimes();\n    EasyMock.replay(strategy);\n\n    return defaultRuntimeParamsBuilder(\n        ImmutableList.of(druidServer1, druidServer2, druidServer3),\n        ImmutableList.of(peon1, peon2, peon3),\n        ImmutableList.of(false, true, false)\n    )\n        .withDynamicConfigs(\n            CoordinatorDynamicConfig.builder()\n                                    .withMaxSegmentsToMove(1)\n                                    .withDecommissioningMaxPercentOfMaxSegmentsToMove(percent)\n                                    .build()\n        )\n        .withBalancerStrategy(strategy)\n        .withBroadcastDatasources(broadcastDatasources)\n        .build();\n  }\n","date":"2020-12-23 00:27:55","endLine":779,"groupId":"15751","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"setupParamsForDecommissioningMaxPercentOfMaxSegmentsToMove","params":"(intpercent)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/26/175f613216b51827ba8d0d16540429ce0a1e4a.src","preCode":"  private DruidCoordinatorRuntimeParams setupParamsForDecommissioningMaxPercentOfMaxSegmentsToMove(int percent)\n  {\n    mockDruidServer(druidServer1, \"1\", \"normal\", 30L, 100L, Arrays.asList(segment1, segment3));\n    mockDruidServer(druidServer2, \"2\", \"normal\", 30L, 100L, Arrays.asList(segment2, segment3));\n    mockDruidServer(druidServer3, \"3\", \"normal\", 0L, 100L, Collections.emptyList());\n\n    EasyMock.replay(druidServer4);\n\n    mockCoordinator(coordinator);\n\n    \r\n    BalancerStrategy strategy = EasyMock.createMock(BalancerStrategy.class);\n    EasyMock.expect(strategy.pickSegmentToMove(ImmutableList.of(new ServerHolder(druidServer2, peon2, true)), broadcastDatasources))\n            .andReturn(new BalancerSegmentHolder(druidServer2, segment2));\n    EasyMock.expect(strategy.pickSegmentToMove(EasyMock.anyObject(), EasyMock.anyObject()))\n            .andReturn(new BalancerSegmentHolder(druidServer1, segment1));\n    EasyMock.expect(strategy.findNewSegmentHomeBalancer(EasyMock.anyObject(), EasyMock.anyObject()))\n            .andReturn(new ServerHolder(druidServer3, peon3))\n            .anyTimes();\n    EasyMock.replay(strategy);\n\n    return defaultRuntimeParamsBuilder(\n        ImmutableList.of(druidServer1, druidServer2, druidServer3),\n        ImmutableList.of(peon1, peon2, peon3),\n        ImmutableList.of(false, true, false)\n    )\n        .withDynamicConfigs(\n            CoordinatorDynamicConfig.builder()\n                                    .withMaxSegmentsToMove(1)\n                                    .withDecommissioningMaxPercentOfMaxSegmentsToMove(percent)\n                                    .build()\n        )\n        .withBalancerStrategy(strategy)\n        .withBroadcastDatasources(broadcastDatasources)\n        .build();\n  }\n","realPath":"server/src/test/java/org/apache/druid/server/coordinator/BalanceSegmentsTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":735,"status":"M"}],"commitId":"58ce2e55d8f49e1cb0de0b1579dff049ac9c873d","commitMessage":"@@@Add dynamic coordinator config that allows control over how many segments are considered when picking a segment to move. (#10284)\n\n* dynamic coord config adding more balancing control\n\nadd new dynamic coordinator config.  maxSegmentsToConsiderPerMove. This\nconfig caps the number of segments that are iterated over when selecting\na segment to move. The default value combined with current balancing\nstrategies will still iterate over all provided segments. However. \nsetting this value to something > 0 will cap the number of segments\nvisited. This could make sense in cases where a cluster has a very large\nnumber of segments and the admins prefer less iterations vs a thorough\nconsideration of all segments provided.\n\n* fix checkstyle failure\n\n* Make doc more detailed for admin to understand when/why to use new config\n\n* refactor PR to use a % of segments instead of raw number\n\n* update the docs\n\n* remove bad doc line\n\n* fix typo in name of new dynamic config\n\n* update RservoirSegmentSampler to gracefully deal with values > 100%\n\n* add handler for <= 0 in ReservoirSegmentSampler\n\n* fixup CoordinatorDynamicConfigTest naming and argument ordering\n\n* fix items in docs after spellcheck flags\n\n* Fix lgtm flag on missing space in string literal\n\n* improve documentation for new config\n\n* Add default value to config docs and add advice in cluster tuning doc\n\n* Add percentOfSegmentsToConsiderPerMove to web console coord config dialog\n\n* update jest snapshot after console change\n\n* fix spell checker errors\n\n* Improve debug logging in getRandomSegmentBalancerHolder to cover all bad inputs for % of segments to consider\n\n* add new config back to web console module after merge with master\n\n* fix ReservoirSegmentSamplerTest\n\n* fix line breaks in coordinator console dialog\n\n* Add a test that helps ensure not regressions for percentOfSegmentsToConsiderPerMove\n\n* Make improvements based off of feedback in review\n\n* additional cleanup coming from review\n\n* Add a warning log if limit on segments to consider for move can't be calcluated\n\n* remove unused import\n\n* fix tests for CoordinatorDynamicConfig\n\n* remove precondition test that is redundant in CoordinatorDynamicConfig Builder class","date":"2020-12-23 00:27:55","modifiedFileCount":"9","status":"M","submitter":"Lucas Capistrant"},{"authorTime":"2021-07-30 22:09:50","codes":[{"authorDate":"2021-07-30 22:09:50","commitOrder":4,"curCode":"  public void testMoveDecommissioningMaxPercentOfMaxSegmentsToMove()\n  {\n    mockDruidServer(druidServer1, \"1\", \"normal\", 30L, 100L, Arrays.asList(segment1, segment2));\n    mockDruidServer(druidServer2, \"2\", \"normal\", 30L, 100L, Arrays.asList(segment3, segment4));\n    mockDruidServer(druidServer3, \"3\", \"normal\", 0L, 100L, Collections.emptyList());\n\n    EasyMock.replay(druidServer4);\n\n    mockCoordinator(coordinator);\n\n    BalancerStrategy strategy = EasyMock.createMock(BalancerStrategy.class);\n    EasyMock.expect(\n        strategy.pickSegmentsToMove(\n            ImmutableList.of(\n                new ServerHolder(druidServer2, peon2, false)\n            ),\n            broadcastDatasources,\n            1,\n            100\n        )\n    ).andReturn(\n        ImmutableList.of(\n            new BalancerSegmentHolder(druidServer2, segment3),\n            new BalancerSegmentHolder(druidServer2, segment4)\n        ).iterator()\n    );\n\n    EasyMock.expect(strategy.pickSegmentsToMove(EasyMock.anyObject(), EasyMock.anyObject(), EasyMock.anyInt(), EasyMock.anyInt()))\n            .andReturn(\n                ImmutableList.of(\n                    new BalancerSegmentHolder(druidServer1, segment1),\n                    new BalancerSegmentHolder(druidServer1, segment2)).iterator());\n\n    EasyMock.expect(strategy.findNewSegmentHomeBalancer(EasyMock.anyObject(), EasyMock.anyObject()))\n            .andReturn(new ServerHolder(druidServer3, peon3))\n            .anyTimes();\n    EasyMock.replay(strategy);\n\n    DruidCoordinatorRuntimeParams params = defaultRuntimeParamsBuilder(\n        ImmutableList.of(druidServer1, druidServer2, druidServer3),\n        ImmutableList.of(peon1, peon2, peon3),\n        ImmutableList.of(false, true, false)\n    )\n        .withDynamicConfigs(\n            CoordinatorDynamicConfig.builder()\n                                    .withMaxSegmentsToMove(3)\n                                    .withDecommissioningMaxPercentOfMaxSegmentsToMove(60)\n                                    .build() \r\n        )\n        .withBalancerStrategy(strategy)\n        .withBroadcastDatasources(broadcastDatasources)\n        .build();\n\n    params = new BalanceSegmentsTester(coordinator).run(params);\n    Assert.assertEquals(3L, params.getCoordinatorStats().getTieredStat(\"movedCount\", \"normal\"));\n    Assert.assertThat(\n        peon3.getSegmentsToLoad(),\n        Matchers.is(Matchers.equalTo(ImmutableSet.of(segment1, segment3, segment4)))\n    );\n  }\n","date":"2021-07-30 22:09:50","endLine":284,"groupId":"10333","id":7,"instanceNumber":1,"isCurCommit":1,"methodName":"testMoveDecommissioningMaxPercentOfMaxSegmentsToMove","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/76/b11040aad9106574489173e9cf344e31f15e78.src","preCode":"  public void testMoveDecommissioningMaxPercentOfMaxSegmentsToMove()\n  {\n    mockDruidServer(druidServer1, \"1\", \"normal\", 30L, 100L, Arrays.asList(segment1, segment2));\n    mockDruidServer(druidServer2, \"2\", \"normal\", 30L, 100L, Arrays.asList(segment3, segment4));\n    mockDruidServer(druidServer3, \"3\", \"normal\", 0L, 100L, Collections.emptyList());\n\n    EasyMock.replay(druidServer4);\n\n    mockCoordinator(coordinator);\n\n    BalancerStrategy strategy = EasyMock.createMock(BalancerStrategy.class);\n    EasyMock.expect(\n        strategy.pickSegmentToMove(\n            ImmutableList.of(\n                new ServerHolder(druidServer2, peon2, false)\n            ),\n            broadcastDatasources,\n            100\n        )\n    ).andReturn(\n        new BalancerSegmentHolder(druidServer2, segment3)).andReturn(new BalancerSegmentHolder(druidServer2, segment4)\n    );\n\n    EasyMock.expect(strategy.pickSegmentToMove(EasyMock.anyObject(), EasyMock.anyObject(), EasyMock.anyInt()))\n            .andReturn(new BalancerSegmentHolder(druidServer1, segment1))\n            .andReturn(new BalancerSegmentHolder(druidServer1, segment2));\n\n    EasyMock.expect(strategy.findNewSegmentHomeBalancer(EasyMock.anyObject(), EasyMock.anyObject()))\n            .andReturn(new ServerHolder(druidServer3, peon3))\n            .anyTimes();\n    EasyMock.replay(strategy);\n\n    DruidCoordinatorRuntimeParams params = defaultRuntimeParamsBuilder(\n        ImmutableList.of(druidServer1, druidServer2, druidServer3),\n        ImmutableList.of(peon1, peon2, peon3),\n        ImmutableList.of(false, true, false)\n    )\n        .withDynamicConfigs(\n            CoordinatorDynamicConfig.builder()\n                                    .withMaxSegmentsToMove(3)\n                                    .withDecommissioningMaxPercentOfMaxSegmentsToMove(60)\n                                    .build() \r\n        )\n        .withBalancerStrategy(strategy)\n        .withBroadcastDatasources(broadcastDatasources)\n        .build();\n\n    params = new BalanceSegmentsTester(coordinator).run(params);\n    Assert.assertEquals(3L, params.getCoordinatorStats().getTieredStat(\"movedCount\", \"normal\"));\n    Assert.assertThat(\n        peon3.getSegmentsToLoad(),\n        Matchers.is(Matchers.equalTo(ImmutableSet.of(segment1, segment3, segment4)))\n    );\n  }\n","realPath":"server/src/test/java/org/apache/druid/server/coordinator/BalanceSegmentsTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":225,"status":"M"},{"authorDate":"2021-07-30 22:09:50","commitOrder":4,"curCode":"  private DruidCoordinatorRuntimeParams setupParamsForDecommissioningMaxPercentOfMaxSegmentsToMove(int percent)\n  {\n    mockDruidServer(druidServer1, \"1\", \"normal\", 30L, 100L, Arrays.asList(segment1, segment3));\n    mockDruidServer(druidServer2, \"2\", \"normal\", 30L, 100L, Arrays.asList(segment2, segment3));\n    mockDruidServer(druidServer3, \"3\", \"normal\", 0L, 100L, Collections.emptyList());\n\n    EasyMock.replay(druidServer4);\n\n    mockCoordinator(coordinator);\n\n    \r\n    BalancerStrategy strategy = EasyMock.createMock(BalancerStrategy.class);\n    EasyMock.expect(\n        strategy.pickSegmentsToMove(\n            ImmutableList.of(\n                new ServerHolder(druidServer2, peon2, true)\n            ),\n            broadcastDatasources,\n            1,\n            100\n        )\n    ).andReturn(\n        ImmutableList.of(new BalancerSegmentHolder(druidServer2, segment2)).iterator()\n    );\n    EasyMock.expect(strategy.pickSegmentsToMove(EasyMock.anyObject(), EasyMock.anyObject(), EasyMock.anyInt(), EasyMock.anyDouble()))\n            .andReturn(ImmutableList.of(new BalancerSegmentHolder(druidServer1, segment1)).iterator());\n    EasyMock.expect(strategy.findNewSegmentHomeBalancer(EasyMock.anyObject(), EasyMock.anyObject()))\n            .andReturn(new ServerHolder(druidServer3, peon3))\n            .anyTimes();\n    EasyMock.replay(strategy);\n\n    return defaultRuntimeParamsBuilder(\n        ImmutableList.of(druidServer1, druidServer2, druidServer3),\n        ImmutableList.of(peon1, peon2, peon3),\n        ImmutableList.of(false, true, false)\n    )\n        .withDynamicConfigs(\n            CoordinatorDynamicConfig.builder()\n                                    .withMaxSegmentsToMove(1)\n                                    .withDecommissioningMaxPercentOfMaxSegmentsToMove(percent)\n                                    .build()\n        )\n        .withBalancerStrategy(strategy)\n        .withBroadcastDatasources(broadcastDatasources)\n        .build();\n  }\n","date":"2021-07-30 22:09:50","endLine":817,"groupId":"10333","id":8,"instanceNumber":2,"isCurCommit":1,"methodName":"setupParamsForDecommissioningMaxPercentOfMaxSegmentsToMove","params":"(intpercent)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/76/b11040aad9106574489173e9cf344e31f15e78.src","preCode":"  private DruidCoordinatorRuntimeParams setupParamsForDecommissioningMaxPercentOfMaxSegmentsToMove(int percent)\n  {\n    mockDruidServer(druidServer1, \"1\", \"normal\", 30L, 100L, Arrays.asList(segment1, segment3));\n    mockDruidServer(druidServer2, \"2\", \"normal\", 30L, 100L, Arrays.asList(segment2, segment3));\n    mockDruidServer(druidServer3, \"3\", \"normal\", 0L, 100L, Collections.emptyList());\n\n    EasyMock.replay(druidServer4);\n\n    mockCoordinator(coordinator);\n\n    \r\n    BalancerStrategy strategy = EasyMock.createMock(BalancerStrategy.class);\n    EasyMock.expect(\n        strategy.pickSegmentToMove(\n            ImmutableList.of(\n                new ServerHolder(druidServer2, peon2, true)\n            ),\n            broadcastDatasources,\n            100\n        )\n    ).andReturn(\n        new BalancerSegmentHolder(druidServer2, segment2)\n    );\n    EasyMock.expect(strategy.pickSegmentToMove(EasyMock.anyObject(), EasyMock.anyObject(), EasyMock.anyInt()))\n            .andReturn(new BalancerSegmentHolder(druidServer1, segment1));\n    EasyMock.expect(strategy.findNewSegmentHomeBalancer(EasyMock.anyObject(), EasyMock.anyObject()))\n            .andReturn(new ServerHolder(druidServer3, peon3))\n            .anyTimes();\n    EasyMock.replay(strategy);\n\n    return defaultRuntimeParamsBuilder(\n        ImmutableList.of(druidServer1, druidServer2, druidServer3),\n        ImmutableList.of(peon1, peon2, peon3),\n        ImmutableList.of(false, true, false)\n    )\n        .withDynamicConfigs(\n            CoordinatorDynamicConfig.builder()\n                                    .withMaxSegmentsToMove(1)\n                                    .withDecommissioningMaxPercentOfMaxSegmentsToMove(percent)\n                                    .build()\n        )\n        .withBalancerStrategy(strategy)\n        .withBroadcastDatasources(broadcastDatasources)\n        .build();\n  }\n","realPath":"server/src/test/java/org/apache/druid/server/coordinator/BalanceSegmentsTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":772,"status":"M"}],"commitId":"b83742179a9035812875b4a77ce68be44ba5989f","commitMessage":"@@@Reduce method invocation of reservoir sampling (#11257)\n\n* reduce method invocation of reservoir sampling\n\n* add a dynamic parameter and add benchmark\n\n* rebase","date":"2021-07-30 22:09:50","modifiedFileCount":"9","status":"M","submitter":"Yuanli Han"}]
