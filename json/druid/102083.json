[{"authorTime":"2018-08-31 00:56:26","codes":[{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  private static DimFilter toSimpleLeafFilter(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final RexNode rexNode\n  )\n  {\n    final SqlKind kind = rexNode.getKind();\n\n    if (kind == SqlKind.IS_TRUE || kind == SqlKind.IS_NOT_FALSE) {\n      return toSimpleLeafFilter(\n          plannerContext,\n          rowSignature,\n          Iterables.getOnlyElement(((RexCall) rexNode).getOperands())\n      );\n    } else if (kind == SqlKind.IS_FALSE || kind == SqlKind.IS_NOT_TRUE) {\n      return new NotDimFilter(\n          toSimpleLeafFilter(\n              plannerContext,\n              rowSignature,\n              Iterables.getOnlyElement(((RexCall) rexNode).getOperands())\n          )\n      );\n    } else if (kind == SqlKind.IS_NULL || kind == SqlKind.IS_NOT_NULL) {\n      final RexNode operand = Iterables.getOnlyElement(((RexCall) rexNode).getOperands());\n\n      \r\n      final DruidExpression druidExpression = toDruidExpression(plannerContext, rowSignature, operand);\n      if (druidExpression == null || !druidExpression.isSimpleExtraction()) {\n        return null;\n      }\n\n      final DimFilter equalFilter = new SelectorDimFilter(\n          druidExpression.getSimpleExtraction().getColumn(),\n          NullHandling.defaultStringValue(),\n          druidExpression.getSimpleExtraction().getExtractionFn()\n      );\n\n      return kind == SqlKind.IS_NOT_NULL ? new NotDimFilter(equalFilter) : equalFilter;\n    } else if (kind == SqlKind.EQUALS\n               || kind == SqlKind.NOT_EQUALS\n               || kind == SqlKind.GREATER_THAN\n               || kind == SqlKind.GREATER_THAN_OR_EQUAL\n               || kind == SqlKind.LESS_THAN\n               || kind == SqlKind.LESS_THAN_OR_EQUAL) {\n      final List<RexNode> operands = ((RexCall) rexNode).getOperands();\n      Preconditions.checkState(operands.size() == 2, \"WTF?! Expected 2 operands, got[%,d]\", operands.size());\n      boolean flip = false;\n      RexNode lhs = operands.get(0);\n      RexNode rhs = operands.get(1);\n\n      if (lhs.getKind() == SqlKind.LITERAL && rhs.getKind() != SqlKind.LITERAL) {\n        \r\n        RexNode x = lhs;\n        lhs = rhs;\n        rhs = x;\n        flip = true;\n      }\n\n      \r\n      final SqlKind flippedKind;\n\n      if (flip) {\n        switch (kind) {\n          case EQUALS:\n          case NOT_EQUALS:\n            flippedKind = kind;\n            break;\n          case GREATER_THAN:\n            flippedKind = SqlKind.LESS_THAN;\n            break;\n          case GREATER_THAN_OR_EQUAL:\n            flippedKind = SqlKind.LESS_THAN_OR_EQUAL;\n            break;\n          case LESS_THAN:\n            flippedKind = SqlKind.GREATER_THAN;\n            break;\n          case LESS_THAN_OR_EQUAL:\n            flippedKind = SqlKind.GREATER_THAN_OR_EQUAL;\n            break;\n          default:\n            throw new ISE(\"WTF?! Kind[%s] not expected here\", kind);\n        }\n      } else {\n        flippedKind = kind;\n      }\n\n      \r\n      if (rhs.getKind() != SqlKind.LITERAL) {\n        return null;\n      }\n\n      \r\n      final DruidExpression lhsExpression = toDruidExpression(plannerContext, rowSignature, lhs);\n      if (lhsExpression == null) {\n        return null;\n      }\n\n      \r\n      final Granularity queryGranularity = toQueryGranularity(lhsExpression, plannerContext.getExprMacroTable());\n      if (queryGranularity != null) {\n        \r\n        final long rhsMillis = Calcites.calciteDateTimeLiteralToJoda(rhs, plannerContext.getTimeZone()).getMillis();\n        return buildTimeFloorFilter(Column.TIME_COLUMN_NAME, queryGranularity, flippedKind, rhsMillis);\n      }\n\n      \r\n      if (!lhsExpression.isSimpleExtraction()) {\n        return null;\n      }\n\n      final String column = lhsExpression.getSimpleExtraction().getColumn();\n      final ExtractionFn extractionFn = lhsExpression.getSimpleExtraction().getExtractionFn();\n\n      if (column.equals(Column.TIME_COLUMN_NAME) && extractionFn instanceof TimeFormatExtractionFn) {\n        \r\n        \r\n\n        final Granularity granularity = ExtractionFns.toQueryGranularity(extractionFn);\n        if (granularity != null) {\n          \r\n          final long rhsMillis = Calcites.calciteDateTimeLiteralToJoda(rhs, plannerContext.getTimeZone()).getMillis();\n          final Interval rhsInterval = granularity.bucket(DateTimes.utc(rhsMillis));\n\n          \r\n          final boolean rhsAligned = rhsInterval.getStartMillis() == rhsMillis;\n\n          \r\n          final BoundRefKey boundRefKey = new BoundRefKey(column, null, StringComparators.NUMERIC);\n\n          switch (flippedKind) {\n            case EQUALS:\n              return rhsAligned\n                     ? Bounds.interval(boundRefKey, rhsInterval)\n                     : Filtration.matchNothing();\n            case NOT_EQUALS:\n              return rhsAligned\n                     ? new NotDimFilter(Bounds.interval(boundRefKey, rhsInterval))\n                     : Filtration.matchEverything();\n            case GREATER_THAN:\n              return Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n            case GREATER_THAN_OR_EQUAL:\n              return rhsAligned\n                     ? Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getStartMillis()))\n                     : Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n            case LESS_THAN:\n              return rhsAligned\n                     ? Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getStartMillis()))\n                     : Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n            case LESS_THAN_OR_EQUAL:\n              return Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n            default:\n              throw new IllegalStateException(\"WTF?! Shouldn't have got here...\");\n          }\n        }\n      }\n\n      final String val;\n      final RexLiteral rhsLiteral = (RexLiteral) rhs;\n      if (SqlTypeName.NUMERIC_TYPES.contains(rhsLiteral.getTypeName())) {\n        val = String.valueOf(RexLiteral.value(rhsLiteral));\n      } else if (SqlTypeName.CHAR_TYPES.contains(rhsLiteral.getTypeName())) {\n        val = String.valueOf(RexLiteral.stringValue(rhsLiteral));\n      } else if (SqlTypeName.TIMESTAMP == rhsLiteral.getTypeName() || SqlTypeName.DATE == rhsLiteral.getTypeName()) {\n        val = String.valueOf(\n            Calcites.calciteDateTimeLiteralToJoda(\n                rhsLiteral,\n                plannerContext.getTimeZone()\n            ).getMillis()\n        );\n      } else {\n        \r\n        return null;\n      }\n\n      \r\n      final StringComparator comparator = Calcites.getStringComparatorForSqlTypeName(lhs.getType().getSqlTypeName());\n      final BoundRefKey boundRefKey = new BoundRefKey(column, extractionFn, comparator);\n      final DimFilter filter;\n\n      \r\n      switch (flippedKind) {\n        case EQUALS:\n          filter = Bounds.equalTo(boundRefKey, val);\n          break;\n        case NOT_EQUALS:\n          filter = new NotDimFilter(Bounds.equalTo(boundRefKey, val));\n          break;\n        case GREATER_THAN:\n          filter = Bounds.greaterThan(boundRefKey, val);\n          break;\n        case GREATER_THAN_OR_EQUAL:\n          filter = Bounds.greaterThanOrEqualTo(boundRefKey, val);\n          break;\n        case LESS_THAN:\n          filter = Bounds.lessThan(boundRefKey, val);\n          break;\n        case LESS_THAN_OR_EQUAL:\n          filter = Bounds.lessThanOrEqualTo(boundRefKey, val);\n          break;\n        default:\n          throw new IllegalStateException(\"WTF?! Shouldn't have got here...\");\n      }\n\n      return filter;\n    } else if (kind == SqlKind.LIKE) {\n      final List<RexNode> operands = ((RexCall) rexNode).getOperands();\n      final DruidExpression druidExpression = toDruidExpression(\n          plannerContext,\n          rowSignature,\n          operands.get(0)\n      );\n      if (druidExpression == null || !druidExpression.isSimpleExtraction()) {\n        return null;\n      }\n      return new LikeDimFilter(\n          druidExpression.getSimpleExtraction().getColumn(),\n          RexLiteral.stringValue(operands.get(1)),\n          operands.size() > 2 ? RexLiteral.stringValue(operands.get(2)) : null,\n          druidExpression.getSimpleExtraction().getExtractionFn()\n      );\n    } else {\n      return null;\n    }\n  }\n","date":"2018-08-31 00:56:26","endLine":507,"groupId":"4656","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"toSimpleLeafFilter","params":"(finalPlannerContextplannerContext@finalRowSignaturerowSignature@finalRexNoderexNode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/75/018e0b359663ac5d0bf33bcb136d8ebafd5cf5.src","preCode":"  private static DimFilter toSimpleLeafFilter(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final RexNode rexNode\n  )\n  {\n    final SqlKind kind = rexNode.getKind();\n\n    if (kind == SqlKind.IS_TRUE || kind == SqlKind.IS_NOT_FALSE) {\n      return toSimpleLeafFilter(\n          plannerContext,\n          rowSignature,\n          Iterables.getOnlyElement(((RexCall) rexNode).getOperands())\n      );\n    } else if (kind == SqlKind.IS_FALSE || kind == SqlKind.IS_NOT_TRUE) {\n      return new NotDimFilter(\n          toSimpleLeafFilter(\n              plannerContext,\n              rowSignature,\n              Iterables.getOnlyElement(((RexCall) rexNode).getOperands())\n          )\n      );\n    } else if (kind == SqlKind.IS_NULL || kind == SqlKind.IS_NOT_NULL) {\n      final RexNode operand = Iterables.getOnlyElement(((RexCall) rexNode).getOperands());\n\n      \r\n      final DruidExpression druidExpression = toDruidExpression(plannerContext, rowSignature, operand);\n      if (druidExpression == null || !druidExpression.isSimpleExtraction()) {\n        return null;\n      }\n\n      final DimFilter equalFilter = new SelectorDimFilter(\n          druidExpression.getSimpleExtraction().getColumn(),\n          NullHandling.defaultStringValue(),\n          druidExpression.getSimpleExtraction().getExtractionFn()\n      );\n\n      return kind == SqlKind.IS_NOT_NULL ? new NotDimFilter(equalFilter) : equalFilter;\n    } else if (kind == SqlKind.EQUALS\n               || kind == SqlKind.NOT_EQUALS\n               || kind == SqlKind.GREATER_THAN\n               || kind == SqlKind.GREATER_THAN_OR_EQUAL\n               || kind == SqlKind.LESS_THAN\n               || kind == SqlKind.LESS_THAN_OR_EQUAL) {\n      final List<RexNode> operands = ((RexCall) rexNode).getOperands();\n      Preconditions.checkState(operands.size() == 2, \"WTF?! Expected 2 operands, got[%,d]\", operands.size());\n      boolean flip = false;\n      RexNode lhs = operands.get(0);\n      RexNode rhs = operands.get(1);\n\n      if (lhs.getKind() == SqlKind.LITERAL && rhs.getKind() != SqlKind.LITERAL) {\n        \r\n        RexNode x = lhs;\n        lhs = rhs;\n        rhs = x;\n        flip = true;\n      }\n\n      \r\n      final SqlKind flippedKind;\n\n      if (flip) {\n        switch (kind) {\n          case EQUALS:\n          case NOT_EQUALS:\n            flippedKind = kind;\n            break;\n          case GREATER_THAN:\n            flippedKind = SqlKind.LESS_THAN;\n            break;\n          case GREATER_THAN_OR_EQUAL:\n            flippedKind = SqlKind.LESS_THAN_OR_EQUAL;\n            break;\n          case LESS_THAN:\n            flippedKind = SqlKind.GREATER_THAN;\n            break;\n          case LESS_THAN_OR_EQUAL:\n            flippedKind = SqlKind.GREATER_THAN_OR_EQUAL;\n            break;\n          default:\n            throw new ISE(\"WTF?! Kind[%s] not expected here\", kind);\n        }\n      } else {\n        flippedKind = kind;\n      }\n\n      \r\n      if (rhs.getKind() != SqlKind.LITERAL) {\n        return null;\n      }\n\n      \r\n      final DruidExpression lhsExpression = toDruidExpression(plannerContext, rowSignature, lhs);\n      if (lhsExpression == null) {\n        return null;\n      }\n\n      \r\n      final Granularity queryGranularity = toQueryGranularity(lhsExpression, plannerContext.getExprMacroTable());\n      if (queryGranularity != null) {\n        \r\n        final long rhsMillis = Calcites.calciteDateTimeLiteralToJoda(rhs, plannerContext.getTimeZone()).getMillis();\n        return buildTimeFloorFilter(Column.TIME_COLUMN_NAME, queryGranularity, flippedKind, rhsMillis);\n      }\n\n      \r\n      if (!lhsExpression.isSimpleExtraction()) {\n        return null;\n      }\n\n      final String column = lhsExpression.getSimpleExtraction().getColumn();\n      final ExtractionFn extractionFn = lhsExpression.getSimpleExtraction().getExtractionFn();\n\n      if (column.equals(Column.TIME_COLUMN_NAME) && extractionFn instanceof TimeFormatExtractionFn) {\n        \r\n        \r\n\n        final Granularity granularity = ExtractionFns.toQueryGranularity(extractionFn);\n        if (granularity != null) {\n          \r\n          final long rhsMillis = Calcites.calciteDateTimeLiteralToJoda(rhs, plannerContext.getTimeZone()).getMillis();\n          final Interval rhsInterval = granularity.bucket(DateTimes.utc(rhsMillis));\n\n          \r\n          final boolean rhsAligned = rhsInterval.getStartMillis() == rhsMillis;\n\n          \r\n          final BoundRefKey boundRefKey = new BoundRefKey(column, null, StringComparators.NUMERIC);\n\n          switch (flippedKind) {\n            case EQUALS:\n              return rhsAligned\n                     ? Bounds.interval(boundRefKey, rhsInterval)\n                     : Filtration.matchNothing();\n            case NOT_EQUALS:\n              return rhsAligned\n                     ? new NotDimFilter(Bounds.interval(boundRefKey, rhsInterval))\n                     : Filtration.matchEverything();\n            case GREATER_THAN:\n              return Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n            case GREATER_THAN_OR_EQUAL:\n              return rhsAligned\n                     ? Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getStartMillis()))\n                     : Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n            case LESS_THAN:\n              return rhsAligned\n                     ? Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getStartMillis()))\n                     : Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n            case LESS_THAN_OR_EQUAL:\n              return Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n            default:\n              throw new IllegalStateException(\"WTF?! Shouldn't have got here...\");\n          }\n        }\n      }\n\n      final String val;\n      final RexLiteral rhsLiteral = (RexLiteral) rhs;\n      if (SqlTypeName.NUMERIC_TYPES.contains(rhsLiteral.getTypeName())) {\n        val = String.valueOf(RexLiteral.value(rhsLiteral));\n      } else if (SqlTypeName.CHAR_TYPES.contains(rhsLiteral.getTypeName())) {\n        val = String.valueOf(RexLiteral.stringValue(rhsLiteral));\n      } else if (SqlTypeName.TIMESTAMP == rhsLiteral.getTypeName() || SqlTypeName.DATE == rhsLiteral.getTypeName()) {\n        val = String.valueOf(\n            Calcites.calciteDateTimeLiteralToJoda(\n                rhsLiteral,\n                plannerContext.getTimeZone()\n            ).getMillis()\n        );\n      } else {\n        \r\n        return null;\n      }\n\n      \r\n      final StringComparator comparator = Calcites.getStringComparatorForSqlTypeName(lhs.getType().getSqlTypeName());\n      final BoundRefKey boundRefKey = new BoundRefKey(column, extractionFn, comparator);\n      final DimFilter filter;\n\n      \r\n      switch (flippedKind) {\n        case EQUALS:\n          filter = Bounds.equalTo(boundRefKey, val);\n          break;\n        case NOT_EQUALS:\n          filter = new NotDimFilter(Bounds.equalTo(boundRefKey, val));\n          break;\n        case GREATER_THAN:\n          filter = Bounds.greaterThan(boundRefKey, val);\n          break;\n        case GREATER_THAN_OR_EQUAL:\n          filter = Bounds.greaterThanOrEqualTo(boundRefKey, val);\n          break;\n        case LESS_THAN:\n          filter = Bounds.lessThan(boundRefKey, val);\n          break;\n        case LESS_THAN_OR_EQUAL:\n          filter = Bounds.lessThanOrEqualTo(boundRefKey, val);\n          break;\n        default:\n          throw new IllegalStateException(\"WTF?! Shouldn't have got here...\");\n      }\n\n      return filter;\n    } else if (kind == SqlKind.LIKE) {\n      final List<RexNode> operands = ((RexCall) rexNode).getOperands();\n      final DruidExpression druidExpression = toDruidExpression(\n          plannerContext,\n          rowSignature,\n          operands.get(0)\n      );\n      if (druidExpression == null || !druidExpression.isSimpleExtraction()) {\n        return null;\n      }\n      return new LikeDimFilter(\n          druidExpression.getSimpleExtraction().getColumn(),\n          RexLiteral.stringValue(operands.get(1)),\n          operands.size() > 2 ? RexLiteral.stringValue(operands.get(2)) : null,\n          druidExpression.getSimpleExtraction().getExtractionFn()\n      );\n    } else {\n      return null;\n    }\n  }\n","realPath":"sql/src/main/java/org/apache/druid/sql/calcite/expression/Expressions.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":284,"status":"B"},{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  private static DimFilter buildTimeFloorFilter(\n      final String column,\n      final Granularity granularity,\n      final SqlKind operatorKind,\n      final long rhsMillis\n  )\n  {\n    final BoundRefKey boundRefKey = new BoundRefKey(column, null, StringComparators.NUMERIC);\n    final Interval rhsInterval = granularity.bucket(DateTimes.utc(rhsMillis));\n\n    \r\n    final boolean rhsAligned = rhsInterval.getStartMillis() == rhsMillis;\n\n    switch (operatorKind) {\n      case EQUALS:\n        return rhsAligned\n               ? Bounds.interval(boundRefKey, rhsInterval)\n               : Filtration.matchNothing();\n      case NOT_EQUALS:\n        return rhsAligned\n               ? new NotDimFilter(Bounds.interval(boundRefKey, rhsInterval))\n               : Filtration.matchEverything();\n      case GREATER_THAN:\n        return Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n      case GREATER_THAN_OR_EQUAL:\n        return rhsAligned\n               ? Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getStartMillis()))\n               : Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n      case LESS_THAN:\n        return rhsAligned\n               ? Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getStartMillis()))\n               : Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n      case LESS_THAN_OR_EQUAL:\n        return Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n      default:\n        throw new IllegalStateException(\"WTF?! Shouldn't have got here...\");\n    }\n  }\n","date":"2018-08-31 00:56:26","endLine":620,"groupId":"11688","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"buildTimeFloorFilter","params":"(finalStringcolumn@finalGranularitygranularity@finalSqlKindoperatorKind@finallongrhsMillis)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/75/018e0b359663ac5d0bf33bcb136d8ebafd5cf5.src","preCode":"  private static DimFilter buildTimeFloorFilter(\n      final String column,\n      final Granularity granularity,\n      final SqlKind operatorKind,\n      final long rhsMillis\n  )\n  {\n    final BoundRefKey boundRefKey = new BoundRefKey(column, null, StringComparators.NUMERIC);\n    final Interval rhsInterval = granularity.bucket(DateTimes.utc(rhsMillis));\n\n    \r\n    final boolean rhsAligned = rhsInterval.getStartMillis() == rhsMillis;\n\n    switch (operatorKind) {\n      case EQUALS:\n        return rhsAligned\n               ? Bounds.interval(boundRefKey, rhsInterval)\n               : Filtration.matchNothing();\n      case NOT_EQUALS:\n        return rhsAligned\n               ? new NotDimFilter(Bounds.interval(boundRefKey, rhsInterval))\n               : Filtration.matchEverything();\n      case GREATER_THAN:\n        return Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n      case GREATER_THAN_OR_EQUAL:\n        return rhsAligned\n               ? Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getStartMillis()))\n               : Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n      case LESS_THAN:\n        return rhsAligned\n               ? Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getStartMillis()))\n               : Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n      case LESS_THAN_OR_EQUAL:\n        return Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n      default:\n        throw new IllegalStateException(\"WTF?! Shouldn't have got here...\");\n    }\n  }\n","realPath":"sql/src/main/java/org/apache/druid/sql/calcite/expression/Expressions.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":583,"status":"B"}],"commitId":"431d3d8497f9079857c3baa7ae7ab4cb44a22355","commitMessage":"@@@Rename io.druid to org.apache.druid. (#6266)\n\n* Rename io.druid to org.apache.druid.\n\n* Fix META-INF files and remove some benchmark results.\n\n* MonitorsConfig update for metrics package migration.\n\n* Reorder some dimensions in inner queries for some reason.\n\n* Fix protobuf tests.\n","date":"2018-08-31 00:56:26","modifiedFileCount":"5","status":"B","submitter":"Gian Merlino"},{"authorTime":"2018-08-31 00:56:26","codes":[{"authorDate":"2018-10-03 01:50:22","commitOrder":2,"curCode":"  private static DimFilter toSimpleLeafFilter(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final RexNode rexNode\n  )\n  {\n    final SqlKind kind = rexNode.getKind();\n\n    if (kind == SqlKind.IS_TRUE || kind == SqlKind.IS_NOT_FALSE) {\n      return toSimpleLeafFilter(\n          plannerContext,\n          rowSignature,\n          Iterables.getOnlyElement(((RexCall) rexNode).getOperands())\n      );\n    } else if (kind == SqlKind.IS_FALSE || kind == SqlKind.IS_NOT_TRUE) {\n      return new NotDimFilter(\n          toSimpleLeafFilter(\n              plannerContext,\n              rowSignature,\n              Iterables.getOnlyElement(((RexCall) rexNode).getOperands())\n          )\n      );\n    } else if (kind == SqlKind.IS_NULL || kind == SqlKind.IS_NOT_NULL) {\n      final RexNode operand = Iterables.getOnlyElement(((RexCall) rexNode).getOperands());\n\n      \r\n      final DruidExpression druidExpression = toDruidExpression(plannerContext, rowSignature, operand);\n      if (druidExpression == null || !druidExpression.isSimpleExtraction()) {\n        return null;\n      }\n\n      final DimFilter equalFilter = new SelectorDimFilter(\n          druidExpression.getSimpleExtraction().getColumn(),\n          NullHandling.defaultStringValue(),\n          druidExpression.getSimpleExtraction().getExtractionFn()\n      );\n\n      return kind == SqlKind.IS_NOT_NULL ? new NotDimFilter(equalFilter) : equalFilter;\n    } else if (kind == SqlKind.EQUALS\n               || kind == SqlKind.NOT_EQUALS\n               || kind == SqlKind.GREATER_THAN\n               || kind == SqlKind.GREATER_THAN_OR_EQUAL\n               || kind == SqlKind.LESS_THAN\n               || kind == SqlKind.LESS_THAN_OR_EQUAL) {\n      final List<RexNode> operands = ((RexCall) rexNode).getOperands();\n      Preconditions.checkState(operands.size() == 2, \"WTF?! Expected 2 operands, got[%,d]\", operands.size());\n      boolean flip = false;\n      RexNode lhs = operands.get(0);\n      RexNode rhs = operands.get(1);\n\n      if (lhs.getKind() == SqlKind.LITERAL && rhs.getKind() != SqlKind.LITERAL) {\n        \r\n        RexNode x = lhs;\n        lhs = rhs;\n        rhs = x;\n        flip = true;\n      }\n\n      \r\n      final SqlKind flippedKind;\n\n      if (flip) {\n        switch (kind) {\n          case EQUALS:\n          case NOT_EQUALS:\n            flippedKind = kind;\n            break;\n          case GREATER_THAN:\n            flippedKind = SqlKind.LESS_THAN;\n            break;\n          case GREATER_THAN_OR_EQUAL:\n            flippedKind = SqlKind.LESS_THAN_OR_EQUAL;\n            break;\n          case LESS_THAN:\n            flippedKind = SqlKind.GREATER_THAN;\n            break;\n          case LESS_THAN_OR_EQUAL:\n            flippedKind = SqlKind.GREATER_THAN_OR_EQUAL;\n            break;\n          default:\n            throw new ISE(\"WTF?! Kind[%s] not expected here\", kind);\n        }\n      } else {\n        flippedKind = kind;\n      }\n\n      \r\n      if (rhs.getKind() != SqlKind.LITERAL) {\n        return null;\n      }\n\n      \r\n      final DruidExpression lhsExpression = toDruidExpression(plannerContext, rowSignature, lhs);\n      if (lhsExpression == null) {\n        return null;\n      }\n\n      \r\n      final Granularity queryGranularity = toQueryGranularity(lhsExpression, plannerContext.getExprMacroTable());\n      if (queryGranularity != null) {\n        \r\n        final long rhsMillis = Calcites.calciteDateTimeLiteralToJoda(rhs, plannerContext.getTimeZone()).getMillis();\n        return buildTimeFloorFilter(ColumnHolder.TIME_COLUMN_NAME, queryGranularity, flippedKind, rhsMillis);\n      }\n\n      \r\n      if (!lhsExpression.isSimpleExtraction()) {\n        return null;\n      }\n\n      final String column = lhsExpression.getSimpleExtraction().getColumn();\n      final ExtractionFn extractionFn = lhsExpression.getSimpleExtraction().getExtractionFn();\n\n      if (column.equals(ColumnHolder.TIME_COLUMN_NAME) && extractionFn instanceof TimeFormatExtractionFn) {\n        \r\n        \r\n\n        final Granularity granularity = ExtractionFns.toQueryGranularity(extractionFn);\n        if (granularity != null) {\n          \r\n          final long rhsMillis = Calcites.calciteDateTimeLiteralToJoda(rhs, plannerContext.getTimeZone()).getMillis();\n          final Interval rhsInterval = granularity.bucket(DateTimes.utc(rhsMillis));\n\n          \r\n          final boolean rhsAligned = rhsInterval.getStartMillis() == rhsMillis;\n\n          \r\n          final BoundRefKey boundRefKey = new BoundRefKey(column, null, StringComparators.NUMERIC);\n\n          switch (flippedKind) {\n            case EQUALS:\n              return rhsAligned\n                     ? Bounds.interval(boundRefKey, rhsInterval)\n                     : Filtration.matchNothing();\n            case NOT_EQUALS:\n              return rhsAligned\n                     ? new NotDimFilter(Bounds.interval(boundRefKey, rhsInterval))\n                     : Filtration.matchEverything();\n            case GREATER_THAN:\n              return Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n            case GREATER_THAN_OR_EQUAL:\n              return rhsAligned\n                     ? Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getStartMillis()))\n                     : Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n            case LESS_THAN:\n              return rhsAligned\n                     ? Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getStartMillis()))\n                     : Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n            case LESS_THAN_OR_EQUAL:\n              return Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n            default:\n              throw new IllegalStateException(\"WTF?! Shouldn't have got here...\");\n          }\n        }\n      }\n\n      final String val;\n      final RexLiteral rhsLiteral = (RexLiteral) rhs;\n      if (SqlTypeName.NUMERIC_TYPES.contains(rhsLiteral.getTypeName())) {\n        val = String.valueOf(RexLiteral.value(rhsLiteral));\n      } else if (SqlTypeName.CHAR_TYPES.contains(rhsLiteral.getTypeName())) {\n        val = String.valueOf(RexLiteral.stringValue(rhsLiteral));\n      } else if (SqlTypeName.TIMESTAMP == rhsLiteral.getTypeName() || SqlTypeName.DATE == rhsLiteral.getTypeName()) {\n        val = String.valueOf(\n            Calcites.calciteDateTimeLiteralToJoda(\n                rhsLiteral,\n                plannerContext.getTimeZone()\n            ).getMillis()\n        );\n      } else {\n        \r\n        return null;\n      }\n\n      \r\n      final StringComparator comparator = Calcites.getStringComparatorForSqlTypeName(lhs.getType().getSqlTypeName());\n      final BoundRefKey boundRefKey = new BoundRefKey(column, extractionFn, comparator);\n      final DimFilter filter;\n\n      \r\n      switch (flippedKind) {\n        case EQUALS:\n          filter = Bounds.equalTo(boundRefKey, val);\n          break;\n        case NOT_EQUALS:\n          filter = new NotDimFilter(Bounds.equalTo(boundRefKey, val));\n          break;\n        case GREATER_THAN:\n          filter = Bounds.greaterThan(boundRefKey, val);\n          break;\n        case GREATER_THAN_OR_EQUAL:\n          filter = Bounds.greaterThanOrEqualTo(boundRefKey, val);\n          break;\n        case LESS_THAN:\n          filter = Bounds.lessThan(boundRefKey, val);\n          break;\n        case LESS_THAN_OR_EQUAL:\n          filter = Bounds.lessThanOrEqualTo(boundRefKey, val);\n          break;\n        default:\n          throw new IllegalStateException(\"WTF?! Shouldn't have got here...\");\n      }\n\n      return filter;\n    } else if (kind == SqlKind.LIKE) {\n      final List<RexNode> operands = ((RexCall) rexNode).getOperands();\n      final DruidExpression druidExpression = toDruidExpression(\n          plannerContext,\n          rowSignature,\n          operands.get(0)\n      );\n      if (druidExpression == null || !druidExpression.isSimpleExtraction()) {\n        return null;\n      }\n      return new LikeDimFilter(\n          druidExpression.getSimpleExtraction().getColumn(),\n          RexLiteral.stringValue(operands.get(1)),\n          operands.size() > 2 ? RexLiteral.stringValue(operands.get(2)) : null,\n          druidExpression.getSimpleExtraction().getExtractionFn()\n      );\n    } else {\n      return null;\n    }\n  }\n","date":"2018-10-03 01:50:22","endLine":515,"groupId":"11688","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"toSimpleLeafFilter","params":"(finalPlannerContextplannerContext@finalRowSignaturerowSignature@finalRexNoderexNode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/e8/b0ffb9c4f223ce913f61048b318fc948b45ced.src","preCode":"  private static DimFilter toSimpleLeafFilter(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final RexNode rexNode\n  )\n  {\n    final SqlKind kind = rexNode.getKind();\n\n    if (kind == SqlKind.IS_TRUE || kind == SqlKind.IS_NOT_FALSE) {\n      return toSimpleLeafFilter(\n          plannerContext,\n          rowSignature,\n          Iterables.getOnlyElement(((RexCall) rexNode).getOperands())\n      );\n    } else if (kind == SqlKind.IS_FALSE || kind == SqlKind.IS_NOT_TRUE) {\n      return new NotDimFilter(\n          toSimpleLeafFilter(\n              plannerContext,\n              rowSignature,\n              Iterables.getOnlyElement(((RexCall) rexNode).getOperands())\n          )\n      );\n    } else if (kind == SqlKind.IS_NULL || kind == SqlKind.IS_NOT_NULL) {\n      final RexNode operand = Iterables.getOnlyElement(((RexCall) rexNode).getOperands());\n\n      \r\n      final DruidExpression druidExpression = toDruidExpression(plannerContext, rowSignature, operand);\n      if (druidExpression == null || !druidExpression.isSimpleExtraction()) {\n        return null;\n      }\n\n      final DimFilter equalFilter = new SelectorDimFilter(\n          druidExpression.getSimpleExtraction().getColumn(),\n          NullHandling.defaultStringValue(),\n          druidExpression.getSimpleExtraction().getExtractionFn()\n      );\n\n      return kind == SqlKind.IS_NOT_NULL ? new NotDimFilter(equalFilter) : equalFilter;\n    } else if (kind == SqlKind.EQUALS\n               || kind == SqlKind.NOT_EQUALS\n               || kind == SqlKind.GREATER_THAN\n               || kind == SqlKind.GREATER_THAN_OR_EQUAL\n               || kind == SqlKind.LESS_THAN\n               || kind == SqlKind.LESS_THAN_OR_EQUAL) {\n      final List<RexNode> operands = ((RexCall) rexNode).getOperands();\n      Preconditions.checkState(operands.size() == 2, \"WTF?! Expected 2 operands, got[%,d]\", operands.size());\n      boolean flip = false;\n      RexNode lhs = operands.get(0);\n      RexNode rhs = operands.get(1);\n\n      if (lhs.getKind() == SqlKind.LITERAL && rhs.getKind() != SqlKind.LITERAL) {\n        \r\n        RexNode x = lhs;\n        lhs = rhs;\n        rhs = x;\n        flip = true;\n      }\n\n      \r\n      final SqlKind flippedKind;\n\n      if (flip) {\n        switch (kind) {\n          case EQUALS:\n          case NOT_EQUALS:\n            flippedKind = kind;\n            break;\n          case GREATER_THAN:\n            flippedKind = SqlKind.LESS_THAN;\n            break;\n          case GREATER_THAN_OR_EQUAL:\n            flippedKind = SqlKind.LESS_THAN_OR_EQUAL;\n            break;\n          case LESS_THAN:\n            flippedKind = SqlKind.GREATER_THAN;\n            break;\n          case LESS_THAN_OR_EQUAL:\n            flippedKind = SqlKind.GREATER_THAN_OR_EQUAL;\n            break;\n          default:\n            throw new ISE(\"WTF?! Kind[%s] not expected here\", kind);\n        }\n      } else {\n        flippedKind = kind;\n      }\n\n      \r\n      if (rhs.getKind() != SqlKind.LITERAL) {\n        return null;\n      }\n\n      \r\n      final DruidExpression lhsExpression = toDruidExpression(plannerContext, rowSignature, lhs);\n      if (lhsExpression == null) {\n        return null;\n      }\n\n      \r\n      final Granularity queryGranularity = toQueryGranularity(lhsExpression, plannerContext.getExprMacroTable());\n      if (queryGranularity != null) {\n        \r\n        final long rhsMillis = Calcites.calciteDateTimeLiteralToJoda(rhs, plannerContext.getTimeZone()).getMillis();\n        return buildTimeFloorFilter(Column.TIME_COLUMN_NAME, queryGranularity, flippedKind, rhsMillis);\n      }\n\n      \r\n      if (!lhsExpression.isSimpleExtraction()) {\n        return null;\n      }\n\n      final String column = lhsExpression.getSimpleExtraction().getColumn();\n      final ExtractionFn extractionFn = lhsExpression.getSimpleExtraction().getExtractionFn();\n\n      if (column.equals(Column.TIME_COLUMN_NAME) && extractionFn instanceof TimeFormatExtractionFn) {\n        \r\n        \r\n\n        final Granularity granularity = ExtractionFns.toQueryGranularity(extractionFn);\n        if (granularity != null) {\n          \r\n          final long rhsMillis = Calcites.calciteDateTimeLiteralToJoda(rhs, plannerContext.getTimeZone()).getMillis();\n          final Interval rhsInterval = granularity.bucket(DateTimes.utc(rhsMillis));\n\n          \r\n          final boolean rhsAligned = rhsInterval.getStartMillis() == rhsMillis;\n\n          \r\n          final BoundRefKey boundRefKey = new BoundRefKey(column, null, StringComparators.NUMERIC);\n\n          switch (flippedKind) {\n            case EQUALS:\n              return rhsAligned\n                     ? Bounds.interval(boundRefKey, rhsInterval)\n                     : Filtration.matchNothing();\n            case NOT_EQUALS:\n              return rhsAligned\n                     ? new NotDimFilter(Bounds.interval(boundRefKey, rhsInterval))\n                     : Filtration.matchEverything();\n            case GREATER_THAN:\n              return Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n            case GREATER_THAN_OR_EQUAL:\n              return rhsAligned\n                     ? Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getStartMillis()))\n                     : Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n            case LESS_THAN:\n              return rhsAligned\n                     ? Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getStartMillis()))\n                     : Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n            case LESS_THAN_OR_EQUAL:\n              return Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n            default:\n              throw new IllegalStateException(\"WTF?! Shouldn't have got here...\");\n          }\n        }\n      }\n\n      final String val;\n      final RexLiteral rhsLiteral = (RexLiteral) rhs;\n      if (SqlTypeName.NUMERIC_TYPES.contains(rhsLiteral.getTypeName())) {\n        val = String.valueOf(RexLiteral.value(rhsLiteral));\n      } else if (SqlTypeName.CHAR_TYPES.contains(rhsLiteral.getTypeName())) {\n        val = String.valueOf(RexLiteral.stringValue(rhsLiteral));\n      } else if (SqlTypeName.TIMESTAMP == rhsLiteral.getTypeName() || SqlTypeName.DATE == rhsLiteral.getTypeName()) {\n        val = String.valueOf(\n            Calcites.calciteDateTimeLiteralToJoda(\n                rhsLiteral,\n                plannerContext.getTimeZone()\n            ).getMillis()\n        );\n      } else {\n        \r\n        return null;\n      }\n\n      \r\n      final StringComparator comparator = Calcites.getStringComparatorForSqlTypeName(lhs.getType().getSqlTypeName());\n      final BoundRefKey boundRefKey = new BoundRefKey(column, extractionFn, comparator);\n      final DimFilter filter;\n\n      \r\n      switch (flippedKind) {\n        case EQUALS:\n          filter = Bounds.equalTo(boundRefKey, val);\n          break;\n        case NOT_EQUALS:\n          filter = new NotDimFilter(Bounds.equalTo(boundRefKey, val));\n          break;\n        case GREATER_THAN:\n          filter = Bounds.greaterThan(boundRefKey, val);\n          break;\n        case GREATER_THAN_OR_EQUAL:\n          filter = Bounds.greaterThanOrEqualTo(boundRefKey, val);\n          break;\n        case LESS_THAN:\n          filter = Bounds.lessThan(boundRefKey, val);\n          break;\n        case LESS_THAN_OR_EQUAL:\n          filter = Bounds.lessThanOrEqualTo(boundRefKey, val);\n          break;\n        default:\n          throw new IllegalStateException(\"WTF?! Shouldn't have got here...\");\n      }\n\n      return filter;\n    } else if (kind == SqlKind.LIKE) {\n      final List<RexNode> operands = ((RexCall) rexNode).getOperands();\n      final DruidExpression druidExpression = toDruidExpression(\n          plannerContext,\n          rowSignature,\n          operands.get(0)\n      );\n      if (druidExpression == null || !druidExpression.isSimpleExtraction()) {\n        return null;\n      }\n      return new LikeDimFilter(\n          druidExpression.getSimpleExtraction().getColumn(),\n          RexLiteral.stringValue(operands.get(1)),\n          operands.size() > 2 ? RexLiteral.stringValue(operands.get(2)) : null,\n          druidExpression.getSimpleExtraction().getExtractionFn()\n      );\n    } else {\n      return null;\n    }\n  }\n","realPath":"sql/src/main/java/org/apache/druid/sql/calcite/expression/Expressions.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":292,"status":"M"},{"authorDate":"2018-08-31 00:56:26","commitOrder":2,"curCode":"  private static DimFilter buildTimeFloorFilter(\n      final String column,\n      final Granularity granularity,\n      final SqlKind operatorKind,\n      final long rhsMillis\n  )\n  {\n    final BoundRefKey boundRefKey = new BoundRefKey(column, null, StringComparators.NUMERIC);\n    final Interval rhsInterval = granularity.bucket(DateTimes.utc(rhsMillis));\n\n    \r\n    final boolean rhsAligned = rhsInterval.getStartMillis() == rhsMillis;\n\n    switch (operatorKind) {\n      case EQUALS:\n        return rhsAligned\n               ? Bounds.interval(boundRefKey, rhsInterval)\n               : Filtration.matchNothing();\n      case NOT_EQUALS:\n        return rhsAligned\n               ? new NotDimFilter(Bounds.interval(boundRefKey, rhsInterval))\n               : Filtration.matchEverything();\n      case GREATER_THAN:\n        return Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n      case GREATER_THAN_OR_EQUAL:\n        return rhsAligned\n               ? Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getStartMillis()))\n               : Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n      case LESS_THAN:\n        return rhsAligned\n               ? Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getStartMillis()))\n               : Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n      case LESS_THAN_OR_EQUAL:\n        return Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n      default:\n        throw new IllegalStateException(\"WTF?! Shouldn't have got here...\");\n    }\n  }\n","date":"2018-08-31 00:56:26","endLine":620,"groupId":"11688","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"buildTimeFloorFilter","params":"(finalStringcolumn@finalGranularitygranularity@finalSqlKindoperatorKind@finallongrhsMillis)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/75/018e0b359663ac5d0bf33bcb136d8ebafd5cf5.src","preCode":"  private static DimFilter buildTimeFloorFilter(\n      final String column,\n      final Granularity granularity,\n      final SqlKind operatorKind,\n      final long rhsMillis\n  )\n  {\n    final BoundRefKey boundRefKey = new BoundRefKey(column, null, StringComparators.NUMERIC);\n    final Interval rhsInterval = granularity.bucket(DateTimes.utc(rhsMillis));\n\n    \r\n    final boolean rhsAligned = rhsInterval.getStartMillis() == rhsMillis;\n\n    switch (operatorKind) {\n      case EQUALS:\n        return rhsAligned\n               ? Bounds.interval(boundRefKey, rhsInterval)\n               : Filtration.matchNothing();\n      case NOT_EQUALS:\n        return rhsAligned\n               ? new NotDimFilter(Bounds.interval(boundRefKey, rhsInterval))\n               : Filtration.matchEverything();\n      case GREATER_THAN:\n        return Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n      case GREATER_THAN_OR_EQUAL:\n        return rhsAligned\n               ? Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getStartMillis()))\n               : Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n      case LESS_THAN:\n        return rhsAligned\n               ? Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getStartMillis()))\n               : Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n      case LESS_THAN_OR_EQUAL:\n        return Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n      default:\n        throw new IllegalStateException(\"WTF?! Shouldn't have got here...\");\n    }\n  }\n","realPath":"sql/src/main/java/org/apache/druid/sql/calcite/expression/Expressions.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":583,"status":"N"}],"commitId":"3ae563263a23000560749071d262727d47296856","commitMessage":"@@@Renamed 'Generic Column' -> 'Numeric Column'; Fixed a few resource leaks in processing; misc refinements (#5957)\n\nThis PR accumulates many refactorings and small improvements that I did while preparing the next change set of https://github.com/druid-io/druid/projects/2. I finally decided to make them a separate PR to minimize the volume of the main PR.\n\nSome of the changes:\n - Renamed confusing \"Generic Column\" term to \"Numeric Column\" (what it actually implies) in many class names.\n - Generified `ComplexMetricExtractor`","date":"2018-10-03 01:50:22","modifiedFileCount":"776","status":"M","submitter":"Roman Leventov"},{"authorTime":"2018-11-27 14:11:18","codes":[{"authorDate":"2018-11-27 14:11:18","commitOrder":3,"curCode":"  private static DimFilter toSimpleLeafFilter(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final RexNode rexNode\n  )\n  {\n    final SqlKind kind = rexNode.getKind();\n\n    if (kind == SqlKind.IS_TRUE || kind == SqlKind.IS_NOT_FALSE) {\n      return toSimpleLeafFilter(\n          plannerContext,\n          rowSignature,\n          Iterables.getOnlyElement(((RexCall) rexNode).getOperands())\n      );\n    } else if (kind == SqlKind.IS_FALSE || kind == SqlKind.IS_NOT_TRUE) {\n      return new NotDimFilter(\n          toSimpleLeafFilter(\n              plannerContext,\n              rowSignature,\n              Iterables.getOnlyElement(((RexCall) rexNode).getOperands())\n          )\n      );\n    } else if (kind == SqlKind.IS_NULL || kind == SqlKind.IS_NOT_NULL) {\n      final RexNode operand = Iterables.getOnlyElement(((RexCall) rexNode).getOperands());\n\n      \r\n      final DruidExpression druidExpression = toDruidExpression(plannerContext, rowSignature, operand);\n      if (druidExpression == null || !druidExpression.isSimpleExtraction()) {\n        return null;\n      }\n\n      final DimFilter equalFilter = new SelectorDimFilter(\n          druidExpression.getSimpleExtraction().getColumn(),\n          NullHandling.defaultStringValue(),\n          druidExpression.getSimpleExtraction().getExtractionFn()\n      );\n\n      return kind == SqlKind.IS_NOT_NULL ? new NotDimFilter(equalFilter) : equalFilter;\n    } else if (kind == SqlKind.EQUALS\n               || kind == SqlKind.NOT_EQUALS\n               || kind == SqlKind.GREATER_THAN\n               || kind == SqlKind.GREATER_THAN_OR_EQUAL\n               || kind == SqlKind.LESS_THAN\n               || kind == SqlKind.LESS_THAN_OR_EQUAL) {\n      final List<RexNode> operands = ((RexCall) rexNode).getOperands();\n      Preconditions.checkState(operands.size() == 2, \"WTF?! Expected 2 operands, got[%,d]\", operands.size());\n      boolean flip = false;\n      RexNode lhs = operands.get(0);\n      RexNode rhs = operands.get(1);\n\n      if (lhs.getKind() == SqlKind.LITERAL && rhs.getKind() != SqlKind.LITERAL) {\n        \r\n        RexNode x = lhs;\n        lhs = rhs;\n        rhs = x;\n        flip = true;\n      }\n\n      \r\n      final SqlKind flippedKind;\n\n      if (flip) {\n        switch (kind) {\n          case EQUALS:\n          case NOT_EQUALS:\n            flippedKind = kind;\n            break;\n          case GREATER_THAN:\n            flippedKind = SqlKind.LESS_THAN;\n            break;\n          case GREATER_THAN_OR_EQUAL:\n            flippedKind = SqlKind.LESS_THAN_OR_EQUAL;\n            break;\n          case LESS_THAN:\n            flippedKind = SqlKind.GREATER_THAN;\n            break;\n          case LESS_THAN_OR_EQUAL:\n            flippedKind = SqlKind.GREATER_THAN_OR_EQUAL;\n            break;\n          default:\n            throw new ISE(\"WTF?! Kind[%s] not expected here\", kind);\n        }\n      } else {\n        flippedKind = kind;\n      }\n\n      \r\n      if (rhs.getKind() != SqlKind.LITERAL) {\n        return null;\n      }\n\n      \r\n      final DruidExpression lhsExpression = toDruidExpression(plannerContext, rowSignature, lhs);\n      if (lhsExpression == null) {\n        return null;\n      }\n\n      \r\n      final Granularity queryGranularity = toQueryGranularity(lhsExpression, plannerContext.getExprMacroTable());\n      if (queryGranularity != null) {\n        \r\n        final long rhsMillis = Calcites.calciteDateTimeLiteralToJoda(rhs, plannerContext.getTimeZone()).getMillis();\n        return buildTimeFloorFilter(ColumnHolder.TIME_COLUMN_NAME, queryGranularity, flippedKind, rhsMillis);\n      }\n\n      \r\n      if (!lhsExpression.isSimpleExtraction()) {\n        return null;\n      }\n\n      final String column = lhsExpression.getSimpleExtraction().getColumn();\n      final ExtractionFn extractionFn = lhsExpression.getSimpleExtraction().getExtractionFn();\n\n      if (column.equals(ColumnHolder.TIME_COLUMN_NAME) && extractionFn instanceof TimeFormatExtractionFn) {\n        \r\n        \r\n\n        final Granularity granularity = ExtractionFns.toQueryGranularity(extractionFn);\n        if (granularity != null) {\n          \r\n          final long rhsMillis = Calcites.calciteDateTimeLiteralToJoda(rhs, plannerContext.getTimeZone()).getMillis();\n          final Interval rhsInterval = granularity.bucket(DateTimes.utc(rhsMillis));\n\n          \r\n          final boolean rhsAligned = rhsInterval.getStartMillis() == rhsMillis;\n\n          \r\n          final BoundRefKey boundRefKey = new BoundRefKey(column, null, StringComparators.NUMERIC);\n\n          return getBoundTimeDimFilter(flippedKind, boundRefKey, rhsInterval, rhsAligned);\n        }\n      }\n\n      final String val;\n      final RexLiteral rhsLiteral = (RexLiteral) rhs;\n      if (SqlTypeName.NUMERIC_TYPES.contains(rhsLiteral.getTypeName())) {\n        val = String.valueOf(RexLiteral.value(rhsLiteral));\n      } else if (SqlTypeName.CHAR_TYPES.contains(rhsLiteral.getTypeName())) {\n        val = String.valueOf(RexLiteral.stringValue(rhsLiteral));\n      } else if (SqlTypeName.TIMESTAMP == rhsLiteral.getTypeName() || SqlTypeName.DATE == rhsLiteral.getTypeName()) {\n        val = String.valueOf(\n            Calcites.calciteDateTimeLiteralToJoda(\n                rhsLiteral,\n                plannerContext.getTimeZone()\n            ).getMillis()\n        );\n      } else {\n        \r\n        return null;\n      }\n\n      \r\n      final StringComparator comparator = Calcites.getStringComparatorForSqlTypeName(lhs.getType().getSqlTypeName());\n      final BoundRefKey boundRefKey = new BoundRefKey(column, extractionFn, comparator);\n      final DimFilter filter;\n\n      \r\n      switch (flippedKind) {\n        case EQUALS:\n          filter = Bounds.equalTo(boundRefKey, val);\n          break;\n        case NOT_EQUALS:\n          filter = new NotDimFilter(Bounds.equalTo(boundRefKey, val));\n          break;\n        case GREATER_THAN:\n          filter = Bounds.greaterThan(boundRefKey, val);\n          break;\n        case GREATER_THAN_OR_EQUAL:\n          filter = Bounds.greaterThanOrEqualTo(boundRefKey, val);\n          break;\n        case LESS_THAN:\n          filter = Bounds.lessThan(boundRefKey, val);\n          break;\n        case LESS_THAN_OR_EQUAL:\n          filter = Bounds.lessThanOrEqualTo(boundRefKey, val);\n          break;\n        default:\n          throw new IllegalStateException(\"WTF?! Shouldn't have got here...\");\n      }\n\n      return filter;\n    } else if (rexNode instanceof RexCall) {\n      final SqlOperator operator = ((RexCall) rexNode).getOperator();\n\n      final SqlOperatorConversion conversion =\n          plannerContext.getOperatorTable().lookupOperatorConversion(operator);\n\n      if (conversion == null) {\n        return null;\n      } else {\n        DimFilter filter = conversion.toDruidFilter(plannerContext, rowSignature, rexNode);\n        if (filter != null) {\n          return filter;\n        }\n        DruidExpression expression = conversion.toDruidExpression(plannerContext, rowSignature, rexNode);\n        if (expression != null) {\n          return new ExpressionDimFilter(expression.getExpression(), plannerContext.getExprMacroTable());\n        }\n      }\n    }\n    return null;\n  }\n","date":"2018-11-27 14:11:18","endLine":491,"groupId":"0","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"toSimpleLeafFilter","params":"(finalPlannerContextplannerContext@finalRowSignaturerowSignature@finalRexNoderexNode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/fd/2c1d86557722bac3f4c6d6da68588189f4cdb9.src","preCode":"  private static DimFilter toSimpleLeafFilter(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final RexNode rexNode\n  )\n  {\n    final SqlKind kind = rexNode.getKind();\n\n    if (kind == SqlKind.IS_TRUE || kind == SqlKind.IS_NOT_FALSE) {\n      return toSimpleLeafFilter(\n          plannerContext,\n          rowSignature,\n          Iterables.getOnlyElement(((RexCall) rexNode).getOperands())\n      );\n    } else if (kind == SqlKind.IS_FALSE || kind == SqlKind.IS_NOT_TRUE) {\n      return new NotDimFilter(\n          toSimpleLeafFilter(\n              plannerContext,\n              rowSignature,\n              Iterables.getOnlyElement(((RexCall) rexNode).getOperands())\n          )\n      );\n    } else if (kind == SqlKind.IS_NULL || kind == SqlKind.IS_NOT_NULL) {\n      final RexNode operand = Iterables.getOnlyElement(((RexCall) rexNode).getOperands());\n\n      \r\n      final DruidExpression druidExpression = toDruidExpression(plannerContext, rowSignature, operand);\n      if (druidExpression == null || !druidExpression.isSimpleExtraction()) {\n        return null;\n      }\n\n      final DimFilter equalFilter = new SelectorDimFilter(\n          druidExpression.getSimpleExtraction().getColumn(),\n          NullHandling.defaultStringValue(),\n          druidExpression.getSimpleExtraction().getExtractionFn()\n      );\n\n      return kind == SqlKind.IS_NOT_NULL ? new NotDimFilter(equalFilter) : equalFilter;\n    } else if (kind == SqlKind.EQUALS\n               || kind == SqlKind.NOT_EQUALS\n               || kind == SqlKind.GREATER_THAN\n               || kind == SqlKind.GREATER_THAN_OR_EQUAL\n               || kind == SqlKind.LESS_THAN\n               || kind == SqlKind.LESS_THAN_OR_EQUAL) {\n      final List<RexNode> operands = ((RexCall) rexNode).getOperands();\n      Preconditions.checkState(operands.size() == 2, \"WTF?! Expected 2 operands, got[%,d]\", operands.size());\n      boolean flip = false;\n      RexNode lhs = operands.get(0);\n      RexNode rhs = operands.get(1);\n\n      if (lhs.getKind() == SqlKind.LITERAL && rhs.getKind() != SqlKind.LITERAL) {\n        \r\n        RexNode x = lhs;\n        lhs = rhs;\n        rhs = x;\n        flip = true;\n      }\n\n      \r\n      final SqlKind flippedKind;\n\n      if (flip) {\n        switch (kind) {\n          case EQUALS:\n          case NOT_EQUALS:\n            flippedKind = kind;\n            break;\n          case GREATER_THAN:\n            flippedKind = SqlKind.LESS_THAN;\n            break;\n          case GREATER_THAN_OR_EQUAL:\n            flippedKind = SqlKind.LESS_THAN_OR_EQUAL;\n            break;\n          case LESS_THAN:\n            flippedKind = SqlKind.GREATER_THAN;\n            break;\n          case LESS_THAN_OR_EQUAL:\n            flippedKind = SqlKind.GREATER_THAN_OR_EQUAL;\n            break;\n          default:\n            throw new ISE(\"WTF?! Kind[%s] not expected here\", kind);\n        }\n      } else {\n        flippedKind = kind;\n      }\n\n      \r\n      if (rhs.getKind() != SqlKind.LITERAL) {\n        return null;\n      }\n\n      \r\n      final DruidExpression lhsExpression = toDruidExpression(plannerContext, rowSignature, lhs);\n      if (lhsExpression == null) {\n        return null;\n      }\n\n      \r\n      final Granularity queryGranularity = toQueryGranularity(lhsExpression, plannerContext.getExprMacroTable());\n      if (queryGranularity != null) {\n        \r\n        final long rhsMillis = Calcites.calciteDateTimeLiteralToJoda(rhs, plannerContext.getTimeZone()).getMillis();\n        return buildTimeFloorFilter(ColumnHolder.TIME_COLUMN_NAME, queryGranularity, flippedKind, rhsMillis);\n      }\n\n      \r\n      if (!lhsExpression.isSimpleExtraction()) {\n        return null;\n      }\n\n      final String column = lhsExpression.getSimpleExtraction().getColumn();\n      final ExtractionFn extractionFn = lhsExpression.getSimpleExtraction().getExtractionFn();\n\n      if (column.equals(ColumnHolder.TIME_COLUMN_NAME) && extractionFn instanceof TimeFormatExtractionFn) {\n        \r\n        \r\n\n        final Granularity granularity = ExtractionFns.toQueryGranularity(extractionFn);\n        if (granularity != null) {\n          \r\n          final long rhsMillis = Calcites.calciteDateTimeLiteralToJoda(rhs, plannerContext.getTimeZone()).getMillis();\n          final Interval rhsInterval = granularity.bucket(DateTimes.utc(rhsMillis));\n\n          \r\n          final boolean rhsAligned = rhsInterval.getStartMillis() == rhsMillis;\n\n          \r\n          final BoundRefKey boundRefKey = new BoundRefKey(column, null, StringComparators.NUMERIC);\n\n          switch (flippedKind) {\n            case EQUALS:\n              return rhsAligned\n                     ? Bounds.interval(boundRefKey, rhsInterval)\n                     : Filtration.matchNothing();\n            case NOT_EQUALS:\n              return rhsAligned\n                     ? new NotDimFilter(Bounds.interval(boundRefKey, rhsInterval))\n                     : Filtration.matchEverything();\n            case GREATER_THAN:\n              return Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n            case GREATER_THAN_OR_EQUAL:\n              return rhsAligned\n                     ? Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getStartMillis()))\n                     : Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n            case LESS_THAN:\n              return rhsAligned\n                     ? Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getStartMillis()))\n                     : Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n            case LESS_THAN_OR_EQUAL:\n              return Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n            default:\n              throw new IllegalStateException(\"WTF?! Shouldn't have got here...\");\n          }\n        }\n      }\n\n      final String val;\n      final RexLiteral rhsLiteral = (RexLiteral) rhs;\n      if (SqlTypeName.NUMERIC_TYPES.contains(rhsLiteral.getTypeName())) {\n        val = String.valueOf(RexLiteral.value(rhsLiteral));\n      } else if (SqlTypeName.CHAR_TYPES.contains(rhsLiteral.getTypeName())) {\n        val = String.valueOf(RexLiteral.stringValue(rhsLiteral));\n      } else if (SqlTypeName.TIMESTAMP == rhsLiteral.getTypeName() || SqlTypeName.DATE == rhsLiteral.getTypeName()) {\n        val = String.valueOf(\n            Calcites.calciteDateTimeLiteralToJoda(\n                rhsLiteral,\n                plannerContext.getTimeZone()\n            ).getMillis()\n        );\n      } else {\n        \r\n        return null;\n      }\n\n      \r\n      final StringComparator comparator = Calcites.getStringComparatorForSqlTypeName(lhs.getType().getSqlTypeName());\n      final BoundRefKey boundRefKey = new BoundRefKey(column, extractionFn, comparator);\n      final DimFilter filter;\n\n      \r\n      switch (flippedKind) {\n        case EQUALS:\n          filter = Bounds.equalTo(boundRefKey, val);\n          break;\n        case NOT_EQUALS:\n          filter = new NotDimFilter(Bounds.equalTo(boundRefKey, val));\n          break;\n        case GREATER_THAN:\n          filter = Bounds.greaterThan(boundRefKey, val);\n          break;\n        case GREATER_THAN_OR_EQUAL:\n          filter = Bounds.greaterThanOrEqualTo(boundRefKey, val);\n          break;\n        case LESS_THAN:\n          filter = Bounds.lessThan(boundRefKey, val);\n          break;\n        case LESS_THAN_OR_EQUAL:\n          filter = Bounds.lessThanOrEqualTo(boundRefKey, val);\n          break;\n        default:\n          throw new IllegalStateException(\"WTF?! Shouldn't have got here...\");\n      }\n\n      return filter;\n    } else if (kind == SqlKind.LIKE) {\n      final List<RexNode> operands = ((RexCall) rexNode).getOperands();\n      final DruidExpression druidExpression = toDruidExpression(\n          plannerContext,\n          rowSignature,\n          operands.get(0)\n      );\n      if (druidExpression == null || !druidExpression.isSimpleExtraction()) {\n        return null;\n      }\n      return new LikeDimFilter(\n          druidExpression.getSimpleExtraction().getColumn(),\n          RexLiteral.stringValue(operands.get(1)),\n          operands.size() > 2 ? RexLiteral.stringValue(operands.get(2)) : null,\n          druidExpression.getSimpleExtraction().getExtractionFn()\n      );\n    } else {\n      return null;\n    }\n  }\n","realPath":"sql/src/main/java/org/apache/druid/sql/calcite/expression/Expressions.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":290,"status":"M"},{"authorDate":"2018-11-27 14:11:18","commitOrder":3,"curCode":"  private static DimFilter buildTimeFloorFilter(\n      final String column,\n      final Granularity granularity,\n      final SqlKind operatorKind,\n      final long rhsMillis\n  )\n  {\n    final BoundRefKey boundRefKey = new BoundRefKey(column, null, StringComparators.NUMERIC);\n    final Interval rhsInterval = granularity.bucket(DateTimes.utc(rhsMillis));\n\n    \r\n    final boolean rhsAligned = rhsInterval.getStartMillis() == rhsMillis;\n\n    return getBoundTimeDimFilter(operatorKind, boundRefKey, rhsInterval, rhsAligned);\n  }\n","date":"2018-11-27 14:11:18","endLine":582,"groupId":"11688","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"buildTimeFloorFilter","params":"(finalStringcolumn@finalGranularitygranularity@finalSqlKindoperatorKind@finallongrhsMillis)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/fd/2c1d86557722bac3f4c6d6da68588189f4cdb9.src","preCode":"  private static DimFilter buildTimeFloorFilter(\n      final String column,\n      final Granularity granularity,\n      final SqlKind operatorKind,\n      final long rhsMillis\n  )\n  {\n    final BoundRefKey boundRefKey = new BoundRefKey(column, null, StringComparators.NUMERIC);\n    final Interval rhsInterval = granularity.bucket(DateTimes.utc(rhsMillis));\n\n    \r\n    final boolean rhsAligned = rhsInterval.getStartMillis() == rhsMillis;\n\n    switch (operatorKind) {\n      case EQUALS:\n        return rhsAligned\n               ? Bounds.interval(boundRefKey, rhsInterval)\n               : Filtration.matchNothing();\n      case NOT_EQUALS:\n        return rhsAligned\n               ? new NotDimFilter(Bounds.interval(boundRefKey, rhsInterval))\n               : Filtration.matchEverything();\n      case GREATER_THAN:\n        return Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n      case GREATER_THAN_OR_EQUAL:\n        return rhsAligned\n               ? Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getStartMillis()))\n               : Bounds.greaterThanOrEqualTo(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n      case LESS_THAN:\n        return rhsAligned\n               ? Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getStartMillis()))\n               : Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n      case LESS_THAN_OR_EQUAL:\n        return Bounds.lessThan(boundRefKey, String.valueOf(rhsInterval.getEndMillis()));\n      default:\n        throw new IllegalStateException(\"WTF?! Shouldn't have got here...\");\n    }\n  }\n","realPath":"sql/src/main/java/org/apache/druid/sql/calcite/expression/Expressions.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":568,"status":"M"}],"commitId":"efdec50847846f93b5c7f42055e7d84351d7631f","commitMessage":"@@@bloom filter sql (#6502)\n\n* bloom filter sql support\n\n* docs\n\n* style fix\n\n* style fixes after rebase\n\n* use copied/patched bloomkfilter\n\n* remove context literal lookup function.  changes from review\n\n* fix build\n\n* rename LookupOperatorConversion to QueryLookupOperatorConversion\n\n* remove doc\n\n* revert unintended change\n\n* add internal exception to bloom filter deserialization exception\n","date":"2018-11-27 14:11:18","modifiedFileCount":"9","status":"M","submitter":"Clint Wylie"},{"authorTime":"2018-11-27 14:11:18","codes":[{"authorDate":"2019-03-12 02:37:58","commitOrder":4,"curCode":"  private static DimFilter toSimpleLeafFilter(\n      final PlannerContext plannerContext,\n      final DruidQuerySignature querySignature,\n      final RexNode rexNode\n  )\n  {\n    final SqlKind kind = rexNode.getKind();\n\n    if (kind == SqlKind.IS_TRUE || kind == SqlKind.IS_NOT_FALSE) {\n      return toSimpleLeafFilter(\n          plannerContext,\n          querySignature,\n          Iterables.getOnlyElement(((RexCall) rexNode).getOperands())\n      );\n    } else if (kind == SqlKind.IS_FALSE || kind == SqlKind.IS_NOT_TRUE) {\n      return new NotDimFilter(\n          toSimpleLeafFilter(\n              plannerContext,\n              querySignature,\n              Iterables.getOnlyElement(((RexCall) rexNode).getOperands())\n          )\n      );\n    } else if (kind == SqlKind.IS_NULL || kind == SqlKind.IS_NOT_NULL) {\n      final RexNode operand = Iterables.getOnlyElement(((RexCall) rexNode).getOperands());\n\n      \r\n      final DruidExpression druidExpression =\n          toDruidExpression(plannerContext, querySignature.getRowSignature(), operand);\n\n      if (druidExpression == null) {\n        return null;\n      }\n\n      final DimFilter equalFilter;\n      if (druidExpression.isSimpleExtraction()) {\n        equalFilter = new SelectorDimFilter(\n            druidExpression.getSimpleExtraction().getColumn(),\n            NullHandling.defaultStringValue(),\n            druidExpression.getSimpleExtraction().getExtractionFn()\n        );\n      } else {\n        final VirtualColumn virtualColumn = querySignature.getOrCreateVirtualColumnForExpression(\n            plannerContext,\n            druidExpression,\n            operand.getType().getSqlTypeName()\n        );\n        if (virtualColumn == null) {\n          return null;\n        }\n        equalFilter = new SelectorDimFilter(\n            virtualColumn.getOutputName(),\n            NullHandling.defaultStringValue(),\n            null\n        );\n      }\n\n      return kind == SqlKind.IS_NOT_NULL ? new NotDimFilter(equalFilter) : equalFilter;\n    } else if (kind == SqlKind.EQUALS\n               || kind == SqlKind.NOT_EQUALS\n               || kind == SqlKind.GREATER_THAN\n               || kind == SqlKind.GREATER_THAN_OR_EQUAL\n               || kind == SqlKind.LESS_THAN\n               || kind == SqlKind.LESS_THAN_OR_EQUAL) {\n      final List<RexNode> operands = ((RexCall) rexNode).getOperands();\n      Preconditions.checkState(operands.size() == 2, \"WTF?! Expected 2 operands, got[%,d]\", operands.size());\n      boolean flip = false;\n      RexNode lhs = operands.get(0);\n      RexNode rhs = operands.get(1);\n\n      if (lhs.getKind() == SqlKind.LITERAL && rhs.getKind() != SqlKind.LITERAL) {\n        \r\n        RexNode x = lhs;\n        lhs = rhs;\n        rhs = x;\n        flip = true;\n      }\n\n      \r\n      final SqlKind flippedKind;\n\n      if (flip) {\n        switch (kind) {\n          case EQUALS:\n          case NOT_EQUALS:\n            flippedKind = kind;\n            break;\n          case GREATER_THAN:\n            flippedKind = SqlKind.LESS_THAN;\n            break;\n          case GREATER_THAN_OR_EQUAL:\n            flippedKind = SqlKind.LESS_THAN_OR_EQUAL;\n            break;\n          case LESS_THAN:\n            flippedKind = SqlKind.GREATER_THAN;\n            break;\n          case LESS_THAN_OR_EQUAL:\n            flippedKind = SqlKind.GREATER_THAN_OR_EQUAL;\n            break;\n          default:\n            throw new ISE(\"WTF?! Kind[%s] not expected here\", kind);\n        }\n      } else {\n        flippedKind = kind;\n      }\n\n      \r\n      if (rhs.getKind() != SqlKind.LITERAL) {\n        return null;\n      }\n\n      \r\n      final DruidExpression lhsExpression = toDruidExpression(plannerContext, querySignature.getRowSignature(), lhs);\n      if (lhsExpression == null) {\n        return null;\n      }\n\n      \r\n      final Granularity queryGranularity = toQueryGranularity(lhsExpression, plannerContext.getExprMacroTable());\n      if (queryGranularity != null) {\n        \r\n        final long rhsMillis = Calcites.calciteDateTimeLiteralToJoda(rhs, plannerContext.getTimeZone()).getMillis();\n        return buildTimeFloorFilter(ColumnHolder.TIME_COLUMN_NAME, queryGranularity, flippedKind, rhsMillis);\n      }\n\n      final String column;\n      final ExtractionFn extractionFn;\n      if (lhsExpression.isSimpleExtraction()) {\n        column = lhsExpression.getSimpleExtraction().getColumn();\n        extractionFn = lhsExpression.getSimpleExtraction().getExtractionFn();\n      } else {\n        VirtualColumn virtualLhs = querySignature.getOrCreateVirtualColumnForExpression(\n            plannerContext,\n            lhsExpression,\n            lhs.getType().getSqlTypeName()\n        );\n        if (virtualLhs == null) {\n          return null;\n        }\n        column = virtualLhs.getOutputName();\n        extractionFn = null;\n      }\n\n      if (column.equals(ColumnHolder.TIME_COLUMN_NAME) && extractionFn instanceof TimeFormatExtractionFn) {\n        \r\n        \r\n\n        final Granularity granularity = ExtractionFns.toQueryGranularity(extractionFn);\n        if (granularity != null) {\n          \r\n          final long rhsMillis = Calcites.calciteDateTimeLiteralToJoda(rhs, plannerContext.getTimeZone()).getMillis();\n          final Interval rhsInterval = granularity.bucket(DateTimes.utc(rhsMillis));\n\n          \r\n          final boolean rhsAligned = rhsInterval.getStartMillis() == rhsMillis;\n\n          \r\n          final BoundRefKey boundRefKey = new BoundRefKey(column, null, StringComparators.NUMERIC);\n\n          return getBoundTimeDimFilter(flippedKind, boundRefKey, rhsInterval, rhsAligned);\n        }\n      }\n\n      final String val;\n      final RexLiteral rhsLiteral = (RexLiteral) rhs;\n      if (SqlTypeName.NUMERIC_TYPES.contains(rhsLiteral.getTypeName())) {\n        val = String.valueOf(RexLiteral.value(rhsLiteral));\n      } else if (SqlTypeName.CHAR_TYPES.contains(rhsLiteral.getTypeName())) {\n        val = String.valueOf(RexLiteral.stringValue(rhsLiteral));\n      } else if (SqlTypeName.TIMESTAMP == rhsLiteral.getTypeName() || SqlTypeName.DATE == rhsLiteral.getTypeName()) {\n        val = String.valueOf(\n            Calcites.calciteDateTimeLiteralToJoda(\n                rhsLiteral,\n                plannerContext.getTimeZone()\n            ).getMillis()\n        );\n      } else {\n        \r\n        return null;\n      }\n\n      \r\n      final StringComparator comparator = Calcites.getStringComparatorForSqlTypeName(lhs.getType().getSqlTypeName());\n      final BoundRefKey boundRefKey = new BoundRefKey(column, extractionFn, comparator);\n      final DimFilter filter;\n\n      \r\n      switch (flippedKind) {\n        case EQUALS:\n          filter = Bounds.equalTo(boundRefKey, val);\n          break;\n        case NOT_EQUALS:\n          filter = new NotDimFilter(Bounds.equalTo(boundRefKey, val));\n          break;\n        case GREATER_THAN:\n          filter = Bounds.greaterThan(boundRefKey, val);\n          break;\n        case GREATER_THAN_OR_EQUAL:\n          filter = Bounds.greaterThanOrEqualTo(boundRefKey, val);\n          break;\n        case LESS_THAN:\n          filter = Bounds.lessThan(boundRefKey, val);\n          break;\n        case LESS_THAN_OR_EQUAL:\n          filter = Bounds.lessThanOrEqualTo(boundRefKey, val);\n          break;\n        default:\n          throw new IllegalStateException(\"WTF?! Shouldn't have got here...\");\n      }\n\n      return filter;\n    } else if (rexNode instanceof RexCall) {\n      final SqlOperator operator = ((RexCall) rexNode).getOperator();\n\n      final SqlOperatorConversion conversion =\n          plannerContext.getOperatorTable().lookupOperatorConversion(operator);\n\n      if (conversion == null) {\n        return null;\n      } else {\n        DimFilter filter =\n            conversion.toDruidFilter(plannerContext, querySignature, rexNode);\n        if (filter != null) {\n          return filter;\n        }\n        return null;\n      }\n    }\n    return null;\n  }\n","date":"2019-03-12 02:37:58","endLine":534,"groupId":"0","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"toSimpleLeafFilter","params":"(finalPlannerContextplannerContext@finalDruidQuerySignaturequerySignature@finalRexNoderexNode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/ef/8764c48d340b6b2f41328c4f8e4b4dc3fc7c9c.src","preCode":"  private static DimFilter toSimpleLeafFilter(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      final RexNode rexNode\n  )\n  {\n    final SqlKind kind = rexNode.getKind();\n\n    if (kind == SqlKind.IS_TRUE || kind == SqlKind.IS_NOT_FALSE) {\n      return toSimpleLeafFilter(\n          plannerContext,\n          rowSignature,\n          Iterables.getOnlyElement(((RexCall) rexNode).getOperands())\n      );\n    } else if (kind == SqlKind.IS_FALSE || kind == SqlKind.IS_NOT_TRUE) {\n      return new NotDimFilter(\n          toSimpleLeafFilter(\n              plannerContext,\n              rowSignature,\n              Iterables.getOnlyElement(((RexCall) rexNode).getOperands())\n          )\n      );\n    } else if (kind == SqlKind.IS_NULL || kind == SqlKind.IS_NOT_NULL) {\n      final RexNode operand = Iterables.getOnlyElement(((RexCall) rexNode).getOperands());\n\n      \r\n      final DruidExpression druidExpression = toDruidExpression(plannerContext, rowSignature, operand);\n      if (druidExpression == null || !druidExpression.isSimpleExtraction()) {\n        return null;\n      }\n\n      final DimFilter equalFilter = new SelectorDimFilter(\n          druidExpression.getSimpleExtraction().getColumn(),\n          NullHandling.defaultStringValue(),\n          druidExpression.getSimpleExtraction().getExtractionFn()\n      );\n\n      return kind == SqlKind.IS_NOT_NULL ? new NotDimFilter(equalFilter) : equalFilter;\n    } else if (kind == SqlKind.EQUALS\n               || kind == SqlKind.NOT_EQUALS\n               || kind == SqlKind.GREATER_THAN\n               || kind == SqlKind.GREATER_THAN_OR_EQUAL\n               || kind == SqlKind.LESS_THAN\n               || kind == SqlKind.LESS_THAN_OR_EQUAL) {\n      final List<RexNode> operands = ((RexCall) rexNode).getOperands();\n      Preconditions.checkState(operands.size() == 2, \"WTF?! Expected 2 operands, got[%,d]\", operands.size());\n      boolean flip = false;\n      RexNode lhs = operands.get(0);\n      RexNode rhs = operands.get(1);\n\n      if (lhs.getKind() == SqlKind.LITERAL && rhs.getKind() != SqlKind.LITERAL) {\n        \r\n        RexNode x = lhs;\n        lhs = rhs;\n        rhs = x;\n        flip = true;\n      }\n\n      \r\n      final SqlKind flippedKind;\n\n      if (flip) {\n        switch (kind) {\n          case EQUALS:\n          case NOT_EQUALS:\n            flippedKind = kind;\n            break;\n          case GREATER_THAN:\n            flippedKind = SqlKind.LESS_THAN;\n            break;\n          case GREATER_THAN_OR_EQUAL:\n            flippedKind = SqlKind.LESS_THAN_OR_EQUAL;\n            break;\n          case LESS_THAN:\n            flippedKind = SqlKind.GREATER_THAN;\n            break;\n          case LESS_THAN_OR_EQUAL:\n            flippedKind = SqlKind.GREATER_THAN_OR_EQUAL;\n            break;\n          default:\n            throw new ISE(\"WTF?! Kind[%s] not expected here\", kind);\n        }\n      } else {\n        flippedKind = kind;\n      }\n\n      \r\n      if (rhs.getKind() != SqlKind.LITERAL) {\n        return null;\n      }\n\n      \r\n      final DruidExpression lhsExpression = toDruidExpression(plannerContext, rowSignature, lhs);\n      if (lhsExpression == null) {\n        return null;\n      }\n\n      \r\n      final Granularity queryGranularity = toQueryGranularity(lhsExpression, plannerContext.getExprMacroTable());\n      if (queryGranularity != null) {\n        \r\n        final long rhsMillis = Calcites.calciteDateTimeLiteralToJoda(rhs, plannerContext.getTimeZone()).getMillis();\n        return buildTimeFloorFilter(ColumnHolder.TIME_COLUMN_NAME, queryGranularity, flippedKind, rhsMillis);\n      }\n\n      \r\n      if (!lhsExpression.isSimpleExtraction()) {\n        return null;\n      }\n\n      final String column = lhsExpression.getSimpleExtraction().getColumn();\n      final ExtractionFn extractionFn = lhsExpression.getSimpleExtraction().getExtractionFn();\n\n      if (column.equals(ColumnHolder.TIME_COLUMN_NAME) && extractionFn instanceof TimeFormatExtractionFn) {\n        \r\n        \r\n\n        final Granularity granularity = ExtractionFns.toQueryGranularity(extractionFn);\n        if (granularity != null) {\n          \r\n          final long rhsMillis = Calcites.calciteDateTimeLiteralToJoda(rhs, plannerContext.getTimeZone()).getMillis();\n          final Interval rhsInterval = granularity.bucket(DateTimes.utc(rhsMillis));\n\n          \r\n          final boolean rhsAligned = rhsInterval.getStartMillis() == rhsMillis;\n\n          \r\n          final BoundRefKey boundRefKey = new BoundRefKey(column, null, StringComparators.NUMERIC);\n\n          return getBoundTimeDimFilter(flippedKind, boundRefKey, rhsInterval, rhsAligned);\n        }\n      }\n\n      final String val;\n      final RexLiteral rhsLiteral = (RexLiteral) rhs;\n      if (SqlTypeName.NUMERIC_TYPES.contains(rhsLiteral.getTypeName())) {\n        val = String.valueOf(RexLiteral.value(rhsLiteral));\n      } else if (SqlTypeName.CHAR_TYPES.contains(rhsLiteral.getTypeName())) {\n        val = String.valueOf(RexLiteral.stringValue(rhsLiteral));\n      } else if (SqlTypeName.TIMESTAMP == rhsLiteral.getTypeName() || SqlTypeName.DATE == rhsLiteral.getTypeName()) {\n        val = String.valueOf(\n            Calcites.calciteDateTimeLiteralToJoda(\n                rhsLiteral,\n                plannerContext.getTimeZone()\n            ).getMillis()\n        );\n      } else {\n        \r\n        return null;\n      }\n\n      \r\n      final StringComparator comparator = Calcites.getStringComparatorForSqlTypeName(lhs.getType().getSqlTypeName());\n      final BoundRefKey boundRefKey = new BoundRefKey(column, extractionFn, comparator);\n      final DimFilter filter;\n\n      \r\n      switch (flippedKind) {\n        case EQUALS:\n          filter = Bounds.equalTo(boundRefKey, val);\n          break;\n        case NOT_EQUALS:\n          filter = new NotDimFilter(Bounds.equalTo(boundRefKey, val));\n          break;\n        case GREATER_THAN:\n          filter = Bounds.greaterThan(boundRefKey, val);\n          break;\n        case GREATER_THAN_OR_EQUAL:\n          filter = Bounds.greaterThanOrEqualTo(boundRefKey, val);\n          break;\n        case LESS_THAN:\n          filter = Bounds.lessThan(boundRefKey, val);\n          break;\n        case LESS_THAN_OR_EQUAL:\n          filter = Bounds.lessThanOrEqualTo(boundRefKey, val);\n          break;\n        default:\n          throw new IllegalStateException(\"WTF?! Shouldn't have got here...\");\n      }\n\n      return filter;\n    } else if (rexNode instanceof RexCall) {\n      final SqlOperator operator = ((RexCall) rexNode).getOperator();\n\n      final SqlOperatorConversion conversion =\n          plannerContext.getOperatorTable().lookupOperatorConversion(operator);\n\n      if (conversion == null) {\n        return null;\n      } else {\n        DimFilter filter = conversion.toDruidFilter(plannerContext, rowSignature, rexNode);\n        if (filter != null) {\n          return filter;\n        }\n        DruidExpression expression = conversion.toDruidExpression(plannerContext, rowSignature, rexNode);\n        if (expression != null) {\n          return new ExpressionDimFilter(expression.getExpression(), plannerContext.getExprMacroTable());\n        }\n      }\n    }\n    return null;\n  }\n","realPath":"sql/src/main/java/org/apache/druid/sql/calcite/expression/Expressions.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":306,"status":"M"},{"authorDate":"2018-11-27 14:11:18","commitOrder":4,"curCode":"  private static DimFilter buildTimeFloorFilter(\n      final String column,\n      final Granularity granularity,\n      final SqlKind operatorKind,\n      final long rhsMillis\n  )\n  {\n    final BoundRefKey boundRefKey = new BoundRefKey(column, null, StringComparators.NUMERIC);\n    final Interval rhsInterval = granularity.bucket(DateTimes.utc(rhsMillis));\n\n    \r\n    final boolean rhsAligned = rhsInterval.getStartMillis() == rhsMillis;\n\n    return getBoundTimeDimFilter(operatorKind, boundRefKey, rhsInterval, rhsAligned);\n  }\n","date":"2018-11-27 14:11:18","endLine":582,"groupId":"11688","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"buildTimeFloorFilter","params":"(finalStringcolumn@finalGranularitygranularity@finalSqlKindoperatorKind@finallongrhsMillis)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/fd/2c1d86557722bac3f4c6d6da68588189f4cdb9.src","preCode":"  private static DimFilter buildTimeFloorFilter(\n      final String column,\n      final Granularity granularity,\n      final SqlKind operatorKind,\n      final long rhsMillis\n  )\n  {\n    final BoundRefKey boundRefKey = new BoundRefKey(column, null, StringComparators.NUMERIC);\n    final Interval rhsInterval = granularity.bucket(DateTimes.utc(rhsMillis));\n\n    \r\n    final boolean rhsAligned = rhsInterval.getStartMillis() == rhsMillis;\n\n    return getBoundTimeDimFilter(operatorKind, boundRefKey, rhsInterval, rhsAligned);\n  }\n","realPath":"sql/src/main/java/org/apache/druid/sql/calcite/expression/Expressions.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":568,"status":"N"}],"commitId":"d7ba19d477732578fc310831ed28365b36332752","commitMessage":"@@@sql.  filters.  and virtual columns  (#6902)\n\n* refactor sql planning to re-use expression virtual columns when possible when constructing a DruidQuery.  allowing virtual columns to be defined in filter expressions.  and making resulting native druid queries more concise. also minor refactor of built-in sql aggregators to maximize code re-use\n\n* fix it\n\n* fix it in the right place\n\n* fixup for base64 stuff\n\n* fixup tests\n\n* fix merge conflict on import order\n\n* fixup\n\n* fix imports\n\n* fix tests\n\n* review comments\n\n* refactor\n\n* re-arrange\n\n* better javadoc\n\n* fixup merge\n\n* fixup tests\n\n* fix accidental changes\n","date":"2019-03-12 02:37:58","modifiedFileCount":"33","status":"M","submitter":"Clint Wylie"},{"authorTime":"2018-11-27 14:11:18","codes":[{"authorDate":"2019-05-31 03:56:29","commitOrder":5,"curCode":"  private static DimFilter toSimpleLeafFilter(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      @Nullable final VirtualColumnRegistry virtualColumnRegistry,\n      final RexNode rexNode\n  )\n  {\n    final SqlKind kind = rexNode.getKind();\n\n    if (kind == SqlKind.IS_TRUE || kind == SqlKind.IS_NOT_FALSE) {\n      return toSimpleLeafFilter(\n          plannerContext,\n          rowSignature,\n          virtualColumnRegistry,\n          Iterables.getOnlyElement(((RexCall) rexNode).getOperands())\n      );\n    } else if (kind == SqlKind.IS_FALSE || kind == SqlKind.IS_NOT_TRUE) {\n      return new NotDimFilter(\n          toSimpleLeafFilter(\n              plannerContext,\n              rowSignature,\n              virtualColumnRegistry,\n              Iterables.getOnlyElement(((RexCall) rexNode).getOperands())\n          )\n      );\n    } else if (kind == SqlKind.IS_NULL || kind == SqlKind.IS_NOT_NULL) {\n      final RexNode operand = Iterables.getOnlyElement(((RexCall) rexNode).getOperands());\n\n      final DruidExpression druidExpression = toDruidExpression(plannerContext, rowSignature, operand);\n      if (druidExpression == null) {\n        return null;\n      }\n\n      final DimFilter equalFilter;\n      if (druidExpression.isSimpleExtraction()) {\n        equalFilter = new SelectorDimFilter(\n            druidExpression.getSimpleExtraction().getColumn(),\n            NullHandling.defaultStringValue(),\n            druidExpression.getSimpleExtraction().getExtractionFn()\n        );\n      } else if (virtualColumnRegistry != null) {\n        final VirtualColumn virtualColumn = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n            plannerContext,\n            druidExpression,\n            operand.getType().getSqlTypeName()\n        );\n\n        equalFilter = new SelectorDimFilter(\n            virtualColumn.getOutputName(),\n            NullHandling.defaultStringValue(),\n            null\n        );\n      } else {\n        return null;\n      }\n\n      return kind == SqlKind.IS_NOT_NULL ? new NotDimFilter(equalFilter) : equalFilter;\n    } else if (kind == SqlKind.EQUALS\n               || kind == SqlKind.NOT_EQUALS\n               || kind == SqlKind.GREATER_THAN\n               || kind == SqlKind.GREATER_THAN_OR_EQUAL\n               || kind == SqlKind.LESS_THAN\n               || kind == SqlKind.LESS_THAN_OR_EQUAL) {\n      final List<RexNode> operands = ((RexCall) rexNode).getOperands();\n      Preconditions.checkState(operands.size() == 2, \"WTF?! Expected 2 operands, got[%,d]\", operands.size());\n      boolean flip = false;\n      RexNode lhs = operands.get(0);\n      RexNode rhs = operands.get(1);\n\n      if (lhs.getKind() == SqlKind.LITERAL && rhs.getKind() != SqlKind.LITERAL) {\n        \r\n        RexNode x = lhs;\n        lhs = rhs;\n        rhs = x;\n        flip = true;\n      }\n\n      \r\n      final SqlKind flippedKind;\n\n      if (flip) {\n        switch (kind) {\n          case EQUALS:\n          case NOT_EQUALS:\n            flippedKind = kind;\n            break;\n          case GREATER_THAN:\n            flippedKind = SqlKind.LESS_THAN;\n            break;\n          case GREATER_THAN_OR_EQUAL:\n            flippedKind = SqlKind.LESS_THAN_OR_EQUAL;\n            break;\n          case LESS_THAN:\n            flippedKind = SqlKind.GREATER_THAN;\n            break;\n          case LESS_THAN_OR_EQUAL:\n            flippedKind = SqlKind.GREATER_THAN_OR_EQUAL;\n            break;\n          default:\n            throw new ISE(\"WTF?! Kind[%s] not expected here\", kind);\n        }\n      } else {\n        flippedKind = kind;\n      }\n\n      \r\n      if (rhs.getKind() != SqlKind.LITERAL) {\n        return null;\n      }\n\n      \r\n      final DruidExpression lhsExpression = toDruidExpression(plannerContext, rowSignature, lhs);\n      if (lhsExpression == null) {\n        return null;\n      }\n\n      \r\n      final Granularity queryGranularity = toQueryGranularity(lhsExpression, plannerContext.getExprMacroTable());\n      if (queryGranularity != null) {\n        \r\n        final long rhsMillis = Calcites.calciteDateTimeLiteralToJoda(rhs, plannerContext.getTimeZone()).getMillis();\n        return buildTimeFloorFilter(ColumnHolder.TIME_COLUMN_NAME, queryGranularity, flippedKind, rhsMillis);\n      }\n\n      final String column;\n      final ExtractionFn extractionFn;\n      if (lhsExpression.isSimpleExtraction()) {\n        column = lhsExpression.getSimpleExtraction().getColumn();\n        extractionFn = lhsExpression.getSimpleExtraction().getExtractionFn();\n      } else if (virtualColumnRegistry != null) {\n        VirtualColumn virtualLhs = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n            plannerContext,\n            lhsExpression,\n            lhs.getType().getSqlTypeName()\n        );\n\n        column = virtualLhs.getOutputName();\n        extractionFn = null;\n      } else {\n        return null;\n      }\n\n      if (column.equals(ColumnHolder.TIME_COLUMN_NAME) && extractionFn instanceof TimeFormatExtractionFn) {\n        \r\n        \r\n\n        final Granularity granularity = ExtractionFns.toQueryGranularity(extractionFn);\n        if (granularity != null) {\n          \r\n          final long rhsMillis = Calcites.calciteDateTimeLiteralToJoda(rhs, plannerContext.getTimeZone()).getMillis();\n          final Interval rhsInterval = granularity.bucket(DateTimes.utc(rhsMillis));\n\n          \r\n          final boolean rhsAligned = rhsInterval.getStartMillis() == rhsMillis;\n\n          \r\n          final BoundRefKey boundRefKey = new BoundRefKey(column, null, StringComparators.NUMERIC);\n\n          return getBoundTimeDimFilter(flippedKind, boundRefKey, rhsInterval, rhsAligned);\n        }\n      }\n\n      final String val;\n      final RexLiteral rhsLiteral = (RexLiteral) rhs;\n      if (SqlTypeName.NUMERIC_TYPES.contains(rhsLiteral.getTypeName())) {\n        val = String.valueOf(RexLiteral.value(rhsLiteral));\n      } else if (SqlTypeName.CHAR_TYPES.contains(rhsLiteral.getTypeName())) {\n        val = String.valueOf(RexLiteral.stringValue(rhsLiteral));\n      } else if (SqlTypeName.TIMESTAMP == rhsLiteral.getTypeName() || SqlTypeName.DATE == rhsLiteral.getTypeName()) {\n        val = String.valueOf(\n            Calcites.calciteDateTimeLiteralToJoda(\n                rhsLiteral,\n                plannerContext.getTimeZone()\n            ).getMillis()\n        );\n      } else {\n        \r\n        return null;\n      }\n\n      \r\n      final StringComparator comparator = Calcites.getStringComparatorForSqlTypeName(lhs.getType().getSqlTypeName());\n      final BoundRefKey boundRefKey = new BoundRefKey(column, extractionFn, comparator);\n      final DimFilter filter;\n\n      \r\n      switch (flippedKind) {\n        case EQUALS:\n          filter = Bounds.equalTo(boundRefKey, val);\n          break;\n        case NOT_EQUALS:\n          filter = new NotDimFilter(Bounds.equalTo(boundRefKey, val));\n          break;\n        case GREATER_THAN:\n          filter = Bounds.greaterThan(boundRefKey, val);\n          break;\n        case GREATER_THAN_OR_EQUAL:\n          filter = Bounds.greaterThanOrEqualTo(boundRefKey, val);\n          break;\n        case LESS_THAN:\n          filter = Bounds.lessThan(boundRefKey, val);\n          break;\n        case LESS_THAN_OR_EQUAL:\n          filter = Bounds.lessThanOrEqualTo(boundRefKey, val);\n          break;\n        default:\n          throw new IllegalStateException(\"WTF?! Shouldn't have got here...\");\n      }\n\n      return filter;\n    } else if (rexNode instanceof RexCall) {\n      final SqlOperator operator = ((RexCall) rexNode).getOperator();\n      final SqlOperatorConversion conversion = plannerContext.getOperatorTable().lookupOperatorConversion(operator);\n\n      if (conversion == null) {\n        return null;\n      } else {\n        return conversion.toDruidFilter(plannerContext, rowSignature, virtualColumnRegistry, rexNode);\n      }\n    } else {\n      return null;\n    }\n  }\n","date":"2019-05-31 03:56:29","endLine":547,"groupId":"5790","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"toSimpleLeafFilter","params":"(finalPlannerContextplannerContext@finalRowSignaturerowSignature@@NullablefinalVirtualColumnRegistryvirtualColumnRegistry@finalRexNoderexNode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/24/13cdb9ec5ef74ff80622f43ae61fbc9ca30cd5.src","preCode":"  private static DimFilter toSimpleLeafFilter(\n      final PlannerContext plannerContext,\n      final DruidQuerySignature querySignature,\n      final RexNode rexNode\n  )\n  {\n    final SqlKind kind = rexNode.getKind();\n\n    if (kind == SqlKind.IS_TRUE || kind == SqlKind.IS_NOT_FALSE) {\n      return toSimpleLeafFilter(\n          plannerContext,\n          querySignature,\n          Iterables.getOnlyElement(((RexCall) rexNode).getOperands())\n      );\n    } else if (kind == SqlKind.IS_FALSE || kind == SqlKind.IS_NOT_TRUE) {\n      return new NotDimFilter(\n          toSimpleLeafFilter(\n              plannerContext,\n              querySignature,\n              Iterables.getOnlyElement(((RexCall) rexNode).getOperands())\n          )\n      );\n    } else if (kind == SqlKind.IS_NULL || kind == SqlKind.IS_NOT_NULL) {\n      final RexNode operand = Iterables.getOnlyElement(((RexCall) rexNode).getOperands());\n\n      \r\n      final DruidExpression druidExpression =\n          toDruidExpression(plannerContext, querySignature.getRowSignature(), operand);\n\n      if (druidExpression == null) {\n        return null;\n      }\n\n      final DimFilter equalFilter;\n      if (druidExpression.isSimpleExtraction()) {\n        equalFilter = new SelectorDimFilter(\n            druidExpression.getSimpleExtraction().getColumn(),\n            NullHandling.defaultStringValue(),\n            druidExpression.getSimpleExtraction().getExtractionFn()\n        );\n      } else {\n        final VirtualColumn virtualColumn = querySignature.getOrCreateVirtualColumnForExpression(\n            plannerContext,\n            druidExpression,\n            operand.getType().getSqlTypeName()\n        );\n        if (virtualColumn == null) {\n          return null;\n        }\n        equalFilter = new SelectorDimFilter(\n            virtualColumn.getOutputName(),\n            NullHandling.defaultStringValue(),\n            null\n        );\n      }\n\n      return kind == SqlKind.IS_NOT_NULL ? new NotDimFilter(equalFilter) : equalFilter;\n    } else if (kind == SqlKind.EQUALS\n               || kind == SqlKind.NOT_EQUALS\n               || kind == SqlKind.GREATER_THAN\n               || kind == SqlKind.GREATER_THAN_OR_EQUAL\n               || kind == SqlKind.LESS_THAN\n               || kind == SqlKind.LESS_THAN_OR_EQUAL) {\n      final List<RexNode> operands = ((RexCall) rexNode).getOperands();\n      Preconditions.checkState(operands.size() == 2, \"WTF?! Expected 2 operands, got[%,d]\", operands.size());\n      boolean flip = false;\n      RexNode lhs = operands.get(0);\n      RexNode rhs = operands.get(1);\n\n      if (lhs.getKind() == SqlKind.LITERAL && rhs.getKind() != SqlKind.LITERAL) {\n        \r\n        RexNode x = lhs;\n        lhs = rhs;\n        rhs = x;\n        flip = true;\n      }\n\n      \r\n      final SqlKind flippedKind;\n\n      if (flip) {\n        switch (kind) {\n          case EQUALS:\n          case NOT_EQUALS:\n            flippedKind = kind;\n            break;\n          case GREATER_THAN:\n            flippedKind = SqlKind.LESS_THAN;\n            break;\n          case GREATER_THAN_OR_EQUAL:\n            flippedKind = SqlKind.LESS_THAN_OR_EQUAL;\n            break;\n          case LESS_THAN:\n            flippedKind = SqlKind.GREATER_THAN;\n            break;\n          case LESS_THAN_OR_EQUAL:\n            flippedKind = SqlKind.GREATER_THAN_OR_EQUAL;\n            break;\n          default:\n            throw new ISE(\"WTF?! Kind[%s] not expected here\", kind);\n        }\n      } else {\n        flippedKind = kind;\n      }\n\n      \r\n      if (rhs.getKind() != SqlKind.LITERAL) {\n        return null;\n      }\n\n      \r\n      final DruidExpression lhsExpression = toDruidExpression(plannerContext, querySignature.getRowSignature(), lhs);\n      if (lhsExpression == null) {\n        return null;\n      }\n\n      \r\n      final Granularity queryGranularity = toQueryGranularity(lhsExpression, plannerContext.getExprMacroTable());\n      if (queryGranularity != null) {\n        \r\n        final long rhsMillis = Calcites.calciteDateTimeLiteralToJoda(rhs, plannerContext.getTimeZone()).getMillis();\n        return buildTimeFloorFilter(ColumnHolder.TIME_COLUMN_NAME, queryGranularity, flippedKind, rhsMillis);\n      }\n\n      final String column;\n      final ExtractionFn extractionFn;\n      if (lhsExpression.isSimpleExtraction()) {\n        column = lhsExpression.getSimpleExtraction().getColumn();\n        extractionFn = lhsExpression.getSimpleExtraction().getExtractionFn();\n      } else {\n        VirtualColumn virtualLhs = querySignature.getOrCreateVirtualColumnForExpression(\n            plannerContext,\n            lhsExpression,\n            lhs.getType().getSqlTypeName()\n        );\n        if (virtualLhs == null) {\n          return null;\n        }\n        column = virtualLhs.getOutputName();\n        extractionFn = null;\n      }\n\n      if (column.equals(ColumnHolder.TIME_COLUMN_NAME) && extractionFn instanceof TimeFormatExtractionFn) {\n        \r\n        \r\n\n        final Granularity granularity = ExtractionFns.toQueryGranularity(extractionFn);\n        if (granularity != null) {\n          \r\n          final long rhsMillis = Calcites.calciteDateTimeLiteralToJoda(rhs, plannerContext.getTimeZone()).getMillis();\n          final Interval rhsInterval = granularity.bucket(DateTimes.utc(rhsMillis));\n\n          \r\n          final boolean rhsAligned = rhsInterval.getStartMillis() == rhsMillis;\n\n          \r\n          final BoundRefKey boundRefKey = new BoundRefKey(column, null, StringComparators.NUMERIC);\n\n          return getBoundTimeDimFilter(flippedKind, boundRefKey, rhsInterval, rhsAligned);\n        }\n      }\n\n      final String val;\n      final RexLiteral rhsLiteral = (RexLiteral) rhs;\n      if (SqlTypeName.NUMERIC_TYPES.contains(rhsLiteral.getTypeName())) {\n        val = String.valueOf(RexLiteral.value(rhsLiteral));\n      } else if (SqlTypeName.CHAR_TYPES.contains(rhsLiteral.getTypeName())) {\n        val = String.valueOf(RexLiteral.stringValue(rhsLiteral));\n      } else if (SqlTypeName.TIMESTAMP == rhsLiteral.getTypeName() || SqlTypeName.DATE == rhsLiteral.getTypeName()) {\n        val = String.valueOf(\n            Calcites.calciteDateTimeLiteralToJoda(\n                rhsLiteral,\n                plannerContext.getTimeZone()\n            ).getMillis()\n        );\n      } else {\n        \r\n        return null;\n      }\n\n      \r\n      final StringComparator comparator = Calcites.getStringComparatorForSqlTypeName(lhs.getType().getSqlTypeName());\n      final BoundRefKey boundRefKey = new BoundRefKey(column, extractionFn, comparator);\n      final DimFilter filter;\n\n      \r\n      switch (flippedKind) {\n        case EQUALS:\n          filter = Bounds.equalTo(boundRefKey, val);\n          break;\n        case NOT_EQUALS:\n          filter = new NotDimFilter(Bounds.equalTo(boundRefKey, val));\n          break;\n        case GREATER_THAN:\n          filter = Bounds.greaterThan(boundRefKey, val);\n          break;\n        case GREATER_THAN_OR_EQUAL:\n          filter = Bounds.greaterThanOrEqualTo(boundRefKey, val);\n          break;\n        case LESS_THAN:\n          filter = Bounds.lessThan(boundRefKey, val);\n          break;\n        case LESS_THAN_OR_EQUAL:\n          filter = Bounds.lessThanOrEqualTo(boundRefKey, val);\n          break;\n        default:\n          throw new IllegalStateException(\"WTF?! Shouldn't have got here...\");\n      }\n\n      return filter;\n    } else if (rexNode instanceof RexCall) {\n      final SqlOperator operator = ((RexCall) rexNode).getOperator();\n\n      final SqlOperatorConversion conversion =\n          plannerContext.getOperatorTable().lookupOperatorConversion(operator);\n\n      if (conversion == null) {\n        return null;\n      } else {\n        DimFilter filter =\n            conversion.toDruidFilter(plannerContext, querySignature, rexNode);\n        if (filter != null) {\n          return filter;\n        }\n        return null;\n      }\n    }\n    return null;\n  }\n","realPath":"sql/src/main/java/org/apache/druid/sql/calcite/expression/Expressions.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":325,"status":"M"},{"authorDate":"2018-11-27 14:11:18","commitOrder":5,"curCode":"  private static DimFilter buildTimeFloorFilter(\n      final String column,\n      final Granularity granularity,\n      final SqlKind operatorKind,\n      final long rhsMillis\n  )\n  {\n    final BoundRefKey boundRefKey = new BoundRefKey(column, null, StringComparators.NUMERIC);\n    final Interval rhsInterval = granularity.bucket(DateTimes.utc(rhsMillis));\n\n    \r\n    final boolean rhsAligned = rhsInterval.getStartMillis() == rhsMillis;\n\n    return getBoundTimeDimFilter(operatorKind, boundRefKey, rhsInterval, rhsAligned);\n  }\n","date":"2018-11-27 14:11:18","endLine":582,"groupId":"11688","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"buildTimeFloorFilter","params":"(finalStringcolumn@finalGranularitygranularity@finalSqlKindoperatorKind@finallongrhsMillis)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/fd/2c1d86557722bac3f4c6d6da68588189f4cdb9.src","preCode":"  private static DimFilter buildTimeFloorFilter(\n      final String column,\n      final Granularity granularity,\n      final SqlKind operatorKind,\n      final long rhsMillis\n  )\n  {\n    final BoundRefKey boundRefKey = new BoundRefKey(column, null, StringComparators.NUMERIC);\n    final Interval rhsInterval = granularity.bucket(DateTimes.utc(rhsMillis));\n\n    \r\n    final boolean rhsAligned = rhsInterval.getStartMillis() == rhsMillis;\n\n    return getBoundTimeDimFilter(operatorKind, boundRefKey, rhsInterval, rhsAligned);\n  }\n","realPath":"sql/src/main/java/org/apache/druid/sql/calcite/expression/Expressions.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":568,"status":"N"}],"commitId":"8649b8ab4caad29d77897272bfae7ffcde054f25","commitMessage":"@@@SQL: Allow select-sort-project query shapes. (#7769)\n\n* SQL: Allow select-sort-project query shapes.\n\nFixes #7768.\n\nDesign changes:\n\n- In PartialDruidQuery.  allow projection after select + sort by removing\n  the SELECT_SORT query stage and instead allowing the SORT and\n  SORT_PROJECT stages to apply either after aggregation or after a plain\n  non-aggregating select. This is different from prior behavior.  where\n  SORT and SORT_PROJECT were only considered valid after aggregation\n  stages. This logic change is in the \"canAccept\" method.\n- In DruidQuery.  represent either kind of sorting with a single \"Sorting\"\n  class (instead of DefaultLimitSpec). The Sorting class is still\n  convertible into a DefaultLimitSpec.  but is also convertible into the\n  sorting parameters accepted by a Scan query.\n- In DruidQuery.  represent post-select and post-sorting projections with\n  a single \"Projection\" class. This obsoletes the SortProject and\n  SelectProjection classes.  and simplifies the DruidQuery by allowing us\n  to move virtual-column and post-aggregator-creation logic into the\n  new Projection class.\n- Split \"DruidQuerySignature\" into RowSignature and VirtualColumnRegistry.\n  This effectively means that instead of having mutable and immutable\n  versions of DruidQuerySignature.  we instead of RowSignature (always\n  immutable) and VirtualColumnRegistry (always mutable.  but sometimes\n  null). This change wasn't required.  but IMO it this makes the logic\n  involving them easier to follow.  and makes it more clear when the\n  virtual column registry is active and when it's not.\n\nOther changes:\n\n- ConvertBoundsToSelectors now just accepts a RowSignature.  but we\n  use the VirtualColumnRegistry.getFullRowSignature() method to get\n  a signature that includes all columns.  and therefore allows us to\n  simplify the logic (no need to special-case virtual columns).\n- Add `__time` to the Scan column list if the query is ordering by time.\n\n* Remove unused import.\n","date":"2019-05-31 03:56:29","modifiedFileCount":"25","status":"M","submitter":"Gian Merlino"},{"authorTime":"2018-11-27 14:11:18","codes":[{"authorDate":"2020-08-27 01:53:44","commitOrder":6,"curCode":"  private static DimFilter toSimpleLeafFilter(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      @Nullable final VirtualColumnRegistry virtualColumnRegistry,\n      final RexNode rexNode\n  )\n  {\n    final SqlKind kind = rexNode.getKind();\n\n    if (kind == SqlKind.IS_TRUE || kind == SqlKind.IS_NOT_FALSE) {\n      return toSimpleLeafFilter(\n          plannerContext,\n          rowSignature,\n          virtualColumnRegistry,\n          Iterables.getOnlyElement(((RexCall) rexNode).getOperands())\n      );\n    } else if (kind == SqlKind.IS_FALSE || kind == SqlKind.IS_NOT_TRUE) {\n      return new NotDimFilter(\n          toSimpleLeafFilter(\n              plannerContext,\n              rowSignature,\n              virtualColumnRegistry,\n              Iterables.getOnlyElement(((RexCall) rexNode).getOperands())\n          )\n      );\n    } else if (kind == SqlKind.IS_NULL || kind == SqlKind.IS_NOT_NULL) {\n      final RexNode operand = Iterables.getOnlyElement(((RexCall) rexNode).getOperands());\n\n      final DruidExpression druidExpression = toDruidExpression(plannerContext, rowSignature, operand);\n      if (druidExpression == null) {\n        return null;\n      }\n\n      final DimFilter equalFilter;\n      if (druidExpression.isSimpleExtraction()) {\n        equalFilter = new SelectorDimFilter(\n            druidExpression.getSimpleExtraction().getColumn(),\n            NullHandling.defaultStringValue(),\n            druidExpression.getSimpleExtraction().getExtractionFn()\n        );\n      } else if (virtualColumnRegistry != null) {\n        final VirtualColumn virtualColumn = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n            plannerContext,\n            druidExpression,\n            operand.getType()\n        );\n\n        equalFilter = new SelectorDimFilter(\n            virtualColumn.getOutputName(),\n            NullHandling.defaultStringValue(),\n            null\n        );\n      } else {\n        return null;\n      }\n\n      return kind == SqlKind.IS_NOT_NULL ? new NotDimFilter(equalFilter) : equalFilter;\n    } else if (kind == SqlKind.EQUALS\n               || kind == SqlKind.NOT_EQUALS\n               || kind == SqlKind.GREATER_THAN\n               || kind == SqlKind.GREATER_THAN_OR_EQUAL\n               || kind == SqlKind.LESS_THAN\n               || kind == SqlKind.LESS_THAN_OR_EQUAL) {\n      final List<RexNode> operands = ((RexCall) rexNode).getOperands();\n      Preconditions.checkState(operands.size() == 2, \"WTF?! Expected 2 operands, got[%,d]\", operands.size());\n      boolean flip = false;\n      RexNode lhs = operands.get(0);\n      RexNode rhs = operands.get(1);\n\n      if (lhs.getKind() == SqlKind.LITERAL && rhs.getKind() != SqlKind.LITERAL) {\n        \r\n        RexNode x = lhs;\n        lhs = rhs;\n        rhs = x;\n        flip = true;\n      }\n\n      \r\n      final SqlKind flippedKind;\n\n      if (flip) {\n        switch (kind) {\n          case EQUALS:\n          case NOT_EQUALS:\n            flippedKind = kind;\n            break;\n          case GREATER_THAN:\n            flippedKind = SqlKind.LESS_THAN;\n            break;\n          case GREATER_THAN_OR_EQUAL:\n            flippedKind = SqlKind.LESS_THAN_OR_EQUAL;\n            break;\n          case LESS_THAN:\n            flippedKind = SqlKind.GREATER_THAN;\n            break;\n          case LESS_THAN_OR_EQUAL:\n            flippedKind = SqlKind.GREATER_THAN_OR_EQUAL;\n            break;\n          default:\n            throw new ISE(\"WTF?! Kind[%s] not expected here\", kind);\n        }\n      } else {\n        flippedKind = kind;\n      }\n\n      \r\n      if (rhs.getKind() != SqlKind.LITERAL) {\n        return null;\n      }\n\n      \r\n      final DruidExpression lhsExpression = toDruidExpression(plannerContext, rowSignature, lhs);\n      if (lhsExpression == null) {\n        return null;\n      }\n\n      \r\n      final Granularity queryGranularity = toQueryGranularity(lhsExpression, plannerContext.getExprMacroTable());\n      if (queryGranularity != null) {\n        \r\n        final long rhsMillis = Calcites.calciteDateTimeLiteralToJoda(rhs, plannerContext.getTimeZone()).getMillis();\n        return buildTimeFloorFilter(ColumnHolder.TIME_COLUMN_NAME, queryGranularity, flippedKind, rhsMillis);\n      }\n\n      final String column;\n      final ExtractionFn extractionFn;\n      if (lhsExpression.isSimpleExtraction()) {\n        column = lhsExpression.getSimpleExtraction().getColumn();\n        extractionFn = lhsExpression.getSimpleExtraction().getExtractionFn();\n      } else if (virtualColumnRegistry != null) {\n        VirtualColumn virtualLhs = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n            plannerContext,\n            lhsExpression,\n            lhs.getType()\n        );\n\n        column = virtualLhs.getOutputName();\n        extractionFn = null;\n      } else {\n        return null;\n      }\n\n      if (column.equals(ColumnHolder.TIME_COLUMN_NAME) && extractionFn instanceof TimeFormatExtractionFn) {\n        \r\n        \r\n\n        final Granularity granularity = ExtractionFns.toQueryGranularity(extractionFn);\n        if (granularity != null) {\n          \r\n          final long rhsMillis = Calcites.calciteDateTimeLiteralToJoda(rhs, plannerContext.getTimeZone()).getMillis();\n          final Interval rhsInterval = granularity.bucket(DateTimes.utc(rhsMillis));\n\n          \r\n          final boolean rhsAligned = rhsInterval.getStartMillis() == rhsMillis;\n\n          \r\n          final BoundRefKey boundRefKey = new BoundRefKey(column, null, StringComparators.NUMERIC);\n\n          return getBoundTimeDimFilter(flippedKind, boundRefKey, rhsInterval, rhsAligned);\n        }\n      }\n\n      final String val;\n      final RexLiteral rhsLiteral = (RexLiteral) rhs;\n      if (SqlTypeName.NUMERIC_TYPES.contains(rhsLiteral.getTypeName())) {\n        val = String.valueOf(RexLiteral.value(rhsLiteral));\n      } else if (SqlTypeName.CHAR_TYPES.contains(rhsLiteral.getTypeName())) {\n        val = String.valueOf(RexLiteral.stringValue(rhsLiteral));\n      } else if (SqlTypeName.TIMESTAMP == rhsLiteral.getTypeName() || SqlTypeName.DATE == rhsLiteral.getTypeName()) {\n        val = String.valueOf(\n            Calcites.calciteDateTimeLiteralToJoda(\n                rhsLiteral,\n                plannerContext.getTimeZone()\n            ).getMillis()\n        );\n      } else {\n        \r\n        return null;\n      }\n\n      \r\n      final StringComparator comparator = Calcites.getStringComparatorForRelDataType(lhs.getType());\n      final BoundRefKey boundRefKey = new BoundRefKey(column, extractionFn, comparator);\n      final DimFilter filter;\n\n      \r\n      switch (flippedKind) {\n        case EQUALS:\n          filter = Bounds.equalTo(boundRefKey, val);\n          break;\n        case NOT_EQUALS:\n          filter = new NotDimFilter(Bounds.equalTo(boundRefKey, val));\n          break;\n        case GREATER_THAN:\n          filter = Bounds.greaterThan(boundRefKey, val);\n          break;\n        case GREATER_THAN_OR_EQUAL:\n          filter = Bounds.greaterThanOrEqualTo(boundRefKey, val);\n          break;\n        case LESS_THAN:\n          filter = Bounds.lessThan(boundRefKey, val);\n          break;\n        case LESS_THAN_OR_EQUAL:\n          filter = Bounds.lessThanOrEqualTo(boundRefKey, val);\n          break;\n        default:\n          throw new IllegalStateException(\"WTF?! Shouldn't have got here...\");\n      }\n\n      return filter;\n    } else if (rexNode instanceof RexCall) {\n      final SqlOperator operator = ((RexCall) rexNode).getOperator();\n      final SqlOperatorConversion conversion = plannerContext.getOperatorTable().lookupOperatorConversion(operator);\n\n      if (conversion == null) {\n        return null;\n      } else {\n        return conversion.toDruidFilter(plannerContext, rowSignature, virtualColumnRegistry, rexNode);\n      }\n    } else {\n      return null;\n    }\n  }\n","date":"2020-08-27 01:53:44","endLine":651,"groupId":"7818","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"toSimpleLeafFilter","params":"(finalPlannerContextplannerContext@finalRowSignaturerowSignature@@NullablefinalVirtualColumnRegistryvirtualColumnRegistry@finalRexNoderexNode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/dc/657f9688fa4688e735b37aecbb5c499c5a6331.src","preCode":"  private static DimFilter toSimpleLeafFilter(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      @Nullable final VirtualColumnRegistry virtualColumnRegistry,\n      final RexNode rexNode\n  )\n  {\n    final SqlKind kind = rexNode.getKind();\n\n    if (kind == SqlKind.IS_TRUE || kind == SqlKind.IS_NOT_FALSE) {\n      return toSimpleLeafFilter(\n          plannerContext,\n          rowSignature,\n          virtualColumnRegistry,\n          Iterables.getOnlyElement(((RexCall) rexNode).getOperands())\n      );\n    } else if (kind == SqlKind.IS_FALSE || kind == SqlKind.IS_NOT_TRUE) {\n      return new NotDimFilter(\n          toSimpleLeafFilter(\n              plannerContext,\n              rowSignature,\n              virtualColumnRegistry,\n              Iterables.getOnlyElement(((RexCall) rexNode).getOperands())\n          )\n      );\n    } else if (kind == SqlKind.IS_NULL || kind == SqlKind.IS_NOT_NULL) {\n      final RexNode operand = Iterables.getOnlyElement(((RexCall) rexNode).getOperands());\n\n      final DruidExpression druidExpression = toDruidExpression(plannerContext, rowSignature, operand);\n      if (druidExpression == null) {\n        return null;\n      }\n\n      final DimFilter equalFilter;\n      if (druidExpression.isSimpleExtraction()) {\n        equalFilter = new SelectorDimFilter(\n            druidExpression.getSimpleExtraction().getColumn(),\n            NullHandling.defaultStringValue(),\n            druidExpression.getSimpleExtraction().getExtractionFn()\n        );\n      } else if (virtualColumnRegistry != null) {\n        final VirtualColumn virtualColumn = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n            plannerContext,\n            druidExpression,\n            operand.getType().getSqlTypeName()\n        );\n\n        equalFilter = new SelectorDimFilter(\n            virtualColumn.getOutputName(),\n            NullHandling.defaultStringValue(),\n            null\n        );\n      } else {\n        return null;\n      }\n\n      return kind == SqlKind.IS_NOT_NULL ? new NotDimFilter(equalFilter) : equalFilter;\n    } else if (kind == SqlKind.EQUALS\n               || kind == SqlKind.NOT_EQUALS\n               || kind == SqlKind.GREATER_THAN\n               || kind == SqlKind.GREATER_THAN_OR_EQUAL\n               || kind == SqlKind.LESS_THAN\n               || kind == SqlKind.LESS_THAN_OR_EQUAL) {\n      final List<RexNode> operands = ((RexCall) rexNode).getOperands();\n      Preconditions.checkState(operands.size() == 2, \"WTF?! Expected 2 operands, got[%,d]\", operands.size());\n      boolean flip = false;\n      RexNode lhs = operands.get(0);\n      RexNode rhs = operands.get(1);\n\n      if (lhs.getKind() == SqlKind.LITERAL && rhs.getKind() != SqlKind.LITERAL) {\n        \r\n        RexNode x = lhs;\n        lhs = rhs;\n        rhs = x;\n        flip = true;\n      }\n\n      \r\n      final SqlKind flippedKind;\n\n      if (flip) {\n        switch (kind) {\n          case EQUALS:\n          case NOT_EQUALS:\n            flippedKind = kind;\n            break;\n          case GREATER_THAN:\n            flippedKind = SqlKind.LESS_THAN;\n            break;\n          case GREATER_THAN_OR_EQUAL:\n            flippedKind = SqlKind.LESS_THAN_OR_EQUAL;\n            break;\n          case LESS_THAN:\n            flippedKind = SqlKind.GREATER_THAN;\n            break;\n          case LESS_THAN_OR_EQUAL:\n            flippedKind = SqlKind.GREATER_THAN_OR_EQUAL;\n            break;\n          default:\n            throw new ISE(\"WTF?! Kind[%s] not expected here\", kind);\n        }\n      } else {\n        flippedKind = kind;\n      }\n\n      \r\n      if (rhs.getKind() != SqlKind.LITERAL) {\n        return null;\n      }\n\n      \r\n      final DruidExpression lhsExpression = toDruidExpression(plannerContext, rowSignature, lhs);\n      if (lhsExpression == null) {\n        return null;\n      }\n\n      \r\n      final Granularity queryGranularity = toQueryGranularity(lhsExpression, plannerContext.getExprMacroTable());\n      if (queryGranularity != null) {\n        \r\n        final long rhsMillis = Calcites.calciteDateTimeLiteralToJoda(rhs, plannerContext.getTimeZone()).getMillis();\n        return buildTimeFloorFilter(ColumnHolder.TIME_COLUMN_NAME, queryGranularity, flippedKind, rhsMillis);\n      }\n\n      final String column;\n      final ExtractionFn extractionFn;\n      if (lhsExpression.isSimpleExtraction()) {\n        column = lhsExpression.getSimpleExtraction().getColumn();\n        extractionFn = lhsExpression.getSimpleExtraction().getExtractionFn();\n      } else if (virtualColumnRegistry != null) {\n        VirtualColumn virtualLhs = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n            plannerContext,\n            lhsExpression,\n            lhs.getType().getSqlTypeName()\n        );\n\n        column = virtualLhs.getOutputName();\n        extractionFn = null;\n      } else {\n        return null;\n      }\n\n      if (column.equals(ColumnHolder.TIME_COLUMN_NAME) && extractionFn instanceof TimeFormatExtractionFn) {\n        \r\n        \r\n\n        final Granularity granularity = ExtractionFns.toQueryGranularity(extractionFn);\n        if (granularity != null) {\n          \r\n          final long rhsMillis = Calcites.calciteDateTimeLiteralToJoda(rhs, plannerContext.getTimeZone()).getMillis();\n          final Interval rhsInterval = granularity.bucket(DateTimes.utc(rhsMillis));\n\n          \r\n          final boolean rhsAligned = rhsInterval.getStartMillis() == rhsMillis;\n\n          \r\n          final BoundRefKey boundRefKey = new BoundRefKey(column, null, StringComparators.NUMERIC);\n\n          return getBoundTimeDimFilter(flippedKind, boundRefKey, rhsInterval, rhsAligned);\n        }\n      }\n\n      final String val;\n      final RexLiteral rhsLiteral = (RexLiteral) rhs;\n      if (SqlTypeName.NUMERIC_TYPES.contains(rhsLiteral.getTypeName())) {\n        val = String.valueOf(RexLiteral.value(rhsLiteral));\n      } else if (SqlTypeName.CHAR_TYPES.contains(rhsLiteral.getTypeName())) {\n        val = String.valueOf(RexLiteral.stringValue(rhsLiteral));\n      } else if (SqlTypeName.TIMESTAMP == rhsLiteral.getTypeName() || SqlTypeName.DATE == rhsLiteral.getTypeName()) {\n        val = String.valueOf(\n            Calcites.calciteDateTimeLiteralToJoda(\n                rhsLiteral,\n                plannerContext.getTimeZone()\n            ).getMillis()\n        );\n      } else {\n        \r\n        return null;\n      }\n\n      \r\n      final StringComparator comparator = Calcites.getStringComparatorForSqlTypeName(lhs.getType().getSqlTypeName());\n      final BoundRefKey boundRefKey = new BoundRefKey(column, extractionFn, comparator);\n      final DimFilter filter;\n\n      \r\n      switch (flippedKind) {\n        case EQUALS:\n          filter = Bounds.equalTo(boundRefKey, val);\n          break;\n        case NOT_EQUALS:\n          filter = new NotDimFilter(Bounds.equalTo(boundRefKey, val));\n          break;\n        case GREATER_THAN:\n          filter = Bounds.greaterThan(boundRefKey, val);\n          break;\n        case GREATER_THAN_OR_EQUAL:\n          filter = Bounds.greaterThanOrEqualTo(boundRefKey, val);\n          break;\n        case LESS_THAN:\n          filter = Bounds.lessThan(boundRefKey, val);\n          break;\n        case LESS_THAN_OR_EQUAL:\n          filter = Bounds.lessThanOrEqualTo(boundRefKey, val);\n          break;\n        default:\n          throw new IllegalStateException(\"WTF?! Shouldn't have got here...\");\n      }\n\n      return filter;\n    } else if (rexNode instanceof RexCall) {\n      final SqlOperator operator = ((RexCall) rexNode).getOperator();\n      final SqlOperatorConversion conversion = plannerContext.getOperatorTable().lookupOperatorConversion(operator);\n\n      if (conversion == null) {\n        return null;\n      } else {\n        return conversion.toDruidFilter(plannerContext, rowSignature, virtualColumnRegistry, rexNode);\n      }\n    } else {\n      return null;\n    }\n  }\n","realPath":"sql/src/main/java/org/apache/druid/sql/calcite/expression/Expressions.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":429,"status":"M"},{"authorDate":"2018-11-27 14:11:18","commitOrder":6,"curCode":"  private static DimFilter buildTimeFloorFilter(\n      final String column,\n      final Granularity granularity,\n      final SqlKind operatorKind,\n      final long rhsMillis\n  )\n  {\n    final BoundRefKey boundRefKey = new BoundRefKey(column, null, StringComparators.NUMERIC);\n    final Interval rhsInterval = granularity.bucket(DateTimes.utc(rhsMillis));\n\n    \r\n    final boolean rhsAligned = rhsInterval.getStartMillis() == rhsMillis;\n\n    return getBoundTimeDimFilter(operatorKind, boundRefKey, rhsInterval, rhsAligned);\n  }\n","date":"2018-11-27 14:11:18","endLine":582,"groupId":"11688","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"buildTimeFloorFilter","params":"(finalStringcolumn@finalGranularitygranularity@finalSqlKindoperatorKind@finallongrhsMillis)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/fd/2c1d86557722bac3f4c6d6da68588189f4cdb9.src","preCode":"  private static DimFilter buildTimeFloorFilter(\n      final String column,\n      final Granularity granularity,\n      final SqlKind operatorKind,\n      final long rhsMillis\n  )\n  {\n    final BoundRefKey boundRefKey = new BoundRefKey(column, null, StringComparators.NUMERIC);\n    final Interval rhsInterval = granularity.bucket(DateTimes.utc(rhsMillis));\n\n    \r\n    final boolean rhsAligned = rhsInterval.getStartMillis() == rhsMillis;\n\n    return getBoundTimeDimFilter(operatorKind, boundRefKey, rhsInterval, rhsAligned);\n  }\n","realPath":"sql/src/main/java/org/apache/druid/sql/calcite/expression/Expressions.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":568,"status":"N"}],"commitId":"ab606610089f7bb9b4b1b68ac488764f394723fd","commitMessage":"@@@refactor internal type system (#9638)\n\n* better type tracking: add typed postaggs.  finalized types for agg factories\n\n* more javadoc\n\n* adjustments\n\n* transition to getTypeName to be used exclusively for complex types\n\n* remove unused fn\n\n* adjust\n\n* more better\n\n* rename getTypeName to getComplexTypeName\n\n* setup expression post agg for type inference existing\n\n* more javadocs\n\n* fixup\n\n* oops\n\n* more test\n\n* more test\n\n* more comments/javadoc\n\n* nulls\n\n* explicitly handle only numeric and complex aggregators for incremental index\n\n* checkstyle\n\n* more tests\n\n* adjust\n\n* more tests to showcase difference in behavior\n\n* timeseries longsum array","date":"2020-08-27 01:53:44","modifiedFileCount":"176","status":"M","submitter":"Clint Wylie"},{"authorTime":"2018-11-27 14:11:18","codes":[{"authorDate":"2020-08-29 02:38:50","commitOrder":7,"curCode":"  private static DimFilter toSimpleLeafFilter(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      @Nullable final VirtualColumnRegistry virtualColumnRegistry,\n      final RexNode rexNode\n  )\n  {\n    final SqlKind kind = rexNode.getKind();\n\n    if (kind == SqlKind.IS_TRUE || kind == SqlKind.IS_NOT_FALSE) {\n      return toSimpleLeafFilter(\n          plannerContext,\n          rowSignature,\n          virtualColumnRegistry,\n          Iterables.getOnlyElement(((RexCall) rexNode).getOperands())\n      );\n    } else if (kind == SqlKind.IS_FALSE || kind == SqlKind.IS_NOT_TRUE) {\n      return new NotDimFilter(\n          toSimpleLeafFilter(\n              plannerContext,\n              rowSignature,\n              virtualColumnRegistry,\n              Iterables.getOnlyElement(((RexCall) rexNode).getOperands())\n          )\n      );\n    } else if (kind == SqlKind.IS_NULL || kind == SqlKind.IS_NOT_NULL) {\n      final RexNode operand = Iterables.getOnlyElement(((RexCall) rexNode).getOperands());\n\n      final DruidExpression druidExpression = toDruidExpression(plannerContext, rowSignature, operand);\n      if (druidExpression == null) {\n        return null;\n      }\n\n      final DimFilter equalFilter;\n      if (druidExpression.isSimpleExtraction()) {\n        equalFilter = new SelectorDimFilter(\n            druidExpression.getSimpleExtraction().getColumn(),\n            NullHandling.defaultStringValue(),\n            druidExpression.getSimpleExtraction().getExtractionFn()\n        );\n      } else if (virtualColumnRegistry != null) {\n        final VirtualColumn virtualColumn = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n            plannerContext,\n            druidExpression,\n            operand.getType()\n        );\n\n        equalFilter = new SelectorDimFilter(\n            virtualColumn.getOutputName(),\n            NullHandling.defaultStringValue(),\n            null\n        );\n      } else {\n        return null;\n      }\n\n      return kind == SqlKind.IS_NOT_NULL ? new NotDimFilter(equalFilter) : equalFilter;\n    } else if (kind == SqlKind.EQUALS\n               || kind == SqlKind.NOT_EQUALS\n               || kind == SqlKind.GREATER_THAN\n               || kind == SqlKind.GREATER_THAN_OR_EQUAL\n               || kind == SqlKind.LESS_THAN\n               || kind == SqlKind.LESS_THAN_OR_EQUAL) {\n      final List<RexNode> operands = ((RexCall) rexNode).getOperands();\n      Preconditions.checkState(operands.size() == 2, \"Expected 2 operands, got[%,d]\", operands.size());\n      boolean flip = false;\n      RexNode lhs = operands.get(0);\n      RexNode rhs = operands.get(1);\n\n      if (lhs.getKind() == SqlKind.LITERAL && rhs.getKind() != SqlKind.LITERAL) {\n        \r\n        RexNode x = lhs;\n        lhs = rhs;\n        rhs = x;\n        flip = true;\n      }\n\n      \r\n      final SqlKind flippedKind;\n\n      if (flip) {\n        switch (kind) {\n          case EQUALS:\n          case NOT_EQUALS:\n            flippedKind = kind;\n            break;\n          case GREATER_THAN:\n            flippedKind = SqlKind.LESS_THAN;\n            break;\n          case GREATER_THAN_OR_EQUAL:\n            flippedKind = SqlKind.LESS_THAN_OR_EQUAL;\n            break;\n          case LESS_THAN:\n            flippedKind = SqlKind.GREATER_THAN;\n            break;\n          case LESS_THAN_OR_EQUAL:\n            flippedKind = SqlKind.GREATER_THAN_OR_EQUAL;\n            break;\n          default:\n            throw new ISE(\"Kind[%s] not expected here\", kind);\n        }\n      } else {\n        flippedKind = kind;\n      }\n\n      \r\n      if (rhs.getKind() != SqlKind.LITERAL) {\n        return null;\n      }\n\n      \r\n      final DruidExpression lhsExpression = toDruidExpression(plannerContext, rowSignature, lhs);\n      if (lhsExpression == null) {\n        return null;\n      }\n\n      \r\n      final Granularity queryGranularity = toQueryGranularity(lhsExpression, plannerContext.getExprMacroTable());\n      if (queryGranularity != null) {\n        \r\n        final long rhsMillis = Calcites.calciteDateTimeLiteralToJoda(rhs, plannerContext.getTimeZone()).getMillis();\n        return buildTimeFloorFilter(ColumnHolder.TIME_COLUMN_NAME, queryGranularity, flippedKind, rhsMillis);\n      }\n\n      final String column;\n      final ExtractionFn extractionFn;\n      if (lhsExpression.isSimpleExtraction()) {\n        column = lhsExpression.getSimpleExtraction().getColumn();\n        extractionFn = lhsExpression.getSimpleExtraction().getExtractionFn();\n      } else if (virtualColumnRegistry != null) {\n        VirtualColumn virtualLhs = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n            plannerContext,\n            lhsExpression,\n            lhs.getType()\n        );\n\n        column = virtualLhs.getOutputName();\n        extractionFn = null;\n      } else {\n        return null;\n      }\n\n      if (column.equals(ColumnHolder.TIME_COLUMN_NAME) && extractionFn instanceof TimeFormatExtractionFn) {\n        \r\n        \r\n\n        final Granularity granularity = ExtractionFns.toQueryGranularity(extractionFn);\n        if (granularity != null) {\n          \r\n          final long rhsMillis = Calcites.calciteDateTimeLiteralToJoda(rhs, plannerContext.getTimeZone()).getMillis();\n          final Interval rhsInterval = granularity.bucket(DateTimes.utc(rhsMillis));\n\n          \r\n          final boolean rhsAligned = rhsInterval.getStartMillis() == rhsMillis;\n\n          \r\n          final BoundRefKey boundRefKey = new BoundRefKey(column, null, StringComparators.NUMERIC);\n\n          return getBoundTimeDimFilter(flippedKind, boundRefKey, rhsInterval, rhsAligned);\n        }\n      }\n\n      final String val;\n      final RexLiteral rhsLiteral = (RexLiteral) rhs;\n      if (SqlTypeName.NUMERIC_TYPES.contains(rhsLiteral.getTypeName())) {\n        val = String.valueOf(RexLiteral.value(rhsLiteral));\n      } else if (SqlTypeName.CHAR_TYPES.contains(rhsLiteral.getTypeName())) {\n        val = String.valueOf(RexLiteral.stringValue(rhsLiteral));\n      } else if (SqlTypeName.TIMESTAMP == rhsLiteral.getTypeName() || SqlTypeName.DATE == rhsLiteral.getTypeName()) {\n        val = String.valueOf(\n            Calcites.calciteDateTimeLiteralToJoda(\n                rhsLiteral,\n                plannerContext.getTimeZone()\n            ).getMillis()\n        );\n      } else {\n        \r\n        return null;\n      }\n\n      \r\n      final StringComparator comparator = Calcites.getStringComparatorForRelDataType(lhs.getType());\n      final BoundRefKey boundRefKey = new BoundRefKey(column, extractionFn, comparator);\n      final DimFilter filter;\n\n      \r\n      switch (flippedKind) {\n        case EQUALS:\n          filter = Bounds.equalTo(boundRefKey, val);\n          break;\n        case NOT_EQUALS:\n          filter = new NotDimFilter(Bounds.equalTo(boundRefKey, val));\n          break;\n        case GREATER_THAN:\n          filter = Bounds.greaterThan(boundRefKey, val);\n          break;\n        case GREATER_THAN_OR_EQUAL:\n          filter = Bounds.greaterThanOrEqualTo(boundRefKey, val);\n          break;\n        case LESS_THAN:\n          filter = Bounds.lessThan(boundRefKey, val);\n          break;\n        case LESS_THAN_OR_EQUAL:\n          filter = Bounds.lessThanOrEqualTo(boundRefKey, val);\n          break;\n        default:\n          throw new IllegalStateException(\"Shouldn't have got here\");\n      }\n\n      return filter;\n    } else if (rexNode instanceof RexCall) {\n      final SqlOperator operator = ((RexCall) rexNode).getOperator();\n      final SqlOperatorConversion conversion = plannerContext.getOperatorTable().lookupOperatorConversion(operator);\n\n      if (conversion == null) {\n        return null;\n      } else {\n        return conversion.toDruidFilter(plannerContext, rowSignature, virtualColumnRegistry, rexNode);\n      }\n    } else {\n      return null;\n    }\n  }\n","date":"2020-08-29 02:38:50","endLine":651,"groupId":"102083","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"toSimpleLeafFilter","params":"(finalPlannerContextplannerContext@finalRowSignaturerowSignature@@NullablefinalVirtualColumnRegistryvirtualColumnRegistry@finalRexNoderexNode)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/e4/5647435b6a1d40a5e4d58a405ac37a105cd33d.src","preCode":"  private static DimFilter toSimpleLeafFilter(\n      final PlannerContext plannerContext,\n      final RowSignature rowSignature,\n      @Nullable final VirtualColumnRegistry virtualColumnRegistry,\n      final RexNode rexNode\n  )\n  {\n    final SqlKind kind = rexNode.getKind();\n\n    if (kind == SqlKind.IS_TRUE || kind == SqlKind.IS_NOT_FALSE) {\n      return toSimpleLeafFilter(\n          plannerContext,\n          rowSignature,\n          virtualColumnRegistry,\n          Iterables.getOnlyElement(((RexCall) rexNode).getOperands())\n      );\n    } else if (kind == SqlKind.IS_FALSE || kind == SqlKind.IS_NOT_TRUE) {\n      return new NotDimFilter(\n          toSimpleLeafFilter(\n              plannerContext,\n              rowSignature,\n              virtualColumnRegistry,\n              Iterables.getOnlyElement(((RexCall) rexNode).getOperands())\n          )\n      );\n    } else if (kind == SqlKind.IS_NULL || kind == SqlKind.IS_NOT_NULL) {\n      final RexNode operand = Iterables.getOnlyElement(((RexCall) rexNode).getOperands());\n\n      final DruidExpression druidExpression = toDruidExpression(plannerContext, rowSignature, operand);\n      if (druidExpression == null) {\n        return null;\n      }\n\n      final DimFilter equalFilter;\n      if (druidExpression.isSimpleExtraction()) {\n        equalFilter = new SelectorDimFilter(\n            druidExpression.getSimpleExtraction().getColumn(),\n            NullHandling.defaultStringValue(),\n            druidExpression.getSimpleExtraction().getExtractionFn()\n        );\n      } else if (virtualColumnRegistry != null) {\n        final VirtualColumn virtualColumn = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n            plannerContext,\n            druidExpression,\n            operand.getType()\n        );\n\n        equalFilter = new SelectorDimFilter(\n            virtualColumn.getOutputName(),\n            NullHandling.defaultStringValue(),\n            null\n        );\n      } else {\n        return null;\n      }\n\n      return kind == SqlKind.IS_NOT_NULL ? new NotDimFilter(equalFilter) : equalFilter;\n    } else if (kind == SqlKind.EQUALS\n               || kind == SqlKind.NOT_EQUALS\n               || kind == SqlKind.GREATER_THAN\n               || kind == SqlKind.GREATER_THAN_OR_EQUAL\n               || kind == SqlKind.LESS_THAN\n               || kind == SqlKind.LESS_THAN_OR_EQUAL) {\n      final List<RexNode> operands = ((RexCall) rexNode).getOperands();\n      Preconditions.checkState(operands.size() == 2, \"WTF?! Expected 2 operands, got[%,d]\", operands.size());\n      boolean flip = false;\n      RexNode lhs = operands.get(0);\n      RexNode rhs = operands.get(1);\n\n      if (lhs.getKind() == SqlKind.LITERAL && rhs.getKind() != SqlKind.LITERAL) {\n        \r\n        RexNode x = lhs;\n        lhs = rhs;\n        rhs = x;\n        flip = true;\n      }\n\n      \r\n      final SqlKind flippedKind;\n\n      if (flip) {\n        switch (kind) {\n          case EQUALS:\n          case NOT_EQUALS:\n            flippedKind = kind;\n            break;\n          case GREATER_THAN:\n            flippedKind = SqlKind.LESS_THAN;\n            break;\n          case GREATER_THAN_OR_EQUAL:\n            flippedKind = SqlKind.LESS_THAN_OR_EQUAL;\n            break;\n          case LESS_THAN:\n            flippedKind = SqlKind.GREATER_THAN;\n            break;\n          case LESS_THAN_OR_EQUAL:\n            flippedKind = SqlKind.GREATER_THAN_OR_EQUAL;\n            break;\n          default:\n            throw new ISE(\"WTF?! Kind[%s] not expected here\", kind);\n        }\n      } else {\n        flippedKind = kind;\n      }\n\n      \r\n      if (rhs.getKind() != SqlKind.LITERAL) {\n        return null;\n      }\n\n      \r\n      final DruidExpression lhsExpression = toDruidExpression(plannerContext, rowSignature, lhs);\n      if (lhsExpression == null) {\n        return null;\n      }\n\n      \r\n      final Granularity queryGranularity = toQueryGranularity(lhsExpression, plannerContext.getExprMacroTable());\n      if (queryGranularity != null) {\n        \r\n        final long rhsMillis = Calcites.calciteDateTimeLiteralToJoda(rhs, plannerContext.getTimeZone()).getMillis();\n        return buildTimeFloorFilter(ColumnHolder.TIME_COLUMN_NAME, queryGranularity, flippedKind, rhsMillis);\n      }\n\n      final String column;\n      final ExtractionFn extractionFn;\n      if (lhsExpression.isSimpleExtraction()) {\n        column = lhsExpression.getSimpleExtraction().getColumn();\n        extractionFn = lhsExpression.getSimpleExtraction().getExtractionFn();\n      } else if (virtualColumnRegistry != null) {\n        VirtualColumn virtualLhs = virtualColumnRegistry.getOrCreateVirtualColumnForExpression(\n            plannerContext,\n            lhsExpression,\n            lhs.getType()\n        );\n\n        column = virtualLhs.getOutputName();\n        extractionFn = null;\n      } else {\n        return null;\n      }\n\n      if (column.equals(ColumnHolder.TIME_COLUMN_NAME) && extractionFn instanceof TimeFormatExtractionFn) {\n        \r\n        \r\n\n        final Granularity granularity = ExtractionFns.toQueryGranularity(extractionFn);\n        if (granularity != null) {\n          \r\n          final long rhsMillis = Calcites.calciteDateTimeLiteralToJoda(rhs, plannerContext.getTimeZone()).getMillis();\n          final Interval rhsInterval = granularity.bucket(DateTimes.utc(rhsMillis));\n\n          \r\n          final boolean rhsAligned = rhsInterval.getStartMillis() == rhsMillis;\n\n          \r\n          final BoundRefKey boundRefKey = new BoundRefKey(column, null, StringComparators.NUMERIC);\n\n          return getBoundTimeDimFilter(flippedKind, boundRefKey, rhsInterval, rhsAligned);\n        }\n      }\n\n      final String val;\n      final RexLiteral rhsLiteral = (RexLiteral) rhs;\n      if (SqlTypeName.NUMERIC_TYPES.contains(rhsLiteral.getTypeName())) {\n        val = String.valueOf(RexLiteral.value(rhsLiteral));\n      } else if (SqlTypeName.CHAR_TYPES.contains(rhsLiteral.getTypeName())) {\n        val = String.valueOf(RexLiteral.stringValue(rhsLiteral));\n      } else if (SqlTypeName.TIMESTAMP == rhsLiteral.getTypeName() || SqlTypeName.DATE == rhsLiteral.getTypeName()) {\n        val = String.valueOf(\n            Calcites.calciteDateTimeLiteralToJoda(\n                rhsLiteral,\n                plannerContext.getTimeZone()\n            ).getMillis()\n        );\n      } else {\n        \r\n        return null;\n      }\n\n      \r\n      final StringComparator comparator = Calcites.getStringComparatorForRelDataType(lhs.getType());\n      final BoundRefKey boundRefKey = new BoundRefKey(column, extractionFn, comparator);\n      final DimFilter filter;\n\n      \r\n      switch (flippedKind) {\n        case EQUALS:\n          filter = Bounds.equalTo(boundRefKey, val);\n          break;\n        case NOT_EQUALS:\n          filter = new NotDimFilter(Bounds.equalTo(boundRefKey, val));\n          break;\n        case GREATER_THAN:\n          filter = Bounds.greaterThan(boundRefKey, val);\n          break;\n        case GREATER_THAN_OR_EQUAL:\n          filter = Bounds.greaterThanOrEqualTo(boundRefKey, val);\n          break;\n        case LESS_THAN:\n          filter = Bounds.lessThan(boundRefKey, val);\n          break;\n        case LESS_THAN_OR_EQUAL:\n          filter = Bounds.lessThanOrEqualTo(boundRefKey, val);\n          break;\n        default:\n          throw new IllegalStateException(\"WTF?! Shouldn't have got here...\");\n      }\n\n      return filter;\n    } else if (rexNode instanceof RexCall) {\n      final SqlOperator operator = ((RexCall) rexNode).getOperator();\n      final SqlOperatorConversion conversion = plannerContext.getOperatorTable().lookupOperatorConversion(operator);\n\n      if (conversion == null) {\n        return null;\n      } else {\n        return conversion.toDruidFilter(plannerContext, rowSignature, virtualColumnRegistry, rexNode);\n      }\n    } else {\n      return null;\n    }\n  }\n","realPath":"sql/src/main/java/org/apache/druid/sql/calcite/expression/Expressions.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":429,"status":"M"},{"authorDate":"2018-11-27 14:11:18","commitOrder":7,"curCode":"  private static DimFilter buildTimeFloorFilter(\n      final String column,\n      final Granularity granularity,\n      final SqlKind operatorKind,\n      final long rhsMillis\n  )\n  {\n    final BoundRefKey boundRefKey = new BoundRefKey(column, null, StringComparators.NUMERIC);\n    final Interval rhsInterval = granularity.bucket(DateTimes.utc(rhsMillis));\n\n    \r\n    final boolean rhsAligned = rhsInterval.getStartMillis() == rhsMillis;\n\n    return getBoundTimeDimFilter(operatorKind, boundRefKey, rhsInterval, rhsAligned);\n  }\n","date":"2018-11-27 14:11:18","endLine":582,"groupId":"102083","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"buildTimeFloorFilter","params":"(finalStringcolumn@finalGranularitygranularity@finalSqlKindoperatorKind@finallongrhsMillis)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/fd/2c1d86557722bac3f4c6d6da68588189f4cdb9.src","preCode":"  private static DimFilter buildTimeFloorFilter(\n      final String column,\n      final Granularity granularity,\n      final SqlKind operatorKind,\n      final long rhsMillis\n  )\n  {\n    final BoundRefKey boundRefKey = new BoundRefKey(column, null, StringComparators.NUMERIC);\n    final Interval rhsInterval = granularity.bucket(DateTimes.utc(rhsMillis));\n\n    \r\n    final boolean rhsAligned = rhsInterval.getStartMillis() == rhsMillis;\n\n    return getBoundTimeDimFilter(operatorKind, boundRefKey, rhsInterval, rhsAligned);\n  }\n","realPath":"sql/src/main/java/org/apache/druid/sql/calcite/expression/Expressions.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":568,"status":"N"}],"commitId":"8ab19793043c65bd79315de6fb26683f561a8a58","commitMessage":"@@@Remove implied profanity from error messages. (#10270)\n\ni.e. WTF.  WTH.","date":"2020-08-29 02:38:50","modifiedFileCount":"76","status":"M","submitter":"Gian Merlino"}]
