[{"authorTime":"2018-08-31 00:56:26","codes":[{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  public void testConcurrentWrites() throws ExecutionException, InterruptedException\n  {\n    final ListeningExecutorService executorService = MoreExecutors.listeningDecorator(\n        Executors.newFixedThreadPool(\n            concurrentThreads,\n            new ThreadFactoryBuilder()\n                .setDaemon(false)\n                .setNameFormat(\"indexible-writes-benchmark-%d\")\n                .build()\n        )\n    );\n    final AtomicInteger index = new AtomicInteger(0);\n    List<ListenableFuture<?>> futures = new LinkedList<>();\n\n    final Integer loops = totalIndexSize / concurrentThreads;\n\n    for (int i = 0; i < concurrentThreads; ++i) {\n      futures.add(\n          executorService.submit(\n              new Runnable()\n              {\n                @Override\n                public void run()\n                {\n                  for (int i = 0; i < loops; ++i) {\n                    final Integer idx = index.getAndIncrement();\n                    concurrentIndexible.set(idx, idx);\n                  }\n                }\n              }\n          )\n      );\n    }\n    Futures.allAsList(futures).get();\n    Assert.assertTrue(StringUtils.format(\"Index too small %d, expected %d across %d loops\", index.get(), totalIndexSize, loops), index.get() >= totalIndexSize);\n    for (int i = 0; i < index.get(); ++i) {\n      Assert.assertEquals(i, concurrentIndexible.get(i).intValue());\n    }\n    concurrentIndexible.clear();\n    futures.clear();\n    executorService.shutdown();\n  }\n","date":"2018-08-31 00:56:26","endLine":228,"groupId":"8792","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testConcurrentWrites","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/50/c0c1089320ff1bac9588aa67a8174c6db9b447.src","preCode":"  public void testConcurrentWrites() throws ExecutionException, InterruptedException\n  {\n    final ListeningExecutorService executorService = MoreExecutors.listeningDecorator(\n        Executors.newFixedThreadPool(\n            concurrentThreads,\n            new ThreadFactoryBuilder()\n                .setDaemon(false)\n                .setNameFormat(\"indexible-writes-benchmark-%d\")\n                .build()\n        )\n    );\n    final AtomicInteger index = new AtomicInteger(0);\n    List<ListenableFuture<?>> futures = new LinkedList<>();\n\n    final Integer loops = totalIndexSize / concurrentThreads;\n\n    for (int i = 0; i < concurrentThreads; ++i) {\n      futures.add(\n          executorService.submit(\n              new Runnable()\n              {\n                @Override\n                public void run()\n                {\n                  for (int i = 0; i < loops; ++i) {\n                    final Integer idx = index.getAndIncrement();\n                    concurrentIndexible.set(idx, idx);\n                  }\n                }\n              }\n          )\n      );\n    }\n    Futures.allAsList(futures).get();\n    Assert.assertTrue(StringUtils.format(\"Index too small %d, expected %d across %d loops\", index.get(), totalIndexSize, loops), index.get() >= totalIndexSize);\n    for (int i = 0; i < index.get(); ++i) {\n      Assert.assertEquals(i, concurrentIndexible.get(i).intValue());\n    }\n    concurrentIndexible.clear();\n    futures.clear();\n    executorService.shutdown();\n  }\n","realPath":"processing/src/test/java/org/apache/druid/segment/data/BenchmarkIndexibleWrites.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":187,"status":"B"},{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  public void testConcurrentReads() throws ExecutionException, InterruptedException\n  {\n    final ListeningExecutorService executorService = MoreExecutors.listeningDecorator(\n        Executors.newFixedThreadPool(\n            concurrentThreads,\n            new ThreadFactoryBuilder()\n                .setDaemon(false)\n                .setNameFormat(\"indexible-writes-benchmark-reader-%d\")\n                .build()\n        )\n    );\n    final AtomicInteger index = new AtomicInteger(0);\n    final AtomicInteger queryableIndex = new AtomicInteger(0);\n    List<ListenableFuture<?>> futures = new LinkedList<>();\n\n    final Integer loops = totalIndexSize / concurrentThreads;\n\n    final AtomicBoolean done = new AtomicBoolean(false);\n\n    final CountDownLatch start = new CountDownLatch(1);\n\n    for (int i = 0; i < concurrentThreads; ++i) {\n      futures.add(\n          executorService.submit(\n              new Runnable()\n              {\n                @Override\n                public void run()\n                {\n                  try {\n                    start.await();\n                  }\n                  catch (InterruptedException e) {\n                    throw Throwables.propagate(e);\n                  }\n                  final Random rndGen = new Random();\n                  while (!done.get()) {\n                    Integer idx = rndGen.nextInt(queryableIndex.get() + 1);\n                    Assert.assertEquals(idx, concurrentIndexible.get(idx));\n                  }\n                }\n              }\n          )\n      );\n    }\n\n    {\n      final Integer idx = index.getAndIncrement();\n      concurrentIndexible.set(idx, idx);\n      start.countDown();\n    }\n    for (int i = 1; i < totalIndexSize; ++i) {\n      final Integer idx = index.getAndIncrement();\n      concurrentIndexible.set(idx, idx);\n      queryableIndex.incrementAndGet();\n    }\n    done.set(true);\n\n    Futures.allAsList(futures).get();\n    executorService.shutdown();\n\n    Assert.assertTrue(StringUtils.format(\"Index too small %d, expected %d across %d loops\", index.get(), totalIndexSize, loops), index.get() >= totalIndexSize);\n    for (int i = 0; i < index.get(); ++i) {\n      Assert.assertEquals(i, concurrentIndexible.get(i).intValue());\n    }\n    concurrentIndexible.clear();\n    futures.clear();\n  }\n","date":"2018-08-31 00:56:26","endLine":306,"groupId":"14503","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testConcurrentReads","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/50/c0c1089320ff1bac9588aa67a8174c6db9b447.src","preCode":"  public void testConcurrentReads() throws ExecutionException, InterruptedException\n  {\n    final ListeningExecutorService executorService = MoreExecutors.listeningDecorator(\n        Executors.newFixedThreadPool(\n            concurrentThreads,\n            new ThreadFactoryBuilder()\n                .setDaemon(false)\n                .setNameFormat(\"indexible-writes-benchmark-reader-%d\")\n                .build()\n        )\n    );\n    final AtomicInteger index = new AtomicInteger(0);\n    final AtomicInteger queryableIndex = new AtomicInteger(0);\n    List<ListenableFuture<?>> futures = new LinkedList<>();\n\n    final Integer loops = totalIndexSize / concurrentThreads;\n\n    final AtomicBoolean done = new AtomicBoolean(false);\n\n    final CountDownLatch start = new CountDownLatch(1);\n\n    for (int i = 0; i < concurrentThreads; ++i) {\n      futures.add(\n          executorService.submit(\n              new Runnable()\n              {\n                @Override\n                public void run()\n                {\n                  try {\n                    start.await();\n                  }\n                  catch (InterruptedException e) {\n                    throw Throwables.propagate(e);\n                  }\n                  final Random rndGen = new Random();\n                  while (!done.get()) {\n                    Integer idx = rndGen.nextInt(queryableIndex.get() + 1);\n                    Assert.assertEquals(idx, concurrentIndexible.get(idx));\n                  }\n                }\n              }\n          )\n      );\n    }\n\n    {\n      final Integer idx = index.getAndIncrement();\n      concurrentIndexible.set(idx, idx);\n      start.countDown();\n    }\n    for (int i = 1; i < totalIndexSize; ++i) {\n      final Integer idx = index.getAndIncrement();\n      concurrentIndexible.set(idx, idx);\n      queryableIndex.incrementAndGet();\n    }\n    done.set(true);\n\n    Futures.allAsList(futures).get();\n    executorService.shutdown();\n\n    Assert.assertTrue(StringUtils.format(\"Index too small %d, expected %d across %d loops\", index.get(), totalIndexSize, loops), index.get() >= totalIndexSize);\n    for (int i = 0; i < index.get(); ++i) {\n      Assert.assertEquals(i, concurrentIndexible.get(i).intValue());\n    }\n    concurrentIndexible.clear();\n    futures.clear();\n  }\n","realPath":"processing/src/test/java/org/apache/druid/segment/data/BenchmarkIndexibleWrites.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":239,"status":"B"}],"commitId":"431d3d8497f9079857c3baa7ae7ab4cb44a22355","commitMessage":"@@@Rename io.druid to org.apache.druid. (#6266)\n\n* Rename io.druid to org.apache.druid.\n\n* Fix META-INF files and remove some benchmark results.\n\n* MonitorsConfig update for metrics package migration.\n\n* Reorder some dimensions in inner queries for some reason.\n\n* Fix protobuf tests.\n","date":"2018-08-31 00:56:26","modifiedFileCount":"5","status":"B","submitter":"Gian Merlino"},{"authorTime":"2018-09-14 09:07:06","codes":[{"authorDate":"2018-09-14 09:07:06","commitOrder":2,"curCode":"  public void testConcurrentWrites() throws ExecutionException, InterruptedException\n  {\n    final ListeningExecutorService executorService = MoreExecutors.listeningDecorator(\n        Executors.newFixedThreadPool(\n            concurrentThreads,\n            new ThreadFactoryBuilder()\n                .setDaemon(false)\n                .setNameFormat(\"indexible-writes-benchmark-%d\")\n                .build()\n        )\n    );\n    final AtomicInteger index = new AtomicInteger(0);\n    List<ListenableFuture<?>> futures = new ArrayList<>();\n\n    final Integer loops = totalIndexSize / concurrentThreads;\n\n    for (int i = 0; i < concurrentThreads; ++i) {\n      futures.add(\n          executorService.submit(\n              new Runnable()\n              {\n                @Override\n                public void run()\n                {\n                  for (int i = 0; i < loops; ++i) {\n                    final Integer idx = index.getAndIncrement();\n                    concurrentIndexible.set(idx, idx);\n                  }\n                }\n              }\n          )\n      );\n    }\n    Futures.allAsList(futures).get();\n    Assert.assertTrue(StringUtils.format(\"Index too small %d, expected %d across %d loops\", index.get(), totalIndexSize, loops), index.get() >= totalIndexSize);\n    for (int i = 0; i < index.get(); ++i) {\n      Assert.assertEquals(i, concurrentIndexible.get(i).intValue());\n    }\n    concurrentIndexible.clear();\n    futures.clear();\n    executorService.shutdown();\n  }\n","date":"2018-09-14 09:07:06","endLine":228,"groupId":"8792","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testConcurrentWrites","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/1c/5d866a2adba9a9567ff6761c025b68de0dabeb.src","preCode":"  public void testConcurrentWrites() throws ExecutionException, InterruptedException\n  {\n    final ListeningExecutorService executorService = MoreExecutors.listeningDecorator(\n        Executors.newFixedThreadPool(\n            concurrentThreads,\n            new ThreadFactoryBuilder()\n                .setDaemon(false)\n                .setNameFormat(\"indexible-writes-benchmark-%d\")\n                .build()\n        )\n    );\n    final AtomicInteger index = new AtomicInteger(0);\n    List<ListenableFuture<?>> futures = new LinkedList<>();\n\n    final Integer loops = totalIndexSize / concurrentThreads;\n\n    for (int i = 0; i < concurrentThreads; ++i) {\n      futures.add(\n          executorService.submit(\n              new Runnable()\n              {\n                @Override\n                public void run()\n                {\n                  for (int i = 0; i < loops; ++i) {\n                    final Integer idx = index.getAndIncrement();\n                    concurrentIndexible.set(idx, idx);\n                  }\n                }\n              }\n          )\n      );\n    }\n    Futures.allAsList(futures).get();\n    Assert.assertTrue(StringUtils.format(\"Index too small %d, expected %d across %d loops\", index.get(), totalIndexSize, loops), index.get() >= totalIndexSize);\n    for (int i = 0; i < index.get(); ++i) {\n      Assert.assertEquals(i, concurrentIndexible.get(i).intValue());\n    }\n    concurrentIndexible.clear();\n    futures.clear();\n    executorService.shutdown();\n  }\n","realPath":"processing/src/test/java/org/apache/druid/segment/data/BenchmarkIndexibleWrites.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":187,"status":"M"},{"authorDate":"2018-09-14 09:07:06","commitOrder":2,"curCode":"  public void testConcurrentReads() throws ExecutionException, InterruptedException\n  {\n    final ListeningExecutorService executorService = MoreExecutors.listeningDecorator(\n        Executors.newFixedThreadPool(\n            concurrentThreads,\n            new ThreadFactoryBuilder()\n                .setDaemon(false)\n                .setNameFormat(\"indexible-writes-benchmark-reader-%d\")\n                .build()\n        )\n    );\n    final AtomicInteger index = new AtomicInteger(0);\n    final AtomicInteger queryableIndex = new AtomicInteger(0);\n    List<ListenableFuture<?>> futures = new ArrayList<>();\n\n    final Integer loops = totalIndexSize / concurrentThreads;\n\n    final AtomicBoolean done = new AtomicBoolean(false);\n\n    final CountDownLatch start = new CountDownLatch(1);\n\n    for (int i = 0; i < concurrentThreads; ++i) {\n      futures.add(\n          executorService.submit(\n              new Runnable()\n              {\n                @Override\n                public void run()\n                {\n                  try {\n                    start.await();\n                  }\n                  catch (InterruptedException e) {\n                    throw Throwables.propagate(e);\n                  }\n                  final Random rndGen = new Random();\n                  while (!done.get()) {\n                    Integer idx = rndGen.nextInt(queryableIndex.get() + 1);\n                    Assert.assertEquals(idx, concurrentIndexible.get(idx));\n                  }\n                }\n              }\n          )\n      );\n    }\n\n    {\n      final Integer idx = index.getAndIncrement();\n      concurrentIndexible.set(idx, idx);\n      start.countDown();\n    }\n    for (int i = 1; i < totalIndexSize; ++i) {\n      final Integer idx = index.getAndIncrement();\n      concurrentIndexible.set(idx, idx);\n      queryableIndex.incrementAndGet();\n    }\n    done.set(true);\n\n    Futures.allAsList(futures).get();\n    executorService.shutdown();\n\n    Assert.assertTrue(StringUtils.format(\"Index too small %d, expected %d across %d loops\", index.get(), totalIndexSize, loops), index.get() >= totalIndexSize);\n    for (int i = 0; i < index.get(); ++i) {\n      Assert.assertEquals(i, concurrentIndexible.get(i).intValue());\n    }\n    concurrentIndexible.clear();\n    futures.clear();\n  }\n","date":"2018-09-14 09:07:06","endLine":306,"groupId":"14503","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testConcurrentReads","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/1c/5d866a2adba9a9567ff6761c025b68de0dabeb.src","preCode":"  public void testConcurrentReads() throws ExecutionException, InterruptedException\n  {\n    final ListeningExecutorService executorService = MoreExecutors.listeningDecorator(\n        Executors.newFixedThreadPool(\n            concurrentThreads,\n            new ThreadFactoryBuilder()\n                .setDaemon(false)\n                .setNameFormat(\"indexible-writes-benchmark-reader-%d\")\n                .build()\n        )\n    );\n    final AtomicInteger index = new AtomicInteger(0);\n    final AtomicInteger queryableIndex = new AtomicInteger(0);\n    List<ListenableFuture<?>> futures = new LinkedList<>();\n\n    final Integer loops = totalIndexSize / concurrentThreads;\n\n    final AtomicBoolean done = new AtomicBoolean(false);\n\n    final CountDownLatch start = new CountDownLatch(1);\n\n    for (int i = 0; i < concurrentThreads; ++i) {\n      futures.add(\n          executorService.submit(\n              new Runnable()\n              {\n                @Override\n                public void run()\n                {\n                  try {\n                    start.await();\n                  }\n                  catch (InterruptedException e) {\n                    throw Throwables.propagate(e);\n                  }\n                  final Random rndGen = new Random();\n                  while (!done.get()) {\n                    Integer idx = rndGen.nextInt(queryableIndex.get() + 1);\n                    Assert.assertEquals(idx, concurrentIndexible.get(idx));\n                  }\n                }\n              }\n          )\n      );\n    }\n\n    {\n      final Integer idx = index.getAndIncrement();\n      concurrentIndexible.set(idx, idx);\n      start.countDown();\n    }\n    for (int i = 1; i < totalIndexSize; ++i) {\n      final Integer idx = index.getAndIncrement();\n      concurrentIndexible.set(idx, idx);\n      queryableIndex.incrementAndGet();\n    }\n    done.set(true);\n\n    Futures.allAsList(futures).get();\n    executorService.shutdown();\n\n    Assert.assertTrue(StringUtils.format(\"Index too small %d, expected %d across %d loops\", index.get(), totalIndexSize, loops), index.get() >= totalIndexSize);\n    for (int i = 0; i < index.get(); ++i) {\n      Assert.assertEquals(i, concurrentIndexible.get(i).intValue());\n    }\n    concurrentIndexible.clear();\n    futures.clear();\n  }\n","realPath":"processing/src/test/java/org/apache/druid/segment/data/BenchmarkIndexibleWrites.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":239,"status":"M"}],"commitId":"d50b69e6d4c29913de4d670b05523a719dbfd97f","commitMessage":"@@@Prohibit LinkedList (#6112)\n\n* Prohibit LinkedList\n\n* Fix tests\n\n* Fix\n\n* Remove unused import\n","date":"2018-09-14 09:07:06","modifiedFileCount":"24","status":"M","submitter":"Roman Leventov"},{"authorTime":"2018-09-15 04:35:51","codes":[{"authorDate":"2018-09-14 09:07:06","commitOrder":3,"curCode":"  public void testConcurrentWrites() throws ExecutionException, InterruptedException\n  {\n    final ListeningExecutorService executorService = MoreExecutors.listeningDecorator(\n        Executors.newFixedThreadPool(\n            concurrentThreads,\n            new ThreadFactoryBuilder()\n                .setDaemon(false)\n                .setNameFormat(\"indexible-writes-benchmark-%d\")\n                .build()\n        )\n    );\n    final AtomicInteger index = new AtomicInteger(0);\n    List<ListenableFuture<?>> futures = new ArrayList<>();\n\n    final Integer loops = totalIndexSize / concurrentThreads;\n\n    for (int i = 0; i < concurrentThreads; ++i) {\n      futures.add(\n          executorService.submit(\n              new Runnable()\n              {\n                @Override\n                public void run()\n                {\n                  for (int i = 0; i < loops; ++i) {\n                    final Integer idx = index.getAndIncrement();\n                    concurrentIndexible.set(idx, idx);\n                  }\n                }\n              }\n          )\n      );\n    }\n    Futures.allAsList(futures).get();\n    Assert.assertTrue(StringUtils.format(\"Index too small %d, expected %d across %d loops\", index.get(), totalIndexSize, loops), index.get() >= totalIndexSize);\n    for (int i = 0; i < index.get(); ++i) {\n      Assert.assertEquals(i, concurrentIndexible.get(i).intValue());\n    }\n    concurrentIndexible.clear();\n    futures.clear();\n    executorService.shutdown();\n  }\n","date":"2018-09-14 09:07:06","endLine":228,"groupId":"8792","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testConcurrentWrites","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/1c/5d866a2adba9a9567ff6761c025b68de0dabeb.src","preCode":"  public void testConcurrentWrites() throws ExecutionException, InterruptedException\n  {\n    final ListeningExecutorService executorService = MoreExecutors.listeningDecorator(\n        Executors.newFixedThreadPool(\n            concurrentThreads,\n            new ThreadFactoryBuilder()\n                .setDaemon(false)\n                .setNameFormat(\"indexible-writes-benchmark-%d\")\n                .build()\n        )\n    );\n    final AtomicInteger index = new AtomicInteger(0);\n    List<ListenableFuture<?>> futures = new ArrayList<>();\n\n    final Integer loops = totalIndexSize / concurrentThreads;\n\n    for (int i = 0; i < concurrentThreads; ++i) {\n      futures.add(\n          executorService.submit(\n              new Runnable()\n              {\n                @Override\n                public void run()\n                {\n                  for (int i = 0; i < loops; ++i) {\n                    final Integer idx = index.getAndIncrement();\n                    concurrentIndexible.set(idx, idx);\n                  }\n                }\n              }\n          )\n      );\n    }\n    Futures.allAsList(futures).get();\n    Assert.assertTrue(StringUtils.format(\"Index too small %d, expected %d across %d loops\", index.get(), totalIndexSize, loops), index.get() >= totalIndexSize);\n    for (int i = 0; i < index.get(); ++i) {\n      Assert.assertEquals(i, concurrentIndexible.get(i).intValue());\n    }\n    concurrentIndexible.clear();\n    futures.clear();\n    executorService.shutdown();\n  }\n","realPath":"processing/src/test/java/org/apache/druid/segment/data/BenchmarkIndexibleWrites.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":187,"status":"N"},{"authorDate":"2018-09-15 04:35:51","commitOrder":3,"curCode":"  public void testConcurrentReads() throws ExecutionException, InterruptedException\n  {\n    final ListeningExecutorService executorService = MoreExecutors.listeningDecorator(\n        Executors.newFixedThreadPool(\n            concurrentThreads,\n            new ThreadFactoryBuilder()\n                .setDaemon(false)\n                .setNameFormat(\"indexible-writes-benchmark-reader-%d\")\n                .build()\n        )\n    );\n    final AtomicInteger index = new AtomicInteger(0);\n    final AtomicInteger queryableIndex = new AtomicInteger(0);\n    List<ListenableFuture<?>> futures = new ArrayList<>();\n\n    final Integer loops = totalIndexSize / concurrentThreads;\n\n    final AtomicBoolean done = new AtomicBoolean(false);\n\n    final CountDownLatch start = new CountDownLatch(1);\n\n    for (int i = 0; i < concurrentThreads; ++i) {\n      futures.add(\n          executorService.submit(\n              new Runnable()\n              {\n                @Override\n                public void run()\n                {\n                  try {\n                    start.await();\n                  }\n                  catch (InterruptedException e) {\n                    throw Throwables.propagate(e);\n                  }\n                  final Random rndGen = ThreadLocalRandom.current();\n                  while (!done.get()) {\n                    Integer idx = rndGen.nextInt(queryableIndex.get() + 1);\n                    Assert.assertEquals(idx, concurrentIndexible.get(idx));\n                  }\n                }\n              }\n          )\n      );\n    }\n\n    {\n      final Integer idx = index.getAndIncrement();\n      concurrentIndexible.set(idx, idx);\n      start.countDown();\n    }\n    for (int i = 1; i < totalIndexSize; ++i) {\n      final Integer idx = index.getAndIncrement();\n      concurrentIndexible.set(idx, idx);\n      queryableIndex.incrementAndGet();\n    }\n    done.set(true);\n\n    Futures.allAsList(futures).get();\n    executorService.shutdown();\n\n    Assert.assertTrue(StringUtils.format(\"Index too small %d, expected %d across %d loops\", index.get(), totalIndexSize, loops), index.get() >= totalIndexSize);\n    for (int i = 0; i < index.get(); ++i) {\n      Assert.assertEquals(i, concurrentIndexible.get(i).intValue());\n    }\n    concurrentIndexible.clear();\n    futures.clear();\n  }\n","date":"2018-09-15 04:35:51","endLine":307,"groupId":"0","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testConcurrentReads","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/df/81b8e3032ab19d8a9b3025ff63a909bd8c1a7a.src","preCode":"  public void testConcurrentReads() throws ExecutionException, InterruptedException\n  {\n    final ListeningExecutorService executorService = MoreExecutors.listeningDecorator(\n        Executors.newFixedThreadPool(\n            concurrentThreads,\n            new ThreadFactoryBuilder()\n                .setDaemon(false)\n                .setNameFormat(\"indexible-writes-benchmark-reader-%d\")\n                .build()\n        )\n    );\n    final AtomicInteger index = new AtomicInteger(0);\n    final AtomicInteger queryableIndex = new AtomicInteger(0);\n    List<ListenableFuture<?>> futures = new ArrayList<>();\n\n    final Integer loops = totalIndexSize / concurrentThreads;\n\n    final AtomicBoolean done = new AtomicBoolean(false);\n\n    final CountDownLatch start = new CountDownLatch(1);\n\n    for (int i = 0; i < concurrentThreads; ++i) {\n      futures.add(\n          executorService.submit(\n              new Runnable()\n              {\n                @Override\n                public void run()\n                {\n                  try {\n                    start.await();\n                  }\n                  catch (InterruptedException e) {\n                    throw Throwables.propagate(e);\n                  }\n                  final Random rndGen = new Random();\n                  while (!done.get()) {\n                    Integer idx = rndGen.nextInt(queryableIndex.get() + 1);\n                    Assert.assertEquals(idx, concurrentIndexible.get(idx));\n                  }\n                }\n              }\n          )\n      );\n    }\n\n    {\n      final Integer idx = index.getAndIncrement();\n      concurrentIndexible.set(idx, idx);\n      start.countDown();\n    }\n    for (int i = 1; i < totalIndexSize; ++i) {\n      final Integer idx = index.getAndIncrement();\n      concurrentIndexible.set(idx, idx);\n      queryableIndex.incrementAndGet();\n    }\n    done.set(true);\n\n    Futures.allAsList(futures).get();\n    executorService.shutdown();\n\n    Assert.assertTrue(StringUtils.format(\"Index too small %d, expected %d across %d loops\", index.get(), totalIndexSize, loops), index.get() >= totalIndexSize);\n    for (int i = 0; i < index.get(); ++i) {\n      Assert.assertEquals(i, concurrentIndexible.get(i).intValue());\n    }\n    concurrentIndexible.clear();\n    futures.clear();\n  }\n","realPath":"processing/src/test/java/org/apache/druid/segment/data/BenchmarkIndexibleWrites.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":240,"status":"M"}],"commitId":"0c4bd2b57b19bcbd9a275fad412960aa0a39ca5f","commitMessage":"@@@Prohibit some Random usage patterns (#6226)\n\n* Prohibit Random usage patterns\n\n* Fix FlattenJSONBenchmarkUtil\n","date":"2018-09-15 04:35:51","modifiedFileCount":"44","status":"M","submitter":"Roman Leventov"},{"authorTime":"2019-03-15 05:28:33","codes":[{"authorDate":"2018-09-14 09:07:06","commitOrder":4,"curCode":"  public void testConcurrentWrites() throws ExecutionException, InterruptedException\n  {\n    final ListeningExecutorService executorService = MoreExecutors.listeningDecorator(\n        Executors.newFixedThreadPool(\n            concurrentThreads,\n            new ThreadFactoryBuilder()\n                .setDaemon(false)\n                .setNameFormat(\"indexible-writes-benchmark-%d\")\n                .build()\n        )\n    );\n    final AtomicInteger index = new AtomicInteger(0);\n    List<ListenableFuture<?>> futures = new ArrayList<>();\n\n    final Integer loops = totalIndexSize / concurrentThreads;\n\n    for (int i = 0; i < concurrentThreads; ++i) {\n      futures.add(\n          executorService.submit(\n              new Runnable()\n              {\n                @Override\n                public void run()\n                {\n                  for (int i = 0; i < loops; ++i) {\n                    final Integer idx = index.getAndIncrement();\n                    concurrentIndexible.set(idx, idx);\n                  }\n                }\n              }\n          )\n      );\n    }\n    Futures.allAsList(futures).get();\n    Assert.assertTrue(StringUtils.format(\"Index too small %d, expected %d across %d loops\", index.get(), totalIndexSize, loops), index.get() >= totalIndexSize);\n    for (int i = 0; i < index.get(); ++i) {\n      Assert.assertEquals(i, concurrentIndexible.get(i).intValue());\n    }\n    concurrentIndexible.clear();\n    futures.clear();\n    executorService.shutdown();\n  }\n","date":"2018-09-14 09:07:06","endLine":228,"groupId":"105644","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testConcurrentWrites","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/1c/5d866a2adba9a9567ff6761c025b68de0dabeb.src","preCode":"  public void testConcurrentWrites() throws ExecutionException, InterruptedException\n  {\n    final ListeningExecutorService executorService = MoreExecutors.listeningDecorator(\n        Executors.newFixedThreadPool(\n            concurrentThreads,\n            new ThreadFactoryBuilder()\n                .setDaemon(false)\n                .setNameFormat(\"indexible-writes-benchmark-%d\")\n                .build()\n        )\n    );\n    final AtomicInteger index = new AtomicInteger(0);\n    List<ListenableFuture<?>> futures = new ArrayList<>();\n\n    final Integer loops = totalIndexSize / concurrentThreads;\n\n    for (int i = 0; i < concurrentThreads; ++i) {\n      futures.add(\n          executorService.submit(\n              new Runnable()\n              {\n                @Override\n                public void run()\n                {\n                  for (int i = 0; i < loops; ++i) {\n                    final Integer idx = index.getAndIncrement();\n                    concurrentIndexible.set(idx, idx);\n                  }\n                }\n              }\n          )\n      );\n    }\n    Futures.allAsList(futures).get();\n    Assert.assertTrue(StringUtils.format(\"Index too small %d, expected %d across %d loops\", index.get(), totalIndexSize, loops), index.get() >= totalIndexSize);\n    for (int i = 0; i < index.get(); ++i) {\n      Assert.assertEquals(i, concurrentIndexible.get(i).intValue());\n    }\n    concurrentIndexible.clear();\n    futures.clear();\n    executorService.shutdown();\n  }\n","realPath":"processing/src/test/java/org/apache/druid/segment/data/BenchmarkIndexibleWrites.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":187,"status":"N"},{"authorDate":"2019-03-15 05:28:33","commitOrder":4,"curCode":"  public void testConcurrentReads() throws ExecutionException, InterruptedException\n  {\n    final ListeningExecutorService executorService = MoreExecutors.listeningDecorator(\n        Executors.newFixedThreadPool(\n            concurrentThreads,\n            new ThreadFactoryBuilder()\n                .setDaemon(false)\n                .setNameFormat(\"indexible-writes-benchmark-reader-%d\")\n                .build()\n        )\n    );\n    final AtomicInteger index = new AtomicInteger(0);\n    final AtomicInteger queryableIndex = new AtomicInteger(0);\n    List<ListenableFuture<?>> futures = new ArrayList<>();\n\n    final Integer loops = totalIndexSize / concurrentThreads;\n\n    final AtomicBoolean done = new AtomicBoolean(false);\n\n    final CountDownLatch start = new CountDownLatch(1);\n\n    for (int i = 0; i < concurrentThreads; ++i) {\n      futures.add(\n          executorService.submit(\n              new Runnable()\n              {\n                @Override\n                public void run()\n                {\n                  try {\n                    start.await();\n                  }\n                  catch (InterruptedException e) {\n                    throw new RuntimeException(e);\n                  }\n                  final Random rndGen = ThreadLocalRandom.current();\n                  while (!done.get()) {\n                    Integer idx = rndGen.nextInt(queryableIndex.get() + 1);\n                    Assert.assertEquals(idx, concurrentIndexible.get(idx));\n                  }\n                }\n              }\n          )\n      );\n    }\n\n    {\n      final Integer idx = index.getAndIncrement();\n      concurrentIndexible.set(idx, idx);\n      start.countDown();\n    }\n    for (int i = 1; i < totalIndexSize; ++i) {\n      final Integer idx = index.getAndIncrement();\n      concurrentIndexible.set(idx, idx);\n      queryableIndex.incrementAndGet();\n    }\n    done.set(true);\n\n    Futures.allAsList(futures).get();\n    executorService.shutdown();\n\n    Assert.assertTrue(StringUtils.format(\"Index too small %d, expected %d across %d loops\", index.get(), totalIndexSize, loops), index.get() >= totalIndexSize);\n    for (int i = 0; i < index.get(); ++i) {\n      Assert.assertEquals(i, concurrentIndexible.get(i).intValue());\n    }\n    concurrentIndexible.clear();\n    futures.clear();\n  }\n","date":"2019-03-15 05:28:33","endLine":306,"groupId":"105644","id":8,"instanceNumber":2,"isCurCommit":1,"methodName":"testConcurrentReads","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/9b/79ff1ff17f514d7deb2774deada54486e35b82.src","preCode":"  public void testConcurrentReads() throws ExecutionException, InterruptedException\n  {\n    final ListeningExecutorService executorService = MoreExecutors.listeningDecorator(\n        Executors.newFixedThreadPool(\n            concurrentThreads,\n            new ThreadFactoryBuilder()\n                .setDaemon(false)\n                .setNameFormat(\"indexible-writes-benchmark-reader-%d\")\n                .build()\n        )\n    );\n    final AtomicInteger index = new AtomicInteger(0);\n    final AtomicInteger queryableIndex = new AtomicInteger(0);\n    List<ListenableFuture<?>> futures = new ArrayList<>();\n\n    final Integer loops = totalIndexSize / concurrentThreads;\n\n    final AtomicBoolean done = new AtomicBoolean(false);\n\n    final CountDownLatch start = new CountDownLatch(1);\n\n    for (int i = 0; i < concurrentThreads; ++i) {\n      futures.add(\n          executorService.submit(\n              new Runnable()\n              {\n                @Override\n                public void run()\n                {\n                  try {\n                    start.await();\n                  }\n                  catch (InterruptedException e) {\n                    throw Throwables.propagate(e);\n                  }\n                  final Random rndGen = ThreadLocalRandom.current();\n                  while (!done.get()) {\n                    Integer idx = rndGen.nextInt(queryableIndex.get() + 1);\n                    Assert.assertEquals(idx, concurrentIndexible.get(idx));\n                  }\n                }\n              }\n          )\n      );\n    }\n\n    {\n      final Integer idx = index.getAndIncrement();\n      concurrentIndexible.set(idx, idx);\n      start.countDown();\n    }\n    for (int i = 1; i < totalIndexSize; ++i) {\n      final Integer idx = index.getAndIncrement();\n      concurrentIndexible.set(idx, idx);\n      queryableIndex.incrementAndGet();\n    }\n    done.set(true);\n\n    Futures.allAsList(futures).get();\n    executorService.shutdown();\n\n    Assert.assertTrue(StringUtils.format(\"Index too small %d, expected %d across %d loops\", index.get(), totalIndexSize, loops), index.get() >= totalIndexSize);\n    for (int i = 0; i < index.get(); ++i) {\n      Assert.assertEquals(i, concurrentIndexible.get(i).intValue());\n    }\n    concurrentIndexible.clear();\n    futures.clear();\n  }\n","realPath":"processing/src/test/java/org/apache/druid/segment/data/BenchmarkIndexibleWrites.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":239,"status":"M"}],"commitId":"7ada1c49f9735a37808f3ed7656d93ae88b8b925","commitMessage":"@@@Prohibit Throwables.propagate() (#7121)\n\n* Throw caught exception.\n\n* Throw caught exceptions.\n\n* Related checkstyle rule is added to prevent further bugs.\n\n* RuntimeException() is used instead of Throwables.propagate().\n\n* Missing import is added.\n\n* Throwables are propogated if possible.\n\n* Throwables are propogated if possible.\n\n* Throwables are propogated if possible.\n\n* Throwables are propogated if possible.\n\n* * Checkstyle definition is improved.\n* Throwables.propagate() usages are removed.\n\n* Checkstyle pattern is changed for only scanning \"Throwables.propagate(\" instead of checking lookbehind.\n\n* Throwable is kept before firing a Runtime Exception.\n\n* Fix unused assignments.\n","date":"2019-03-15 05:28:33","modifiedFileCount":"228","status":"M","submitter":"Furkan KAMACI"}]
