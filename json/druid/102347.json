[{"authorTime":"2018-12-22 03:49:24","codes":[{"authorDate":"2018-12-22 03:49:24","commitOrder":1,"curCode":"  public void testIncrementalHandOff() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = 2;\n    maxRecordsPerPoll = 1;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(0, 5))\n                                          .once()\n                                          .andReturn(records.subList(4, records.size()))\n                                          .once();\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    final SeekableStreamPartitions<String, String> startPartitions = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"0\",\n            shardId0,\n            \"0\"\n        )\n    );\n\n    final SeekableStreamPartitions<String, String> checkpoint1 = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"4\",\n            shardId0,\n            \"0\"\n        )\n    );\n\n    final SeekableStreamPartitions<String, String> endPartitions = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"9\",\n            shardId0,\n            \"1\"\n        )\n    );\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            null,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n    Assert.assertTrue(checkpoint1.getPartitionSequenceNumberMap().equals(currentOffsets));\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(1, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, currentOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(8, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = SD(task, \"2008/P1D\", 0);\n    SegmentDescriptor desc2 = SD(task, \"2009/P1D\", 0);\n    SegmentDescriptor desc3 = SD(task, \"2010/P1D\", 0);\n    SegmentDescriptor desc4 = SD(task, \"2011/P1D\", 0);\n    SegmentDescriptor desc5 = SD(task, \"2011/P1D\", 1);\n    SegmentDescriptor desc6 = SD(task, \"2012/P1D\", 0);\n    SegmentDescriptor desc7 = SD(task, \"2013/P1D\", 0);\n    Assert.assertEquals(ImmutableSet.of(desc1, desc2, desc3, desc4, desc5, desc6, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, ImmutableMap.of(\n            shardId1,\n            \"9\",\n            shardId0,\n            \"1\"\n        ))),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", desc1));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", desc2));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", desc3));\n    Assert.assertTrue((ImmutableList.of(\"d\", \"e\").equals(readSegmentColumn(\"dim1\", desc4))\n                       && ImmutableList.of(\"h\").equals(readSegmentColumn(\"dim1\", desc5))) ||\n                      (ImmutableList.of(\"d\", \"h\").equals(readSegmentColumn(\"dim1\", desc4))\n                       && ImmutableList.of(\"e\").equals(readSegmentColumn(\"dim1\", desc5))));\n    Assert.assertEquals(ImmutableList.of(\"g\"), readSegmentColumn(\"dim1\", desc6));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc7));\n  }\n","date":"2018-12-22 03:49:24","endLine":642,"groupId":"13112","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testIncrementalHandOff","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/ce/f97955db2e8ceaae814ce65540385404536749.src","preCode":"  public void testIncrementalHandOff() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = 2;\n    maxRecordsPerPoll = 1;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(0, 5))\n                                          .once()\n                                          .andReturn(records.subList(4, records.size()))\n                                          .once();\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    final SeekableStreamPartitions<String, String> startPartitions = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"0\",\n            shardId0,\n            \"0\"\n        )\n    );\n\n    final SeekableStreamPartitions<String, String> checkpoint1 = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"4\",\n            shardId0,\n            \"0\"\n        )\n    );\n\n    final SeekableStreamPartitions<String, String> endPartitions = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"9\",\n            shardId0,\n            \"1\"\n        )\n    );\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            null,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n    Assert.assertTrue(checkpoint1.getPartitionSequenceNumberMap().equals(currentOffsets));\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(1, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, currentOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(8, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = SD(task, \"2008/P1D\", 0);\n    SegmentDescriptor desc2 = SD(task, \"2009/P1D\", 0);\n    SegmentDescriptor desc3 = SD(task, \"2010/P1D\", 0);\n    SegmentDescriptor desc4 = SD(task, \"2011/P1D\", 0);\n    SegmentDescriptor desc5 = SD(task, \"2011/P1D\", 1);\n    SegmentDescriptor desc6 = SD(task, \"2012/P1D\", 0);\n    SegmentDescriptor desc7 = SD(task, \"2013/P1D\", 0);\n    Assert.assertEquals(ImmutableSet.of(desc1, desc2, desc3, desc4, desc5, desc6, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, ImmutableMap.of(\n            shardId1,\n            \"9\",\n            shardId0,\n            \"1\"\n        ))),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", desc1));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", desc2));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", desc3));\n    Assert.assertTrue((ImmutableList.of(\"d\", \"e\").equals(readSegmentColumn(\"dim1\", desc4))\n                       && ImmutableList.of(\"h\").equals(readSegmentColumn(\"dim1\", desc5))) ||\n                      (ImmutableList.of(\"d\", \"h\").equals(readSegmentColumn(\"dim1\", desc4))\n                       && ImmutableList.of(\"e\").equals(readSegmentColumn(\"dim1\", desc5))));\n    Assert.assertEquals(ImmutableList.of(\"g\"), readSegmentColumn(\"dim1\", desc6));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc7));\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":511,"status":"B"},{"authorDate":"2018-12-22 03:49:24","commitOrder":1,"curCode":"  public void testIncrementalHandOffMaxTotalRows() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = Integer.MAX_VALUE;\n    maxTotalRows = 3L;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(0, 3))\n                                          .once()\n                                          .andReturn(records.subList(2, 10))\n                                          .once()\n                                          .andReturn(records.subList(9, 11));\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    \r\n    final SeekableStreamPartitions<String, String> startPartitions = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"0\"\n        )\n    );\n    \r\n    \r\n    final SeekableStreamPartitions<String, String> checkpoint1 = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"2\"\n        )\n    );\n    final SeekableStreamPartitions<String, String> checkpoint2 = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"9\"\n        )\n    );\n    final SeekableStreamPartitions<String, String> endPartitions = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"10\"\n        )\n    );\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            null,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    while (task.getRunner().getStatus() != Status.PAUSED) {\n      Thread.sleep(10);\n    }\n\n    final Map<String, String> nextOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint2.getPartitionSequenceNumberMap(), nextOffsets);\n\n    task.getRunner().setEndOffsets(nextOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(2, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, currentOffsets))\n            )\n        )\n    );\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, currentOffsets)),\n                new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, nextOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(6, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = SD(task, \"2008/P1D\", 0);\n    SegmentDescriptor desc2 = SD(task, \"2009/P1D\", 0);\n    SegmentDescriptor desc3 = SD(task, \"2010/P1D\", 0);\n    SegmentDescriptor desc4 = SD(task, \"2011/P1D\", 0);\n    SegmentDescriptor desc5 = SD(task, \"2049/P1D\", 0);\n    SegmentDescriptor desc7 = SD(task, \"2013/P1D\", 0);\n    Assert.assertEquals(ImmutableSet.of(desc1, desc2, desc3, desc4, desc5, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, ImmutableMap.of(\n            shardId1,\n            \"10\"\n        ))),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", desc1));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", desc2));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", desc3));\n    Assert.assertEquals(ImmutableList.of(\"d\", \"e\"), readSegmentColumn(\"dim1\", desc4));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc5));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc7));\n  }\n","date":"2018-12-22 03:49:24","endLine":797,"groupId":"13113","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testIncrementalHandOffMaxTotalRows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/ce/f97955db2e8ceaae814ce65540385404536749.src","preCode":"  public void testIncrementalHandOffMaxTotalRows() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = Integer.MAX_VALUE;\n    maxTotalRows = 3L;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(0, 3))\n                                          .once()\n                                          .andReturn(records.subList(2, 10))\n                                          .once()\n                                          .andReturn(records.subList(9, 11));\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    \r\n    final SeekableStreamPartitions<String, String> startPartitions = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"0\"\n        )\n    );\n    \r\n    \r\n    final SeekableStreamPartitions<String, String> checkpoint1 = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"2\"\n        )\n    );\n    final SeekableStreamPartitions<String, String> checkpoint2 = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"9\"\n        )\n    );\n    final SeekableStreamPartitions<String, String> endPartitions = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"10\"\n        )\n    );\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            null,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    while (task.getRunner().getStatus() != Status.PAUSED) {\n      Thread.sleep(10);\n    }\n\n    final Map<String, String> nextOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint2.getPartitionSequenceNumberMap(), nextOffsets);\n\n    task.getRunner().setEndOffsets(nextOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(2, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, currentOffsets))\n            )\n        )\n    );\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, currentOffsets)),\n                new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, nextOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(6, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = SD(task, \"2008/P1D\", 0);\n    SegmentDescriptor desc2 = SD(task, \"2009/P1D\", 0);\n    SegmentDescriptor desc3 = SD(task, \"2010/P1D\", 0);\n    SegmentDescriptor desc4 = SD(task, \"2011/P1D\", 0);\n    SegmentDescriptor desc5 = SD(task, \"2049/P1D\", 0);\n    SegmentDescriptor desc7 = SD(task, \"2013/P1D\", 0);\n    Assert.assertEquals(ImmutableSet.of(desc1, desc2, desc3, desc4, desc5, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, ImmutableMap.of(\n            shardId1,\n            \"10\"\n        ))),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", desc1));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", desc2));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", desc3));\n    Assert.assertEquals(ImmutableList.of(\"d\", \"e\"), readSegmentColumn(\"dim1\", desc4));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc5));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc7));\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":646,"status":"B"}],"commitId":"7c7997e8a1183a7bffad731ca94e8b4c381e8665","commitMessage":"@@@Add Kinesis Indexing Service to core Druid (#6431)\n\n* created seekablestream classes\n\n* created seekablestreamsupervisor class\n\n* first attempt to integrate kafa indexing service to use SeekableStream\n\n* seekablestream bug fixes\n\n* kafkarecordsupplier\n\n* integrated kafka indexing service with seekablestream\n\n* implemented resume/suspend and refactored some package names\n\n* moved kinesis indexing service into core druid extensions\n\n* merged some changes from kafka supervisor race condition\n\n* integrated kinesis-indexing-service with seekablestream\n\n* unite tests for kinesis-indexing-service\n\n* various bug fixes for kinesis-indexing-service\n\n* refactored kinesisindexingtask\n\n* finished up more kinesis unit tests\n\n* more bug fixes for kinesis-indexing-service\n\n* finsihed refactoring kinesis unit tests\n\n* removed KinesisParititons and KafkaPartitions to use SeekableStreamPartitions\n\n* kinesis-indexing-service code cleanup and docs\n\n* merge #6291\n\nmerge #6337\n\nmerge #6383\n\n* added more docs and reordered methods\n\n* fixd kinesis tests after merging master and added docs in seekablestream\n\n* fix various things from pr comment\n\n* improve recordsupplier and add unit tests\n\n* migrated to aws-java-sdk-kinesis\n\n* merge changes from master\n\n* fix pom files and forbiddenapi checks\n\n* checkpoint JavaType bug fix\n\n* fix pom and stuff\n\n* disable checkpointing in kinesis\n\n* fix kinesis sequence number null in closed shard\n\n* merge changes from master\n\n* fixes for kinesis tasks\n\n* capitalized <partitionType.  sequenceType>\n\n* removed abstract class loggers\n\n* conform to guava api restrictions\n\n* add docker for travis other modules test\n\n* address comments\n\n* improve RecordSupplier to supply records in batch\n\n* fix strict compile issue\n\n* add test scope for localstack dependency\n\n* kinesis indexing task refactoring\n\n* comments\n\n* github comments\n\n* minor fix\n\n* removed unneeded readme\n\n* fix deserialization bug\n\n* fix various bugs\n\n* KinesisRecordSupplier unable to catch up to earliest position in stream bug fix\n\n* minor changes to kinesis\n\n* implement deaggregate for kinesis\n\n* Merge remote-tracking branch 'upstream/master' into seekablestream\n\n* fix kinesis offset discrepancy with kafka\n\n* kinesis record supplier disable getPosition\n\n* pr comments\n\n* mock for kinesis tests and remove docker dependency for unit tests\n\n* PR comments\n\n* avg lag in kafkasupervisor #6587\n\n* refacotred SequenceMetadata in taskRunners\n\n* small fix\n\n* more small fix\n\n* recordsupplier resource leak\n\n* revert .travis.yml formatting\n\n* fix style\n\n* kinesis docs\n\n* doc part2\n\n* more docs\n\n* comments\n\n* comments*2\n\n* revert string replace changes\n\n* comments\n\n* teamcity\n\n* comments part 1\n\n* comments part 2\n\n* comments part 3\n\n* merge #6754\n\n* fix injection binding\n\n* comments\n\n* KinesisRegion refactor\n\n* comments part idk lol\n\n* can't think of a commit msg anymore\n\n* remove possiblyResetDataSourceMetadata() for IncrementalPublishingTaskRunner\n\n* commmmmmmmmmments\n\n* extra error handling in KinesisRecordSupplier getRecords\n\n* comments\n\n* quickfix\n\n* typo\n\n* oof\n","date":"2018-12-22 03:49:24","modifiedFileCount":"22","status":"B","submitter":"Joshua Sun"},{"authorTime":"2019-02-24 12:10:31","codes":[{"authorDate":"2019-02-24 12:10:31","commitOrder":2,"curCode":"  public void testIncrementalHandOff() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = 2;\n    maxRecordsPerPoll = 1;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(0, 5))\n                                          .once()\n                                          .andReturn(records.subList(4, records.size()))\n                                          .once();\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    final SeekableStreamPartitions<String, String> startPartitions = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"0\",\n            shardId0,\n            \"0\"\n        )\n    );\n\n    final SeekableStreamPartitions<String, String> checkpoint1 = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"4\",\n            shardId0,\n            \"0\"\n        )\n    );\n\n    final SeekableStreamPartitions<String, String> endPartitions = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"9\",\n            shardId0,\n            \"1\"\n        )\n    );\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            null,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n    Assert.assertTrue(checkpoint1.getPartitionSequenceNumberMap().equals(currentOffsets));\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(1, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, currentOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(8, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = sd(task, \"2008/P1D\", 0);\n    SegmentDescriptor desc2 = sd(task, \"2009/P1D\", 0);\n    SegmentDescriptor desc3 = sd(task, \"2010/P1D\", 0);\n    SegmentDescriptor desc4 = sd(task, \"2011/P1D\", 0);\n    SegmentDescriptor desc5 = sd(task, \"2011/P1D\", 1);\n    SegmentDescriptor desc6 = sd(task, \"2012/P1D\", 0);\n    SegmentDescriptor desc7 = sd(task, \"2013/P1D\", 0);\n    Assert.assertEquals(ImmutableSet.of(desc1, desc2, desc3, desc4, desc5, desc6, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, ImmutableMap.of(\n            shardId1,\n            \"9\",\n            shardId0,\n            \"1\"\n        ))),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", desc1));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", desc2));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", desc3));\n    Assert.assertTrue((ImmutableList.of(\"d\", \"e\").equals(readSegmentColumn(\"dim1\", desc4))\n                       && ImmutableList.of(\"h\").equals(readSegmentColumn(\"dim1\", desc5))) ||\n                      (ImmutableList.of(\"d\", \"h\").equals(readSegmentColumn(\"dim1\", desc4))\n                       && ImmutableList.of(\"e\").equals(readSegmentColumn(\"dim1\", desc5))));\n    Assert.assertEquals(ImmutableList.of(\"g\"), readSegmentColumn(\"dim1\", desc6));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc7));\n  }\n","date":"2019-02-24 12:10:31","endLine":640,"groupId":"13112","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testIncrementalHandOff","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/78/ce481980bc6b2995ed7f4d5df533ef509f0938.src","preCode":"  public void testIncrementalHandOff() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = 2;\n    maxRecordsPerPoll = 1;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(0, 5))\n                                          .once()\n                                          .andReturn(records.subList(4, records.size()))\n                                          .once();\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    final SeekableStreamPartitions<String, String> startPartitions = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"0\",\n            shardId0,\n            \"0\"\n        )\n    );\n\n    final SeekableStreamPartitions<String, String> checkpoint1 = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"4\",\n            shardId0,\n            \"0\"\n        )\n    );\n\n    final SeekableStreamPartitions<String, String> endPartitions = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"9\",\n            shardId0,\n            \"1\"\n        )\n    );\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            null,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n    Assert.assertTrue(checkpoint1.getPartitionSequenceNumberMap().equals(currentOffsets));\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(1, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, currentOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(8, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = SD(task, \"2008/P1D\", 0);\n    SegmentDescriptor desc2 = SD(task, \"2009/P1D\", 0);\n    SegmentDescriptor desc3 = SD(task, \"2010/P1D\", 0);\n    SegmentDescriptor desc4 = SD(task, \"2011/P1D\", 0);\n    SegmentDescriptor desc5 = SD(task, \"2011/P1D\", 1);\n    SegmentDescriptor desc6 = SD(task, \"2012/P1D\", 0);\n    SegmentDescriptor desc7 = SD(task, \"2013/P1D\", 0);\n    Assert.assertEquals(ImmutableSet.of(desc1, desc2, desc3, desc4, desc5, desc6, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, ImmutableMap.of(\n            shardId1,\n            \"9\",\n            shardId0,\n            \"1\"\n        ))),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", desc1));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", desc2));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", desc3));\n    Assert.assertTrue((ImmutableList.of(\"d\", \"e\").equals(readSegmentColumn(\"dim1\", desc4))\n                       && ImmutableList.of(\"h\").equals(readSegmentColumn(\"dim1\", desc5))) ||\n                      (ImmutableList.of(\"d\", \"h\").equals(readSegmentColumn(\"dim1\", desc4))\n                       && ImmutableList.of(\"e\").equals(readSegmentColumn(\"dim1\", desc5))));\n    Assert.assertEquals(ImmutableList.of(\"g\"), readSegmentColumn(\"dim1\", desc6));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc7));\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":509,"status":"M"},{"authorDate":"2019-02-24 12:10:31","commitOrder":2,"curCode":"  public void testIncrementalHandOffMaxTotalRows() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = Integer.MAX_VALUE;\n    maxTotalRows = 3L;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(0, 3))\n                                          .once()\n                                          .andReturn(records.subList(2, 10))\n                                          .once()\n                                          .andReturn(records.subList(9, 11));\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    \r\n    final SeekableStreamPartitions<String, String> startPartitions = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"0\"\n        )\n    );\n    \r\n    \r\n    final SeekableStreamPartitions<String, String> checkpoint1 = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"2\"\n        )\n    );\n    final SeekableStreamPartitions<String, String> checkpoint2 = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"9\"\n        )\n    );\n    final SeekableStreamPartitions<String, String> endPartitions = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"10\"\n        )\n    );\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            null,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    while (task.getRunner().getStatus() != Status.PAUSED) {\n      Thread.sleep(10);\n    }\n\n    final Map<String, String> nextOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint2.getPartitionSequenceNumberMap(), nextOffsets);\n\n    task.getRunner().setEndOffsets(nextOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(2, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, currentOffsets))\n            )\n        )\n    );\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, currentOffsets)),\n                new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, nextOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(6, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = sd(task, \"2008/P1D\", 0);\n    SegmentDescriptor desc2 = sd(task, \"2009/P1D\", 0);\n    SegmentDescriptor desc3 = sd(task, \"2010/P1D\", 0);\n    SegmentDescriptor desc4 = sd(task, \"2011/P1D\", 0);\n    SegmentDescriptor desc5 = sd(task, \"2049/P1D\", 0);\n    SegmentDescriptor desc7 = sd(task, \"2013/P1D\", 0);\n    Assert.assertEquals(ImmutableSet.of(desc1, desc2, desc3, desc4, desc5, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, ImmutableMap.of(\n            shardId1,\n            \"10\"\n        ))),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", desc1));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", desc2));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", desc3));\n    Assert.assertEquals(ImmutableList.of(\"d\", \"e\"), readSegmentColumn(\"dim1\", desc4));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc5));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc7));\n  }\n","date":"2019-02-24 12:10:31","endLine":795,"groupId":"13113","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testIncrementalHandOffMaxTotalRows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/78/ce481980bc6b2995ed7f4d5df533ef509f0938.src","preCode":"  public void testIncrementalHandOffMaxTotalRows() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = Integer.MAX_VALUE;\n    maxTotalRows = 3L;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(0, 3))\n                                          .once()\n                                          .andReturn(records.subList(2, 10))\n                                          .once()\n                                          .andReturn(records.subList(9, 11));\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    \r\n    final SeekableStreamPartitions<String, String> startPartitions = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"0\"\n        )\n    );\n    \r\n    \r\n    final SeekableStreamPartitions<String, String> checkpoint1 = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"2\"\n        )\n    );\n    final SeekableStreamPartitions<String, String> checkpoint2 = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"9\"\n        )\n    );\n    final SeekableStreamPartitions<String, String> endPartitions = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"10\"\n        )\n    );\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            null,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    while (task.getRunner().getStatus() != Status.PAUSED) {\n      Thread.sleep(10);\n    }\n\n    final Map<String, String> nextOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint2.getPartitionSequenceNumberMap(), nextOffsets);\n\n    task.getRunner().setEndOffsets(nextOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(2, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, currentOffsets))\n            )\n        )\n    );\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, currentOffsets)),\n                new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, nextOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(6, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = SD(task, \"2008/P1D\", 0);\n    SegmentDescriptor desc2 = SD(task, \"2009/P1D\", 0);\n    SegmentDescriptor desc3 = SD(task, \"2010/P1D\", 0);\n    SegmentDescriptor desc4 = SD(task, \"2011/P1D\", 0);\n    SegmentDescriptor desc5 = SD(task, \"2049/P1D\", 0);\n    SegmentDescriptor desc7 = SD(task, \"2013/P1D\", 0);\n    Assert.assertEquals(ImmutableSet.of(desc1, desc2, desc3, desc4, desc5, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, ImmutableMap.of(\n            shardId1,\n            \"10\"\n        ))),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", desc1));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", desc2));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", desc3));\n    Assert.assertEquals(ImmutableList.of(\"d\", \"e\"), readSegmentColumn(\"dim1\", desc4));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc5));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc7));\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":644,"status":"M"}],"commitId":"8b803cbc22b15799fd0526de8d6d0eea155ad733","commitMessage":"@@@Added checkstyle for \"Methods starting with Capital Letters\"  (#7118)\n\n* Added checkstyle for \"Methods starting with Capital Letters\" and changed the method names violating this.\n\n* Un-abbreviate the method names in the calcite tests\n\n* Fixed checkstyle errors\n\n* Changed asserts position in the code\n","date":"2019-02-24 12:10:31","modifiedFileCount":"24","status":"M","submitter":"Himanshu Pandey"},{"authorTime":"2019-03-22 04:12:22","codes":[{"authorDate":"2019-03-22 04:12:22","commitOrder":3,"curCode":"  public void testIncrementalHandOff() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = 2;\n    maxRecordsPerPoll = 1;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(0, 5))\n                                          .once()\n                                          .andReturn(records.subList(4, records.size()))\n                                          .once();\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"0\", shardId0, \"0\"),\n        ImmutableSet.of()\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"4\", shardId0, \"0\")\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"9\", shardId0, \"1\")\n    );\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            null,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(1, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(stream, currentOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(8, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = sd(task, \"2008/P1D\", 0);\n    SegmentDescriptor desc2 = sd(task, \"2009/P1D\", 0);\n    SegmentDescriptor desc3 = sd(task, \"2010/P1D\", 0);\n    SegmentDescriptor desc4 = sd(task, \"2011/P1D\", 0);\n    SegmentDescriptor desc5 = sd(task, \"2011/P1D\", 1);\n    SegmentDescriptor desc6 = sd(task, \"2012/P1D\", 0);\n    SegmentDescriptor desc7 = sd(task, \"2013/P1D\", 0);\n    Assert.assertEquals(ImmutableSet.of(desc1, desc2, desc3, desc4, desc5, desc6, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<>(\n                stream,\n                ImmutableMap.of(shardId1, \"9\", shardId0, \"1\")\n            )\n        ),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", desc1));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", desc2));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", desc3));\n    Assert.assertTrue((ImmutableList.of(\"d\", \"e\").equals(readSegmentColumn(\"dim1\", desc4))\n                       && ImmutableList.of(\"h\").equals(readSegmentColumn(\"dim1\", desc5))) ||\n                      (ImmutableList.of(\"d\", \"h\").equals(readSegmentColumn(\"dim1\", desc4))\n                       && ImmutableList.of(\"e\").equals(readSegmentColumn(\"dim1\", desc5))));\n    Assert.assertEquals(ImmutableList.of(\"g\"), readSegmentColumn(\"dim1\", desc6));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc7));\n  }\n","date":"2019-03-22 04:12:22","endLine":630,"groupId":"13112","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testIncrementalHandOff","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/43/5bb2abf8e4aa9a5b48367bb0a0c33d66fdd44b.src","preCode":"  public void testIncrementalHandOff() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = 2;\n    maxRecordsPerPoll = 1;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(0, 5))\n                                          .once()\n                                          .andReturn(records.subList(4, records.size()))\n                                          .once();\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    final SeekableStreamPartitions<String, String> startPartitions = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"0\",\n            shardId0,\n            \"0\"\n        )\n    );\n\n    final SeekableStreamPartitions<String, String> checkpoint1 = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"4\",\n            shardId0,\n            \"0\"\n        )\n    );\n\n    final SeekableStreamPartitions<String, String> endPartitions = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"9\",\n            shardId0,\n            \"1\"\n        )\n    );\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            null,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n    Assert.assertTrue(checkpoint1.getPartitionSequenceNumberMap().equals(currentOffsets));\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(1, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, currentOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(8, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = sd(task, \"2008/P1D\", 0);\n    SegmentDescriptor desc2 = sd(task, \"2009/P1D\", 0);\n    SegmentDescriptor desc3 = sd(task, \"2010/P1D\", 0);\n    SegmentDescriptor desc4 = sd(task, \"2011/P1D\", 0);\n    SegmentDescriptor desc5 = sd(task, \"2011/P1D\", 1);\n    SegmentDescriptor desc6 = sd(task, \"2012/P1D\", 0);\n    SegmentDescriptor desc7 = sd(task, \"2013/P1D\", 0);\n    Assert.assertEquals(ImmutableSet.of(desc1, desc2, desc3, desc4, desc5, desc6, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, ImmutableMap.of(\n            shardId1,\n            \"9\",\n            shardId0,\n            \"1\"\n        ))),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", desc1));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", desc2));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", desc3));\n    Assert.assertTrue((ImmutableList.of(\"d\", \"e\").equals(readSegmentColumn(\"dim1\", desc4))\n                       && ImmutableList.of(\"h\").equals(readSegmentColumn(\"dim1\", desc5))) ||\n                      (ImmutableList.of(\"d\", \"h\").equals(readSegmentColumn(\"dim1\", desc4))\n                       && ImmutableList.of(\"e\").equals(readSegmentColumn(\"dim1\", desc5))));\n    Assert.assertEquals(ImmutableList.of(\"g\"), readSegmentColumn(\"dim1\", desc6));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc7));\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":514,"status":"M"},{"authorDate":"2019-03-22 04:12:22","commitOrder":3,"curCode":"  public void testIncrementalHandOffMaxTotalRows() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = Integer.MAX_VALUE;\n    maxTotalRows = 3L;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(0, 3))\n                                          .once()\n                                          .andReturn(records.subList(2, 10))\n                                          .once()\n                                          .andReturn(records.subList(9, 11));\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    \r\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"0\"),\n        ImmutableSet.of()\n    );\n    \r\n    \r\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"2\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint2 = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"9\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"10\")\n    );\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            null,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    while (task.getRunner().getStatus() != Status.PAUSED) {\n      Thread.sleep(10);\n    }\n\n    final Map<String, String> nextOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint2.getPartitionSequenceNumberMap(), nextOffsets);\n\n    task.getRunner().setEndOffsets(nextOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(2, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(stream, currentOffsets))\n            )\n        )\n    );\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(\n                    new SeekableStreamStartSequenceNumbers<>(stream, currentOffsets, ImmutableSet.of())\n                ),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(stream, nextOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(6, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = sd(task, \"2008/P1D\", 0);\n    SegmentDescriptor desc2 = sd(task, \"2009/P1D\", 0);\n    SegmentDescriptor desc3 = sd(task, \"2010/P1D\", 0);\n    SegmentDescriptor desc4 = sd(task, \"2011/P1D\", 0);\n    SegmentDescriptor desc5 = sd(task, \"2049/P1D\", 0);\n    SegmentDescriptor desc7 = sd(task, \"2013/P1D\", 0);\n    Assert.assertEquals(ImmutableSet.of(desc1, desc2, desc3, desc4, desc5, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"10\"))),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", desc1));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", desc2));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", desc3));\n    Assert.assertEquals(ImmutableList.of(\"d\", \"e\"), readSegmentColumn(\"dim1\", desc4));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc5));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc7));\n  }\n","date":"2019-03-22 04:12:22","endLine":771,"groupId":"13113","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testIncrementalHandOffMaxTotalRows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/43/5bb2abf8e4aa9a5b48367bb0a0c33d66fdd44b.src","preCode":"  public void testIncrementalHandOffMaxTotalRows() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = Integer.MAX_VALUE;\n    maxTotalRows = 3L;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(0, 3))\n                                          .once()\n                                          .andReturn(records.subList(2, 10))\n                                          .once()\n                                          .andReturn(records.subList(9, 11));\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    \r\n    final SeekableStreamPartitions<String, String> startPartitions = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"0\"\n        )\n    );\n    \r\n    \r\n    final SeekableStreamPartitions<String, String> checkpoint1 = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"2\"\n        )\n    );\n    final SeekableStreamPartitions<String, String> checkpoint2 = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"9\"\n        )\n    );\n    final SeekableStreamPartitions<String, String> endPartitions = new SeekableStreamPartitions<>(\n        stream,\n        ImmutableMap.of(\n            shardId1,\n            \"10\"\n        )\n    );\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            null,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    while (task.getRunner().getStatus() != Status.PAUSED) {\n      Thread.sleep(10);\n    }\n\n    final Map<String, String> nextOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint2.getPartitionSequenceNumberMap(), nextOffsets);\n\n    task.getRunner().setEndOffsets(nextOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(2, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, currentOffsets))\n            )\n        )\n    );\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, currentOffsets)),\n                new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, nextOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(6, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = sd(task, \"2008/P1D\", 0);\n    SegmentDescriptor desc2 = sd(task, \"2009/P1D\", 0);\n    SegmentDescriptor desc3 = sd(task, \"2010/P1D\", 0);\n    SegmentDescriptor desc4 = sd(task, \"2011/P1D\", 0);\n    SegmentDescriptor desc5 = sd(task, \"2049/P1D\", 0);\n    SegmentDescriptor desc7 = sd(task, \"2013/P1D\", 0);\n    Assert.assertEquals(ImmutableSet.of(desc1, desc2, desc3, desc4, desc5, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamPartitions<>(stream, ImmutableMap.of(\n            shardId1,\n            \"10\"\n        ))),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", desc1));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", desc2));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", desc3));\n    Assert.assertEquals(ImmutableList.of(\"d\", \"e\"), readSegmentColumn(\"dim1\", desc4));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc5));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc7));\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":633,"status":"M"}],"commitId":"0c5dcf5586e33607849e397209f3eb0b10661f1e","commitMessage":"@@@Fix exclusivity for start offset in kinesis indexing service & check exclusivity properly in IndexerSQLMetadataStorageCoordinator (#7291)\n\n* Fix exclusivity for start offset in kinesis indexing service\n\n* some adjustment\n\n* Fix SeekableStreamDataSourceMetadata\n\n* Add missing javadocs\n\n* Add missing comments and unit test\n\n* fix SeekableStreamStartSequenceNumbers.plus and add comments\n\n* remove extra exclusivePartitions in KafkaIOConfig and fix downgrade issue\n\n* Add javadocs\n\n* fix compilation\n\n* fix test\n\n* remove unused variable\n","date":"2019-03-22 04:12:22","modifiedFileCount":"30","status":"M","submitter":"Jihoon Son"},{"authorTime":"2019-03-27 05:39:07","codes":[{"authorDate":"2019-03-22 04:12:22","commitOrder":4,"curCode":"  public void testIncrementalHandOff() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = 2;\n    maxRecordsPerPoll = 1;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(0, 5))\n                                          .once()\n                                          .andReturn(records.subList(4, records.size()))\n                                          .once();\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"0\", shardId0, \"0\"),\n        ImmutableSet.of()\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"4\", shardId0, \"0\")\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"9\", shardId0, \"1\")\n    );\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            null,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(1, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(stream, currentOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(8, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = sd(task, \"2008/P1D\", 0);\n    SegmentDescriptor desc2 = sd(task, \"2009/P1D\", 0);\n    SegmentDescriptor desc3 = sd(task, \"2010/P1D\", 0);\n    SegmentDescriptor desc4 = sd(task, \"2011/P1D\", 0);\n    SegmentDescriptor desc5 = sd(task, \"2011/P1D\", 1);\n    SegmentDescriptor desc6 = sd(task, \"2012/P1D\", 0);\n    SegmentDescriptor desc7 = sd(task, \"2013/P1D\", 0);\n    Assert.assertEquals(ImmutableSet.of(desc1, desc2, desc3, desc4, desc5, desc6, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<>(\n                stream,\n                ImmutableMap.of(shardId1, \"9\", shardId0, \"1\")\n            )\n        ),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", desc1));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", desc2));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", desc3));\n    Assert.assertTrue((ImmutableList.of(\"d\", \"e\").equals(readSegmentColumn(\"dim1\", desc4))\n                       && ImmutableList.of(\"h\").equals(readSegmentColumn(\"dim1\", desc5))) ||\n                      (ImmutableList.of(\"d\", \"h\").equals(readSegmentColumn(\"dim1\", desc4))\n                       && ImmutableList.of(\"e\").equals(readSegmentColumn(\"dim1\", desc5))));\n    Assert.assertEquals(ImmutableList.of(\"g\"), readSegmentColumn(\"dim1\", desc6));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc7));\n  }\n","date":"2019-03-22 04:12:22","endLine":630,"groupId":"13112","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testIncrementalHandOff","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/43/5bb2abf8e4aa9a5b48367bb0a0c33d66fdd44b.src","preCode":"  public void testIncrementalHandOff() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = 2;\n    maxRecordsPerPoll = 1;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(0, 5))\n                                          .once()\n                                          .andReturn(records.subList(4, records.size()))\n                                          .once();\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"0\", shardId0, \"0\"),\n        ImmutableSet.of()\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"4\", shardId0, \"0\")\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"9\", shardId0, \"1\")\n    );\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            null,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(1, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(stream, currentOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(8, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = sd(task, \"2008/P1D\", 0);\n    SegmentDescriptor desc2 = sd(task, \"2009/P1D\", 0);\n    SegmentDescriptor desc3 = sd(task, \"2010/P1D\", 0);\n    SegmentDescriptor desc4 = sd(task, \"2011/P1D\", 0);\n    SegmentDescriptor desc5 = sd(task, \"2011/P1D\", 1);\n    SegmentDescriptor desc6 = sd(task, \"2012/P1D\", 0);\n    SegmentDescriptor desc7 = sd(task, \"2013/P1D\", 0);\n    Assert.assertEquals(ImmutableSet.of(desc1, desc2, desc3, desc4, desc5, desc6, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<>(\n                stream,\n                ImmutableMap.of(shardId1, \"9\", shardId0, \"1\")\n            )\n        ),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", desc1));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", desc2));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", desc3));\n    Assert.assertTrue((ImmutableList.of(\"d\", \"e\").equals(readSegmentColumn(\"dim1\", desc4))\n                       && ImmutableList.of(\"h\").equals(readSegmentColumn(\"dim1\", desc5))) ||\n                      (ImmutableList.of(\"d\", \"h\").equals(readSegmentColumn(\"dim1\", desc4))\n                       && ImmutableList.of(\"e\").equals(readSegmentColumn(\"dim1\", desc5))));\n    Assert.assertEquals(ImmutableList.of(\"g\"), readSegmentColumn(\"dim1\", desc6));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc7));\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":514,"status":"N"},{"authorDate":"2019-03-27 05:39:07","commitOrder":4,"curCode":"  public void testIncrementalHandOffMaxTotalRows() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = Integer.MAX_VALUE;\n    maxTotalRows = 3L;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(0, 3))\n                                          .once()\n                                          .andReturn(records.subList(2, 10))\n                                          .once()\n                                          .andReturn(records.subList(9, 11));\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    \r\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"0\"),\n        ImmutableSet.of()\n    );\n    \r\n    \r\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"2\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint2 = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"9\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"10\")\n    );\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            null,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    while (task.getRunner().getStatus() != Status.PAUSED) {\n      Thread.sleep(10);\n    }\n\n    final Map<String, String> nextOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint2.getPartitionSequenceNumberMap(), nextOffsets);\n\n    task.getRunner().setEndOffsets(nextOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(2, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(stream, currentOffsets))\n            )\n        )\n    );\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(\n                    new SeekableStreamStartSequenceNumbers<>(stream, currentOffsets, currentOffsets.keySet())\n                ),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(stream, nextOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(6, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = sd(task, \"2008/P1D\", 0);\n    SegmentDescriptor desc2 = sd(task, \"2009/P1D\", 0);\n    SegmentDescriptor desc3 = sd(task, \"2010/P1D\", 0);\n    SegmentDescriptor desc4 = sd(task, \"2011/P1D\", 0);\n    SegmentDescriptor desc5 = sd(task, \"2049/P1D\", 0);\n    SegmentDescriptor desc7 = sd(task, \"2013/P1D\", 0);\n    Assert.assertEquals(ImmutableSet.of(desc1, desc2, desc3, desc4, desc5, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"10\"))),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", desc1));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", desc2));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", desc3));\n    Assert.assertEquals(ImmutableList.of(\"d\", \"e\"), readSegmentColumn(\"dim1\", desc4));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc5));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc7));\n  }\n","date":"2019-03-27 05:39:07","endLine":774,"groupId":"13113","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testIncrementalHandOffMaxTotalRows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/bb/dd2ddc713f78b36973de6029d2b174f92e4413.src","preCode":"  public void testIncrementalHandOffMaxTotalRows() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = Integer.MAX_VALUE;\n    maxTotalRows = 3L;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(0, 3))\n                                          .once()\n                                          .andReturn(records.subList(2, 10))\n                                          .once()\n                                          .andReturn(records.subList(9, 11));\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    \r\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"0\"),\n        ImmutableSet.of()\n    );\n    \r\n    \r\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"2\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint2 = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"9\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"10\")\n    );\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            null,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    while (task.getRunner().getStatus() != Status.PAUSED) {\n      Thread.sleep(10);\n    }\n\n    final Map<String, String> nextOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint2.getPartitionSequenceNumberMap(), nextOffsets);\n\n    task.getRunner().setEndOffsets(nextOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(2, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(stream, currentOffsets))\n            )\n        )\n    );\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(\n                    new SeekableStreamStartSequenceNumbers<>(stream, currentOffsets, ImmutableSet.of())\n                ),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(stream, nextOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(6, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = sd(task, \"2008/P1D\", 0);\n    SegmentDescriptor desc2 = sd(task, \"2009/P1D\", 0);\n    SegmentDescriptor desc3 = sd(task, \"2010/P1D\", 0);\n    SegmentDescriptor desc4 = sd(task, \"2011/P1D\", 0);\n    SegmentDescriptor desc5 = sd(task, \"2049/P1D\", 0);\n    SegmentDescriptor desc7 = sd(task, \"2013/P1D\", 0);\n    Assert.assertEquals(ImmutableSet.of(desc1, desc2, desc3, desc4, desc5, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"10\"))),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", desc1));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", desc2));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", desc3));\n    Assert.assertEquals(ImmutableList.of(\"d\", \"e\"), readSegmentColumn(\"dim1\", desc4));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc5));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc7));\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":636,"status":"M"}],"commitId":"5294277cb4a382ae77baec2111d9383f0b34bed3","commitMessage":"@@@Fix exclusive start partitions for sequenceMetadata (#7339)\n\n* Fix exclusvie start partitions for sequenceMetadata\n\n* add empty check\n","date":"2019-03-27 05:39:07","modifiedFileCount":"10","status":"M","submitter":"Jihoon Son"},{"authorTime":"2019-04-09 10:19:34","codes":[{"authorDate":"2019-04-09 10:19:34","commitOrder":5,"curCode":"  public void testIncrementalHandOff() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = 2;\n    maxRecordsPerPoll = 1;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(0, 5))\n                                          .once()\n                                          .andReturn(records.subList(4, records.size()))\n                                          .once();\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"0\", shardId0, \"0\"),\n        ImmutableSet.of()\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"4\", shardId0, \"0\")\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"9\", shardId0, \"1\")\n    );\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(1, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(stream, currentOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(8, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = sd(task, \"2008/P1D\", 0);\n    SegmentDescriptor desc2 = sd(task, \"2009/P1D\", 0);\n    SegmentDescriptor desc3 = sd(task, \"2010/P1D\", 0);\n    SegmentDescriptor desc4 = sd(task, \"2011/P1D\", 0);\n    SegmentDescriptor desc5 = sd(task, \"2011/P1D\", 1);\n    SegmentDescriptor desc6 = sd(task, \"2012/P1D\", 0);\n    SegmentDescriptor desc7 = sd(task, \"2013/P1D\", 0);\n    Assert.assertEquals(ImmutableSet.of(desc1, desc2, desc3, desc4, desc5, desc6, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<>(\n                stream,\n                ImmutableMap.of(shardId1, \"9\", shardId0, \"1\")\n            )\n        ),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", desc1));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", desc2));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", desc3));\n    Assert.assertTrue((ImmutableList.of(\"d\", \"e\").equals(readSegmentColumn(\"dim1\", desc4))\n                       && ImmutableList.of(\"h\").equals(readSegmentColumn(\"dim1\", desc5))) ||\n                      (ImmutableList.of(\"d\", \"h\").equals(readSegmentColumn(\"dim1\", desc4))\n                       && ImmutableList.of(\"e\").equals(readSegmentColumn(\"dim1\", desc5))));\n    Assert.assertEquals(ImmutableList.of(\"g\"), readSegmentColumn(\"dim1\", desc6));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc7));\n  }\n","date":"2019-04-09 10:19:34","endLine":633,"groupId":"13112","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testIncrementalHandOff","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/96/9cc399636844b4dc771e9dcb171336b8b71c50.src","preCode":"  public void testIncrementalHandOff() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = 2;\n    maxRecordsPerPoll = 1;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(0, 5))\n                                          .once()\n                                          .andReturn(records.subList(4, records.size()))\n                                          .once();\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"0\", shardId0, \"0\"),\n        ImmutableSet.of()\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"4\", shardId0, \"0\")\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"9\", shardId0, \"1\")\n    );\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            null,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(1, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(stream, currentOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(8, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = sd(task, \"2008/P1D\", 0);\n    SegmentDescriptor desc2 = sd(task, \"2009/P1D\", 0);\n    SegmentDescriptor desc3 = sd(task, \"2010/P1D\", 0);\n    SegmentDescriptor desc4 = sd(task, \"2011/P1D\", 0);\n    SegmentDescriptor desc5 = sd(task, \"2011/P1D\", 1);\n    SegmentDescriptor desc6 = sd(task, \"2012/P1D\", 0);\n    SegmentDescriptor desc7 = sd(task, \"2013/P1D\", 0);\n    Assert.assertEquals(ImmutableSet.of(desc1, desc2, desc3, desc4, desc5, desc6, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<>(\n                stream,\n                ImmutableMap.of(shardId1, \"9\", shardId0, \"1\")\n            )\n        ),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", desc1));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", desc2));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", desc3));\n    Assert.assertTrue((ImmutableList.of(\"d\", \"e\").equals(readSegmentColumn(\"dim1\", desc4))\n                       && ImmutableList.of(\"h\").equals(readSegmentColumn(\"dim1\", desc5))) ||\n                      (ImmutableList.of(\"d\", \"h\").equals(readSegmentColumn(\"dim1\", desc4))\n                       && ImmutableList.of(\"e\").equals(readSegmentColumn(\"dim1\", desc5))));\n    Assert.assertEquals(ImmutableList.of(\"g\"), readSegmentColumn(\"dim1\", desc6));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc7));\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":517,"status":"M"},{"authorDate":"2019-04-09 10:19:34","commitOrder":5,"curCode":"  public void testIncrementalHandOffMaxTotalRows() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = Integer.MAX_VALUE;\n    maxTotalRows = 3L;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(0, 3))\n                                          .once()\n                                          .andReturn(records.subList(2, 10))\n                                          .once()\n                                          .andReturn(records.subList(9, 11));\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    \r\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"0\"),\n        ImmutableSet.of()\n    );\n    \r\n    \r\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"2\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint2 = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"9\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"10\")\n    );\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    while (task.getRunner().getStatus() != Status.PAUSED) {\n      Thread.sleep(10);\n    }\n\n    final Map<String, String> nextOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint2.getPartitionSequenceNumberMap(), nextOffsets);\n\n    task.getRunner().setEndOffsets(nextOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(2, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(stream, currentOffsets))\n            )\n        )\n    );\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(\n                    new SeekableStreamStartSequenceNumbers<>(stream, currentOffsets, currentOffsets.keySet())\n                ),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(stream, nextOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(6, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = sd(task, \"2008/P1D\", 0);\n    SegmentDescriptor desc2 = sd(task, \"2009/P1D\", 0);\n    SegmentDescriptor desc3 = sd(task, \"2010/P1D\", 0);\n    SegmentDescriptor desc4 = sd(task, \"2011/P1D\", 0);\n    SegmentDescriptor desc5 = sd(task, \"2049/P1D\", 0);\n    SegmentDescriptor desc7 = sd(task, \"2013/P1D\", 0);\n    Assert.assertEquals(ImmutableSet.of(desc1, desc2, desc3, desc4, desc5, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"10\"))),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", desc1));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", desc2));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", desc3));\n    Assert.assertEquals(ImmutableList.of(\"d\", \"e\"), readSegmentColumn(\"dim1\", desc4));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc5));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc7));\n  }\n","date":"2019-04-09 10:19:34","endLine":774,"groupId":"13113","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testIncrementalHandOffMaxTotalRows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/96/9cc399636844b4dc771e9dcb171336b8b71c50.src","preCode":"  public void testIncrementalHandOffMaxTotalRows() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = Integer.MAX_VALUE;\n    maxTotalRows = 3L;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(0, 3))\n                                          .once()\n                                          .andReturn(records.subList(2, 10))\n                                          .once()\n                                          .andReturn(records.subList(9, 11));\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    \r\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"0\"),\n        ImmutableSet.of()\n    );\n    \r\n    \r\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"2\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint2 = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"9\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"10\")\n    );\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            null,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    while (task.getRunner().getStatus() != Status.PAUSED) {\n      Thread.sleep(10);\n    }\n\n    final Map<String, String> nextOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint2.getPartitionSequenceNumberMap(), nextOffsets);\n\n    task.getRunner().setEndOffsets(nextOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(2, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(stream, currentOffsets))\n            )\n        )\n    );\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(\n                    new SeekableStreamStartSequenceNumbers<>(stream, currentOffsets, currentOffsets.keySet())\n                ),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(stream, nextOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(6, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = sd(task, \"2008/P1D\", 0);\n    SegmentDescriptor desc2 = sd(task, \"2009/P1D\", 0);\n    SegmentDescriptor desc3 = sd(task, \"2010/P1D\", 0);\n    SegmentDescriptor desc4 = sd(task, \"2011/P1D\", 0);\n    SegmentDescriptor desc5 = sd(task, \"2049/P1D\", 0);\n    SegmentDescriptor desc7 = sd(task, \"2013/P1D\", 0);\n    Assert.assertEquals(ImmutableSet.of(desc1, desc2, desc3, desc4, desc5, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"10\"))),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", desc1));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", desc2));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", desc3));\n    Assert.assertEquals(ImmutableList.of(\"d\", \"e\"), readSegmentColumn(\"dim1\", desc4));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc5));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc7));\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":636,"status":"M"}],"commitId":"e87d6e32b3b3f56441a6bdef4974e9c24ffcbf47","commitMessage":"@@@Support kinesis compatibility (#7351)\n\n","date":"2019-04-09 10:19:34","modifiedFileCount":"5","status":"M","submitter":"Jihoon Son"},{"authorTime":"2019-07-07 00:33:12","codes":[{"authorDate":"2019-07-07 00:33:12","commitOrder":6,"curCode":"  public void testIncrementalHandOff() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = 2;\n    maxRecordsPerPoll = 1;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(0, 5))\n            .once()\n            .andReturn(records.subList(4, records.size()))\n            .once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"0\", SHARD_ID0, \"0\"),\n        ImmutableSet.of()\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"4\", SHARD_ID0, \"0\")\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"9\", SHARD_ID0, \"1\")\n    );\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(1, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(STREAM, currentOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(8, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = sd(task, \"2008/P1D\", 0);\n    SegmentDescriptor desc2 = sd(task, \"2009/P1D\", 0);\n    SegmentDescriptor desc3 = sd(task, \"2010/P1D\", 0);\n    SegmentDescriptor desc4 = sd(task, \"2011/P1D\", 0);\n    SegmentDescriptor desc5 = sd(task, \"2011/P1D\", 1);\n    SegmentDescriptor desc6 = sd(task, \"2012/P1D\", 0);\n    SegmentDescriptor desc7 = sd(task, \"2013/P1D\", 0);\n    Assert.assertEquals(ImmutableSet.of(desc1, desc2, desc3, desc4, desc5, desc6, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<>(\n                STREAM,\n                ImmutableMap.of(SHARD_ID1, \"9\", SHARD_ID0, \"1\")\n            )\n        ),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", desc1));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", desc2));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", desc3));\n    Assert.assertTrue((ImmutableList.of(\"d\", \"e\").equals(readSegmentColumn(\"dim1\", desc4))\n                       && ImmutableList.of(\"h\").equals(readSegmentColumn(\"dim1\", desc5))) ||\n                      (ImmutableList.of(\"d\", \"h\").equals(readSegmentColumn(\"dim1\", desc4))\n                       && ImmutableList.of(\"e\").equals(readSegmentColumn(\"dim1\", desc5))));\n    Assert.assertEquals(ImmutableList.of(\"g\"), readSegmentColumn(\"dim1\", desc6));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc7));\n  }\n","date":"2019-07-07 00:33:12","endLine":632,"groupId":"13112","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testIncrementalHandOff","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/d8/bf83ce2a3969f1243df5bd1dad6429b383e83e.src","preCode":"  public void testIncrementalHandOff() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = 2;\n    maxRecordsPerPoll = 1;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(0, 5))\n                                          .once()\n                                          .andReturn(records.subList(4, records.size()))\n                                          .once();\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"0\", shardId0, \"0\"),\n        ImmutableSet.of()\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"4\", shardId0, \"0\")\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"9\", shardId0, \"1\")\n    );\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(1, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(stream, currentOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(8, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = sd(task, \"2008/P1D\", 0);\n    SegmentDescriptor desc2 = sd(task, \"2009/P1D\", 0);\n    SegmentDescriptor desc3 = sd(task, \"2010/P1D\", 0);\n    SegmentDescriptor desc4 = sd(task, \"2011/P1D\", 0);\n    SegmentDescriptor desc5 = sd(task, \"2011/P1D\", 1);\n    SegmentDescriptor desc6 = sd(task, \"2012/P1D\", 0);\n    SegmentDescriptor desc7 = sd(task, \"2013/P1D\", 0);\n    Assert.assertEquals(ImmutableSet.of(desc1, desc2, desc3, desc4, desc5, desc6, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<>(\n                stream,\n                ImmutableMap.of(shardId1, \"9\", shardId0, \"1\")\n            )\n        ),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", desc1));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", desc2));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", desc3));\n    Assert.assertTrue((ImmutableList.of(\"d\", \"e\").equals(readSegmentColumn(\"dim1\", desc4))\n                       && ImmutableList.of(\"h\").equals(readSegmentColumn(\"dim1\", desc5))) ||\n                      (ImmutableList.of(\"d\", \"h\").equals(readSegmentColumn(\"dim1\", desc4))\n                       && ImmutableList.of(\"e\").equals(readSegmentColumn(\"dim1\", desc5))));\n    Assert.assertEquals(ImmutableList.of(\"g\"), readSegmentColumn(\"dim1\", desc6));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc7));\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":516,"status":"M"},{"authorDate":"2019-07-07 00:33:12","commitOrder":6,"curCode":"  public void testIncrementalHandOffMaxTotalRows() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = Integer.MAX_VALUE;\n    maxTotalRows = 3L;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(0, 3))\n            .once()\n            .andReturn(records.subList(2, 10))\n            .once()\n            .andReturn(records.subList(9, 11));\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    \r\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"0\"),\n        ImmutableSet.of()\n    );\n    \r\n    \r\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"2\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint2 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"9\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"10\")\n    );\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n\n    final Map<String, String> nextOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint2.getPartitionSequenceNumberMap(), nextOffsets);\n\n    task.getRunner().setEndOffsets(nextOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(2, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(STREAM, currentOffsets))\n            )\n        )\n    );\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(\n                    new SeekableStreamStartSequenceNumbers<>(STREAM, currentOffsets, currentOffsets.keySet())\n                ),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(STREAM, nextOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(6, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = sd(task, \"2008/P1D\", 0);\n    SegmentDescriptor desc2 = sd(task, \"2009/P1D\", 0);\n    SegmentDescriptor desc3 = sd(task, \"2010/P1D\", 0);\n    SegmentDescriptor desc4 = sd(task, \"2011/P1D\", 0);\n    SegmentDescriptor desc5 = sd(task, \"2049/P1D\", 0);\n    SegmentDescriptor desc7 = sd(task, \"2013/P1D\", 0);\n    Assert.assertEquals(ImmutableSet.of(desc1, desc2, desc3, desc4, desc5, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"10\"))),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", desc1));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", desc2));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", desc3));\n    Assert.assertEquals(ImmutableList.of(\"d\", \"e\"), readSegmentColumn(\"dim1\", desc4));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc5));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc7));\n  }\n","date":"2019-07-07 00:33:12","endLine":773,"groupId":"1343","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testIncrementalHandOffMaxTotalRows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/d8/bf83ce2a3969f1243df5bd1dad6429b383e83e.src","preCode":"  public void testIncrementalHandOffMaxTotalRows() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = Integer.MAX_VALUE;\n    maxTotalRows = 3L;\n\n    recordSupplier.assign(anyObject());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.getEarliestSequenceNumber(anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(anyObject(), anyString());\n    expectLastCall().anyTimes();\n\n    expect(recordSupplier.poll(anyLong())).andReturn(records.subList(0, 3))\n                                          .once()\n                                          .andReturn(records.subList(2, 10))\n                                          .once()\n                                          .andReturn(records.subList(9, 11));\n\n    recordSupplier.close();\n    expectLastCall().once();\n\n    replayAll();\n\n    \r\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"0\"),\n        ImmutableSet.of()\n    );\n    \r\n    \r\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"2\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint2 = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"9\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        stream,\n        ImmutableMap.of(shardId1, \"10\")\n    );\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    while (task.getRunner().getStatus() != Status.PAUSED) {\n      Thread.sleep(10);\n    }\n\n    final Map<String, String> nextOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint2.getPartitionSequenceNumberMap(), nextOffsets);\n\n    task.getRunner().setEndOffsets(nextOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(2, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(stream, currentOffsets))\n            )\n        )\n    );\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(\n                    new SeekableStreamStartSequenceNumbers<>(stream, currentOffsets, currentOffsets.keySet())\n                ),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(stream, nextOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(6, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = sd(task, \"2008/P1D\", 0);\n    SegmentDescriptor desc2 = sd(task, \"2009/P1D\", 0);\n    SegmentDescriptor desc3 = sd(task, \"2010/P1D\", 0);\n    SegmentDescriptor desc4 = sd(task, \"2011/P1D\", 0);\n    SegmentDescriptor desc5 = sd(task, \"2049/P1D\", 0);\n    SegmentDescriptor desc7 = sd(task, \"2013/P1D\", 0);\n    Assert.assertEquals(ImmutableSet.of(desc1, desc2, desc3, desc4, desc5, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(stream, ImmutableMap.of(shardId1, \"10\"))),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", desc1));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", desc2));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", desc3));\n    Assert.assertEquals(ImmutableList.of(\"d\", \"e\"), readSegmentColumn(\"dim1\", desc4));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc5));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc7));\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":635,"status":"M"}],"commitId":"1166bbcb75d432817715fdd429737f86730b5591","commitMessage":"@@@Remove static imports from tests (#8036)\n\nMake static imports forbidden in tests and remove all occurrences to be\nconsistent with the non-test code.\n\nAlso.  various changes to files affected by above:\n- Reformat to adhere to druid style guide\n- Fix various IntelliJ warnings\n- Fix various SonarLint warnings (e.g..  the expected/actual args to\n  Assert.assertEquals() were flipped)","date":"2019-07-07 00:33:12","modifiedFileCount":"98","status":"M","submitter":"Chi Cao Minh"},{"authorTime":"2019-07-25 08:35:46","codes":[{"authorDate":"2019-07-25 08:35:46","commitOrder":7,"curCode":"  public void testIncrementalHandOff() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = 2;\n    maxRecordsPerPoll = 1;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(0, 5))\n            .once()\n            .andReturn(records.subList(4, records.size()))\n            .once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"0\", SHARD_ID0, \"0\"),\n        ImmutableSet.of()\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"4\", SHARD_ID0, \"0\")\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"9\", SHARD_ID0, \"1\")\n    );\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(1, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(STREAM, currentOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(8, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = sd(\"2008/P1D\", 0);\n    SegmentDescriptor desc2 = sd(\"2009/P1D\", 0);\n    SegmentDescriptor desc3 = sd(\"2010/P1D\", 0);\n    SegmentDescriptor desc4 = sd(\"2011/P1D\", 0);\n    SegmentDescriptor desc5 = sd(\"2011/P1D\", 1);\n    SegmentDescriptor desc6 = sd(\"2012/P1D\", 0);\n    SegmentDescriptor desc7 = sd(\"2013/P1D\", 0);\n    assertEqualsExceptVersion(ImmutableList.of(desc1, desc2, desc3, desc4, desc5, desc6, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<>(\n                STREAM,\n                ImmutableMap.of(SHARD_ID1, \"9\", SHARD_ID0, \"1\")\n            )\n        ),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    final List<SegmentDescriptor> publishedDescriptors = publishedDescriptors();\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(0)));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(1)));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(2)));\n    Assert.assertTrue((ImmutableList.of(\"d\", \"e\").equals(readSegmentColumn(\"dim1\", publishedDescriptors.get(3)))\n                       && ImmutableList.of(\"h\").equals(readSegmentColumn(\"dim1\", publishedDescriptors.get(4)))) ||\n                      (ImmutableList.of(\"d\", \"h\").equals(readSegmentColumn(\"dim1\", publishedDescriptors.get(3)))\n                       && ImmutableList.of(\"e\").equals(readSegmentColumn(\"dim1\", publishedDescriptors.get(4)))));\n    Assert.assertEquals(ImmutableList.of(\"g\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(5)));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(6)));\n  }\n","date":"2019-07-25 08:35:46","endLine":658,"groupId":"14790","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testIncrementalHandOff","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/00/6677b0a28185be95d0eb677acfab7ede656120.src","preCode":"  public void testIncrementalHandOff() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = 2;\n    maxRecordsPerPoll = 1;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(0, 5))\n            .once()\n            .andReturn(records.subList(4, records.size()))\n            .once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"0\", SHARD_ID0, \"0\"),\n        ImmutableSet.of()\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"4\", SHARD_ID0, \"0\")\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"9\", SHARD_ID0, \"1\")\n    );\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(1, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(STREAM, currentOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(8, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = sd(task, \"2008/P1D\", 0);\n    SegmentDescriptor desc2 = sd(task, \"2009/P1D\", 0);\n    SegmentDescriptor desc3 = sd(task, \"2010/P1D\", 0);\n    SegmentDescriptor desc4 = sd(task, \"2011/P1D\", 0);\n    SegmentDescriptor desc5 = sd(task, \"2011/P1D\", 1);\n    SegmentDescriptor desc6 = sd(task, \"2012/P1D\", 0);\n    SegmentDescriptor desc7 = sd(task, \"2013/P1D\", 0);\n    Assert.assertEquals(ImmutableSet.of(desc1, desc2, desc3, desc4, desc5, desc6, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<>(\n                STREAM,\n                ImmutableMap.of(SHARD_ID1, \"9\", SHARD_ID0, \"1\")\n            )\n        ),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", desc1));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", desc2));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", desc3));\n    Assert.assertTrue((ImmutableList.of(\"d\", \"e\").equals(readSegmentColumn(\"dim1\", desc4))\n                       && ImmutableList.of(\"h\").equals(readSegmentColumn(\"dim1\", desc5))) ||\n                      (ImmutableList.of(\"d\", \"h\").equals(readSegmentColumn(\"dim1\", desc4))\n                       && ImmutableList.of(\"e\").equals(readSegmentColumn(\"dim1\", desc5))));\n    Assert.assertEquals(ImmutableList.of(\"g\"), readSegmentColumn(\"dim1\", desc6));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc7));\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":541,"status":"M"},{"authorDate":"2019-07-25 08:35:46","commitOrder":7,"curCode":"  public void testIncrementalHandOffMaxTotalRows() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = Integer.MAX_VALUE;\n    maxTotalRows = 3L;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(0, 3))\n            .once()\n            .andReturn(records.subList(2, 10))\n            .once()\n            .andReturn(records.subList(9, 11));\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    \r\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"0\"),\n        ImmutableSet.of()\n    );\n    \r\n    \r\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"2\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint2 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"9\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"10\")\n    );\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n\n    final Map<String, String> nextOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint2.getPartitionSequenceNumberMap(), nextOffsets);\n\n    task.getRunner().setEndOffsets(nextOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(2, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(STREAM, currentOffsets))\n            )\n        )\n    );\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(\n                    new SeekableStreamStartSequenceNumbers<>(STREAM, currentOffsets, currentOffsets.keySet())\n                ),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(STREAM, nextOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(6, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = sd(\"2008/P1D\", 0);\n    SegmentDescriptor desc2 = sd(\"2009/P1D\", 0);\n    SegmentDescriptor desc3 = sd(\"2010/P1D\", 0);\n    SegmentDescriptor desc4 = sd(\"2011/P1D\", 0);\n    SegmentDescriptor desc5 = sd(\"2049/P1D\", 0);\n    SegmentDescriptor desc7 = sd(\"2013/P1D\", 0);\n    assertEqualsExceptVersion(ImmutableList.of(desc1, desc2, desc3, desc4, desc5, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"10\"))),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    final List<SegmentDescriptor> publishedDescriptors = publishedDescriptors();\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(0)));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(1)));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(2)));\n    Assert.assertEquals(ImmutableList.of(\"d\", \"e\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(3)));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(4)));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(5)));\n  }\n","date":"2019-07-25 08:35:46","endLine":800,"groupId":"1343","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testIncrementalHandOffMaxTotalRows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/00/6677b0a28185be95d0eb677acfab7ede656120.src","preCode":"  public void testIncrementalHandOffMaxTotalRows() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = Integer.MAX_VALUE;\n    maxTotalRows = 3L;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(0, 3))\n            .once()\n            .andReturn(records.subList(2, 10))\n            .once()\n            .andReturn(records.subList(9, 11));\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    \r\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"0\"),\n        ImmutableSet.of()\n    );\n    \r\n    \r\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"2\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint2 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"9\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"10\")\n    );\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n\n    final Map<String, String> nextOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint2.getPartitionSequenceNumberMap(), nextOffsets);\n\n    task.getRunner().setEndOffsets(nextOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(2, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(STREAM, currentOffsets))\n            )\n        )\n    );\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(\n                    new SeekableStreamStartSequenceNumbers<>(STREAM, currentOffsets, currentOffsets.keySet())\n                ),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(STREAM, nextOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(6, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = sd(task, \"2008/P1D\", 0);\n    SegmentDescriptor desc2 = sd(task, \"2009/P1D\", 0);\n    SegmentDescriptor desc3 = sd(task, \"2010/P1D\", 0);\n    SegmentDescriptor desc4 = sd(task, \"2011/P1D\", 0);\n    SegmentDescriptor desc5 = sd(task, \"2049/P1D\", 0);\n    SegmentDescriptor desc7 = sd(task, \"2013/P1D\", 0);\n    Assert.assertEquals(ImmutableSet.of(desc1, desc2, desc3, desc4, desc5, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"10\"))),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", desc1));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", desc2));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", desc3));\n    Assert.assertEquals(ImmutableList.of(\"d\", \"e\"), readSegmentColumn(\"dim1\", desc4));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc5));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", desc7));\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":661,"status":"M"}],"commitId":"db149462073d59e7563f0d3834e69d44a2bb4011","commitMessage":"@@@Add support minor compaction with segment locking (#7547)\n\n* Segment locking\n\n* Allow both timeChunk and segment lock in the same gruop\n\n* fix it test\n\n* Fix adding same chunk to atomicUpdateGroup\n\n* resolving todos\n\n* Fix segments to lock\n\n* fix segments to lock\n\n* fix kill task\n\n* resolving todos\n\n* resolving todos\n\n* fix teamcity\n\n* remove unused class\n\n* fix single map\n\n* resolving todos\n\n* fix build\n\n* fix SQLMetadataSegmentManager\n\n* fix findInputSegments\n\n* adding more tests\n\n* fixing task lock checks\n\n* add SegmentTransactionalOverwriteAction\n\n* changing publisher\n\n* fixing something\n\n* fix for perfect rollup\n\n* fix test\n\n* adjust package-lock.json\n\n* fix test\n\n* fix style\n\n* adding javadocs\n\n* remove unused classes\n\n* add more javadocs\n\n* unused import\n\n* fix test\n\n* fix test\n\n* Support forceTimeChunk context and force timeChunk lock for parallel index task if intervals are missing\n\n* fix travis\n\n* fix travis\n\n* unused import\n\n* spotbug\n\n* revert getMaxVersion\n\n* address comments\n\n* fix tc\n\n* add missing error handling\n\n* fix backward compatibility\n\n* unused import\n\n* Fix perf of versionedIntervalTimeline\n\n* fix timeline\n\n* fix tc\n\n* remove remaining todos\n\n* add comment for parallel index\n\n* fix javadoc and typos\n\n* typo\n\n* address comments\n","date":"2019-07-25 08:35:46","modifiedFileCount":"130","status":"M","submitter":"Jihoon Son"},{"authorTime":"2019-08-22 01:58:22","codes":[{"authorDate":"2019-08-22 01:58:22","commitOrder":8,"curCode":"  public void testIncrementalHandOff() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = 2;\n    maxRecordsPerPoll = 1;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(0, 5))\n            .once()\n            .andReturn(records.subList(4, records.size()))\n            .once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"0\", SHARD_ID0, \"0\"),\n        ImmutableSet.of()\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"4\", SHARD_ID0, \"0\")\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"9\", SHARD_ID0, \"1\")\n    );\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(1, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions)\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(8, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = sd(\"2008/P1D\", 0);\n    SegmentDescriptor desc2 = sd(\"2009/P1D\", 0);\n    SegmentDescriptor desc3 = sd(\"2010/P1D\", 0);\n    SegmentDescriptor desc4 = sd(\"2011/P1D\", 0);\n    SegmentDescriptor desc5 = sd(\"2011/P1D\", 1);\n    SegmentDescriptor desc6 = sd(\"2012/P1D\", 0);\n    SegmentDescriptor desc7 = sd(\"2013/P1D\", 0);\n    assertEqualsExceptVersion(ImmutableList.of(desc1, desc2, desc3, desc4, desc5, desc6, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<>(\n                STREAM,\n                ImmutableMap.of(SHARD_ID1, \"9\", SHARD_ID0, \"1\")\n            )\n        ),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    final List<SegmentDescriptor> publishedDescriptors = publishedDescriptors();\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(0)));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(1)));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(2)));\n    Assert.assertTrue((ImmutableList.of(\"d\", \"e\").equals(readSegmentColumn(\"dim1\", publishedDescriptors.get(3)))\n                       && ImmutableList.of(\"h\").equals(readSegmentColumn(\"dim1\", publishedDescriptors.get(4)))) ||\n                      (ImmutableList.of(\"d\", \"h\").equals(readSegmentColumn(\"dim1\", publishedDescriptors.get(3)))\n                       && ImmutableList.of(\"e\").equals(readSegmentColumn(\"dim1\", publishedDescriptors.get(4)))));\n    Assert.assertEquals(ImmutableList.of(\"g\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(5)));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(6)));\n  }\n","date":"2019-08-22 01:58:22","endLine":662,"groupId":"8759","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testIncrementalHandOff","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/d8/b98a272a298b563509af89b00decbb917bc831.src","preCode":"  public void testIncrementalHandOff() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = 2;\n    maxRecordsPerPoll = 1;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(0, 5))\n            .once()\n            .andReturn(records.subList(4, records.size()))\n            .once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"0\", SHARD_ID0, \"0\"),\n        ImmutableSet.of()\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"4\", SHARD_ID0, \"0\")\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"9\", SHARD_ID0, \"1\")\n    );\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(1, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(STREAM, currentOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(8, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = sd(\"2008/P1D\", 0);\n    SegmentDescriptor desc2 = sd(\"2009/P1D\", 0);\n    SegmentDescriptor desc3 = sd(\"2010/P1D\", 0);\n    SegmentDescriptor desc4 = sd(\"2011/P1D\", 0);\n    SegmentDescriptor desc5 = sd(\"2011/P1D\", 1);\n    SegmentDescriptor desc6 = sd(\"2012/P1D\", 0);\n    SegmentDescriptor desc7 = sd(\"2013/P1D\", 0);\n    assertEqualsExceptVersion(ImmutableList.of(desc1, desc2, desc3, desc4, desc5, desc6, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<>(\n                STREAM,\n                ImmutableMap.of(SHARD_ID1, \"9\", SHARD_ID0, \"1\")\n            )\n        ),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    final List<SegmentDescriptor> publishedDescriptors = publishedDescriptors();\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(0)));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(1)));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(2)));\n    Assert.assertTrue((ImmutableList.of(\"d\", \"e\").equals(readSegmentColumn(\"dim1\", publishedDescriptors.get(3)))\n                       && ImmutableList.of(\"h\").equals(readSegmentColumn(\"dim1\", publishedDescriptors.get(4)))) ||\n                      (ImmutableList.of(\"d\", \"h\").equals(readSegmentColumn(\"dim1\", publishedDescriptors.get(3)))\n                       && ImmutableList.of(\"e\").equals(readSegmentColumn(\"dim1\", publishedDescriptors.get(4)))));\n    Assert.assertEquals(ImmutableList.of(\"g\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(5)));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(6)));\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":546,"status":"M"},{"authorDate":"2019-08-22 01:58:22","commitOrder":8,"curCode":"  public void testIncrementalHandOffMaxTotalRows() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = Integer.MAX_VALUE;\n    maxTotalRows = 3L;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(0, 3))\n            .once()\n            .andReturn(records.subList(2, 10))\n            .once()\n            .andReturn(records.subList(9, 11));\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    \r\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"0\"),\n        ImmutableSet.of()\n    );\n    \r\n    \r\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"2\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint2 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"9\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"10\")\n    );\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n\n    final Map<String, String> nextOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint2.getPartitionSequenceNumberMap(), nextOffsets);\n\n    task.getRunner().setEndOffsets(nextOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(2, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions)\n            )\n        )\n    );\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(\n                    new SeekableStreamStartSequenceNumbers<>(STREAM, currentOffsets, currentOffsets.keySet()))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(6, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = sd(\"2008/P1D\", 0);\n    SegmentDescriptor desc2 = sd(\"2009/P1D\", 0);\n    SegmentDescriptor desc3 = sd(\"2010/P1D\", 0);\n    SegmentDescriptor desc4 = sd(\"2011/P1D\", 0);\n    SegmentDescriptor desc5 = sd(\"2049/P1D\", 0);\n    SegmentDescriptor desc7 = sd(\"2013/P1D\", 0);\n    assertEqualsExceptVersion(ImmutableList.of(desc1, desc2, desc3, desc4, desc5, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"10\"))),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    final List<SegmentDescriptor> publishedDescriptors = publishedDescriptors();\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(0)));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(1)));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(2)));\n    Assert.assertEquals(ImmutableList.of(\"d\", \"e\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(3)));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(4)));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(5)));\n  }\n","date":"2019-08-22 01:58:22","endLine":801,"groupId":"8760","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testIncrementalHandOffMaxTotalRows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/d8/b98a272a298b563509af89b00decbb917bc831.src","preCode":"  public void testIncrementalHandOffMaxTotalRows() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = Integer.MAX_VALUE;\n    maxTotalRows = 3L;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(0, 3))\n            .once()\n            .andReturn(records.subList(2, 10))\n            .once()\n            .andReturn(records.subList(9, 11));\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    \r\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"0\"),\n        ImmutableSet.of()\n    );\n    \r\n    \r\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"2\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint2 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"9\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"10\")\n    );\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n\n    final Map<String, String> nextOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint2.getPartitionSequenceNumberMap(), nextOffsets);\n\n    task.getRunner().setEndOffsets(nextOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(2, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(STREAM, currentOffsets))\n            )\n        )\n    );\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(\n                    new SeekableStreamStartSequenceNumbers<>(STREAM, currentOffsets, currentOffsets.keySet())\n                ),\n                new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(STREAM, nextOffsets))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(6, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = sd(\"2008/P1D\", 0);\n    SegmentDescriptor desc2 = sd(\"2009/P1D\", 0);\n    SegmentDescriptor desc3 = sd(\"2010/P1D\", 0);\n    SegmentDescriptor desc4 = sd(\"2011/P1D\", 0);\n    SegmentDescriptor desc5 = sd(\"2049/P1D\", 0);\n    SegmentDescriptor desc7 = sd(\"2013/P1D\", 0);\n    assertEqualsExceptVersion(ImmutableList.of(desc1, desc2, desc3, desc4, desc5, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"10\"))),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    final List<SegmentDescriptor> publishedDescriptors = publishedDescriptors();\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(0)));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(1)));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(2)));\n    Assert.assertEquals(ImmutableList.of(\"d\", \"e\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(3)));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(4)));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(5)));\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":665,"status":"M"}],"commitId":"22d6384d364a851fd2b5cecafea9d72b004cb03b","commitMessage":"@@@Fix unrealistic test variables in KafkaSupervisorTest and tidy up unused variable in checkpointing process (#7319)\n\n* Fix unrealistic test arguments in KafkaSupervisorTest\n\n* remove currentCheckpoint from checkpoint action\n\n* rename variable\n","date":"2019-08-22 01:58:22","modifiedFileCount":"12","status":"M","submitter":"Jihoon Son"},{"authorTime":"2019-11-07 03:07:04","codes":[{"authorDate":"2019-11-07 03:07:04","commitOrder":9,"curCode":"  public void testIncrementalHandOff() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = 2;\n    maxRecordsPerPoll = 1;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(0, 5))\n            .once()\n            .andReturn(records.subList(4, records.size()))\n            .once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"0\", SHARD_ID0, \"0\"),\n        ImmutableSet.of()\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"4\", SHARD_ID0, \"0\")\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"9\", SHARD_ID0, \"1\")\n    );\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(1, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions)\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(8, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    assertEqualsExceptVersion(\n        ImmutableList.of(\n            sdd(\"2008/P1D\", 0, ImmutableList.of(\"a\")),\n            sdd(\"2009/P1D\", 0, ImmutableList.of(\"b\")),\n            sdd(\"2010/P1D\", 0, ImmutableList.of(\"c\")),\n            sdd(\"2011/P1D\", 0, ImmutableList.of(\"d\", \"e\"), ImmutableList.of(\"d\", \"h\")),\n            sdd(\"2011/P1D\", 1, ImmutableList.of(\"h\"), ImmutableList.of(\"e\")),\n            sdd(\"2012/P1D\", 0, ImmutableList.of(\"g\")),\n            sdd(\"2013/P1D\", 0, ImmutableList.of(\"f\"))\n        ),\n        publishedDescriptors()\n    );\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<>(\n                STREAM,\n                ImmutableMap.of(SHARD_ID1, \"9\", SHARD_ID0, \"1\")\n            )\n        ),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n  }\n","date":"2019-11-07 03:07:04","endLine":559,"groupId":"8759","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"testIncrementalHandOff","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/27/4549891b92c24291334168d8161d2a1bfc90f5.src","preCode":"  public void testIncrementalHandOff() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = 2;\n    maxRecordsPerPoll = 1;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(0, 5))\n            .once()\n            .andReturn(records.subList(4, records.size()))\n            .once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"0\", SHARD_ID0, \"0\"),\n        ImmutableSet.of()\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"4\", SHARD_ID0, \"0\")\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"9\", SHARD_ID0, \"1\")\n    );\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(1, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions)\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(8, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = sd(\"2008/P1D\", 0);\n    SegmentDescriptor desc2 = sd(\"2009/P1D\", 0);\n    SegmentDescriptor desc3 = sd(\"2010/P1D\", 0);\n    SegmentDescriptor desc4 = sd(\"2011/P1D\", 0);\n    SegmentDescriptor desc5 = sd(\"2011/P1D\", 1);\n    SegmentDescriptor desc6 = sd(\"2012/P1D\", 0);\n    SegmentDescriptor desc7 = sd(\"2013/P1D\", 0);\n    assertEqualsExceptVersion(ImmutableList.of(desc1, desc2, desc3, desc4, desc5, desc6, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<>(\n                STREAM,\n                ImmutableMap.of(SHARD_ID1, \"9\", SHARD_ID0, \"1\")\n            )\n        ),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    final List<SegmentDescriptor> publishedDescriptors = publishedDescriptors();\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(0)));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(1)));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(2)));\n    Assert.assertTrue((ImmutableList.of(\"d\", \"e\").equals(readSegmentColumn(\"dim1\", publishedDescriptors.get(3)))\n                       && ImmutableList.of(\"h\").equals(readSegmentColumn(\"dim1\", publishedDescriptors.get(4)))) ||\n                      (ImmutableList.of(\"d\", \"h\").equals(readSegmentColumn(\"dim1\", publishedDescriptors.get(3)))\n                       && ImmutableList.of(\"e\").equals(readSegmentColumn(\"dim1\", publishedDescriptors.get(4)))));\n    Assert.assertEquals(ImmutableList.of(\"g\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(5)));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(6)));\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":451,"status":"M"},{"authorDate":"2019-11-07 03:07:04","commitOrder":9,"curCode":"  public void testIncrementalHandOffMaxTotalRows() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = Integer.MAX_VALUE;\n    maxTotalRows = 3L;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(0, 3))\n            .once()\n            .andReturn(records.subList(2, 10))\n            .once()\n            .andReturn(records.subList(9, 11));\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    \r\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"0\"),\n        ImmutableSet.of()\n    );\n    \r\n    \r\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"2\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint2 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"9\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"10\")\n    );\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n\n    final Map<String, String> nextOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint2.getPartitionSequenceNumberMap(), nextOffsets);\n\n    task.getRunner().setEndOffsets(nextOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(2, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions)\n            )\n        )\n    );\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(\n                    new SeekableStreamStartSequenceNumbers<>(STREAM, currentOffsets, currentOffsets.keySet()))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(6, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    assertEqualsExceptVersion(\n        ImmutableList.of(\n            sdd(\"2008/P1D\", 0, ImmutableList.of(\"a\")),\n            sdd(\"2009/P1D\", 0, ImmutableList.of(\"b\")),\n            sdd(\"2010/P1D\", 0, ImmutableList.of(\"c\")),\n            sdd(\"2011/P1D\", 0, ImmutableList.of(\"d\", \"e\")),\n            sdd(\"2049/P1D\", 0, ImmutableList.of(\"f\")),\n            sdd(\"2013/P1D\", 0, ImmutableList.of(\"f\"))\n        ),\n        publishedDescriptors()\n    );\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"10\"))),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n  }\n","date":"2019-11-07 03:07:04","endLine":693,"groupId":"8760","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"testIncrementalHandOffMaxTotalRows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/27/4549891b92c24291334168d8161d2a1bfc90f5.src","preCode":"  public void testIncrementalHandOffMaxTotalRows() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = Integer.MAX_VALUE;\n    maxTotalRows = 3L;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(0, 3))\n            .once()\n            .andReturn(records.subList(2, 10))\n            .once()\n            .andReturn(records.subList(9, 11));\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    \r\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"0\"),\n        ImmutableSet.of()\n    );\n    \r\n    \r\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"2\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint2 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"9\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"10\")\n    );\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n\n    final Map<String, String> nextOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint2.getPartitionSequenceNumberMap(), nextOffsets);\n\n    task.getRunner().setEndOffsets(nextOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(2, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions)\n            )\n        )\n    );\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(\n                    new SeekableStreamStartSequenceNumbers<>(STREAM, currentOffsets, currentOffsets.keySet()))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(6, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    SegmentDescriptor desc1 = sd(\"2008/P1D\", 0);\n    SegmentDescriptor desc2 = sd(\"2009/P1D\", 0);\n    SegmentDescriptor desc3 = sd(\"2010/P1D\", 0);\n    SegmentDescriptor desc4 = sd(\"2011/P1D\", 0);\n    SegmentDescriptor desc5 = sd(\"2049/P1D\", 0);\n    SegmentDescriptor desc7 = sd(\"2013/P1D\", 0);\n    assertEqualsExceptVersion(ImmutableList.of(desc1, desc2, desc3, desc4, desc5, desc7), publishedDescriptors());\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"10\"))),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n\n    \r\n    final List<SegmentDescriptor> publishedDescriptors = publishedDescriptors();\n    Assert.assertEquals(ImmutableList.of(\"a\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(0)));\n    Assert.assertEquals(ImmutableList.of(\"b\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(1)));\n    Assert.assertEquals(ImmutableList.of(\"c\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(2)));\n    Assert.assertEquals(ImmutableList.of(\"d\", \"e\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(3)));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(4)));\n    Assert.assertEquals(ImmutableList.of(\"f\"), readSegmentColumn(\"dim1\", publishedDescriptors.get(5)));\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":562,"status":"M"}],"commitId":"5c0fc0a13ab4d259b430bf50b322f631504c4529","commitMessage":"@@@Fix ambiguity about IndexerSQLMetadataStorageCoordinator.getUsedSegmentsForInterval() returning only non-overshadowed or all used segments (#8564)\n\n* IndexerSQLMetadataStorageCoordinator.getTimelineForIntervalsWithHandle() don't fetch abutting intervals; simplify getUsedSegmentsForIntervals()\n\n* Add VersionedIntervalTimeline.findNonOvershadowedObjectsInInterval() method; Propagate the decision about whether only visible segmetns or visible and overshadowed segments should be returned from IndexerMetadataStorageCoordinator's methods to the user logic; Rename SegmentListUsedAction to RetrieveUsedSegmentsAction.  SegmetnListUnusedAction to RetrieveUnusedSegmentsAction.  and UsedSegmentLister to UsedSegmentsRetriever\n\n* Fix tests\n\n* More fixes\n\n* Add javadoc notes about returning Collection instead of Set. Add JacksonUtils.readValue() to reduce boilerplate code\n\n* Fix KinesisIndexTaskTest.  factor out common parts from KinesisIndexTaskTest and KafkaIndexTaskTest into SeekableStreamIndexTaskTestBase\n\n* More test fixes\n\n* More test fixes\n\n* Add a comment to VersionedIntervalTimelineTestBase\n\n* Fix tests\n\n* Set DataSegment.size(0) in more tests\n\n* Specify DataSegment.size(0) in more places in tests\n\n* Fix more tests\n\n* Fix DruidSchemaTest\n\n* Set DataSegment's size in more tests and benchmarks\n\n* Fix HdfsDataSegmentPusherTest\n\n* Doc changes addressing comments\n\n* Extended doc for visibility\n\n* Typo\n\n* Typo 2\n\n* Address comment\n","date":"2019-11-07 03:07:04","modifiedFileCount":"88","status":"M","submitter":"Roman Leventov"},{"authorTime":"2019-11-21 06:51:25","codes":[{"authorDate":"2019-11-21 06:51:25","commitOrder":10,"curCode":"  public void testIncrementalHandOff() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = 2;\n    maxRecordsPerPoll = 1;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(0, 5))\n            .once()\n            .andReturn(records.subList(4, records.size()))\n            .once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"0\", SHARD_ID0, \"0\"),\n        ImmutableSet.of()\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"4\", SHARD_ID0, \"0\")\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"9\", SHARD_ID0, \"1\")\n    );\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            INPUT_FORMAT,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(1, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                NEW_DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions)\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(8, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    assertEqualsExceptVersion(\n        ImmutableList.of(\n            sdd(\"2008/P1D\", 0, ImmutableList.of(\"a\")),\n            sdd(\"2009/P1D\", 0, ImmutableList.of(\"b\")),\n            sdd(\"2010/P1D\", 0, ImmutableList.of(\"c\")),\n            sdd(\"2011/P1D\", 0, ImmutableList.of(\"d\", \"e\"), ImmutableList.of(\"d\", \"h\")),\n            sdd(\"2011/P1D\", 1, ImmutableList.of(\"h\"), ImmutableList.of(\"e\")),\n            sdd(\"2012/P1D\", 0, ImmutableList.of(\"g\")),\n            sdd(\"2013/P1D\", 0, ImmutableList.of(\"f\"))\n        ),\n        publishedDescriptors()\n    );\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<>(\n                STREAM,\n                ImmutableMap.of(SHARD_ID1, \"9\", SHARD_ID0, \"1\")\n            )\n        ),\n        metadataStorageCoordinator.getDataSourceMetadata(NEW_DATA_SCHEMA.getDataSource())\n    );\n  }\n","date":"2019-11-21 06:51:25","endLine":629,"groupId":"349","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"testIncrementalHandOff","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/a3/34a790bdbace996db1007835d408c9c203e38c.src","preCode":"  public void testIncrementalHandOff() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = 2;\n    maxRecordsPerPoll = 1;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(0, 5))\n            .once()\n            .andReturn(records.subList(4, records.size()))\n            .once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"0\", SHARD_ID0, \"0\"),\n        ImmutableSet.of()\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"4\", SHARD_ID0, \"0\")\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"9\", SHARD_ID0, \"1\")\n    );\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(1, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions)\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(8, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    assertEqualsExceptVersion(\n        ImmutableList.of(\n            sdd(\"2008/P1D\", 0, ImmutableList.of(\"a\")),\n            sdd(\"2009/P1D\", 0, ImmutableList.of(\"b\")),\n            sdd(\"2010/P1D\", 0, ImmutableList.of(\"c\")),\n            sdd(\"2011/P1D\", 0, ImmutableList.of(\"d\", \"e\"), ImmutableList.of(\"d\", \"h\")),\n            sdd(\"2011/P1D\", 1, ImmutableList.of(\"h\"), ImmutableList.of(\"e\")),\n            sdd(\"2012/P1D\", 0, ImmutableList.of(\"g\")),\n            sdd(\"2013/P1D\", 0, ImmutableList.of(\"f\"))\n        ),\n        publishedDescriptors()\n    );\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<>(\n                STREAM,\n                ImmutableMap.of(SHARD_ID1, \"9\", SHARD_ID0, \"1\")\n            )\n        ),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":520,"status":"M"},{"authorDate":"2019-11-21 06:51:25","commitOrder":10,"curCode":"  public void testIncrementalHandOffMaxTotalRows() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = Integer.MAX_VALUE;\n    maxTotalRows = 3L;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(0, 3))\n            .once()\n            .andReturn(records.subList(2, 10))\n            .once()\n            .andReturn(records.subList(9, 11));\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    \r\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"0\"),\n        ImmutableSet.of()\n    );\n    \r\n    \r\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"2\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint2 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"9\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"10\")\n    );\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            INPUT_FORMAT,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n\n    final Map<String, String> nextOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint2.getPartitionSequenceNumberMap(), nextOffsets);\n\n    task.getRunner().setEndOffsets(nextOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(2, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                NEW_DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions)\n            )\n        )\n    );\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                NEW_DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(\n                    new SeekableStreamStartSequenceNumbers<>(STREAM, currentOffsets, currentOffsets.keySet()))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(6, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    assertEqualsExceptVersion(\n        ImmutableList.of(\n            sdd(\"2008/P1D\", 0, ImmutableList.of(\"a\")),\n            sdd(\"2009/P1D\", 0, ImmutableList.of(\"b\")),\n            sdd(\"2010/P1D\", 0, ImmutableList.of(\"c\")),\n            sdd(\"2011/P1D\", 0, ImmutableList.of(\"d\", \"e\")),\n            sdd(\"2049/P1D\", 0, ImmutableList.of(\"f\")),\n            sdd(\"2013/P1D\", 0, ImmutableList.of(\"f\"))\n        ),\n        publishedDescriptors()\n    );\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"10\"))),\n        metadataStorageCoordinator.getDataSourceMetadata(NEW_DATA_SCHEMA.getDataSource())\n    );\n  }\n","date":"2019-11-21 06:51:25","endLine":764,"groupId":"351","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"testIncrementalHandOffMaxTotalRows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/a3/34a790bdbace996db1007835d408c9c203e38c.src","preCode":"  public void testIncrementalHandOffMaxTotalRows() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = Integer.MAX_VALUE;\n    maxTotalRows = 3L;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(0, 3))\n            .once()\n            .andReturn(records.subList(2, 10))\n            .once()\n            .andReturn(records.subList(9, 11));\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    \r\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"0\"),\n        ImmutableSet.of()\n    );\n    \r\n    \r\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"2\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint2 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"9\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"10\")\n    );\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n\n    final Map<String, String> nextOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint2.getPartitionSequenceNumberMap(), nextOffsets);\n\n    task.getRunner().setEndOffsets(nextOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(2, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions)\n            )\n        )\n    );\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(\n                    new SeekableStreamStartSequenceNumbers<>(STREAM, currentOffsets, currentOffsets.keySet()))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(6, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    assertEqualsExceptVersion(\n        ImmutableList.of(\n            sdd(\"2008/P1D\", 0, ImmutableList.of(\"a\")),\n            sdd(\"2009/P1D\", 0, ImmutableList.of(\"b\")),\n            sdd(\"2010/P1D\", 0, ImmutableList.of(\"c\")),\n            sdd(\"2011/P1D\", 0, ImmutableList.of(\"d\", \"e\")),\n            sdd(\"2049/P1D\", 0, ImmutableList.of(\"f\")),\n            sdd(\"2013/P1D\", 0, ImmutableList.of(\"f\"))\n        ),\n        publishedDescriptors()\n    );\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"10\"))),\n        metadataStorageCoordinator.getDataSourceMetadata(DATA_SCHEMA.getDataSource())\n    );\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":632,"status":"M"}],"commitId":"ac6d703814ccb5b258c586b63e0bc33d669e0f57","commitMessage":"@@@Support inputFormat and inputSource for sampler (#8901)\n\n* Support inputFormat and inputSource for sampler\n\n* Cleanup javadocs and names\n\n* fix style\n\n* fix timed shutoff input source reader\n\n* fix timed shutoff input source reader again\n\n* tidy up timed shutoff reader\n\n* unused imports\n\n* fix tc\n","date":"2019-11-21 06:51:25","modifiedFileCount":"66","status":"M","submitter":"Jihoon Son"},{"authorTime":"2020-01-28 03:24:29","codes":[{"authorDate":"2020-01-28 03:24:29","commitOrder":11,"curCode":"  public void testIncrementalHandOff() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = 2;\n    maxRecordsPerPoll = 1;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(0, 5))\n            .once()\n            .andReturn(records.subList(4, records.size()))\n            .once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"0\", SHARD_ID0, \"0\"),\n        ImmutableSet.of()\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"4\", SHARD_ID0, \"0\")\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"9\", SHARD_ID0, \"1\")\n    );\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            INPUT_FORMAT,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(1, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                NEW_DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions)\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(8, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    assertEqualsExceptVersion(\n        ImmutableList.of(\n            sdd(\"2008/P1D\", 0, ImmutableList.of(\"a\")),\n            sdd(\"2009/P1D\", 0, ImmutableList.of(\"b\")),\n            sdd(\"2010/P1D\", 0, ImmutableList.of(\"c\")),\n            sdd(\"2011/P1D\", 0, ImmutableList.of(\"d\", \"e\"), ImmutableList.of(\"d\", \"h\")),\n            sdd(\"2011/P1D\", 1, ImmutableList.of(\"h\"), ImmutableList.of(\"e\")),\n            sdd(\"2012/P1D\", 0, ImmutableList.of(\"g\")),\n            sdd(\"2013/P1D\", 0, ImmutableList.of(\"f\"))\n        ),\n        publishedDescriptors()\n    );\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<>(\n                STREAM,\n                ImmutableMap.of(SHARD_ID1, \"9\", SHARD_ID0, \"1\")\n            )\n        ),\n        newDataSchemaMetadata()\n    );\n  }\n","date":"2020-01-28 03:24:29","endLine":632,"groupId":"349","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"testIncrementalHandOff","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/78/67522a54ebcfbe41346f09fcd327a4d81923d3.src","preCode":"  public void testIncrementalHandOff() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = 2;\n    maxRecordsPerPoll = 1;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(0, 5))\n            .once()\n            .andReturn(records.subList(4, records.size()))\n            .once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"0\", SHARD_ID0, \"0\"),\n        ImmutableSet.of()\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"4\", SHARD_ID0, \"0\")\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"9\", SHARD_ID0, \"1\")\n    );\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            INPUT_FORMAT,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(1, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                NEW_DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions)\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(8, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    assertEqualsExceptVersion(\n        ImmutableList.of(\n            sdd(\"2008/P1D\", 0, ImmutableList.of(\"a\")),\n            sdd(\"2009/P1D\", 0, ImmutableList.of(\"b\")),\n            sdd(\"2010/P1D\", 0, ImmutableList.of(\"c\")),\n            sdd(\"2011/P1D\", 0, ImmutableList.of(\"d\", \"e\"), ImmutableList.of(\"d\", \"h\")),\n            sdd(\"2011/P1D\", 1, ImmutableList.of(\"h\"), ImmutableList.of(\"e\")),\n            sdd(\"2012/P1D\", 0, ImmutableList.of(\"g\")),\n            sdd(\"2013/P1D\", 0, ImmutableList.of(\"f\"))\n        ),\n        publishedDescriptors()\n    );\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<>(\n                STREAM,\n                ImmutableMap.of(SHARD_ID1, \"9\", SHARD_ID0, \"1\")\n            )\n        ),\n        metadataStorageCoordinator.getDataSourceMetadata(NEW_DATA_SCHEMA.getDataSource())\n    );\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":523,"status":"M"},{"authorDate":"2020-01-28 03:24:29","commitOrder":11,"curCode":"  public void testIncrementalHandOffMaxTotalRows() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = Integer.MAX_VALUE;\n    maxTotalRows = 3L;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(0, 3))\n            .once()\n            .andReturn(records.subList(2, 10))\n            .once()\n            .andReturn(records.subList(9, 11));\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    \r\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"0\"),\n        ImmutableSet.of()\n    );\n    \r\n    \r\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"2\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint2 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"9\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"10\")\n    );\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            INPUT_FORMAT,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n\n    final Map<String, String> nextOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint2.getPartitionSequenceNumberMap(), nextOffsets);\n\n    task.getRunner().setEndOffsets(nextOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(2, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                NEW_DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions)\n            )\n        )\n    );\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                NEW_DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(\n                    new SeekableStreamStartSequenceNumbers<>(STREAM, currentOffsets, currentOffsets.keySet()))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(6, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    assertEqualsExceptVersion(\n        ImmutableList.of(\n            sdd(\"2008/P1D\", 0, ImmutableList.of(\"a\")),\n            sdd(\"2009/P1D\", 0, ImmutableList.of(\"b\")),\n            sdd(\"2010/P1D\", 0, ImmutableList.of(\"c\")),\n            sdd(\"2011/P1D\", 0, ImmutableList.of(\"d\", \"e\")),\n            sdd(\"2049/P1D\", 0, ImmutableList.of(\"f\")),\n            sdd(\"2013/P1D\", 0, ImmutableList.of(\"f\"))\n        ),\n        publishedDescriptors()\n    );\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"10\"))),\n        newDataSchemaMetadata()\n    );\n  }\n","date":"2020-01-28 03:24:29","endLine":767,"groupId":"351","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"testIncrementalHandOffMaxTotalRows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/78/67522a54ebcfbe41346f09fcd327a4d81923d3.src","preCode":"  public void testIncrementalHandOffMaxTotalRows() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = Integer.MAX_VALUE;\n    maxTotalRows = 3L;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(0, 3))\n            .once()\n            .andReturn(records.subList(2, 10))\n            .once()\n            .andReturn(records.subList(9, 11));\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    \r\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"0\"),\n        ImmutableSet.of()\n    );\n    \r\n    \r\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"2\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint2 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"9\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"10\")\n    );\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            INPUT_FORMAT,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n\n    final Map<String, String> nextOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint2.getPartitionSequenceNumberMap(), nextOffsets);\n\n    task.getRunner().setEndOffsets(nextOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(2, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                NEW_DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions)\n            )\n        )\n    );\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                NEW_DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(\n                    new SeekableStreamStartSequenceNumbers<>(STREAM, currentOffsets, currentOffsets.keySet()))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(6, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    assertEqualsExceptVersion(\n        ImmutableList.of(\n            sdd(\"2008/P1D\", 0, ImmutableList.of(\"a\")),\n            sdd(\"2009/P1D\", 0, ImmutableList.of(\"b\")),\n            sdd(\"2010/P1D\", 0, ImmutableList.of(\"c\")),\n            sdd(\"2011/P1D\", 0, ImmutableList.of(\"d\", \"e\")),\n            sdd(\"2049/P1D\", 0, ImmutableList.of(\"f\")),\n            sdd(\"2013/P1D\", 0, ImmutableList.of(\"f\"))\n        ),\n        publishedDescriptors()\n    );\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"10\"))),\n        metadataStorageCoordinator.getDataSourceMetadata(NEW_DATA_SCHEMA.getDataSource())\n    );\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":635,"status":"M"}],"commitId":"b9186f8f9ff2ff52aceda42bc5f24ffd47a7d17e","commitMessage":"@@@Reconcile terminology and method naming to 'used/unused segments'; Rename MetadataSegmentManager to MetadataSegmentsManager (#7306)\n\n* Reconcile terminology and method naming to 'used/unused segments'; Don't use terms 'enable/disable data source'; Rename MetadataSegmentManager to MetadataSegments; Make REST API methods which mark segments as used/unused to return server error instead of an empty response in case of error\n\n* Fix brace\n\n* Import order\n\n* Rename withKillDataSourceWhitelist to withSpecificDataSourcesToKill\n\n* Fix tests\n\n* Fix tests by adding proper methods without interval parameters to IndexerMetadataStorageCoordinator instead of hacking with Intervals.ETERNITY\n\n* More aligned names of DruidCoordinatorHelpers.  rename several CoordinatorDynamicConfig parameters\n\n* Rename ClientCompactTaskQuery to ClientCompactionTaskQuery for consistency with CompactionTask; ClientCompactQueryTuningConfig to ClientCompactionTaskQueryTuningConfig\n\n* More variable and method renames\n\n* Rename MetadataSegments to SegmentsMetadata\n\n* Javadoc update\n\n* Simplify SegmentsMetadata.getUnusedSegmentIntervals().  more javadocs\n\n* Update Javadoc of VersionedIntervalTimeline.iterateAllObjects()\n\n* Reorder imports\n\n* Rename SegmentsMetadata.tryMark... methods to mark... and make them to return boolean and the numbers of segments changed and relay exceptions to callers\n\n* Complete merge\n\n* Add CollectionUtils.newTreeSet(); Refactor DruidCoordinatorRuntimeParams creation in tests\n\n* Remove MetadataSegmentManager\n\n* Rename millisLagSinceCoordinatorBecomesLeaderBeforeCanMarkAsUnusedOvershadowedSegments to leadingTimeMillisBeforeCanMarkAsUnusedOvershadowedSegments\n\n* Fix tests.  refactor DruidCluster creation in tests into DruidClusterBuilder\n\n* Fix inspections\n\n* Fix SQLMetadataSegmentManagerEmptyTest and rename it to SqlSegmentsMetadataEmptyTest\n\n* Rename SegmentsAndMetadata to SegmentsAndCommitMetadata to reduce the similarity with SegmentsMetadata; Rename some methods\n\n* Rename DruidCoordinatorHelper to CoordinatorDuty.  refactor DruidCoordinator\n\n* Unused import\n\n* Optimize imports\n\n* Rename IndexerSQLMetadataStorageCoordinator.getDataSourceMetadata() to retrieveDataSourceMetadata()\n\n* Unused import\n\n* Update terminology in datasource-view.tsx\n\n* Fix label in datasource-view.spec.tsx.snap\n\n* Fix lint errors in datasource-view.tsx\n\n* Doc improvements\n\n* Another attempt to please TSLint\n\n* Another attempt to please TSLint\n\n* Style fixes\n\n* Fix IndexerSQLMetadataStorageCoordinator.createUsedSegmentsSqlQueryForIntervals() (wrong merge)\n\n* Try to fix docs build issue\n\n* Javadoc and spelling fixes\n\n* Rename SegmentsMetadata to SegmentsMetadataManager.  address other comments\n\n* Address more comments\n","date":"2020-01-28 03:24:29","modifiedFileCount":"127","status":"M","submitter":"Roman Leventov"},{"authorTime":"2021-01-09 08:04:37","codes":[{"authorDate":"2021-01-09 08:04:37","commitOrder":12,"curCode":"  public void testIncrementalHandOff() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = 2;\n    maxRecordsPerPoll = 1;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(generateRecords(0, 5))\n            .once()\n            .andReturn(generateRecords(4))\n            .once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"0\", SHARD_ID0, \"0\"),\n        ImmutableSet.of()\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"4\", SHARD_ID0, \"0\")\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"9\", SHARD_ID0, \"1\")\n    );\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            INPUT_FORMAT,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(1, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                NEW_DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions)\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(8, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    assertEqualsExceptVersion(\n        ImmutableList.of(\n            sdd(\"2008/P1D\", 0, ImmutableList.of(\"a\")),\n            sdd(\"2009/P1D\", 0, ImmutableList.of(\"b\")),\n            sdd(\"2010/P1D\", 0, ImmutableList.of(\"c\")),\n            sdd(\"2011/P1D\", 0, ImmutableList.of(\"d\", \"e\"), ImmutableList.of(\"d\", \"h\")),\n            sdd(\"2011/P1D\", 1, ImmutableList.of(\"h\"), ImmutableList.of(\"e\")),\n            sdd(\"2012/P1D\", 0, ImmutableList.of(\"g\")),\n            sdd(\"2013/P1D\", 0, ImmutableList.of(\"f\"))\n        ),\n        publishedDescriptors()\n    );\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<>(\n                STREAM,\n                ImmutableMap.of(SHARD_ID1, \"9\", SHARD_ID0, \"1\")\n            )\n        ),\n        newDataSchemaMetadata()\n    );\n  }\n","date":"2021-01-09 08:04:37","endLine":644,"groupId":"102347","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"testIncrementalHandOff","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/37/d699a39eb40765e6e0d5b39c1e64d358746164.src","preCode":"  public void testIncrementalHandOff() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = 2;\n    maxRecordsPerPoll = 1;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(0, 5))\n            .once()\n            .andReturn(records.subList(4, records.size()))\n            .once();\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"0\", SHARD_ID0, \"0\"),\n        ImmutableSet.of()\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"4\", SHARD_ID0, \"0\")\n    );\n\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"9\", SHARD_ID0, \"1\")\n    );\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            INPUT_FORMAT,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(1, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                NEW_DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions)\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(8, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    assertEqualsExceptVersion(\n        ImmutableList.of(\n            sdd(\"2008/P1D\", 0, ImmutableList.of(\"a\")),\n            sdd(\"2009/P1D\", 0, ImmutableList.of(\"b\")),\n            sdd(\"2010/P1D\", 0, ImmutableList.of(\"c\")),\n            sdd(\"2011/P1D\", 0, ImmutableList.of(\"d\", \"e\"), ImmutableList.of(\"d\", \"h\")),\n            sdd(\"2011/P1D\", 1, ImmutableList.of(\"h\"), ImmutableList.of(\"e\")),\n            sdd(\"2012/P1D\", 0, ImmutableList.of(\"g\")),\n            sdd(\"2013/P1D\", 0, ImmutableList.of(\"f\"))\n        ),\n        publishedDescriptors()\n    );\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(\n            new SeekableStreamEndSequenceNumbers<>(\n                STREAM,\n                ImmutableMap.of(SHARD_ID1, \"9\", SHARD_ID0, \"1\")\n            )\n        ),\n        newDataSchemaMetadata()\n    );\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":535,"status":"M"},{"authorDate":"2021-01-09 08:04:37","commitOrder":12,"curCode":"  public void testIncrementalHandOffMaxTotalRows() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = Integer.MAX_VALUE;\n    maxTotalRows = 3L;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(generateRecords(0, 3))\n            .once()\n            .andReturn(generateRecords(2, 10))\n            .once()\n            .andReturn(generateRecords(9, 11));\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    \r\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"0\"),\n        ImmutableSet.of()\n    );\n    \r\n    \r\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"2\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint2 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"9\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"10\")\n    );\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            INPUT_FORMAT,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n\n    final Map<String, String> nextOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint2.getPartitionSequenceNumberMap(), nextOffsets);\n\n    task.getRunner().setEndOffsets(nextOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(2, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                NEW_DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions)\n            )\n        )\n    );\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                NEW_DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(\n                    new SeekableStreamStartSequenceNumbers<>(STREAM, currentOffsets, currentOffsets.keySet()))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(6, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    assertEqualsExceptVersion(\n        ImmutableList.of(\n            sdd(\"2008/P1D\", 0, ImmutableList.of(\"a\")),\n            sdd(\"2009/P1D\", 0, ImmutableList.of(\"b\")),\n            sdd(\"2010/P1D\", 0, ImmutableList.of(\"c\")),\n            sdd(\"2011/P1D\", 0, ImmutableList.of(\"d\", \"e\")),\n            sdd(\"2049/P1D\", 0, ImmutableList.of(\"f\")),\n            sdd(\"2013/P1D\", 0, ImmutableList.of(\"f\"))\n        ),\n        publishedDescriptors()\n    );\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"10\"))),\n        newDataSchemaMetadata()\n    );\n  }\n","date":"2021-01-09 08:04:37","endLine":779,"groupId":"102347","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"testIncrementalHandOffMaxTotalRows","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/37/d699a39eb40765e6e0d5b39c1e64d358746164.src","preCode":"  public void testIncrementalHandOffMaxTotalRows() throws Exception\n  {\n    final String baseSequenceName = \"sequence0\";\n    \r\n    maxRowsPerSegment = Integer.MAX_VALUE;\n    maxTotalRows = 3L;\n\n    recordSupplier.assign(EasyMock.anyObject());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.getEarliestSequenceNumber(EasyMock.anyObject())).andReturn(\"0\").anyTimes();\n\n    recordSupplier.seek(EasyMock.anyObject(), EasyMock.anyString());\n    EasyMock.expectLastCall().anyTimes();\n\n    EasyMock.expect(recordSupplier.poll(EasyMock.anyLong())).andReturn(records.subList(0, 3))\n            .once()\n            .andReturn(records.subList(2, 10))\n            .once()\n            .andReturn(records.subList(9, 11));\n\n    recordSupplier.close();\n    EasyMock.expectLastCall().once();\n\n    replayAll();\n\n    \r\n    final SeekableStreamStartSequenceNumbers<String, String> startPartitions = new SeekableStreamStartSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"0\"),\n        ImmutableSet.of()\n    );\n    \r\n    \r\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint1 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"2\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> checkpoint2 = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"9\")\n    );\n    final SeekableStreamEndSequenceNumbers<String, String> endPartitions = new SeekableStreamEndSequenceNumbers<>(\n        STREAM,\n        ImmutableMap.of(SHARD_ID1, \"10\")\n    );\n\n    final KinesisIndexTask task = createTask(\n        null,\n        new KinesisIndexTaskIOConfig(\n            0,\n            baseSequenceName,\n            startPartitions,\n            endPartitions,\n            true,\n            null,\n            null,\n            INPUT_FORMAT,\n            \"awsEndpoint\",\n            null,\n            null,\n            null,\n            null,\n            false\n        )\n    );\n\n    final ListenableFuture<TaskStatus> future = runTask(task);\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n    final Map<String, String> currentOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint1.getPartitionSequenceNumberMap(), currentOffsets);\n    task.getRunner().setEndOffsets(currentOffsets, false);\n\n    while (task.getRunner().getStatus() != SeekableStreamIndexTaskRunner.Status.PAUSED) {\n      Thread.sleep(10);\n    }\n\n    final Map<String, String> nextOffsets = ImmutableMap.copyOf(task.getRunner().getCurrentOffsets());\n\n    Assert.assertEquals(checkpoint2.getPartitionSequenceNumberMap(), nextOffsets);\n\n    task.getRunner().setEndOffsets(nextOffsets, false);\n\n    Assert.assertEquals(TaskState.SUCCESS, future.get().getStatusCode());\n\n    verifyAll();\n\n    Assert.assertEquals(2, checkpointRequestsHash.size());\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                NEW_DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(startPartitions)\n            )\n        )\n    );\n    Assert.assertTrue(\n        checkpointRequestsHash.contains(\n            Objects.hash(\n                NEW_DATA_SCHEMA.getDataSource(),\n                0,\n                new KinesisDataSourceMetadata(\n                    new SeekableStreamStartSequenceNumbers<>(STREAM, currentOffsets, currentOffsets.keySet()))\n            )\n        )\n    );\n\n    \r\n    Assert.assertEquals(6, task.getRunner().getRowIngestionMeters().getProcessed());\n    Assert.assertEquals(4, task.getRunner().getRowIngestionMeters().getUnparseable());\n    Assert.assertEquals(0, task.getRunner().getRowIngestionMeters().getThrownAway());\n\n    \r\n    assertEqualsExceptVersion(\n        ImmutableList.of(\n            sdd(\"2008/P1D\", 0, ImmutableList.of(\"a\")),\n            sdd(\"2009/P1D\", 0, ImmutableList.of(\"b\")),\n            sdd(\"2010/P1D\", 0, ImmutableList.of(\"c\")),\n            sdd(\"2011/P1D\", 0, ImmutableList.of(\"d\", \"e\")),\n            sdd(\"2049/P1D\", 0, ImmutableList.of(\"f\")),\n            sdd(\"2013/P1D\", 0, ImmutableList.of(\"f\"))\n        ),\n        publishedDescriptors()\n    );\n    Assert.assertEquals(\n        new KinesisDataSourceMetadata(new SeekableStreamEndSequenceNumbers<>(STREAM, ImmutableMap.of(SHARD_ID1, \"10\"))),\n        newDataSchemaMetadata()\n    );\n  }\n","realPath":"extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":647,"status":"M"}],"commitId":"118b50195e5c2989e04e0f5290aa72cae114db39","commitMessage":"@@@Introduce KafkaRecordEntity to support Kafka headers in InputFormats (#10730)\n\nToday Kafka message support in streaming indexing tasks is limited to\nmessage values.  and does not provide a way to expose Kafka headers. \ntimestamps.  or keys.  which may be of interest to more specialized\nDruid input formats. For instance.  Kafka headers may be used to indicate\npayload format/encoding or additional metadata.  and timestamps are often\nomitted from values in Kafka streams applications.  since they are\nincluded in the record.\n\nThis change proposes to introduce KafkaRecordEntity as InputEntity. \nwhich would give input formats full access to the underlying Kafka record. \nincluding headers.  key.  timestamps. It would also open access to low-level\ninformation such as topic.  partition.  offset if needed.\n\nKafkaEntity is a subclass of ByteEntity for backwards compatibility with\nexisting input formats.  and to avoid introducing unnecessary complexity\nfor Kinesis indexing tasks.","date":"2021-01-09 08:04:37","modifiedFileCount":"30","status":"M","submitter":"Xavier L?aut?"}]
