[{"authorTime":"2018-08-31 00:56:26","codes":[{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  public void testQueryCancellation() throws Exception\n  {\n    ExecutorService exec = PrioritizedExecutorService.create(\n        new Lifecycle(), new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return \"test\";\n          }\n\n          @Override\n          public int getNumThreads()\n          {\n            return 2;\n          }\n        }\n    );\n\n    final CountDownLatch queriesStarted = new CountDownLatch(2);\n    final CountDownLatch queriesInterrupted = new CountDownLatch(2);\n    final CountDownLatch queryIsRegistered = new CountDownLatch(1);\n\n    Capture<ListenableFuture> capturedFuture = EasyMock.newCapture();\n    QueryWatcher watcher = EasyMock.createStrictMock(QueryWatcher.class);\n    watcher.registerQuery(\n        EasyMock.anyObject(),\n        EasyMock.and(EasyMock.anyObject(), EasyMock.capture(capturedFuture))\n    );\n    EasyMock.expectLastCall()\n            .andAnswer(\n                new IAnswer<Void>()\n                {\n                  @Override\n                  public Void answer()\n                  {\n                    queryIsRegistered.countDown();\n                    return null;\n                  }\n                }\n            )\n            .once();\n\n    EasyMock.replay(watcher);\n\n    ArrayBlockingQueue<DyingQueryRunner> interrupted = new ArrayBlockingQueue<>(3);\n    Set<DyingQueryRunner> runners = Sets.newHashSet(\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted)\n    );\n\n    ChainedExecutionQueryRunner chainedRunner = new ChainedExecutionQueryRunner<>(\n        exec,\n        watcher,\n        Lists.newArrayList(\n         runners\n        )\n    );\n    Map<String, Object> context = ImmutableMap.of();\n    TimeseriesQuery query = Druids.newTimeseriesQueryBuilder()\n                                  .dataSource(\"test\")\n                                  .intervals(\"2014/2015\")\n                                  .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n                                  .build();\n    final Sequence seq = chainedRunner.run(QueryPlus.wrap(query), context);\n\n    Future resultFuture = Executors.newFixedThreadPool(1).submit(\n        new Runnable()\n        {\n          @Override\n          public void run()\n          {\n            seq.toList();\n          }\n        }\n    );\n\n    \r\n    queryIsRegistered.await();\n    queriesStarted.await();\n\n    \r\n    Assert.assertTrue(capturedFuture.hasCaptured());\n    ListenableFuture future = capturedFuture.getValue();\n    future.cancel(true);\n\n    QueryInterruptedException cause = null;\n    try {\n      resultFuture.get();\n    }\n    catch (ExecutionException e) {\n      Assert.assertTrue(e.getCause() instanceof QueryInterruptedException);\n      cause = (QueryInterruptedException) e.getCause();\n    }\n    queriesInterrupted.await();\n    Assert.assertNotNull(cause);\n    Assert.assertTrue(future.isCancelled());\n\n    DyingQueryRunner interrupted1 = interrupted.poll();\n    synchronized (interrupted1) {\n      Assert.assertTrue(\"runner 1 started\", interrupted1.hasStarted);\n      Assert.assertTrue(\"runner 1 interrupted\", interrupted1.interrupted);\n    }\n    DyingQueryRunner interrupted2 = interrupted.poll();\n    synchronized (interrupted2) {\n      Assert.assertTrue(\"runner 2 started\", interrupted2.hasStarted);\n      Assert.assertTrue(\"runner 2 interrupted\", interrupted2.interrupted);\n    }\n    runners.remove(interrupted1);\n    runners.remove(interrupted2);\n    DyingQueryRunner remainingRunner = runners.iterator().next();\n    synchronized (remainingRunner) {\n      Assert.assertTrue(\"runner 3 should be interrupted or not have started\",\n                        !remainingRunner.hasStarted || remainingRunner.interrupted);\n    }\n    Assert.assertFalse(\"runner 1 not completed\", interrupted1.hasCompleted);\n    Assert.assertFalse(\"runner 2 not completed\", interrupted2.hasCompleted);\n    Assert.assertFalse(\"runner 3 not completed\", remainingRunner.hasCompleted);\n\n    EasyMock.verify(watcher);\n  }\n","date":"2018-08-31 00:56:26","endLine":184,"groupId":"6825","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testQueryCancellation","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/97/c28909b3807624164ef3c65ad1db9f953af525.src","preCode":"  public void testQueryCancellation() throws Exception\n  {\n    ExecutorService exec = PrioritizedExecutorService.create(\n        new Lifecycle(), new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return \"test\";\n          }\n\n          @Override\n          public int getNumThreads()\n          {\n            return 2;\n          }\n        }\n    );\n\n    final CountDownLatch queriesStarted = new CountDownLatch(2);\n    final CountDownLatch queriesInterrupted = new CountDownLatch(2);\n    final CountDownLatch queryIsRegistered = new CountDownLatch(1);\n\n    Capture<ListenableFuture> capturedFuture = EasyMock.newCapture();\n    QueryWatcher watcher = EasyMock.createStrictMock(QueryWatcher.class);\n    watcher.registerQuery(\n        EasyMock.anyObject(),\n        EasyMock.and(EasyMock.anyObject(), EasyMock.capture(capturedFuture))\n    );\n    EasyMock.expectLastCall()\n            .andAnswer(\n                new IAnswer<Void>()\n                {\n                  @Override\n                  public Void answer()\n                  {\n                    queryIsRegistered.countDown();\n                    return null;\n                  }\n                }\n            )\n            .once();\n\n    EasyMock.replay(watcher);\n\n    ArrayBlockingQueue<DyingQueryRunner> interrupted = new ArrayBlockingQueue<>(3);\n    Set<DyingQueryRunner> runners = Sets.newHashSet(\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted)\n    );\n\n    ChainedExecutionQueryRunner chainedRunner = new ChainedExecutionQueryRunner<>(\n        exec,\n        watcher,\n        Lists.newArrayList(\n         runners\n        )\n    );\n    Map<String, Object> context = ImmutableMap.of();\n    TimeseriesQuery query = Druids.newTimeseriesQueryBuilder()\n                                  .dataSource(\"test\")\n                                  .intervals(\"2014/2015\")\n                                  .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n                                  .build();\n    final Sequence seq = chainedRunner.run(QueryPlus.wrap(query), context);\n\n    Future resultFuture = Executors.newFixedThreadPool(1).submit(\n        new Runnable()\n        {\n          @Override\n          public void run()\n          {\n            seq.toList();\n          }\n        }\n    );\n\n    \r\n    queryIsRegistered.await();\n    queriesStarted.await();\n\n    \r\n    Assert.assertTrue(capturedFuture.hasCaptured());\n    ListenableFuture future = capturedFuture.getValue();\n    future.cancel(true);\n\n    QueryInterruptedException cause = null;\n    try {\n      resultFuture.get();\n    }\n    catch (ExecutionException e) {\n      Assert.assertTrue(e.getCause() instanceof QueryInterruptedException);\n      cause = (QueryInterruptedException) e.getCause();\n    }\n    queriesInterrupted.await();\n    Assert.assertNotNull(cause);\n    Assert.assertTrue(future.isCancelled());\n\n    DyingQueryRunner interrupted1 = interrupted.poll();\n    synchronized (interrupted1) {\n      Assert.assertTrue(\"runner 1 started\", interrupted1.hasStarted);\n      Assert.assertTrue(\"runner 1 interrupted\", interrupted1.interrupted);\n    }\n    DyingQueryRunner interrupted2 = interrupted.poll();\n    synchronized (interrupted2) {\n      Assert.assertTrue(\"runner 2 started\", interrupted2.hasStarted);\n      Assert.assertTrue(\"runner 2 interrupted\", interrupted2.interrupted);\n    }\n    runners.remove(interrupted1);\n    runners.remove(interrupted2);\n    DyingQueryRunner remainingRunner = runners.iterator().next();\n    synchronized (remainingRunner) {\n      Assert.assertTrue(\"runner 3 should be interrupted or not have started\",\n                        !remainingRunner.hasStarted || remainingRunner.interrupted);\n    }\n    Assert.assertFalse(\"runner 1 not completed\", interrupted1.hasCompleted);\n    Assert.assertFalse(\"runner 2 not completed\", interrupted2.hasCompleted);\n    Assert.assertFalse(\"runner 3 not completed\", remainingRunner.hasCompleted);\n\n    EasyMock.verify(watcher);\n  }\n","realPath":"processing/src/test/java/org/apache/druid/query/ChainedExecutionQueryRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"B"},{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  public void testQueryTimeout() throws Exception\n  {\n    ExecutorService exec = PrioritizedExecutorService.create(\n        new Lifecycle(), new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return \"test\";\n          }\n\n          @Override\n          public int getNumThreads()\n          {\n            return 2;\n          }\n        }\n    );\n\n    final CountDownLatch queriesStarted = new CountDownLatch(2);\n    final CountDownLatch queriesInterrupted = new CountDownLatch(2);\n    final CountDownLatch queryIsRegistered = new CountDownLatch(1);\n\n    Capture<ListenableFuture> capturedFuture = new Capture<>();\n    QueryWatcher watcher = EasyMock.createStrictMock(QueryWatcher.class);\n    watcher.registerQuery(\n        EasyMock.anyObject(),\n        EasyMock.and(EasyMock.anyObject(), EasyMock.capture(capturedFuture))\n    );\n    EasyMock.expectLastCall()\n            .andAnswer(\n                new IAnswer<Void>()\n                {\n                  @Override\n                  public Void answer()\n                  {\n                    queryIsRegistered.countDown();\n                    return null;\n                  }\n                }\n            )\n            .once();\n\n    EasyMock.replay(watcher);\n\n\n    ArrayBlockingQueue<DyingQueryRunner> interrupted = new ArrayBlockingQueue<>(3);\n    Set<DyingQueryRunner> runners = Sets.newHashSet(\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted)\n    );\n\n    ChainedExecutionQueryRunner chainedRunner = new ChainedExecutionQueryRunner<>(\n        exec,\n        watcher,\n        Lists.newArrayList(\n            runners\n        )\n    );\n    HashMap<String, Object> context = new HashMap<String, Object>();\n    TimeseriesQuery query = Druids.newTimeseriesQueryBuilder()\n                                  .dataSource(\"test\")\n                                  .intervals(\"2014/2015\")\n                                  .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n                                  .context(ImmutableMap.of(QueryContexts.TIMEOUT_KEY, 100, \"queryId\", \"test\"))\n                                  .build();\n    final Sequence seq = chainedRunner.run(QueryPlus.wrap(query), context);\n\n    Future resultFuture = Executors.newFixedThreadPool(1).submit(\n        new Runnable()\n        {\n          @Override\n          public void run()\n          {\n            seq.toList();\n          }\n        }\n    );\n\n    \r\n    queryIsRegistered.await();\n    queriesStarted.await();\n\n    Assert.assertTrue(capturedFuture.hasCaptured());\n    ListenableFuture future = capturedFuture.getValue();\n\n    \r\n    QueryInterruptedException cause = null;\n    try {\n      resultFuture.get();\n    }\n    catch (ExecutionException e) {\n      Assert.assertTrue(e.getCause() instanceof QueryInterruptedException);\n      Assert.assertEquals(\"Query timeout\", ((QueryInterruptedException) e.getCause()).getErrorCode());\n      cause = (QueryInterruptedException) e.getCause();\n    }\n    queriesInterrupted.await();\n    Assert.assertNotNull(cause);\n    Assert.assertTrue(future.isCancelled());\n\n    DyingQueryRunner interrupted1 = interrupted.poll();\n    synchronized (interrupted1) {\n      Assert.assertTrue(\"runner 1 started\", interrupted1.hasStarted);\n      Assert.assertTrue(\"runner 1 interrupted\", interrupted1.interrupted);\n    }\n    DyingQueryRunner interrupted2 = interrupted.poll();\n    synchronized (interrupted2) {\n      Assert.assertTrue(\"runner 2 started\", interrupted2.hasStarted);\n      Assert.assertTrue(\"runner 2 interrupted\", interrupted2.interrupted);\n    }\n    runners.remove(interrupted1);\n    runners.remove(interrupted2);\n    DyingQueryRunner remainingRunner = runners.iterator().next();\n    synchronized (remainingRunner) {\n      Assert.assertTrue(\"runner 3 should be interrupted or not have started\",\n                        !remainingRunner.hasStarted || remainingRunner.interrupted);\n    }\n    Assert.assertFalse(\"runner 1 not completed\", interrupted1.hasCompleted);\n    Assert.assertFalse(\"runner 2 not completed\", interrupted2.hasCompleted);\n    Assert.assertFalse(\"runner 3 not completed\", remainingRunner.hasCompleted);\n\n    EasyMock.verify(watcher);\n  }\n","date":"2018-08-31 00:56:26","endLine":310,"groupId":"10681","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testQueryTimeout","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/97/c28909b3807624164ef3c65ad1db9f953af525.src","preCode":"  public void testQueryTimeout() throws Exception\n  {\n    ExecutorService exec = PrioritizedExecutorService.create(\n        new Lifecycle(), new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return \"test\";\n          }\n\n          @Override\n          public int getNumThreads()\n          {\n            return 2;\n          }\n        }\n    );\n\n    final CountDownLatch queriesStarted = new CountDownLatch(2);\n    final CountDownLatch queriesInterrupted = new CountDownLatch(2);\n    final CountDownLatch queryIsRegistered = new CountDownLatch(1);\n\n    Capture<ListenableFuture> capturedFuture = new Capture<>();\n    QueryWatcher watcher = EasyMock.createStrictMock(QueryWatcher.class);\n    watcher.registerQuery(\n        EasyMock.anyObject(),\n        EasyMock.and(EasyMock.anyObject(), EasyMock.capture(capturedFuture))\n    );\n    EasyMock.expectLastCall()\n            .andAnswer(\n                new IAnswer<Void>()\n                {\n                  @Override\n                  public Void answer()\n                  {\n                    queryIsRegistered.countDown();\n                    return null;\n                  }\n                }\n            )\n            .once();\n\n    EasyMock.replay(watcher);\n\n\n    ArrayBlockingQueue<DyingQueryRunner> interrupted = new ArrayBlockingQueue<>(3);\n    Set<DyingQueryRunner> runners = Sets.newHashSet(\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted)\n    );\n\n    ChainedExecutionQueryRunner chainedRunner = new ChainedExecutionQueryRunner<>(\n        exec,\n        watcher,\n        Lists.newArrayList(\n            runners\n        )\n    );\n    HashMap<String, Object> context = new HashMap<String, Object>();\n    TimeseriesQuery query = Druids.newTimeseriesQueryBuilder()\n                                  .dataSource(\"test\")\n                                  .intervals(\"2014/2015\")\n                                  .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n                                  .context(ImmutableMap.of(QueryContexts.TIMEOUT_KEY, 100, \"queryId\", \"test\"))\n                                  .build();\n    final Sequence seq = chainedRunner.run(QueryPlus.wrap(query), context);\n\n    Future resultFuture = Executors.newFixedThreadPool(1).submit(\n        new Runnable()\n        {\n          @Override\n          public void run()\n          {\n            seq.toList();\n          }\n        }\n    );\n\n    \r\n    queryIsRegistered.await();\n    queriesStarted.await();\n\n    Assert.assertTrue(capturedFuture.hasCaptured());\n    ListenableFuture future = capturedFuture.getValue();\n\n    \r\n    QueryInterruptedException cause = null;\n    try {\n      resultFuture.get();\n    }\n    catch (ExecutionException e) {\n      Assert.assertTrue(e.getCause() instanceof QueryInterruptedException);\n      Assert.assertEquals(\"Query timeout\", ((QueryInterruptedException) e.getCause()).getErrorCode());\n      cause = (QueryInterruptedException) e.getCause();\n    }\n    queriesInterrupted.await();\n    Assert.assertNotNull(cause);\n    Assert.assertTrue(future.isCancelled());\n\n    DyingQueryRunner interrupted1 = interrupted.poll();\n    synchronized (interrupted1) {\n      Assert.assertTrue(\"runner 1 started\", interrupted1.hasStarted);\n      Assert.assertTrue(\"runner 1 interrupted\", interrupted1.interrupted);\n    }\n    DyingQueryRunner interrupted2 = interrupted.poll();\n    synchronized (interrupted2) {\n      Assert.assertTrue(\"runner 2 started\", interrupted2.hasStarted);\n      Assert.assertTrue(\"runner 2 interrupted\", interrupted2.interrupted);\n    }\n    runners.remove(interrupted1);\n    runners.remove(interrupted2);\n    DyingQueryRunner remainingRunner = runners.iterator().next();\n    synchronized (remainingRunner) {\n      Assert.assertTrue(\"runner 3 should be interrupted or not have started\",\n                        !remainingRunner.hasStarted || remainingRunner.interrupted);\n    }\n    Assert.assertFalse(\"runner 1 not completed\", interrupted1.hasCompleted);\n    Assert.assertFalse(\"runner 2 not completed\", interrupted2.hasCompleted);\n    Assert.assertFalse(\"runner 3 not completed\", remainingRunner.hasCompleted);\n\n    EasyMock.verify(watcher);\n  }\n","realPath":"processing/src/test/java/org/apache/druid/query/ChainedExecutionQueryRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":187,"status":"B"}],"commitId":"431d3d8497f9079857c3baa7ae7ab4cb44a22355","commitMessage":"@@@Rename io.druid to org.apache.druid. (#6266)\n\n* Rename io.druid to org.apache.druid.\n\n* Fix META-INF files and remove some benchmark results.\n\n* MonitorsConfig update for metrics package migration.\n\n* Reorder some dimensions in inner queries for some reason.\n\n* Fix protobuf tests.\n","date":"2018-08-31 00:56:26","modifiedFileCount":"5","status":"B","submitter":"Gian Merlino"},{"authorTime":"2019-05-07 03:28:56","codes":[{"authorDate":"2018-08-31 00:56:26","commitOrder":2,"curCode":"  public void testQueryCancellation() throws Exception\n  {\n    ExecutorService exec = PrioritizedExecutorService.create(\n        new Lifecycle(), new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return \"test\";\n          }\n\n          @Override\n          public int getNumThreads()\n          {\n            return 2;\n          }\n        }\n    );\n\n    final CountDownLatch queriesStarted = new CountDownLatch(2);\n    final CountDownLatch queriesInterrupted = new CountDownLatch(2);\n    final CountDownLatch queryIsRegistered = new CountDownLatch(1);\n\n    Capture<ListenableFuture> capturedFuture = EasyMock.newCapture();\n    QueryWatcher watcher = EasyMock.createStrictMock(QueryWatcher.class);\n    watcher.registerQuery(\n        EasyMock.anyObject(),\n        EasyMock.and(EasyMock.anyObject(), EasyMock.capture(capturedFuture))\n    );\n    EasyMock.expectLastCall()\n            .andAnswer(\n                new IAnswer<Void>()\n                {\n                  @Override\n                  public Void answer()\n                  {\n                    queryIsRegistered.countDown();\n                    return null;\n                  }\n                }\n            )\n            .once();\n\n    EasyMock.replay(watcher);\n\n    ArrayBlockingQueue<DyingQueryRunner> interrupted = new ArrayBlockingQueue<>(3);\n    Set<DyingQueryRunner> runners = Sets.newHashSet(\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted)\n    );\n\n    ChainedExecutionQueryRunner chainedRunner = new ChainedExecutionQueryRunner<>(\n        exec,\n        watcher,\n        Lists.newArrayList(\n         runners\n        )\n    );\n    Map<String, Object> context = ImmutableMap.of();\n    TimeseriesQuery query = Druids.newTimeseriesQueryBuilder()\n                                  .dataSource(\"test\")\n                                  .intervals(\"2014/2015\")\n                                  .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n                                  .build();\n    final Sequence seq = chainedRunner.run(QueryPlus.wrap(query), context);\n\n    Future resultFuture = Executors.newFixedThreadPool(1).submit(\n        new Runnable()\n        {\n          @Override\n          public void run()\n          {\n            seq.toList();\n          }\n        }\n    );\n\n    \r\n    queryIsRegistered.await();\n    queriesStarted.await();\n\n    \r\n    Assert.assertTrue(capturedFuture.hasCaptured());\n    ListenableFuture future = capturedFuture.getValue();\n    future.cancel(true);\n\n    QueryInterruptedException cause = null;\n    try {\n      resultFuture.get();\n    }\n    catch (ExecutionException e) {\n      Assert.assertTrue(e.getCause() instanceof QueryInterruptedException);\n      cause = (QueryInterruptedException) e.getCause();\n    }\n    queriesInterrupted.await();\n    Assert.assertNotNull(cause);\n    Assert.assertTrue(future.isCancelled());\n\n    DyingQueryRunner interrupted1 = interrupted.poll();\n    synchronized (interrupted1) {\n      Assert.assertTrue(\"runner 1 started\", interrupted1.hasStarted);\n      Assert.assertTrue(\"runner 1 interrupted\", interrupted1.interrupted);\n    }\n    DyingQueryRunner interrupted2 = interrupted.poll();\n    synchronized (interrupted2) {\n      Assert.assertTrue(\"runner 2 started\", interrupted2.hasStarted);\n      Assert.assertTrue(\"runner 2 interrupted\", interrupted2.interrupted);\n    }\n    runners.remove(interrupted1);\n    runners.remove(interrupted2);\n    DyingQueryRunner remainingRunner = runners.iterator().next();\n    synchronized (remainingRunner) {\n      Assert.assertTrue(\"runner 3 should be interrupted or not have started\",\n                        !remainingRunner.hasStarted || remainingRunner.interrupted);\n    }\n    Assert.assertFalse(\"runner 1 not completed\", interrupted1.hasCompleted);\n    Assert.assertFalse(\"runner 2 not completed\", interrupted2.hasCompleted);\n    Assert.assertFalse(\"runner 3 not completed\", remainingRunner.hasCompleted);\n\n    EasyMock.verify(watcher);\n  }\n","date":"2018-08-31 00:56:26","endLine":184,"groupId":"6825","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testQueryCancellation","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/97/c28909b3807624164ef3c65ad1db9f953af525.src","preCode":"  public void testQueryCancellation() throws Exception\n  {\n    ExecutorService exec = PrioritizedExecutorService.create(\n        new Lifecycle(), new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return \"test\";\n          }\n\n          @Override\n          public int getNumThreads()\n          {\n            return 2;\n          }\n        }\n    );\n\n    final CountDownLatch queriesStarted = new CountDownLatch(2);\n    final CountDownLatch queriesInterrupted = new CountDownLatch(2);\n    final CountDownLatch queryIsRegistered = new CountDownLatch(1);\n\n    Capture<ListenableFuture> capturedFuture = EasyMock.newCapture();\n    QueryWatcher watcher = EasyMock.createStrictMock(QueryWatcher.class);\n    watcher.registerQuery(\n        EasyMock.anyObject(),\n        EasyMock.and(EasyMock.anyObject(), EasyMock.capture(capturedFuture))\n    );\n    EasyMock.expectLastCall()\n            .andAnswer(\n                new IAnswer<Void>()\n                {\n                  @Override\n                  public Void answer()\n                  {\n                    queryIsRegistered.countDown();\n                    return null;\n                  }\n                }\n            )\n            .once();\n\n    EasyMock.replay(watcher);\n\n    ArrayBlockingQueue<DyingQueryRunner> interrupted = new ArrayBlockingQueue<>(3);\n    Set<DyingQueryRunner> runners = Sets.newHashSet(\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted)\n    );\n\n    ChainedExecutionQueryRunner chainedRunner = new ChainedExecutionQueryRunner<>(\n        exec,\n        watcher,\n        Lists.newArrayList(\n         runners\n        )\n    );\n    Map<String, Object> context = ImmutableMap.of();\n    TimeseriesQuery query = Druids.newTimeseriesQueryBuilder()\n                                  .dataSource(\"test\")\n                                  .intervals(\"2014/2015\")\n                                  .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n                                  .build();\n    final Sequence seq = chainedRunner.run(QueryPlus.wrap(query), context);\n\n    Future resultFuture = Executors.newFixedThreadPool(1).submit(\n        new Runnable()\n        {\n          @Override\n          public void run()\n          {\n            seq.toList();\n          }\n        }\n    );\n\n    \r\n    queryIsRegistered.await();\n    queriesStarted.await();\n\n    \r\n    Assert.assertTrue(capturedFuture.hasCaptured());\n    ListenableFuture future = capturedFuture.getValue();\n    future.cancel(true);\n\n    QueryInterruptedException cause = null;\n    try {\n      resultFuture.get();\n    }\n    catch (ExecutionException e) {\n      Assert.assertTrue(e.getCause() instanceof QueryInterruptedException);\n      cause = (QueryInterruptedException) e.getCause();\n    }\n    queriesInterrupted.await();\n    Assert.assertNotNull(cause);\n    Assert.assertTrue(future.isCancelled());\n\n    DyingQueryRunner interrupted1 = interrupted.poll();\n    synchronized (interrupted1) {\n      Assert.assertTrue(\"runner 1 started\", interrupted1.hasStarted);\n      Assert.assertTrue(\"runner 1 interrupted\", interrupted1.interrupted);\n    }\n    DyingQueryRunner interrupted2 = interrupted.poll();\n    synchronized (interrupted2) {\n      Assert.assertTrue(\"runner 2 started\", interrupted2.hasStarted);\n      Assert.assertTrue(\"runner 2 interrupted\", interrupted2.interrupted);\n    }\n    runners.remove(interrupted1);\n    runners.remove(interrupted2);\n    DyingQueryRunner remainingRunner = runners.iterator().next();\n    synchronized (remainingRunner) {\n      Assert.assertTrue(\"runner 3 should be interrupted or not have started\",\n                        !remainingRunner.hasStarted || remainingRunner.interrupted);\n    }\n    Assert.assertFalse(\"runner 1 not completed\", interrupted1.hasCompleted);\n    Assert.assertFalse(\"runner 2 not completed\", interrupted2.hasCompleted);\n    Assert.assertFalse(\"runner 3 not completed\", remainingRunner.hasCompleted);\n\n    EasyMock.verify(watcher);\n  }\n","realPath":"processing/src/test/java/org/apache/druid/query/ChainedExecutionQueryRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"N"},{"authorDate":"2019-05-07 03:28:56","commitOrder":2,"curCode":"  public void testQueryTimeout() throws Exception\n  {\n    ExecutorService exec = PrioritizedExecutorService.create(\n        new Lifecycle(), new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return \"test\";\n          }\n\n          @Override\n          public int getNumThreads()\n          {\n            return 2;\n          }\n        }\n    );\n\n    final CountDownLatch queriesStarted = new CountDownLatch(2);\n    final CountDownLatch queriesInterrupted = new CountDownLatch(2);\n    final CountDownLatch queryIsRegistered = new CountDownLatch(1);\n\n    Capture<ListenableFuture> capturedFuture = Capture.newInstance();\n    QueryWatcher watcher = EasyMock.createStrictMock(QueryWatcher.class);\n    watcher.registerQuery(\n        EasyMock.anyObject(),\n        EasyMock.and(EasyMock.anyObject(), EasyMock.capture(capturedFuture))\n    );\n    EasyMock.expectLastCall()\n            .andAnswer(\n                new IAnswer<Void>()\n                {\n                  @Override\n                  public Void answer()\n                  {\n                    queryIsRegistered.countDown();\n                    return null;\n                  }\n                }\n            )\n            .once();\n\n    EasyMock.replay(watcher);\n\n\n    ArrayBlockingQueue<DyingQueryRunner> interrupted = new ArrayBlockingQueue<>(3);\n    Set<DyingQueryRunner> runners = Sets.newHashSet(\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted)\n    );\n\n    ChainedExecutionQueryRunner chainedRunner = new ChainedExecutionQueryRunner<>(\n        exec,\n        watcher,\n        Lists.newArrayList(\n            runners\n        )\n    );\n    HashMap<String, Object> context = new HashMap<String, Object>();\n    TimeseriesQuery query = Druids.newTimeseriesQueryBuilder()\n                                  .dataSource(\"test\")\n                                  .intervals(\"2014/2015\")\n                                  .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n                                  .context(ImmutableMap.of(QueryContexts.TIMEOUT_KEY, 100, \"queryId\", \"test\"))\n                                  .build();\n    final Sequence seq = chainedRunner.run(QueryPlus.wrap(query), context);\n\n    Future resultFuture = Executors.newFixedThreadPool(1).submit(\n        new Runnable()\n        {\n          @Override\n          public void run()\n          {\n            seq.toList();\n          }\n        }\n    );\n\n    \r\n    queryIsRegistered.await();\n    queriesStarted.await();\n\n    Assert.assertTrue(capturedFuture.hasCaptured());\n    ListenableFuture future = capturedFuture.getValue();\n\n    \r\n    QueryInterruptedException cause = null;\n    try {\n      resultFuture.get();\n    }\n    catch (ExecutionException e) {\n      Assert.assertTrue(e.getCause() instanceof QueryInterruptedException);\n      Assert.assertEquals(\"Query timeout\", ((QueryInterruptedException) e.getCause()).getErrorCode());\n      cause = (QueryInterruptedException) e.getCause();\n    }\n    queriesInterrupted.await();\n    Assert.assertNotNull(cause);\n    Assert.assertTrue(future.isCancelled());\n\n    DyingQueryRunner interrupted1 = interrupted.poll();\n    synchronized (interrupted1) {\n      Assert.assertTrue(\"runner 1 started\", interrupted1.hasStarted);\n      Assert.assertTrue(\"runner 1 interrupted\", interrupted1.interrupted);\n    }\n    DyingQueryRunner interrupted2 = interrupted.poll();\n    synchronized (interrupted2) {\n      Assert.assertTrue(\"runner 2 started\", interrupted2.hasStarted);\n      Assert.assertTrue(\"runner 2 interrupted\", interrupted2.interrupted);\n    }\n    runners.remove(interrupted1);\n    runners.remove(interrupted2);\n    DyingQueryRunner remainingRunner = runners.iterator().next();\n    synchronized (remainingRunner) {\n      Assert.assertTrue(\"runner 3 should be interrupted or not have started\",\n                        !remainingRunner.hasStarted || remainingRunner.interrupted);\n    }\n    Assert.assertFalse(\"runner 1 not completed\", interrupted1.hasCompleted);\n    Assert.assertFalse(\"runner 2 not completed\", interrupted2.hasCompleted);\n    Assert.assertFalse(\"runner 3 not completed\", remainingRunner.hasCompleted);\n\n    EasyMock.verify(watcher);\n  }\n","date":"2019-05-07 03:28:56","endLine":310,"groupId":"10681","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testQueryTimeout","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/b3/70e4cd0fc566bc671f223594216a3263c9952c.src","preCode":"  public void testQueryTimeout() throws Exception\n  {\n    ExecutorService exec = PrioritizedExecutorService.create(\n        new Lifecycle(), new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return \"test\";\n          }\n\n          @Override\n          public int getNumThreads()\n          {\n            return 2;\n          }\n        }\n    );\n\n    final CountDownLatch queriesStarted = new CountDownLatch(2);\n    final CountDownLatch queriesInterrupted = new CountDownLatch(2);\n    final CountDownLatch queryIsRegistered = new CountDownLatch(1);\n\n    Capture<ListenableFuture> capturedFuture = new Capture<>();\n    QueryWatcher watcher = EasyMock.createStrictMock(QueryWatcher.class);\n    watcher.registerQuery(\n        EasyMock.anyObject(),\n        EasyMock.and(EasyMock.anyObject(), EasyMock.capture(capturedFuture))\n    );\n    EasyMock.expectLastCall()\n            .andAnswer(\n                new IAnswer<Void>()\n                {\n                  @Override\n                  public Void answer()\n                  {\n                    queryIsRegistered.countDown();\n                    return null;\n                  }\n                }\n            )\n            .once();\n\n    EasyMock.replay(watcher);\n\n\n    ArrayBlockingQueue<DyingQueryRunner> interrupted = new ArrayBlockingQueue<>(3);\n    Set<DyingQueryRunner> runners = Sets.newHashSet(\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted)\n    );\n\n    ChainedExecutionQueryRunner chainedRunner = new ChainedExecutionQueryRunner<>(\n        exec,\n        watcher,\n        Lists.newArrayList(\n            runners\n        )\n    );\n    HashMap<String, Object> context = new HashMap<String, Object>();\n    TimeseriesQuery query = Druids.newTimeseriesQueryBuilder()\n                                  .dataSource(\"test\")\n                                  .intervals(\"2014/2015\")\n                                  .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n                                  .context(ImmutableMap.of(QueryContexts.TIMEOUT_KEY, 100, \"queryId\", \"test\"))\n                                  .build();\n    final Sequence seq = chainedRunner.run(QueryPlus.wrap(query), context);\n\n    Future resultFuture = Executors.newFixedThreadPool(1).submit(\n        new Runnable()\n        {\n          @Override\n          public void run()\n          {\n            seq.toList();\n          }\n        }\n    );\n\n    \r\n    queryIsRegistered.await();\n    queriesStarted.await();\n\n    Assert.assertTrue(capturedFuture.hasCaptured());\n    ListenableFuture future = capturedFuture.getValue();\n\n    \r\n    QueryInterruptedException cause = null;\n    try {\n      resultFuture.get();\n    }\n    catch (ExecutionException e) {\n      Assert.assertTrue(e.getCause() instanceof QueryInterruptedException);\n      Assert.assertEquals(\"Query timeout\", ((QueryInterruptedException) e.getCause()).getErrorCode());\n      cause = (QueryInterruptedException) e.getCause();\n    }\n    queriesInterrupted.await();\n    Assert.assertNotNull(cause);\n    Assert.assertTrue(future.isCancelled());\n\n    DyingQueryRunner interrupted1 = interrupted.poll();\n    synchronized (interrupted1) {\n      Assert.assertTrue(\"runner 1 started\", interrupted1.hasStarted);\n      Assert.assertTrue(\"runner 1 interrupted\", interrupted1.interrupted);\n    }\n    DyingQueryRunner interrupted2 = interrupted.poll();\n    synchronized (interrupted2) {\n      Assert.assertTrue(\"runner 2 started\", interrupted2.hasStarted);\n      Assert.assertTrue(\"runner 2 interrupted\", interrupted2.interrupted);\n    }\n    runners.remove(interrupted1);\n    runners.remove(interrupted2);\n    DyingQueryRunner remainingRunner = runners.iterator().next();\n    synchronized (remainingRunner) {\n      Assert.assertTrue(\"runner 3 should be interrupted or not have started\",\n                        !remainingRunner.hasStarted || remainingRunner.interrupted);\n    }\n    Assert.assertFalse(\"runner 1 not completed\", interrupted1.hasCompleted);\n    Assert.assertFalse(\"runner 2 not completed\", interrupted2.hasCompleted);\n    Assert.assertFalse(\"runner 3 not completed\", remainingRunner.hasCompleted);\n\n    EasyMock.verify(watcher);\n  }\n","realPath":"processing/src/test/java/org/apache/druid/query/ChainedExecutionQueryRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":187,"status":"M"}],"commitId":"f7bfe8f2697277f4216d90607d01bfd26e813ab3","commitMessage":"@@@Update mocking libraries for Java 11 support (#7596)\n\n* update easymock / powermock for to 4.0.2 / 2.0.2 for JDK11 support\n* update tests to use new easymock interfaces\n* fix tests failing due to easymock fixes\n* remove dependency on jmockit\n* fix race condition in ResourcePoolTest","date":"2019-05-07 03:28:56","modifiedFileCount":"7","status":"M","submitter":"Xavier L?aut?"},{"authorTime":"2019-07-24 23:29:03","codes":[{"authorDate":"2019-07-24 23:29:03","commitOrder":3,"curCode":"  public void testQueryCancellation() throws Exception\n  {\n    ExecutorService exec = PrioritizedExecutorService.create(\n        new Lifecycle(), new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return \"test\";\n          }\n\n          @Override\n          public int getNumThreads()\n          {\n            return 2;\n          }\n        }\n    );\n\n    final CountDownLatch queriesStarted = new CountDownLatch(2);\n    final CountDownLatch queriesInterrupted = new CountDownLatch(2);\n    final CountDownLatch queryIsRegistered = new CountDownLatch(1);\n\n    Capture<ListenableFuture> capturedFuture = EasyMock.newCapture();\n    QueryWatcher watcher = EasyMock.createStrictMock(QueryWatcher.class);\n    watcher.registerQuery(\n        EasyMock.anyObject(),\n        EasyMock.and(EasyMock.anyObject(), EasyMock.capture(capturedFuture))\n    );\n    EasyMock.expectLastCall()\n            .andAnswer(\n                new IAnswer<Void>()\n                {\n                  @Override\n                  public Void answer()\n                  {\n                    queryIsRegistered.countDown();\n                    return null;\n                  }\n                }\n            )\n            .once();\n\n    EasyMock.replay(watcher);\n\n    ArrayBlockingQueue<DyingQueryRunner> interrupted = new ArrayBlockingQueue<>(3);\n    Set<DyingQueryRunner> runners = Sets.newHashSet(\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted)\n    );\n\n    ChainedExecutionQueryRunner chainedRunner = new ChainedExecutionQueryRunner<>(\n        exec,\n        watcher,\n        Lists.newArrayList(\n         runners\n        )\n    );\n    TimeseriesQuery query = Druids.newTimeseriesQueryBuilder()\n                                  .dataSource(\"test\")\n                                  .intervals(\"2014/2015\")\n                                  .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n                                  .build();\n    final Sequence seq = chainedRunner.run(QueryPlus.wrap(query));\n\n    Future resultFuture = Executors.newFixedThreadPool(1).submit(\n        new Runnable()\n        {\n          @Override\n          public void run()\n          {\n            seq.toList();\n          }\n        }\n    );\n\n    \r\n    queryIsRegistered.await();\n    queriesStarted.await();\n\n    \r\n    Assert.assertTrue(capturedFuture.hasCaptured());\n    ListenableFuture future = capturedFuture.getValue();\n    future.cancel(true);\n\n    QueryInterruptedException cause = null;\n    try {\n      resultFuture.get();\n    }\n    catch (ExecutionException e) {\n      Assert.assertTrue(e.getCause() instanceof QueryInterruptedException);\n      cause = (QueryInterruptedException) e.getCause();\n    }\n    queriesInterrupted.await();\n    Assert.assertNotNull(cause);\n    Assert.assertTrue(future.isCancelled());\n\n    DyingQueryRunner interrupted1 = interrupted.poll();\n    synchronized (interrupted1) {\n      Assert.assertTrue(\"runner 1 started\", interrupted1.hasStarted);\n      Assert.assertTrue(\"runner 1 interrupted\", interrupted1.interrupted);\n    }\n    DyingQueryRunner interrupted2 = interrupted.poll();\n    synchronized (interrupted2) {\n      Assert.assertTrue(\"runner 2 started\", interrupted2.hasStarted);\n      Assert.assertTrue(\"runner 2 interrupted\", interrupted2.interrupted);\n    }\n    runners.remove(interrupted1);\n    runners.remove(interrupted2);\n    DyingQueryRunner remainingRunner = runners.iterator().next();\n    synchronized (remainingRunner) {\n      Assert.assertTrue(\"runner 3 should be interrupted or not have started\",\n                        !remainingRunner.hasStarted || remainingRunner.interrupted);\n    }\n    Assert.assertFalse(\"runner 1 not completed\", interrupted1.hasCompleted);\n    Assert.assertFalse(\"runner 2 not completed\", interrupted2.hasCompleted);\n    Assert.assertFalse(\"runner 3 not completed\", remainingRunner.hasCompleted);\n\n    EasyMock.verify(watcher);\n  }\n","date":"2019-07-24 23:29:03","endLine":182,"groupId":"6825","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testQueryCancellation","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/27/5fb637f7226ac63435dd88cbf349f655eb213c.src","preCode":"  public void testQueryCancellation() throws Exception\n  {\n    ExecutorService exec = PrioritizedExecutorService.create(\n        new Lifecycle(), new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return \"test\";\n          }\n\n          @Override\n          public int getNumThreads()\n          {\n            return 2;\n          }\n        }\n    );\n\n    final CountDownLatch queriesStarted = new CountDownLatch(2);\n    final CountDownLatch queriesInterrupted = new CountDownLatch(2);\n    final CountDownLatch queryIsRegistered = new CountDownLatch(1);\n\n    Capture<ListenableFuture> capturedFuture = EasyMock.newCapture();\n    QueryWatcher watcher = EasyMock.createStrictMock(QueryWatcher.class);\n    watcher.registerQuery(\n        EasyMock.anyObject(),\n        EasyMock.and(EasyMock.anyObject(), EasyMock.capture(capturedFuture))\n    );\n    EasyMock.expectLastCall()\n            .andAnswer(\n                new IAnswer<Void>()\n                {\n                  @Override\n                  public Void answer()\n                  {\n                    queryIsRegistered.countDown();\n                    return null;\n                  }\n                }\n            )\n            .once();\n\n    EasyMock.replay(watcher);\n\n    ArrayBlockingQueue<DyingQueryRunner> interrupted = new ArrayBlockingQueue<>(3);\n    Set<DyingQueryRunner> runners = Sets.newHashSet(\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted)\n    );\n\n    ChainedExecutionQueryRunner chainedRunner = new ChainedExecutionQueryRunner<>(\n        exec,\n        watcher,\n        Lists.newArrayList(\n         runners\n        )\n    );\n    Map<String, Object> context = ImmutableMap.of();\n    TimeseriesQuery query = Druids.newTimeseriesQueryBuilder()\n                                  .dataSource(\"test\")\n                                  .intervals(\"2014/2015\")\n                                  .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n                                  .build();\n    final Sequence seq = chainedRunner.run(QueryPlus.wrap(query), context);\n\n    Future resultFuture = Executors.newFixedThreadPool(1).submit(\n        new Runnable()\n        {\n          @Override\n          public void run()\n          {\n            seq.toList();\n          }\n        }\n    );\n\n    \r\n    queryIsRegistered.await();\n    queriesStarted.await();\n\n    \r\n    Assert.assertTrue(capturedFuture.hasCaptured());\n    ListenableFuture future = capturedFuture.getValue();\n    future.cancel(true);\n\n    QueryInterruptedException cause = null;\n    try {\n      resultFuture.get();\n    }\n    catch (ExecutionException e) {\n      Assert.assertTrue(e.getCause() instanceof QueryInterruptedException);\n      cause = (QueryInterruptedException) e.getCause();\n    }\n    queriesInterrupted.await();\n    Assert.assertNotNull(cause);\n    Assert.assertTrue(future.isCancelled());\n\n    DyingQueryRunner interrupted1 = interrupted.poll();\n    synchronized (interrupted1) {\n      Assert.assertTrue(\"runner 1 started\", interrupted1.hasStarted);\n      Assert.assertTrue(\"runner 1 interrupted\", interrupted1.interrupted);\n    }\n    DyingQueryRunner interrupted2 = interrupted.poll();\n    synchronized (interrupted2) {\n      Assert.assertTrue(\"runner 2 started\", interrupted2.hasStarted);\n      Assert.assertTrue(\"runner 2 interrupted\", interrupted2.interrupted);\n    }\n    runners.remove(interrupted1);\n    runners.remove(interrupted2);\n    DyingQueryRunner remainingRunner = runners.iterator().next();\n    synchronized (remainingRunner) {\n      Assert.assertTrue(\"runner 3 should be interrupted or not have started\",\n                        !remainingRunner.hasStarted || remainingRunner.interrupted);\n    }\n    Assert.assertFalse(\"runner 1 not completed\", interrupted1.hasCompleted);\n    Assert.assertFalse(\"runner 2 not completed\", interrupted2.hasCompleted);\n    Assert.assertFalse(\"runner 3 not completed\", remainingRunner.hasCompleted);\n\n    EasyMock.verify(watcher);\n  }\n","realPath":"processing/src/test/java/org/apache/druid/query/ChainedExecutionQueryRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":62,"status":"M"},{"authorDate":"2019-07-24 23:29:03","commitOrder":3,"curCode":"  public void testQueryTimeout() throws Exception\n  {\n    ExecutorService exec = PrioritizedExecutorService.create(\n        new Lifecycle(), new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return \"test\";\n          }\n\n          @Override\n          public int getNumThreads()\n          {\n            return 2;\n          }\n        }\n    );\n\n    final CountDownLatch queriesStarted = new CountDownLatch(2);\n    final CountDownLatch queriesInterrupted = new CountDownLatch(2);\n    final CountDownLatch queryIsRegistered = new CountDownLatch(1);\n\n    Capture<ListenableFuture> capturedFuture = Capture.newInstance();\n    QueryWatcher watcher = EasyMock.createStrictMock(QueryWatcher.class);\n    watcher.registerQuery(\n        EasyMock.anyObject(),\n        EasyMock.and(EasyMock.anyObject(), EasyMock.capture(capturedFuture))\n    );\n    EasyMock.expectLastCall()\n            .andAnswer(\n                new IAnswer<Void>()\n                {\n                  @Override\n                  public Void answer()\n                  {\n                    queryIsRegistered.countDown();\n                    return null;\n                  }\n                }\n            )\n            .once();\n\n    EasyMock.replay(watcher);\n\n\n    ArrayBlockingQueue<DyingQueryRunner> interrupted = new ArrayBlockingQueue<>(3);\n    Set<DyingQueryRunner> runners = Sets.newHashSet(\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted)\n    );\n\n    ChainedExecutionQueryRunner chainedRunner = new ChainedExecutionQueryRunner<>(\n        exec,\n        watcher,\n        Lists.newArrayList(\n            runners\n        )\n    );\n    TimeseriesQuery query = Druids.newTimeseriesQueryBuilder()\n                                  .dataSource(\"test\")\n                                  .intervals(\"2014/2015\")\n                                  .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n                                  .context(ImmutableMap.of(QueryContexts.TIMEOUT_KEY, 100, \"queryId\", \"test\"))\n                                  .build();\n    final Sequence seq = chainedRunner.run(QueryPlus.wrap(query));\n\n    Future resultFuture = Executors.newFixedThreadPool(1).submit(\n        new Runnable()\n        {\n          @Override\n          public void run()\n          {\n            seq.toList();\n          }\n        }\n    );\n\n    \r\n    queryIsRegistered.await();\n    queriesStarted.await();\n\n    Assert.assertTrue(capturedFuture.hasCaptured());\n    ListenableFuture future = capturedFuture.getValue();\n\n    \r\n    QueryInterruptedException cause = null;\n    try {\n      resultFuture.get();\n    }\n    catch (ExecutionException e) {\n      Assert.assertTrue(e.getCause() instanceof QueryInterruptedException);\n      Assert.assertEquals(\"Query timeout\", ((QueryInterruptedException) e.getCause()).getErrorCode());\n      cause = (QueryInterruptedException) e.getCause();\n    }\n    queriesInterrupted.await();\n    Assert.assertNotNull(cause);\n    Assert.assertTrue(future.isCancelled());\n\n    DyingQueryRunner interrupted1 = interrupted.poll();\n    synchronized (interrupted1) {\n      Assert.assertTrue(\"runner 1 started\", interrupted1.hasStarted);\n      Assert.assertTrue(\"runner 1 interrupted\", interrupted1.interrupted);\n    }\n    DyingQueryRunner interrupted2 = interrupted.poll();\n    synchronized (interrupted2) {\n      Assert.assertTrue(\"runner 2 started\", interrupted2.hasStarted);\n      Assert.assertTrue(\"runner 2 interrupted\", interrupted2.interrupted);\n    }\n    runners.remove(interrupted1);\n    runners.remove(interrupted2);\n    DyingQueryRunner remainingRunner = runners.iterator().next();\n    synchronized (remainingRunner) {\n      Assert.assertTrue(\"runner 3 should be interrupted or not have started\",\n                        !remainingRunner.hasStarted || remainingRunner.interrupted);\n    }\n    Assert.assertFalse(\"runner 1 not completed\", interrupted1.hasCompleted);\n    Assert.assertFalse(\"runner 2 not completed\", interrupted2.hasCompleted);\n    Assert.assertFalse(\"runner 3 not completed\", remainingRunner.hasCompleted);\n\n    EasyMock.verify(watcher);\n  }\n","date":"2019-07-24 23:29:03","endLine":307,"groupId":"16717","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testQueryTimeout","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/27/5fb637f7226ac63435dd88cbf349f655eb213c.src","preCode":"  public void testQueryTimeout() throws Exception\n  {\n    ExecutorService exec = PrioritizedExecutorService.create(\n        new Lifecycle(), new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return \"test\";\n          }\n\n          @Override\n          public int getNumThreads()\n          {\n            return 2;\n          }\n        }\n    );\n\n    final CountDownLatch queriesStarted = new CountDownLatch(2);\n    final CountDownLatch queriesInterrupted = new CountDownLatch(2);\n    final CountDownLatch queryIsRegistered = new CountDownLatch(1);\n\n    Capture<ListenableFuture> capturedFuture = Capture.newInstance();\n    QueryWatcher watcher = EasyMock.createStrictMock(QueryWatcher.class);\n    watcher.registerQuery(\n        EasyMock.anyObject(),\n        EasyMock.and(EasyMock.anyObject(), EasyMock.capture(capturedFuture))\n    );\n    EasyMock.expectLastCall()\n            .andAnswer(\n                new IAnswer<Void>()\n                {\n                  @Override\n                  public Void answer()\n                  {\n                    queryIsRegistered.countDown();\n                    return null;\n                  }\n                }\n            )\n            .once();\n\n    EasyMock.replay(watcher);\n\n\n    ArrayBlockingQueue<DyingQueryRunner> interrupted = new ArrayBlockingQueue<>(3);\n    Set<DyingQueryRunner> runners = Sets.newHashSet(\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted)\n    );\n\n    ChainedExecutionQueryRunner chainedRunner = new ChainedExecutionQueryRunner<>(\n        exec,\n        watcher,\n        Lists.newArrayList(\n            runners\n        )\n    );\n    HashMap<String, Object> context = new HashMap<String, Object>();\n    TimeseriesQuery query = Druids.newTimeseriesQueryBuilder()\n                                  .dataSource(\"test\")\n                                  .intervals(\"2014/2015\")\n                                  .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n                                  .context(ImmutableMap.of(QueryContexts.TIMEOUT_KEY, 100, \"queryId\", \"test\"))\n                                  .build();\n    final Sequence seq = chainedRunner.run(QueryPlus.wrap(query), context);\n\n    Future resultFuture = Executors.newFixedThreadPool(1).submit(\n        new Runnable()\n        {\n          @Override\n          public void run()\n          {\n            seq.toList();\n          }\n        }\n    );\n\n    \r\n    queryIsRegistered.await();\n    queriesStarted.await();\n\n    Assert.assertTrue(capturedFuture.hasCaptured());\n    ListenableFuture future = capturedFuture.getValue();\n\n    \r\n    QueryInterruptedException cause = null;\n    try {\n      resultFuture.get();\n    }\n    catch (ExecutionException e) {\n      Assert.assertTrue(e.getCause() instanceof QueryInterruptedException);\n      Assert.assertEquals(\"Query timeout\", ((QueryInterruptedException) e.getCause()).getErrorCode());\n      cause = (QueryInterruptedException) e.getCause();\n    }\n    queriesInterrupted.await();\n    Assert.assertNotNull(cause);\n    Assert.assertTrue(future.isCancelled());\n\n    DyingQueryRunner interrupted1 = interrupted.poll();\n    synchronized (interrupted1) {\n      Assert.assertTrue(\"runner 1 started\", interrupted1.hasStarted);\n      Assert.assertTrue(\"runner 1 interrupted\", interrupted1.interrupted);\n    }\n    DyingQueryRunner interrupted2 = interrupted.poll();\n    synchronized (interrupted2) {\n      Assert.assertTrue(\"runner 2 started\", interrupted2.hasStarted);\n      Assert.assertTrue(\"runner 2 interrupted\", interrupted2.interrupted);\n    }\n    runners.remove(interrupted1);\n    runners.remove(interrupted2);\n    DyingQueryRunner remainingRunner = runners.iterator().next();\n    synchronized (remainingRunner) {\n      Assert.assertTrue(\"runner 3 should be interrupted or not have started\",\n                        !remainingRunner.hasStarted || remainingRunner.interrupted);\n    }\n    Assert.assertFalse(\"runner 1 not completed\", interrupted1.hasCompleted);\n    Assert.assertFalse(\"runner 2 not completed\", interrupted2.hasCompleted);\n    Assert.assertFalse(\"runner 3 not completed\", remainingRunner.hasCompleted);\n\n    EasyMock.verify(watcher);\n  }\n","realPath":"processing/src/test/java/org/apache/druid/query/ChainedExecutionQueryRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":185,"status":"M"}],"commitId":"799d20249fe6333ea86b020f6d09c91fa4d3f998","commitMessage":"@@@Response context refactoring (#8110)\n\n* Response context refactoring\n\n* Serialization/Deserialization of ResponseContext\n\n* Added java doc comments\n\n* Renamed vars related to ResponseContext\n\n* Renamed empty() methods to createEmpty()\n\n* Fixed ResponseContext usage\n\n* Renamed multiple ResponseContext static fields\n\n* Added PublicApi annotations\n\n* Renamed QueryResponseContext class to ResourceIOReaderWriter\n\n* Moved the protected method below public static constants\n\n* Added createEmpty method to ResponseContext with DefaultResponseContext creation\n\n* Fixed inspection error\n\n* Added comments to the ResponseContext length limit and ResponseContext\nhttp header name\n\n* Added a comment of possible future refactoring\n\n* Removed .gitignore file of indexing-service\n\n* Removed a never-used method\n\n* VisibleForTesting method reducing boilerplate\n\nCo-Authored-By: Clint Wylie <cjwylie@gmail.com>\n\n* Reduced boilerplate\n\n* Renamed the method serialize to serializeWith\n\n* Removed unused import\n\n* Fixed incorrectly refactored test method\n\n* Added comments for ResponseContext keys\n\n* Fixed incorrectly refactored test method\n\n* Fixed IntervalChunkingQueryRunnerTest mocks\n","date":"2019-07-24 23:29:03","modifiedFileCount":"142","status":"M","submitter":"Eugene Sevastianov"},{"authorTime":"2020-03-10 17:57:16","codes":[{"authorDate":"2020-03-10 17:57:16","commitOrder":4,"curCode":"  public void testQueryCancellation() throws Exception\n  {\n    ExecutorService exec = PrioritizedExecutorService.create(\n        new Lifecycle(), new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return \"test\";\n          }\n\n          @Override\n          public int getNumThreads()\n          {\n            return 2;\n          }\n        }\n    );\n\n    final CountDownLatch queriesStarted = new CountDownLatch(2);\n    final CountDownLatch queriesInterrupted = new CountDownLatch(2);\n    final CountDownLatch queryIsRegistered = new CountDownLatch(1);\n\n    Capture<ListenableFuture> capturedFuture = EasyMock.newCapture();\n    QueryWatcher watcher = EasyMock.createStrictMock(QueryWatcher.class);\n    watcher.registerQueryFuture(\n        EasyMock.anyObject(),\n        EasyMock.and(EasyMock.anyObject(), EasyMock.capture(capturedFuture))\n    );\n    EasyMock.expectLastCall()\n            .andAnswer(\n                new IAnswer<Void>()\n                {\n                  @Override\n                  public Void answer()\n                  {\n                    queryIsRegistered.countDown();\n                    return null;\n                  }\n                }\n            )\n            .once();\n\n    EasyMock.replay(watcher);\n\n    ArrayBlockingQueue<DyingQueryRunner> interrupted = new ArrayBlockingQueue<>(3);\n    Set<DyingQueryRunner> runners = Sets.newHashSet(\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted)\n    );\n\n    ChainedExecutionQueryRunner chainedRunner = new ChainedExecutionQueryRunner<>(\n        exec,\n        watcher,\n        Lists.newArrayList(\n         runners\n        )\n    );\n    TimeseriesQuery query = Druids.newTimeseriesQueryBuilder()\n                                  .dataSource(\"test\")\n                                  .intervals(\"2014/2015\")\n                                  .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n                                  .build();\n    final Sequence seq = chainedRunner.run(QueryPlus.wrap(query));\n\n    Future resultFuture = Executors.newFixedThreadPool(1).submit(\n        new Runnable()\n        {\n          @Override\n          public void run()\n          {\n            seq.toList();\n          }\n        }\n    );\n\n    \r\n    queryIsRegistered.await();\n    queriesStarted.await();\n\n    \r\n    Assert.assertTrue(capturedFuture.hasCaptured());\n    ListenableFuture future = capturedFuture.getValue();\n    future.cancel(true);\n\n    QueryInterruptedException cause = null;\n    try {\n      resultFuture.get();\n    }\n    catch (ExecutionException e) {\n      Assert.assertTrue(e.getCause() instanceof QueryInterruptedException);\n      cause = (QueryInterruptedException) e.getCause();\n    }\n    queriesInterrupted.await();\n    Assert.assertNotNull(cause);\n    Assert.assertTrue(future.isCancelled());\n\n    DyingQueryRunner interrupted1 = interrupted.poll();\n    synchronized (interrupted1) {\n      Assert.assertTrue(\"runner 1 started\", interrupted1.hasStarted);\n      Assert.assertTrue(\"runner 1 interrupted\", interrupted1.interrupted);\n    }\n    DyingQueryRunner interrupted2 = interrupted.poll();\n    synchronized (interrupted2) {\n      Assert.assertTrue(\"runner 2 started\", interrupted2.hasStarted);\n      Assert.assertTrue(\"runner 2 interrupted\", interrupted2.interrupted);\n    }\n    runners.remove(interrupted1);\n    runners.remove(interrupted2);\n    DyingQueryRunner remainingRunner = runners.iterator().next();\n    synchronized (remainingRunner) {\n      Assert.assertTrue(\"runner 3 should be interrupted or not have started\",\n                        !remainingRunner.hasStarted || remainingRunner.interrupted);\n    }\n    Assert.assertFalse(\"runner 1 not completed\", interrupted1.hasCompleted);\n    Assert.assertFalse(\"runner 2 not completed\", interrupted2.hasCompleted);\n    Assert.assertFalse(\"runner 3 not completed\", remainingRunner.hasCompleted);\n\n    EasyMock.verify(watcher);\n  }\n","date":"2020-03-10 17:57:16","endLine":182,"groupId":"6825","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testQueryCancellation","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/b2/385044b5606128b9955226389db5f28864c09b.src","preCode":"  public void testQueryCancellation() throws Exception\n  {\n    ExecutorService exec = PrioritizedExecutorService.create(\n        new Lifecycle(), new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return \"test\";\n          }\n\n          @Override\n          public int getNumThreads()\n          {\n            return 2;\n          }\n        }\n    );\n\n    final CountDownLatch queriesStarted = new CountDownLatch(2);\n    final CountDownLatch queriesInterrupted = new CountDownLatch(2);\n    final CountDownLatch queryIsRegistered = new CountDownLatch(1);\n\n    Capture<ListenableFuture> capturedFuture = EasyMock.newCapture();\n    QueryWatcher watcher = EasyMock.createStrictMock(QueryWatcher.class);\n    watcher.registerQuery(\n        EasyMock.anyObject(),\n        EasyMock.and(EasyMock.anyObject(), EasyMock.capture(capturedFuture))\n    );\n    EasyMock.expectLastCall()\n            .andAnswer(\n                new IAnswer<Void>()\n                {\n                  @Override\n                  public Void answer()\n                  {\n                    queryIsRegistered.countDown();\n                    return null;\n                  }\n                }\n            )\n            .once();\n\n    EasyMock.replay(watcher);\n\n    ArrayBlockingQueue<DyingQueryRunner> interrupted = new ArrayBlockingQueue<>(3);\n    Set<DyingQueryRunner> runners = Sets.newHashSet(\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted)\n    );\n\n    ChainedExecutionQueryRunner chainedRunner = new ChainedExecutionQueryRunner<>(\n        exec,\n        watcher,\n        Lists.newArrayList(\n         runners\n        )\n    );\n    TimeseriesQuery query = Druids.newTimeseriesQueryBuilder()\n                                  .dataSource(\"test\")\n                                  .intervals(\"2014/2015\")\n                                  .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n                                  .build();\n    final Sequence seq = chainedRunner.run(QueryPlus.wrap(query));\n\n    Future resultFuture = Executors.newFixedThreadPool(1).submit(\n        new Runnable()\n        {\n          @Override\n          public void run()\n          {\n            seq.toList();\n          }\n        }\n    );\n\n    \r\n    queryIsRegistered.await();\n    queriesStarted.await();\n\n    \r\n    Assert.assertTrue(capturedFuture.hasCaptured());\n    ListenableFuture future = capturedFuture.getValue();\n    future.cancel(true);\n\n    QueryInterruptedException cause = null;\n    try {\n      resultFuture.get();\n    }\n    catch (ExecutionException e) {\n      Assert.assertTrue(e.getCause() instanceof QueryInterruptedException);\n      cause = (QueryInterruptedException) e.getCause();\n    }\n    queriesInterrupted.await();\n    Assert.assertNotNull(cause);\n    Assert.assertTrue(future.isCancelled());\n\n    DyingQueryRunner interrupted1 = interrupted.poll();\n    synchronized (interrupted1) {\n      Assert.assertTrue(\"runner 1 started\", interrupted1.hasStarted);\n      Assert.assertTrue(\"runner 1 interrupted\", interrupted1.interrupted);\n    }\n    DyingQueryRunner interrupted2 = interrupted.poll();\n    synchronized (interrupted2) {\n      Assert.assertTrue(\"runner 2 started\", interrupted2.hasStarted);\n      Assert.assertTrue(\"runner 2 interrupted\", interrupted2.interrupted);\n    }\n    runners.remove(interrupted1);\n    runners.remove(interrupted2);\n    DyingQueryRunner remainingRunner = runners.iterator().next();\n    synchronized (remainingRunner) {\n      Assert.assertTrue(\"runner 3 should be interrupted or not have started\",\n                        !remainingRunner.hasStarted || remainingRunner.interrupted);\n    }\n    Assert.assertFalse(\"runner 1 not completed\", interrupted1.hasCompleted);\n    Assert.assertFalse(\"runner 2 not completed\", interrupted2.hasCompleted);\n    Assert.assertFalse(\"runner 3 not completed\", remainingRunner.hasCompleted);\n\n    EasyMock.verify(watcher);\n  }\n","realPath":"processing/src/test/java/org/apache/druid/query/ChainedExecutionQueryRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":62,"status":"M"},{"authorDate":"2020-03-10 17:57:16","commitOrder":4,"curCode":"  public void testQueryTimeout() throws Exception\n  {\n    ExecutorService exec = PrioritizedExecutorService.create(\n        new Lifecycle(), new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return \"test\";\n          }\n\n          @Override\n          public int getNumThreads()\n          {\n            return 2;\n          }\n        }\n    );\n\n    final CountDownLatch queriesStarted = new CountDownLatch(2);\n    final CountDownLatch queriesInterrupted = new CountDownLatch(2);\n    final CountDownLatch queryIsRegistered = new CountDownLatch(1);\n\n    Capture<ListenableFuture> capturedFuture = Capture.newInstance();\n    QueryWatcher watcher = EasyMock.createStrictMock(QueryWatcher.class);\n    watcher.registerQueryFuture(\n        EasyMock.anyObject(),\n        EasyMock.and(EasyMock.anyObject(), EasyMock.capture(capturedFuture))\n    );\n    EasyMock.expectLastCall()\n            .andAnswer(\n                new IAnswer<Void>()\n                {\n                  @Override\n                  public Void answer()\n                  {\n                    queryIsRegistered.countDown();\n                    return null;\n                  }\n                }\n            )\n            .once();\n\n    EasyMock.replay(watcher);\n\n\n    ArrayBlockingQueue<DyingQueryRunner> interrupted = new ArrayBlockingQueue<>(3);\n    Set<DyingQueryRunner> runners = Sets.newHashSet(\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted)\n    );\n\n    ChainedExecutionQueryRunner chainedRunner = new ChainedExecutionQueryRunner<>(\n        exec,\n        watcher,\n        Lists.newArrayList(\n            runners\n        )\n    );\n    TimeseriesQuery query = Druids.newTimeseriesQueryBuilder()\n                                  .dataSource(\"test\")\n                                  .intervals(\"2014/2015\")\n                                  .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n                                  .context(ImmutableMap.of(QueryContexts.TIMEOUT_KEY, 100, \"queryId\", \"test\"))\n                                  .build();\n    final Sequence seq = chainedRunner.run(QueryPlus.wrap(query));\n\n    Future resultFuture = Executors.newFixedThreadPool(1).submit(\n        new Runnable()\n        {\n          @Override\n          public void run()\n          {\n            seq.toList();\n          }\n        }\n    );\n\n    \r\n    queryIsRegistered.await();\n    queriesStarted.await();\n\n    Assert.assertTrue(capturedFuture.hasCaptured());\n    ListenableFuture future = capturedFuture.getValue();\n\n    \r\n    QueryInterruptedException cause = null;\n    try {\n      resultFuture.get();\n    }\n    catch (ExecutionException e) {\n      Assert.assertTrue(e.getCause() instanceof QueryInterruptedException);\n      Assert.assertEquals(\"Query timeout\", ((QueryInterruptedException) e.getCause()).getErrorCode());\n      cause = (QueryInterruptedException) e.getCause();\n    }\n    queriesInterrupted.await();\n    Assert.assertNotNull(cause);\n    Assert.assertTrue(future.isCancelled());\n\n    DyingQueryRunner interrupted1 = interrupted.poll();\n    synchronized (interrupted1) {\n      Assert.assertTrue(\"runner 1 started\", interrupted1.hasStarted);\n      Assert.assertTrue(\"runner 1 interrupted\", interrupted1.interrupted);\n    }\n    DyingQueryRunner interrupted2 = interrupted.poll();\n    synchronized (interrupted2) {\n      Assert.assertTrue(\"runner 2 started\", interrupted2.hasStarted);\n      Assert.assertTrue(\"runner 2 interrupted\", interrupted2.interrupted);\n    }\n    runners.remove(interrupted1);\n    runners.remove(interrupted2);\n    DyingQueryRunner remainingRunner = runners.iterator().next();\n    synchronized (remainingRunner) {\n      Assert.assertTrue(\"runner 3 should be interrupted or not have started\",\n                        !remainingRunner.hasStarted || remainingRunner.interrupted);\n    }\n    Assert.assertFalse(\"runner 1 not completed\", interrupted1.hasCompleted);\n    Assert.assertFalse(\"runner 2 not completed\", interrupted2.hasCompleted);\n    Assert.assertFalse(\"runner 3 not completed\", remainingRunner.hasCompleted);\n\n    EasyMock.verify(watcher);\n  }\n","date":"2020-03-10 17:57:16","endLine":307,"groupId":"16717","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testQueryTimeout","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/b2/385044b5606128b9955226389db5f28864c09b.src","preCode":"  public void testQueryTimeout() throws Exception\n  {\n    ExecutorService exec = PrioritizedExecutorService.create(\n        new Lifecycle(), new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return \"test\";\n          }\n\n          @Override\n          public int getNumThreads()\n          {\n            return 2;\n          }\n        }\n    );\n\n    final CountDownLatch queriesStarted = new CountDownLatch(2);\n    final CountDownLatch queriesInterrupted = new CountDownLatch(2);\n    final CountDownLatch queryIsRegistered = new CountDownLatch(1);\n\n    Capture<ListenableFuture> capturedFuture = Capture.newInstance();\n    QueryWatcher watcher = EasyMock.createStrictMock(QueryWatcher.class);\n    watcher.registerQuery(\n        EasyMock.anyObject(),\n        EasyMock.and(EasyMock.anyObject(), EasyMock.capture(capturedFuture))\n    );\n    EasyMock.expectLastCall()\n            .andAnswer(\n                new IAnswer<Void>()\n                {\n                  @Override\n                  public Void answer()\n                  {\n                    queryIsRegistered.countDown();\n                    return null;\n                  }\n                }\n            )\n            .once();\n\n    EasyMock.replay(watcher);\n\n\n    ArrayBlockingQueue<DyingQueryRunner> interrupted = new ArrayBlockingQueue<>(3);\n    Set<DyingQueryRunner> runners = Sets.newHashSet(\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted)\n    );\n\n    ChainedExecutionQueryRunner chainedRunner = new ChainedExecutionQueryRunner<>(\n        exec,\n        watcher,\n        Lists.newArrayList(\n            runners\n        )\n    );\n    TimeseriesQuery query = Druids.newTimeseriesQueryBuilder()\n                                  .dataSource(\"test\")\n                                  .intervals(\"2014/2015\")\n                                  .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n                                  .context(ImmutableMap.of(QueryContexts.TIMEOUT_KEY, 100, \"queryId\", \"test\"))\n                                  .build();\n    final Sequence seq = chainedRunner.run(QueryPlus.wrap(query));\n\n    Future resultFuture = Executors.newFixedThreadPool(1).submit(\n        new Runnable()\n        {\n          @Override\n          public void run()\n          {\n            seq.toList();\n          }\n        }\n    );\n\n    \r\n    queryIsRegistered.await();\n    queriesStarted.await();\n\n    Assert.assertTrue(capturedFuture.hasCaptured());\n    ListenableFuture future = capturedFuture.getValue();\n\n    \r\n    QueryInterruptedException cause = null;\n    try {\n      resultFuture.get();\n    }\n    catch (ExecutionException e) {\n      Assert.assertTrue(e.getCause() instanceof QueryInterruptedException);\n      Assert.assertEquals(\"Query timeout\", ((QueryInterruptedException) e.getCause()).getErrorCode());\n      cause = (QueryInterruptedException) e.getCause();\n    }\n    queriesInterrupted.await();\n    Assert.assertNotNull(cause);\n    Assert.assertTrue(future.isCancelled());\n\n    DyingQueryRunner interrupted1 = interrupted.poll();\n    synchronized (interrupted1) {\n      Assert.assertTrue(\"runner 1 started\", interrupted1.hasStarted);\n      Assert.assertTrue(\"runner 1 interrupted\", interrupted1.interrupted);\n    }\n    DyingQueryRunner interrupted2 = interrupted.poll();\n    synchronized (interrupted2) {\n      Assert.assertTrue(\"runner 2 started\", interrupted2.hasStarted);\n      Assert.assertTrue(\"runner 2 interrupted\", interrupted2.interrupted);\n    }\n    runners.remove(interrupted1);\n    runners.remove(interrupted2);\n    DyingQueryRunner remainingRunner = runners.iterator().next();\n    synchronized (remainingRunner) {\n      Assert.assertTrue(\"runner 3 should be interrupted or not have started\",\n                        !remainingRunner.hasStarted || remainingRunner.interrupted);\n    }\n    Assert.assertFalse(\"runner 1 not completed\", interrupted1.hasCompleted);\n    Assert.assertFalse(\"runner 2 not completed\", interrupted2.hasCompleted);\n    Assert.assertFalse(\"runner 3 not completed\", remainingRunner.hasCompleted);\n\n    EasyMock.verify(watcher);\n  }\n","realPath":"processing/src/test/java/org/apache/druid/query/ChainedExecutionQueryRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":185,"status":"M"}],"commitId":"8b9fe6f58461f1fc3f453c14f1634f9e779aeb71","commitMessage":"@@@query laning and load shedding (#9407)\n\n* prototype\n\n* merge QueryScheduler and QueryManager\n\n* everything in its right place\n\n* adjustments\n\n* docs\n\n* fixes\n\n* doc fixes\n\n* use resilience4j instead of semaphore\n\n* more tests\n\n* simplify\n\n* checkstyle\n\n* spelling\n\n* oops heh\n\n* remove unused\n\n* simplify\n\n* concurrency tests\n\n* add SqlResource tests.  refactor error response\n\n* add json config tests\n\n* use LongAdder instead of AtomicLong\n\n* remove test only stuffs from scheduler\n\n* javadocs.  etc\n\n* style\n\n* partial review stuffs\n\n* adjust\n\n* review stuffs\n\n* more javadoc\n\n* error response documentation\n\n* spelling\n\n* preserve user specified lane for NoSchedulingStrategy\n\n* more test.  why not\n\n* doc adjustment\n\n* style\n\n* missed review for make a thing a constant\n\n* fixes and tests\n\n* fix test\n\n* Update docs/configuration/index.md\n\nCo-Authored-By: sthetland <steve.hetland@imply.io>\n\n* doc update\n\nCo-authored-by: sthetland <steve.hetland@imply.io>","date":"2020-03-10 17:57:16","modifiedFileCount":"26","status":"M","submitter":"Clint Wylie"},{"authorTime":"2020-11-03 23:00:33","codes":[{"authorDate":"2020-03-10 17:57:16","commitOrder":5,"curCode":"  public void testQueryCancellation() throws Exception\n  {\n    ExecutorService exec = PrioritizedExecutorService.create(\n        new Lifecycle(), new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return \"test\";\n          }\n\n          @Override\n          public int getNumThreads()\n          {\n            return 2;\n          }\n        }\n    );\n\n    final CountDownLatch queriesStarted = new CountDownLatch(2);\n    final CountDownLatch queriesInterrupted = new CountDownLatch(2);\n    final CountDownLatch queryIsRegistered = new CountDownLatch(1);\n\n    Capture<ListenableFuture> capturedFuture = EasyMock.newCapture();\n    QueryWatcher watcher = EasyMock.createStrictMock(QueryWatcher.class);\n    watcher.registerQueryFuture(\n        EasyMock.anyObject(),\n        EasyMock.and(EasyMock.anyObject(), EasyMock.capture(capturedFuture))\n    );\n    EasyMock.expectLastCall()\n            .andAnswer(\n                new IAnswer<Void>()\n                {\n                  @Override\n                  public Void answer()\n                  {\n                    queryIsRegistered.countDown();\n                    return null;\n                  }\n                }\n            )\n            .once();\n\n    EasyMock.replay(watcher);\n\n    ArrayBlockingQueue<DyingQueryRunner> interrupted = new ArrayBlockingQueue<>(3);\n    Set<DyingQueryRunner> runners = Sets.newHashSet(\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted)\n    );\n\n    ChainedExecutionQueryRunner chainedRunner = new ChainedExecutionQueryRunner<>(\n        exec,\n        watcher,\n        Lists.newArrayList(\n         runners\n        )\n    );\n    TimeseriesQuery query = Druids.newTimeseriesQueryBuilder()\n                                  .dataSource(\"test\")\n                                  .intervals(\"2014/2015\")\n                                  .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n                                  .build();\n    final Sequence seq = chainedRunner.run(QueryPlus.wrap(query));\n\n    Future resultFuture = Executors.newFixedThreadPool(1).submit(\n        new Runnable()\n        {\n          @Override\n          public void run()\n          {\n            seq.toList();\n          }\n        }\n    );\n\n    \r\n    queryIsRegistered.await();\n    queriesStarted.await();\n\n    \r\n    Assert.assertTrue(capturedFuture.hasCaptured());\n    ListenableFuture future = capturedFuture.getValue();\n    future.cancel(true);\n\n    QueryInterruptedException cause = null;\n    try {\n      resultFuture.get();\n    }\n    catch (ExecutionException e) {\n      Assert.assertTrue(e.getCause() instanceof QueryInterruptedException);\n      cause = (QueryInterruptedException) e.getCause();\n    }\n    queriesInterrupted.await();\n    Assert.assertNotNull(cause);\n    Assert.assertTrue(future.isCancelled());\n\n    DyingQueryRunner interrupted1 = interrupted.poll();\n    synchronized (interrupted1) {\n      Assert.assertTrue(\"runner 1 started\", interrupted1.hasStarted);\n      Assert.assertTrue(\"runner 1 interrupted\", interrupted1.interrupted);\n    }\n    DyingQueryRunner interrupted2 = interrupted.poll();\n    synchronized (interrupted2) {\n      Assert.assertTrue(\"runner 2 started\", interrupted2.hasStarted);\n      Assert.assertTrue(\"runner 2 interrupted\", interrupted2.interrupted);\n    }\n    runners.remove(interrupted1);\n    runners.remove(interrupted2);\n    DyingQueryRunner remainingRunner = runners.iterator().next();\n    synchronized (remainingRunner) {\n      Assert.assertTrue(\"runner 3 should be interrupted or not have started\",\n                        !remainingRunner.hasStarted || remainingRunner.interrupted);\n    }\n    Assert.assertFalse(\"runner 1 not completed\", interrupted1.hasCompleted);\n    Assert.assertFalse(\"runner 2 not completed\", interrupted2.hasCompleted);\n    Assert.assertFalse(\"runner 3 not completed\", remainingRunner.hasCompleted);\n\n    EasyMock.verify(watcher);\n  }\n","date":"2020-03-10 17:57:16","endLine":182,"groupId":"6825","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testQueryCancellation","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/b2/385044b5606128b9955226389db5f28864c09b.src","preCode":"  public void testQueryCancellation() throws Exception\n  {\n    ExecutorService exec = PrioritizedExecutorService.create(\n        new Lifecycle(), new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return \"test\";\n          }\n\n          @Override\n          public int getNumThreads()\n          {\n            return 2;\n          }\n        }\n    );\n\n    final CountDownLatch queriesStarted = new CountDownLatch(2);\n    final CountDownLatch queriesInterrupted = new CountDownLatch(2);\n    final CountDownLatch queryIsRegistered = new CountDownLatch(1);\n\n    Capture<ListenableFuture> capturedFuture = EasyMock.newCapture();\n    QueryWatcher watcher = EasyMock.createStrictMock(QueryWatcher.class);\n    watcher.registerQueryFuture(\n        EasyMock.anyObject(),\n        EasyMock.and(EasyMock.anyObject(), EasyMock.capture(capturedFuture))\n    );\n    EasyMock.expectLastCall()\n            .andAnswer(\n                new IAnswer<Void>()\n                {\n                  @Override\n                  public Void answer()\n                  {\n                    queryIsRegistered.countDown();\n                    return null;\n                  }\n                }\n            )\n            .once();\n\n    EasyMock.replay(watcher);\n\n    ArrayBlockingQueue<DyingQueryRunner> interrupted = new ArrayBlockingQueue<>(3);\n    Set<DyingQueryRunner> runners = Sets.newHashSet(\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted)\n    );\n\n    ChainedExecutionQueryRunner chainedRunner = new ChainedExecutionQueryRunner<>(\n        exec,\n        watcher,\n        Lists.newArrayList(\n         runners\n        )\n    );\n    TimeseriesQuery query = Druids.newTimeseriesQueryBuilder()\n                                  .dataSource(\"test\")\n                                  .intervals(\"2014/2015\")\n                                  .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n                                  .build();\n    final Sequence seq = chainedRunner.run(QueryPlus.wrap(query));\n\n    Future resultFuture = Executors.newFixedThreadPool(1).submit(\n        new Runnable()\n        {\n          @Override\n          public void run()\n          {\n            seq.toList();\n          }\n        }\n    );\n\n    \r\n    queryIsRegistered.await();\n    queriesStarted.await();\n\n    \r\n    Assert.assertTrue(capturedFuture.hasCaptured());\n    ListenableFuture future = capturedFuture.getValue();\n    future.cancel(true);\n\n    QueryInterruptedException cause = null;\n    try {\n      resultFuture.get();\n    }\n    catch (ExecutionException e) {\n      Assert.assertTrue(e.getCause() instanceof QueryInterruptedException);\n      cause = (QueryInterruptedException) e.getCause();\n    }\n    queriesInterrupted.await();\n    Assert.assertNotNull(cause);\n    Assert.assertTrue(future.isCancelled());\n\n    DyingQueryRunner interrupted1 = interrupted.poll();\n    synchronized (interrupted1) {\n      Assert.assertTrue(\"runner 1 started\", interrupted1.hasStarted);\n      Assert.assertTrue(\"runner 1 interrupted\", interrupted1.interrupted);\n    }\n    DyingQueryRunner interrupted2 = interrupted.poll();\n    synchronized (interrupted2) {\n      Assert.assertTrue(\"runner 2 started\", interrupted2.hasStarted);\n      Assert.assertTrue(\"runner 2 interrupted\", interrupted2.interrupted);\n    }\n    runners.remove(interrupted1);\n    runners.remove(interrupted2);\n    DyingQueryRunner remainingRunner = runners.iterator().next();\n    synchronized (remainingRunner) {\n      Assert.assertTrue(\"runner 3 should be interrupted or not have started\",\n                        !remainingRunner.hasStarted || remainingRunner.interrupted);\n    }\n    Assert.assertFalse(\"runner 1 not completed\", interrupted1.hasCompleted);\n    Assert.assertFalse(\"runner 2 not completed\", interrupted2.hasCompleted);\n    Assert.assertFalse(\"runner 3 not completed\", remainingRunner.hasCompleted);\n\n    EasyMock.verify(watcher);\n  }\n","realPath":"processing/src/test/java/org/apache/druid/query/ChainedExecutionQueryRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":62,"status":"N"},{"authorDate":"2020-11-03 23:00:33","commitOrder":5,"curCode":"  public void testQueryTimeout() throws Exception\n  {\n    ExecutorService exec = PrioritizedExecutorService.create(\n        new Lifecycle(), new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return \"test\";\n          }\n\n          @Override\n          public int getNumThreads()\n          {\n            return 2;\n          }\n        }\n    );\n\n    final CountDownLatch queriesStarted = new CountDownLatch(2);\n    final CountDownLatch queriesInterrupted = new CountDownLatch(2);\n    final CountDownLatch queryIsRegistered = new CountDownLatch(1);\n\n    Capture<ListenableFuture> capturedFuture = Capture.newInstance();\n    QueryWatcher watcher = EasyMock.createStrictMock(QueryWatcher.class);\n    watcher.registerQueryFuture(\n        EasyMock.anyObject(),\n        EasyMock.and(EasyMock.anyObject(), EasyMock.capture(capturedFuture))\n    );\n    EasyMock.expectLastCall()\n            .andAnswer(\n                new IAnswer<Void>()\n                {\n                  @Override\n                  public Void answer()\n                  {\n                    queryIsRegistered.countDown();\n                    return null;\n                  }\n                }\n            )\n            .once();\n\n    EasyMock.replay(watcher);\n\n\n    ArrayBlockingQueue<DyingQueryRunner> interrupted = new ArrayBlockingQueue<>(3);\n    Set<DyingQueryRunner> runners = Sets.newHashSet(\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted)\n    );\n\n    ChainedExecutionQueryRunner chainedRunner = new ChainedExecutionQueryRunner<>(\n        exec,\n        watcher,\n        Lists.newArrayList(\n            runners\n        )\n    );\n    TimeseriesQuery query = Druids.newTimeseriesQueryBuilder()\n                                  .dataSource(\"test\")\n                                  .intervals(\"2014/2015\")\n                                  .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n                                  .context(ImmutableMap.of(QueryContexts.TIMEOUT_KEY, 100, \"queryId\", \"test\"))\n                                  .build();\n    final Sequence seq = chainedRunner.run(QueryPlus.wrap(query));\n\n    Future resultFuture = Executors.newFixedThreadPool(1).submit(\n        new Runnable()\n        {\n          @Override\n          public void run()\n          {\n            seq.toList();\n          }\n        }\n    );\n\n    \r\n    queryIsRegistered.await();\n    queriesStarted.await();\n\n    Assert.assertTrue(capturedFuture.hasCaptured());\n    ListenableFuture future = capturedFuture.getValue();\n\n    \r\n    QueryTimeoutException cause = null;\n    try {\n      resultFuture.get();\n    }\n    catch (ExecutionException e) {\n      Assert.assertTrue(e.getCause() instanceof QueryTimeoutException);\n      Assert.assertEquals(\"Query timeout\", ((QueryTimeoutException) e.getCause()).getErrorCode());\n      cause = (QueryTimeoutException) e.getCause();\n    }\n    queriesInterrupted.await();\n    Assert.assertNotNull(cause);\n    Assert.assertTrue(future.isCancelled());\n\n    DyingQueryRunner interrupted1 = interrupted.poll();\n    synchronized (interrupted1) {\n      Assert.assertTrue(\"runner 1 started\", interrupted1.hasStarted);\n      Assert.assertTrue(\"runner 1 interrupted\", interrupted1.interrupted);\n    }\n    DyingQueryRunner interrupted2 = interrupted.poll();\n    synchronized (interrupted2) {\n      Assert.assertTrue(\"runner 2 started\", interrupted2.hasStarted);\n      Assert.assertTrue(\"runner 2 interrupted\", interrupted2.interrupted);\n    }\n    runners.remove(interrupted1);\n    runners.remove(interrupted2);\n    DyingQueryRunner remainingRunner = runners.iterator().next();\n    synchronized (remainingRunner) {\n      Assert.assertTrue(\"runner 3 should be interrupted or not have started\",\n                        !remainingRunner.hasStarted || remainingRunner.interrupted);\n    }\n    Assert.assertFalse(\"runner 1 not completed\", interrupted1.hasCompleted);\n    Assert.assertFalse(\"runner 2 not completed\", interrupted2.hasCompleted);\n    Assert.assertFalse(\"runner 3 not completed\", remainingRunner.hasCompleted);\n\n    EasyMock.verify(watcher);\n  }\n","date":"2020-11-03 23:00:33","endLine":307,"groupId":"16717","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testQueryTimeout","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/cf/822927fc67c12c4a9347b2c81d9dfaa92816a5.src","preCode":"  public void testQueryTimeout() throws Exception\n  {\n    ExecutorService exec = PrioritizedExecutorService.create(\n        new Lifecycle(), new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return \"test\";\n          }\n\n          @Override\n          public int getNumThreads()\n          {\n            return 2;\n          }\n        }\n    );\n\n    final CountDownLatch queriesStarted = new CountDownLatch(2);\n    final CountDownLatch queriesInterrupted = new CountDownLatch(2);\n    final CountDownLatch queryIsRegistered = new CountDownLatch(1);\n\n    Capture<ListenableFuture> capturedFuture = Capture.newInstance();\n    QueryWatcher watcher = EasyMock.createStrictMock(QueryWatcher.class);\n    watcher.registerQueryFuture(\n        EasyMock.anyObject(),\n        EasyMock.and(EasyMock.anyObject(), EasyMock.capture(capturedFuture))\n    );\n    EasyMock.expectLastCall()\n            .andAnswer(\n                new IAnswer<Void>()\n                {\n                  @Override\n                  public Void answer()\n                  {\n                    queryIsRegistered.countDown();\n                    return null;\n                  }\n                }\n            )\n            .once();\n\n    EasyMock.replay(watcher);\n\n\n    ArrayBlockingQueue<DyingQueryRunner> interrupted = new ArrayBlockingQueue<>(3);\n    Set<DyingQueryRunner> runners = Sets.newHashSet(\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted)\n    );\n\n    ChainedExecutionQueryRunner chainedRunner = new ChainedExecutionQueryRunner<>(\n        exec,\n        watcher,\n        Lists.newArrayList(\n            runners\n        )\n    );\n    TimeseriesQuery query = Druids.newTimeseriesQueryBuilder()\n                                  .dataSource(\"test\")\n                                  .intervals(\"2014/2015\")\n                                  .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n                                  .context(ImmutableMap.of(QueryContexts.TIMEOUT_KEY, 100, \"queryId\", \"test\"))\n                                  .build();\n    final Sequence seq = chainedRunner.run(QueryPlus.wrap(query));\n\n    Future resultFuture = Executors.newFixedThreadPool(1).submit(\n        new Runnable()\n        {\n          @Override\n          public void run()\n          {\n            seq.toList();\n          }\n        }\n    );\n\n    \r\n    queryIsRegistered.await();\n    queriesStarted.await();\n\n    Assert.assertTrue(capturedFuture.hasCaptured());\n    ListenableFuture future = capturedFuture.getValue();\n\n    \r\n    QueryInterruptedException cause = null;\n    try {\n      resultFuture.get();\n    }\n    catch (ExecutionException e) {\n      Assert.assertTrue(e.getCause() instanceof QueryInterruptedException);\n      Assert.assertEquals(\"Query timeout\", ((QueryInterruptedException) e.getCause()).getErrorCode());\n      cause = (QueryInterruptedException) e.getCause();\n    }\n    queriesInterrupted.await();\n    Assert.assertNotNull(cause);\n    Assert.assertTrue(future.isCancelled());\n\n    DyingQueryRunner interrupted1 = interrupted.poll();\n    synchronized (interrupted1) {\n      Assert.assertTrue(\"runner 1 started\", interrupted1.hasStarted);\n      Assert.assertTrue(\"runner 1 interrupted\", interrupted1.interrupted);\n    }\n    DyingQueryRunner interrupted2 = interrupted.poll();\n    synchronized (interrupted2) {\n      Assert.assertTrue(\"runner 2 started\", interrupted2.hasStarted);\n      Assert.assertTrue(\"runner 2 interrupted\", interrupted2.interrupted);\n    }\n    runners.remove(interrupted1);\n    runners.remove(interrupted2);\n    DyingQueryRunner remainingRunner = runners.iterator().next();\n    synchronized (remainingRunner) {\n      Assert.assertTrue(\"runner 3 should be interrupted or not have started\",\n                        !remainingRunner.hasStarted || remainingRunner.interrupted);\n    }\n    Assert.assertFalse(\"runner 1 not completed\", interrupted1.hasCompleted);\n    Assert.assertFalse(\"runner 2 not completed\", interrupted2.hasCompleted);\n    Assert.assertFalse(\"runner 3 not completed\", remainingRunner.hasCompleted);\n\n    EasyMock.verify(watcher);\n  }\n","realPath":"processing/src/test/java/org/apache/druid/query/ChainedExecutionQueryRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":185,"status":"M"}],"commitId":"6ccddedb7a1752dc130d939066b04da16eb6b1bd","commitMessage":"@@@Improved exception handling in case of query timeouts (#10464)\n\n* Separate timeout exceptions\n\n* Add more tests\n\nCo-authored-by: Atul Mohan <atulmohan@yahoo-inc.com>","date":"2020-11-03 23:00:33","modifiedFileCount":"25","status":"M","submitter":"Atul Mohan"},{"authorTime":"2021-07-01 18:33:08","codes":[{"authorDate":"2021-07-01 18:33:08","commitOrder":6,"curCode":"  public void testQueryCancellation() throws Exception\n  {\n    ExecutorService exec = PrioritizedExecutorService.create(\n        new Lifecycle(), new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return \"test\";\n          }\n\n          @Override\n          public int getNumThreads()\n          {\n            return 2;\n          }\n        }\n    );\n\n    final CountDownLatch queriesStarted = new CountDownLatch(2);\n    final CountDownLatch queriesInterrupted = new CountDownLatch(2);\n    final CountDownLatch queryIsRegistered = new CountDownLatch(1);\n\n    Capture<ListenableFuture> capturedFuture = EasyMock.newCapture();\n    QueryWatcher watcher = EasyMock.createStrictMock(QueryWatcher.class);\n    watcher.registerQueryFuture(\n        EasyMock.anyObject(),\n        EasyMock.and(EasyMock.anyObject(), EasyMock.capture(capturedFuture))\n    );\n    EasyMock.expectLastCall()\n            .andAnswer(\n                new IAnswer<Void>()\n                {\n                  @Override\n                  public Void answer()\n                  {\n                    queryIsRegistered.countDown();\n                    return null;\n                  }\n                }\n            )\n            .once();\n\n    EasyMock.replay(watcher);\n\n    ArrayBlockingQueue<DyingQueryRunner> interrupted = new ArrayBlockingQueue<>(3);\n    Set<DyingQueryRunner> runners = Sets.newHashSet(\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted)\n    );\n\n    ChainedExecutionQueryRunner chainedRunner = new ChainedExecutionQueryRunner<>(\n        new ForwardingQueryProcessingPool(exec),\n        watcher,\n        Lists.newArrayList(\n            runners\n        )\n    );\n    TimeseriesQuery query = Druids.newTimeseriesQueryBuilder()\n                                  .dataSource(\"test\")\n                                  .intervals(\"2014/2015\")\n                                  .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n                                  .build();\n    final Sequence seq = chainedRunner.run(QueryPlus.wrap(query));\n\n    Future resultFuture = Executors.newFixedThreadPool(1).submit(\n        new Runnable()\n        {\n          @Override\n          public void run()\n          {\n            seq.toList();\n          }\n        }\n    );\n\n    \r\n    queryIsRegistered.await();\n    queriesStarted.await();\n\n    \r\n    Assert.assertTrue(capturedFuture.hasCaptured());\n    ListenableFuture future = capturedFuture.getValue();\n    future.cancel(true);\n\n    QueryInterruptedException cause = null;\n    try {\n      resultFuture.get();\n    }\n    catch (ExecutionException e) {\n      Assert.assertTrue(e.getCause() instanceof QueryInterruptedException);\n      cause = (QueryInterruptedException) e.getCause();\n    }\n    queriesInterrupted.await();\n    Assert.assertNotNull(cause);\n    Assert.assertTrue(future.isCancelled());\n\n    DyingQueryRunner interrupted1 = interrupted.poll();\n    synchronized (interrupted1) {\n      Assert.assertTrue(\"runner 1 started\", interrupted1.hasStarted);\n      Assert.assertTrue(\"runner 1 interrupted\", interrupted1.interrupted);\n    }\n    DyingQueryRunner interrupted2 = interrupted.poll();\n    synchronized (interrupted2) {\n      Assert.assertTrue(\"runner 2 started\", interrupted2.hasStarted);\n      Assert.assertTrue(\"runner 2 interrupted\", interrupted2.interrupted);\n    }\n    runners.remove(interrupted1);\n    runners.remove(interrupted2);\n    DyingQueryRunner remainingRunner = runners.iterator().next();\n    synchronized (remainingRunner) {\n      Assert.assertTrue(\"runner 3 should be interrupted or not have started\",\n                        !remainingRunner.hasStarted || remainingRunner.interrupted);\n    }\n    Assert.assertFalse(\"runner 1 not completed\", interrupted1.hasCompleted);\n    Assert.assertFalse(\"runner 2 not completed\", interrupted2.hasCompleted);\n    Assert.assertFalse(\"runner 3 not completed\", remainingRunner.hasCompleted);\n\n    EasyMock.verify(watcher);\n  }\n","date":"2021-07-01 18:33:08","endLine":190,"groupId":"106247","id":11,"instanceNumber":1,"isCurCommit":1,"methodName":"testQueryCancellation","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/b1/b5084a70c0f3ad7612433afed47a81c1a15383.src","preCode":"  public void testQueryCancellation() throws Exception\n  {\n    ExecutorService exec = PrioritizedExecutorService.create(\n        new Lifecycle(), new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return \"test\";\n          }\n\n          @Override\n          public int getNumThreads()\n          {\n            return 2;\n          }\n        }\n    );\n\n    final CountDownLatch queriesStarted = new CountDownLatch(2);\n    final CountDownLatch queriesInterrupted = new CountDownLatch(2);\n    final CountDownLatch queryIsRegistered = new CountDownLatch(1);\n\n    Capture<ListenableFuture> capturedFuture = EasyMock.newCapture();\n    QueryWatcher watcher = EasyMock.createStrictMock(QueryWatcher.class);\n    watcher.registerQueryFuture(\n        EasyMock.anyObject(),\n        EasyMock.and(EasyMock.anyObject(), EasyMock.capture(capturedFuture))\n    );\n    EasyMock.expectLastCall()\n            .andAnswer(\n                new IAnswer<Void>()\n                {\n                  @Override\n                  public Void answer()\n                  {\n                    queryIsRegistered.countDown();\n                    return null;\n                  }\n                }\n            )\n            .once();\n\n    EasyMock.replay(watcher);\n\n    ArrayBlockingQueue<DyingQueryRunner> interrupted = new ArrayBlockingQueue<>(3);\n    Set<DyingQueryRunner> runners = Sets.newHashSet(\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted)\n    );\n\n    ChainedExecutionQueryRunner chainedRunner = new ChainedExecutionQueryRunner<>(\n        exec,\n        watcher,\n        Lists.newArrayList(\n         runners\n        )\n    );\n    TimeseriesQuery query = Druids.newTimeseriesQueryBuilder()\n                                  .dataSource(\"test\")\n                                  .intervals(\"2014/2015\")\n                                  .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n                                  .build();\n    final Sequence seq = chainedRunner.run(QueryPlus.wrap(query));\n\n    Future resultFuture = Executors.newFixedThreadPool(1).submit(\n        new Runnable()\n        {\n          @Override\n          public void run()\n          {\n            seq.toList();\n          }\n        }\n    );\n\n    \r\n    queryIsRegistered.await();\n    queriesStarted.await();\n\n    \r\n    Assert.assertTrue(capturedFuture.hasCaptured());\n    ListenableFuture future = capturedFuture.getValue();\n    future.cancel(true);\n\n    QueryInterruptedException cause = null;\n    try {\n      resultFuture.get();\n    }\n    catch (ExecutionException e) {\n      Assert.assertTrue(e.getCause() instanceof QueryInterruptedException);\n      cause = (QueryInterruptedException) e.getCause();\n    }\n    queriesInterrupted.await();\n    Assert.assertNotNull(cause);\n    Assert.assertTrue(future.isCancelled());\n\n    DyingQueryRunner interrupted1 = interrupted.poll();\n    synchronized (interrupted1) {\n      Assert.assertTrue(\"runner 1 started\", interrupted1.hasStarted);\n      Assert.assertTrue(\"runner 1 interrupted\", interrupted1.interrupted);\n    }\n    DyingQueryRunner interrupted2 = interrupted.poll();\n    synchronized (interrupted2) {\n      Assert.assertTrue(\"runner 2 started\", interrupted2.hasStarted);\n      Assert.assertTrue(\"runner 2 interrupted\", interrupted2.interrupted);\n    }\n    runners.remove(interrupted1);\n    runners.remove(interrupted2);\n    DyingQueryRunner remainingRunner = runners.iterator().next();\n    synchronized (remainingRunner) {\n      Assert.assertTrue(\"runner 3 should be interrupted or not have started\",\n                        !remainingRunner.hasStarted || remainingRunner.interrupted);\n    }\n    Assert.assertFalse(\"runner 1 not completed\", interrupted1.hasCompleted);\n    Assert.assertFalse(\"runner 2 not completed\", interrupted2.hasCompleted);\n    Assert.assertFalse(\"runner 3 not completed\", remainingRunner.hasCompleted);\n\n    EasyMock.verify(watcher);\n  }\n","realPath":"processing/src/test/java/org/apache/druid/query/ChainedExecutionQueryRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":70,"status":"M"},{"authorDate":"2021-07-01 18:33:08","commitOrder":6,"curCode":"  public void testQueryTimeout() throws Exception\n  {\n    ExecutorService exec = PrioritizedExecutorService.create(\n        new Lifecycle(), new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return \"test\";\n          }\n\n          @Override\n          public int getNumThreads()\n          {\n            return 2;\n          }\n        }\n    );\n\n    final CountDownLatch queriesStarted = new CountDownLatch(2);\n    final CountDownLatch queriesInterrupted = new CountDownLatch(2);\n    final CountDownLatch queryIsRegistered = new CountDownLatch(1);\n\n    Capture<ListenableFuture> capturedFuture = Capture.newInstance();\n    QueryWatcher watcher = EasyMock.createStrictMock(QueryWatcher.class);\n    watcher.registerQueryFuture(\n        EasyMock.anyObject(),\n        EasyMock.and(EasyMock.anyObject(), EasyMock.capture(capturedFuture))\n    );\n    EasyMock.expectLastCall()\n            .andAnswer(\n                new IAnswer<Void>()\n                {\n                  @Override\n                  public Void answer()\n                  {\n                    queryIsRegistered.countDown();\n                    return null;\n                  }\n                }\n            )\n            .once();\n\n    EasyMock.replay(watcher);\n\n\n    ArrayBlockingQueue<DyingQueryRunner> interrupted = new ArrayBlockingQueue<>(3);\n    Set<DyingQueryRunner> runners = Sets.newHashSet(\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted)\n    );\n\n    ChainedExecutionQueryRunner chainedRunner = new ChainedExecutionQueryRunner<>(\n        new ForwardingQueryProcessingPool(exec),\n        watcher,\n        Lists.newArrayList(\n            runners\n        )\n    );\n    TimeseriesQuery query = Druids.newTimeseriesQueryBuilder()\n                                  .dataSource(\"test\")\n                                  .intervals(\"2014/2015\")\n                                  .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n                                  .context(ImmutableMap.of(QueryContexts.TIMEOUT_KEY, 100, \"queryId\", \"test\"))\n                                  .build();\n    final Sequence seq = chainedRunner.run(QueryPlus.wrap(query));\n\n    Future resultFuture = Executors.newFixedThreadPool(1).submit(\n        new Runnable()\n        {\n          @Override\n          public void run()\n          {\n            seq.toList();\n          }\n        }\n    );\n\n    \r\n    queryIsRegistered.await();\n    queriesStarted.await();\n\n    Assert.assertTrue(capturedFuture.hasCaptured());\n    ListenableFuture future = capturedFuture.getValue();\n\n    \r\n    QueryTimeoutException cause = null;\n    try {\n      resultFuture.get();\n    }\n    catch (ExecutionException e) {\n      Assert.assertTrue(e.getCause() instanceof QueryTimeoutException);\n      Assert.assertEquals(\"Query timeout\", ((QueryTimeoutException) e.getCause()).getErrorCode());\n      cause = (QueryTimeoutException) e.getCause();\n    }\n    queriesInterrupted.await();\n    Assert.assertNotNull(cause);\n    Assert.assertTrue(future.isCancelled());\n\n    DyingQueryRunner interrupted1 = interrupted.poll();\n    synchronized (interrupted1) {\n      Assert.assertTrue(\"runner 1 started\", interrupted1.hasStarted);\n      Assert.assertTrue(\"runner 1 interrupted\", interrupted1.interrupted);\n    }\n    DyingQueryRunner interrupted2 = interrupted.poll();\n    synchronized (interrupted2) {\n      Assert.assertTrue(\"runner 2 started\", interrupted2.hasStarted);\n      Assert.assertTrue(\"runner 2 interrupted\", interrupted2.interrupted);\n    }\n    runners.remove(interrupted1);\n    runners.remove(interrupted2);\n    DyingQueryRunner remainingRunner = runners.iterator().next();\n    synchronized (remainingRunner) {\n      Assert.assertTrue(\"runner 3 should be interrupted or not have started\",\n                        !remainingRunner.hasStarted || remainingRunner.interrupted);\n    }\n    Assert.assertFalse(\"runner 1 not completed\", interrupted1.hasCompleted);\n    Assert.assertFalse(\"runner 2 not completed\", interrupted2.hasCompleted);\n    Assert.assertFalse(\"runner 3 not completed\", remainingRunner.hasCompleted);\n\n    EasyMock.verify(watcher);\n  }\n","date":"2021-07-01 18:33:08","endLine":315,"groupId":"106247","id":12,"instanceNumber":2,"isCurCommit":1,"methodName":"testQueryTimeout","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/b1/b5084a70c0f3ad7612433afed47a81c1a15383.src","preCode":"  public void testQueryTimeout() throws Exception\n  {\n    ExecutorService exec = PrioritizedExecutorService.create(\n        new Lifecycle(), new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return \"test\";\n          }\n\n          @Override\n          public int getNumThreads()\n          {\n            return 2;\n          }\n        }\n    );\n\n    final CountDownLatch queriesStarted = new CountDownLatch(2);\n    final CountDownLatch queriesInterrupted = new CountDownLatch(2);\n    final CountDownLatch queryIsRegistered = new CountDownLatch(1);\n\n    Capture<ListenableFuture> capturedFuture = Capture.newInstance();\n    QueryWatcher watcher = EasyMock.createStrictMock(QueryWatcher.class);\n    watcher.registerQueryFuture(\n        EasyMock.anyObject(),\n        EasyMock.and(EasyMock.anyObject(), EasyMock.capture(capturedFuture))\n    );\n    EasyMock.expectLastCall()\n            .andAnswer(\n                new IAnswer<Void>()\n                {\n                  @Override\n                  public Void answer()\n                  {\n                    queryIsRegistered.countDown();\n                    return null;\n                  }\n                }\n            )\n            .once();\n\n    EasyMock.replay(watcher);\n\n\n    ArrayBlockingQueue<DyingQueryRunner> interrupted = new ArrayBlockingQueue<>(3);\n    Set<DyingQueryRunner> runners = Sets.newHashSet(\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted),\n        new DyingQueryRunner(queriesStarted, queriesInterrupted, interrupted)\n    );\n\n    ChainedExecutionQueryRunner chainedRunner = new ChainedExecutionQueryRunner<>(\n        exec,\n        watcher,\n        Lists.newArrayList(\n            runners\n        )\n    );\n    TimeseriesQuery query = Druids.newTimeseriesQueryBuilder()\n                                  .dataSource(\"test\")\n                                  .intervals(\"2014/2015\")\n                                  .aggregators(Collections.singletonList(new CountAggregatorFactory(\"count\")))\n                                  .context(ImmutableMap.of(QueryContexts.TIMEOUT_KEY, 100, \"queryId\", \"test\"))\n                                  .build();\n    final Sequence seq = chainedRunner.run(QueryPlus.wrap(query));\n\n    Future resultFuture = Executors.newFixedThreadPool(1).submit(\n        new Runnable()\n        {\n          @Override\n          public void run()\n          {\n            seq.toList();\n          }\n        }\n    );\n\n    \r\n    queryIsRegistered.await();\n    queriesStarted.await();\n\n    Assert.assertTrue(capturedFuture.hasCaptured());\n    ListenableFuture future = capturedFuture.getValue();\n\n    \r\n    QueryTimeoutException cause = null;\n    try {\n      resultFuture.get();\n    }\n    catch (ExecutionException e) {\n      Assert.assertTrue(e.getCause() instanceof QueryTimeoutException);\n      Assert.assertEquals(\"Query timeout\", ((QueryTimeoutException) e.getCause()).getErrorCode());\n      cause = (QueryTimeoutException) e.getCause();\n    }\n    queriesInterrupted.await();\n    Assert.assertNotNull(cause);\n    Assert.assertTrue(future.isCancelled());\n\n    DyingQueryRunner interrupted1 = interrupted.poll();\n    synchronized (interrupted1) {\n      Assert.assertTrue(\"runner 1 started\", interrupted1.hasStarted);\n      Assert.assertTrue(\"runner 1 interrupted\", interrupted1.interrupted);\n    }\n    DyingQueryRunner interrupted2 = interrupted.poll();\n    synchronized (interrupted2) {\n      Assert.assertTrue(\"runner 2 started\", interrupted2.hasStarted);\n      Assert.assertTrue(\"runner 2 interrupted\", interrupted2.interrupted);\n    }\n    runners.remove(interrupted1);\n    runners.remove(interrupted2);\n    DyingQueryRunner remainingRunner = runners.iterator().next();\n    synchronized (remainingRunner) {\n      Assert.assertTrue(\"runner 3 should be interrupted or not have started\",\n                        !remainingRunner.hasStarted || remainingRunner.interrupted);\n    }\n    Assert.assertFalse(\"runner 1 not completed\", interrupted1.hasCompleted);\n    Assert.assertFalse(\"runner 2 not completed\", interrupted2.hasCompleted);\n    Assert.assertFalse(\"runner 3 not completed\", remainingRunner.hasCompleted);\n\n    EasyMock.verify(watcher);\n  }\n","realPath":"processing/src/test/java/org/apache/druid/query/ChainedExecutionQueryRunnerTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":193,"status":"M"}],"commitId":"03a6a6d6e1f7024c2691e6fef0685bd137d223e7","commitMessage":"@@@Replace Processing ExecutorService with QueryProcessingPool (#11382)\n\nThis PR refactors the code for QueryRunnerFactory#mergeRunners to accept a new interface called QueryProcessingPool instead of ExecutorService for concurrent execution of query runners. This interface will let custom extensions inject their own implementation for deciding which query-runner to prioritize first. The default implementation is the same as today that takes the priority of query into account. QueryProcessingPool can also be used as a regular executor service. It has a dedicated method for accepting query execution work so implementations can differentiate between regular async tasks and query execution tasks. This dedicated method also passes the QueryRunner object as part of the task information. This hook will let custom extensions carry any state from QuerySegmentWalker to QueryProcessingPool#mergeRunners which is not possible currently.","date":"2021-07-01 18:33:08","modifiedFileCount":"52","status":"M","submitter":"Abhishek Agarwal"}]
