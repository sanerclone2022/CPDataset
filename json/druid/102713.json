[{"authorTime":"2019-06-11 00:40:09","codes":[{"authorDate":"2019-06-11 00:40:09","commitOrder":1,"curCode":"  public void testVarPop() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"VAR_POP(d1),\\n\"\n                       + \"VAR_POP(f1),\\n\"\n                       + \"VAR_POP(l1)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        sqlLifecycle.runSimple(sql, BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n\n    VarianceAggregatorCollector holder1 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder2 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder3 = new VarianceAggregatorCollector();\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      Object raw1 = row.getRaw(\"d1\");\n      Object raw2 = row.getRaw(\"f1\");\n      Object raw3 = row.getRaw(\"l1\");\n      addToHolder(holder1, raw1);\n      addToHolder(holder2, raw2);\n      addToHolder(holder3, raw3);\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            holder1.getVariance(true),\n            (float) holder2.getVariance(true),\n            (long) holder3.getVariance(true),\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n        .dataSource(CalciteTests.DATASOURCE3)\n        .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n        .granularity(Granularities.ALL)\n        .aggregators(\n            ImmutableList.of(\n              new VarianceAggregatorFactory(\"a0:agg\", \"d1\", \"population\", \"float\"),\n              new VarianceAggregatorFactory(\"a1:agg\", \"f1\", \"population\", \"float\"),\n              new VarianceAggregatorFactory(\"a2:agg\", \"l1\", \"population\", \"long\")\n            )\n        )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","date":"2019-06-11 00:40:09","endLine":274,"groupId":"1911","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testVarPop","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/50/b7177392cdbb404e31dd8782adca623aa1c81d.src","preCode":"  public void testVarPop() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"VAR_POP(d1),\\n\"\n                       + \"VAR_POP(f1),\\n\"\n                       + \"VAR_POP(l1)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        sqlLifecycle.runSimple(sql, BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n\n    VarianceAggregatorCollector holder1 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder2 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder3 = new VarianceAggregatorCollector();\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      Object raw1 = row.getRaw(\"d1\");\n      Object raw2 = row.getRaw(\"f1\");\n      Object raw3 = row.getRaw(\"l1\");\n      addToHolder(holder1, raw1);\n      addToHolder(holder2, raw2);\n      addToHolder(holder3, raw3);\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            holder1.getVariance(true),\n            (float) holder2.getVariance(true),\n            (long) holder3.getVariance(true),\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n        .dataSource(CalciteTests.DATASOURCE3)\n        .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n        .granularity(Granularities.ALL)\n        .aggregators(\n            ImmutableList.of(\n              new VarianceAggregatorFactory(\"a0:agg\", \"d1\", \"population\", \"float\"),\n              new VarianceAggregatorFactory(\"a1:agg\", \"f1\", \"population\", \"float\"),\n              new VarianceAggregatorFactory(\"a2:agg\", \"l1\", \"population\", \"long\")\n            )\n        )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","realPath":"extensions-core/stats/src/test/java/org/apache/druid/query/aggregation/variance/sql/VarianceSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":222,"status":"B"},{"authorDate":"2019-06-11 00:40:09","commitOrder":1,"curCode":"  public void testStdDevPop() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"STDDEV_POP(d1),\\n\"\n                       + \"STDDEV_POP(f1),\\n\"\n                       + \"STDDEV_POP(l1)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        sqlLifecycle.runSimple(sql, BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n\n    VarianceAggregatorCollector holder1 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder2 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder3 = new VarianceAggregatorCollector();\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      Object raw1 = row.getRaw(\"d1\");\n      Object raw2 = row.getRaw(\"f1\");\n      Object raw3 = row.getRaw(\"l1\");\n      addToHolder(holder1, raw1);\n      addToHolder(holder2, raw2);\n      addToHolder(holder3, raw3);\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            Math.sqrt(holder1.getVariance(true)),\n            (float) Math.sqrt(holder2.getVariance(true)),\n            (long) Math.sqrt(holder3.getVariance(true)),\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n        .dataSource(CalciteTests.DATASOURCE3)\n        .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n        .granularity(Granularities.ALL)\n        .aggregators(\n            ImmutableList.of(\n              new VarianceAggregatorFactory(\"a0:agg\", \"d1\", \"population\", \"float\"),\n              new VarianceAggregatorFactory(\"a1:agg\", \"f1\", \"population\", \"float\"),\n              new VarianceAggregatorFactory(\"a2:agg\", \"l1\", \"population\", \"long\")\n            )\n        )\n        .postAggregators(\n            ImmutableList.of(\n            new StandardDeviationPostAggregator(\"a0\", \"a0:agg\", \"population\"),\n            new StandardDeviationPostAggregator(\"a1\", \"a1:agg\", \"population\"),\n            new StandardDeviationPostAggregator(\"a2\", \"a2:agg\", \"population\"))\n        )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","date":"2019-06-11 00:40:09","endLine":390,"groupId":"3657","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testStdDevPop","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/50/b7177392cdbb404e31dd8782adca623aa1c81d.src","preCode":"  public void testStdDevPop() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"STDDEV_POP(d1),\\n\"\n                       + \"STDDEV_POP(f1),\\n\"\n                       + \"STDDEV_POP(l1)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        sqlLifecycle.runSimple(sql, BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n\n    VarianceAggregatorCollector holder1 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder2 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder3 = new VarianceAggregatorCollector();\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      Object raw1 = row.getRaw(\"d1\");\n      Object raw2 = row.getRaw(\"f1\");\n      Object raw3 = row.getRaw(\"l1\");\n      addToHolder(holder1, raw1);\n      addToHolder(holder2, raw2);\n      addToHolder(holder3, raw3);\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            Math.sqrt(holder1.getVariance(true)),\n            (float) Math.sqrt(holder2.getVariance(true)),\n            (long) Math.sqrt(holder3.getVariance(true)),\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n        .dataSource(CalciteTests.DATASOURCE3)\n        .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n        .granularity(Granularities.ALL)\n        .aggregators(\n            ImmutableList.of(\n              new VarianceAggregatorFactory(\"a0:agg\", \"d1\", \"population\", \"float\"),\n              new VarianceAggregatorFactory(\"a1:agg\", \"f1\", \"population\", \"float\"),\n              new VarianceAggregatorFactory(\"a2:agg\", \"l1\", \"population\", \"long\")\n            )\n        )\n        .postAggregators(\n            ImmutableList.of(\n            new StandardDeviationPostAggregator(\"a0\", \"a0:agg\", \"population\"),\n            new StandardDeviationPostAggregator(\"a1\", \"a1:agg\", \"population\"),\n            new StandardDeviationPostAggregator(\"a2\", \"a2:agg\", \"population\"))\n        )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","realPath":"extensions-core/stats/src/test/java/org/apache/druid/query/aggregation/variance/sql/VarianceSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":332,"status":"B"}],"commitId":"ce591d14574cf0cb81d83ddf405a446aeee7648f","commitMessage":"@@@Support var_pop.  var_samp.  stddev_pop and stddev_samp etc in sql (#7801)\n\n* support var_pop.  stddev_pop etc in sql\n\n* fix sql compatible\n\n* rebase on master\n\n* update doc\n","date":"2019-06-11 00:40:09","modifiedFileCount":"4","status":"B","submitter":"Xue Yu"},{"authorTime":"2020-02-13 01:32:42","codes":[{"authorDate":"2020-02-13 01:32:42","commitOrder":2,"curCode":"  public void testVarPop() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"VAR_POP(d1),\\n\"\n                       + \"VAR_POP(f1),\\n\"\n                       + \"VAR_POP(l1)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        sqlLifecycle.runSimple(sql, BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n\n    VarianceAggregatorCollector holder1 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder2 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder3 = new VarianceAggregatorCollector();\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      Object raw1 = row.getRaw(\"d1\");\n      Object raw2 = row.getRaw(\"f1\");\n      Object raw3 = row.getRaw(\"l1\");\n      addToHolder(holder1, raw1);\n      addToHolder(holder2, raw2);\n      addToHolder(holder3, raw3);\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            holder1.getVariance(true),\n            (float) holder2.getVariance(true),\n            (long) holder3.getVariance(true),\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n        .dataSource(CalciteTests.DATASOURCE3)\n        .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n        .granularity(Granularities.ALL)\n        .aggregators(\n            ImmutableList.of(\n              new VarianceAggregatorFactory(\"a0:agg\", \"d1\", \"population\", \"double\"),\n              new VarianceAggregatorFactory(\"a1:agg\", \"f1\", \"population\", \"float\"),\n              new VarianceAggregatorFactory(\"a2:agg\", \"l1\", \"population\", \"long\")\n            )\n        )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","date":"2020-02-13 01:32:42","endLine":275,"groupId":"1911","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testVarPop","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/19/2788fed357e661c54fb3fd07768162e60fd697.src","preCode":"  public void testVarPop() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"VAR_POP(d1),\\n\"\n                       + \"VAR_POP(f1),\\n\"\n                       + \"VAR_POP(l1)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        sqlLifecycle.runSimple(sql, BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n\n    VarianceAggregatorCollector holder1 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder2 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder3 = new VarianceAggregatorCollector();\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      Object raw1 = row.getRaw(\"d1\");\n      Object raw2 = row.getRaw(\"f1\");\n      Object raw3 = row.getRaw(\"l1\");\n      addToHolder(holder1, raw1);\n      addToHolder(holder2, raw2);\n      addToHolder(holder3, raw3);\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            holder1.getVariance(true),\n            (float) holder2.getVariance(true),\n            (long) holder3.getVariance(true),\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n        .dataSource(CalciteTests.DATASOURCE3)\n        .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n        .granularity(Granularities.ALL)\n        .aggregators(\n            ImmutableList.of(\n              new VarianceAggregatorFactory(\"a0:agg\", \"d1\", \"population\", \"float\"),\n              new VarianceAggregatorFactory(\"a1:agg\", \"f1\", \"population\", \"float\"),\n              new VarianceAggregatorFactory(\"a2:agg\", \"l1\", \"population\", \"long\")\n            )\n        )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","realPath":"extensions-core/stats/src/test/java/org/apache/druid/query/aggregation/variance/sql/VarianceSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":223,"status":"M"},{"authorDate":"2020-02-13 01:32:42","commitOrder":2,"curCode":"  public void testStdDevPop() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"STDDEV_POP(d1),\\n\"\n                       + \"STDDEV_POP(f1),\\n\"\n                       + \"STDDEV_POP(l1)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        sqlLifecycle.runSimple(sql, BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n\n    VarianceAggregatorCollector holder1 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder2 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder3 = new VarianceAggregatorCollector();\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      Object raw1 = row.getRaw(\"d1\");\n      Object raw2 = row.getRaw(\"f1\");\n      Object raw3 = row.getRaw(\"l1\");\n      addToHolder(holder1, raw1);\n      addToHolder(holder2, raw2);\n      addToHolder(holder3, raw3);\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            Math.sqrt(holder1.getVariance(true)),\n            (float) Math.sqrt(holder2.getVariance(true)),\n            (long) Math.sqrt(holder3.getVariance(true)),\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n        .dataSource(CalciteTests.DATASOURCE3)\n        .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n        .granularity(Granularities.ALL)\n        .aggregators(\n            ImmutableList.of(\n              new VarianceAggregatorFactory(\"a0:agg\", \"d1\", \"population\", \"double\"),\n              new VarianceAggregatorFactory(\"a1:agg\", \"f1\", \"population\", \"float\"),\n              new VarianceAggregatorFactory(\"a2:agg\", \"l1\", \"population\", \"long\")\n            )\n        )\n        .postAggregators(\n            ImmutableList.of(\n            new StandardDeviationPostAggregator(\"a0\", \"a0:agg\", \"population\"),\n            new StandardDeviationPostAggregator(\"a1\", \"a1:agg\", \"population\"),\n            new StandardDeviationPostAggregator(\"a2\", \"a2:agg\", \"population\"))\n        )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","date":"2020-02-13 01:32:42","endLine":391,"groupId":"3657","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testStdDevPop","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/19/2788fed357e661c54fb3fd07768162e60fd697.src","preCode":"  public void testStdDevPop() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"STDDEV_POP(d1),\\n\"\n                       + \"STDDEV_POP(f1),\\n\"\n                       + \"STDDEV_POP(l1)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        sqlLifecycle.runSimple(sql, BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n\n    VarianceAggregatorCollector holder1 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder2 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder3 = new VarianceAggregatorCollector();\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      Object raw1 = row.getRaw(\"d1\");\n      Object raw2 = row.getRaw(\"f1\");\n      Object raw3 = row.getRaw(\"l1\");\n      addToHolder(holder1, raw1);\n      addToHolder(holder2, raw2);\n      addToHolder(holder3, raw3);\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            Math.sqrt(holder1.getVariance(true)),\n            (float) Math.sqrt(holder2.getVariance(true)),\n            (long) Math.sqrt(holder3.getVariance(true)),\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n        .dataSource(CalciteTests.DATASOURCE3)\n        .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n        .granularity(Granularities.ALL)\n        .aggregators(\n            ImmutableList.of(\n              new VarianceAggregatorFactory(\"a0:agg\", \"d1\", \"population\", \"float\"),\n              new VarianceAggregatorFactory(\"a1:agg\", \"f1\", \"population\", \"float\"),\n              new VarianceAggregatorFactory(\"a2:agg\", \"l1\", \"population\", \"long\")\n            )\n        )\n        .postAggregators(\n            ImmutableList.of(\n            new StandardDeviationPostAggregator(\"a0\", \"a0:agg\", \"population\"),\n            new StandardDeviationPostAggregator(\"a1\", \"a1:agg\", \"population\"),\n            new StandardDeviationPostAggregator(\"a2\", \"a2:agg\", \"population\"))\n        )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","realPath":"extensions-core/stats/src/test/java/org/apache/druid/query/aggregation/variance/sql/VarianceSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":333,"status":"M"}],"commitId":"c3ebb5eb650d7d71fdf2a096b6678e485f6ca92a","commitMessage":"@@@variance aggregator support for double columns (#9076)\n\n* variance aggregator support for double column instead of casting to float\n\n* docs\n\n* everything in its right place\n\n* checkstyle\n\n* adjustments\n","date":"2020-02-13 01:32:42","modifiedFileCount":"7","status":"M","submitter":"Clint Wylie"},{"authorTime":"2020-02-20 05:09:20","codes":[{"authorDate":"2020-02-20 05:09:20","commitOrder":3,"curCode":"  public void testVarPop() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"VAR_POP(d1),\\n\"\n                       + \"VAR_POP(f1),\\n\"\n                       + \"VAR_POP(l1)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        sqlLifecycle.runSimple(\n            sql,\n            BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT,\n            CalciteTestBase.DEFAULT_PARAMETERS,\n            authenticationResult\n        ).toList();\n\n    VarianceAggregatorCollector holder1 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder2 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder3 = new VarianceAggregatorCollector();\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      Object raw1 = row.getRaw(\"d1\");\n      Object raw2 = row.getRaw(\"f1\");\n      Object raw3 = row.getRaw(\"l1\");\n      addToHolder(holder1, raw1);\n      addToHolder(holder2, raw2);\n      addToHolder(holder3, raw3);\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            holder1.getVariance(true),\n            (float) holder2.getVariance(true),\n            (long) holder3.getVariance(true),\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n        .dataSource(CalciteTests.DATASOURCE3)\n        .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n        .granularity(Granularities.ALL)\n        .aggregators(\n            ImmutableList.of(\n              new VarianceAggregatorFactory(\"a0:agg\", \"d1\", \"population\", \"double\"),\n              new VarianceAggregatorFactory(\"a1:agg\", \"f1\", \"population\", \"float\"),\n              new VarianceAggregatorFactory(\"a2:agg\", \"l1\", \"population\", \"long\")\n            )\n        )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","date":"2020-02-20 05:09:20","endLine":281,"groupId":"1911","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testVarPop","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/56/866d4662b082b6b32af2743892537c4203c795.src","preCode":"  public void testVarPop() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"VAR_POP(d1),\\n\"\n                       + \"VAR_POP(f1),\\n\"\n                       + \"VAR_POP(l1)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        sqlLifecycle.runSimple(sql, BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n\n    VarianceAggregatorCollector holder1 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder2 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder3 = new VarianceAggregatorCollector();\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      Object raw1 = row.getRaw(\"d1\");\n      Object raw2 = row.getRaw(\"f1\");\n      Object raw3 = row.getRaw(\"l1\");\n      addToHolder(holder1, raw1);\n      addToHolder(holder2, raw2);\n      addToHolder(holder3, raw3);\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            holder1.getVariance(true),\n            (float) holder2.getVariance(true),\n            (long) holder3.getVariance(true),\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n        .dataSource(CalciteTests.DATASOURCE3)\n        .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n        .granularity(Granularities.ALL)\n        .aggregators(\n            ImmutableList.of(\n              new VarianceAggregatorFactory(\"a0:agg\", \"d1\", \"population\", \"double\"),\n              new VarianceAggregatorFactory(\"a1:agg\", \"f1\", \"population\", \"float\"),\n              new VarianceAggregatorFactory(\"a2:agg\", \"l1\", \"population\", \"long\")\n            )\n        )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","realPath":"extensions-core/stats/src/test/java/org/apache/druid/query/aggregation/variance/sql/VarianceSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":224,"status":"M"},{"authorDate":"2020-02-20 05:09:20","commitOrder":3,"curCode":"  public void testStdDevPop() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"STDDEV_POP(d1),\\n\"\n                       + \"STDDEV_POP(f1),\\n\"\n                       + \"STDDEV_POP(l1)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        sqlLifecycle.runSimple(\n            sql,\n            BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT,\n            CalciteTestBase.DEFAULT_PARAMETERS,\n            authenticationResult\n        ).toList();\n\n    VarianceAggregatorCollector holder1 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder2 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder3 = new VarianceAggregatorCollector();\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      Object raw1 = row.getRaw(\"d1\");\n      Object raw2 = row.getRaw(\"f1\");\n      Object raw3 = row.getRaw(\"l1\");\n      addToHolder(holder1, raw1);\n      addToHolder(holder2, raw2);\n      addToHolder(holder3, raw3);\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            Math.sqrt(holder1.getVariance(true)),\n            (float) Math.sqrt(holder2.getVariance(true)),\n            (long) Math.sqrt(holder3.getVariance(true)),\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n        .dataSource(CalciteTests.DATASOURCE3)\n        .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n        .granularity(Granularities.ALL)\n        .aggregators(\n            ImmutableList.of(\n              new VarianceAggregatorFactory(\"a0:agg\", \"d1\", \"population\", \"double\"),\n              new VarianceAggregatorFactory(\"a1:agg\", \"f1\", \"population\", \"float\"),\n              new VarianceAggregatorFactory(\"a2:agg\", \"l1\", \"population\", \"long\")\n            )\n        )\n        .postAggregators(\n            ImmutableList.of(\n            new StandardDeviationPostAggregator(\"a0\", \"a0:agg\", \"population\"),\n            new StandardDeviationPostAggregator(\"a1\", \"a1:agg\", \"population\"),\n            new StandardDeviationPostAggregator(\"a2\", \"a2:agg\", \"population\"))\n        )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","date":"2020-02-20 05:09:20","endLine":407,"groupId":"3657","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testStdDevPop","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/56/866d4662b082b6b32af2743892537c4203c795.src","preCode":"  public void testStdDevPop() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"STDDEV_POP(d1),\\n\"\n                       + \"STDDEV_POP(f1),\\n\"\n                       + \"STDDEV_POP(l1)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        sqlLifecycle.runSimple(sql, BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT, authenticationResult).toList();\n\n    VarianceAggregatorCollector holder1 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder2 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder3 = new VarianceAggregatorCollector();\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      Object raw1 = row.getRaw(\"d1\");\n      Object raw2 = row.getRaw(\"f1\");\n      Object raw3 = row.getRaw(\"l1\");\n      addToHolder(holder1, raw1);\n      addToHolder(holder2, raw2);\n      addToHolder(holder3, raw3);\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            Math.sqrt(holder1.getVariance(true)),\n            (float) Math.sqrt(holder2.getVariance(true)),\n            (long) Math.sqrt(holder3.getVariance(true)),\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n        .dataSource(CalciteTests.DATASOURCE3)\n        .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n        .granularity(Granularities.ALL)\n        .aggregators(\n            ImmutableList.of(\n              new VarianceAggregatorFactory(\"a0:agg\", \"d1\", \"population\", \"double\"),\n              new VarianceAggregatorFactory(\"a1:agg\", \"f1\", \"population\", \"float\"),\n              new VarianceAggregatorFactory(\"a2:agg\", \"l1\", \"population\", \"long\")\n            )\n        )\n        .postAggregators(\n            ImmutableList.of(\n            new StandardDeviationPostAggregator(\"a0\", \"a0:agg\", \"population\"),\n            new StandardDeviationPostAggregator(\"a1\", \"a1:agg\", \"population\"),\n            new StandardDeviationPostAggregator(\"a2\", \"a2:agg\", \"population\"))\n        )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","realPath":"extensions-core/stats/src/test/java/org/apache/druid/query/aggregation/variance/sql/VarianceSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":344,"status":"M"}],"commitId":"b408a6d774e43e574bf8092584fae76d582cfd8f","commitMessage":"@@@sql support for dynamic parameters (#6974)\n\n* sql support for dynamic parameters\n\n* fixup\n\n* javadocs\n\n* fixup from merge\n\n* formatting\n\n* fixes\n\n* fix it\n\n* doc fix\n\n* remove druid fallback self-join parameterized test\n\n* unused imports\n\n* ignore test for now\n\n* fix imports\n\n* fixup\n\n* fix merge\n\n* merge fixup\n\n* fix test that cannot vectorize\n\n* fixup and more better\n\n* dependency thingo\n\n* fix docs\n\n* tweaks\n\n* fix docs\n\n* spelling\n\n* unused imports after merge\n\n* review stuffs\n\n* add comment\n\n* add ignore text\n\n* review stuffs\n","date":"2020-02-20 05:09:20","modifiedFileCount":"32","status":"M","submitter":"Clint Wylie"},{"authorTime":"2020-09-04 08:38:37","codes":[{"authorDate":"2020-09-04 08:38:37","commitOrder":4,"curCode":"  public void testVarPop() throws Exception\n  {\n    final String sql = \"SELECT\\n\"\n                       + \"VAR_POP(d1),\\n\"\n                       + \"VAR_POP(f1),\\n\"\n                       + \"VAR_POP(l1)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        sqlLifecycle.runSimple(\n            sql,\n            BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT,\n            CalciteTestBase.DEFAULT_PARAMETERS,\n            authenticationResult\n        ).toList();\n\n    VarianceAggregatorCollector holder1 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder2 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder3 = new VarianceAggregatorCollector();\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      Object raw1 = row.getRaw(\"d1\");\n      Object raw2 = row.getRaw(\"f1\");\n      Object raw3 = row.getRaw(\"l1\");\n      addToHolder(holder1, raw1);\n      addToHolder(holder2, raw2);\n      addToHolder(holder3, raw3);\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            holder1.getVariance(true),\n            holder2.getVariance(true).floatValue(),\n            holder3.getVariance(true).longValue()\n        }\n    );\n    assertResultsEquals(expectedResults, results);\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n        .dataSource(CalciteTests.DATASOURCE3)\n        .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n        .granularity(Granularities.ALL)\n        .aggregators(\n            ImmutableList.of(\n              new VarianceAggregatorFactory(\"a0:agg\", \"d1\", \"population\", \"double\"),\n              new VarianceAggregatorFactory(\"a1:agg\", \"f1\", \"population\", \"float\"),\n              new VarianceAggregatorFactory(\"a2:agg\", \"l1\", \"population\", \"long\")\n            )\n        )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","date":"2020-09-04 08:38:37","endLine":302,"groupId":"21732","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testVarPop","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/cf/b945b99cc56036adaa9a429bbcb4408394fc9c.src","preCode":"  public void testVarPop() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"VAR_POP(d1),\\n\"\n                       + \"VAR_POP(f1),\\n\"\n                       + \"VAR_POP(l1)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        sqlLifecycle.runSimple(\n            sql,\n            BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT,\n            CalciteTestBase.DEFAULT_PARAMETERS,\n            authenticationResult\n        ).toList();\n\n    VarianceAggregatorCollector holder1 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder2 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder3 = new VarianceAggregatorCollector();\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      Object raw1 = row.getRaw(\"d1\");\n      Object raw2 = row.getRaw(\"f1\");\n      Object raw3 = row.getRaw(\"l1\");\n      addToHolder(holder1, raw1);\n      addToHolder(holder2, raw2);\n      addToHolder(holder3, raw3);\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            holder1.getVariance(true),\n            (float) holder2.getVariance(true),\n            (long) holder3.getVariance(true),\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n        .dataSource(CalciteTests.DATASOURCE3)\n        .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n        .granularity(Granularities.ALL)\n        .aggregators(\n            ImmutableList.of(\n              new VarianceAggregatorFactory(\"a0:agg\", \"d1\", \"population\", \"double\"),\n              new VarianceAggregatorFactory(\"a1:agg\", \"f1\", \"population\", \"float\"),\n              new VarianceAggregatorFactory(\"a2:agg\", \"l1\", \"population\", \"long\")\n            )\n        )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","realPath":"extensions-core/stats/src/test/java/org/apache/druid/query/aggregation/variance/sql/VarianceSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":249,"status":"M"},{"authorDate":"2020-09-04 08:38:37","commitOrder":4,"curCode":"  public void testStdDevPop() throws Exception\n  {\n    final String sql = \"SELECT\\n\"\n                       + \"STDDEV_POP(d1),\\n\"\n                       + \"STDDEV_POP(f1),\\n\"\n                       + \"STDDEV_POP(l1)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        sqlLifecycle.runSimple(\n            sql,\n            BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT,\n            CalciteTestBase.DEFAULT_PARAMETERS,\n            authenticationResult\n        ).toList();\n\n    VarianceAggregatorCollector holder1 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder2 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder3 = new VarianceAggregatorCollector();\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      Object raw1 = row.getRaw(\"d1\");\n      Object raw2 = row.getRaw(\"f1\");\n      Object raw3 = row.getRaw(\"l1\");\n      addToHolder(holder1, raw1);\n      addToHolder(holder2, raw2);\n      addToHolder(holder3, raw3);\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            Math.sqrt(holder1.getVariance(true)),\n            (float) Math.sqrt(holder2.getVariance(true)),\n            (long) Math.sqrt(holder3.getVariance(true)),\n        }\n    );\n    assertResultsEquals(expectedResults, results);\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n        .dataSource(CalciteTests.DATASOURCE3)\n        .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n        .granularity(Granularities.ALL)\n        .aggregators(\n            ImmutableList.of(\n              new VarianceAggregatorFactory(\"a0:agg\", \"d1\", \"population\", \"double\"),\n              new VarianceAggregatorFactory(\"a1:agg\", \"f1\", \"population\", \"float\"),\n              new VarianceAggregatorFactory(\"a2:agg\", \"l1\", \"population\", \"long\")\n            )\n        )\n        .postAggregators(\n            ImmutableList.of(\n            new StandardDeviationPostAggregator(\"a0\", \"a0:agg\", \"population\"),\n            new StandardDeviationPostAggregator(\"a1\", \"a1:agg\", \"population\"),\n            new StandardDeviationPostAggregator(\"a2\", \"a2:agg\", \"population\"))\n        )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","date":"2020-09-04 08:38:37","endLine":420,"groupId":"11004","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testStdDevPop","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/cf/b945b99cc56036adaa9a429bbcb4408394fc9c.src","preCode":"  public void testStdDevPop() throws Exception\n  {\n    SqlLifecycle sqlLifecycle = sqlLifecycleFactory.factorize();\n    final String sql = \"SELECT\\n\"\n                       + \"STDDEV_POP(d1),\\n\"\n                       + \"STDDEV_POP(f1),\\n\"\n                       + \"STDDEV_POP(l1)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        sqlLifecycle.runSimple(\n            sql,\n            BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT,\n            CalciteTestBase.DEFAULT_PARAMETERS,\n            authenticationResult\n        ).toList();\n\n    VarianceAggregatorCollector holder1 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder2 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder3 = new VarianceAggregatorCollector();\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      Object raw1 = row.getRaw(\"d1\");\n      Object raw2 = row.getRaw(\"f1\");\n      Object raw3 = row.getRaw(\"l1\");\n      addToHolder(holder1, raw1);\n      addToHolder(holder2, raw2);\n      addToHolder(holder3, raw3);\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            Math.sqrt(holder1.getVariance(true)),\n            (float) Math.sqrt(holder2.getVariance(true)),\n            (long) Math.sqrt(holder3.getVariance(true)),\n        }\n    );\n    Assert.assertEquals(expectedResults.size(), results.size());\n    for (int i = 0; i < expectedResults.size(); i++) {\n      Assert.assertArrayEquals(expectedResults.get(i), results.get(i));\n    }\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n        .dataSource(CalciteTests.DATASOURCE3)\n        .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n        .granularity(Granularities.ALL)\n        .aggregators(\n            ImmutableList.of(\n              new VarianceAggregatorFactory(\"a0:agg\", \"d1\", \"population\", \"double\"),\n              new VarianceAggregatorFactory(\"a1:agg\", \"f1\", \"population\", \"float\"),\n              new VarianceAggregatorFactory(\"a2:agg\", \"l1\", \"population\", \"long\")\n            )\n        )\n        .postAggregators(\n            ImmutableList.of(\n            new StandardDeviationPostAggregator(\"a0\", \"a0:agg\", \"population\"),\n            new StandardDeviationPostAggregator(\"a1\", \"a1:agg\", \"population\"),\n            new StandardDeviationPostAggregator(\"a2\", \"a2:agg\", \"population\"))\n        )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","realPath":"extensions-core/stats/src/test/java/org/apache/druid/query/aggregation/variance/sql/VarianceSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":361,"status":"M"}],"commitId":"a5cd5f1e8404157f1f3ff6bda5ad6bb4cbfa1ff6","commitMessage":"@@@Fix VARIANCE aggregator comparator (#10340)\n\n* Fix VARIANCE aggregator comparator\n\nThe comparator for the variance aggregator used to compare values using the\ncount. This is now fixed to compare values using the variance. If the variance\nis equal.  the count and sum are used as tie breakers.\n\n* fix tests + sql compatible mode\n\n* code review\n\n* more tests\n\n* fix last test","date":"2020-09-04 08:38:37","modifiedFileCount":"8","status":"M","submitter":"Suneet Saldanha"},{"authorTime":"2021-04-13 13:21:24","codes":[{"authorDate":"2021-04-13 13:21:24","commitOrder":5,"curCode":"  public void testVarPop() throws Exception\n  {\n    final String sql = \"SELECT\\n\"\n                       + \"VAR_POP(d1),\\n\"\n                       + \"VAR_POP(f1),\\n\"\n                       + \"VAR_POP(l1)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        getSqlLifecycle().runSimple(\n            sql,\n            BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT,\n            CalciteTestBase.DEFAULT_PARAMETERS,\n            AUTH_RESULT\n        ).toList();\n\n    VarianceAggregatorCollector holder1 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder2 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder3 = new VarianceAggregatorCollector();\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      Object raw1 = row.getRaw(\"d1\");\n      Object raw2 = row.getRaw(\"f1\");\n      Object raw3 = row.getRaw(\"l1\");\n      addToHolder(holder1, raw1);\n      addToHolder(holder2, raw2);\n      addToHolder(holder3, raw3);\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            holder1.getVariance(true),\n            holder2.getVariance(true).floatValue(),\n            holder3.getVariance(true).longValue()\n        }\n    );\n    assertResultsEquals(sql, expectedResults, results);\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(CalciteTests.DATASOURCE3)\n              .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n              .granularity(Granularities.ALL)\n              .aggregators(\n                  ImmutableList.of(\n                      new VarianceAggregatorFactory(\"a0:agg\", \"d1\", \"population\", \"double\"),\n                      new VarianceAggregatorFactory(\"a1:agg\", \"f1\", \"population\", \"float\"),\n                      new VarianceAggregatorFactory(\"a2:agg\", \"l1\", \"population\", \"long\")\n                  )\n              )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","date":"2021-04-13 13:21:24","endLine":245,"groupId":"21732","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testVarPop","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/5e/3b2b206b1feee935aa898b20649555eaae8e0f.src","preCode":"  public void testVarPop() throws Exception\n  {\n    final String sql = \"SELECT\\n\"\n                       + \"VAR_POP(d1),\\n\"\n                       + \"VAR_POP(f1),\\n\"\n                       + \"VAR_POP(l1)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        sqlLifecycle.runSimple(\n            sql,\n            BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT,\n            CalciteTestBase.DEFAULT_PARAMETERS,\n            authenticationResult\n        ).toList();\n\n    VarianceAggregatorCollector holder1 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder2 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder3 = new VarianceAggregatorCollector();\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      Object raw1 = row.getRaw(\"d1\");\n      Object raw2 = row.getRaw(\"f1\");\n      Object raw3 = row.getRaw(\"l1\");\n      addToHolder(holder1, raw1);\n      addToHolder(holder2, raw2);\n      addToHolder(holder3, raw3);\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            holder1.getVariance(true),\n            holder2.getVariance(true).floatValue(),\n            holder3.getVariance(true).longValue()\n        }\n    );\n    assertResultsEquals(expectedResults, results);\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(CalciteTests.DATASOURCE3)\n              .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n              .granularity(Granularities.ALL)\n              .aggregators(\n                  ImmutableList.of(\n                      new VarianceAggregatorFactory(\"a0:agg\", \"d1\", \"population\", \"double\"),\n                      new VarianceAggregatorFactory(\"a1:agg\", \"f1\", \"population\", \"float\"),\n                      new VarianceAggregatorFactory(\"a2:agg\", \"l1\", \"population\", \"long\")\n                  )\n              )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","realPath":"extensions-core/stats/src/test/java/org/apache/druid/query/aggregation/variance/sql/VarianceSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":192,"status":"M"},{"authorDate":"2021-04-13 13:21:24","commitOrder":5,"curCode":"  public void testStdDevPop() throws Exception\n  {\n    final String sql = \"SELECT\\n\"\n                       + \"STDDEV_POP(d1),\\n\"\n                       + \"STDDEV_POP(f1),\\n\"\n                       + \"STDDEV_POP(l1)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        getSqlLifecycle().runSimple(\n            sql,\n            BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT,\n            CalciteTestBase.DEFAULT_PARAMETERS,\n            AUTH_RESULT\n        ).toList();\n\n    VarianceAggregatorCollector holder1 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder2 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder3 = new VarianceAggregatorCollector();\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      Object raw1 = row.getRaw(\"d1\");\n      Object raw2 = row.getRaw(\"f1\");\n      Object raw3 = row.getRaw(\"l1\");\n      addToHolder(holder1, raw1);\n      addToHolder(holder2, raw2);\n      addToHolder(holder3, raw3);\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            Math.sqrt(holder1.getVariance(true)),\n            (float) Math.sqrt(holder2.getVariance(true)),\n            (long) Math.sqrt(holder3.getVariance(true)),\n            }\n    );\n    assertResultsEquals(sql, expectedResults, results);\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(CalciteTests.DATASOURCE3)\n              .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n              .granularity(Granularities.ALL)\n              .aggregators(\n                  ImmutableList.of(\n                      new VarianceAggregatorFactory(\"a0:agg\", \"d1\", \"population\", \"double\"),\n                      new VarianceAggregatorFactory(\"a1:agg\", \"f1\", \"population\", \"float\"),\n                      new VarianceAggregatorFactory(\"a2:agg\", \"l1\", \"population\", \"long\")\n                  )\n              )\n              .postAggregators(\n                  ImmutableList.of(\n                      new StandardDeviationPostAggregator(\"a0\", \"a0:agg\", \"population\"),\n                      new StandardDeviationPostAggregator(\"a1\", \"a1:agg\", \"population\"),\n                      new StandardDeviationPostAggregator(\"a2\", \"a2:agg\", \"population\")\n                  )\n              )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","date":"2021-04-13 13:21:24","endLine":364,"groupId":"11004","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testStdDevPop","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/5e/3b2b206b1feee935aa898b20649555eaae8e0f.src","preCode":"  public void testStdDevPop() throws Exception\n  {\n    final String sql = \"SELECT\\n\"\n                       + \"STDDEV_POP(d1),\\n\"\n                       + \"STDDEV_POP(f1),\\n\"\n                       + \"STDDEV_POP(l1)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        sqlLifecycle.runSimple(\n            sql,\n            BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT,\n            CalciteTestBase.DEFAULT_PARAMETERS,\n            authenticationResult\n        ).toList();\n\n    VarianceAggregatorCollector holder1 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder2 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder3 = new VarianceAggregatorCollector();\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      Object raw1 = row.getRaw(\"d1\");\n      Object raw2 = row.getRaw(\"f1\");\n      Object raw3 = row.getRaw(\"l1\");\n      addToHolder(holder1, raw1);\n      addToHolder(holder2, raw2);\n      addToHolder(holder3, raw3);\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            Math.sqrt(holder1.getVariance(true)),\n            (float) Math.sqrt(holder2.getVariance(true)),\n            (long) Math.sqrt(holder3.getVariance(true)),\n            }\n    );\n    assertResultsEquals(expectedResults, results);\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(CalciteTests.DATASOURCE3)\n              .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n              .granularity(Granularities.ALL)\n              .aggregators(\n                  ImmutableList.of(\n                      new VarianceAggregatorFactory(\"a0:agg\", \"d1\", \"population\", \"double\"),\n                      new VarianceAggregatorFactory(\"a1:agg\", \"f1\", \"population\", \"float\"),\n                      new VarianceAggregatorFactory(\"a2:agg\", \"l1\", \"population\", \"long\")\n                  )\n              )\n              .postAggregators(\n                  ImmutableList.of(\n                      new StandardDeviationPostAggregator(\"a0\", \"a0:agg\", \"population\"),\n                      new StandardDeviationPostAggregator(\"a1\", \"a1:agg\", \"population\"),\n                      new StandardDeviationPostAggregator(\"a2\", \"a2:agg\", \"population\")\n                  )\n              )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","realPath":"extensions-core/stats/src/test/java/org/apache/druid/query/aggregation/variance/sql/VarianceSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":304,"status":"M"}],"commitId":"25db8787b3d7eac87aa3be8e32d48d0e823298af","commitMessage":"@@@Fix CAST being ignored when aggregating on strings after cast (#11083)\n\n* Fix CAST being ignored when aggregating on strings after cast\n\n* fix checkstyle and dependency\n\n* unused import","date":"2021-04-13 13:21:24","modifiedFileCount":"21","status":"M","submitter":"Jihoon Son"},{"authorTime":"2021-05-11 01:13:37","codes":[{"authorDate":"2021-05-11 01:13:37","commitOrder":6,"curCode":"  public void testVarPop() throws Exception\n  {\n    VarianceAggregatorCollector holder1 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder2 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder3 = new VarianceAggregatorCollector();\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      Object raw1 = row.getRaw(\"d1\");\n      Object raw2 = row.getRaw(\"f1\");\n      Object raw3 = row.getRaw(\"l1\");\n      addToHolder(holder1, raw1);\n      addToHolder(holder2, raw2);\n      addToHolder(holder3, raw3);\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            holder1.getVariance(true),\n            holder2.getVariance(true).floatValue(),\n            holder3.getVariance(true).longValue()\n        }\n    );\n    testQuery(\n        \"SELECT\\n\"\n        + \"VAR_POP(d1),\\n\"\n        + \"VAR_POP(f1),\\n\"\n        + \"VAR_POP(l1)\\n\"\n        + \"FROM numfoo\",\n        ImmutableList.of(\n            Druids.newTimeseriesQueryBuilder()\n                  .dataSource(CalciteTests.DATASOURCE3)\n                  .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n                  .granularity(Granularities.ALL)\n                  .aggregators(\n                      ImmutableList.of(\n                          new VarianceAggregatorFactory(\"a0:agg\", \"d1\", \"population\", \"double\"),\n                          new VarianceAggregatorFactory(\"a1:agg\", \"f1\", \"population\", \"float\"),\n                          new VarianceAggregatorFactory(\"a2:agg\", \"l1\", \"population\", \"long\")\n                      )\n                  )\n                  .context(BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT)\n                  .build()\n        ),\n        expectedResults\n    );\n  }\n","date":"2021-05-11 01:13:37","endLine":201,"groupId":"102713","id":11,"instanceNumber":1,"isCurCommit":1,"methodName":"testVarPop","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/e6/7f09f2399e6e4d6b2ae5de7c5714318668e4a9.src","preCode":"  public void testVarPop() throws Exception\n  {\n    final String sql = \"SELECT\\n\"\n                       + \"VAR_POP(d1),\\n\"\n                       + \"VAR_POP(f1),\\n\"\n                       + \"VAR_POP(l1)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        getSqlLifecycle().runSimple(\n            sql,\n            BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT,\n            CalciteTestBase.DEFAULT_PARAMETERS,\n            AUTH_RESULT\n        ).toList();\n\n    VarianceAggregatorCollector holder1 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder2 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder3 = new VarianceAggregatorCollector();\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      Object raw1 = row.getRaw(\"d1\");\n      Object raw2 = row.getRaw(\"f1\");\n      Object raw3 = row.getRaw(\"l1\");\n      addToHolder(holder1, raw1);\n      addToHolder(holder2, raw2);\n      addToHolder(holder3, raw3);\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            holder1.getVariance(true),\n            holder2.getVariance(true).floatValue(),\n            holder3.getVariance(true).longValue()\n        }\n    );\n    assertResultsEquals(sql, expectedResults, results);\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(CalciteTests.DATASOURCE3)\n              .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n              .granularity(Granularities.ALL)\n              .aggregators(\n                  ImmutableList.of(\n                      new VarianceAggregatorFactory(\"a0:agg\", \"d1\", \"population\", \"double\"),\n                      new VarianceAggregatorFactory(\"a1:agg\", \"f1\", \"population\", \"float\"),\n                      new VarianceAggregatorFactory(\"a2:agg\", \"l1\", \"population\", \"long\")\n                  )\n              )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","realPath":"extensions-core/stats/src/test/java/org/apache/druid/query/aggregation/variance/sql/VarianceSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":157,"status":"M"},{"authorDate":"2021-05-11 01:13:37","commitOrder":6,"curCode":"  public void testStdDevPop() throws Exception\n  {\n    VarianceAggregatorCollector holder1 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder2 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder3 = new VarianceAggregatorCollector();\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      Object raw1 = row.getRaw(\"d1\");\n      Object raw2 = row.getRaw(\"f1\");\n      Object raw3 = row.getRaw(\"l1\");\n      addToHolder(holder1, raw1);\n      addToHolder(holder2, raw2);\n      addToHolder(holder3, raw3);\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[] {\n            Math.sqrt(holder1.getVariance(true)),\n            (float) Math.sqrt(holder2.getVariance(true)),\n            (long) Math.sqrt(holder3.getVariance(true)),\n        }\n    );\n\n    testQuery(\n        \"SELECT\\n\"\n        + \"STDDEV_POP(d1),\\n\"\n        + \"STDDEV_POP(f1),\\n\"\n        + \"STDDEV_POP(l1)\\n\"\n        + \"FROM numfoo\",\n        ImmutableList.of(\n            Druids.newTimeseriesQueryBuilder()\n                  .dataSource(CalciteTests.DATASOURCE3)\n                  .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n                  .granularity(Granularities.ALL)\n                  .aggregators(\n                      ImmutableList.of(\n                          new VarianceAggregatorFactory(\"a0:agg\", \"d1\", \"population\", \"double\"),\n                          new VarianceAggregatorFactory(\"a1:agg\", \"f1\", \"population\", \"float\"),\n                          new VarianceAggregatorFactory(\"a2:agg\", \"l1\", \"population\", \"long\")\n                      )\n                  )\n                  .postAggregators(\n                      ImmutableList.of(\n                          new StandardDeviationPostAggregator(\"a0\", \"a0:agg\", \"population\"),\n                          new StandardDeviationPostAggregator(\"a1\", \"a1:agg\", \"population\"),\n                          new StandardDeviationPostAggregator(\"a2\", \"a2:agg\", \"population\")\n                      )\n                  )\n                  .context(BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT)\n                  .build()\n        ),\n        expectedResults\n    );\n  }\n","date":"2021-05-11 01:13:37","endLine":303,"groupId":"102713","id":12,"instanceNumber":2,"isCurCommit":1,"methodName":"testStdDevPop","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/e6/7f09f2399e6e4d6b2ae5de7c5714318668e4a9.src","preCode":"  public void testStdDevPop() throws Exception\n  {\n    final String sql = \"SELECT\\n\"\n                       + \"STDDEV_POP(d1),\\n\"\n                       + \"STDDEV_POP(f1),\\n\"\n                       + \"STDDEV_POP(l1)\\n\"\n                       + \"FROM numfoo\";\n\n    final List<Object[]> results =\n        getSqlLifecycle().runSimple(\n            sql,\n            BaseCalciteQueryTest.QUERY_CONTEXT_DEFAULT,\n            CalciteTestBase.DEFAULT_PARAMETERS,\n            AUTH_RESULT\n        ).toList();\n\n    VarianceAggregatorCollector holder1 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder2 = new VarianceAggregatorCollector();\n    VarianceAggregatorCollector holder3 = new VarianceAggregatorCollector();\n    for (InputRow row : CalciteTests.ROWS1_WITH_NUMERIC_DIMS) {\n      Object raw1 = row.getRaw(\"d1\");\n      Object raw2 = row.getRaw(\"f1\");\n      Object raw3 = row.getRaw(\"l1\");\n      addToHolder(holder1, raw1);\n      addToHolder(holder2, raw2);\n      addToHolder(holder3, raw3);\n    }\n\n    final List<Object[]> expectedResults = ImmutableList.of(\n        new Object[]{\n            Math.sqrt(holder1.getVariance(true)),\n            (float) Math.sqrt(holder2.getVariance(true)),\n            (long) Math.sqrt(holder3.getVariance(true)),\n            }\n    );\n    assertResultsEquals(sql, expectedResults, results);\n\n    Assert.assertEquals(\n        Druids.newTimeseriesQueryBuilder()\n              .dataSource(CalciteTests.DATASOURCE3)\n              .intervals(new MultipleIntervalSegmentSpec(ImmutableList.of(Filtration.eternity())))\n              .granularity(Granularities.ALL)\n              .aggregators(\n                  ImmutableList.of(\n                      new VarianceAggregatorFactory(\"a0:agg\", \"d1\", \"population\", \"double\"),\n                      new VarianceAggregatorFactory(\"a1:agg\", \"f1\", \"population\", \"float\"),\n                      new VarianceAggregatorFactory(\"a2:agg\", \"l1\", \"population\", \"long\")\n                  )\n              )\n              .postAggregators(\n                  ImmutableList.of(\n                      new StandardDeviationPostAggregator(\"a0\", \"a0:agg\", \"population\"),\n                      new StandardDeviationPostAggregator(\"a1\", \"a1:agg\", \"population\"),\n                      new StandardDeviationPostAggregator(\"a2\", \"a2:agg\", \"population\")\n                  )\n              )\n              .context(BaseCalciteQueryTest.TIMESERIES_CONTEXT_DEFAULT)\n              .build(),\n        Iterables.getOnlyElement(queryLogHook.getRecordedQueries())\n    );\n  }\n","realPath":"extensions-core/stats/src/test/java/org/apache/druid/query/aggregation/variance/sql/VarianceSqlAggregatorTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":251,"status":"M"}],"commitId":"691d7a1d548909951468005348a603380f4d6d74","commitMessage":"@@@SQL timeseries no longer skip empty buckets with all granularity (#11188)\n\n* SQL timeseries no longer skip empty buckets with all granularity\n\n* add comment.  fix tests\n\n* the ol switcheroo\n\n* revert unintended change\n\n* docs and more tests\n\n* style\n\n* make checkstyle happy\n\n* docs fixes and more tests\n\n* add docs.  tests for array_agg\n\n* fixes\n\n* oops\n\n* doc stuffs\n\n* fix compile.  match doc style","date":"2021-05-11 01:13:37","modifiedFileCount":"16","status":"M","submitter":"Clint Wylie"}]
