[{"authorTime":"2018-08-31 00:56:26","codes":[{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  private void makeRowPersistedIndexes()\n  {\n    synchronized (log) {\n      try {\n        if (events.isEmpty()) {\n          makeEvents();\n        }\n\n        for (final Map<String, Object> event : events) {\n\n          final long timestamp = new DateTime(event.get(TIMESTAMP), ISOChronology.getInstanceUTC()).getMillis();\n          final List<String> dims = Lists.newArrayList();\n          for (Map.Entry<String, Object> entry : event.entrySet()) {\n            if (!entry.getKey().equalsIgnoreCase(TIMESTAMP) && !METRICS.contains(entry.getKey())) {\n              dims.add(entry.getKey());\n            }\n          }\n\n          final IncrementalIndex rowIndex = new IncrementalIndex.Builder()\n              .setIndexSchema(\n                  new IncrementalIndexSchema.Builder()\n                      .withMinTimestamp(timestamp)\n                      .withQueryGranularity(Granularities.MINUTE)\n                      .withMetrics(METRIC_AGGS)\n                      .build()\n              )\n              .setMaxRowCount(1000)\n              .buildOnheap();\n\n          rowIndex.add(\n              new MapBasedInputRow(timestamp, dims, event)\n          );\n\n          File tmpFile = File.createTempFile(\"billy\", \"yay\");\n          tmpFile.delete();\n          tmpFile.mkdirs();\n          tmpFile.deleteOnExit();\n\n          indexMerger.persist(rowIndex, tmpFile, indexSpec, null);\n          rowPersistedIndexes.add(indexIO.loadIndex(tmpFile));\n        }\n      }\n      catch (IOException e) {\n        throw Throwables.propagate(e);\n      }\n    }\n  }\n","date":"2018-08-31 00:56:26","endLine":400,"groupId":"18893","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"makeRowPersistedIndexes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/48/92026239340dbf8f47429a3ec03ed0e1f6d556.src","preCode":"  private void makeRowPersistedIndexes()\n  {\n    synchronized (log) {\n      try {\n        if (events.isEmpty()) {\n          makeEvents();\n        }\n\n        for (final Map<String, Object> event : events) {\n\n          final long timestamp = new DateTime(event.get(TIMESTAMP), ISOChronology.getInstanceUTC()).getMillis();\n          final List<String> dims = Lists.newArrayList();\n          for (Map.Entry<String, Object> entry : event.entrySet()) {\n            if (!entry.getKey().equalsIgnoreCase(TIMESTAMP) && !METRICS.contains(entry.getKey())) {\n              dims.add(entry.getKey());\n            }\n          }\n\n          final IncrementalIndex rowIndex = new IncrementalIndex.Builder()\n              .setIndexSchema(\n                  new IncrementalIndexSchema.Builder()\n                      .withMinTimestamp(timestamp)\n                      .withQueryGranularity(Granularities.MINUTE)\n                      .withMetrics(METRIC_AGGS)\n                      .build()\n              )\n              .setMaxRowCount(1000)\n              .buildOnheap();\n\n          rowIndex.add(\n              new MapBasedInputRow(timestamp, dims, event)\n          );\n\n          File tmpFile = File.createTempFile(\"billy\", \"yay\");\n          tmpFile.delete();\n          tmpFile.mkdirs();\n          tmpFile.deleteOnExit();\n\n          indexMerger.persist(rowIndex, tmpFile, indexSpec, null);\n          rowPersistedIndexes.add(indexIO.loadIndex(tmpFile));\n        }\n      }\n      catch (IOException e) {\n        throw Throwables.propagate(e);\n      }\n    }\n  }\n","realPath":"processing/src/test/java/org/apache/druid/segment/SchemalessIndexTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":354,"status":"B"},{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  public static QueryableIndex persistRealtimeAndLoadMMapped(IncrementalIndex index)\n  {\n    try {\n      File someTmpFile = File.createTempFile(\"billy\", \"yay\");\n      someTmpFile.delete();\n      someTmpFile.mkdirs();\n      someTmpFile.deleteOnExit();\n\n      INDEX_MERGER.persist(index, someTmpFile, indexSpec, null);\n      return INDEX_IO.loadIndex(someTmpFile);\n    }\n    catch (IOException e) {\n      throw Throwables.propagate(e);\n    }\n  }\n","date":"2018-08-31 00:56:26","endLine":374,"groupId":"18893","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"persistRealtimeAndLoadMMapped","params":"(IncrementalIndexindex)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/20/1354a430b45d19b7a7f50ed179982c24faed1b.src","preCode":"  public static QueryableIndex persistRealtimeAndLoadMMapped(IncrementalIndex index)\n  {\n    try {\n      File someTmpFile = File.createTempFile(\"billy\", \"yay\");\n      someTmpFile.delete();\n      someTmpFile.mkdirs();\n      someTmpFile.deleteOnExit();\n\n      INDEX_MERGER.persist(index, someTmpFile, indexSpec, null);\n      return INDEX_IO.loadIndex(someTmpFile);\n    }\n    catch (IOException e) {\n      throw Throwables.propagate(e);\n    }\n  }\n","realPath":"processing/src/test/java/org/apache/druid/segment/TestIndex.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":360,"status":"B"}],"commitId":"431d3d8497f9079857c3baa7ae7ab4cb44a22355","commitMessage":"@@@Rename io.druid to org.apache.druid. (#6266)\n\n* Rename io.druid to org.apache.druid.\n\n* Fix META-INF files and remove some benchmark results.\n\n* MonitorsConfig update for metrics package migration.\n\n* Reorder some dimensions in inner queries for some reason.\n\n* Fix protobuf tests.\n","date":"2018-08-31 00:56:26","modifiedFileCount":"5","status":"B","submitter":"Gian Merlino"},{"authorTime":"2018-08-31 00:56:26","codes":[{"authorDate":"2018-10-29 20:02:43","commitOrder":2,"curCode":"  private void makeRowPersistedIndexes()\n  {\n    synchronized (log) {\n      try {\n        if (events.isEmpty()) {\n          makeEvents();\n        }\n\n        for (final Map<String, Object> event : events) {\n\n          final long timestamp = new DateTime(event.get(TIMESTAMP), ISOChronology.getInstanceUTC()).getMillis();\n          final List<String> dims = new ArrayList<>();\n          for (Map.Entry<String, Object> entry : event.entrySet()) {\n            if (!entry.getKey().equalsIgnoreCase(TIMESTAMP) && !METRICS.contains(entry.getKey())) {\n              dims.add(entry.getKey());\n            }\n          }\n\n          final IncrementalIndex rowIndex = new IncrementalIndex.Builder()\n              .setIndexSchema(\n                  new IncrementalIndexSchema.Builder()\n                      .withMinTimestamp(timestamp)\n                      .withQueryGranularity(Granularities.MINUTE)\n                      .withMetrics(METRIC_AGGS)\n                      .build()\n              )\n              .setMaxRowCount(1000)\n              .buildOnheap();\n\n          rowIndex.add(\n              new MapBasedInputRow(timestamp, dims, event)\n          );\n\n          File tmpFile = File.createTempFile(\"billy\", \"yay\");\n          tmpFile.delete();\n          tmpFile.mkdirs();\n          tmpFile.deleteOnExit();\n\n          indexMerger.persist(rowIndex, tmpFile, indexSpec, null);\n          rowPersistedIndexes.add(indexIO.loadIndex(tmpFile));\n        }\n      }\n      catch (IOException e) {\n        throw Throwables.propagate(e);\n      }\n    }\n  }\n","date":"2018-10-29 20:02:43","endLine":401,"groupId":"18893","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"makeRowPersistedIndexes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/c2/621f43e08291975509ce8f45a0eadcab56d508.src","preCode":"  private void makeRowPersistedIndexes()\n  {\n    synchronized (log) {\n      try {\n        if (events.isEmpty()) {\n          makeEvents();\n        }\n\n        for (final Map<String, Object> event : events) {\n\n          final long timestamp = new DateTime(event.get(TIMESTAMP), ISOChronology.getInstanceUTC()).getMillis();\n          final List<String> dims = Lists.newArrayList();\n          for (Map.Entry<String, Object> entry : event.entrySet()) {\n            if (!entry.getKey().equalsIgnoreCase(TIMESTAMP) && !METRICS.contains(entry.getKey())) {\n              dims.add(entry.getKey());\n            }\n          }\n\n          final IncrementalIndex rowIndex = new IncrementalIndex.Builder()\n              .setIndexSchema(\n                  new IncrementalIndexSchema.Builder()\n                      .withMinTimestamp(timestamp)\n                      .withQueryGranularity(Granularities.MINUTE)\n                      .withMetrics(METRIC_AGGS)\n                      .build()\n              )\n              .setMaxRowCount(1000)\n              .buildOnheap();\n\n          rowIndex.add(\n              new MapBasedInputRow(timestamp, dims, event)\n          );\n\n          File tmpFile = File.createTempFile(\"billy\", \"yay\");\n          tmpFile.delete();\n          tmpFile.mkdirs();\n          tmpFile.deleteOnExit();\n\n          indexMerger.persist(rowIndex, tmpFile, indexSpec, null);\n          rowPersistedIndexes.add(indexIO.loadIndex(tmpFile));\n        }\n      }\n      catch (IOException e) {\n        throw Throwables.propagate(e);\n      }\n    }\n  }\n","realPath":"processing/src/test/java/org/apache/druid/segment/SchemalessIndexTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":355,"status":"M"},{"authorDate":"2018-08-31 00:56:26","commitOrder":2,"curCode":"  public static QueryableIndex persistRealtimeAndLoadMMapped(IncrementalIndex index)\n  {\n    try {\n      File someTmpFile = File.createTempFile(\"billy\", \"yay\");\n      someTmpFile.delete();\n      someTmpFile.mkdirs();\n      someTmpFile.deleteOnExit();\n\n      INDEX_MERGER.persist(index, someTmpFile, indexSpec, null);\n      return INDEX_IO.loadIndex(someTmpFile);\n    }\n    catch (IOException e) {\n      throw Throwables.propagate(e);\n    }\n  }\n","date":"2018-08-31 00:56:26","endLine":374,"groupId":"18893","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"persistRealtimeAndLoadMMapped","params":"(IncrementalIndexindex)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/20/1354a430b45d19b7a7f50ed179982c24faed1b.src","preCode":"  public static QueryableIndex persistRealtimeAndLoadMMapped(IncrementalIndex index)\n  {\n    try {\n      File someTmpFile = File.createTempFile(\"billy\", \"yay\");\n      someTmpFile.delete();\n      someTmpFile.mkdirs();\n      someTmpFile.deleteOnExit();\n\n      INDEX_MERGER.persist(index, someTmpFile, indexSpec, null);\n      return INDEX_IO.loadIndex(someTmpFile);\n    }\n    catch (IOException e) {\n      throw Throwables.propagate(e);\n    }\n  }\n","realPath":"processing/src/test/java/org/apache/druid/segment/TestIndex.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":360,"status":"N"}],"commitId":"676f5e6d7f184101b8763e4249b18b237bbe0ec7","commitMessage":"@@@Prohibit some guava collection APIs and use JDK collection APIs directly (#6511)\n\n* Prohibit some guava collection APIs and use JDK APIs directly\n\n* reset files that changed by accident\n\n* sort codestyle/druid-forbidden-apis.txt alphabetically\n","date":"2018-10-29 20:02:43","modifiedFileCount":"427","status":"M","submitter":"QiuMM"},{"authorTime":"2019-03-15 05:28:33","codes":[{"authorDate":"2019-03-15 05:28:33","commitOrder":3,"curCode":"  private void makeRowPersistedIndexes()\n  {\n    synchronized (log) {\n      try {\n        if (events.isEmpty()) {\n          makeEvents();\n        }\n\n        for (final Map<String, Object> event : events) {\n\n          final long timestamp = new DateTime(event.get(TIMESTAMP), ISOChronology.getInstanceUTC()).getMillis();\n          final List<String> dims = new ArrayList<>();\n          for (Map.Entry<String, Object> entry : event.entrySet()) {\n            if (!entry.getKey().equalsIgnoreCase(TIMESTAMP) && !METRICS.contains(entry.getKey())) {\n              dims.add(entry.getKey());\n            }\n          }\n\n          final IncrementalIndex rowIndex = new IncrementalIndex.Builder()\n              .setIndexSchema(\n                  new IncrementalIndexSchema.Builder()\n                      .withMinTimestamp(timestamp)\n                      .withQueryGranularity(Granularities.MINUTE)\n                      .withMetrics(METRIC_AGGS)\n                      .build()\n              )\n              .setMaxRowCount(1000)\n              .buildOnheap();\n\n          rowIndex.add(\n              new MapBasedInputRow(timestamp, dims, event)\n          );\n\n          File tmpFile = File.createTempFile(\"billy\", \"yay\");\n          tmpFile.delete();\n          tmpFile.mkdirs();\n          tmpFile.deleteOnExit();\n\n          indexMerger.persist(rowIndex, tmpFile, indexSpec, null);\n          rowPersistedIndexes.add(indexIO.loadIndex(tmpFile));\n        }\n      }\n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n","date":"2019-03-15 05:28:33","endLine":400,"groupId":"18893","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"makeRowPersistedIndexes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/92/29295cb4144a64496cfdd92e2ebaeb84f35198.src","preCode":"  private void makeRowPersistedIndexes()\n  {\n    synchronized (log) {\n      try {\n        if (events.isEmpty()) {\n          makeEvents();\n        }\n\n        for (final Map<String, Object> event : events) {\n\n          final long timestamp = new DateTime(event.get(TIMESTAMP), ISOChronology.getInstanceUTC()).getMillis();\n          final List<String> dims = new ArrayList<>();\n          for (Map.Entry<String, Object> entry : event.entrySet()) {\n            if (!entry.getKey().equalsIgnoreCase(TIMESTAMP) && !METRICS.contains(entry.getKey())) {\n              dims.add(entry.getKey());\n            }\n          }\n\n          final IncrementalIndex rowIndex = new IncrementalIndex.Builder()\n              .setIndexSchema(\n                  new IncrementalIndexSchema.Builder()\n                      .withMinTimestamp(timestamp)\n                      .withQueryGranularity(Granularities.MINUTE)\n                      .withMetrics(METRIC_AGGS)\n                      .build()\n              )\n              .setMaxRowCount(1000)\n              .buildOnheap();\n\n          rowIndex.add(\n              new MapBasedInputRow(timestamp, dims, event)\n          );\n\n          File tmpFile = File.createTempFile(\"billy\", \"yay\");\n          tmpFile.delete();\n          tmpFile.mkdirs();\n          tmpFile.deleteOnExit();\n\n          indexMerger.persist(rowIndex, tmpFile, indexSpec, null);\n          rowPersistedIndexes.add(indexIO.loadIndex(tmpFile));\n        }\n      }\n      catch (IOException e) {\n        throw Throwables.propagate(e);\n      }\n    }\n  }\n","realPath":"processing/src/test/java/org/apache/druid/segment/SchemalessIndexTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":354,"status":"M"},{"authorDate":"2019-03-15 05:28:33","commitOrder":3,"curCode":"  public static QueryableIndex persistRealtimeAndLoadMMapped(IncrementalIndex index)\n  {\n    try {\n      File someTmpFile = File.createTempFile(\"billy\", \"yay\");\n      someTmpFile.delete();\n      someTmpFile.mkdirs();\n      someTmpFile.deleteOnExit();\n\n      INDEX_MERGER.persist(index, someTmpFile, indexSpec, null);\n      return INDEX_IO.loadIndex(someTmpFile);\n    }\n    catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","date":"2019-03-15 05:28:33","endLine":388,"groupId":"18893","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"persistRealtimeAndLoadMMapped","params":"(IncrementalIndexindex)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/cb/5d6bdcec808a6df077f61a8bf1b261056f0b5b.src","preCode":"  public static QueryableIndex persistRealtimeAndLoadMMapped(IncrementalIndex index)\n  {\n    try {\n      File someTmpFile = File.createTempFile(\"billy\", \"yay\");\n      someTmpFile.delete();\n      someTmpFile.mkdirs();\n      someTmpFile.deleteOnExit();\n\n      INDEX_MERGER.persist(index, someTmpFile, indexSpec, null);\n      return INDEX_IO.loadIndex(someTmpFile);\n    }\n    catch (IOException e) {\n      throw Throwables.propagate(e);\n    }\n  }\n","realPath":"processing/src/test/java/org/apache/druid/segment/TestIndex.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":374,"status":"M"}],"commitId":"7ada1c49f9735a37808f3ed7656d93ae88b8b925","commitMessage":"@@@Prohibit Throwables.propagate() (#7121)\n\n* Throw caught exception.\n\n* Throw caught exceptions.\n\n* Related checkstyle rule is added to prevent further bugs.\n\n* RuntimeException() is used instead of Throwables.propagate().\n\n* Missing import is added.\n\n* Throwables are propogated if possible.\n\n* Throwables are propogated if possible.\n\n* Throwables are propogated if possible.\n\n* Throwables are propogated if possible.\n\n* * Checkstyle definition is improved.\n* Throwables.propagate() usages are removed.\n\n* Checkstyle pattern is changed for only scanning \"Throwables.propagate(\" instead of checking lookbehind.\n\n* Throwable is kept before firing a Runtime Exception.\n\n* Fix unused assignments.\n","date":"2019-03-15 05:28:33","modifiedFileCount":"228","status":"M","submitter":"Furkan KAMACI"},{"authorTime":"2019-08-23 18:13:54","codes":[{"authorDate":"2019-08-23 18:13:54","commitOrder":4,"curCode":"  private void makeRowPersistedIndexes()\n  {\n    synchronized (log) {\n      try {\n        if (EVENTS.isEmpty()) {\n          makeEvents();\n        }\n\n        for (final Map<String, Object> event : EVENTS) {\n\n          final long timestamp = new DateTime(event.get(TIMESTAMP), ISOChronology.getInstanceUTC()).getMillis();\n          final List<String> dims = new ArrayList<>();\n          for (Map.Entry<String, Object> entry : event.entrySet()) {\n            if (!entry.getKey().equalsIgnoreCase(TIMESTAMP) && !METRICS.contains(entry.getKey())) {\n              dims.add(entry.getKey());\n            }\n          }\n\n          final IncrementalIndex rowIndex = new IncrementalIndex.Builder()\n              .setIndexSchema(\n                  new IncrementalIndexSchema.Builder()\n                      .withMinTimestamp(timestamp)\n                      .withQueryGranularity(Granularities.MINUTE)\n                      .withMetrics(METRIC_AGGS)\n                      .build()\n              )\n              .setMaxRowCount(1000)\n              .buildOnheap();\n\n          rowIndex.add(\n              new MapBasedInputRow(timestamp, dims, event)\n          );\n\n          File tmpFile = File.createTempFile(\"billy\", \"yay\");\n          tmpFile.delete();\n          tmpFile.mkdirs();\n          tmpFile.deleteOnExit();\n\n          indexMerger.persist(rowIndex, tmpFile, INDEX_SPEC, null);\n          ROW_PERSISTED_INDEXES.add(indexIO.loadIndex(tmpFile));\n        }\n      }\n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n","date":"2019-08-23 18:13:54","endLine":398,"groupId":"18893","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"makeRowPersistedIndexes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/0c/f4d0dd134bd90f97adf4da5a6f03693a7ffadf.src","preCode":"  private void makeRowPersistedIndexes()\n  {\n    synchronized (log) {\n      try {\n        if (events.isEmpty()) {\n          makeEvents();\n        }\n\n        for (final Map<String, Object> event : events) {\n\n          final long timestamp = new DateTime(event.get(TIMESTAMP), ISOChronology.getInstanceUTC()).getMillis();\n          final List<String> dims = new ArrayList<>();\n          for (Map.Entry<String, Object> entry : event.entrySet()) {\n            if (!entry.getKey().equalsIgnoreCase(TIMESTAMP) && !METRICS.contains(entry.getKey())) {\n              dims.add(entry.getKey());\n            }\n          }\n\n          final IncrementalIndex rowIndex = new IncrementalIndex.Builder()\n              .setIndexSchema(\n                  new IncrementalIndexSchema.Builder()\n                      .withMinTimestamp(timestamp)\n                      .withQueryGranularity(Granularities.MINUTE)\n                      .withMetrics(METRIC_AGGS)\n                      .build()\n              )\n              .setMaxRowCount(1000)\n              .buildOnheap();\n\n          rowIndex.add(\n              new MapBasedInputRow(timestamp, dims, event)\n          );\n\n          File tmpFile = File.createTempFile(\"billy\", \"yay\");\n          tmpFile.delete();\n          tmpFile.mkdirs();\n          tmpFile.deleteOnExit();\n\n          indexMerger.persist(rowIndex, tmpFile, indexSpec, null);\n          rowPersistedIndexes.add(indexIO.loadIndex(tmpFile));\n        }\n      }\n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n","realPath":"processing/src/test/java/org/apache/druid/segment/SchemalessIndexTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":352,"status":"M"},{"authorDate":"2019-08-23 18:13:54","commitOrder":4,"curCode":"  public static QueryableIndex persistRealtimeAndLoadMMapped(IncrementalIndex index)\n  {\n    try {\n      File someTmpFile = File.createTempFile(\"billy\", \"yay\");\n      someTmpFile.delete();\n      someTmpFile.mkdirs();\n      someTmpFile.deleteOnExit();\n\n      INDEX_MERGER.persist(index, someTmpFile, INDEX_SPEC, null);\n      return INDEX_IO.loadIndex(someTmpFile);\n    }\n    catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","date":"2019-08-23 18:13:54","endLine":385,"groupId":"18893","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"persistRealtimeAndLoadMMapped","params":"(IncrementalIndexindex)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/94/70b59903d72d3bfba834c73fb705f27acf0e68.src","preCode":"  public static QueryableIndex persistRealtimeAndLoadMMapped(IncrementalIndex index)\n  {\n    try {\n      File someTmpFile = File.createTempFile(\"billy\", \"yay\");\n      someTmpFile.delete();\n      someTmpFile.mkdirs();\n      someTmpFile.deleteOnExit();\n\n      INDEX_MERGER.persist(index, someTmpFile, indexSpec, null);\n      return INDEX_IO.loadIndex(someTmpFile);\n    }\n    catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","realPath":"processing/src/test/java/org/apache/druid/segment/TestIndex.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":371,"status":"M"}],"commitId":"33f0753a70361e7d345a488034f76a889f7c3682","commitMessage":"@@@Add Checkstyle for constant name static final (#8060)\n\n* check ctyle for constant field name\n\n* check ctyle for constant field name\n\n* check ctyle for constant field name\n\n* check ctyle for constant field name\n\n* check ctyle for constant field name\n\n* check ctyle for constant field name\n\n* check ctyle for constant field name\n\n* check ctyle for constant field name\n\n* check ctyle for constant field name\n\n* merging with upstream\n\n* review-1\n\n* unknow changes\n\n* unknow changes\n\n* review-2\n\n* merging with master\n\n* review-2 1 changes\n\n* review changes-2 2\n\n* bug fix\n","date":"2019-08-23 18:13:54","modifiedFileCount":"298","status":"M","submitter":"SandishKumarHN"},{"authorTime":"2019-08-23 18:13:54","codes":[{"authorDate":"2021-01-08 14:18:47","commitOrder":5,"curCode":"  private void makeRowPersistedIndexes()\n  {\n    synchronized (log) {\n      try {\n        if (EVENTS.isEmpty()) {\n          makeEvents();\n        }\n\n        for (final Map<String, Object> event : EVENTS) {\n\n          final long timestamp = new DateTime(event.get(TIMESTAMP), ISOChronology.getInstanceUTC()).getMillis();\n          final List<String> dims = new ArrayList<>();\n          for (Map.Entry<String, Object> entry : event.entrySet()) {\n            if (!entry.getKey().equalsIgnoreCase(TIMESTAMP) && !METRICS.contains(entry.getKey())) {\n              dims.add(entry.getKey());\n            }\n          }\n\n          final IncrementalIndex rowIndex = new OnheapIncrementalIndex.Builder()\n              .setIndexSchema(\n                  new IncrementalIndexSchema.Builder()\n                      .withMinTimestamp(timestamp)\n                      .withQueryGranularity(Granularities.MINUTE)\n                      .withMetrics(METRIC_AGGS)\n                      .build()\n              )\n              .setMaxRowCount(1000)\n              .build();\n\n          rowIndex.add(\n              new MapBasedInputRow(timestamp, dims, event)\n          );\n\n          File tmpFile = File.createTempFile(\"billy\", \"yay\");\n          tmpFile.delete();\n          tmpFile.mkdirs();\n          tmpFile.deleteOnExit();\n\n          indexMerger.persist(rowIndex, tmpFile, INDEX_SPEC, null);\n          ROW_PERSISTED_INDEXES.add(indexIO.loadIndex(tmpFile));\n        }\n      }\n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n","date":"2021-01-08 14:18:47","endLine":401,"groupId":"105812","id":9,"instanceNumber":1,"isCurCommit":1,"methodName":"makeRowPersistedIndexes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/73/280615d4da7b0c561d46b8ad191c679928a3a4.src","preCode":"  private void makeRowPersistedIndexes()\n  {\n    synchronized (log) {\n      try {\n        if (EVENTS.isEmpty()) {\n          makeEvents();\n        }\n\n        for (final Map<String, Object> event : EVENTS) {\n\n          final long timestamp = new DateTime(event.get(TIMESTAMP), ISOChronology.getInstanceUTC()).getMillis();\n          final List<String> dims = new ArrayList<>();\n          for (Map.Entry<String, Object> entry : event.entrySet()) {\n            if (!entry.getKey().equalsIgnoreCase(TIMESTAMP) && !METRICS.contains(entry.getKey())) {\n              dims.add(entry.getKey());\n            }\n          }\n\n          final IncrementalIndex rowIndex = new IncrementalIndex.Builder()\n              .setIndexSchema(\n                  new IncrementalIndexSchema.Builder()\n                      .withMinTimestamp(timestamp)\n                      .withQueryGranularity(Granularities.MINUTE)\n                      .withMetrics(METRIC_AGGS)\n                      .build()\n              )\n              .setMaxRowCount(1000)\n              .buildOnheap();\n\n          rowIndex.add(\n              new MapBasedInputRow(timestamp, dims, event)\n          );\n\n          File tmpFile = File.createTempFile(\"billy\", \"yay\");\n          tmpFile.delete();\n          tmpFile.mkdirs();\n          tmpFile.deleteOnExit();\n\n          indexMerger.persist(rowIndex, tmpFile, INDEX_SPEC, null);\n          ROW_PERSISTED_INDEXES.add(indexIO.loadIndex(tmpFile));\n        }\n      }\n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n","realPath":"processing/src/test/java/org/apache/druid/segment/SchemalessIndexTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":355,"status":"M"},{"authorDate":"2019-08-23 18:13:54","commitOrder":5,"curCode":"  public static QueryableIndex persistRealtimeAndLoadMMapped(IncrementalIndex index)\n  {\n    try {\n      File someTmpFile = File.createTempFile(\"billy\", \"yay\");\n      someTmpFile.delete();\n      someTmpFile.mkdirs();\n      someTmpFile.deleteOnExit();\n\n      INDEX_MERGER.persist(index, someTmpFile, INDEX_SPEC, null);\n      return INDEX_IO.loadIndex(someTmpFile);\n    }\n    catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","date":"2019-08-23 18:13:54","endLine":385,"groupId":"105812","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"persistRealtimeAndLoadMMapped","params":"(IncrementalIndexindex)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/94/70b59903d72d3bfba834c73fb705f27acf0e68.src","preCode":"  public static QueryableIndex persistRealtimeAndLoadMMapped(IncrementalIndex index)\n  {\n    try {\n      File someTmpFile = File.createTempFile(\"billy\", \"yay\");\n      someTmpFile.delete();\n      someTmpFile.mkdirs();\n      someTmpFile.deleteOnExit();\n\n      INDEX_MERGER.persist(index, someTmpFile, INDEX_SPEC, null);\n      return INDEX_IO.loadIndex(someTmpFile);\n    }\n    catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","realPath":"processing/src/test/java/org/apache/druid/segment/TestIndex.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":371,"status":"N"}],"commitId":"08ab82f55ca856d60dfe1088c1c0393428b0bb6d","commitMessage":"@@@IncrementalIndex Tests and Benchmarks Parametrization (#10593)\n\n* Remove redundant IncrementalIndex.Builder\n\n* Parametrize incremental index tests and benchmarks\n\n- Reveal and fix a bug in OffheapIncrementalIndex\n\n* Fix forbiddenapis error: Forbidden method invocation: java.lang.String#format(java.lang.String. java.lang.Object[]) [Uses default locale]\n\n* Fix Intellij errors: declared exception is never thrown\n\n* Add documentation and validate before closing objects on tearDown.\n\n* Add documentation to OffheapIncrementalIndexTestSpec\n\n* Doc corrections and minor changes.\n\n* Add logging for generated rows.\n\n* Refactor new tests/benchmarks.\n\n* Improve IncrementalIndexCreator documentation\n\n* Add required tests for DataGenerator\n\n* Revert \"rollupOpportunity\" to be a string","date":"2021-01-08 14:18:47","modifiedFileCount":"62","status":"M","submitter":"Liran Funaro"}]
