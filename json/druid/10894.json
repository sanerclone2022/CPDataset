[{"authorTime":"2018-08-31 00:56:26","codes":[{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public VersionedIntervalTimeline<String, ServerSelector> getTimeline(DataSource dataSource)\n          {\n            return timeline;\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        JSON_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        }\n    );\n  }\n","date":"2018-08-31 00:56:26","endLine":2689,"groupId":"5600","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"makeClient","params":"(finalCachePopulatorcachePopulator@finalCachecache@finalintmergeLimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/4a/6dfd0a7ba50835713564aebc5ab8650ac4b7a1.src","preCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public VersionedIntervalTimeline<String, ServerSelector> getTimeline(DataSource dataSource)\n          {\n            return timeline;\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        JSON_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        }\n    );\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":2620,"status":"B"},{"authorDate":"2018-08-31 00:56:26","commitOrder":1,"curCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public VersionedIntervalTimeline<String, ServerSelector> getTimeline(DataSource dataSource)\n          {\n            return timeline;\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        OBJECT_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        }\n    );\n  }\n","date":"2018-08-31 00:56:26","endLine":301,"groupId":"20759","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"makeClient","params":"(finalCachePopulatorcachePopulator@finalCachecache@finalintmergeLimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/7a/c1596b91312e5edd2371b0365c6b7732156499.src","preCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public VersionedIntervalTimeline<String, ServerSelector> getTimeline(DataSource dataSource)\n          {\n            return timeline;\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        OBJECT_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        }\n    );\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientFunctionalityTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":232,"status":"B"}],"commitId":"431d3d8497f9079857c3baa7ae7ab4cb44a22355","commitMessage":"@@@Rename io.druid to org.apache.druid. (#6266)\n\n* Rename io.druid to org.apache.druid.\n\n* Fix META-INF files and remove some benchmark results.\n\n* MonitorsConfig update for metrics package migration.\n\n* Reorder some dimensions in inner queries for some reason.\n\n* Fix protobuf tests.\n","date":"2018-08-31 00:56:26","modifiedFileCount":"5","status":"B","submitter":"Gian Merlino"},{"authorTime":"2018-09-11 00:33:29","codes":[{"authorDate":"2018-09-11 00:33:29","commitOrder":2,"curCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public VersionedIntervalTimeline<String, ServerSelector> getTimeline(DataSource dataSource)\n          {\n            return timeline;\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        JSON_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig() {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        }\n    );\n  }\n","date":"2018-09-11 00:33:29","endLine":2697,"groupId":"5600","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"makeClient","params":"(finalCachePopulatorcachePopulator@finalCachecache@finalintmergeLimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/83/b4aeebcd57e55375b460a52ac87d36a10fc780.src","preCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public VersionedIntervalTimeline<String, ServerSelector> getTimeline(DataSource dataSource)\n          {\n            return timeline;\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        JSON_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        }\n    );\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":2621,"status":"M"},{"authorDate":"2018-09-11 00:33:29","commitOrder":2,"curCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public VersionedIntervalTimeline<String, ServerSelector> getTimeline(DataSource dataSource)\n          {\n            return timeline;\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        OBJECT_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig() {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        }\n    );\n  }\n","date":"2018-09-11 00:33:29","endLine":309,"groupId":"20759","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"makeClient","params":"(finalCachePopulatorcachePopulator@finalCachecache@finalintmergeLimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/f0/2ba430eca663398197fed0f06ce8de2c60a226.src","preCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public VersionedIntervalTimeline<String, ServerSelector> getTimeline(DataSource dataSource)\n          {\n            return timeline;\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        OBJECT_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        }\n    );\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientFunctionalityTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":233,"status":"M"}],"commitId":"d6cbdf86c2e01a2bfbecb2263f7aad62bbbda5e2","commitMessage":"@@@Broker backpressure. (#6313)\n\n* Broker backpressure.\n\nAdds a new property \"druid.broker.http.maxQueuedBytes\" and a new context\nparameter \"maxQueuedBytes\". Both represent a maximum number of bytes queued\nper query before exerting backpressure on the channel to the data server.\n\nFixes #4933.\n\n* Fix query context doc.\n","date":"2018-09-11 00:33:29","modifiedFileCount":"25","status":"M","submitter":"Gian Merlino"},{"authorTime":"2018-10-11 08:17:29","codes":[{"authorDate":"2018-10-11 08:17:29","commitOrder":3,"curCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public VersionedIntervalTimeline<String, ServerSelector> getTimeline(DataSource dataSource)\n          {\n            return timeline;\n          }\n\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        JSON_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig() {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        }\n    );\n  }\n","date":"2018-10-11 08:17:29","endLine":2703,"groupId":"5600","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"makeClient","params":"(finalCachePopulatorcachePopulator@finalCachecache@finalintmergeLimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/57/3c5c924658354a31f5c451c0708aa144688968.src","preCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public VersionedIntervalTimeline<String, ServerSelector> getTimeline(DataSource dataSource)\n          {\n            return timeline;\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        JSON_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig() {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        }\n    );\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":2621,"status":"M"},{"authorDate":"2018-10-11 08:17:29","commitOrder":3,"curCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public VersionedIntervalTimeline<String, ServerSelector> getTimeline(DataSource dataSource)\n          {\n            return timeline;\n          }\n\n          @Nullable\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        OBJECT_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig() {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        }\n    );\n  }\n","date":"2018-10-11 08:17:29","endLine":317,"groupId":"20759","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"makeClient","params":"(finalCachePopulatorcachePopulator@finalCachecache@finalintmergeLimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/9c/ec0227aac382ce6c478e5cffc2805b6fc6600b.src","preCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public VersionedIntervalTimeline<String, ServerSelector> getTimeline(DataSource dataSource)\n          {\n            return timeline;\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        OBJECT_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig() {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        }\n    );\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientFunctionalityTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":234,"status":"M"}],"commitId":"3a0a667fe03d03d97c4e5d6cbeb3e60e28c7d4f7","commitMessage":"@@@Introduce SystemSchema tables (#5989) (#6094)\n\n* Added SystemSchema with following tables (#5989)\n\n* SEGMENTS table provides details on served and published segments\n* SERVERS table provides details on data servers\n* SERVERSEGMETS table is the JOIN of SEGMENTS and SERVERS\n* TASKS table provides details on tasks\n\n* Add documentation for system schema\n\n* Fix static-analysis warnings\n\n* Address PR comments\n\n*Add unit tests\n\n* Fix a test\n\n* Try to fix a test\n\n* Fix a bug around replica count\n\n* rename io.druid to org.apache.druid\n\n* Major change is to make tasks and segment queries streaming\n\n* Made tasks/segments stream to calcite instead of storing it in memory\n* Add num_rows to segments table\n* Refactor JsonParserIterator\n* Replace with closeable iterator\n\n* Fix docs.  make num_rows column nullable.  some unit test changes\n\n* make num_rows column type long.  allow it to be null\n\nfix a compile error after merge.  add TrafficCop param to InputStreamResponseHandler\n\n* Filter null rows for segments table from Linq4j enumerable\n\n* change num_replicas datatype to long in segments table\n\n* Fix some tests and address comments\n\n* Doc updates.  other PR comments\n\n* Update tests\n\n* Address comments\n\n* Add auth check\n* Update docs\n* Refactoring\n\n* Fix teamcity warning.  change the getQueryableServer in TimelineServerView\n\n* Fix compilation after rebase\n\n* Use the stream API from AuthorizationUtils\n\n* Added LeaderClient interface and NoopDruidLeaderClient class\n\n* Revert \"Added LeaderClient interface and NoopDruidLeaderClient class\"\n\nThis reverts commit 100fa46e396ab0f68da6c4bef80951f6b996657e.\n\n* Make the naming consistent to server_segments for the join table\n\n* Add ForbiddenException on auth check failure\n* Remove static block from SystemSchema\n\n* Try to fix a test in CalciteQueryTest due to rename of server_segments\n\n* Fix the json output format in the coordinator API\n\n* Add auth check in the segments API\n* Add null check to avoid NPE\n\n* Use annonymous class object instead of mock for DruidLeaderClient in SqlBenchmark\n\n* Fix test failures.  type long/BIGINT can be nullable\n\n* Revert long nullability to fix tests\n\n* Fix style for tests\n\n* PR comments\n\n* Address PR comments\n\n* Add the missing BytesAccumulatingResponseHandler class\n\n* Use Sequences.withBaggage in DruidPlanner\n\n* Fix docs.  add comments\n\n* Close the iterator if hasNext returns false\n","date":"2018-10-11 08:17:29","modifiedFileCount":"22","status":"M","submitter":"Surekha"},{"authorTime":"2019-11-08 03:58:46","codes":[{"authorDate":"2019-11-08 03:58:46","commitOrder":4,"curCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public VersionedIntervalTimeline<String, ServerSelector> getTimeline(DataSource dataSource)\n          {\n            return timeline;\n          }\n\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        JSON_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n        },\n        ForkJoinPool.commonPool()\n    );\n  }\n","date":"2019-11-08 03:58:46","endLine":2506,"groupId":"5600","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"makeClient","params":"(finalCachePopulatorcachePopulator@finalCachecache@finalintmergeLimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/d8/75df32990400bfc403fed405514b1da9dd1a33.src","preCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public VersionedIntervalTimeline<String, ServerSelector> getTimeline(DataSource dataSource)\n          {\n            return timeline;\n          }\n\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        JSON_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        }\n    );\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":2414,"status":"M"},{"authorDate":"2019-11-08 03:58:46","commitOrder":4,"curCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public VersionedIntervalTimeline<String, ServerSelector> getTimeline(DataSource dataSource)\n          {\n            return timeline;\n          }\n\n          @Nullable\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        OBJECT_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n        },\n        ForkJoinPool.commonPool()\n    );\n  }\n","date":"2019-11-08 03:58:46","endLine":325,"groupId":"20759","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"makeClient","params":"(finalCachePopulatorcachePopulator@finalCachecache@finalintmergeLimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/56/cb4864d2b369bc45c069d7cbdf7456d33e6a2c.src","preCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public VersionedIntervalTimeline<String, ServerSelector> getTimeline(DataSource dataSource)\n          {\n            return timeline;\n          }\n\n          @Nullable\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        OBJECT_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig() {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        }\n    );\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientFunctionalityTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":232,"status":"M"}],"commitId":"7aafcf8bcae3d57a8992a2634c7b73869c9a4117","commitMessage":"@@@parallel broker merges on fork join pool (#8578)\n\n* sketch of broker parallel merges done in small batches on fork join pool\n\n* fix non-terminating sequences.  auto compute parallelism\n\n* adjust benches\n\n* adjust benchmarks\n\n* now hella more faster.  fixed dumb\n\n* fix\n\n* remove comments\n\n* log.info for debug\n\n* javadoc\n\n* safer block for sequence to yielder conversion\n\n* refactor LifecycleForkJoinPool into LifecycleForkJoinPoolProvider which wraps a ForkJoinPool\n\n* smooth yield rate adjustment.  more logs to help tune\n\n* cleanup.  less logs\n\n* error handling.  bug fixes.  on by default.  more parallel.  more tests\n\n* remove unused var\n\n* comments\n\n* timeboundary mergeFn\n\n* simplify.  more javadoc\n\n* formatting\n\n* pushdown config\n\n* use nanos consistently.  move logs back to debug level.  bit more javadoc\n\n* static terminal result batch\n\n* javadoc for nullability of createMergeFn\n\n* cleanup\n\n* oops\n\n* fix race.  add docs\n\n* spelling.  remove todo.  add unhandled exception log\n\n* cleanup.  revert unintended change\n\n* another unintended change\n\n* review stuff\n\n* add ParallelMergeCombiningSequenceBenchmark.  fixes\n\n* hyper-threading is the enemy\n\n* fix initial start delay.  lol\n\n* parallelism computer now balances partition sizes to partition counts using sqrt of sequence count instead of sequence count by 2\n\n* fix those important style issues with the benchmarks code\n\n* lazy sequence creation for benchmarks\n\n* more benchmark comments\n\n* stable sequence generation time\n\n* update defaults to use 100ms target time.  4096 batch size.  16384 initial yield.  also update user docs\n\n* add jmh thread based benchmarks.  cleanup some stuff\n\n* oops\n\n* style\n\n* add spread to jmh thread benchmark start range.  more comments to benchmarks parameters and purpose\n\n* retool benchmark to allow modeling more typical heterogenous heavy workloads\n\n* spelling\n\n* fix\n\n* refactor benchmarks\n\n* formatting\n\n* docs\n\n* add maxThreadStartDelay parameter to threaded benchmark\n\n* why does catch need to be on its own line but else doesnt\n","date":"2019-11-08 03:58:46","modifiedFileCount":"16","status":"M","submitter":"Clint Wylie"},{"authorTime":"2019-12-07 05:42:53","codes":[{"authorDate":"2019-12-07 05:42:53","commitOrder":5,"curCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public VersionedIntervalTimeline<String, ServerSelector> getTimeline(DataSource dataSource)\n          {\n            return timeline;\n          }\n\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        JSON_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n\n          @Override\n          public int getMergePoolParallelism()\n          {\n            \r\n            return 4;\n          }\n        },\n        ForkJoinPool.commonPool()\n    );\n  }\n","date":"2019-12-07 05:42:53","endLine":2513,"groupId":"5600","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"makeClient","params":"(finalCachePopulatorcachePopulator@finalCachecache@finalintmergeLimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/cd/9e6d071fd6698350dea202f25a145c56437477.src","preCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public VersionedIntervalTimeline<String, ServerSelector> getTimeline(DataSource dataSource)\n          {\n            return timeline;\n          }\n\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        JSON_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n        },\n        ForkJoinPool.commonPool()\n    );\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":2414,"status":"M"},{"authorDate":"2019-12-07 05:42:53","commitOrder":5,"curCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public VersionedIntervalTimeline<String, ServerSelector> getTimeline(DataSource dataSource)\n          {\n            return timeline;\n          }\n\n          @Nullable\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        OBJECT_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n\n          @Override\n          public int getMergePoolParallelism()\n          {\n            \r\n            return 4;\n          }\n        },\n        ForkJoinPool.commonPool()\n    );\n  }\n","date":"2019-12-07 05:42:53","endLine":332,"groupId":"20759","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"makeClient","params":"(finalCachePopulatorcachePopulator@finalCachecache@finalintmergeLimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/a7/5ad64e080cbb718c4ea36304f6e5f7b8b5c9ba.src","preCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public VersionedIntervalTimeline<String, ServerSelector> getTimeline(DataSource dataSource)\n          {\n            return timeline;\n          }\n\n          @Nullable\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        OBJECT_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n        },\n        ForkJoinPool.commonPool()\n    );\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientFunctionalityTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":232,"status":"M"}],"commitId":"06cd30460ef51f9e316e86d4b417882efc9b861c","commitMessage":"@@@add query metrics for broker parallel merges.  off by default (#8981)\n\n* add a bunch of metrics for broker parallel merges.  off by default.  and tests\n\n* fix tests\n\n* review stuffs\n\n* propogateIfPossible\n","date":"2019-12-07 05:42:53","modifiedFileCount":"12","status":"M","submitter":"Clint Wylie"},{"authorTime":"2020-01-24 06:07:14","codes":[{"authorDate":"2020-01-24 06:07:14","commitOrder":6,"curCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public Optional<VersionedIntervalTimeline<String, ServerSelector>> getTimeline(DataSourceAnalysis analysis)\n          {\n            return Optional.of(timeline);\n          }\n\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        JSON_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n\n          @Override\n          public int getMergePoolParallelism()\n          {\n            \r\n            return 4;\n          }\n        },\n        ForkJoinPool.commonPool()\n    );\n  }\n","date":"2020-01-24 06:07:14","endLine":2478,"groupId":"5600","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"makeClient","params":"(finalCachePopulatorcachePopulator@finalCachecache@finalintmergeLimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/9c/0588837ffdf6bfa05cbf7de729ee78075145c6.src","preCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public VersionedIntervalTimeline<String, ServerSelector> getTimeline(DataSource dataSource)\n          {\n            return timeline;\n          }\n\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        JSON_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n\n          @Override\n          public int getMergePoolParallelism()\n          {\n            \r\n            return 4;\n          }\n        },\n        ForkJoinPool.commonPool()\n    );\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":2379,"status":"M"},{"authorDate":"2020-01-24 06:07:14","commitOrder":6,"curCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public Optional<? extends TimelineLookup<String, ServerSelector>> getTimeline(DataSourceAnalysis analysis)\n          {\n            return Optional.of(timeline);\n          }\n\n          @Nullable\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        OBJECT_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n\n          @Override\n          public int getMergePoolParallelism()\n          {\n            \r\n            return 4;\n          }\n        },\n        ForkJoinPool.commonPool()\n    );\n  }\n","date":"2020-01-24 06:07:14","endLine":335,"groupId":"20759","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"makeClient","params":"(finalCachePopulatorcachePopulator@finalCachecache@finalintmergeLimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/3e/fe7bc5d759ccfc618814606ab4ca215d06f24f.src","preCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public VersionedIntervalTimeline<String, ServerSelector> getTimeline(DataSource dataSource)\n          {\n            return timeline;\n          }\n\n          @Nullable\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        OBJECT_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n\n          @Override\n          public int getMergePoolParallelism()\n          {\n            \r\n            return 4;\n          }\n        },\n        ForkJoinPool.commonPool()\n    );\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientFunctionalityTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":235,"status":"M"}],"commitId":"f0f68570ec1e897348ab7c2825c7063e1330355e","commitMessage":"@@@Use DataSourceAnalysis throughout the query stack. (#9239)\n\nBuilds on #9235.  using the datasource analysis functionality to replace various ad-hoc\napproaches. The most interesting changes are in ClientQuerySegmentWalker (brokers). \nServerManager (historicals).  and SinkQuerySegmentWalker (indexing tasks).\n\nOther changes related to improving how we analyze queries:\n\n1) Changes TimelineServerView to return an Optional timeline.  which I thought made\n   the analysis changes cleaner to implement.\n2) Added QueryToolChest#canPerformSubquery.  which is now used by query entry points to\n   determine whether it is safe to pass a subquery dataSource to the query toolchest.\n   Fixes an issue introduced in #5471 where subqueries under non-groupBy-typed queries\n   were silently ignored.  since neither the query entry point nor the toolchest did\n   anything special with them.\n3) Removes the QueryPlus.withQuerySegmentSpec method.  which was mostly being used in\n   error-prone ways (ignoring any potential subqueries.  and not verifying that the\n   underlying data source is actually a table). Replaces with a new function. \n   Queries.withSpecificSegments.  that includes sanity checks.","date":"2020-01-24 06:07:14","modifiedFileCount":"38","status":"M","submitter":"Gian Merlino"},{"authorTime":"2020-03-10 17:57:16","codes":[{"authorDate":"2020-03-10 17:57:16","commitOrder":7,"curCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public Optional<VersionedIntervalTimeline<String, ServerSelector>> getTimeline(DataSourceAnalysis analysis)\n          {\n            return Optional.of(timeline);\n          }\n\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        JSON_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n\n          @Override\n          public int getMergePoolParallelism()\n          {\n            \r\n            return 4;\n          }\n        },\n        ForkJoinPool.commonPool(),\n        new QueryScheduler(0, NoQueryLaningStrategy.INSTANCE, new ServerConfig())\n    );\n  }\n","date":"2020-03-10 17:57:16","endLine":2482,"groupId":"5600","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"makeClient","params":"(finalCachePopulatorcachePopulator@finalCachecache@finalintmergeLimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/25/c027e9e56ed82c8b36de1a193084b8df49f8c8.src","preCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public Optional<VersionedIntervalTimeline<String, ServerSelector>> getTimeline(DataSourceAnalysis analysis)\n          {\n            return Optional.of(timeline);\n          }\n\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        JSON_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n\n          @Override\n          public int getMergePoolParallelism()\n          {\n            \r\n            return 4;\n          }\n        },\n        ForkJoinPool.commonPool()\n    );\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":2382,"status":"M"},{"authorDate":"2020-03-10 17:57:16","commitOrder":7,"curCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public Optional<? extends TimelineLookup<String, ServerSelector>> getTimeline(DataSourceAnalysis analysis)\n          {\n            return Optional.of(timeline);\n          }\n\n          @Nullable\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        OBJECT_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n\n          @Override\n          public int getMergePoolParallelism()\n          {\n            \r\n            return 4;\n          }\n        },\n        ForkJoinPool.commonPool(),\n        new QueryScheduler(0, NoQueryLaningStrategy.INSTANCE, new ServerConfig())\n    );\n  }\n","date":"2020-03-10 17:57:16","endLine":339,"groupId":"20759","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"makeClient","params":"(finalCachePopulatorcachePopulator@finalCachecache@finalintmergeLimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/ac/983eb3d4cf08e9ee294684e6714fe7529ab444.src","preCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public Optional<? extends TimelineLookup<String, ServerSelector>> getTimeline(DataSourceAnalysis analysis)\n          {\n            return Optional.of(timeline);\n          }\n\n          @Nullable\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        OBJECT_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n\n          @Override\n          public int getMergePoolParallelism()\n          {\n            \r\n            return 4;\n          }\n        },\n        ForkJoinPool.commonPool()\n    );\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientFunctionalityTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":238,"status":"M"}],"commitId":"8b9fe6f58461f1fc3f453c14f1634f9e779aeb71","commitMessage":"@@@query laning and load shedding (#9407)\n\n* prototype\n\n* merge QueryScheduler and QueryManager\n\n* everything in its right place\n\n* adjustments\n\n* docs\n\n* fixes\n\n* doc fixes\n\n* use resilience4j instead of semaphore\n\n* more tests\n\n* simplify\n\n* checkstyle\n\n* spelling\n\n* oops heh\n\n* remove unused\n\n* simplify\n\n* concurrency tests\n\n* add SqlResource tests.  refactor error response\n\n* add json config tests\n\n* use LongAdder instead of AtomicLong\n\n* remove test only stuffs from scheduler\n\n* javadocs.  etc\n\n* style\n\n* partial review stuffs\n\n* adjust\n\n* review stuffs\n\n* more javadoc\n\n* error response documentation\n\n* spelling\n\n* preserve user specified lane for NoSchedulingStrategy\n\n* more test.  why not\n\n* doc adjustment\n\n* style\n\n* missed review for make a thing a constant\n\n* fixes and tests\n\n* fix test\n\n* Update docs/configuration/index.md\n\nCo-Authored-By: sthetland <steve.hetland@imply.io>\n\n* doc update\n\nCo-authored-by: sthetland <steve.hetland@imply.io>","date":"2020-03-10 17:57:16","modifiedFileCount":"26","status":"M","submitter":"Clint Wylie"},{"authorTime":"2020-03-13 16:41:54","codes":[{"authorDate":"2020-03-13 16:41:54","commitOrder":8,"curCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public Optional<VersionedIntervalTimeline<String, ServerSelector>> getTimeline(DataSourceAnalysis analysis)\n          {\n            return Optional.of(timeline);\n          }\n\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        JSON_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n\n          @Override\n          public int getMergePoolParallelism()\n          {\n            \r\n            return 4;\n          }\n        },\n        ForkJoinPool.commonPool(),\n        new QueryScheduler(\n            0,\n            ManualQueryPrioritizationStrategy.INSTANCE,\n            NoQueryLaningStrategy.INSTANCE,\n            new ServerConfig()\n        )\n    );\n  }\n","date":"2020-03-13 16:41:54","endLine":2488,"groupId":"5600","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"makeClient","params":"(finalCachePopulatorcachePopulator@finalCachecache@finalintmergeLimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/ed/6ececbeb86d744fe9e77c643300e6128264ae7.src","preCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public Optional<VersionedIntervalTimeline<String, ServerSelector>> getTimeline(DataSourceAnalysis analysis)\n          {\n            return Optional.of(timeline);\n          }\n\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        JSON_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n\n          @Override\n          public int getMergePoolParallelism()\n          {\n            \r\n            return 4;\n          }\n        },\n        ForkJoinPool.commonPool(),\n        new QueryScheduler(0, NoQueryLaningStrategy.INSTANCE, new ServerConfig())\n    );\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":2383,"status":"M"},{"authorDate":"2020-03-13 16:41:54","commitOrder":8,"curCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public Optional<? extends TimelineLookup<String, ServerSelector>> getTimeline(DataSourceAnalysis analysis)\n          {\n            return Optional.of(timeline);\n          }\n\n          @Nullable\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        OBJECT_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n\n          @Override\n          public int getMergePoolParallelism()\n          {\n            \r\n            return 4;\n          }\n        },\n        ForkJoinPool.commonPool(),\n        new QueryScheduler(0, ManualQueryPrioritizationStrategy.INSTANCE, NoQueryLaningStrategy.INSTANCE, new ServerConfig())\n    );\n  }\n","date":"2020-03-13 16:41:54","endLine":340,"groupId":"20759","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"makeClient","params":"(finalCachePopulatorcachePopulator@finalCachecache@finalintmergeLimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/77/9fd5478d0cb7e3c83f870cb3e4e576daba1d54.src","preCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public Optional<? extends TimelineLookup<String, ServerSelector>> getTimeline(DataSourceAnalysis analysis)\n          {\n            return Optional.of(timeline);\n          }\n\n          @Nullable\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        OBJECT_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n\n          @Override\n          public int getMergePoolParallelism()\n          {\n            \r\n            return 4;\n          }\n        },\n        ForkJoinPool.commonPool(),\n        new QueryScheduler(0, NoQueryLaningStrategy.INSTANCE, new ServerConfig())\n    );\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientFunctionalityTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":239,"status":"M"}],"commitId":"6afd55c8f4b49802d873ca181727231670abd566","commitMessage":"@@@threshold based automatic query prioritization (#9493)\n\n* threshold based automatic query prioritization\n\n* fixes\n\n* spelling and fixes\n\n* fix docs\n\n* spelling\n\n* checkstyle\n\n* adjustments\n\n* doc fix","date":"2020-03-13 16:41:54","modifiedFileCount":"13","status":"M","submitter":"Clint Wylie"},{"authorTime":"2020-03-31 02:58:16","codes":[{"authorDate":"2020-03-13 16:41:54","commitOrder":9,"curCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public Optional<VersionedIntervalTimeline<String, ServerSelector>> getTimeline(DataSourceAnalysis analysis)\n          {\n            return Optional.of(timeline);\n          }\n\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        JSON_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n\n          @Override\n          public int getMergePoolParallelism()\n          {\n            \r\n            return 4;\n          }\n        },\n        ForkJoinPool.commonPool(),\n        new QueryScheduler(\n            0,\n            ManualQueryPrioritizationStrategy.INSTANCE,\n            NoQueryLaningStrategy.INSTANCE,\n            new ServerConfig()\n        )\n    );\n  }\n","date":"2020-03-13 16:41:54","endLine":2488,"groupId":"5600","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"makeClient","params":"(finalCachePopulatorcachePopulator@finalCachecache@finalintmergeLimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/ed/6ececbeb86d744fe9e77c643300e6128264ae7.src","preCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public Optional<VersionedIntervalTimeline<String, ServerSelector>> getTimeline(DataSourceAnalysis analysis)\n          {\n            return Optional.of(timeline);\n          }\n\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        JSON_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n\n          @Override\n          public int getMergePoolParallelism()\n          {\n            \r\n            return 4;\n          }\n        },\n        ForkJoinPool.commonPool(),\n        new QueryScheduler(\n            0,\n            ManualQueryPrioritizationStrategy.INSTANCE,\n            NoQueryLaningStrategy.INSTANCE,\n            new ServerConfig()\n        )\n    );\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":2383,"status":"N"},{"authorDate":"2020-03-31 02:58:16","commitOrder":9,"curCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public Optional<? extends TimelineLookup<String, ServerSelector>> getTimeline(DataSourceAnalysis analysis)\n          {\n            return Optional.of(timeline);\n          }\n\n          @Nullable\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        OBJECT_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n\n          @Override\n          public int getMergePoolParallelism()\n          {\n            \r\n            return 4;\n          }\n        },\n        ForkJoinPool.commonPool(),\n        QueryStackTests.DEFAULT_NOOP_SCHEDULER\n    );\n  }\n","date":"2020-03-31 02:58:16","endLine":337,"groupId":"20759","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"makeClient","params":"(finalCachePopulatorcachePopulator@finalCachecache@finalintmergeLimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/53/03989b80cc57e1a7979fda6db04c4312cccd3e.src","preCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public Optional<? extends TimelineLookup<String, ServerSelector>> getTimeline(DataSourceAnalysis analysis)\n          {\n            return Optional.of(timeline);\n          }\n\n          @Nullable\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        OBJECT_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n\n          @Override\n          public int getMergePoolParallelism()\n          {\n            \r\n            return 4;\n          }\n        },\n        ForkJoinPool.commonPool(),\n        new QueryScheduler(0, ManualQueryPrioritizationStrategy.INSTANCE, NoQueryLaningStrategy.INSTANCE, new ServerConfig())\n    );\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientFunctionalityTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":236,"status":"M"}],"commitId":"fa5da6693ca4dbb614c6398e50e34b772298f5ae","commitMessage":"@@@add lane enforcement for joinish queries (#9563)\n\n* add lane enforcement for joinish queries\n\n* oops\n\n* style\n\n* review stuffs","date":"2020-03-31 02:58:16","modifiedFileCount":"13","status":"M","submitter":"Clint Wylie"},{"authorTime":"2020-10-10 08:42:30","codes":[{"authorDate":"2020-10-10 08:42:30","commitOrder":10,"curCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public Optional<VersionedIntervalTimeline<String, ServerSelector>> getTimeline(DataSourceAnalysis analysis)\n          {\n            return Optional.of(timeline);\n          }\n\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        JSON_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n\n          @Override\n          public int getMergePoolParallelism()\n          {\n            \r\n            return 4;\n          }\n        },\n        ForkJoinPool.commonPool(),\n        new QueryScheduler(\n            0,\n            ManualQueryPrioritizationStrategy.INSTANCE,\n            NoQueryLaningStrategy.INSTANCE,\n            new ServerConfig()\n        ),\n        new MapJoinableFactory(ImmutableSet.of(), ImmutableMap.of())\n    );\n  }\n","date":"2020-10-10 08:42:30","endLine":2855,"groupId":"5600","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"makeClient","params":"(finalCachePopulatorcachePopulator@finalCachecache@finalintmergeLimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/5b/96d7ad873aad715bbad0cab0798f0ea098534a.src","preCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public Optional<VersionedIntervalTimeline<String, ServerSelector>> getTimeline(DataSourceAnalysis analysis)\n          {\n            return Optional.of(timeline);\n          }\n\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        JSON_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n\n          @Override\n          public int getMergePoolParallelism()\n          {\n            \r\n            return 4;\n          }\n        },\n        ForkJoinPool.commonPool(),\n        new QueryScheduler(\n            0,\n            ManualQueryPrioritizationStrategy.INSTANCE,\n            NoQueryLaningStrategy.INSTANCE,\n            new ServerConfig()\n        )\n    );\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":2749,"status":"M"},{"authorDate":"2020-10-10 08:42:30","commitOrder":10,"curCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public Optional<? extends TimelineLookup<String, ServerSelector>> getTimeline(DataSourceAnalysis analysis)\n          {\n            return Optional.of(timeline);\n          }\n\n          @Nullable\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        OBJECT_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n\n          @Override\n          public int getMergePoolParallelism()\n          {\n            \r\n            return 4;\n          }\n        },\n        ForkJoinPool.commonPool(),\n        QueryStackTests.DEFAULT_NOOP_SCHEDULER,\n        new MapJoinableFactory(ImmutableSet.of(), ImmutableMap.of())\n    );\n  }\n","date":"2020-10-10 08:42:30","endLine":340,"groupId":"20759","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"makeClient","params":"(finalCachePopulatorcachePopulator@finalCachecache@finalintmergeLimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/1d/591e2148db9797973d01cd1a64e9d7ca8e9cd0.src","preCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public Optional<? extends TimelineLookup<String, ServerSelector>> getTimeline(DataSourceAnalysis analysis)\n          {\n            return Optional.of(timeline);\n          }\n\n          @Nullable\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        OBJECT_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n\n          @Override\n          public int getMergePoolParallelism()\n          {\n            \r\n            return 4;\n          }\n        },\n        ForkJoinPool.commonPool(),\n        QueryStackTests.DEFAULT_NOOP_SCHEDULER\n    );\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientFunctionalityTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":238,"status":"M"}],"commitId":"4d2a92f46a121fc8b3f5a02f1480156ccc62bb4a","commitMessage":"@@@Add caching support to join queries (#10366)\n\n* Proposed changes for making joins cacheable\n\n* Add unit tests\n\n* Fix tests\n\n* simplify logic\n\n* Pull empty byte array logic out of CachingQueryRunner\n\n* remove useless null check\n\n* Minor refactor\n\n* Fix tests\n\n* Fix segment caching on Broker\n\n* Move join cache key computation in Broker\n\nMove join cache key computation in Broker from ResultLevelCachingQueryRunner to CachingClusteredClient\n\n* Fix compilation\n\n* Review comments\n\n* Add more tests\n\n* Fix inspection errors\n\n* Pushed condition analysis to JoinableFactory\n\n* review comments\n\n* Disable join caching for broker and add prefix key to BroadcastSegmentIndexedTable\n\n* Remove commented lines\n\n* Fix populateCache\n\n* Disable caching for selective datasources\n\nRefactored the code so that we can decide at the data source level.  whether to enable cache for broker or data nodes","date":"2020-10-10 08:42:30","modifiedFileCount":"52","status":"M","submitter":"Abhishek Agarwal"},{"authorTime":"2021-07-23 08:57:35","codes":[{"authorDate":"2021-07-23 08:57:35","commitOrder":11,"curCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public Optional<VersionedIntervalTimeline<String, ServerSelector>> getTimeline(DataSourceAnalysis analysis)\n          {\n            return Optional.of(timeline);\n          }\n\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        JSON_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n\n          @Override\n          public int getMergePoolParallelism()\n          {\n            \r\n            return 4;\n          }\n        },\n        ForkJoinPool.commonPool(),\n        new QueryScheduler(\n            0,\n            ManualQueryPrioritizationStrategy.INSTANCE,\n            NoQueryLaningStrategy.INSTANCE,\n            new ServerConfig()\n        ),\n        new MapJoinableFactory(ImmutableSet.of(), ImmutableMap.of()),\n        new NoopServiceEmitter()\n    );\n  }\n","date":"2021-07-23 08:57:35","endLine":2857,"groupId":"10894","id":21,"instanceNumber":1,"isCurCommit":1,"methodName":"makeClient","params":"(finalCachePopulatorcachePopulator@finalCachecache@finalintmergeLimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/6f/e08c4622ba7dd423571451fabc51cdc1dced11.src","preCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public Optional<VersionedIntervalTimeline<String, ServerSelector>> getTimeline(DataSourceAnalysis analysis)\n          {\n            return Optional.of(timeline);\n          }\n\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        JSON_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n\n          @Override\n          public int getMergePoolParallelism()\n          {\n            \r\n            return 4;\n          }\n        },\n        ForkJoinPool.commonPool(),\n        new QueryScheduler(\n            0,\n            ManualQueryPrioritizationStrategy.INSTANCE,\n            NoQueryLaningStrategy.INSTANCE,\n            new ServerConfig()\n        ),\n        new MapJoinableFactory(ImmutableSet.of(), ImmutableMap.of())\n    );\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":2750,"status":"M"},{"authorDate":"2021-07-23 08:57:35","commitOrder":11,"curCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public Optional<? extends TimelineLookup<String, ServerSelector>> getTimeline(DataSourceAnalysis analysis)\n          {\n            return Optional.of(timeline);\n          }\n\n          @Nullable\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        OBJECT_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n\n          @Override\n          public int getMergePoolParallelism()\n          {\n            \r\n            return 4;\n          }\n        },\n        ForkJoinPool.commonPool(),\n        QueryStackTests.DEFAULT_NOOP_SCHEDULER,\n        new MapJoinableFactory(ImmutableSet.of(), ImmutableMap.of()),\n        new NoopServiceEmitter()\n    );\n  }\n","date":"2021-07-23 08:57:35","endLine":342,"groupId":"10894","id":22,"instanceNumber":2,"isCurCommit":1,"methodName":"makeClient","params":"(finalCachePopulatorcachePopulator@finalCachecache@finalintmergeLimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/a8/97e09d64349147388b894d48595ea129043452.src","preCode":"  protected CachingClusteredClient makeClient(\n      final CachePopulator cachePopulator,\n      final Cache cache,\n      final int mergeLimit\n  )\n  {\n    return new CachingClusteredClient(\n        WAREHOUSE,\n        new TimelineServerView()\n        {\n          @Override\n          public void registerSegmentCallback(Executor exec, SegmentCallback callback)\n          {\n          }\n\n          @Override\n          public Optional<? extends TimelineLookup<String, ServerSelector>> getTimeline(DataSourceAnalysis analysis)\n          {\n            return Optional.of(timeline);\n          }\n\n          @Nullable\n          @Override\n          public List<ImmutableDruidServer> getDruidServers()\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public void registerTimelineCallback(final Executor exec, final TimelineCallback callback)\n          {\n            throw new UnsupportedOperationException();\n          }\n\n          @Override\n          public <T> QueryRunner<T> getQueryRunner(DruidServer server)\n          {\n            return serverView.getQueryRunner(server);\n          }\n\n          @Override\n          public void registerServerRemovedCallback(Executor exec, ServerRemovedCallback callback)\n          {\n\n          }\n        },\n        cache,\n        OBJECT_MAPPER,\n        cachePopulator,\n        new CacheConfig()\n        {\n          @Override\n          public boolean isPopulateCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isUseCache()\n          {\n            return true;\n          }\n\n          @Override\n          public boolean isQueryCacheable(Query query)\n          {\n            return true;\n          }\n\n          @Override\n          public int getCacheBulkMergeLimit()\n          {\n            return mergeLimit;\n          }\n        },\n        new DruidHttpClientConfig()\n        {\n          @Override\n          public long getMaxQueuedBytes()\n          {\n            return 0L;\n          }\n        },\n        new DruidProcessingConfig()\n        {\n          @Override\n          public String getFormatString()\n          {\n            return null;\n          }\n\n          @Override\n          public int getMergePoolParallelism()\n          {\n            \r\n            return 4;\n          }\n        },\n        ForkJoinPool.commonPool(),\n        QueryStackTests.DEFAULT_NOOP_SCHEDULER,\n        new MapJoinableFactory(ImmutableSet.of(), ImmutableMap.of())\n    );\n  }\n","realPath":"server/src/test/java/org/apache/druid/client/CachingClusteredClientFunctionalityTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":239,"status":"M"}],"commitId":"9767b42e85a91d4e2b71b3f718d072a9b52d140d","commitMessage":"@@@Add a new metric query/segments/count that is not emitted by default (#11394)\n\n* Add a new metric query/segments/count that is not emitted by default\n\n* docs\n\n* test the default implementation of the metric\n\n* fix spelling error in docs\n\n* document the fact that query retries will result in additional metric emissions\n\n* update using recommended text from @jihoonson","date":"2021-07-23 08:57:35","modifiedFileCount":"11","status":"M","submitter":"Lucas Capistrant"}]
