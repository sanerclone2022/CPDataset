[{"authorTime":"2020-06-04 07:46:28","codes":[{"authorDate":"2020-06-04 07:46:28","commitOrder":1,"curCode":"  public void testJoinOuterGroupByAndSubqueryHasLimit() throws Exception\n  {\n    \r\n    cannotVectorize();\n\n    testQuery(\n        \"SELECT dim2, AVG(m2) FROM (SELECT * FROM foo AS t1 INNER JOIN foo AS t2 ON t1.m1 = t2.m1 LIMIT 10) AS t3 GROUP BY dim2\",\n        ImmutableList.of(\n            GroupByQuery.builder()\n                        .setDataSource(\n                            newScanQueryBuilder()\n                                .dataSource(\n                                    join(\n                                        new TableDataSource(CalciteTests.DATASOURCE1),\n                                        new QueryDataSource(\n                                            newScanQueryBuilder()\n                                                .dataSource(CalciteTests.DATASOURCE1)\n                                                .intervals(querySegmentSpec(Filtration.eternity()))\n                                                .columns(ImmutableList.of(\"m1\"))\n                                                .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                                                .context(QUERY_CONTEXT_DEFAULT)\n                                                .build()\n                                        ),\n                                        \"j0.\",\n                                        equalsCondition(\n                                            DruidExpression.fromColumn(\"m1\"),\n                                            DruidExpression.fromColumn(\"j0.m1\")\n                                        ),\n                                        JoinType.INNER\n                                    )\n                                )\n                                .intervals(querySegmentSpec(Filtration.eternity()))\n                                .limit(10)\n                                .columns(\"__time\", \"cnt\", \"dim1\", \"dim2\", \"dim3\", \"j0.m1\", \"m1\", \"m2\", \"unique_dim1\")\n                                .context(QUERY_CONTEXT_DEFAULT)\n                                .build()\n                        )\n                        .setInterval(querySegmentSpec(Filtration.eternity()))\n                        .setDimensions(new DefaultDimensionSpec(\"dim2\", \"d0\", ValueType.STRING))\n                        .setGranularity(Granularities.ALL)\n                        .setAggregatorSpecs(aggregators(\n                            new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                            new CountAggregatorFactory(\"a0:count\")\n                                            )\n                        )\n                        .setPostAggregatorSpecs(\n                            ImmutableList.of(\n                                new ArithmeticPostAggregator(\n                                    \"a0\",\n                                    \"quotient\",\n                                    ImmutableList.of(\n                                        new FieldAccessPostAggregator(null, \"a0:sum\"),\n                                        new FieldAccessPostAggregator(null, \"a0:count\")\n                                    )\n                                )\n\n                            )\n                        )\n                        .setContext(QUERY_CONTEXT_DEFAULT)\n                        .build()\n        ),\n        NullHandling.sqlCompatible()\n        ? ImmutableList.of(\n            new Object[]{null, 4.0},\n            new Object[]{\"\", 3.0},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n        : ImmutableList.of(\n            new Object[]{\"\", 3.6666666666666665},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n    );\n  }\n","date":"2020-06-04 07:46:28","endLine":239,"groupId":"23486","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoinOuterGroupByAndSubqueryHasLimit","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/80/68a0d9e38b7f8629d5cf759c2492a4d2cb8fd4.src","preCode":"  public void testJoinOuterGroupByAndSubqueryHasLimit() throws Exception\n  {\n    \r\n    cannotVectorize();\n\n    testQuery(\n        \"SELECT dim2, AVG(m2) FROM (SELECT * FROM foo AS t1 INNER JOIN foo AS t2 ON t1.m1 = t2.m1 LIMIT 10) AS t3 GROUP BY dim2\",\n        ImmutableList.of(\n            GroupByQuery.builder()\n                        .setDataSource(\n                            newScanQueryBuilder()\n                                .dataSource(\n                                    join(\n                                        new TableDataSource(CalciteTests.DATASOURCE1),\n                                        new QueryDataSource(\n                                            newScanQueryBuilder()\n                                                .dataSource(CalciteTests.DATASOURCE1)\n                                                .intervals(querySegmentSpec(Filtration.eternity()))\n                                                .columns(ImmutableList.of(\"m1\"))\n                                                .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                                                .context(QUERY_CONTEXT_DEFAULT)\n                                                .build()\n                                        ),\n                                        \"j0.\",\n                                        equalsCondition(\n                                            DruidExpression.fromColumn(\"m1\"),\n                                            DruidExpression.fromColumn(\"j0.m1\")\n                                        ),\n                                        JoinType.INNER\n                                    )\n                                )\n                                .intervals(querySegmentSpec(Filtration.eternity()))\n                                .limit(10)\n                                .columns(\"__time\", \"cnt\", \"dim1\", \"dim2\", \"dim3\", \"j0.m1\", \"m1\", \"m2\", \"unique_dim1\")\n                                .context(QUERY_CONTEXT_DEFAULT)\n                                .build()\n                        )\n                        .setInterval(querySegmentSpec(Filtration.eternity()))\n                        .setDimensions(new DefaultDimensionSpec(\"dim2\", \"d0\", ValueType.STRING))\n                        .setGranularity(Granularities.ALL)\n                        .setAggregatorSpecs(aggregators(\n                            new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                            new CountAggregatorFactory(\"a0:count\")\n                                            )\n                        )\n                        .setPostAggregatorSpecs(\n                            ImmutableList.of(\n                                new ArithmeticPostAggregator(\n                                    \"a0\",\n                                    \"quotient\",\n                                    ImmutableList.of(\n                                        new FieldAccessPostAggregator(null, \"a0:sum\"),\n                                        new FieldAccessPostAggregator(null, \"a0:count\")\n                                    )\n                                )\n\n                            )\n                        )\n                        .setContext(QUERY_CONTEXT_DEFAULT)\n                        .build()\n        ),\n        NullHandling.sqlCompatible()\n        ? ImmutableList.of(\n            new Object[]{null, 4.0},\n            new Object[]{\"\", 3.0},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n        : ImmutableList.of(\n            new Object[]{\"\", 3.6666666666666665},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n    );\n  }\n","realPath":"sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":165,"status":"B"},{"authorDate":"2020-06-04 07:46:28","commitOrder":1,"curCode":"  public void testJoinOuterGroupByAndSubqueryNoLimit() throws Exception\n  {\n    \r\n    cannotVectorize();\n\n    testQuery(\n        \"SELECT dim2, AVG(m2) FROM (SELECT * FROM foo AS t1 INNER JOIN foo AS t2 ON t1.m1 = t2.m1) AS t3 GROUP BY dim2\",\n        ImmutableList.of(\n            GroupByQuery.builder()\n                        .setDataSource(\n                            join(\n                                new TableDataSource(CalciteTests.DATASOURCE1),\n                                new QueryDataSource(\n                                    newScanQueryBuilder()\n                                        .dataSource(CalciteTests.DATASOURCE1)\n                                        .intervals(querySegmentSpec(Filtration.eternity()))\n                                        .columns(ImmutableList.of(\"m1\"))\n                                        .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                                        .context(QUERY_CONTEXT_DEFAULT)\n                                        .build()\n                                ),\n                                \"j0.\",\n                                equalsCondition(\n                                    DruidExpression.fromColumn(\"m1\"),\n                                    DruidExpression.fromColumn(\"j0.m1\")\n                                ),\n                                JoinType.INNER\n                            )\n                        )\n                        .setInterval(querySegmentSpec(Filtration.eternity()))\n                        .setDimensions(new DefaultDimensionSpec(\"dim2\", \"d0\", ValueType.STRING))\n                        .setGranularity(Granularities.ALL)\n                        .setAggregatorSpecs(aggregators(\n                            new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                            new CountAggregatorFactory(\"a0:count\")\n                                            )\n                        )\n                        .setPostAggregatorSpecs(\n                            ImmutableList.of(\n                                new ArithmeticPostAggregator(\n                                    \"a0\",\n                                    \"quotient\",\n                                    ImmutableList.of(\n                                        new FieldAccessPostAggregator(null, \"a0:sum\"),\n                                        new FieldAccessPostAggregator(null, \"a0:count\")\n                                    )\n                                )\n\n                            )\n                        )\n                        .setContext(QUERY_CONTEXT_DEFAULT)\n                        .build()\n        ),\n        NullHandling.sqlCompatible()\n        ? ImmutableList.of(\n            new Object[]{null, 4.0},\n            new Object[]{\"\", 3.0},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n        : ImmutableList.of(\n            new Object[]{\"\", 3.6666666666666665},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n    );\n  }\n","date":"2020-06-04 07:46:28","endLine":308,"groupId":"13697","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoinOuterGroupByAndSubqueryNoLimit","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/80/68a0d9e38b7f8629d5cf759c2492a4d2cb8fd4.src","preCode":"  public void testJoinOuterGroupByAndSubqueryNoLimit() throws Exception\n  {\n    \r\n    cannotVectorize();\n\n    testQuery(\n        \"SELECT dim2, AVG(m2) FROM (SELECT * FROM foo AS t1 INNER JOIN foo AS t2 ON t1.m1 = t2.m1) AS t3 GROUP BY dim2\",\n        ImmutableList.of(\n            GroupByQuery.builder()\n                        .setDataSource(\n                            join(\n                                new TableDataSource(CalciteTests.DATASOURCE1),\n                                new QueryDataSource(\n                                    newScanQueryBuilder()\n                                        .dataSource(CalciteTests.DATASOURCE1)\n                                        .intervals(querySegmentSpec(Filtration.eternity()))\n                                        .columns(ImmutableList.of(\"m1\"))\n                                        .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                                        .context(QUERY_CONTEXT_DEFAULT)\n                                        .build()\n                                ),\n                                \"j0.\",\n                                equalsCondition(\n                                    DruidExpression.fromColumn(\"m1\"),\n                                    DruidExpression.fromColumn(\"j0.m1\")\n                                ),\n                                JoinType.INNER\n                            )\n                        )\n                        .setInterval(querySegmentSpec(Filtration.eternity()))\n                        .setDimensions(new DefaultDimensionSpec(\"dim2\", \"d0\", ValueType.STRING))\n                        .setGranularity(Granularities.ALL)\n                        .setAggregatorSpecs(aggregators(\n                            new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                            new CountAggregatorFactory(\"a0:count\")\n                                            )\n                        )\n                        .setPostAggregatorSpecs(\n                            ImmutableList.of(\n                                new ArithmeticPostAggregator(\n                                    \"a0\",\n                                    \"quotient\",\n                                    ImmutableList.of(\n                                        new FieldAccessPostAggregator(null, \"a0:sum\"),\n                                        new FieldAccessPostAggregator(null, \"a0:count\")\n                                    )\n                                )\n\n                            )\n                        )\n                        .setContext(QUERY_CONTEXT_DEFAULT)\n                        .build()\n        ),\n        NullHandling.sqlCompatible()\n        ? ImmutableList.of(\n            new Object[]{null, 4.0},\n            new Object[]{\"\", 3.0},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n        : ImmutableList.of(\n            new Object[]{\"\", 3.6666666666666665},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n    );\n  }\n","realPath":"sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":242,"status":"B"}],"commitId":"790e9482ea18d87d59eeeeab4ceec14e4b1e192d","commitMessage":"@@@Fix Subquery could not be converted to groupBy query (#9959)\n\n* Fix join\n\n* Fix Subquery could not be converted to groupBy query\n\n* Fix Subquery could not be converted to groupBy query\n\n* Fix Subquery could not be converted to groupBy query\n\n* Fix Subquery could not be converted to groupBy query\n\n* Fix Subquery could not be converted to groupBy query\n\n* Fix Subquery could not be converted to groupBy query\n\n* Fix Subquery could not be converted to groupBy query\n\n* Fix Subquery could not be converted to groupBy query\n\n* add tests\n\n* address comments\n\n* fix failing tests","date":"2020-06-04 07:46:28","modifiedFileCount":"12","status":"B","submitter":"Maytas Monsereenusorn"},{"authorTime":"2020-07-08 23:38:56","codes":[{"authorDate":"2020-07-08 23:38:56","commitOrder":2,"curCode":"  public void testJoinOuterGroupByAndSubqueryHasLimit() throws Exception\n  {\n    \r\n    cannotVectorize();\n\n    testQuery(\n        \"SELECT dim2, AVG(m2) FROM (SELECT * FROM foo AS t1 INNER JOIN foo AS t2 ON t1.m1 = t2.m1 LIMIT 10) AS t3 GROUP BY dim2\",\n        ImmutableList.of(\n            GroupByQuery.builder()\n                        .setDataSource(\n                            newScanQueryBuilder()\n                                .dataSource(\n                                    join(\n                                        new TableDataSource(CalciteTests.DATASOURCE1),\n                                        new QueryDataSource(\n                                            newScanQueryBuilder()\n                                                .dataSource(CalciteTests.DATASOURCE1)\n                                                .intervals(querySegmentSpec(Filtration.eternity()))\n                                                .columns(ImmutableList.of(\"m1\"))\n                                                .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                                                .context(QUERY_CONTEXT_DEFAULT)\n                                                .build()\n                                        ),\n                                        \"j0.\",\n                                        equalsCondition(\n                                            DruidExpression.fromColumn(\"m1\"),\n                                            DruidExpression.fromColumn(\"j0.m1\")\n                                        ),\n                                        JoinType.INNER\n                                    )\n                                )\n                                .intervals(querySegmentSpec(Filtration.eternity()))\n                                .limit(10)\n                                .columns(\"__time\", \"cnt\", \"dim1\", \"dim2\", \"dim3\", \"j0.m1\", \"m1\", \"m2\", \"unique_dim1\")\n                                .context(QUERY_CONTEXT_DEFAULT)\n                                .build()\n                        )\n                        .setInterval(querySegmentSpec(Filtration.eternity()))\n                        .setDimensions(new DefaultDimensionSpec(\"dim2\", \"d0\", ValueType.STRING))\n                        .setGranularity(Granularities.ALL)\n                        .setAggregatorSpecs(\n                            useDefault\n                            ? aggregators(\n                              new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                              new CountAggregatorFactory(\"a0:count\")\n                            )\n                            : aggregators(\n                                new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                                new FilteredAggregatorFactory(\n                                    new CountAggregatorFactory(\"a0:count\"),\n                                    not(selector(\"m2\", null, null))\n                                )\n                            )\n                        )\n                        .setPostAggregatorSpecs(\n                            ImmutableList.of(\n                                new ArithmeticPostAggregator(\n                                    \"a0\",\n                                    \"quotient\",\n                                    ImmutableList.of(\n                                        new FieldAccessPostAggregator(null, \"a0:sum\"),\n                                        new FieldAccessPostAggregator(null, \"a0:count\")\n                                    )\n                                )\n\n                            )\n                        )\n                        .setContext(QUERY_CONTEXT_DEFAULT)\n                        .build()\n        ),\n        NullHandling.sqlCompatible()\n        ? ImmutableList.of(\n            new Object[]{null, 4.0},\n            new Object[]{\"\", 3.0},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n        : ImmutableList.of(\n            new Object[]{\"\", 3.6666666666666665},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n    );\n  }\n","date":"2020-07-08 23:38:56","endLine":290,"groupId":"19106","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoinOuterGroupByAndSubqueryHasLimit","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/de/ffe204d42ebe73c27bc4d0353e239d4c1ab61d.src","preCode":"  public void testJoinOuterGroupByAndSubqueryHasLimit() throws Exception\n  {\n    \r\n    cannotVectorize();\n\n    testQuery(\n        \"SELECT dim2, AVG(m2) FROM (SELECT * FROM foo AS t1 INNER JOIN foo AS t2 ON t1.m1 = t2.m1 LIMIT 10) AS t3 GROUP BY dim2\",\n        ImmutableList.of(\n            GroupByQuery.builder()\n                        .setDataSource(\n                            newScanQueryBuilder()\n                                .dataSource(\n                                    join(\n                                        new TableDataSource(CalciteTests.DATASOURCE1),\n                                        new QueryDataSource(\n                                            newScanQueryBuilder()\n                                                .dataSource(CalciteTests.DATASOURCE1)\n                                                .intervals(querySegmentSpec(Filtration.eternity()))\n                                                .columns(ImmutableList.of(\"m1\"))\n                                                .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                                                .context(QUERY_CONTEXT_DEFAULT)\n                                                .build()\n                                        ),\n                                        \"j0.\",\n                                        equalsCondition(\n                                            DruidExpression.fromColumn(\"m1\"),\n                                            DruidExpression.fromColumn(\"j0.m1\")\n                                        ),\n                                        JoinType.INNER\n                                    )\n                                )\n                                .intervals(querySegmentSpec(Filtration.eternity()))\n                                .limit(10)\n                                .columns(\"__time\", \"cnt\", \"dim1\", \"dim2\", \"dim3\", \"j0.m1\", \"m1\", \"m2\", \"unique_dim1\")\n                                .context(QUERY_CONTEXT_DEFAULT)\n                                .build()\n                        )\n                        .setInterval(querySegmentSpec(Filtration.eternity()))\n                        .setDimensions(new DefaultDimensionSpec(\"dim2\", \"d0\", ValueType.STRING))\n                        .setGranularity(Granularities.ALL)\n                        .setAggregatorSpecs(aggregators(\n                            new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                            new CountAggregatorFactory(\"a0:count\")\n                                            )\n                        )\n                        .setPostAggregatorSpecs(\n                            ImmutableList.of(\n                                new ArithmeticPostAggregator(\n                                    \"a0\",\n                                    \"quotient\",\n                                    ImmutableList.of(\n                                        new FieldAccessPostAggregator(null, \"a0:sum\"),\n                                        new FieldAccessPostAggregator(null, \"a0:count\")\n                                    )\n                                )\n\n                            )\n                        )\n                        .setContext(QUERY_CONTEXT_DEFAULT)\n                        .build()\n        ),\n        NullHandling.sqlCompatible()\n        ? ImmutableList.of(\n            new Object[]{null, 4.0},\n            new Object[]{\"\", 3.0},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n        : ImmutableList.of(\n            new Object[]{\"\", 3.6666666666666665},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n    );\n  }\n","realPath":"sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":207,"status":"M"},{"authorDate":"2020-07-08 23:38:56","commitOrder":2,"curCode":"  public void testJoinOuterGroupByAndSubqueryNoLimit() throws Exception\n  {\n    \r\n    cannotVectorize();\n\n    testQuery(\n        \"SELECT dim2, AVG(m2) FROM (SELECT * FROM foo AS t1 INNER JOIN foo AS t2 ON t1.m1 = t2.m1) AS t3 GROUP BY dim2\",\n        ImmutableList.of(\n            GroupByQuery.builder()\n                        .setDataSource(\n                            join(\n                                new TableDataSource(CalciteTests.DATASOURCE1),\n                                new QueryDataSource(\n                                    newScanQueryBuilder()\n                                        .dataSource(CalciteTests.DATASOURCE1)\n                                        .intervals(querySegmentSpec(Filtration.eternity()))\n                                        .columns(ImmutableList.of(\"m1\"))\n                                        .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                                        .context(QUERY_CONTEXT_DEFAULT)\n                                        .build()\n                                ),\n                                \"j0.\",\n                                equalsCondition(\n                                    DruidExpression.fromColumn(\"m1\"),\n                                    DruidExpression.fromColumn(\"j0.m1\")\n                                ),\n                                JoinType.INNER\n                            )\n                        )\n                        .setInterval(querySegmentSpec(Filtration.eternity()))\n                        .setDimensions(new DefaultDimensionSpec(\"dim2\", \"d0\", ValueType.STRING))\n                        .setGranularity(Granularities.ALL)\n                        .setAggregatorSpecs(\n                            useDefault\n                            ? aggregators(\n                                new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                                new CountAggregatorFactory(\"a0:count\")\n                            )\n                            : aggregators(\n                                new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                                new FilteredAggregatorFactory(\n                                    new CountAggregatorFactory(\"a0:count\"),\n                                    not(selector(\"m2\", null, null))\n                                )\n                            )\n                        )\n                        .setPostAggregatorSpecs(\n                            ImmutableList.of(\n                                new ArithmeticPostAggregator(\n                                    \"a0\",\n                                    \"quotient\",\n                                    ImmutableList.of(\n                                        new FieldAccessPostAggregator(null, \"a0:sum\"),\n                                        new FieldAccessPostAggregator(null, \"a0:count\")\n                                    )\n                                )\n\n                            )\n                        )\n                        .setContext(QUERY_CONTEXT_DEFAULT)\n                        .build()\n        ),\n        NullHandling.sqlCompatible()\n        ? ImmutableList.of(\n            new Object[]{null, 4.0},\n            new Object[]{\"\", 3.0},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n        : ImmutableList.of(\n            new Object[]{\"\", 3.6666666666666665},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n    );\n  }\n","date":"2020-07-08 23:38:56","endLine":368,"groupId":"13697","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoinOuterGroupByAndSubqueryNoLimit","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/de/ffe204d42ebe73c27bc4d0353e239d4c1ab61d.src","preCode":"  public void testJoinOuterGroupByAndSubqueryNoLimit() throws Exception\n  {\n    \r\n    cannotVectorize();\n\n    testQuery(\n        \"SELECT dim2, AVG(m2) FROM (SELECT * FROM foo AS t1 INNER JOIN foo AS t2 ON t1.m1 = t2.m1) AS t3 GROUP BY dim2\",\n        ImmutableList.of(\n            GroupByQuery.builder()\n                        .setDataSource(\n                            join(\n                                new TableDataSource(CalciteTests.DATASOURCE1),\n                                new QueryDataSource(\n                                    newScanQueryBuilder()\n                                        .dataSource(CalciteTests.DATASOURCE1)\n                                        .intervals(querySegmentSpec(Filtration.eternity()))\n                                        .columns(ImmutableList.of(\"m1\"))\n                                        .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                                        .context(QUERY_CONTEXT_DEFAULT)\n                                        .build()\n                                ),\n                                \"j0.\",\n                                equalsCondition(\n                                    DruidExpression.fromColumn(\"m1\"),\n                                    DruidExpression.fromColumn(\"j0.m1\")\n                                ),\n                                JoinType.INNER\n                            )\n                        )\n                        .setInterval(querySegmentSpec(Filtration.eternity()))\n                        .setDimensions(new DefaultDimensionSpec(\"dim2\", \"d0\", ValueType.STRING))\n                        .setGranularity(Granularities.ALL)\n                        .setAggregatorSpecs(aggregators(\n                            new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                            new CountAggregatorFactory(\"a0:count\")\n                                            )\n                        )\n                        .setPostAggregatorSpecs(\n                            ImmutableList.of(\n                                new ArithmeticPostAggregator(\n                                    \"a0\",\n                                    \"quotient\",\n                                    ImmutableList.of(\n                                        new FieldAccessPostAggregator(null, \"a0:sum\"),\n                                        new FieldAccessPostAggregator(null, \"a0:count\")\n                                    )\n                                )\n\n                            )\n                        )\n                        .setContext(QUERY_CONTEXT_DEFAULT)\n                        .build()\n        ),\n        NullHandling.sqlCompatible()\n        ? ImmutableList.of(\n            new Object[]{null, 4.0},\n            new Object[]{\"\", 3.0},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n        : ImmutableList.of(\n            new Object[]{\"\", 3.6666666666666665},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n    );\n  }\n","realPath":"sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":293,"status":"M"}],"commitId":"1b9aacb1cd1d16b23de2f4485e1398640e97f8bd","commitMessage":"@@@Fix avg sql aggregator (#10135)\n\n* new average aggregator\n\n* method to create count aggregator factory\n\n* test everything\n\n* update other usages\n\n* fix style\n\n* fix more tests\n\n* fix datasketches tests","date":"2020-07-08 23:38:56","modifiedFileCount":"5","status":"M","submitter":"Franklyn Dsouza"},{"authorTime":"2021-04-15 01:49:27","codes":[{"authorDate":"2020-07-08 23:38:56","commitOrder":3,"curCode":"  public void testJoinOuterGroupByAndSubqueryHasLimit() throws Exception\n  {\n    \r\n    cannotVectorize();\n\n    testQuery(\n        \"SELECT dim2, AVG(m2) FROM (SELECT * FROM foo AS t1 INNER JOIN foo AS t2 ON t1.m1 = t2.m1 LIMIT 10) AS t3 GROUP BY dim2\",\n        ImmutableList.of(\n            GroupByQuery.builder()\n                        .setDataSource(\n                            newScanQueryBuilder()\n                                .dataSource(\n                                    join(\n                                        new TableDataSource(CalciteTests.DATASOURCE1),\n                                        new QueryDataSource(\n                                            newScanQueryBuilder()\n                                                .dataSource(CalciteTests.DATASOURCE1)\n                                                .intervals(querySegmentSpec(Filtration.eternity()))\n                                                .columns(ImmutableList.of(\"m1\"))\n                                                .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                                                .context(QUERY_CONTEXT_DEFAULT)\n                                                .build()\n                                        ),\n                                        \"j0.\",\n                                        equalsCondition(\n                                            DruidExpression.fromColumn(\"m1\"),\n                                            DruidExpression.fromColumn(\"j0.m1\")\n                                        ),\n                                        JoinType.INNER\n                                    )\n                                )\n                                .intervals(querySegmentSpec(Filtration.eternity()))\n                                .limit(10)\n                                .columns(\"__time\", \"cnt\", \"dim1\", \"dim2\", \"dim3\", \"j0.m1\", \"m1\", \"m2\", \"unique_dim1\")\n                                .context(QUERY_CONTEXT_DEFAULT)\n                                .build()\n                        )\n                        .setInterval(querySegmentSpec(Filtration.eternity()))\n                        .setDimensions(new DefaultDimensionSpec(\"dim2\", \"d0\", ValueType.STRING))\n                        .setGranularity(Granularities.ALL)\n                        .setAggregatorSpecs(\n                            useDefault\n                            ? aggregators(\n                              new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                              new CountAggregatorFactory(\"a0:count\")\n                            )\n                            : aggregators(\n                                new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                                new FilteredAggregatorFactory(\n                                    new CountAggregatorFactory(\"a0:count\"),\n                                    not(selector(\"m2\", null, null))\n                                )\n                            )\n                        )\n                        .setPostAggregatorSpecs(\n                            ImmutableList.of(\n                                new ArithmeticPostAggregator(\n                                    \"a0\",\n                                    \"quotient\",\n                                    ImmutableList.of(\n                                        new FieldAccessPostAggregator(null, \"a0:sum\"),\n                                        new FieldAccessPostAggregator(null, \"a0:count\")\n                                    )\n                                )\n\n                            )\n                        )\n                        .setContext(QUERY_CONTEXT_DEFAULT)\n                        .build()\n        ),\n        NullHandling.sqlCompatible()\n        ? ImmutableList.of(\n            new Object[]{null, 4.0},\n            new Object[]{\"\", 3.0},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n        : ImmutableList.of(\n            new Object[]{\"\", 3.6666666666666665},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n    );\n  }\n","date":"2020-07-08 23:38:56","endLine":290,"groupId":"19106","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoinOuterGroupByAndSubqueryHasLimit","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/de/ffe204d42ebe73c27bc4d0353e239d4c1ab61d.src","preCode":"  public void testJoinOuterGroupByAndSubqueryHasLimit() throws Exception\n  {\n    \r\n    cannotVectorize();\n\n    testQuery(\n        \"SELECT dim2, AVG(m2) FROM (SELECT * FROM foo AS t1 INNER JOIN foo AS t2 ON t1.m1 = t2.m1 LIMIT 10) AS t3 GROUP BY dim2\",\n        ImmutableList.of(\n            GroupByQuery.builder()\n                        .setDataSource(\n                            newScanQueryBuilder()\n                                .dataSource(\n                                    join(\n                                        new TableDataSource(CalciteTests.DATASOURCE1),\n                                        new QueryDataSource(\n                                            newScanQueryBuilder()\n                                                .dataSource(CalciteTests.DATASOURCE1)\n                                                .intervals(querySegmentSpec(Filtration.eternity()))\n                                                .columns(ImmutableList.of(\"m1\"))\n                                                .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                                                .context(QUERY_CONTEXT_DEFAULT)\n                                                .build()\n                                        ),\n                                        \"j0.\",\n                                        equalsCondition(\n                                            DruidExpression.fromColumn(\"m1\"),\n                                            DruidExpression.fromColumn(\"j0.m1\")\n                                        ),\n                                        JoinType.INNER\n                                    )\n                                )\n                                .intervals(querySegmentSpec(Filtration.eternity()))\n                                .limit(10)\n                                .columns(\"__time\", \"cnt\", \"dim1\", \"dim2\", \"dim3\", \"j0.m1\", \"m1\", \"m2\", \"unique_dim1\")\n                                .context(QUERY_CONTEXT_DEFAULT)\n                                .build()\n                        )\n                        .setInterval(querySegmentSpec(Filtration.eternity()))\n                        .setDimensions(new DefaultDimensionSpec(\"dim2\", \"d0\", ValueType.STRING))\n                        .setGranularity(Granularities.ALL)\n                        .setAggregatorSpecs(\n                            useDefault\n                            ? aggregators(\n                              new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                              new CountAggregatorFactory(\"a0:count\")\n                            )\n                            : aggregators(\n                                new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                                new FilteredAggregatorFactory(\n                                    new CountAggregatorFactory(\"a0:count\"),\n                                    not(selector(\"m2\", null, null))\n                                )\n                            )\n                        )\n                        .setPostAggregatorSpecs(\n                            ImmutableList.of(\n                                new ArithmeticPostAggregator(\n                                    \"a0\",\n                                    \"quotient\",\n                                    ImmutableList.of(\n                                        new FieldAccessPostAggregator(null, \"a0:sum\"),\n                                        new FieldAccessPostAggregator(null, \"a0:count\")\n                                    )\n                                )\n\n                            )\n                        )\n                        .setContext(QUERY_CONTEXT_DEFAULT)\n                        .build()\n        ),\n        NullHandling.sqlCompatible()\n        ? ImmutableList.of(\n            new Object[]{null, 4.0},\n            new Object[]{\"\", 3.0},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n        : ImmutableList.of(\n            new Object[]{\"\", 3.6666666666666665},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n    );\n  }\n","realPath":"sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":207,"status":"N"},{"authorDate":"2021-04-15 01:49:27","commitOrder":3,"curCode":"  public void testJoinOuterGroupByAndSubqueryNoLimit(Map<String, Object> queryContext) throws Exception\n  {\n    \r\n    if (!isRewriteJoinToFilter(queryContext)) {\n      cannotVectorize();\n    }\n\n    testQuery(\n        \"SELECT dim2, AVG(m2) FROM (SELECT * FROM foo AS t1 INNER JOIN foo AS t2 ON t1.m1 = t2.m1) AS t3 GROUP BY dim2\",\n        queryContext,\n        ImmutableList.of(\n            GroupByQuery.builder()\n                        .setDataSource(\n                            join(\n                                new TableDataSource(CalciteTests.DATASOURCE1),\n                                new QueryDataSource(\n                                    newScanQueryBuilder()\n                                        .dataSource(CalciteTests.DATASOURCE1)\n                                        .intervals(querySegmentSpec(Filtration.eternity()))\n                                        .columns(ImmutableList.of(\"m1\"))\n                                        .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                                        .context(QUERY_CONTEXT_DEFAULT)\n                                        .build()\n                                        .withOverriddenContext(queryContext)\n                                ),\n                                \"j0.\",\n                                equalsCondition(\n                                    DruidExpression.fromColumn(\"m1\"),\n                                    DruidExpression.fromColumn(\"j0.m1\")\n                                ),\n                                JoinType.INNER\n                            )\n                        )\n                        .setInterval(querySegmentSpec(Filtration.eternity()))\n                        .setDimensions(new DefaultDimensionSpec(\"dim2\", \"d0\", ValueType.STRING))\n                        .setGranularity(Granularities.ALL)\n                        .setAggregatorSpecs(\n                            useDefault\n                            ? aggregators(\n                                new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                                new CountAggregatorFactory(\"a0:count\")\n                            )\n                            : aggregators(\n                                new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                                new FilteredAggregatorFactory(\n                                    new CountAggregatorFactory(\"a0:count\"),\n                                    not(selector(\"m2\", null, null))\n                                )\n                            )\n                        )\n                        .setPostAggregatorSpecs(\n                            ImmutableList.of(\n                                new ArithmeticPostAggregator(\n                                    \"a0\",\n                                    \"quotient\",\n                                    ImmutableList.of(\n                                        new FieldAccessPostAggregator(null, \"a0:sum\"),\n                                        new FieldAccessPostAggregator(null, \"a0:count\")\n                                    )\n                                )\n\n                            )\n                        )\n                        .setContext(QUERY_CONTEXT_DEFAULT)\n                        .build()\n                        .withOverriddenContext(queryContext)\n        ),\n        NullHandling.sqlCompatible()\n        ? ImmutableList.of(\n            new Object[]{null, 4.0},\n            new Object[]{\"\", 3.0},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n        : ImmutableList.of(\n            new Object[]{\"\", 3.6666666666666665},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n    );\n  }\n","date":"2021-04-15 01:49:27","endLine":454,"groupId":"17837","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoinOuterGroupByAndSubqueryNoLimit","params":"(Map<String@Object>queryContext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/e4/7a89a5f784d8e7b5f15645a5dacf38a7460d1d.src","preCode":"  public void testJoinOuterGroupByAndSubqueryNoLimit() throws Exception\n  {\n    \r\n    cannotVectorize();\n\n    testQuery(\n        \"SELECT dim2, AVG(m2) FROM (SELECT * FROM foo AS t1 INNER JOIN foo AS t2 ON t1.m1 = t2.m1) AS t3 GROUP BY dim2\",\n        ImmutableList.of(\n            GroupByQuery.builder()\n                        .setDataSource(\n                            join(\n                                new TableDataSource(CalciteTests.DATASOURCE1),\n                                new QueryDataSource(\n                                    newScanQueryBuilder()\n                                        .dataSource(CalciteTests.DATASOURCE1)\n                                        .intervals(querySegmentSpec(Filtration.eternity()))\n                                        .columns(ImmutableList.of(\"m1\"))\n                                        .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                                        .context(QUERY_CONTEXT_DEFAULT)\n                                        .build()\n                                ),\n                                \"j0.\",\n                                equalsCondition(\n                                    DruidExpression.fromColumn(\"m1\"),\n                                    DruidExpression.fromColumn(\"j0.m1\")\n                                ),\n                                JoinType.INNER\n                            )\n                        )\n                        .setInterval(querySegmentSpec(Filtration.eternity()))\n                        .setDimensions(new DefaultDimensionSpec(\"dim2\", \"d0\", ValueType.STRING))\n                        .setGranularity(Granularities.ALL)\n                        .setAggregatorSpecs(\n                            useDefault\n                            ? aggregators(\n                                new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                                new CountAggregatorFactory(\"a0:count\")\n                            )\n                            : aggregators(\n                                new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                                new FilteredAggregatorFactory(\n                                    new CountAggregatorFactory(\"a0:count\"),\n                                    not(selector(\"m2\", null, null))\n                                )\n                            )\n                        )\n                        .setPostAggregatorSpecs(\n                            ImmutableList.of(\n                                new ArithmeticPostAggregator(\n                                    \"a0\",\n                                    \"quotient\",\n                                    ImmutableList.of(\n                                        new FieldAccessPostAggregator(null, \"a0:sum\"),\n                                        new FieldAccessPostAggregator(null, \"a0:count\")\n                                    )\n                                )\n\n                            )\n                        )\n                        .setContext(QUERY_CONTEXT_DEFAULT)\n                        .build()\n        ),\n        NullHandling.sqlCompatible()\n        ? ImmutableList.of(\n            new Object[]{null, 4.0},\n            new Object[]{\"\", 3.0},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n        : ImmutableList.of(\n            new Object[]{\"\", 3.6666666666666665},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n    );\n  }\n","realPath":"sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":374,"status":"M"}],"commitId":"202c78c8f32bd3ec5e70e021b1494d878f38d678","commitMessage":"@@@Enable rewriting certain inner joins as filters. (#11068)\n\n* Enable rewriting certain inner joins as filters.\n\nThe main logic for doing the rewrite is in JoinableFactoryWrapper's\nsegmentMapFn method. The requirements are:\n\n- It must be an inner equi-join.\n- The right-hand columns referenced by the condition must not contain any\n  duplicate values. (If they did.  the inner join would not be guaranteed\n  to return at most one row for each left-hand-side row.)\n- No columns from the right-hand side can be used by anything other than\n  the join condition itself.\n\nHashJoinSegmentStorageAdapter is also modified to pass through to\nthe base adapter (even allowing vectorization!) in the case where 100%\nof join clauses could be rewritten as filters.\n\nIn support of this goal:\n\n- Add Query getRequiredColumns() method to help us figure out whether\n  the right-hand side of a join datasource is being used or not.\n- Add JoinConditionAnalysis getRequiredColumns() method to help us\n  figure out if the right-hand side of a join is being used by later\n  join clauses acting on the same base.\n- Add Joinable getNonNullColumnValuesIfAllUnique method to enable\n  retrieving the set of values that will form the \"in\" filter.\n- Add LookupExtractor canGetKeySet() and keySet() methods to support\n  LookupJoinable in its efforts to implement the new Joinable method.\n- Add \"enableRewriteJoinToFilter\" feature flag to\n  JoinFilterRewriteConfig. The default is disabled.\n\n* Test improvements.\n\n* Test fixes.\n\n* Avoid slow size() call.\n\n* Remove invalid test.\n\n* Fix style.\n\n* Fix mistaken default.\n\n* Small fixes.\n\n* Fix logic error.","date":"2021-04-15 01:49:27","modifiedFileCount":"38","status":"M","submitter":"Gian Merlino"},{"authorTime":"2021-04-15 01:49:27","codes":[{"authorDate":"2021-07-23 23:27:19","commitOrder":4,"curCode":"  public void testJoinOuterGroupByAndSubqueryHasLimit() throws Exception\n  {\n    \r\n    cannotVectorize();\n\n    testQuery(\n        \"SELECT dim2, AVG(m2) FROM (SELECT * FROM foo AS t1 INNER JOIN foo AS t2 ON t1.m1 = t2.m1 LIMIT 10) AS t3 GROUP BY dim2\",\n        ImmutableList.of(\n            GroupByQuery.builder()\n                        .setDataSource(\n                            newScanQueryBuilder()\n                                .dataSource(\n                                    join(\n                                        new TableDataSource(CalciteTests.DATASOURCE1),\n                                        new QueryDataSource(\n                                            newScanQueryBuilder()\n                                                .dataSource(CalciteTests.DATASOURCE1)\n                                                .intervals(querySegmentSpec(Filtration.eternity()))\n                                                .columns(ImmutableList.of(\"m1\"))\n                                                .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                                                .context(QUERY_CONTEXT_DEFAULT)\n                                                .build()\n                                        ),\n                                        \"j0.\",\n                                        equalsCondition(\n                                            DruidExpression.fromColumn(\"m1\"),\n                                            DruidExpression.fromColumn(\"j0.m1\")\n                                        ),\n                                        JoinType.INNER\n                                    )\n                                )\n                                .intervals(querySegmentSpec(Filtration.eternity()))\n                                .limit(10)\n                                .columns(\"dim2\", \"j0.m1\", \"m1\", \"m2\")\n                                .context(QUERY_CONTEXT_DEFAULT)\n                                .build()\n                        )\n                        .setInterval(querySegmentSpec(Filtration.eternity()))\n                        .setDimensions(new DefaultDimensionSpec(\"dim2\", \"d0\", ValueType.STRING))\n                        .setGranularity(Granularities.ALL)\n                        .setAggregatorSpecs(\n                            useDefault\n                            ? aggregators(\n                              new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                              new CountAggregatorFactory(\"a0:count\")\n                            )\n                            : aggregators(\n                                new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                                new FilteredAggregatorFactory(\n                                    new CountAggregatorFactory(\"a0:count\"),\n                                    not(selector(\"m2\", null, null))\n                                )\n                            )\n                        )\n                        .setPostAggregatorSpecs(\n                            ImmutableList.of(\n                                new ArithmeticPostAggregator(\n                                    \"a0\",\n                                    \"quotient\",\n                                    ImmutableList.of(\n                                        new FieldAccessPostAggregator(null, \"a0:sum\"),\n                                        new FieldAccessPostAggregator(null, \"a0:count\")\n                                    )\n                                )\n\n                            )\n                        )\n                        .setContext(QUERY_CONTEXT_DEFAULT)\n                        .build()\n        ),\n        NullHandling.sqlCompatible()\n        ? ImmutableList.of(\n            new Object[]{null, 4.0},\n            new Object[]{\"\", 3.0},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n        : ImmutableList.of(\n            new Object[]{\"\", 3.6666666666666665},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n    );\n  }\n","date":"2021-07-23 23:27:19","endLine":440,"groupId":"101564","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testJoinOuterGroupByAndSubqueryHasLimit","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/94/04b037f001631c112fc76fd2502609202a6858.src","preCode":"  public void testJoinOuterGroupByAndSubqueryHasLimit() throws Exception\n  {\n    \r\n    cannotVectorize();\n\n    testQuery(\n        \"SELECT dim2, AVG(m2) FROM (SELECT * FROM foo AS t1 INNER JOIN foo AS t2 ON t1.m1 = t2.m1 LIMIT 10) AS t3 GROUP BY dim2\",\n        ImmutableList.of(\n            GroupByQuery.builder()\n                        .setDataSource(\n                            newScanQueryBuilder()\n                                .dataSource(\n                                    join(\n                                        new TableDataSource(CalciteTests.DATASOURCE1),\n                                        new QueryDataSource(\n                                            newScanQueryBuilder()\n                                                .dataSource(CalciteTests.DATASOURCE1)\n                                                .intervals(querySegmentSpec(Filtration.eternity()))\n                                                .columns(ImmutableList.of(\"m1\"))\n                                                .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                                                .context(QUERY_CONTEXT_DEFAULT)\n                                                .build()\n                                        ),\n                                        \"j0.\",\n                                        equalsCondition(\n                                            DruidExpression.fromColumn(\"m1\"),\n                                            DruidExpression.fromColumn(\"j0.m1\")\n                                        ),\n                                        JoinType.INNER\n                                    )\n                                )\n                                .intervals(querySegmentSpec(Filtration.eternity()))\n                                .limit(10)\n                                .columns(\"__time\", \"cnt\", \"dim1\", \"dim2\", \"dim3\", \"j0.m1\", \"m1\", \"m2\", \"unique_dim1\")\n                                .context(QUERY_CONTEXT_DEFAULT)\n                                .build()\n                        )\n                        .setInterval(querySegmentSpec(Filtration.eternity()))\n                        .setDimensions(new DefaultDimensionSpec(\"dim2\", \"d0\", ValueType.STRING))\n                        .setGranularity(Granularities.ALL)\n                        .setAggregatorSpecs(\n                            useDefault\n                            ? aggregators(\n                              new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                              new CountAggregatorFactory(\"a0:count\")\n                            )\n                            : aggregators(\n                                new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                                new FilteredAggregatorFactory(\n                                    new CountAggregatorFactory(\"a0:count\"),\n                                    not(selector(\"m2\", null, null))\n                                )\n                            )\n                        )\n                        .setPostAggregatorSpecs(\n                            ImmutableList.of(\n                                new ArithmeticPostAggregator(\n                                    \"a0\",\n                                    \"quotient\",\n                                    ImmutableList.of(\n                                        new FieldAccessPostAggregator(null, \"a0:sum\"),\n                                        new FieldAccessPostAggregator(null, \"a0:count\")\n                                    )\n                                )\n\n                            )\n                        )\n                        .setContext(QUERY_CONTEXT_DEFAULT)\n                        .build()\n        ),\n        NullHandling.sqlCompatible()\n        ? ImmutableList.of(\n            new Object[]{null, 4.0},\n            new Object[]{\"\", 3.0},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n        : ImmutableList.of(\n            new Object[]{\"\", 3.6666666666666665},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n    );\n  }\n","realPath":"sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":357,"status":"M"},{"authorDate":"2021-04-15 01:49:27","commitOrder":4,"curCode":"  public void testJoinOuterGroupByAndSubqueryNoLimit(Map<String, Object> queryContext) throws Exception\n  {\n    \r\n    if (!isRewriteJoinToFilter(queryContext)) {\n      cannotVectorize();\n    }\n\n    testQuery(\n        \"SELECT dim2, AVG(m2) FROM (SELECT * FROM foo AS t1 INNER JOIN foo AS t2 ON t1.m1 = t2.m1) AS t3 GROUP BY dim2\",\n        queryContext,\n        ImmutableList.of(\n            GroupByQuery.builder()\n                        .setDataSource(\n                            join(\n                                new TableDataSource(CalciteTests.DATASOURCE1),\n                                new QueryDataSource(\n                                    newScanQueryBuilder()\n                                        .dataSource(CalciteTests.DATASOURCE1)\n                                        .intervals(querySegmentSpec(Filtration.eternity()))\n                                        .columns(ImmutableList.of(\"m1\"))\n                                        .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                                        .context(QUERY_CONTEXT_DEFAULT)\n                                        .build()\n                                        .withOverriddenContext(queryContext)\n                                ),\n                                \"j0.\",\n                                equalsCondition(\n                                    DruidExpression.fromColumn(\"m1\"),\n                                    DruidExpression.fromColumn(\"j0.m1\")\n                                ),\n                                JoinType.INNER\n                            )\n                        )\n                        .setInterval(querySegmentSpec(Filtration.eternity()))\n                        .setDimensions(new DefaultDimensionSpec(\"dim2\", \"d0\", ValueType.STRING))\n                        .setGranularity(Granularities.ALL)\n                        .setAggregatorSpecs(\n                            useDefault\n                            ? aggregators(\n                                new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                                new CountAggregatorFactory(\"a0:count\")\n                            )\n                            : aggregators(\n                                new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                                new FilteredAggregatorFactory(\n                                    new CountAggregatorFactory(\"a0:count\"),\n                                    not(selector(\"m2\", null, null))\n                                )\n                            )\n                        )\n                        .setPostAggregatorSpecs(\n                            ImmutableList.of(\n                                new ArithmeticPostAggregator(\n                                    \"a0\",\n                                    \"quotient\",\n                                    ImmutableList.of(\n                                        new FieldAccessPostAggregator(null, \"a0:sum\"),\n                                        new FieldAccessPostAggregator(null, \"a0:count\")\n                                    )\n                                )\n\n                            )\n                        )\n                        .setContext(QUERY_CONTEXT_DEFAULT)\n                        .build()\n                        .withOverriddenContext(queryContext)\n        ),\n        NullHandling.sqlCompatible()\n        ? ImmutableList.of(\n            new Object[]{null, 4.0},\n            new Object[]{\"\", 3.0},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n        : ImmutableList.of(\n            new Object[]{\"\", 3.6666666666666665},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n    );\n  }\n","date":"2021-04-15 01:49:27","endLine":454,"groupId":"101564","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testJoinOuterGroupByAndSubqueryNoLimit","params":"(Map<String@Object>queryContext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-druid-10-0.7/blobInfo/CC_OUT/blobs/e4/7a89a5f784d8e7b5f15645a5dacf38a7460d1d.src","preCode":"  public void testJoinOuterGroupByAndSubqueryNoLimit(Map<String, Object> queryContext) throws Exception\n  {\n    \r\n    if (!isRewriteJoinToFilter(queryContext)) {\n      cannotVectorize();\n    }\n\n    testQuery(\n        \"SELECT dim2, AVG(m2) FROM (SELECT * FROM foo AS t1 INNER JOIN foo AS t2 ON t1.m1 = t2.m1) AS t3 GROUP BY dim2\",\n        queryContext,\n        ImmutableList.of(\n            GroupByQuery.builder()\n                        .setDataSource(\n                            join(\n                                new TableDataSource(CalciteTests.DATASOURCE1),\n                                new QueryDataSource(\n                                    newScanQueryBuilder()\n                                        .dataSource(CalciteTests.DATASOURCE1)\n                                        .intervals(querySegmentSpec(Filtration.eternity()))\n                                        .columns(ImmutableList.of(\"m1\"))\n                                        .resultFormat(ScanQuery.ResultFormat.RESULT_FORMAT_COMPACTED_LIST)\n                                        .context(QUERY_CONTEXT_DEFAULT)\n                                        .build()\n                                        .withOverriddenContext(queryContext)\n                                ),\n                                \"j0.\",\n                                equalsCondition(\n                                    DruidExpression.fromColumn(\"m1\"),\n                                    DruidExpression.fromColumn(\"j0.m1\")\n                                ),\n                                JoinType.INNER\n                            )\n                        )\n                        .setInterval(querySegmentSpec(Filtration.eternity()))\n                        .setDimensions(new DefaultDimensionSpec(\"dim2\", \"d0\", ValueType.STRING))\n                        .setGranularity(Granularities.ALL)\n                        .setAggregatorSpecs(\n                            useDefault\n                            ? aggregators(\n                                new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                                new CountAggregatorFactory(\"a0:count\")\n                            )\n                            : aggregators(\n                                new DoubleSumAggregatorFactory(\"a0:sum\", \"m2\"),\n                                new FilteredAggregatorFactory(\n                                    new CountAggregatorFactory(\"a0:count\"),\n                                    not(selector(\"m2\", null, null))\n                                )\n                            )\n                        )\n                        .setPostAggregatorSpecs(\n                            ImmutableList.of(\n                                new ArithmeticPostAggregator(\n                                    \"a0\",\n                                    \"quotient\",\n                                    ImmutableList.of(\n                                        new FieldAccessPostAggregator(null, \"a0:sum\"),\n                                        new FieldAccessPostAggregator(null, \"a0:count\")\n                                    )\n                                )\n\n                            )\n                        )\n                        .setContext(QUERY_CONTEXT_DEFAULT)\n                        .build()\n                        .withOverriddenContext(queryContext)\n        ),\n        NullHandling.sqlCompatible()\n        ? ImmutableList.of(\n            new Object[]{null, 4.0},\n            new Object[]{\"\", 3.0},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n        : ImmutableList.of(\n            new Object[]{\"\", 3.6666666666666665},\n            new Object[]{\"a\", 2.5},\n            new Object[]{\"abc\", 5.0}\n        )\n    );\n  }\n","realPath":"sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java","repoName":"druid","snippetEndLine":0,"snippetStartLine":0,"startLine":374,"status":"N"}],"commitId":"c98e7c3aa3d1b883f76f0edaafe29cf426fb119d","commitMessage":"@@@Fix left join SQL queries with IS NOT NULL filter (#11434)\n\nThis PR fixes the incorrect results for query : \n\nSELECT dim1.  l1.k FROM foo LEFT JOIN (select k || '' as k from lookup.lookyloo group by 1) l1 ON foo.dim1 = l1.k WHERE l1.k IS NOT NULL (in CalciteQueryTests)\nIn the current code.  the WHERE clause gets removed from the top of the left join and is pushed to the table foo\nleading to incorrect results.\nThe fix for such a situation is done by :\n\nConverting such left joins into inner joins (since logically the mentioned left join query is equivalent to an inner join) using Calcite while maintaining that the druid execution layer can execute such inner joins.\nPreferring converted inner joins over original left joins in our cost model","date":"2021-07-23 23:27:19","modifiedFileCount":"7","status":"M","submitter":"Rohan Garg"}]
