[{"authorTime":"2020-04-10 12:06:03","codes":[{"authorDate":"2020-04-10 12:06:03","commitOrder":1,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = FastJsonSerializer.deserialize(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n\n        TaskExecutionContext taskExecutionContext = JSONObject.parseObject(contextJson, TaskExecutionContext.class);\n        taskExecutionContext.setHost(OSUtils.getHost() + \":\" + workerConfig.getListenPort());\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Exception ex){\n            logger.error(String.format(\"create execLocalPath : %s\", execLocalPath), ex);\n        }\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        this.doAck(taskExecutionContext);\n        \r\n        workerExecService.submit(new TaskExecuteThread(taskExecutionContext,taskCallbackService));\n    }\n","date":"2020-04-10 12:06:03","endLine":107,"groupId":"1345","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/ed/476133caf8a6426c1a06b0269363bf656975d9.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = FastJsonSerializer.deserialize(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n\n        TaskExecutionContext taskExecutionContext = JSONObject.parseObject(contextJson, TaskExecutionContext.class);\n        taskExecutionContext.setHost(OSUtils.getHost() + \":\" + workerConfig.getListenPort());\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Exception ex){\n            logger.error(String.format(\"create execLocalPath : %s\", execLocalPath), ex);\n        }\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        this.doAck(taskExecutionContext);\n        \r\n        workerExecService.submit(new TaskExecuteThread(taskExecutionContext,taskCallbackService));\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskExecuteProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":78,"status":"B"},{"authorDate":"2020-04-10 12:06:03","commitOrder":1,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = FastJsonSerializer.deserialize(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n    }\n","date":"2020-04-10 12:06:03","endLine":96,"groupId":"2209","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/b6/f58279b1c51889374e47d6fbaa07a9bc7bbad8.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = FastJsonSerializer.deserialize(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"B"}],"commitId":"4c90f04bb22c67475b7ccdebb62414a02a28c7eb","commitMessage":"@@@Merge pull request #2380 from qiaozhanwei/dev\n\nrefactor-worker merge to dev","date":"2020-04-10 12:06:03","modifiedFileCount":"156","status":"B","submitter":"Tboy"},{"authorTime":"2020-04-10 12:06:03","codes":[{"authorDate":"2020-05-08 15:43:11","commitOrder":2,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = FastJsonSerializer.deserialize(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n\n        TaskExecutionContext taskExecutionContext = JSONObject.parseObject(contextJson, TaskExecutionContext.class);\n        taskExecutionContext.setHost(OSUtils.getHost() + \":\" + workerConfig.getListenPort());\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Exception ex){\n            logger.error(String.format(\"create execLocalPath : %s\", execLocalPath), ex);\n        }\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        try {\n            this.doAck(taskExecutionContext);\n        }catch (Exception e){\n            ThreadUtils.sleep(Constants.SLEEP_TIME_MILLIS);\n            this.doAck(taskExecutionContext);\n        }\n\n        \r\n        workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService));\n    }\n","date":"2020-05-08 15:43:11","endLine":113,"groupId":"1345","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/4c/a110f42b54eb59527be348eb5631014e75bde0.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = FastJsonSerializer.deserialize(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n\n        TaskExecutionContext taskExecutionContext = JSONObject.parseObject(contextJson, TaskExecutionContext.class);\n        taskExecutionContext.setHost(OSUtils.getHost() + \":\" + workerConfig.getListenPort());\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Exception ex){\n            logger.error(String.format(\"create execLocalPath : %s\", execLocalPath), ex);\n        }\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        this.doAck(taskExecutionContext);\n        \r\n        workerExecService.submit(new TaskExecuteThread(taskExecutionContext,taskCallbackService));\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskExecuteProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":78,"status":"M"},{"authorDate":"2020-04-10 12:06:03","commitOrder":2,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = FastJsonSerializer.deserialize(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n    }\n","date":"2020-04-10 12:06:03","endLine":96,"groupId":"2209","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/b6/f58279b1c51889374e47d6fbaa07a9bc7bbad8.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = FastJsonSerializer.deserialize(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"N"}],"commitId":"bb52671feec08ae5075db6d51270104fec419a83","commitMessage":"@@@Worker Group display #2627 (#2630)\n\n* dispatch task fail will set task status failed\n\n* 1?no worker condition .  master will while ture wait for worker startup\n2?worker response task status sync wait for result\n\n* 1?no worker condition .  master will while ture wait for worker startup\n2?worker response task status sync wait for result\n\n* 1?no worker condition .  master will while ture wait for worker startup\n2?worker response task status sync wait for result\n\n* 1?no worker condition .  master will while ture wait for worker startup\n2?worker response task status sync wait for result\n\n* 1?no worker condition .  master will while ture wait for worker startup\n2?worker response task status sync wait for result\n\n* 1?no worker condition .  master will while ture wait for worker startup\n2?worker response task status sync wait for result\n\n* 1?no worker condition .  master will while ture wait for worker startup\n2?worker response task status sync wait for result\n\n* 1?no worker condition .  master will while ture wait for worker startup\n2?worker response task status sync wait for result\n\n* 1?no worker condition .  master will while ture wait for worker startup\n2?worker response task status sync wait for result\n\n* 1?no worker condition .  master will while ture wait for worker startup\n2?worker response task status sync wait for result\n\n* 1?no worker condition .  master will while ture wait for worker startup\n2?worker response task status sync wait for result\n\n* 1?task status statistics and process status statistics bug fix (#2357)\n2?worker group bug fix\n\n* 1?task status statistics and process status statistics bug fix (#2357)\n2?worker group bug fix\n\n* 1?task status statistics and process status statistics bug fix (#2357)\n2?worker group bug fix\n\n* 1?task status statistics and process status statistics bug fix (#2357)\n2?worker group bug fix\n\n* send mail error.  #2466 bug fix\n\n* send mail error.  #2466 bug fix\n\n* send mail error.  #2466 bug fix\n\n* send mail error.  #2466 bug fix\n\n* #2486 bug fix\n\n* host and workergroup compatible\n\n* EnterpriseWeChatUtils modify\n\n* EnterpriseWeChatUtils modify\n\n* EnterpriseWeChatUtils modify\n\n* #2499 bug fix\n\n* add comment\n\n* revert comment\n\n* revert comment\n\n* #2499 buf fix\n\n* #2499 bug fix\n\n* #2499 bug fix\n\n* #2499 bug fix\n\n* #2499 bug fix\n\n* #2499 bug fix\n\n* #2499 bug fix\n\n* no valid worker group?master can kill task directly\n\n* no valid worker group?master can kill task directly\n\n* no valid worker group?master can kill task directly\n\n* no valid worker group?master can kill task directly\n\n* no valid worker group?master can kill task directly\n\n* no valid worker group?master can kill task directly\n\n* no valid worker group?master can kill task directly\n\n* no valid worker group?master can kill task directly\n\n* no valid worker group?master can kill task directly\n\n* No master don't create command #2571\n\n* No master don't create command #2571\n\n* No master don't create command #2571\n\n* Worker Group display #2627\n\n* Worker Group display #2627\n\n* Worker Group display #2627\n\n* Worker Group display #2627\n\n* Worker Group display #2627\n\n* Worker Group display #2627\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>","date":"2020-05-08 15:43:11","modifiedFileCount":"13","status":"M","submitter":"qiaozhanwei"},{"authorTime":"2020-04-10 12:06:03","codes":[{"authorDate":"2020-05-14 17:51:50","commitOrder":3,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = FastJsonSerializer.deserialize(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n\n        TaskExecutionContext taskExecutionContext = JSONObject.parseObject(contextJson, TaskExecutionContext.class);\n        taskExecutionContext.setHost(OSUtils.getHost() + \":\" + workerConfig.getListenPort());\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Exception ex){\n            logger.error(String.format(\"create execLocalPath : %s\", execLocalPath), ex);\n        }\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        \r\n        final Command ackCommand = buildAckCommand(taskExecutionContext).convert2Command();\n        \n        try {\n            RetryerUtils.retryCall(() -> {\n                taskCallbackService.sendAck(taskExecutionContext.getTaskInstanceId(),ackCommand);\n                return Boolean.TRUE;\n            });\n            \r\n            workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService));\n        } catch (ExecutionException | RetryException e) {\n            logger.error(e.getMessage(), e);\n        }\n    }\n","date":"2020-05-14 17:51:50","endLine":120,"groupId":"1345","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/ae/26b8d7dd4d05d8a109370da6ee60d4dec57c6a.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = FastJsonSerializer.deserialize(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n\n        TaskExecutionContext taskExecutionContext = JSONObject.parseObject(contextJson, TaskExecutionContext.class);\n        taskExecutionContext.setHost(OSUtils.getHost() + \":\" + workerConfig.getListenPort());\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Exception ex){\n            logger.error(String.format(\"create execLocalPath : %s\", execLocalPath), ex);\n        }\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        try {\n            this.doAck(taskExecutionContext);\n        }catch (Exception e){\n            ThreadUtils.sleep(Constants.SLEEP_TIME_MILLIS);\n            this.doAck(taskExecutionContext);\n        }\n\n        \r\n        workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService));\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskExecuteProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":81,"status":"M"},{"authorDate":"2020-04-10 12:06:03","commitOrder":3,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = FastJsonSerializer.deserialize(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n    }\n","date":"2020-04-10 12:06:03","endLine":96,"groupId":"2209","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/b6/f58279b1c51889374e47d6fbaa07a9bc7bbad8.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = FastJsonSerializer.deserialize(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"N"}],"commitId":"c28a697ee8a05a6e94a7e335d05d1ea0c43c7d3b","commitMessage":"@@@add RetryerUtils to retry async & sync function gracefully (#2697)\n\n* add RetryerUtils tool class for async & sync retry invoking\n\n* add RetryerUtils tool class for async & sync retry invoking\n\n* add guava-retrying-2.0.0.jar to known-dependencies.txt\n\n* fix javadoc\n\n* fix code smell\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@outlook.com>","date":"2020-05-14 17:51:50","modifiedFileCount":"1","status":"M","submitter":"gabry.wu"},{"authorTime":"2020-06-13 19:47:34","codes":[{"authorDate":"2020-06-13 19:47:34","commitOrder":4,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JsonSerializer.deserialize(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n        taskExecutionContext.setHost(OSUtils.getHost() + \":\" + workerConfig.getListenPort());\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Exception ex){\n            logger.error(String.format(\"create execLocalPath : %s\", execLocalPath), ex);\n        }\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        \r\n        final Command ackCommand = buildAckCommand(taskExecutionContext).convert2Command();\n        \n        try {\n            RetryerUtils.retryCall(() -> {\n                taskCallbackService.sendAck(taskExecutionContext.getTaskInstanceId(),ackCommand);\n                return Boolean.TRUE;\n            });\n            \r\n            workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService));\n        } catch (ExecutionException | RetryException e) {\n            logger.error(e.getMessage(), e);\n        }\n    }\n","date":"2020-06-13 19:47:34","endLine":116,"groupId":"1345","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/50/f8989b0e271defc055c7dfa4b6637318a2e1dc.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = FastJsonSerializer.deserialize(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n\n        TaskExecutionContext taskExecutionContext = JSONObject.parseObject(contextJson, TaskExecutionContext.class);\n        taskExecutionContext.setHost(OSUtils.getHost() + \":\" + workerConfig.getListenPort());\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Exception ex){\n            logger.error(String.format(\"create execLocalPath : %s\", execLocalPath), ex);\n        }\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        \r\n        final Command ackCommand = buildAckCommand(taskExecutionContext).convert2Command();\n        \n        try {\n            RetryerUtils.retryCall(() -> {\n                taskCallbackService.sendAck(taskExecutionContext.getTaskInstanceId(),ackCommand);\n                return Boolean.TRUE;\n            });\n            \r\n            workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService));\n        } catch (ExecutionException | RetryException e) {\n            logger.error(e.getMessage(), e);\n        }\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskExecuteProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":77,"status":"M"},{"authorDate":"2020-06-13 19:47:34","commitOrder":4,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JsonSerializer.deserialize(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n    }\n","date":"2020-06-13 19:47:34","endLine":96,"groupId":"2209","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/17/ae6a43b191d903c74290ac564ebca26852210f.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = FastJsonSerializer.deserialize(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"M"}],"commitId":"11c4c583286d913c17eb8efff029d93d89f98b25","commitMessage":"@@@Merge pull request #2960 from simon824/dev\n\nUsing Jackson instead of Fastjson","date":"2020-06-13 19:47:34","modifiedFileCount":"136","status":"M","submitter":"gabry.wu"},{"authorTime":"2020-06-13 19:47:34","codes":[{"authorDate":"2020-06-28 10:48:14","commitOrder":5,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JsonSerializer.deserialize(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if(taskRequestCommand == null){\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n        if(taskExecutionContext == null){\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        taskExecutionContext.setHost(OSUtils.getHost() + \":\" + workerConfig.getListenPort());\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Exception ex){\n            logger.error(String.format(\"create execLocalPath : %s\", execLocalPath), ex);\n        }\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        \r\n        final Command ackCommand = buildAckCommand(taskExecutionContext).convert2Command();\n\n        try {\n            RetryerUtils.retryCall(() -> {\n                taskCallbackService.sendAck(taskExecutionContext.getTaskInstanceId(),ackCommand);\n                return Boolean.TRUE;\n            });\n            \r\n            workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService));\n        } catch (ExecutionException | RetryException e) {\n            logger.error(e.getMessage(), e);\n        }\n    }\n","date":"2020-06-28 10:48:14","endLine":124,"groupId":"1345","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/0a/f84b100f8fa4eceb5925f7605fc67d2d2cd980.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JsonSerializer.deserialize(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n        taskExecutionContext.setHost(OSUtils.getHost() + \":\" + workerConfig.getListenPort());\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Exception ex){\n            logger.error(String.format(\"create execLocalPath : %s\", execLocalPath), ex);\n        }\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        \r\n        final Command ackCommand = buildAckCommand(taskExecutionContext).convert2Command();\n        \n        try {\n            RetryerUtils.retryCall(() -> {\n                taskCallbackService.sendAck(taskExecutionContext.getTaskInstanceId(),ackCommand);\n                return Boolean.TRUE;\n            });\n            \r\n            workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService));\n        } catch (ExecutionException | RetryException e) {\n            logger.error(e.getMessage(), e);\n        }\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskExecuteProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":76,"status":"M"},{"authorDate":"2020-06-13 19:47:34","commitOrder":5,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JsonSerializer.deserialize(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n    }\n","date":"2020-06-13 19:47:34","endLine":96,"groupId":"2209","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/17/ae6a43b191d903c74290ac564ebca26852210f.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JsonSerializer.deserialize(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"N"}],"commitId":"9bf67d80d0db866d2ead7fce1b9d33767ee0f66e","commitMessage":"@@@Revise annotation spelling errors & Enhanced code robustness (#3042)\n\n* revise annotation spelling errors & enhanced code robustness\n\n* revise annotation spelling errors & enhanced code robustness\n\nCo-authored-by: sunchaohe <sunzhaohe@linklogis.com>\nCo-authored-by: dailidong <dailidong66@gmail.com>\nCo-authored-by: qiaozhanwei <qiaozhanwei@outlook.com>","date":"2020-06-28 10:48:14","modifiedFileCount":"7","status":"M","submitter":"zixi0825"},{"authorTime":"2020-06-13 19:47:34","codes":[{"authorDate":"2020-06-28 17:43:13","commitOrder":6,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JsonSerializer.deserialize(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if(taskRequestCommand == null){\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n        if(taskExecutionContext == null){\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        taskExecutionContext.setHost(OSUtils.getHost() + \":\" + workerConfig.getListenPort());\n\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n                taskExecutionContext.getProcessDefineId(),\n                taskExecutionContext.getProcessInstanceId(),\n                taskExecutionContext.getTaskInstanceId()));\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.ofNullable(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        \r\n        final Command ackCommand = buildAckCommand(taskExecutionContext).convert2Command();\n\n        try {\n            RetryerUtils.retryCall(() -> {\n                taskCallbackService.sendAck(taskExecutionContext.getTaskInstanceId(),ackCommand);\n                return Boolean.TRUE;\n            });\n            \r\n            workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger));\n        } catch (ExecutionException | RetryException e) {\n            logger.error(e.getMessage(), e);\n        }\n    }\n","date":"2020-06-28 17:43:13","endLine":144,"groupId":"2432","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/4a/2767f138b4b7cb57f191a541741ad564dce144.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JsonSerializer.deserialize(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if(taskRequestCommand == null){\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n        if(taskExecutionContext == null){\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        taskExecutionContext.setHost(OSUtils.getHost() + \":\" + workerConfig.getListenPort());\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Exception ex){\n            logger.error(String.format(\"create execLocalPath : %s\", execLocalPath), ex);\n        }\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        \r\n        final Command ackCommand = buildAckCommand(taskExecutionContext).convert2Command();\n\n        try {\n            RetryerUtils.retryCall(() -> {\n                taskCallbackService.sendAck(taskExecutionContext.getTaskInstanceId(),ackCommand);\n                return Boolean.TRUE;\n            });\n            \r\n            workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService));\n        } catch (ExecutionException | RetryException e) {\n            logger.error(e.getMessage(), e);\n        }\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskExecuteProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"M"},{"authorDate":"2020-06-13 19:47:34","commitOrder":6,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JsonSerializer.deserialize(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n    }\n","date":"2020-06-13 19:47:34","endLine":96,"groupId":"2209","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/17/ae6a43b191d903c74290ac564ebca26852210f.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JsonSerializer.deserialize(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"N"}],"commitId":"38e485373de9a7301a19f57cb53dbf4cb6744696","commitMessage":"@@@[Feature-2925][server] Init TaskLogger in TaskExecuteProcessor (#2925) (#2965)\n\n* [Feature-2925][common] Add exitVal judge in OSUtils.exeCmd (#2925)\n\n* optimize the logger utils","date":"2020-06-28 17:43:13","modifiedFileCount":"8","status":"M","submitter":"Yichao Yang"},{"authorTime":"2020-06-30 15:23:35","codes":[{"authorDate":"2020-06-28 17:43:13","commitOrder":7,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JsonSerializer.deserialize(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if(taskRequestCommand == null){\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n        if(taskExecutionContext == null){\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        taskExecutionContext.setHost(OSUtils.getHost() + \":\" + workerConfig.getListenPort());\n\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n                taskExecutionContext.getProcessDefineId(),\n                taskExecutionContext.getProcessInstanceId(),\n                taskExecutionContext.getTaskInstanceId()));\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.ofNullable(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        \r\n        final Command ackCommand = buildAckCommand(taskExecutionContext).convert2Command();\n\n        try {\n            RetryerUtils.retryCall(() -> {\n                taskCallbackService.sendAck(taskExecutionContext.getTaskInstanceId(),ackCommand);\n                return Boolean.TRUE;\n            });\n            \r\n            workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger));\n        } catch (ExecutionException | RetryException e) {\n            logger.error(e.getMessage(), e);\n        }\n    }\n","date":"2020-06-28 17:43:13","endLine":144,"groupId":"2432","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/4a/2767f138b4b7cb57f191a541741ad564dce144.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JsonSerializer.deserialize(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if(taskRequestCommand == null){\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n        if(taskExecutionContext == null){\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        taskExecutionContext.setHost(OSUtils.getHost() + \":\" + workerConfig.getListenPort());\n\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n                taskExecutionContext.getProcessDefineId(),\n                taskExecutionContext.getProcessInstanceId(),\n                taskExecutionContext.getTaskInstanceId()));\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.ofNullable(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        \r\n        final Command ackCommand = buildAckCommand(taskExecutionContext).convert2Command();\n\n        try {\n            RetryerUtils.retryCall(() -> {\n                taskCallbackService.sendAck(taskExecutionContext.getTaskInstanceId(),ackCommand);\n                return Boolean.TRUE;\n            });\n            \r\n            workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger));\n        } catch (ExecutionException | RetryException e) {\n            logger.error(e.getMessage(), e);\n        }\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskExecuteProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"N"},{"authorDate":"2020-06-30 15:23:35","commitOrder":7,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JsonSerializer.deserialize(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","date":"2020-06-30 15:23:35","endLine":97,"groupId":"2209","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/80/0db211c36a5a2edfe8c3e60dd83b6083b0bcb6.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JsonSerializer.deserialize(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"M"}],"commitId":"ab6e4310b42ba6772b71334bc5360e470e933d7c","commitMessage":"@@@branch dev merge from dev-1.3.0 (#3087)\n\n* add DolphinScheduler slack channel\n\n* Update README.md\n\nCo-Authored-By: Jiajie Zhong <zhongjiajie955@hotmail.com>\n\n* modify soft_version 1.2.2 to 1.3.0\n\n* Repair worklist cannot be deleted\n\n* update schema version (#2657)\n\n* change schema version from 1.2.2 to 1.3.0\n\n* change version value of table t_ds_version from 2.0.0 to 1.3.0\n\n* fix bug: sub worker flow in complement data would run start date (#2581) (#2656)\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* Fix conditions node save exception\n\n* add unique key for t_ds_process_definition\n\n* add unique key for t_ds_process_definition\n\n* script variable has \"processDefinitionId\" is error #2664 (#2666)\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\n\n* update filename\n\n* Update dolphinscheduler_ddl.sql\n\n* Delete dolphinscheduler_ddl.sql\n\n* Delete dolphinscheduler_ddl.sql\n\n* add unique key for t_ds_process_definition\n\nadd unique key for t_ds_process_definition\n\n* add unique key for t_ds_process_definition\n\nadd unique key for t_ds_process_definition\n\n* Modify the alert log file\n?\n\n* blank in eamil and left font align #2648 (#2673)\n\n* script variable has \"processDefinitionId\" is error #2664\n\n* blank in eamil and left font align  #2648\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\n\n* fix zookeeper health check and merge volumes into logs volume (#2674)\n\n* fix zookeeper health check and merge volumes into logs volume\n\n1. Fix zookeeper health check\n2. Merge volumes into logs volume\n3. Modify `dockerfile/hooks/build` script\n\n* Modify ci_e2e and docker image registry\n\n* Modify ci_e2e\n\n* Modify ci_e2e\n\n* Modify ci_e2e and move ./dockerfile/hooks/check to ./docker/docker-swarm/\n\n* migrate docker composer and move dockerfile dir to docker/build\n\n* ut docker\n\n* alter dockerfile to docker/build dir\n\n* delete docker-compose old\n\n* delete dockerfile zk\n\n* delete dockerfile zk\n\n* delete dockerfile zk\n\n* [bug fix] some bugs from 1.2.0 to 1.3.0 (#2676)\n\n* fix bug: some bugs about worker group from 1.2.0 to 1.3.0\n\n* fix bug: scheduler from 1.2.0 to 1.3.0 do not work\n\n* fix bug: scheduler from 1.2.0 to 1.3.0 do not work\n\n* fix ut bug\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* add worker group config (#2681)\n\n* update README about DolphinScheduler\n\n* Update issue templates\n\n* update\n\n* regularize api pom xml\nupdate rpc maven compile to 1.8\n\n* regularize api pom xml\n\n* change commons.lang3.StringUtils to common.utils.StringUtils\n\n* update pom.xml\n\n* update\n\n* correct equals method\n\n* jasper-runtime is needed when api server start\n\n* jasper-runtime jar is needed when api server start\n\n* combine logback config of master/worker/alert/api server to one logback.xml\n\n* remove tomcat runtime jar\n\n* add UT\n\n* add license\n\n* remove jasper-runtime jar.  not need anymore\n\n* sovle jar conflict? remove servlet-api 2.5 jar\n\n* remove servlet 2.5\n\n* add embedded database h2 and update embedded zookeeper\n\n* delete logs\n\n* add license\n\n* change log level to INFO\n\n* simplify and optimize config\n\n* add development state\n\n* simplify common config\n\n* add worker group config\n\n* add worker group config\n\nCo-authored-by: lidongdai <escheduler@outlook.com>\nCo-authored-by: dailidong <dolphinschedule@gmail.com>\n\n* delete log files while deleting process instances #2463 (#2693)\n\n* script variable has \"processDefinitionId\" is error #2664\n\n* blank in eamil and left font align  #2648\n\n* delete log files while deleting process instances #2463\n\n* delete log files while deleting process instances #2463\n\n* delete log files while deleting process instances #2463\n\n* delete log files while deleting process instances #2463\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\n\n* Update dolphinscheduler_ddl.sql\n\n* Using docker/docker-swarm/docker-compose.yml to run pg and zk in ci_ut.yml (#2692)\n\n* Using docker/docker-swarm/docker-compose.yml to run pg and zk in ci_ut.yml\n\n1. add initdb volume for pg service in docker-compose.yml\n2. modify ci_ut.yml\n\n* add sudo in ci_ut.yml\n\n* Query the metadata of indexes is not correct in postgresql/dolphinscheduler_ddl.sql\n\n1. replace information_schema.STATISTICS to pg_stat_all_indexes\n2. modify ProcessDefinitionMapperTest.java\n\n* Remove inner zk and pg\n\n* add inner pg\n\n* conditions The task node adds a background color to distinguish successful and failed connections\n\n* add LoggerServerTest UT (#2713)\n\n* add LoggerServerTest UT\n\n* add LoggerServerTest UT\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\n\n* add UT (#2717)\n\n* add LoggerServerTest UT\n\n* add LoggerServerTest UT\n\n* add LoggerServerTest UT\nadd RemoveTaskLogRequestCommandTest UT\nadd RemoveTaskLogResponseCommandTest\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\n\n* fix worker group config no effect (#2719)\n\n* Conditional judgment adds text\n\n* fix\n\n* fix #2449:It's should successful to cancel authorize a resource of a user if all the online process definitions created by this user didn't use this resource. (#2725)\n\n* Underline the list of workflow operations\n\n* Modify HDFS/S3 path (#2736)\n\n* Modify HDFS/S3 path\n?\n\n* Modify HDFS/S3 path\n?\n\n* Update common.properties\n\nCo-authored-by: chenxingchun <438044805@qq.com>\nCo-authored-by: dailidong <dailidong66@gmail.com>\n\n* Modify ip configuration\n\n* set worker group  (#2743)\n\n* simple config\n\n* fix worker group config no effect\n\n* fix #2598::allow to update resource suffix. but if it is authorized to other users. it is not allowed (#2732)\n\n* fix #2598:allow to update resource suffix. but if it is authorized to other users. it is not allowed.\n\n* add RESOURCE_IS_AUTHORIZED status\n\n* verify whether the suffix is empty\n\n* remove extra variables\n\n* fix code smell\n\n* Update known-dependencies.txt\n\n* update worker group config (#2746)\n\n* fix worker group config no effect\n\n* remove codehaus janino jar\nthe license about janino maybe not compatiable with Apache v2\n\n* Merge remote-tracking branch 'upstream/dev-1.3.0' into dev-1.3.0\n\n# Conflicts:\n#\tdolphinscheduler-server/src/main/resources/config/install_config.conf\n\n* Update datasource.properties\n\n* remove codehaus janino jar (#2742)\n\nthe license about janino maybe not compatiable with Apache v2\n\n* [bug fix] fix bug:2634:Process shows success. when the task of the process is killed in the terminal (#2731)\n\n* fix bug: some bugs about worker group from 1.2.0 to 1.3.0\n\n* fix bug: scheduler from 1.2.0 to 1.3.0 do not work\n\n* fix bug: scheduler from 1.2.0 to 1.3.0 do not work\n\n* fix ut bug\n\n* fix bug: Process shows success. when the task of the process is killed in the termina\n\n* fix bug #2634: Process shows success. when the task of the process is killed in the terminal\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* Update known-dependencies.txt (#2748)\n\n* fix getWorkers bug on RunConfig (#2747)\n\n* fix worker group config no effect\n\n* remove codehaus janino jar\nthe license about janino maybe not compatiable with Apache v2\n\n* Merge remote-tracking branch 'upstream/dev-1.3.0' into dev-1.3.0\n\n# Conflicts:\n#\tdolphinscheduler-server/src/main/resources/config/install_config.conf\n\n* datasource config\n\n* Update datasource.properties\n\n* fix RunConfig bug\n\n* master select worker filter high load worker #2704 (#2733)\n\n* add LoggerServerTest UT\n\n* add LoggerServerTest UT\n\n* add LoggerServerTest UT\nadd RemoveTaskLogRequestCommandTest UT\nadd RemoveTaskLogResponseCommandTest\n\n* master select worker filter high load worker #2704\n\n* master select worker filter high load worker #2704\n\n* master select worker filter high load worker #2704\n\n* master select worker filter high load worker #2704\n\n* master select worker filter high load worker #2704\n\n* master select worker filter high load worker #2704\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\n\n* Fix rename check parameter\n\n* fix\n\n* fix 2598:change getId to getUserId (#2757)\n\n* fix #2598:allow to update resource suffix. but if it is authorized to other users. it is not allowed.\n\n* add RESOURCE_IS_AUTHORIZED status\n\n* verify whether the suffix is empty\n\n* remove extra variables\n\n* fix code smell\n\n* change getId to getUserId\n\n* Fix MySQL autoDeserialize bug (#2728)\n\n* Fix MySQL autoDeserialize bug\n\n* add MySQLDataSourceTest\n\n* Fix workflow definition history node data cannot be opened\n\n* fix\n\n* delete normalize\n\n* update e2e chrome version (#2775)\n\nCo-authored-by: chenxingchun <438044805@qq.com>\n\n* Modify the background color of conditions task node connection\n\n* [BUF FIX]fix: the master would be blocked when worker group not exists (#2764)\n\n* feature: add number configuration for master dispatch tasks\n\n* fix bug(#2762) the master would be blocked when worker group not exists\n\n* fix bug(#2762) the master would be blocked when worker group not exists\n\n* fix ut\n\n* fix ut\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* [BUG FIX] fix bug: dependent task failed when conditions task exists (#2768)\n\n* fix bug 2464: change dependent task for process.\n\n* remove unused code\n\n* add ut\n\n* add ut\n\n* update comments\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* Hourly dependency configuration? 'currentHour' and 'last24Hours' (#2696)\n\n* [feature] Add hourly dependency scenarios\n\n* [Feature] #2680\n\nadd DependentUtilsTest UT\n\nCo-authored-by: changqun.xu <changqun.xu@17zuoye.com>\nCo-authored-by: xuchangqun <changqun.x@gmail.com>\n\n* fix sql task bug #2739 (#2741)\n\n* Solve the failure to execute non-query sql\n\n* fix sql task bug\n\nCo-authored-by: sunchaohe <sunzhaohe@linklogis.com>\nCo-authored-by: qiaozhanwei <qiaozhanwei@outlook.com>\nCo-authored-by: lgcareer <18610854716@163.com>\n\n* Worker group adds check\n\n* fix\n\n* Worker group adds check (#2787)\n\n* Worker group adds check\n\n* fix\n\n* add not worker log and remove worker invalid property (#2784)\n\n* add LoggerServerTest UT\n\n* add LoggerServerTest UT\n\n* add LoggerServerTest UT\nadd RemoveTaskLogRequestCommandTest UT\nadd RemoveTaskLogResponseCommandTest\n\n* master select worker filter high load worker #2704\n\n* master select worker filter high load worker #2704\n\n* master select worker filter high load worker #2704\n\n* master select worker filter high load worker #2704\n\n* master select worker filter high load worker #2704\n\n* master select worker filter high load worker #2704\n\n* add not worker log and remove worker invalid property\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\n\n* Modify the ambari-plugin readme for packing RPM packages and add a description of the replication plug-in directory (#2786)\n\n* fixed #2788  resolve the bug #2788  (#2789)\n\n* Modify the ambari-plugin readme for packing RPM packages and add a description of the replication plug-in directory\n\n* fixed #2788\n\n* [BUG FIX] fix bug:cannot pause work flow when task state is \"submit success\" (#2783)\n\n* feature: add number configuration for master dispatch tasks\n\n* fix bug(#2762) the master would be blocked when worker group not exists\n\n* fix bug(#2762) the master would be blocked when worker group not exists\n\n* fix ut\n\n* fix ut\n\n* fix bug(2781): cannot pause work flow when task state is \"submit success\"\n\n* fix code smell\n\n* add mysql other param blank judge\n\n* test\n\n* update comments\n\n* update comments\n\n* add ut\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* fix bug:#2735 (#2770)\n\n1. store process id in zk.\n2. resolve host and port through zk path.\n3. modify ui key.\n\n* Modify startup parameter worker group value\n\n* Fix [Bug] process definition json worker group convert #2794 (#2795)\n\n* add LoggerServerTest UT\n\n* add LoggerServerTest UT\n\n* add LoggerServerTest UT\nadd RemoveTaskLogRequestCommandTest UT\nadd RemoveTaskLogResponseCommandTest\n\n* master select worker filter high load worker #2704\n\n* master select worker filter high load worker #2704\n\n* master select worker filter high load worker #2704\n\n* master select worker filter high load worker #2704\n\n* master select worker filter high load worker #2704\n\n* master select worker filter high load worker #2704\n\n* add not worker log and remove worker invalid property\n\n* process definition json worker group convert #2794\n\n* process definition json worker group convert #2794\n\n* process definition json worker group convert #2794\n\n* process definition json worker group convert #2794\n\n* process definition json worker group convert #2794\n\n* process definition json worker group convert #2794\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\n\n* [BUG FIX]fix bug: Restart the worker service again.  the previously submitted successful tasks are not executed bug (#2800)\n\n* feature: add number configuration for master dispatch tasks\n\n* fix bug(#2762) the master would be blocked when worker group not exists\n\n* fix bug(#2762) the master would be blocked when worker group not exists\n\n* fix ut\n\n* fix ut\n\n* fix bug(2781): cannot pause work flow when task state is \"submit success\"\n\n* fix code smell\n\n* add mysql other param blank judge\n\n* test\n\n* update comments\n\n* update comments\n\n* add ut\n\n* fix bug: Restart the worker service again.  the previously submitted successful tasks are not executed\n\n* update comments\n\n* add sleep\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* delete unnecessary configuration items (#2803)\n\n* rename worker_group_id to worker_group and set the value of worker_group_name (#2801)\n\n* process definition json worker group convert #2794 (#2809)\n\n* add LoggerServerTest UT\n\n* add LoggerServerTest UT\n\n* add LoggerServerTest UT\nadd RemoveTaskLogRequestCommandTest UT\nadd RemoveTaskLogResponseCommandTest\n\n* master select worker filter high load worker #2704\n\n* master select worker filter high load worker #2704\n\n* master select worker filter high load worker #2704\n\n* master select worker filter high load worker #2704\n\n* master select worker filter high load worker #2704\n\n* master select worker filter high load worker #2704\n\n* add not worker log and remove worker invalid property\n\n* process definition json worker group convert #2794\n\n* process definition json worker group convert #2794\n\n* process definition json worker group convert #2794\n\n* process definition json worker group convert #2794\n\n* process definition json worker group convert #2794\n\n* process definition json worker group convert #2794\n\n* process definition json worker group convert #2794\n\n* process definition json worker group convert #2794\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\n\n* compatible old version host not port delete log file (#2811)\n\n* add LoggerServerTest UT\n\n* add LoggerServerTest UT\n\n* add LoggerServerTest UT\nadd RemoveTaskLogRequestCommandTest UT\nadd RemoveTaskLogResponseCommandTest\n\n* master select worker filter high load worker #2704\n\n* master select worker filter high load worker #2704\n\n* master select worker filter high load worker #2704\n\n* master select worker filter high load worker #2704\n\n* master select worker filter high load worker #2704\n\n* master select worker filter high load worker #2704\n\n* add not worker log and remove worker invalid property\n\n* process definition json worker group convert #2794\n\n* process definition json worker group convert #2794\n\n* process definition json worker group convert #2794\n\n* process definition json worker group convert #2794\n\n* process definition json worker group convert #2794\n\n* process definition json worker group convert #2794\n\n* process definition json worker group convert #2794\n\n* process definition json worker group convert #2794\n\n* compatible old version host not port delete log file\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\n\n* Added instructions for ambari to add and remove Dolphin Schdumer components on nodes (#2806)\n\n* delete unnecessary configuration items\n\n* Added instructions for ambari to add and remove Dolphin Schdumer components on nodes\n\n* Added instructions for ambari to add and remove Dolphin Schdumer components on nodes\n\n* fix oracle connect failure (#2812)\n\n* use method getJdbcUrl of parent\n\n* Remove the incorrect print message\n\n* Modify process group workerGroup value display and filter child node duplicate values\n\n* Repair process definition bulk delete function\n\n* when init workflow.  the tenantId linked by the tenantId of user\n\n* dag download does not refresh.  modify the task instance operation width value\n\n* fix\n\n* [bug fix]fix bug: After the master is fault-tolerant.  it cannot resume operation  (#2813)\n\n* feature: add number configuration for master dispatch tasks\n\n* fix bug(#2762) the master would be blocked when worker group not exists\n\n* fix bug(#2762) the master would be blocked when worker group not exists\n\n* fix ut\n\n* fix ut\n\n* fix bug(2781): cannot pause work flow when task state is \"submit success\"\n\n* fix code smell\n\n* add mysql other param blank judge\n\n* test\n\n* update comments\n\n* update comments\n\n* add ut\n\n* fix bug: Restart the worker service again.  the previously submitted successful tasks are not executed\n\n* update comments\n\n* add sleep\n\n* add null point check\n\n* fix bug:After the master is fault-tolerant.  it cannot resume operation\n\n* fix bug: do not failover the host is 'NULL' process\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* When update the data source. the host and port show error (#2821)\n\n* When update the data source. the host and port show error\n\n* update DataSourceServiceTest\n\n* update DataSourceServiceTest\n\n* update DataSourceServiceTest\n\n* Fix ORACLE service name value display\n\n* Add tips for download workflow\n\n* fix\n\n* [bug fix] fix: The workflow is fault-tolerant and 2 task instances are generated (#2833)\n\n* feature: add number configuration for master dispatch tasks\n\n* fix bug(#2762) the master would be blocked when worker group not exists\n\n* fix bug(#2762) the master would be blocked when worker group not exists\n\n* fix ut\n\n* fix ut\n\n* fix bug(2781): cannot pause work flow when task state is \"submit success\"\n\n* fix code smell\n\n* add mysql other param blank judge\n\n* test\n\n* update comments\n\n* update comments\n\n* add ut\n\n* fix bug: Restart the worker service again.  the previously submitted successful tasks are not executed\n\n* update comments\n\n* add sleep\n\n* add null point check\n\n* fix bug:After the master is fault-tolerant.  it cannot resume operation\n\n* fix bug: do not failover the host is 'NULL' process\n\n* fix bug:worker failover error.\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* add maven Xmx to 5g\n\n* fix bug: send task result to master until success. (#2839)\n\n* fix bug: send task result to master until success.\n\n* fix bug: send task result to master until success.\n\n* add sleep\n\n* set null if send result failed\n\n* set null if send result failed\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* Fix errors when running on win10 (#2842)\n\n1. DS cant run bat script\n2. DS cant run python script\n3. DS cant run datax script\n\n* Fix abnormal display of regular worker parameters\n\n* add source license full text into source license (#2840)\n\n* add source license full text into source license\n\n* exclude ScriptRunner.java on rat check\n\n* fix table not exist when init db metadata (#2838)\n\n* fix table not exist when init db metadata\n\n* fix db init error\n\n* fix ds-1.3.0 init db\n\n* init db modify process instance json\n\nCo-authored-by: eights <yelli.hl@foxmail.com>\n\n* change notice copyright date from 2019 to 2019-2020 (#2847)\n\n* add source license full text into source license\n\n* exclude ScriptRunner.java on rat check\n\n* change notice copyright date from 2019 to 2019-2020\n\n* fix [BUG] TaskExecutionContextCacheManagerImpl Do not execute removeByTaskInstanceId #2745 (#2754)\n\n* mr resource display and create user username length cannot be less than 3\n\n* fix\n\n* fix\n\n* fix\n\n* fix table T_DS_ALERT (#2854)\n\n* fix worker group config no effect\n\n* remove codehaus janino jar\nthe license about janino maybe not compatiable with Apache v2\n\n* Merge remote-tracking branch 'upstream/dev-1.3.0' into dev-1.3.0\n\n# Conflicts:\n#\tdolphinscheduler-server/src/main/resources/config/install_config.conf\n\n* datasource config\n\n* Update datasource.properties\n\n* fix RunConfig bug\n\n* remove param monitor server state\n\n* fix table T_DS_ALERT\n\n* fix\n\n* fix\n\n* modify t_ds_task_instance app_link change sql (#2861)\n\n* change max length of user name to 39 (#2856)\n\n* fix bug: send task result to master until success.\n\n* fix bug: send task result to master until success.\n\n* add sleep\n\n* set null if send result failed\n\n* set null if send result failed\n\n* change max length of username to 39\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* copy resources need get top directory first (#2866)\n\n* copy resources need get top directory first\n\n* copy resources need get top directory first\n\n* fix #2860:copy files and create empty directory (#2876)\n\n* copy resources need get top directory first\n\n* copy resources need get top directory first\n\n* fix #2860:copy files and create empty directory\n\n* Fix bug:If user didn't set the value of tenant. release process definition fail (#2885)\n\n* copy resources need get top directory first\n\n* copy resources need get top directory first\n\n* fix #2860:copy files and create empty directory\n\n* Fix bug:If user didn't set the value of tenant. release process definition online fail\n\n* merge method updateuser if and fix bug#2892\n\nfix [BUG] When editing user information.  clear the phone number.  the database table t_ds_user.phone is not cleared #2892\n\n* fix bug: sqoop mysql import params error (#2896)\n\n* fix bug: sqoop mysql import params error\n\n* fix bug: sqoop mysql import params error\n\n* Fixed selection of tenant value and defalut changed to lower case\n\n* update how to build and remove docs link (#2906)\n\n* Fix tasks not execute in sub-process when rerun scheduled process. #2903 (#2908)\n\n* fix create table sql exception (#2912)\n\nfix create table sql exception\n\n* fix #2910 master server will show exception for some time when it restart (#2913)\n\n* fix worker group config no effect\n\n* remove codehaus janino jar\nthe license about janino maybe not compatiable with Apache v2\n\n* Merge remote-tracking branch 'upstream/dev-1.3.0' into dev-1.3.0\n\n# Conflicts:\n#\tdolphinscheduler-server/src/main/resources/config/install_config.conf\n\n* datasource config\n\n* Update datasource.properties\n\n* fix RunConfig bug\n\n* remove param monitor server state\n\n* fix table T_DS_ALERT\n\n* update h2 database\n\n* fix #2910 master server will show exception for some time when it restart\n\n* Fixbug datax task (#2909)\n\n* fix:  local param bug\n\n* fix: UT bug\n\nCo-authored-by: Rubik-W <whm_777@163.com>\n\n* [license] add license and notice (#2916)\n\n* fix bug: send task result to master until success.\n\n* fix bug: send task result to master until success.\n\n* add sleep\n\n* set null if send result failed\n\n* set null if send result failed\n\n* change max length of username to 39\n\n* test for gc\n\n* change version to 1.3.0\n\n* check and add some license files\n\n* check and add some license files\n\n* revert\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* fix oom when no master is active in dev-1.3.0 (#2918)\n\n* fix worker group config no effect\n\n* remove codehaus janino jar\nthe license about janino maybe not compatiable with Apache v2\n\n* Merge remote-tracking branch 'upstream/dev-1.3.0' into dev-1.3.0\n\n# Conflicts:\n#\tdolphinscheduler-server/src/main/resources/config/install_config.conf\n\n* datasource config\n\n* Update datasource.properties\n\n* fix RunConfig bug\n\n* remove param monitor server state\n\n* fix table T_DS_ALERT\n\n* update h2 database\n\n* fix #2910 master server will show exception for some time when it restart\n\n* fix oom when no master is active\n\n* fix worker oom when master server restart\n\n* fix oom\n\n* fix\n\n* add UT\n\n* fix worker group config no effect\n\n* Python.  sql.  sqoop. datax task node editor adds zoom function #2929 (#2933)\n\n* Python.  sql.  sqoop task node editor adds zoom function\n\n* fix\n\n* change 1.3.0 to 1.3.0-snapshot\n\n* add janino-3.0.12.jar\n\n* delete duplicate codes\n\n* add commons-compiler-3.0.12.jar\n\n* change delete status according to delete action result\n\n* Delete the pom files animation.scss.  _normalize.scss and _animation.scss under the common folder\n\n* Change email to default (#2981)\n\n* add mybatis-3 notice in the top-level notice (#3003)\n\n* fix download resource file that under the directory error (#3007)\n\n* add mybatis-3 notice in the top-level notice\n\n* fix download resource file that under the directory error\n\n* Fix unfiltered jar files in resource directory and UDF upload resource parameters (#3008)\n\n* Change email to default\n\n* Fix unfiltered jar files in resource directory and UDF upload resource parameters\n\n* fix singe resource manager will NPE (#3013)\n\n* fix worker group config no effect\n\n* remove codehaus janino jar\nthe license about janino maybe not compatiable with Apache v2\n\n* Merge remote-tracking branch 'upstream/dev-1.3.0' into dev-1.3.0\n\n# Conflicts:\n#\tdolphinscheduler-server/src/main/resources/config/install_config.conf\n\n* datasource config\n\n* Update datasource.properties\n\n* fix RunConfig bug\n\n* remove param monitor server state\n\n* fix table T_DS_ALERT\n\n* update h2 database\n\n* fix #2910 master server will show exception for some time when it restart\n\n* fix oom when no master is active\n\n* fix worker oom when master server restart\n\n* fix oom\n\n* fix\n\n* add UT\n\n* fix worker group config no effect\n\n* fix singe resource manager will NPE\n\n* Update HadoopUtilsTest.java\n\n* merge from dev-1.3.0\n\n* update ut\n\n* remove duplicate code\n\n* remove exception ut\n\n* remove exception ut\n\n* remove exception ut\n\n* remove exception ut\n\n* remove exception ut\n\n* [bugfix] remove Conflicting configuration sudo and user (#3038)\n\nCo-authored-by: zhangchunyang1024 <zhangchunyang0123@gamil.com>\n\n* [bugfix] 1. fix alert.json includes repeated tag 'DOLPHIN_ALERT' 2. metainfo.xml The version number of the RPM package is no longer specified in the metainfo.xml (#3032)\n\nCo-authored-by: zhangchunyang1024 <zhangchunyang0123@gamil.com>\n\n* [feature] readme.md adds instructions for changing environment variables (#3031)\n\nCo-authored-by: zhangchunyang1024 <zhangchunyang0123@gamil.com>\n\n* merge from dev\n\n* Change favicon.ico icon introduction method and package compilation to increase version number (#3030)\n\nCo-authored-by: Jiajie Zhong <zhongjiajie955@hotmail.com>\nCo-authored-by: qiaozhanwei <qiaozhanwei@outlook.com>\nCo-authored-by: chenxingchun <438044805@qq.com>\nCo-authored-by: break60 <790061044@qq.com>\nCo-authored-by: lgcareer <18610854716@163.com>\nCo-authored-by: bao liang <29528966+lenboo@users.noreply.github.com>\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\nCo-authored-by: Simon <3656562@qq.com>\nCo-authored-by: xingchun-chen <55787491+xingchun-chen@users.noreply.github.com>\nCo-authored-by: ??? <zhangshiming@cvte.com>\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\nCo-authored-by: liwenhe1993 <liwenhe@apache.org>\nCo-authored-by: xiaochun.liu <xiaochun.liu@centurygame.com>\nCo-authored-by: lidongdai <escheduler@outlook.com>\nCo-authored-by: dailidong <dolphinschedule@gmail.com>\nCo-authored-by: Tboy <guo.jiwei@immomo.com>\nCo-authored-by: xuchangqun <58328021+xuchangqun@users.noreply.github.com>\nCo-authored-by: changqun.xu <changqun.xu@17zuoye.com>\nCo-authored-by: xuchangqun <changqun.x@gmail.com>\nCo-authored-by: zixi0825 <649790970@qq.com>\nCo-authored-by: sunchaohe <sunzhaohe@linklogis.com>\nCo-authored-by: zhangchunyang <zhangchunyang0123@gmail.com>\nCo-authored-by: tlhhup <137273278@qq.com>\nCo-authored-by: yelli.hl@foxmail.com <amarantine@my.com>\nCo-authored-by: eights <yelli.hl@foxmail.com>\nCo-authored-by: yaoyao <42244568+1445103710@users.noreply.github.com>\nCo-authored-by: ?? <62982788+597365581@users.noreply.github.com>\nCo-authored-by: gabry.wu <gabrywu@apache.org>\nCo-authored-by: t1mon <178317391@qq.com>\nCo-authored-by: Rubik-W <39549317+Rubik-W@users.noreply.github.com>\nCo-authored-by: Rubik-W <whm_777@163.com>\nCo-authored-by: zhangchunyang1024 <zhangchunyang0123@gamil.com>","date":"2020-06-30 15:23:35","modifiedFileCount":"76","status":"M","submitter":"dailidong"},{"authorTime":"2020-06-30 16:36:56","codes":[{"authorDate":"2020-06-28 17:43:13","commitOrder":8,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JsonSerializer.deserialize(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if(taskRequestCommand == null){\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n        if(taskExecutionContext == null){\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        taskExecutionContext.setHost(OSUtils.getHost() + \":\" + workerConfig.getListenPort());\n\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n                taskExecutionContext.getProcessDefineId(),\n                taskExecutionContext.getProcessInstanceId(),\n                taskExecutionContext.getTaskInstanceId()));\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.ofNullable(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        \r\n        final Command ackCommand = buildAckCommand(taskExecutionContext).convert2Command();\n\n        try {\n            RetryerUtils.retryCall(() -> {\n                taskCallbackService.sendAck(taskExecutionContext.getTaskInstanceId(),ackCommand);\n                return Boolean.TRUE;\n            });\n            \r\n            workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger));\n        } catch (ExecutionException | RetryException e) {\n            logger.error(e.getMessage(), e);\n        }\n    }\n","date":"2020-06-28 17:43:13","endLine":144,"groupId":"2432","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/4a/2767f138b4b7cb57f191a541741ad564dce144.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JsonSerializer.deserialize(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if(taskRequestCommand == null){\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n        if(taskExecutionContext == null){\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        taskExecutionContext.setHost(OSUtils.getHost() + \":\" + workerConfig.getListenPort());\n\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n                taskExecutionContext.getProcessDefineId(),\n                taskExecutionContext.getProcessInstanceId(),\n                taskExecutionContext.getTaskInstanceId()));\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.ofNullable(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        \r\n        final Command ackCommand = buildAckCommand(taskExecutionContext).convert2Command();\n\n        try {\n            RetryerUtils.retryCall(() -> {\n                taskCallbackService.sendAck(taskExecutionContext.getTaskInstanceId(),ackCommand);\n                return Boolean.TRUE;\n            });\n            \r\n            workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger));\n        } catch (ExecutionException | RetryException e) {\n            logger.error(e.getMessage(), e);\n        }\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskExecuteProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"N"},{"authorDate":"2020-06-30 16:36:56","commitOrder":8,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JsonSerializer.deserialize(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n    }\n","date":"2020-06-30 16:36:56","endLine":96,"groupId":"2209","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/17/ae6a43b191d903c74290ac564ebca26852210f.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JsonSerializer.deserialize(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"M"}],"commitId":"5bac559d22ee940e51477f73b62eb563b021631a","commitMessage":"@@@Revert \"branch dev merge from dev-1.3.0 (#3087)\" (#3094)\n\nThis reverts commit ab6e4310b42ba6772b71334bc5360e470e933d7c.\n\nCo-authored-by: dailidong <dailidong66@gmail.com>","date":"2020-06-30 16:36:56","modifiedFileCount":"76","status":"M","submitter":"bao liang"},{"authorTime":"2020-06-30 16:50:17","codes":[{"authorDate":"2020-06-28 17:43:13","commitOrder":9,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JsonSerializer.deserialize(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if(taskRequestCommand == null){\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n        if(taskExecutionContext == null){\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        taskExecutionContext.setHost(OSUtils.getHost() + \":\" + workerConfig.getListenPort());\n\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n                taskExecutionContext.getProcessDefineId(),\n                taskExecutionContext.getProcessInstanceId(),\n                taskExecutionContext.getTaskInstanceId()));\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.ofNullable(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        \r\n        final Command ackCommand = buildAckCommand(taskExecutionContext).convert2Command();\n\n        try {\n            RetryerUtils.retryCall(() -> {\n                taskCallbackService.sendAck(taskExecutionContext.getTaskInstanceId(),ackCommand);\n                return Boolean.TRUE;\n            });\n            \r\n            workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger));\n        } catch (ExecutionException | RetryException e) {\n            logger.error(e.getMessage(), e);\n        }\n    }\n","date":"2020-06-28 17:43:13","endLine":144,"groupId":"2432","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/4a/2767f138b4b7cb57f191a541741ad564dce144.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JsonSerializer.deserialize(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if(taskRequestCommand == null){\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n        if(taskExecutionContext == null){\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        taskExecutionContext.setHost(OSUtils.getHost() + \":\" + workerConfig.getListenPort());\n\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n                taskExecutionContext.getProcessDefineId(),\n                taskExecutionContext.getProcessInstanceId(),\n                taskExecutionContext.getTaskInstanceId()));\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.ofNullable(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        \r\n        final Command ackCommand = buildAckCommand(taskExecutionContext).convert2Command();\n\n        try {\n            RetryerUtils.retryCall(() -> {\n                taskCallbackService.sendAck(taskExecutionContext.getTaskInstanceId(),ackCommand);\n                return Boolean.TRUE;\n            });\n            \r\n            workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger));\n        } catch (ExecutionException | RetryException e) {\n            logger.error(e.getMessage(), e);\n        }\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskExecuteProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"N"},{"authorDate":"2020-06-30 16:50:17","commitOrder":9,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JsonSerializer.deserialize(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","date":"2020-06-30 16:50:17","endLine":97,"groupId":"2209","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/80/0db211c36a5a2edfe8c3e60dd83b6083b0bcb6.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JsonSerializer.deserialize(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"M"}],"commitId":"2d0fe8a8c68d915de0852da53198ebeb1cc48ae6","commitMessage":"@@@Merge pull request #3095 from apache/dev-merge\n\nbranch dev merge from dev-1.3.0","date":"2020-06-30 16:50:17","modifiedFileCount":"76","status":"M","submitter":"bao liang"},{"authorTime":"2020-06-30 16:50:17","codes":[{"authorDate":"2020-07-02 19:16:37","commitOrder":10,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JsonSerializer.deserialize(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if(taskRequestCommand == null){\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if(taskExecutionContext == null){\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n         taskExecutionContext.setHost(NetUtils.getHost() + \":\" + workerConfig.getListenPort());\n\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n                taskExecutionContext.getProcessDefineId(),\n                taskExecutionContext.getProcessInstanceId(),\n                taskExecutionContext.getTaskInstanceId()));\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.ofNullable(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        \r\n        final Command ackCommand = buildAckCommand(taskExecutionContext).convert2Command();\n\n        try {\n            RetryerUtils.retryCall(() -> {\n                taskCallbackService.sendAck(taskExecutionContext.getTaskInstanceId(),ackCommand);\n                return Boolean.TRUE;\n            });\n            \r\n            workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger));\n        } catch (ExecutionException | RetryException e) {\n            logger.error(e.getMessage(), e);\n        }\n    }\n","date":"2020-07-02 19:16:37","endLine":138,"groupId":"2432","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/78/8a1d7119cbb24d93a77a2ae3fd7a0c870661e8.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JsonSerializer.deserialize(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if(taskRequestCommand == null){\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n        if(taskExecutionContext == null){\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        taskExecutionContext.setHost(OSUtils.getHost() + \":\" + workerConfig.getListenPort());\n\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n                taskExecutionContext.getProcessDefineId(),\n                taskExecutionContext.getProcessInstanceId(),\n                taskExecutionContext.getTaskInstanceId()));\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.ofNullable(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        \r\n        final Command ackCommand = buildAckCommand(taskExecutionContext).convert2Command();\n\n        try {\n            RetryerUtils.retryCall(() -> {\n                taskCallbackService.sendAck(taskExecutionContext.getTaskInstanceId(),ackCommand);\n                return Boolean.TRUE;\n            });\n            \r\n            workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger));\n        } catch (ExecutionException | RetryException e) {\n            logger.error(e.getMessage(), e);\n        }\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskExecuteProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":78,"status":"M"},{"authorDate":"2020-06-30 16:50:17","commitOrder":10,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JsonSerializer.deserialize(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","date":"2020-06-30 16:50:17","endLine":97,"groupId":"2209","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/80/0db211c36a5a2edfe8c3e60dd83b6083b0bcb6.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JsonSerializer.deserialize(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"N"}],"commitId":"d1282fdd96147ca345f2a60d4e5c3554820f6fc9","commitMessage":"@@@In the case of multiple network cards.  a valid host is returned (#2924)\n\n* In the case of multiple network cards.  a valid host is returned\n\n* In the case of multiple network cards.  a valid host is returned\n\n* In the case of multiple network cards.  a valid host is returned\n\n* In the case of multiple network cards.  a valid host is returned\n\n* fix LOCAL_ADDRESS not assigned  value\n\n* fix LOCAL_ADDRESS not assigned  value\n\n* fix LOCAL_ADDRESS not assigned  value\n\n* fix lock error\n\n* fix lock error\n\n* end\n\n* end\n\n* end\n\n* end\n\n* code smell\n\n* code smell\n\n* code smell\n\n* code smell\n\n* code smell\n\n* code smell\n\n* code smell\n\n* lowering\n\n* messy\n\n* small change\n\n* compile error\n\nCo-authored-by: dailidong <dailidong66@gmail.com>\nCo-authored-by: gabry.wu <gabrywu@apache.org>","date":"2020-07-02 19:16:37","modifiedFileCount":"15","status":"M","submitter":"CalvinKirs"},{"authorTime":"2020-06-30 16:50:17","codes":[{"authorDate":"2020-08-19 11:36:30","commitOrder":11,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JsonSerializer.deserialize(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if(taskRequestCommand == null){\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if(taskExecutionContext == null){\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        taskExecutionContext.setHost(NetUtils.getHost() + \":\" + workerConfig.getListenPort());\n\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n                taskExecutionContext.getProcessDefineId(),\n                taskExecutionContext.getProcessInstanceId(),\n                taskExecutionContext.getTaskInstanceId()));\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.ofNullable(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        if (DateUtils.getRemainTime(taskExecutionContext.getFirstSubmitTime(), taskExecutionContext.getDelayTime() * 60L) > 0) {\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.DELAY_EXECUTION);\n            taskExecutionContext.setStartTime(null);\n        } else {\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n            taskExecutionContext.setStartTime(new Date());\n        }\n\n        \r\n        final Command ackCommand = buildAckCommand(taskExecutionContext).convert2Command();\n\n        try {\n            RetryerUtils.retryCall(() -> {\n                taskCallbackService.sendAck(taskExecutionContext.getTaskInstanceId(),ackCommand);\n                return Boolean.TRUE;\n            });\n            \r\n            workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger));\n        } catch (ExecutionException | RetryException e) {\n            logger.error(e.getMessage(), e);\n        }\n    }\n","date":"2020-08-19 11:36:30","endLine":155,"groupId":"2432","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/2d/c9bb2ce9f7d96aab37d5ed473632e251d60b93.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JsonSerializer.deserialize(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if(taskRequestCommand == null){\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if(taskExecutionContext == null){\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n         taskExecutionContext.setHost(NetUtils.getHost() + \":\" + workerConfig.getListenPort());\n\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n                taskExecutionContext.getProcessDefineId(),\n                taskExecutionContext.getProcessInstanceId(),\n                taskExecutionContext.getTaskInstanceId()));\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.ofNullable(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        \r\n        final Command ackCommand = buildAckCommand(taskExecutionContext).convert2Command();\n\n        try {\n            RetryerUtils.retryCall(() -> {\n                taskCallbackService.sendAck(taskExecutionContext.getTaskInstanceId(),ackCommand);\n                return Boolean.TRUE;\n            });\n            \r\n            workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger));\n        } catch (ExecutionException | RetryException e) {\n            logger.error(e.getMessage(), e);\n        }\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskExecuteProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":87,"status":"M"},{"authorDate":"2020-06-30 16:50:17","commitOrder":11,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JsonSerializer.deserialize(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","date":"2020-06-30 16:50:17","endLine":97,"groupId":"2209","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/80/0db211c36a5a2edfe8c3e60dd83b6083b0bcb6.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JsonSerializer.deserialize(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"N"}],"commitId":"a4ee351a3af1b05bafab48699f846e2b3ac226eb","commitMessage":"@@@delay execution of tasks and improve some designs (#3427)\n\n","date":"2020-08-19 11:36:30","modifiedFileCount":"25","status":"M","submitter":"vanilla111"},{"authorTime":"2020-11-07 19:37:48","codes":[{"authorDate":"2020-11-07 19:37:48","commitOrder":12,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        taskExecutionContext.setHost(NetUtils.getHost() + \":\" + workerConfig.getListenPort());\n\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n                taskExecutionContext.getProcessDefineId(),\n                taskExecutionContext.getProcessInstanceId(),\n                taskExecutionContext.getTaskInstanceId()));\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.ofNullable(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        if (DateUtils.getRemainTime(taskExecutionContext.getFirstSubmitTime(), taskExecutionContext.getDelayTime() * 60L) > 0) {\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.DELAY_EXECUTION);\n            taskExecutionContext.setStartTime(null);\n        } else {\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n            taskExecutionContext.setStartTime(new Date());\n        }\n\n        \r\n        final Command ackCommand = buildAckCommand(taskExecutionContext).convert2Command();\n\n        try {\n            RetryerUtils.retryCall(() -> {\n                taskCallbackService.sendAck(taskExecutionContext.getTaskInstanceId(),ackCommand);\n                return Boolean.TRUE;\n            });\n            \r\n            workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger));\n        } catch (ExecutionException | RetryException e) {\n            logger.error(e.getMessage(), e);\n        }\n    }\n","date":"2020-11-07 19:37:48","endLine":150,"groupId":"2432","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/13/a9dca9d6c24df9844667fe77e45d8377c094fc.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JsonSerializer.deserialize(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if(taskRequestCommand == null){\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if(taskExecutionContext == null){\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        taskExecutionContext.setHost(NetUtils.getHost() + \":\" + workerConfig.getListenPort());\n\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n                taskExecutionContext.getProcessDefineId(),\n                taskExecutionContext.getProcessInstanceId(),\n                taskExecutionContext.getTaskInstanceId()));\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.ofNullable(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        if (DateUtils.getRemainTime(taskExecutionContext.getFirstSubmitTime(), taskExecutionContext.getDelayTime() * 60L) > 0) {\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.DELAY_EXECUTION);\n            taskExecutionContext.setStartTime(null);\n        } else {\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n            taskExecutionContext.setStartTime(new Date());\n        }\n\n        \r\n        final Command ackCommand = buildAckCommand(taskExecutionContext).convert2Command();\n\n        try {\n            RetryerUtils.retryCall(() -> {\n                taskCallbackService.sendAck(taskExecutionContext.getTaskInstanceId(),ackCommand);\n                return Boolean.TRUE;\n            });\n            \r\n            workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger));\n        } catch (ExecutionException | RetryException e) {\n            logger.error(e.getMessage(), e);\n        }\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskExecuteProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":82,"status":"M"},{"authorDate":"2020-11-07 19:37:48","commitOrder":12,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","date":"2020-11-07 19:37:48","endLine":98,"groupId":"2209","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/21/108d1291f06cc9f363fe9ff727e794f916022b.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JsonSerializer.deserialize(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"M"}],"commitId":"4b502e361fa0d41d142b1f2c0845d64d1dcc1abd","commitMessage":"@@@[Improvement-4012][common/remote] Json util code integration. remove the remote module json util (#4013)\n\n* Json util code integration. remove the remote module json util.\n\n* update code checkstyle.\n\n* update code checkstyle.\n\n* add code checkstyle.\n\n* add test class.\n\n* update JSONUtils class.\n\n* update JSONUtils class.","date":"2020-11-07 19:37:48","modifiedFileCount":"23","status":"M","submitter":"zhuangchong"},{"authorTime":"2020-11-07 19:37:48","codes":[{"authorDate":"2020-11-12 11:27:05","commitOrder":13,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n                taskExecutionContext.getProcessDefineId(),\n                taskExecutionContext.getProcessInstanceId(),\n                taskExecutionContext.getTaskInstanceId()));\n\n        taskExecutionContext.setHost(NetUtils.getHost() + \":\" + workerConfig.getListenPort());\n        taskExecutionContext.setStartTime(new Date());\n        taskExecutionContext.setLogPath(LogUtils.getTaskLogPath(taskExecutionContext));\n        taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.ofNullable(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        this.doAck(taskExecutionContext);\n\n        \r\n        workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger));\n    }\n","date":"2020-11-12 11:27:05","endLine":135,"groupId":"2209","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/60/80baf3cbeaf76e1ae42b681c1d9cfbb2158919.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        taskExecutionContext.setHost(NetUtils.getHost() + \":\" + workerConfig.getListenPort());\n\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n                taskExecutionContext.getProcessDefineId(),\n                taskExecutionContext.getProcessInstanceId(),\n                taskExecutionContext.getTaskInstanceId()));\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.ofNullable(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        if (DateUtils.getRemainTime(taskExecutionContext.getFirstSubmitTime(), taskExecutionContext.getDelayTime() * 60L) > 0) {\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.DELAY_EXECUTION);\n            taskExecutionContext.setStartTime(null);\n        } else {\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n            taskExecutionContext.setStartTime(new Date());\n        }\n\n        \r\n        final Command ackCommand = buildAckCommand(taskExecutionContext).convert2Command();\n\n        try {\n            RetryerUtils.retryCall(() -> {\n                taskCallbackService.sendAck(taskExecutionContext.getTaskInstanceId(),ackCommand);\n                return Boolean.TRUE;\n            });\n            \r\n            workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger));\n        } catch (ExecutionException | RetryException e) {\n            logger.error(e.getMessage(), e);\n        }\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskExecuteProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":82,"status":"M"},{"authorDate":"2020-11-07 19:37:48","commitOrder":13,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","date":"2020-11-07 19:37:48","endLine":98,"groupId":"2209","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/21/108d1291f06cc9f363fe9ff727e794f916022b.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"N"}],"commitId":"ad2d9f99d01f3baef8641e0a7e741c08a39f1f24","commitMessage":"@@@[Draft][Merge][133-dev]133 merge dev (#4031)\n\n* [Feture-3327][ui]Add the function of re-uploading files in the resource center\n\n* [Feture-3327][ui]Add the function of re-uploading files in the resource center (#3394)\n\n* Before creating a workflow.  clear the canvas\n\n* [Fix-3256][ui] herry pick commit from dev for Fix admin user info update error (#3306)\n\n* [Feture-3327][ui]Add the function of re-uploading files in the resource center\n\nCo-authored-by: wuchunfu <319355703@qq.com>\n\n* [Improvement-3327][api]support re-upload the resource file (#3395)\n\n* [Fix-3390][server]Running hive sql task need find the hdfs path correctly (#3396)\n\n* [Fix-3390][api]Running hive sql task need find the hdfs path correctly\n\n* [Fix-3390][api]Running hive sql task need find the hdfs path correctly\n\n* update soft version\n\n* hive UDF function to modify the background color\n\n* fix\n\n* fix bug: Fix master task dependency check bug\n\n* cancel spark task version check (#3406)\n\nCo-authored-by: Eights-Li <yelli.hl@gmail.com>\n\n* [Bug][ui]Fix front-end bug #3413\n\n* [Feature][ambari_plugin]support one worker can belongs different worker groups when execute install script (#3410)\n\n* Optimize dag\n\n* Update actions.js (#3401)\n\n* [Fix-3256][ui] Fix admin user info update error (#3425) (#3428)\n\n* [PROPOSAL-3139] Datasource selection changes from radio to select\n\n* [PROPOSAL-3139] Datasource selection changes from radio to select\n\n* [BUG FIX] issues #3256\n\n* [BUG FIX] issues #3256\n\n* [BUG FIX] issues #3256\n\n* [Fix-3256][ui] Fix admin user info update error\n\n* [Fix-3256][ui] Fix admin user info update error\n\n* [Fix-3256][ui] Fix admin user info update error\n\n* [Fix-3256][ui] Fix admin user info update error\n\n* reset createUser.vue\n\n* [Fix-3256][ui] Fix admin user info update error\n\nCo-authored-by: dailidong <dailidong66@gmail.com>\n\nCo-authored-by: wuchunfu <319355703@qq.com>\nCo-authored-by: dailidong <dailidong66@gmail.com>\n\n* [Fix-3433][api]Fixed that release the imported process definition which version is below 1.3.0 will be failure\n\n* dag connection add check\n\n* fix\n\n* [Fix-3423][dao][sql]Fixed that the resource file of the task node can't be found when upgrade from 1.2.0 to 1.3.x (#3454)\n\n* Remove node deep monitoring\n\n* If worker group id is null. don't need to set the value of the worker group (#3460)\n\n* [Fix-3423][dao][sql]Fixed that the resource file of the task node can't be found when upgrade from 1.2.0 to 1.3.x\n\n* [Fix-3423][dao]If worker group id is null. don't need to set the value of the worker group\n\n* [ui]Code optimization\n\n* fix\n\n* fix\n\n* [fix-3058][ui]Move rtTargetArr to jsPlumbHandle.js\n\n* [optimization][ui]Prevent the shell script input box from being empty\n\n* [Fix-3462][api]If login user is admin. need list all udfs (#3465)\n\n* [Fix-3462][api]If login user is admin. need list all udfs\n\n* [Fix-3462][api]add the test on the method of QueryUdfFuncList\n\n* [Fix-3462][api]fix the code smell\n\n* [Fix-3462][api]fix the code smell\n\n* [Fix-3462][api]fix the code smell\n\n* [Fix-3463][api]Fixed that run the sql task will be failure after rename the udf resource (#3482)\n\n* [fixBug-3058][ui]Fix connection abnormalities in historical workflow instance data\n\n* [Feture-3327][ui]Add the function of re-uploading files in the udf subdirectory\n\n* fix bug: Fix master task dependency check bug (#3473)\n\nCo-authored-by: lenboo <baoliang@analysys.com.cn>\n\n* [maven-release-plugin] prepare release 1.3.2\n\n* [maven-release-plugin] prepare for next development iteration\n\n* fix ci_e2e fail (#3497)\n\n* [Fix-3469][api]Should filter the resource by the different program type (#3498)\n\n* [Fix-3463][api]Fixed that run the sql task will be failure after rename the udf resource\n\n* [Fix-3469][api]Should list python file and jar file\n\n* [Fix-3469][api]Should filter the resource by the different program type\n\n* [Fix-3469][api]fix the code smell\n\n* test release 1.3.2 version rollback\n\n* test release 1.3.2 version rollback\n\n* test release 1.3.2 version rollback (#3499)\n\n* [Feature] JVM parameter optimization .  related issue #3370\n\n* [Feature] JVM parameter optimization .  related issue #3370\n\n* test release 1.3.2 version rollback\n\n* test release 1.3.2 version rollback\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\n\n* [maven-release-plugin] prepare release 1.3.2\n\n* [maven-release-plugin] prepare for next development iteration\n\n* [Fix-3469][ui]The value of maintenance resources and the filtering of resources according to different program types\n\n* fix\n\n* Revert \"fix ci_e2e fail (#3497)\"\n\nThis reverts commit e367f90bb73c9682739308a0a98887a1c0f407ef.\n\n* test\n\n* test release 1.3.2 version rollback\n\n* test release 1.3.2 version rollback (#3503)\n\n* [Feature] JVM parameter optimization .  related issue #3370\n\n* [Feature] JVM parameter optimization .  related issue #3370\n\n* test release 1.3.2 version rollback\n\n* test release 1.3.2 version rollback\n\n* test\n\n* test release 1.3.2 version rollback\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\n\n* [maven-release-plugin] prepare release 1.3.2\n\n* [maven-release-plugin] prepare for next development iteration\n\n* test release 1.3.2 version rollback (#3504)\n\n* [Feature] JVM parameter optimization .  related issue #3370\n\n* [Feature] JVM parameter optimization .  related issue #3370\n\n* test release 1.3.2 version rollback\n\n* test release 1.3.2 version rollback\n\n* test\n\n* test release 1.3.2 version rollback\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\n\n* [maven-release-plugin] prepare release 1.3.2\n\n* [maven-release-plugin] prepare for next development iteration\n\n* fix ds muti-level directory in zk.  which lead to fail to assign work\n\n* add login user check some actions in api\n\n* [Hotfix][ci] Fix e2e ci docker image build error\n\n* modify tag 1.3.0 to HEAD\n\n* modify tag 1.3.0 to HEAD (#3525)\n\n* [Feature] JVM parameter optimization .  related issue #3370\n\n* [Feature] JVM parameter optimization .  related issue #3370\n\n* test release 1.3.2 version rollback\n\n* test release 1.3.2 version rollback\n\n* test\n\n* test release 1.3.2 version rollback\n\n* modify tag 1.3.0 to HEAD\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\n\n* remove OGNL part of the mybaits notice (#3526)\n\n* [maven-release-plugin] prepare release 1.3.2\n\n* [maven-release-plugin] prepare for next development iteration\n\n* release 1.3.2 version rollback (#3527)\n\n* [Feature] JVM parameter optimization .  related issue #3370\n\n* [Feature] JVM parameter optimization .  related issue #3370\n\n* test release 1.3.2 version rollback\n\n* test release 1.3.2 version rollback\n\n* test\n\n* test release 1.3.2 version rollback\n\n* modify tag 1.3.0 to HEAD\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\n\n* [ui]Script input box to modify the delay loading time\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* modify general user can't create token\n\n* [ui]It is forbidden to select non-existent resources and modify the tree display data format\n\n* modify general user can't create token (#3533)\n\n* [Feature] JVM parameter optimization .  related issue #3370\n\n* [Feature] JVM parameter optimization .  related issue #3370\n\n* test release 1.3.2 version rollback\n\n* test release 1.3.2 version rollback\n\n* test\n\n* test release 1.3.2 version rollback\n\n* modify tag 1.3.0 to HEAD\n\n* modify general user can't create token\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\n\n* if task is null .  set task type is null instead of \"null\"\n\n* [Fix-3536][api]If user didn't have tenant. create resource directory will NPE (#3537)\n\n* [Fix-3536][api]If user didn't have tenant. create resource will NPE\n\n* [Fix-3536][api]If user didn't have tenant. create resource directory will NPE\n\n* modify general user can't create. delete. update token (#3538)\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\n\n* [ui]Resource delete OK button to increase loading.  change the number of homepage display cursor\n\n* fix\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry (#3748)\n\n* [fixbug][ui]Repair the master and worker management instrument display\n\n* [Fix-3238][docker]Fix that can not create folder in docker with standalone mode (#3741)\n\n* [fixbug][ui]Remove non-existent or deleted resources disabled\n\n* [fixBug-3621][ui]If the workflow instance status is executing status.  it is forbidden to select\n\n* [fix-3553][ui]Repair click workflow connection.  select the entire path\n\n* fix\n\n* fix\n\n* [Fix-3238][docker]Fix that can not create folder in docker with standalone mode\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry (#3776)\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\n\n* The batch delete function in the workflow definition and workflow instance pages cannot be canceled if selected.\n\n* [Improvement-3720][ui] js mailbox verification fix\n\n* [Fix-3549] [Server][sqlTask]The alias column in the query SQL does not take effect (#3784)\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* The batch delete function in the workflow definition and workflow instance pages cannot be canceled if selected.\n\n* [Fix-3549] [Server][sqlTask]The alias column in the query SQL does not take effect\n\n* [Fix-3549] [Server][sqlTask]The alias column in the query SQL does not take effect\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\nCo-authored-by: zhuangchong <zhuangchong8@163.com>\nCo-authored-by: JinyLeeChina <42576980+JinyLeeChina@users.noreply.github.com>\n\n* [Fix-3124][docker]Fix that can not build a docker image on windows (#3765)\n\n* [Fix-3549] [Server][sqlTask]The alias column in the query SQL does not take effect (#3786)\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* The batch delete function in the workflow definition and workflow instance pages cannot be canceled if selected.\n\n* [Fix-3549] [Server][sqlTask]The alias column in the query SQL does not take effect\n\n* [Fix-3549] [Server][sqlTask]The alias column in the query SQL does not take effect\n\n* [Fix-3549] [Server][sqlTask]The alias column in the query SQL does not take effect\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\nCo-authored-by: zhuangchong <zhuangchong8@163.com>\nCo-authored-by: JinyLeeChina <42576980+JinyLeeChina@users.noreply.github.com>\n\n* [Fix-3258][Security][Worker group manage] Connot get create time and update time. report DateTimeParseException (#3787)\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* The batch delete function in the workflow definition and workflow instance pages cannot be canceled if selected.\n\n* [Fix-3549] [Server][sqlTask]The alias column in the query SQL does not take effect\n\n* [Fix-3549] [Server][sqlTask]The alias column in the query SQL does not take effect\n\n* [Fix-3549] [Server][sqlTask]The alias column in the query SQL does not take effect\n\n* [BugFixed] issue #3258 (#3265)\n\n* 'ExecutionStatus'\n\n* '3258'\n\n* Update WorkerGroupServiceTest.java\n\n* Delete UserState.java\n\n* Delete ResourceSyncService.java\n\n* Delete core-site.xml\n\n* Delete hdfs-site.xml\n\nCo-authored-by: dailidong <dailidong66@gmail.com>\nCo-authored-by: qiaozhanwei <qiaozhanwei@outlook.com>\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\nCo-authored-by: zhuangchong <zhuangchong8@163.com>\nCo-authored-by: JinyLeeChina <42576980+JinyLeeChina@users.noreply.github.com>\nCo-authored-by: dailidong <dailidong66@gmail.com>\n\n* [fixBug-3792][ui]Click on the sidebar to adapt the width of the pie chart on the project homepage\n\n* [Bug-3713][HadoopUtils] catfile method Stream not closed  (#3715)\n\n* fix bug\n\nDelete invalid field: executorcores\n\nModify verification prompt\n\n* fix bug\n\nDelete invalid field: executorcores\n\nModify verification prompt\n\n* fix bug\n\nDelete invalid field: executorcores\n\nModify verification prompt\n\n* dag  add close button\n\n* reset last version\n\n* reset last version\n\n* dag add close buttion\n\ndag add close buttion\n\n* update  CLICK_SAVE_WORKFLOW_BUTTON  xpath\n\n* updae CLICK_SAVE_WORKFLOW_BUTTON xpath\n\n* updae CLICK_SAVE_WORKFLOW_BUTTON xpath\n\n* updae CLICK_SAVE_WORKFLOW_BUTTON xpath\n\n* Update CreateWorkflowLocator.java\n\nmodify submit workflow button\n\n* Update CreateWorkflowLocator.java\n\n* Update CreateWorkflowLocator.java\n\nmodify CLICK_ADD_BUTTON\n\n* Update CreateWorkflowLocator.java\n\ndelete print\n\n* Update CreateWorkflowLocator.java\n\n1\n\n* Update CreateWorkflowLocator.java\n\n1\n\n* Setting '-XX:+DisableExplicitGC ' causes netty memory leaks\n\nin addition\n\nupdate '- XX: largepagesizeinbytes = 128M' to '- XX: largepagesizeinbytes = 10M'\n\n* Update dag.vue\n\n* Update dag.vue\n\n* Update dag.vue\n\n* Update CreateWorkflowLocator.java\n\n* Revert \"Setting '-XX:+DisableExplicitGC ' causes netty memory leaks\"\n\nThis reverts commit 3a2cba7a\n\n* Setting '-XX:+DisableExplicitGC ' causes netty memory leaks\n\nin addition\n\nupdate '- XX: largepagesizeinbytes = 128M' to '- XX: largepagesizeinbytes = 10M'\n\n* Update dolphinscheduler-daemon.sh\n\n* catfile method Stream not closed\n\n* catfile method Stream not closed\n\nCo-authored-by: dailidong <dailidong66@gmail.com>\nCo-authored-by: xingchun-chen <55787491+xingchun-chen@users.noreply.github.com>\n\n* [Fix-#3713][common]Fix that catfile method Stream not closed\n\n* [Fix-#3713][common]Fix that catfile method Stream not closed (#3810)\n\n* [Bug-3713][HadoopUtils] catfile method Stream not closed  (#3715)\n\n* fix bug\n\nDelete invalid field: executorcores\n\nModify verification prompt\n\n* fix bug\n\nDelete invalid field: executorcores\n\nModify verification prompt\n\n* fix bug\n\nDelete invalid field: executorcores\n\nModify verification prompt\n\n* dag  add close button\n\n* reset last version\n\n* reset last version\n\n* dag add close buttion\n\ndag add close buttion\n\n* update  CLICK_SAVE_WORKFLOW_BUTTON  xpath\n\n* updae CLICK_SAVE_WORKFLOW_BUTTON xpath\n\n* updae CLICK_SAVE_WORKFLOW_BUTTON xpath\n\n* updae CLICK_SAVE_WORKFLOW_BUTTON xpath\n\n* Update CreateWorkflowLocator.java\n\nmodify submit workflow button\n\n* Update CreateWorkflowLocator.java\n\n* Update CreateWorkflowLocator.java\n\nmodify CLICK_ADD_BUTTON\n\n* Update CreateWorkflowLocator.java\n\ndelete print\n\n* Update CreateWorkflowLocator.java\n\n1\n\n* Update CreateWorkflowLocator.java\n\n1\n\n* Setting '-XX:+DisableExplicitGC ' causes netty memory leaks\n\nin addition\n\nupdate '- XX: largepagesizeinbytes = 128M' to '- XX: largepagesizeinbytes = 10M'\n\n* Update dag.vue\n\n* Update dag.vue\n\n* Update dag.vue\n\n* Update CreateWorkflowLocator.java\n\n* Revert \"Setting '-XX:+DisableExplicitGC ' causes netty memory leaks\"\n\nThis reverts commit 3a2cba7a\n\n* Setting '-XX:+DisableExplicitGC ' causes netty memory leaks\n\nin addition\n\nupdate '- XX: largepagesizeinbytes = 128M' to '- XX: largepagesizeinbytes = 10M'\n\n* Update dolphinscheduler-daemon.sh\n\n* catfile method Stream not closed\n\n* catfile method Stream not closed\n\nCo-authored-by: dailidong <dailidong66@gmail.com>\nCo-authored-by: xingchun-chen <55787491+xingchun-chen@users.noreply.github.com>\n\n* [Fix-#3713][common]Fix that catfile method Stream not closed\n\nCo-authored-by: BoYiZhang <39816903+BoYiZhang@users.noreply.github.com>\nCo-authored-by: dailidong <dailidong66@gmail.com>\nCo-authored-by: xingchun-chen <55787491+xingchun-chen@users.noreply.github.com>\n\n* [Fix-#3487][api?dao] cherry pick from dev to fix that create folder duplicate name under multithreading\n\n* [Hotfix-3131][api] Fix the new tenant already exists prompt (#3132)\n\n* Bugfix: Fix the new tenant already exists prompt\n\n* Feature: Add test cases\n\n* Update TenantServiceTest.java\n\nCo-authored-by: dailidong <dailidong66@gmail.com>\nCo-authored-by: qiaozhanwei <qiaozhanwei@outlook.com>\n\n* Set up JDK 11 for SonarCloud in github action. (#3052)\n\n* Set up JDK 11 for SonarCloud in github action.\n\n* Fix javadoc error with JDK 11.\n\n* Prevent Javadoc from stopping if it finds any html errors.\n\n* [fixBug-3621][ui]Select the batch checkbox to unfilter the instances in the executing state\n\n* add verify tenant name cannot contain special characters.\n\n* [fixBug-3840][ui]The tenant code only allows letters or a combination of letters and numbers\n\n* fix\n\n* fix\n\n* fix\n\n* [Fix-#3702][api] When re-upload the resource file but don't change the name or desc. it need replace the origin resource file. (#3862)\n\n* [Fix-#3702][api] When re-upload the resource file but don't change the name or desc. it will not replace the origin resource file.\n\n* [Fix-#3702][api] When re-upload the resource file but don't change the name or desc. it will not replace the origin resource file.\n\n* [fixbug-3621][ui]Workflow instance ready to stop and ready to suspend state prohibits checking\n\n* [fixbug-3887][ui]Fix missing English translation of re-upload files\n\n* add process define name verify. (#3879)\n\n* Revert \"[1.3.3-release][fix-3835][ui] When the tenantName contains \"<\".  the tenant drop-down list is blankadd verify tenant name cannot contain special characters.\"\n\n* revert pr 3872\n\n* [FIX-3617][Service]after subtask fault tolerance.  2 task instances are generated (#3830)\n\n* fix bug(#3617): after subtask fault tolerance.  2 task instances are generated.\n\n* delete unused code\n\n* update code smell\n\n* refactor sub work command process\n\n* add process service ut\n\n* add license header\n\n* fix some code smell\n\n* chang ut java8 to java11\n\n* update sonar to java11\n\n* copy ut config from dev\n\n* remove checkstyle\n\n* revert to 1.3.3\n\n* change proess service test to executor service\n\n* add process service test\n\n* add process service test\n\n* revert\n\n* revert\n\n* add comments\n\n* change dev to 1.3.3-release\n\n* revert\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* [Fix-#3487][sql] add dolphinscheduler_dml.sql under 1.3.3_schema (#3907)\n\n* [FIX-3836][1.3.3-release-API] process definition validation name interface prompt information error  (#3899)\n\n* fix bug : error message\n\n* fix code smell\n\n* fix code smell\n\n* [FIX_#3789][remote]cherry pick from dev to support netty heart beat\n\n* [FIX_#3789][remote]cherry pick from dev to support netty heart beat\n\n* [FIX_#3789][remote]cherry pick from dev to support netty heart beat (#3913)\n\n* [FIX_#3789][remote]cherry pick from dev to support netty heart beat\n\n* [FIX_#3789][remote]cherry pick from dev to support netty heart beat\n\nCo-authored-by: Kirs <acm_master@163.com>\n\n* Repair check box cannot be canceled\n\n* [fix-3843][api] When update workflow definition. if name already exists.  the prompt is not friendly\n\n* [fix-3843][api] When update workflow definition. if name already exists.  the prompt is not friendly\n\n* [fix-#3843][api]When update workflow definition. if name already exists.  the prompt is not friendly (#3918)\n\n* [FIX_#3789][remote]cherry pick from dev to support netty heart beat\n\n* [FIX_#3789][remote]cherry pick from dev to support netty heart beat\n\n* [fix-3843][api] When update workflow definition. if name already exists.  the prompt is not friendly\n\n* [fix-3843][api] When update workflow definition. if name already exists.  the prompt is not friendly\n\nCo-authored-by: Kirs <acm_master@163.com>\n\n* [Fix-#3487][sql] update uc_dolphin_T_t_ds_resources_un\n\n* Workflow definition name re-modified and added check\n\n* [fix-#3843][api]When update workflow definition. if name already exists.  the prompt is not friendly.\n\n* update code.\n\n* [#3931][ui]Field name optimization for spark.  flink.  and mr\n\n* change version from 1.3.2-SNAPSHOT to 1.3.3-SNAPSHOT (#3934)\n\n* [maven-release-plugin] prepare release 1.3.3\n\n* [maven-release-plugin] prepare for next development iteration\n\n* [ambari-plugin]change version 1.3.2 to 1.3.3 (#3935)\n\n* fix bug:3615 After the task is executed successfully.  but the next task has not been submitted.  stop the master\n\n* [fixBug-3964][ui]Switch back and forth over timeout alarm.  the selected value is empty\n\n* solve too many files.  close logClientService (#3971)\n\n* fix #3966 sub process doesnot send alert mail after process instance ending. (#3972)\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* [Fix-#3618][server] resolve task executed finished but not release the file handle (#3975)\n\n* [Fix-#3618][server] resolve task executed finished but not release the file handle\n\n* [Fix-#3618][server] resolve task executed finished but not release the file handle\n\n* [Fix-#3958][api] files should not be created successfully in the directory of the authorized file\n\n* [FIX-3966] The timeout warning does not take effect in sub_process (#3982)\n\n* fix #3966 sub process doesnot send alert mail after process instance ending.\n\n* fix bug 3964: sub_process The timeout warning does not take effect\nadd timeout warning for sub_process/dependent task.\n\n* fix code smell\n\n* fix code smell\n\n* fix code smell\n\n* update worker group inherit from parent\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* fix import dolphinscheduler_mysql.sql insert admin user data\n\n* [FIX-3929] condition task would post wrong tasks when failover. (#3999)\n\n* fix #3966 sub process doesnot send alert mail after process instance ending.\n\n* fix bug 3964: sub_process The timeout warning does not take effect\nadd timeout warning for sub_process/dependent task.\n\n* fix code smell\n\n* fix code smell\n\n* fix code smell\n\n* update worker group inherit from parent\n\n* remove stdout in logback configuration\n\n* fix bug #3929 condition task would post error when failover.\n\n* remove unused test\n\n* add comments\n\n* add skip node judge\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* [FIX-3929]  because of no lock.  start up failover would dispatch two same tasks. (#4004)\n\n* fix #3966 sub process doesnot send alert mail after process instance ending.\n\n* fix bug 3964: sub_process The timeout warning does not take effect\nadd timeout warning for sub_process/dependent task.\n\n* fix code smell\n\n* fix code smell\n\n* fix code smell\n\n* update worker group inherit from parent\n\n* remove stdout in logback configuration\n\n* fix bug #3929 condition task would post error when failover.\n\n* remove unused test\n\n* add comments\n\n* add skip node judge\n\n* fix bug 3929: because of no lock.  start up failover would dispatch two same tasks.\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* revert pom version to 1.3.3-release\n\n* [maven-release-plugin] prepare release 1.3.3\n\n* [maven-release-plugin] prepare for next development iteration\n\n* [release]revert pom version to 1.3.3-release\n\n* fix bug 4010: remove failed condition tasks from error-task-list. (#4011)\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* [maven-release-plugin] prepare release 1.3.3\n\n* [maven-release-plugin] prepare for next development iteration\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* refactor code style\n\n* refactor code style\n\n* refactor code style\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* refactor ut test\n\n* refactor ut test\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* refactor ut\n\n* merge from 1.3.3-release\n\n* refactor ut\n\n* refactor ut\n\n* refactor\n\n* refactor\n\n* refactor code style\n\n* refactor code style\n\n* refactor code style\n\n* refactor code style\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* refactor code style\n\nCo-authored-by: break60 <790061044@qq.com>\nCo-authored-by: wuchunfu <319355703@qq.com>\nCo-authored-by: lgcareer <18610854716@163.com>\nCo-authored-by: xingchun-chen <55787491+xingchun-chen@users.noreply.github.com>\nCo-authored-by: lenboo <baoliang@analysys.com.cn>\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\nCo-authored-by: Yelli <amarantine@my.com>\nCo-authored-by: Eights-Li <yelli.hl@gmail.com>\nCo-authored-by: JinyLeeChina <42576980+JinyLeeChina@users.noreply.github.com>\nCo-authored-by: dailidong <dailidong66@gmail.com>\nCo-authored-by: qiaozhanwei <qiaozhanwei@outlook.com>\nCo-authored-by: XiaotaoYi <v-xiayi@hotmail.com>\nCo-authored-by: Yichao Yang <1048262223@qq.com>\nCo-authored-by: zhuangchong <zhuangchong8@163.com>\nCo-authored-by: BoYiZhang <39816903+BoYiZhang@users.noreply.github.com>\nCo-authored-by: muzhongjiang <mu_zhongjiang@163.com>\nCo-authored-by: Jave-Chen <baicai.chen@gmail.com>\nCo-authored-by: zhuangchong <zhuangchong6@163.com>\nCo-authored-by: zhuangchong <37063904+zhuangchong@users.noreply.github.com>\nCo-authored-by: Kirs <acm_master@163.com>\nCo-authored-by: lgcareer <lgcareer@apache.org>\nCo-authored-by: wulingqi <wulingqi@baijiahulian.com>","date":"2020-11-12 11:27:05","modifiedFileCount":"64","status":"M","submitter":"bao liang"},{"authorTime":"2020-11-07 19:37:48","codes":[{"authorDate":"2020-11-12 11:33:46","commitOrder":14,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        taskExecutionContext.setHost(NetUtils.getHost() + \":\" + workerConfig.getListenPort());\n\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n                taskExecutionContext.getProcessDefineId(),\n                taskExecutionContext.getProcessInstanceId(),\n                taskExecutionContext.getTaskInstanceId()));\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.ofNullable(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        if (DateUtils.getRemainTime(taskExecutionContext.getFirstSubmitTime(), taskExecutionContext.getDelayTime() * 60L) > 0) {\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.DELAY_EXECUTION);\n            taskExecutionContext.setStartTime(null);\n        } else {\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n            taskExecutionContext.setStartTime(new Date());\n        }\n\n        \r\n        final Command ackCommand = buildAckCommand(taskExecutionContext).convert2Command();\n\n        try {\n            RetryerUtils.retryCall(() -> {\n                taskCallbackService.sendAck(taskExecutionContext.getTaskInstanceId(),ackCommand);\n                return Boolean.TRUE;\n            });\n            \r\n            workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger));\n        } catch (ExecutionException | RetryException e) {\n            logger.error(e.getMessage(), e);\n        }\n    }\n","date":"2020-11-12 11:33:46","endLine":150,"groupId":"2432","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/13/a9dca9d6c24df9844667fe77e45d8377c094fc.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n                taskExecutionContext.getProcessDefineId(),\n                taskExecutionContext.getProcessInstanceId(),\n                taskExecutionContext.getTaskInstanceId()));\n\n        taskExecutionContext.setHost(NetUtils.getHost() + \":\" + workerConfig.getListenPort());\n        taskExecutionContext.setStartTime(new Date());\n        taskExecutionContext.setLogPath(LogUtils.getTaskLogPath(taskExecutionContext));\n        taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.ofNullable(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        this.doAck(taskExecutionContext);\n\n        \r\n        workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger));\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskExecuteProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":82,"status":"M"},{"authorDate":"2020-11-07 19:37:48","commitOrder":14,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","date":"2020-11-07 19:37:48","endLine":98,"groupId":"2209","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/21/108d1291f06cc9f363fe9ff727e794f916022b.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"N"}],"commitId":"02dbd3ee06cf047f9e644322c5153232f72e7be4","commitMessage":"@@@Revert \"[Draft][Merge][133-dev]133 merge dev (#4031)\" (#4057)\n\nThis reverts commit ad2d9f99d01f3baef8641e0a7e741c08a39f1f24.","date":"2020-11-12 11:33:46","modifiedFileCount":"64","status":"M","submitter":"bao liang"},{"authorTime":"2020-11-07 19:37:48","codes":[{"authorDate":"2020-11-12 11:42:29","commitOrder":15,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n                taskExecutionContext.getProcessDefineId(),\n                taskExecutionContext.getProcessInstanceId(),\n                taskExecutionContext.getTaskInstanceId()));\n\n        taskExecutionContext.setHost(NetUtils.getHost() + \":\" + workerConfig.getListenPort());\n        taskExecutionContext.setStartTime(new Date());\n        taskExecutionContext.setLogPath(LogUtils.getTaskLogPath(taskExecutionContext));\n        taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.ofNullable(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        this.doAck(taskExecutionContext);\n\n        \r\n        workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger));\n    }\n","date":"2020-11-12 11:42:29","endLine":135,"groupId":"2209","id":29,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/60/80baf3cbeaf76e1ae42b681c1d9cfbb2158919.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        taskExecutionContext.setHost(NetUtils.getHost() + \":\" + workerConfig.getListenPort());\n\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n                taskExecutionContext.getProcessDefineId(),\n                taskExecutionContext.getProcessInstanceId(),\n                taskExecutionContext.getTaskInstanceId()));\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.ofNullable(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        if (DateUtils.getRemainTime(taskExecutionContext.getFirstSubmitTime(), taskExecutionContext.getDelayTime() * 60L) > 0) {\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.DELAY_EXECUTION);\n            taskExecutionContext.setStartTime(null);\n        } else {\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n            taskExecutionContext.setStartTime(new Date());\n        }\n\n        \r\n        final Command ackCommand = buildAckCommand(taskExecutionContext).convert2Command();\n\n        try {\n            RetryerUtils.retryCall(() -> {\n                taskCallbackService.sendAck(taskExecutionContext.getTaskInstanceId(),ackCommand);\n                return Boolean.TRUE;\n            });\n            \r\n            workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger));\n        } catch (ExecutionException | RetryException e) {\n            logger.error(e.getMessage(), e);\n        }\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskExecuteProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":82,"status":"M"},{"authorDate":"2020-11-07 19:37:48","commitOrder":15,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","date":"2020-11-07 19:37:48","endLine":98,"groupId":"2209","id":30,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/21/108d1291f06cc9f363fe9ff727e794f916022b.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"N"}],"commitId":"46091bb870e4d84e934a30298e8d659cdb5e8c92","commitMessage":"@@@Merge pull request #4058 from apache/133-merge-dev\n\n[Merge][133-dev] merge from 1.3.3-release to branch  dev","date":"2020-11-12 11:42:29","modifiedFileCount":"64","status":"M","submitter":"dailidong"},{"authorTime":"2020-11-07 19:37:48","codes":[{"authorDate":"2020-12-11 15:41:35","commitOrder":16,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n            String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n            command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n        setTaskCache(taskExecutionContext);\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n            taskExecutionContext.getProcessDefineId(),\n            taskExecutionContext.getProcessInstanceId(),\n            taskExecutionContext.getTaskInstanceId()));\n\n        taskExecutionContext.setHost(NetUtils.getHost() + \":\" + workerConfig.getListenPort());\n        taskExecutionContext.setStartTime(new Date());\n        taskExecutionContext.setLogPath(LogUtils.getTaskLogPath(taskExecutionContext));\n        taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.of(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n            taskExecutionContextCacheManager.removeByTaskInstanceId(taskExecutionContext.getTaskInstanceId());\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n            new NettyRemoteChannel(channel, command.getOpaque()));\n\n        this.doAck(taskExecutionContext);\n\n        \r\n        workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger));\n    }\n","date":"2020-12-11 15:41:35","endLine":153,"groupId":"0","id":31,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/3f/e3b6dc53b3cb56881ae817e6ea2a0c9815109d.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n                taskExecutionContext.getProcessDefineId(),\n                taskExecutionContext.getProcessInstanceId(),\n                taskExecutionContext.getTaskInstanceId()));\n\n        taskExecutionContext.setHost(NetUtils.getHost() + \":\" + workerConfig.getListenPort());\n        taskExecutionContext.setStartTime(new Date());\n        taskExecutionContext.setLogPath(LogUtils.getTaskLogPath(taskExecutionContext));\n        taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.ofNullable(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        this.doAck(taskExecutionContext);\n\n        \r\n        workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger));\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskExecuteProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":98,"status":"M"},{"authorDate":"2020-11-07 19:37:48","commitOrder":16,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","date":"2020-11-07 19:37:48","endLine":98,"groupId":"2209","id":32,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/21/108d1291f06cc9f363fe9ff727e794f916022b.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"N"}],"commitId":"a13e737eb472b21b6b4c596ede9afc80fa3beb06","commitMessage":"@@@[FIX-#4172][server-worker] kill task NPE (#4182)\n\n* [FIX-#4172][server-worker] kill task NPE\n\nThe cache task will be sent when the Process is generated. Before that.  if a kill task appears.  then NPE will appear\nModification method: write into the cache when the task is received.  and mark it as preData\nIf the task is killed before the Process is generated.  delete the cache directly at this time\nIt will be judged before the process is generated. If the task has been killed.  it will not be executed.\nAfter the new process is created.  write it into the cache.  and judge again.  if kill.  then kill the process.\n\nthis closes #4172\n\n* Delete the commented out code\nAdd spring beans\n\n* code smell\n\n* add test\n\n* add test\n\n* fix error\n\n* test\n\n* test\n\n* revert\n\n* fix error","date":"2020-12-11 15:41:35","modifiedFileCount":"7","status":"M","submitter":"Kirs"},{"authorTime":"2020-11-07 19:37:48","codes":[{"authorDate":"2020-12-20 21:17:39","commitOrder":17,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n            String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n            command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        setTaskCache(taskExecutionContext);\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n            taskExecutionContext.getProcessDefineId(),\n            taskExecutionContext.getProcessInstanceId(),\n            taskExecutionContext.getTaskInstanceId()));\n\n        taskExecutionContext.setHost(NetUtils.getHost() + \":\" + workerConfig.getListenPort());\n        taskExecutionContext.setStartTime(new Date());\n        taskExecutionContext.setLogPath(LogUtils.getTaskLogPath(taskExecutionContext));\n        taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirIfAbsent(execLocalPath);\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.of(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n            taskExecutionContextCacheManager.removeByTaskInstanceId(taskExecutionContext.getTaskInstanceId());\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n            new NettyRemoteChannel(channel, command.getOpaque()));\n\n        this.doAck(taskExecutionContext);\n\n        \r\n        workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger));\n    }\n","date":"2020-12-20 21:17:39","endLine":154,"groupId":"1091","id":33,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/e4/3a913e8c42820b58469ac8860d59b6c05b0d50.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n            String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n            command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n        setTaskCache(taskExecutionContext);\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n            taskExecutionContext.getProcessDefineId(),\n            taskExecutionContext.getProcessInstanceId(),\n            taskExecutionContext.getTaskInstanceId()));\n\n        taskExecutionContext.setHost(NetUtils.getHost() + \":\" + workerConfig.getListenPort());\n        taskExecutionContext.setStartTime(new Date());\n        taskExecutionContext.setLogPath(LogUtils.getTaskLogPath(taskExecutionContext));\n        taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirAndUserIfAbsent(execLocalPath, taskExecutionContext.getTenantCode());\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.of(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n            taskExecutionContextCacheManager.removeByTaskInstanceId(taskExecutionContext.getTaskInstanceId());\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n            new NettyRemoteChannel(channel, command.getOpaque()));\n\n        this.doAck(taskExecutionContext);\n\n        \r\n        workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger));\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskExecuteProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":98,"status":"M"},{"authorDate":"2020-11-07 19:37:48","commitOrder":17,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","date":"2020-11-07 19:37:48","endLine":98,"groupId":"2209","id":34,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/21/108d1291f06cc9f363fe9ff727e794f916022b.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"N"}],"commitId":"3bcd3fbcd344983ed35f997bed1fea2c0cf6055d","commitMessage":"@@@[Improvement-4069][server] When the tenant does not exist.  the task execution should throw an exception (#4108)\n\n* when  the tenant does not exist.  the task execution should throw an exception\n\n* remote method createWorkDirAndUserIfAbsent\n\n* set the task status failed when the tenant code does not exist.\n\n* add taskLog.\n\n* update check os user exists\n\n* update TaskExecuteThreadTest test method.\n\n* solving sonar fail.","date":"2020-12-20 21:17:39","modifiedFileCount":"5","status":"M","submitter":"zhuangchong"},{"authorTime":"2020-11-07 19:37:48","codes":[{"authorDate":"2021-01-22 11:01:46","commitOrder":18,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n            String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n            command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        setTaskCache(taskExecutionContext);\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n            taskExecutionContext.getProcessDefineId(),\n            taskExecutionContext.getProcessInstanceId(),\n            taskExecutionContext.getTaskInstanceId()));\n\n        taskExecutionContext.setHost(NetUtils.getHost() + \":\" + workerConfig.getListenPort());\n        taskExecutionContext.setStartTime(new Date());\n        taskExecutionContext.setLogPath(LogUtils.getTaskLogPath(taskExecutionContext));\n        taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirIfAbsent(execLocalPath);\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.of(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n            taskExecutionContextCacheManager.removeByTaskInstanceId(taskExecutionContext.getTaskInstanceId());\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n            new NettyRemoteChannel(channel, command.getOpaque()));\n\n        this.doAck(taskExecutionContext);\n\n        \r\n        workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger, alertClientService));\n    }\n","date":"2021-01-22 11:01:46","endLine":169,"groupId":"1091","id":35,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/d8/a6e2bfd860f612a87d58c795dcb9bc47ea92d3.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n            String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n            command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        setTaskCache(taskExecutionContext);\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n            taskExecutionContext.getProcessDefineId(),\n            taskExecutionContext.getProcessInstanceId(),\n            taskExecutionContext.getTaskInstanceId()));\n\n        taskExecutionContext.setHost(NetUtils.getHost() + \":\" + workerConfig.getListenPort());\n        taskExecutionContext.setStartTime(new Date());\n        taskExecutionContext.setLogPath(LogUtils.getTaskLogPath(taskExecutionContext));\n        taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirIfAbsent(execLocalPath);\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.of(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n            taskExecutionContextCacheManager.removeByTaskInstanceId(taskExecutionContext.getTaskInstanceId());\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n            new NettyRemoteChannel(channel, command.getOpaque()));\n\n        this.doAck(taskExecutionContext);\n\n        \r\n        workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger));\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskExecuteProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":113,"status":"M"},{"authorDate":"2020-11-07 19:37:48","commitOrder":18,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","date":"2020-11-07 19:37:48","endLine":98,"groupId":"2209","id":36,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/21/108d1291f06cc9f363fe9ff727e794f916022b.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"N"}],"commitId":"0c8d08cbaa0636ef93cbcb01c43a34f002bb7fdb","commitMessage":"@@@[Feature-#3049] Alert Plugin Design(merge alert_plugin_design to dev) (#4495)\n\n* [feature-3665][ui]Add element-ui (#3666)\n\n* [feature-3665][ui]Add element-ui\n\n* add license\n\n* Add form-create plug-in and alarm group management add sample demo\n\n* Modify node version\n\n* fix\n\n* fix\n\n* [feature][ui]Alert plugin design (#3734)\n\n* [feature-3665][ui]Add element-ui (#3666)\n\n* [feature-3665][ui]Add element-ui\n\n* add license\n\n* Add form-create plug-in and alarm group management add sample demo\n\n* Modify node version\n\n* fix\n\n* fix\n\n* [Feature-3682][ui]Add form-create plug-in and alarm group management add sample demo (#3683)\n\n* Add form-create plug-in and alarm group management add sample demo\n\n* Modify node version\n\n* fix\n\n* fix\n\n* [feature][ui] Add alarm instance page\n\n* [feature-3665][ui]Add element-ui (#3666)\n\n* [feature-3665][ui]Add element-ui\n\n* add license\n\n* Add form-create plug-in and alarm group management add sample demo\n\n* Modify node version\n\n* fix\n\n* fix\n\n* [Feature-3189][alert. spi. dao. plugin-api] base code of dolphinscheduler spi and alert plugin implement (#3601)\n\n* DS SPI\n\n* Add DolphinScheduler SPI .  and rebuilt the code of the Alert plug-in based on SPI\n\n* Add DolphinScheduler SPI .  and rebuilt the code of the Alert plug-in based on SPI\n\n* add TODO\n\n* delete\n\n* compile\n\n* spi commit\n\n* Plugin Alert\n\n* fix some bug\n\n* add todo\n\n* change web ui from alpacajs to form-create\n\n* remove module\n\n* add plugin schema\n\n* add license header\n\n* update alert and spi module version\n\n* update the alert plugin sub module version\n\n* comment the maven.local.repository param\n\n* move utils from spi to common module\n\n* add license header\n\n* add license header and delete some chinese comment\n\n* update spi packages\n\n* delete no use alert_xx.properties\n\n* update mysql.connector.version back to 5.1.34\n\n* delete no use comment in pom.xml\n\n* update email stmp password\n\n* add license\n\n* add semicolon to sql/upgrade/1.4.0_schema/mysql/dolphinscheduler_ddl.sql file\n\n* format the code style\n\n* format new clase file with checkstyle\n\n* update plugin params to Builder model\n\n* move JSONUtils to SPI because plugin can not dependency common module\n\n* move JSONUtils to SPI because plugin can not dependency common module\n\n* delete collection dependency\n\n* replace PluginParamsTransfer to spi PluginParamsTransfer\n\n* update dolphinscheduler-maven-plugin to 1.0.0\n\n* update license\n\n* update apache-rat-plugin add exclude '.iml' file\n\n* check license\n\n* ArtifactResolver only use in development and configPlugins is not empty\n\n* ArtifactResolver only use in development and configPlugins is not empty\n\n* ArtifactResolver only use in development and configPlugins is not empty\n\n* default datasource should be postgresql\n\n* add license files\n\n* add license files\n\n* postgresql port should be 5432\n\n* postgresql test\n\n* mv show_type to spi\n\nadd license header to AlertConstants\n\n* check style fix\n\n* copy check style file from branch dev\n\n* alert show_type set by plugin\n\n* alert show_type set by plugin\n\n* add PluginDefineMapper to dolphinscheduler-server/src/test/java/org/apache/dolphinscheduler/server/registry/DependencyConfig.java\n\n* add Bean to TaskCallbackServiceTestConfig\n\n* add Bean to TaskCallbackServiceTestConfig\n\n* fix check style\n\n* check style fix\n\n* [feature-3665][ui]Add element-ui (#3666)\n\n* [feature-3665][ui]Add element-ui\n\n* add license\n\n* fix check style\n\n* [Feature-3682][ui]Add form-create plug-in and alarm group management add sample demo (#3683)\n\n* Add form-create plug-in and alarm group management add sample demo\n\n* Modify node version\n\n* fix\n\n* fix\n\n* check style fix\n\n* rollback test change\n\n* rollback test change\n\n* rollback dao pom change\n\n* [feature-3665][ui]Add element-ui (#3666)\n\n* [feature-3665][ui]Add element-ui\n\n* add license\n\n* Add form-create plug-in and alarm group management add sample demo\n\n* Modify node version\n\n* fix\n\n* fix\n\n* add ut to pom.xml\n\n* add upgrade schema to global schema\n\n* fix ut failed\n\n* fix ut failed\n\n* fix ut failed\n\n* fix ut failed\n\n* add test EmailAlertPluginTest to pom.xml\n\n* fix ut failed\n\n* fix ut failed\n\n* fix check style\n\n* update license header to presto license header\n\n* presto license header not check\n\n* fix ut coverage\n\n* fix ut coverage\n\n* fix ut\n\n* fix ut\n\n* fix ut\n\n* fix ut coverage\n\n* fix ut coverage\n\n* fix ut coverage\n\n* fix ut coverage\n\n* fix ut coverage\n\n* fix ut coverage\n\nCo-authored-by: break60 <790061044@qq.com>\n\n* Replace the tenant management page ui with element-ui (#3891)\n\n* [feature-3665][ui]Add element-ui (#3666)\n\n* [feature-3665][ui]Add element-ui\n\n* add license\n\n* Add form-create plug-in and alarm group management add sample demo\n\n* Modify node version\n\n* fix\n\n* fix\n\n* [Feature-3682][ui]Add form-create plug-in and alarm group management add sample demo (#3683)\n\n* Add form-create plug-in and alarm group management add sample demo\n\n* Modify node version\n\n* fix\n\n* fix\n\n* [feature][ui] Add alarm instance page\n\n* [feature-3665][ui]Add element-ui (#3666)\n\n* [feature-3665][ui]Add element-ui\n\n* add license\n\n* Add form-create plug-in and alarm group management add sample demo\n\n* Modify node version\n\n* fix\n\n* fix\n\n* [feature-3665][ui]Add element-ui (#3666)\n\n* [feature-3665][ui]Add element-ui\n\n* add license\n\n* Add form-create plug-in and alarm group management add sample demo\n\n* Modify node version\n\n* fix\n\n* fix\n\n* [feature][ui]Alert plugin design (#3734)\n\n* [feature-3665][ui]Add element-ui (#3666)\n\n* [feature-3665][ui]Add element-ui\n\n* add license\n\n* Add form-create plug-in and alarm group management add sample demo\n\n* Modify node version\n\n* fix\n\n* fix\n\n* [Feature-3682][ui]Add form-create plug-in and alarm group management add sample demo (#3683)\n\n* Add form-create plug-in and alarm group management add sample demo\n\n* Modify node version\n\n* fix\n\n* fix\n\n* [feature][ui] Add alarm instance page\n\n* [feature-3665][ui]Add element-ui (#3666)\n\n* [feature-3665][ui]Add element-ui\n\n* add license\n\n* Add form-create plug-in and alarm group management add sample demo\n\n* Modify node version\n\n* fix\n\n* fix\n\n* [Feature-3189][alert. spi. dao. plugin-api] base code of dolphinscheduler spi and alert plugin implement (#3601)\n\n* DS SPI\n\n* Add DolphinScheduler SPI .  and rebuilt the code of the Alert plug-in based on SPI\n\n* Add DolphinScheduler SPI .  and rebuilt the code of the Alert plug-in based on SPI\n\n* add TODO\n\n* delete\n\n* compile\n\n* spi commit\n\n* Plugin Alert\n\n* fix some bug\n\n* add todo\n\n* change web ui from alpacajs to form-create\n\n* remove module\n\n* add plugin schema\n\n* add license header\n\n* update alert and spi module version\n\n* update the alert plugin sub module version\n\n* comment the maven.local.repository param\n\n* move utils from spi to common module\n\n* add license header\n\n* add license header and delete some chinese comment\n\n* update spi packages\n\n* delete no use alert_xx.properties\n\n* update mysql.connector.version back to 5.1.34\n\n* delete no use comment in pom.xml\n\n* update email stmp password\n\n* add license\n\n* add semicolon to sql/upgrade/1.4.0_schema/mysql/dolphinscheduler_ddl.sql file\n\n* format the code style\n\n* format new clase file with checkstyle\n\n* update plugin params to Builder model\n\n* move JSONUtils to SPI because plugin can not dependency common module\n\n* move JSONUtils to SPI because plugin can not dependency common module\n\n* delete collection dependency\n\n* replace PluginParamsTransfer to spi PluginParamsTransfer\n\n* update dolphinscheduler-maven-plugin to 1.0.0\n\n* update license\n\n* update apache-rat-plugin add exclude '.iml' file\n\n* check license\n\n* ArtifactResolver only use in development and configPlugins is not empty\n\n* ArtifactResolver only use in development and configPlugins is not empty\n\n* ArtifactResolver only use in development and configPlugins is not empty\n\n* default datasource should be postgresql\n\n* add license files\n\n* add license files\n\n* postgresql port should be 5432\n\n* postgresql test\n\n* mv show_type to spi\n\nadd license header to AlertConstants\n\n* check style fix\n\n* copy check style file from branch dev\n\n* alert show_type set by plugin\n\n* alert show_type set by plugin\n\n* add PluginDefineMapper to dolphinscheduler-server/src/test/java/org/apache/dolphinscheduler/server/registry/DependencyConfig.java\n\n* add Bean to TaskCallbackServiceTestConfig\n\n* add Bean to TaskCallbackServiceTestConfig\n\n* fix check style\n\n* check style fix\n\n* [feature-3665][ui]Add element-ui (#3666)\n\n* [feature-3665][ui]Add element-ui\n\n* add license\n\n* fix check style\n\n* [Feature-3682][ui]Add form-create plug-in and alarm group management add sample demo (#3683)\n\n* Add form-create plug-in and alarm group management add sample demo\n\n* Modify node version\n\n* fix\n\n* fix\n\n* check style fix\n\n* rollback test change\n\n* rollback test change\n\n* rollback dao pom change\n\n* [feature-3665][ui]Add element-ui (#3666)\n\n* [feature-3665][ui]Add element-ui\n\n* add license\n\n* Add form-create plug-in and alarm group management add sample demo\n\n* Modify node version\n\n* fix\n\n* fix\n\n* add ut to pom.xml\n\n* add upgrade schema to global schema\n\n* fix ut failed\n\n* fix ut failed\n\n* fix ut failed\n\n* fix ut failed\n\n* add test EmailAlertPluginTest to pom.xml\n\n* fix ut failed\n\n* fix ut failed\n\n* fix check style\n\n* update license header to presto license header\n\n* presto license header not check\n\n* fix ut coverage\n\n* fix ut coverage\n\n* fix ut\n\n* fix ut\n\n* fix ut\n\n* fix ut coverage\n\n* fix ut coverage\n\n* fix ut coverage\n\n* fix ut coverage\n\n* fix ut coverage\n\n* fix ut coverage\n\nCo-authored-by: break60 <790061044@qq.com>\n\n* The tenant management module ui is replaced with element-ui\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* modify\n\n* fix\n\nCo-authored-by: gaojun2048 <32193458+gaojun2048@users.noreply.github.com>\n\n* the alert module support service.\n\n* the alert module support service.\n\n* Delete blank lines.\n\n* add code checkstyle.\n\n* Solve the sonar bug.\n\n* Re-execute build.\n\n* add test.\n\n* update ut.\n\n* add test class.\n\n* update test.\n\n* [feature#3356] alert-spi support DingTalk&WeChat (#3869)\n\n* [feature-3665][ui]Add element-ui (#3666)\n\n* [feature-3665][ui]Add element-ui\n\n* add license\n\n* Add form-create plug-in and alarm group management add sample demo\n\n* Modify node version\n\n* fix\n\n* fix\n\n* [feature][ui]Alert plugin design (#3734)\n\n* [feature-3665][ui]Add element-ui (#3666)\n\n* [feature-3665][ui]Add element-ui\n\n* add license\n\n* Add form-create plug-in and alarm group management add sample demo\n\n* Modify node version\n\n* fix\n\n* fix\n\n* [Feature-3682][ui]Add form-create plug-in and alarm group management add sample demo (#3683)\n\n* Add form-create plug-in and alarm group management add sample demo\n\n* Modify node version\n\n* fix\n\n* fix\n\n* [feature][ui] Add alarm instance page\n\n* [feature-3665][ui]Add element-ui (#3666)\n\n* [feature-3665][ui]Add element-ui\n\n* add license\n\n* Add form-create plug-in and alarm group management add sample demo\n\n* Modify node version\n\n* fix\n\n* fix\n\n* [Feature-3189][alert. spi. dao. plugin-api] base code of dolphinscheduler spi and alert plugin implement (#3601)\n\n* DS SPI\n\n* Add DolphinScheduler SPI .  and rebuilt the code of the Alert plug-in based on SPI\n\n* Add DolphinScheduler SPI .  and rebuilt the code of the Alert plug-in based on SPI\n\n* add TODO\n\n* delete\n\n* compile\n\n* spi commit\n\n* Plugin Alert\n\n* fix some bug\n\n* add todo\n\n* change web ui from alpacajs to form-create\n\n* remove module\n\n* add plugin schema\n\n* add license header\n\n* update alert and spi module version\n\n* update the alert plugin sub module version\n\n* comment the maven.local.repository param\n\n* move utils from spi to common module\n\n* add license header\n\n* add license header and delete some chinese comment\n\n* update spi packages\n\n* delete no use alert_xx.properties\n\n* update mysql.connector.version back to 5.1.34\n\n* delete no use comment in pom.xml\n\n* update email stmp password\n\n* add license\n\n* add semicolon to sql/upgrade/1.4.0_schema/mysql/dolphinscheduler_ddl.sql file\n\n* format the code style\n\n* format new clase file with checkstyle\n\n* update plugin params to Builder model\n\n* move JSONUtils to SPI because plugin can not dependency common module\n\n* move JSONUtils to SPI because plugin can not dependency common module\n\n* delete collection dependency\n\n* replace PluginParamsTransfer to spi PluginParamsTransfer\n\n* update dolphinscheduler-maven-plugin to 1.0.0\n\n* update license\n\n* update apache-rat-plugin add exclude '.iml' file\n\n* check license\n\n* ArtifactResolver only use in development and configPlugins is not empty\n\n* ArtifactResolver only use in development and configPlugins is not empty\n\n* ArtifactResolver only use in development and configPlugins is not empty\n\n* default datasource should be postgresql\n\n* add license files\n\n* add license files\n\n* postgresql port should be 5432\n\n* postgresql test\n\n* mv show_type to spi\n\nadd license header to AlertConstants\n\n* check style fix\n\n* copy check style file from branch dev\n\n* alert show_type set by plugin\n\n* alert show_type set by plugin\n\n* add PluginDefineMapper to dolphinscheduler-server/src/test/java/org/apache/dolphinscheduler/server/registry/DependencyConfig.java\n\n* add Bean to TaskCallbackServiceTestConfig\n\n* add Bean to TaskCallbackServiceTestConfig\n\n* fix check style\n\n* check style fix\n\n* [feature-3665][ui]Add element-ui (#3666)\n\n* [feature-3665][ui]Add element-ui\n\n* add license\n\n* fix check style\n\n* [Feature-3682][ui]Add form-create plug-in and alarm group management add sample demo (#3683)\n\n* Add form-create plug-in and alarm group management add sample demo\n\n* Modify node version\n\n* fix\n\n* fix\n\n* check style fix\n\n* rollback test change\n\n* rollback test change\n\n* rollback dao pom change\n\n* [feature-3665][ui]Add element-ui (#3666)\n\n* [feature-3665][ui]Add element-ui\n\n* add license\n\n* Add form-create plug-in and alarm group management add sample demo\n\n* Modify node version\n\n* fix\n\n* fix\n\n* add ut to pom.xml\n\n* add upgrade schema to global schema\n\n* fix ut failed\n\n* fix ut failed\n\n* fix ut failed\n\n* fix ut failed\n\n* add test EmailAlertPluginTest to pom.xml\n\n* fix ut failed\n\n* fix ut failed\n\n* fix check style\n\n* update license header to presto license header\n\n* presto license header not check\n\n* fix ut coverage\n\n* fix ut coverage\n\n* fix ut\n\n* fix ut\n\n* fix ut\n\n* fix ut coverage\n\n* fix ut coverage\n\n* fix ut coverage\n\n* fix ut coverage\n\n* fix ut coverage\n\n* fix ut coverage\n\nCo-authored-by: break60 <790061044@qq.com>\n\n* [feature#3356] alert-spi support DingTalk\n\nthis closes # 3356\n\n* add test\n\n* code style\n\n* we chat alert\n\n* support we chat alert\n\n* support we chat alert\n\n* support we chat alert. update ding talk alert\n\n* code style\n\n* add test\n\n* code style\n\n* clean old code\n\n* clean old code\n\n* code smell\n\n* code style\n\n* add test\n\n* simple config\n\n* code style\n\n* code style\n\n* code style\n\n* delete old file\n\n* fix log content error\n\nCo-authored-by: break60 <790061044@qq.com>\nCo-authored-by: gaojun2048 <32193458+gaojun2048@users.noreply.github.com>\n\n* [FEATURE#4029] alert spi support script alert\n\nthis closes #4029\n\n* code style\n\n* code smell\n\n* add test\n\n* code style\n\n* code smell\n\n* code style\n\n* fix name error\n\n* init sms plugin\n\n* modify http type\n\n* delete dolphinscheduler-alert-sms plugin\n\n* dolphinscheduler plugin need add <package>dolphinscheduler-plugin</package> in the pom.xml file\n\n* delete alert http plugin (#4152)\n\ndelete alert http plugin (#4152)\nThis part of the code was merged by mistake.  so I need to delete it\n\n* [Feature-3749][Alert-SPI] SqlTask should send notifications by alert server api (#4080)\n\n* add sqltask send sync alert server.\n\n* update alert-sms license.\n\n* update AlertServer test.\n\n* remote EmailAlertPluginTest.\n\n* update sqltask.\n\n* update test class.\n\n* [Alert plugin design] add http alert plugin (#4165)\n\n* add http alert plugin\n\n* [Feature-3311] Add alert plugin instance function (#4038)\n\n* [Feature-#3252][build]plugins need put in plugins dir when install (#4259)\n\nUpdate maven build.  put the alert plugins in the ${install_dir}/lib/plugin/alert/${plugin_module_name} directory\n(assembly build and rpm build).\nNote: When adding a new plug-in.  it must be reflected in provisio/dolphinscheduler.xml.\n\nthis closes #3252\n\n* [Feature#4310][Alert-SPI] Plug-ins containing UI components provide display pages (#4311)\n\n* [Feature#4310][Alert-SPI] Plug-ins containing UI components provide display pages\n\n*Some plugins (such as alert plugin) need to provide UI interfaces to users.\n*We use from-creat to dynamically generate UI interfaces. Related parameters are mainly provided by pluginParams.\n*From-create can generate dynamic ui based on this parameter.\n\nthis closes #4310\n\n* add license head\n\n* rename\n\n* add ut\n\n* add license\n\n* add query plugin detail interface\n\n* fix error\n\n* [Feature-#3828][server] Delete recipients and CCs in the process defi? (#4303)\n\n* [Feature-#3828][server] Delete recipients and CCs in the process definition and select the associated alert group instead\n\n* The specific alarm instance associated with the alert group\n* The process definition only associates the alert group.  and does not care about the specific alarm instance.\n\nthis closes #3828\n\n* remove test cc\n\n* remove test cc\n\n* fix test error\n\n* add sql upgrade script\ndelete alert column(show_type?alert_type?re?cc)\n\n* code style\n\n* update test\nNote the statement to delete the column.  and provide related instructions\n\n* delete AlertGroup field(alert_type)\n\n* fix ut error\n\n* fix ut error\n\n* fix ut error\n\n* code style\n\n* delete api-doc receiverCC\n\n* delete UserAlertGroupMapper\n\n* delete UserAlertGroup\n\n* delete UserAlertGroupApi\n\n* alert group add coulmn user_id\n\n* alter user_id to create_user_id\n\n* userinfo remove alert group info\n\n* Replace the front-end code of the plugin branch with the front-end code of the dev branch (#4353)\n\n* Replace the front-end code of the plugin branch with the front-end code of the dev branch\n\n* Merge dev to alert_plugin_design (#4351)\n\n* fixed queryProcessInstanceListPaging query slow (#3893)\n\nbecause queryProcessInstanceListPaging has contain longtext type field by instance.*. so queryProcessInstanceListPaging query slow .  but longtext field not used.\n\n* fixed  queryTaskInstanceListPaging query slow (#3892)\n\nbecause queryTaskInstanceListPaging  has contain longtext  type field  by instance.*. so  queryTaskInstanceListPaging query slow .  but longtext  field not used.\n\n* add verify tenant name cannot contain special characters. (#3865)\n\n* [Fix][Docker] fix startup.sh variables cannot reference in single quotes. (#3895)\n\n* [Fix][Docker] fix startup.sh variables cannot reference in single quotes.(#3894)\n\nSigned-off-by: YoungMan <bushengquan@gmail.com>\n\n* Update Dockerfile\n\nupdate the  comment\nand delete the maridb client\n\nCo-authored-by: dailidong <dailidong66@gmail.com>\n\n* [ambari-plugin]change version 1.3.2 to 1.3.3 (#3935)\n\n* [CodeClean][DAO]Remove redundant comments (#3939)\n\n* fix bug\n\nDelete invalid field: executorcores\n\nModify verification prompt\n\n* fix bug\n\nDelete invalid field: executorcores\n\nModify verification prompt\n\n* fix bug\n\nDelete invalid field: executorcores\n\nModify verification prompt\n\n* dag  add close button\n\n* reset last version\n\n* reset last version\n\n* dag add close buttion\n\ndag add close buttion\n\n* update  CLICK_SAVE_WORKFLOW_BUTTON  xpath\n\n* updae CLICK_SAVE_WORKFLOW_BUTTON xpath\n\n* updae CLICK_SAVE_WORKFLOW_BUTTON xpath\n\n* updae CLICK_SAVE_WORKFLOW_BUTTON xpath\n\n* Update CreateWorkflowLocator.java\n\nmodify submit workflow button\n\n* Update CreateWorkflowLocator.java\n\n* Update CreateWorkflowLocator.java\n\nmodify CLICK_ADD_BUTTON\n\n* Update CreateWorkflowLocator.java\n\ndelete print\n\n* Update CreateWorkflowLocator.java\n\n1\n\n* Update CreateWorkflowLocator.java\n\n1\n\n* Setting '-XX:+DisableExplicitGC ' causes netty memory leaks\n\nin addition\n\nupdate '- XX: largepagesizeinbytes = 128M' to '- XX: largepagesizeinbytes = 10M'\n\n* Update dag.vue\n\n* Update dag.vue\n\n* Update dag.vue\n\n* Update CreateWorkflowLocator.java\n\n* Revert \"Setting '-XX:+DisableExplicitGC ' causes netty memory leaks\"\n\nThis reverts commit 3a2cba7a\n\n* Setting '-XX:+DisableExplicitGC ' causes netty memory leaks\n\nin addition\n\nupdate '- XX: largepagesizeinbytes = 128M' to '- XX: largepagesizeinbytes = 10M'\n\n* Update dolphinscheduler-daemon.sh\n\n* Remove redundant comments\nProcessInstanceMapper# queryProcessInstanceListPaging\n\n* Remove redundant comments\nProcessInstanceMapper# queryProcessInstanceListPaging\n\nCo-authored-by: dailidong <dailidong66@gmail.com>\nCo-authored-by: xingchun-chen <55787491+xingchun-chen@users.noreply.github.com>\n\n* fix bug:3615 After the task is executed successfully.  but the next task has not been submitted.  stop the master\n\n* When running a task.  the resource file is lost.  which results in an error\n\n* When running a task.  the resource file is lost.  which results in an error\n\n* When running a task.  the resource file is lost.  which results in an error\n\n* [Fix][api] Add queryProjectCreatedAndAuthorizedByUser function (#3658)\n\n* fix getLoginUserCreated bug\n\n* fix getLoginUserCreated bug 1\n\n* fix checkstyle\n\n* modify function name\n\n* modify comment\n\n* fix unit test error\n\n* rollback sqoop task hive target file\n\nCo-authored-by: sunchaohe <sunzhaohe@linklogis.com>\nCo-authored-by: dailidong <dailidong66@gmail.com>\n\n* When running a task.  the resource file is lost.  which results in an error\n\n* When running a task.  the resource file is lost.  which results in an error\n\n* [fixBug-3964][ui]Switch back and forth over timeout alarm.  the selected value is empty\n\n* solve too many files.  close logClientService (#3971)\n\n* fix #3966 sub process doesnot send alert mail after process instance ending. (#3972)\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* [Fix-#3618][server] resolve task executed finished but not release the file handle (#3975)\n\n* [Fix-#3618][server] resolve task executed finished but not release the file handle\n\n* [Fix-#3618][server] resolve task executed finished but not release the file handle\n\n* [Fix-#3958][api] files should not be created successfully in the directory of the authorized file\n\n* [FIX-3966] The timeout warning does not take effect in sub_process (#3982)\n\n* fix #3966 sub process doesnot send alert mail after process instance ending.\n\n* fix bug 3964: sub_process The timeout warning does not take effect\nadd timeout warning for sub_process/dependent task.\n\n* fix code smell\n\n* fix code smell\n\n* fix code smell\n\n* update worker group inherit from parent\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* [fix-#3962][api] Avoid ClassCastException for LoggerService.queryLog(). (#3963)\n\n* Enhance user experience.  add close button to file details page\n\n* [Test-3557][API] full cover DataAnalysisServiceImpl (#3605)\n\n* generate equals and hashCode method\n\n* make up for the state of oblivion\n\n* simplify countQueueState method\n\n* delete try catch.  because this never throw exception\n\n* full cover DataAnalysisServiceImpl\n\n* improve test coverage\n\n* adjust code style\n\n* simplify countCommandState method\n\n* reduce duplication\n\n* simplify countTaskDtos method\n\n* Update DataAnalysisServiceImpl.java\n\nCo-authored-by: dailidong <dailidong66@gmail.com>\n\n* fix import dolphinscheduler_mysql.sql insert admin user data\n\n* [FIX-3929] condition task would post wrong tasks when failover. (#3999)\n\n* fix #3966 sub process doesnot send alert mail after process instance ending.\n\n* fix bug 3964: sub_process The timeout warning does not take effect\nadd timeout warning for sub_process/dependent task.\n\n* fix code smell\n\n* fix code smell\n\n* fix code smell\n\n* update worker group inherit from parent\n\n* remove stdout in logback configuration\n\n* fix bug #3929 condition task would post error when failover.\n\n* remove unused test\n\n* add comments\n\n* add skip node judge\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* [FIX-3929]  because of no lock.  start up failover would dispatch two same tasks. (#4004)\n\n* fix #3966 sub process doesnot send alert mail after process instance ending.\n\n* fix bug 3964: sub_process The timeout warning does not take effect\nadd timeout warning for sub_process/dependent task.\n\n* fix code smell\n\n* fix code smell\n\n* fix code smell\n\n* update worker group inherit from parent\n\n* remove stdout in logback configuration\n\n* fix bug #3929 condition task would post error when failover.\n\n* remove unused test\n\n* add comments\n\n* add skip node judge\n\n* fix bug 3929: because of no lock.  start up failover would dispatch two same tasks.\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* revert pom version to 1.3.3-release\n\n* [maven-release-plugin] prepare release 1.3.3\n\n* [maven-release-plugin] prepare for next development iteration\n\n* the resources API document does not match the interface parameters\n\n* [release]revert pom version to 1.3.3-release\n\n* fix bug 4010: remove failed condition tasks from error-task-list. (#4011)\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* [maven-release-plugin] prepare release 1.3.3\n\n* [maven-release-plugin] prepare for next development iteration\n\n* fix bug\n\n* reset code\n\n* Update udfs.vue\n\n* [Feature-3941][ui] Remove tenant name  (#3949)\n\n* FeatureUI-3941: Removed Tenant\n\n* FeatureUI-3941: Removed tenantName in the suggested pages\n\n* FeatureUI-3941: Updated the suggested files\n\n* FeatureUI-3941: Updated the TenantController\n\n* FeatureUI-3941: Updated the TenantController and the pom.xml\n\n* FeatureUI-3941: Updated the TenantControllerTest\n\n* [Improvement][script] daemon script usage (#3968)\n\n* Improvement daemon script usage\n\n* don't remove status command\n\ndon't remove status command\n\nCo-authored-by: dailidong <dailidong66@gmail.com>\n\n* fix #3688.  Optimization of table building statements (#3689)\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* [Improvement-4012][common/remote] Json util code integration. remove the remote module json util (#4013)\n\n* Json util code integration. remove the remote module json util.\n\n* update code checkstyle.\n\n* update code checkstyle.\n\n* add code checkstyle.\n\n* add test class.\n\n* update JSONUtils class.\n\n* update JSONUtils class.\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* refactor code style\n\n* refactor code style\n\n* refactor code style\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* refactor ut test\n\n* refactor ut test\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* fix #3900 kill multi yarn app in one job\n\n* refactor ut\n\n* merge from 1.3.3-release\n\n* refactor ut\n\n* refactor ut\n\n* refactor\n\n* refactor\n\n* refactor code style\n\n* refactor code style\n\n* refactor code style\n\n* refactor code style\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* add ProcessUtils UT\n\n* refactor code style\n\n* refactor code style\n\n* refactor code style\n\n* refactor code style\n\n* [Draft][Merge][133-dev]133 merge dev (#4031)\n\n* [Feture-3327][ui]Add the function of re-uploading files in the resource center\n\n* [Feture-3327][ui]Add the function of re-uploading files in the resource center (#3394)\n\n* Before creating a workflow.  clear the canvas\n\n* [Fix-3256][ui] herry pick commit from dev for Fix admin user info update error (#3306)\n\n* [Feture-3327][ui]Add the function of re-uploading files in the resource center\n\nCo-authored-by: wuchunfu <319355703@qq.com>\n\n* [Improvement-3327][api]support re-upload the resource file (#3395)\n\n* [Fix-3390][server]Running hive sql task need find the hdfs path correctly (#3396)\n\n* [Fix-3390][api]Running hive sql task need find the hdfs path correctly\n\n* [Fix-3390][api]Running hive sql task need find the hdfs path correctly\n\n* update soft version\n\n* hive UDF function to modify the background color\n\n* fix\n\n* fix bug: Fix master task dependency check bug\n\n* cancel spark task version check (#3406)\n\nCo-authored-by: Eights-Li <yelli.hl@gmail.com>\n\n* [Bug][ui]Fix front-end bug #3413\n\n* [Feature][ambari_plugin]support one worker can belongs different worker groups when execute install script (#3410)\n\n* Optimize dag\n\n* Update actions.js (#3401)\n\n* [Fix-3256][ui] Fix admin user info update error (#3425) (#3428)\n\n* [PROPOSAL-3139] Datasource selection changes from radio to select\n\n* [PROPOSAL-3139] Datasource selection changes from radio to select\n\n* [BUG FIX] issues #3256\n\n* [BUG FIX] issues #3256\n\n* [BUG FIX] issues #3256\n\n* [Fix-3256][ui] Fix admin user info update error\n\n* [Fix-3256][ui] Fix admin user info update error\n\n* [Fix-3256][ui] Fix admin user info update error\n\n* [Fix-3256][ui] Fix admin user info update error\n\n* reset createUser.vue\n\n* [Fix-3256][ui] Fix admin user info update error\n\nCo-authored-by: dailidong <dailidong66@gmail.com>\n\nCo-authored-by: wuchunfu <319355703@qq.com>\nCo-authored-by: dailidong <dailidong66@gmail.com>\n\n* [Fix-3433][api]Fixed that release the imported process definition which version is below 1.3.0 will be failure\n\n* dag connection add check\n\n* fix\n\n* [Fix-3423][dao][sql]Fixed that the resource file of the task node can't be found when upgrade from 1.2.0 to 1.3.x (#3454)\n\n* Remove node deep monitoring\n\n* If worker group id is null. don't need to set the value of the worker group (#3460)\n\n* [Fix-3423][dao][sql]Fixed that the resource file of the task node can't be found when upgrade from 1.2.0 to 1.3.x\n\n* [Fix-3423][dao]If worker group id is null. don't need to set the value of the worker group\n\n* [ui]Code optimization\n\n* fix\n\n* fix\n\n* [fix-3058][ui]Move rtTargetArr to jsPlumbHandle.js\n\n* [optimization][ui]Prevent the shell script input box from being empty\n\n* [Fix-3462][api]If login user is admin. need list all udfs (#3465)\n\n* [Fix-3462][api]If login user is admin. need list all udfs\n\n* [Fix-3462][api]add the test on the method of QueryUdfFuncList\n\n* [Fix-3462][api]fix the code smell\n\n* [Fix-3462][api]fix the code smell\n\n* [Fix-3462][api]fix the code smell\n\n* [Fix-3463][api]Fixed that run the sql task will be failure after rename the udf resource (#3482)\n\n* [fixBug-3058][ui]Fix connection abnormalities in historical workflow instance data\n\n* [Feture-3327][ui]Add the function of re-uploading files in the udf subdirectory\n\n* fix bug: Fix master task dependency check bug (#3473)\n\nCo-authored-by: lenboo <baoliang@analysys.com.cn>\n\n* [maven-release-plugin] prepare release 1.3.2\n\n* [maven-release-plugin] prepare for next development iteration\n\n* fix ci_e2e fail (#3497)\n\n* [Fix-3469][api]Should filter the resource by the different program type (#3498)\n\n* [Fix-3463][api]Fixed that run the sql task will be failure after rename the udf resource\n\n* [Fix-3469][api]Should list python file and jar file\n\n* [Fix-3469][api]Should filter the resource by the different program type\n\n* [Fix-3469][api]fix the code smell\n\n* test release 1.3.2 version rollback\n\n* test release 1.3.2 version rollback\n\n* test release 1.3.2 version rollback (#3499)\n\n* [Feature] JVM parameter optimization .  related issue #3370\n\n* [Feature] JVM parameter optimization .  related issue #3370\n\n* test release 1.3.2 version rollback\n\n* test release 1.3.2 version rollback\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\n\n* [maven-release-plugin] prepare release 1.3.2\n\n* [maven-release-plugin] prepare for next development iteration\n\n* [Fix-3469][ui]The value of maintenance resources and the filtering of resources according to different program types\n\n* fix\n\n* Revert \"fix ci_e2e fail (#3497)\"\n\nThis reverts commit e367f90bb73c9682739308a0a98887a1c0f407ef.\n\n* test\n\n* test release 1.3.2 version rollback\n\n* test release 1.3.2 version rollback (#3503)\n\n* [Feature] JVM parameter optimization .  related issue #3370\n\n* [Feature] JVM parameter optimization .  related issue #3370\n\n* test release 1.3.2 version rollback\n\n* test release 1.3.2 version rollback\n\n* test\n\n* test release 1.3.2 version rollback\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\n\n* [maven-release-plugin] prepare release 1.3.2\n\n* [maven-release-plugin] prepare for next development iteration\n\n* test release 1.3.2 version rollback (#3504)\n\n* [Feature] JVM parameter optimization .  related issue #3370\n\n* [Feature] JVM parameter optimization .  related issue #3370\n\n* test release 1.3.2 version rollback\n\n* test release 1.3.2 version rollback\n\n* test\n\n* test release 1.3.2 version rollback\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\n\n* [maven-release-plugin] prepare release 1.3.2\n\n* [maven-release-plugin] prepare for next development iteration\n\n* fix ds muti-level directory in zk.  which lead to fail to assign work\n\n* add login user check some actions in api\n\n* [Hotfix][ci] Fix e2e ci docker image build error\n\n* modify tag 1.3.0 to HEAD\n\n* modify tag 1.3.0 to HEAD (#3525)\n\n* [Feature] JVM parameter optimization .  related issue #3370\n\n* [Feature] JVM parameter optimization .  related issue #3370\n\n* test release 1.3.2 version rollback\n\n* test release 1.3.2 version rollback\n\n* test\n\n* test release 1.3.2 version rollback\n\n* modify tag 1.3.0 to HEAD\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\n\n* remove OGNL part of the mybaits notice (#3526)\n\n* [maven-release-plugin] prepare release 1.3.2\n\n* [maven-release-plugin] prepare for next development iteration\n\n* release 1.3.2 version rollback (#3527)\n\n* [Feature] JVM parameter optimization .  related issue #3370\n\n* [Feature] JVM parameter optimization .  related issue #3370\n\n* test release 1.3.2 version rollback\n\n* test release 1.3.2 version rollback\n\n* test\n\n* test release 1.3.2 version rollback\n\n* modify tag 1.3.0 to HEAD\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\n\n* [ui]Script input box to modify the delay loading time\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* modify general user can't create token\n\n* [ui]It is forbidden to select non-existent resources and modify the tree display data format\n\n* modify general user can't create token (#3533)\n\n* [Feature] JVM parameter optimization .  related issue #3370\n\n* [Feature] JVM parameter optimization .  related issue #3370\n\n* test release 1.3.2 version rollback\n\n* test release 1.3.2 version rollback\n\n* test\n\n* test release 1.3.2 version rollback\n\n* modify tag 1.3.0 to HEAD\n\n* modify general user can't create token\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\n\n* if task is null .  set task type is null instead of \"null\"\n\n* [Fix-3536][api]If user didn't have tenant. create resource directory will NPE (#3537)\n\n* [Fix-3536][api]If user didn't have tenant. create resource will NPE\n\n* [Fix-3536][api]If user didn't have tenant. create resource directory will NPE\n\n* modify general user can't create. delete. update token (#3538)\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\n\n* [ui]Resource delete OK button to increase loading.  change the number of homepage display cursor\n\n* fix\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry (#3748)\n\n* [fixbug][ui]Repair the master and worker management instrument display\n\n* [Fix-3238][docker]Fix that can not create folder in docker with standalone mode (#3741)\n\n* [fixbug][ui]Remove non-existent or deleted resources disabled\n\n* [fixBug-3621][ui]If the workflow instance status is executing status.  it is forbidden to select\n\n* [fix-3553][ui]Repair click workflow connection.  select the entire path\n\n* fix\n\n* fix\n\n* [Fix-3238][docker]Fix that can not create folder in docker with standalone mode\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry (#3776)\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\n\n* The batch delete function in the workflow definition and workflow instance pages cannot be canceled if selected.\n\n* [Improvement-3720][ui] js mailbox verification fix\n\n* [Fix-3549] [Server][sqlTask]The alias column in the query SQL does not take effect (#3784)\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* The batch delete function in the workflow definition and workflow instance pages cannot be canceled if selected.\n\n* [Fix-3549] [Server][sqlTask]The alias column in the query SQL does not take effect\n\n* [Fix-3549] [Server][sqlTask]The alias column in the query SQL does not take effect\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\nCo-authored-by: zhuangchong <zhuangchong8@163.com>\nCo-authored-by: JinyLeeChina <42576980+JinyLeeChina@users.noreply.github.com>\n\n* [Fix-3124][docker]Fix that can not build a docker image on windows (#3765)\n\n* [Fix-3549] [Server][sqlTask]The alias column in the query SQL does not take effect (#3786)\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* The batch delete function in the workflow definition and workflow instance pages cannot be canceled if selected.\n\n* [Fix-3549] [Server][sqlTask]The alias column in the query SQL does not take effect\n\n* [Fix-3549] [Server][sqlTask]The alias column in the query SQL does not take effect\n\n* [Fix-3549] [Server][sqlTask]The alias column in the query SQL does not take effect\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\nCo-authored-by: zhuangchong <zhuangchong8@163.com>\nCo-authored-by: JinyLeeChina <42576980+JinyLeeChina@users.noreply.github.com>\n\n* [Fix-3258][Security][Worker group manage] Connot get create time and update time. report DateTimeParseException (#3787)\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* [Fix-3616][Server] when worker akc/response master exception .  async retry\n\n* The batch delete function in the workflow definition and workflow instance pages cannot be canceled if selected.\n\n* [Fix-3549] [Server][sqlTask]The alias column in the query SQL does not take effect\n\n* [Fix-3549] [Server][sqlTask]The alias column in the query SQL does not take effect\n\n* [Fix-3549] [Server][sqlTask]The alias column in the query SQL does not take effect\n\n* [BugFixed] issue #3258 (#3265)\n\n* 'ExecutionStatus'\n\n* '3258'\n\n* Update WorkerGroupServiceTest.java\n\n* Delete UserState.java\n\n* Delete ResourceSyncService.java\n\n* Delete core-site.xml\n\n* Delete hdfs-site.xml\n\nCo-authored-by: dailidong <dailidong66@gmail.com>\nCo-authored-by: qiaozhanwei <qiaozhanwei@outlook.com>\n\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\nCo-authored-by: zhuangchong <zhuangchong8@163.com>\nCo-authored-by: JinyLeeChina <42576980+JinyLeeChina@users.noreply.github.com>\nCo-authored-by: dailidong <dailidong66@gmail.com>\n\n* [fixBug-3792][ui]Click on the sidebar to adapt the width of the pie chart on the project homepage\n\n* [Bug-3713][HadoopUtils] catfile method Stream not closed  (#3715)\n\n* fix bug\n\nDelete invalid field: executorcores\n\nModify verification prompt\n\n* fix bug\n\nDelete invalid field: executorcores\n\nModify verification prompt\n\n* fix bug\n\nDelete invalid field: executorcores\n\nModify verification prompt\n\n* dag  add close button\n\n* reset last version\n\n* reset last version\n\n* dag add close buttion\n\ndag add close buttion\n\n* update  CLICK_SAVE_WORKFLOW_BUTTON  xpath\n\n* updae CLICK_SAVE_WORKFLOW_BUTTON xpath\n\n* updae CLICK_SAVE_WORKFLOW_BUTTON xpath\n\n* updae CLICK_SAVE_WORKFLOW_BUTTON xpath\n\n* Update CreateWorkflowLocator.java\n\nmodify submit workflow button\n\n* Update CreateWorkflowLocator.java\n\n* Update CreateWorkflowLocator.java\n\nmodify CLICK_ADD_BUTTON\n\n* Update CreateWorkflowLocator.java\n\ndelete print\n\n* Update CreateWorkflowLocator.java\n\n1\n\n* Update CreateWorkflowLocator.java\n\n1\n\n* Setting '-XX:+DisableExplicitGC ' causes netty memory leaks\n\nin addition\n\nupdate '- XX: largepagesizeinbytes = 128M' to '- XX: largepagesizeinbytes = 10M'\n\n* Update dag.vue\n\n* Update dag.vue\n\n* Update dag.vue\n\n* Update CreateWorkflowLocator.java\n\n* Revert \"Setting '-XX:+DisableExplicitGC ' causes netty memory leaks\"\n\nThis reverts commit 3a2cba7a\n\n* Setting '-XX:+DisableExplicitGC ' causes netty memory leaks\n\nin addition\n\nupdate '- XX: largepagesizeinbytes = 128M' to '- XX: largepagesizeinbytes = 10M'\n\n* Update dolphinscheduler-daemon.sh\n\n* catfile method Stream not closed\n\n* catfile method Stream not closed\n\nCo-authored-by: dailidong <dailidong66@gmail.com>\nCo-authored-by: xingchun-chen <55787491+xingchun-chen@users.noreply.github.com>\n\n* [Fix-#3713][common]Fix that catfile method Stream not closed\n\n* [Fix-#3713][common]Fix that catfile method Stream not closed (#3810)\n\n* [Bug-3713][HadoopUtils] catfile method Stream not closed  (#3715)\n\n* fix bug\n\nDelete invalid field: executorcores\n\nModify verification prompt\n\n* fix bug\n\nDelete invalid field: executorcores\n\nModify verification prompt\n\n* fix bug\n\nDelete invalid field: executorcores\n\nModify verification prompt\n\n* dag  add close button\n\n* reset last version\n\n* reset last version\n\n* dag add close buttion\n\ndag add close buttion\n\n* update  CLICK_SAVE_WORKFLOW_BUTTON  xpath\n\n* updae CLICK_SAVE_WORKFLOW_BUTTON xpath\n\n* updae CLICK_SAVE_WORKFLOW_BUTTON xpath\n\n* updae CLICK_SAVE_WORKFLOW_BUTTON xpath\n\n* Update CreateWorkflowLocator.java\n\nmodify submit workflow button\n\n* Update CreateWorkflowLocator.java\n\n* Update CreateWorkflowLocator.java\n\nmodify CLICK_ADD_BUTTON\n\n* Update CreateWorkflowLocator.java\n\ndelete print\n\n* Update CreateWorkflowLocator.java\n\n1\n\n* Update CreateWorkflowLocator.java\n\n1\n\n* Setting '-XX:+DisableExplicitGC ' causes netty memory leaks\n\nin addition\n\nupdate '- XX: largepagesizeinbytes = 128M' to '- XX: largepagesizeinbytes = 10M'\n\n* Update dag.vue\n\n* Update dag.vue\n\n* Update dag.vue\n\n* Update CreateWorkflowLocator.java\n\n* Revert \"Setting '-XX:+DisableExplicitGC ' causes netty memory leaks\"\n\nThis reverts commit 3a2cba7a\n\n* Setting '-XX:+DisableExplicitGC ' causes netty memory leaks\n\nin addition\n\nupdate '- XX: largepagesizeinbytes = 128M' to '- XX: largepagesizeinbytes = 10M'\n\n* Update dolphinscheduler-daemon.sh\n\n* catfile method Stream not closed\n\n* catfile method Stream not closed\n\nCo-authored-by: dailidong <dailidong66@gmail.com>\nCo-authored-by: xingchun-chen <55787491+xingchun-chen@users.noreply.github.com>\n\n* [Fix-#3713][common]Fix that catfile method Stream not closed\n\nCo-authored-by: BoYiZhang <39816903+BoYiZhang@users.noreply.github.com>\nCo-authored-by: dailidong <dailidong66@gmail.com>\nCo-authored-by: xingchun-chen <55787491+xingchun-chen@users.noreply.github.com>\n\n* [Fix-#3487][api?dao] cherry pick from dev to fix that create folder duplicate name under multithreading\n\n* [Hotfix-3131][api] Fix the new tenant already exists prompt (#3132)\n\n* Bugfix: Fix the new tenant already exists prompt\n\n* Feature: Add test cases\n\n* Update TenantServiceTest.java\n\nCo-authored-by: dailidong <dailidong66@gmail.com>\nCo-authored-by: qiaozhanwei <qiaozhanwei@outlook.com>\n\n* Set up JDK 11 for SonarCloud in github action. (#3052)\n\n* Set up JDK 11 for SonarCloud in github action.\n\n* Fix javadoc error with JDK 11.\n\n* Prevent Javadoc from stopping if it finds any html errors.\n\n* [fixBug-3621][ui]Select the batch checkbox to unfilter the instances in the executing state\n\n* add verify tenant name cannot contain special characters.\n\n* [fixBug-3840][ui]The tenant code only allows letters or a combination of letters and numbers\n\n* fix\n\n* fix\n\n* fix\n\n* [Fix-#3702][api] When re-upload the resource file but don't change the name or desc. it need replace the origin resource file. (#3862)\n\n* [Fix-#3702][api] When re-upload the resource file but don't change the name or desc. it will not replace the origin resource file.\n\n* [Fix-#3702][api] When re-upload the resource file but don't change the name or desc. it will not replace the origin resource file.\n\n* [fixbug-3621][ui]Workflow instance ready to stop and ready to suspend state prohibits checking\n\n* [fixbug-3887][ui]Fix missing English translation of re-upload files\n\n* add process define name verify. (#3879)\n\n* Revert \"[1.3.3-release][fix-3835][ui] When the tenantName contains \"<\".  the tenant drop-down list is blankadd verify tenant name cannot contain special characters.\"\n\n* revert pr 3872\n\n* [FIX-3617][Service]after subtask fault tolerance.  2 task instances are generated (#3830)\n\n* fix bug(#3617): after subtask fault tolerance.  2 task instances are generated.\n\n* delete unused code\n\n* update code smell\n\n* refactor sub work command process\n\n* add process service ut\n\n* add license header\n\n* fix some code smell\n\n* chang ut java8 to java11\n\n* update sonar to java11\n\n* copy ut config from dev\n\n* remove checkstyle\n\n* revert to 1.3.3\n\n* change proess service test to executor service\n\n* add process service test\n\n* add process service test\n\n* revert\n\n* revert\n\n* add comments\n\n* change dev to 1.3.3-release\n\n* revert\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* [Fix-#3487][sql] add dolphinscheduler_dml.sql under 1.3.3_schema (#3907)\n\n* [FIX-3836][1.3.3-release-API] process definition validation name interface prompt information error  (#3899)\n\n* fix bug : error message\n\n* fix code smell\n\n* fix code smell\n\n* [FIX_#3789][remote]cherry pick from dev to support netty heart beat\n\n* [FIX_#3789][remote]cherry pick from dev to support netty heart beat\n\n* [FIX_#3789][remote]cherry pick from dev to support netty heart beat (#3913)\n\n* [FIX_#3789][remote]cherry pick from dev to support netty heart beat\n\n* [FIX_#3789][remote]cherry pick from dev to support netty heart beat\n\nCo-authored-by: Kirs <acm_master@163.com>\n\n* Repair check box cannot be canceled\n\n* [fix-3843][api] When update workflow definition. if name already exists.  the prompt is not friendly\n\n* [fix-3843][api] When update workflow definition. if name already exists.  the prompt is not friendly\n\n* [fix-#3843][api]When update workflow definition. if name already exists.  the prompt is not friendly (#3918)\n\n* [FIX_#3789][remote]cherry pick from dev to support netty heart beat\n\n* [FIX_#3789][remote]cherry pick from dev to support netty heart beat\n\n* [fix-3843][api] When update workflow definition. if name already exists.  the prompt is not friendly\n\n* [fix-3843][api] When update workflow definition. if name already exists.  the prompt is not friendly\n\nCo-authored-by: Kirs <acm_master@163.com>\n\n* [Fix-#3487][sql] update uc_dolphin_T_t_ds_resources_un\n\n* Workflow definition name re-modified and added check\n\n* [fix-#3843][api]When update workflow definition. if name already exists.  the prompt is not friendly.\n\n* update code.\n\n* [#3931][ui]Field name optimization for spark.  flink.  and mr\n\n* change version from 1.3.2-SNAPSHOT to 1.3.3-SNAPSHOT (#3934)\n\n* [maven-release-plugin] prepare release 1.3.3\n\n* [maven-release-plugin] prepare for next development iteration\n\n* [ambari-plugin]change version 1.3.2 to 1.3.3 (#3935)\n\n* fix bug:3615 After the task is executed successfully.  but the next task has not been submitted.  stop the master\n\n* [fixBug-3964][ui]Switch back and forth over timeout alarm.  the selected value is empty\n\n* solve too many files.  close logClientService (#3971)\n\n* fix #3966 sub process doesnot send alert mail after process instance ending. (#3972)\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* [Fix-#3618][server] resolve task executed finished but not release the file handle (#3975)\n\n* [Fix-#3618][server] resolve task executed finished but not release the file handle\n\n* [Fix-#3618][server] resolve task executed finished but not release the file handle\n\n* [Fix-#3958][api] files should not be created successfully in the directory of the authorized file\n\n* [FIX-3966] The timeout warning does not take effect in sub_process (#3982)\n\n* fix #3966 sub process doesnot send alert mail after process instance ending.\n\n* fix bug 3964: sub_process The timeout warning does not take effect\nadd timeout warning for sub_process/dependent task.\n\n* fix code smell\n\n* fix code smell\n\n* fix code smell\n\n* update worker group inherit from parent\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* fix import dolphinscheduler_mysql.sql insert admin user data\n\n* [FIX-3929] condition task would post wrong tasks when failover. (#3999)\n\n* fix #3966 sub process doesnot send alert mail after process instance ending.\n\n* fix bug 3964: sub_process The timeout warning does not take effect\nadd timeout warning for sub_process/dependent task.\n\n* fix code smell\n\n* fix code smell\n\n* fix code smell\n\n* update worker group inherit from parent\n\n* remove stdout in logback configuration\n\n* fix bug #3929 condition task would post error when failover.\n\n* remove unused test\n\n* add comments\n\n* add skip node judge\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* [FIX-3929]  because of no lock.  start up failover would dispatch two same tasks. (#4004)\n\n* fix #3966 sub process doesnot send alert mail after process instance ending.\n\n* fix bug 3964: sub_process The timeout warning does not take effect\nadd timeout warning for sub_process/dependent task.\n\n* fix code smell\n\n* fix code smell\n\n* fix code smell\n\n* update worker group inherit from parent\n\n* remove stdout in logback configuration\n\n* fix bug #3929 condition task would post error when failover.\n\n* remove unused test\n\n* add comments\n\n* add skip node judge\n\n* fix bug 3929: because of no lock.  start up failover would dispatch two same tasks.\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* revert pom version to 1.3.3-release\n\n* [maven-release-plugin] prepare release 1.3.3\n\n* [maven-release-plugin] prepare for next development iteration\n\n* [release]revert pom version to 1.3.3-release\n\n* fix bug 4010: remove failed condition tasks from error-task-list. (#4011)\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* [maven-release-plugin] prepare release 1.3.3\n\n* [maven-release-plugin] prepare for next development iteration\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* refactor code style\n\n* refactor code style\n\n* refactor code style\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* refactor ut test\n\n* refactor ut test\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* refactor ut\n\n* merge from 1.3.3-release\n\n* refactor ut\n\n* refactor ut\n\n* refactor\n\n* refactor\n\n* refactor code style\n\n* refactor code style\n\n* refactor code style\n\n* refactor code style\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* merge from 1.3.3-release\n\n* refactor code style\n\nCo-authored-by: break60 <790061044@qq.com>\nCo-authored-by: wuchunfu <319355703@qq.com>\nCo-authored-by: lgcareer <18610854716@163.com>\nCo-authored-by: xingchun-chen <55787491+xingchun-chen@users.noreply.github.com>\nCo-authored-by: lenboo <baoliang@analysys.com.cn>\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\nCo-authored-by: Yelli <amarantine@my.com>\nCo-authored-by: Eights-Li <yelli.hl@gmail.com>\nCo-authored-by: JinyLeeChina <42576980+JinyLeeChina@users.noreply.github.com>\nCo-authored-by: dailidong <dailidong66@gmail.com>\nCo-authored-by: qiaozhanwei <qiaozhanwei@outlook.com>\nCo-authored-by: XiaotaoYi <v-xiayi@hotmail.com>\nCo-authored-by: Yichao Yang <1048262223@qq.com>\nCo-authored-by: zhuangchong <zhuangchong8@163.com>\nCo-authored-by: BoYiZhang <39816903+BoYiZhang@users.noreply.github.com>\nCo-authored-by: muzhongjiang <mu_zhongjiang@163.com>\nCo-authored-by: Jave-Chen <baicai.chen@gmail.com>\nCo-authored-by: zhuangchong <zhuangchong6@163.com>\nCo-authored-by: zhuangchong <37063904+zhuangchong@users.noreply.github.com>\nCo-authored-by: Kirs <acm_master@163.com>\nCo-authored-by: lgcareer <lgcareer@apache.org>\nCo-authored-by: wulingqi <wulingqi@baijiahulian.com>\n\n* Revert \"[Draft][Merge][133-dev]133 merge dev (#4031)\" (#4057)\n\nThis reverts commit ad2d9f99d01f3baef8641e0a7e741c08a39f1f24.\n\n* [Fix][API] Condition task null pointer exception (#4056)\n\n* add ProcessUtils UT\n\n* modify ProcessUtils & ProcessUtilsTest\n\n* Enhance user experience.  add close button.  return to the previous page (#4006)\n\nCo-authored-by: zhanglong <zhanglong@ysstech.com>\n\n* [FIX_BUG][server-test] dismiss of server warm-up time in RoundRobinSelectorTest (#4067)\n\n* [Fix][api] Fix build parameter error of sqlserver when create. (#4015)\n\n* [fix-#3962][api] Avoid ClassCastException for LoggerService.queryLog().\n\n* [Fix][api] Fix build parameter error of sqlserver when create.\n\n* [Feature-3985][Datax] Datax supports setting up running memory (#3986)\n\n* Datax supports setting up running memory\n\n* Datax supports setting up running memory\n\n* Datax supports setting up running memory\n\n* When running a task.  the resource file is lost.  which results in an error\n\n* add unit test\n\n* add unit test\n\n* add unit test\n\n* add test unit\n\n* add test unit\n\n* add test unit\n\n* fix code smell\n\n* add test unit\n\n* add test unit\n\n* [Improvement-3767][api] Task instance supports query by process instance name (#3825)\n\n* Task instance supports query by process instance name.\n\n* add test code checkstyle.\n\n* add test param.\n\n* resolve the sonar duplication check.\n\n* solve logger single-line string exceeds 200 characters.\n\n* resolve the sonar check.\n\n* Resolve code conflicts.\n\nCo-authored-by: zhuangchong <zhuangchong8@163.com>\n\n* deal with magic value\n\n* [Feature-4050][server] Spark task support udv inject (#4061)\n\n* #4050 spark task support udv inject\n\n* modify spark task UT\n\n* modify sparkTaskExecutionCtx\n\n* add exp for spark task get main jar method\n\n* deal with magic value\n\n* [Improvement-3471][common] JSONUtils.toMap It is not necessary to check whether the JSON method is empty again. #3471 (#3481)\n\n* JSONUtils.toMap call improvement.\n\n* [Fix-4054][Api] Fix The last week of the month for adding/editing timing.  preview and save timing will report an error\n\n* ???????????????\n\n* using OSUtils.execCmd when kill yarn app\n\n* ???????????????(??checkstyle)\n\n* ???????????????(??checkstyle)\n\n* [FIX-#4083][server]fix taskInstance state change error\nConcurrent processing of ack message and result message causes the execution sequence to be wrong\n\n# this close # 4083\n\n* code style\n\n* fix replaceNRTtoUnderline NullPointerException #4098 (#4100)\n\n* fix replaceNRTtoUnderline NullPointerException\n\n* add  unit Test\n\n* add taskResponseTest\n\n* add taskResponseTest\n\n* code smell\n\n* Time is too small and the task is not finished\n\n* Time is too small and the task is not finished\n\n* [FIX-4034][server] fix sqoop import fail (#4036)\n\n* fix #4043.  sqoop import query fail\n\n* fix #4043.  sqoop task hard code & code style\n\n* add license for SqoopConstants\n\n* add private constructor for SqoopConstants\n\n* fixed sqoop mysql pwd have special character\n\n* fix checkstyle\n\n* fix sqoop task log\n\n* remove unused constants\n\n* Time is too small and the task is not finished\n\n* Time is too small and the task is not finished\n\n* test\n\n* remove assert\n\n* test\n\n* test\n\n* fix task instance status judgment error\n\n* fix: security page disappear delay problem when force refresh under GENERAL_USER\n\n* improvement: resovle download url with resolveURL to prevent change of apiPrefix\n\n* fix sqoop task jdbc string contains special char (#4105)\n\n* [Bug][Common] read file garbled (#3479)\n\n* fix bug : Random code problem\n\nCo-authored-by: zhanglong <zhanglong@ysstech.com>\n\n* [Improvement-3933][db operation] Improve the performance of sql query (#3940)\n\n* optimize select * case\n\n* emove redundancy\n\n* bug fixed\n\n* Update en_US.js\n\n* Update startup.sh\n\n* optimize\n\n* optimize code\n\n* optimize\n\n* bug fixed\n\n* add ut\n\n* bug fixed\n\n* bug fixed\n\n* bug fixed\n\n* bug fixed\n\n* Delete WorkFlowLineageMapper.xml\n\n* Delete createTenement.vue\n\n* recove wrongly deleted file\n\n* Update WorkFlowLineageMapper.xml\n\n* Update createTenement.vue\n\n* [Feature][API]enable response resources gzip compression (#4121)\n\n* enable response compression\n\n* add server.compression.mime-types with default value explicitly\n\n* [Improvement][API] ignore noNodeException when get worker groups (#4120)\n\n* ignore noNodeException when get worker groups\n\n* add ut\n\n* [Improvement][Code style] FIX SPELL WAITTING TO WAITING .  etc. (#4118)\n\n* FIX SPELL\n\n* FIX SPELL AND  Optimizing code conventions\n\n* add ut  cannot construct process instance.  return null;\n\n* add ut testExportProcessMetaData\n\n* add ut testExportProcessMetaData\n\n* add ut testImportProcessSchedule\n\n* add ut MasterExecThreadTest\n\n* add ut MasterExecThreadTest\n\n* add ut testSubProcessViewTree\n\n* add ut testComplementWithStartNodeList\n\n* add ut testRecurseFindSubProcessId\n\n* add ut testRecurseFindSubProcessId\n\n* add ut testRecurseFindSubProcessId\n\n* [FIX#4033] $[] conflicts with mysql keywords (#4111)\n\n* [FIX#4033] $[] conflicts with mysql keywords\nWe currently only use this symbol for dates.  so I filtered out the number type.\nthis close #4033\n\n* test\n\n* fix error\n\n* split sqoop import hive database and table (#4141)\n\n* upgrade quartz version to 2.3.0\n\n* add HikariCP-java6. c3p0. mchange-commons-java license\n\n* upgrade jackson version to 2.9.10\n\n* remove c3p0. mchange-commons-java license\n\n* update Check code style\n\n* update  code style\n\n* Update pom.xml\n\n* Update pom.xml\n\n* Update LICENSE\n\nnot need to add HikariCP-java6\n\n* Delete LICENSE-HikariCP-java6.txt\n\n* Update known-dependencies.txt\n\n* Update TaskInstanceMapper.xml\n\noptimize page of [TaskInstance] load data slow\n\n* [FIX-PR-4097][server-master]task ack miss (#4189)\n\nWhen the message of successful execution arrives earlier than\nthe message of ack. \nthe message of ack will be discarded. \nresulting in some information missing\n\n* fix bug #4125 (#4127)\n\n* fix bug #4125\n\n* code style!\n\n* code style.\n\nCo-authored-by: chengp <chengp@chengp.net>\n\n* [FIX-4190][DAO] When the amount of json data is large.  the process list page display slowly. (#4201)\n\n* fix 4190: When the amount of json data is large.  process list page display slowly\n\n* fix 4190: When the amount of json data is large.  process list page display slowly\n\n* fix 4190: When the amount of json data is large.  process list page display slowly\n\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\n\n* [Fix-3457][flink] fix flink args build problem (#4166)\n\n* [Fix][Flink] fix flink args build problem\n\n* [Fix][Flink] fix FlinkArgsUtilsTest\n\n* [Improvement][UI] hide version and cluster input when deployMode is local\n\n* [common]del windows file( not support windows ) (#4204)\n\n* del support win\n\n* del support win\n\n* [Feature-4138][Master] dispatch workgroup error add sleep time (#4139)\n\n* When there are tasks with assignment failure and the number of tasks in the current task queue is less than 10.  sleep for 1 second\n\n* When there are tasks with assignment failure and the number of tasks in the current task queue is less than 10.  sleep for 1 second\n\n* fix code smell & code style\n\n* fix code smell & code style\n\nCo-authored-by: zhanglong <zhanglong@ysstech.com>\n\n* [FIX-#4172][server-worker] kill task NPE (#4182)\n\n* [FIX-#4172][server-worker] kill task NPE\n\nThe cache task will be sent when the Process is generated. Before that.  if a kill task appears.  then NPE will appear\nModification method: write into the cache when the task is received.  and mark it as preData\nIf the task is killed before the Process is generated.  delete the cache directly at this time\nIt will be judged before the process is generated. If the task has been killed.  it will not be executed.\nAfter the new process is created.  write it into the cache.  and judge again.  if kill.  then kill the process.\n\nthis closes #4172\n\n* Delete the commented out code\nAdd spring beans\n\n* code smell\n\n* add test\n\n* add test\n\n* fix error\n\n* test\n\n* test\n\n* revert\n\n* fix error\n\n* [Feature-3878]Replace the page with element-ui (#4065)\n\n* [Feature-3878]Introduce elment-ui and replace the security center module page with elment-ui\n\n* Change node version\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* Replace the page with element-ui\n\n* Replace user management with elment-ui\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* Repair the last Sunday of each month\n\n* support auto eslint for .js.  .vue file on save\n\n* update .eslintrc.yml and license check exclude .eslintignore\n\n* fix eslint: fix syntax by npm run lint automatically\n\n* fix eslint: fatal syntax errors\n\n* fix eslint: expected '!==' but instead saw '!='.  expected '===' but instead saw '=='\n\n* fix eslint: Unexpected side effect in 'cacheParams' computed property\n\n* fix eslint: assigned a value but never used\n\n* fix eslint: component has been registered but not used\n\n* fix eslint: unexpected mutation of prop\n\n* fix bug: start from the setting nodes with NODE_PRE would be NPE. (#4219)\n\n* deleted invalid code as assigned in issue 4215 (#4221)\n\ndeleted the code at following two places:\norg.apache.dolphinscheduler.service.process.ProcessService#checkTaskExistsInTaskQueue\norg.apache.dolphinscheduler.service.process.ProcessService#taskZkInfo\n\n* [FIX-#3177]Task time parameter parsing error (#4224)\n\n* [FIX-#3177]Task time parameter parsing error\n\nrerun schedule time error\n\nthis closes #3177\n\n* [FIX-#3177]Task time parameter parsing error\n\nrerun schedule time error\n\nthis closes #3177\n\n* fix sql error (#4227)\n\n* [FIX-3177]Task time parameter parsing error (#4228)\n\n* [FIX-3177]Task time parameter parsing error\nwhen system.datetime !=null $[datetime] = system.datetime\nelse $[datetime] = current time\n\n* remove unused import\n\n* fix date_convert null\n\n* fix time cover\n\n* fix time cover\n\n* reformat\n\n* add ut\n\n* [Fix][UI]: fix re-login problem in new tab and state synchronization problem in multiple tabs (#4162)\n\n* fix(ui): re-login problem in new tab\n\n* refresh page in new tab automatically\n\n* support to reload router view in lightweight\n\n* optimize visibility code\n\n* [Improvement][UI] Add no-var rule for eslint and add 'npm run lint:fix' command (#4225)\n\nAdd no-var rule for eslint.  and fix related files\nAdd npm run lint:fix command.  which distinguished from the default command npm run lint\nThe behavior of command npm run lint and command npm run lint:fix should be distinguished\nThe first command is used to lint only.  and the second one is used to lint and fix problems automatically\n\n* [FIX][UI ]  security user state  tenantCode User Type Display abnormal (#4255)\n\n* fix user state error\n\n* fix userType  error\n\n* fix tenantCode  error\n\n* [Fix-4222][Master]Add the priority queue to ensure that tasks are submitted according to priority. (#4250)\n\n* [Fix-4222][Master]Add the priority queue to ensure that tasks are submitted according to priority.\n\n* [Fix-4222][Master]Add the priority queue to ensure that tasks are submitted according to priority.\n\n* [Fix-4222][Master]Remove useless import\n\n* [Fix-4222][Master]Reformat code style\n\n* [Fix-4222][Master]Reformat code style\n\n* [Fix-4222][Master]Reformat code style\n\n* [Fix-4222][Master]add PeerTaskInstancePriorityQueueTest\n\n* [Fix-4222][Master]Fix code smell\n\n* [Fix-4222][Master]Reformat code style\n\n* [Fix-4222][Master]Fix code smell\n\nCo-authored-by: xingchun-chen <55787491+xingchun-chen@users.noreply.github.com>\n\n* update bug template (#4260)\n\n* [Improvement-4069][server] When the tenant does not exist.  the task execution should throw an exception (#4108)\n\n* when  the tenant does not exist.  the task execution should throw an exception\n\n* remote method createWorkDirAndUserIfAbsent\n\n* set the task status failed when the tenant code does not exist.\n\n* add taskLog.\n\n* update check os user exists\n\n* update TaskExecuteThreadTest test method.\n\n* solving sonar fail.\n\n* remove AbstractTask.getCurTaskParamsClass()and replace with TaskParametersUtils.getParameters() (#4262)\n\n* remove getCurTaskParamsClass() in AbstractTask.java and replace it with TaskParametersUtils.getParameters()\n\n* remove unused imports in AbstractTask.java\n\n* reformat\n\n* [Fix-4271][server] Fix IOException or NoSuchFileException in logger server (#4272)\n\n* fix version funcation delete. (#4265)\n\n* [improvement][config] Update datasource.properties?add mysql meta data template (#4266)\n\n* Update datasource.properties\n\n[??]???mysql????\n\n* Update datasource.properties\n\nCo-authored-by: dailidong <dailidong66@gmail.com>\n\n* fix taskInstance submitTime is empty. (#4274)\n\n* [Improvement-3878]Tenant list delete user name (#4278)\n\n* [Fix-4268] Fix NumberFormatException when visiting a doc.html or swagger-ui.html (#4269)\n\n* [Fix-4268] Fix NumberFormatException when visiting a doc.html or swagger-ui.html\n\n* Fix checkstyle error\n\n* Update swagger-models in known-dependencies.txt\n\n* [Improvement-3878][ui]Fix the list style (#4280)\n\n* [Improvement-3878]Tenant list delete user name\n\n* [Improvement-3878][ui]Fix the list style\n\n* [FIX] [UI] fix create project cancel button invalid (#4282)\n\n* fix create project cancel button invalid\n\n* [Improvement] Refactor code to support distributed tracing (#4270)\n\n* Refactor code to support tracing\n\n* Extension network protocol.  support context and version\n* Extension master asynchronous queue support context\n* Extract scan task method from MasterSchedulerService for tracing\n\n* fix\n\n* fix\n\n* add test case\n\n* fix\n\n* fix\n\nCo-authored-by: hailin0 <hailin0@yeah.net>\n\n* [Improvement] Add Flink job name (#4285)\n\n* [Improvement] Add Flink job name\n\n* fix typo\n\n* [Improvement][ui]List vacancy optimization and icon icon repair (#4286)\n\n* [Improvement][ui] List vacancy optimization and icon icon repair\n\n* [FEATURE-736] integrate ldap authentication (#3743)\n\n* [FEATURE-736] integrate ldap authentication\n\n* add ldap authentication type\n* refactor authentication with ldap and password\n* add  createUser for ldap in user service\n* remove duplicate password authenticator\n\n* [Fix-4289][*] Flink name with disappeared and unescaped problem (#4290)\n\n* fix flink name not display in process definition editor\n\n* fix flink name not escape problem\n\n* simplify escape method\n\n* fix database is the mysql DB keyword. (#4295)\n\n* fix the token management list does not display the user name. (#4302)\n\n* Dev imp server process utils (#4263)\n\n\n* Adds the comment on the WINDOWSATTERN\n\nCo-authored-by: Kirs <acm_master@163.com>\nCo-authored-by: 0002939 <licongyang@mininglamp.com>\n\n* fix version close function does not take effect. (#4307)\n\n* fix user management authorization operation exceptions do not prompt exception information. (#4292)\n\n* [Fix][UI] Fix ui style problem and refactor form style (#4329)\n\n* rename from-model to form-model\n\n* [UI] remove duplicated css style code\n\n* [UI] refactor css style of form model\n\n* fix form model overflow problem in ie\n\n* Align each item one by one in locale\n\n* fix el-dialog width is too wide\n\n* fix locale\n\n* [Improvement][UI] Improve script box and dialog css style (#4331)\n\n* [Fix-4335][UI] Fix IE 9-11 not supported\n\n* [FIx-4338][UI] Fix invalid date problem in IE\n\n* [Improvement] Use environment variable $DOLPHINSCHEDULE_OPTS as daemon startup arguments (#4341)\n\nCo-authored-by: hailin0 <hailin0@yeah.net>\n\n* [Fix][common] only two yarns can be selected(#4314) (#4344)\n\n* Handling conflicts manually\n\n* code style\n\n* ut skip ui\n\n* fix ut error\n\n* fix ut error\n\n* delete SchedulerController Unused field\n\n* delete SchedulerController Unused field\n\n* delete SchedulerController Unused field\n\n* ci skip ui\n\n* ignore AlertPluginManagerTest.java and DolphinPluginLoaderTest.java\n\n* fix ut error\n\n* fix ut error\n\n* test\n\n* code style\n\n* replace ui\n\n* replace ui\n\n* replace ui\n\n* replace ui\n\n* fix license\n\n* fix license\n\nCo-authored-by: ?? <62982788+597365581@users.noreply.github.com>\nCo-authored-by: zhuangchong <37063904+zhuangchong@users.noreply.github.com>\nCo-authored-by: spring-bu <37682426+spring-bu@users.noreply.github.com>\nCo-authored-by: dailidong <dailidong66@gmail.com>\nCo-authored-by: lgcareer <18610854716@163.com>\nCo-authored-by: BoYiZhang <39816903+BoYiZhang@users.noreply.github.com>\nCo-authored-by: xingchun-chen <55787491+xingchun-chen@users.noreply.github.com>\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\nCo-authored-by: BoYiZhang <zhangboyi_mx@163.com>\nCo-authored-by: zixi0825 <649790970@qq.com>\nCo-authored-by: sunchaohe <sunzhaohe@linklogis.com>\nCo-authored-by: break60 <790061044@qq.com>\nCo-authored-by: bao liang <29528966+lenboo@users.noreply.github.com>\nCo-authored-by: t1mon <178317391@qq.com>\nCo-authored-by: zhanglong <zhanglong@ysstech.com>\nCo-authored-by: ??? <sun.jifeng@outlook.com>\nCo-authored-by: wulingqi <wulingqi@baijiahulian.com>\nCo-authored-by: lgcareer <lgcareer@apache.org>\nCo-authored-by: IamMujuziMoses <49279842+IamMujuziMoses@users.noreply.github.com>\nCo-authored-by: huzekang <1040080742@qq.com>\nCo-authored-by: JinyLeeChina <42576980+JinyLeeChina@users.noreply.github.com>\nCo-authored-by: Eights-LI <yelli.eights@gmail.com>\nCo-authored-by: wuchunfu <319355703@qq.com>\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\nCo-authored-by: Yelli <amarantine@my.com>\nCo-authored-by: Eights-Li <yelli.hl@gmail.com>\nCo-authored-by: qiaozhanwei <qiaozhanwei@outlook.com>\nCo-authored-by: XiaotaoYi <v-xiayi@hotmail.com>\nCo-authored-by: Yichao Yang <1048262223@qq.com>\nCo-authored-by: zhuangchong <zhuangchong8@163.com>\nCo-authored-by: muzhongjiang <mu_zhongjiang@163.com>\nCo-authored-by: Jave-Chen <baicai.chen@gmail.com>\nCo-authored-by: zhuangchong <zhuangchong6@163.com>\nCo-authored-by: hailin0 <hailin0@yeah.net>\nCo-authored-by: yangquan <iyeeku@qq.com>\nCo-authored-by: liliang1991 <liliang_68@126.com>\nCo-authored-by: liang.li.c <liang.li.c@17zuoye.com>\nCo-authored-by: felix.wang <59079269+felix-thinkingdata@users.noreply.github.com>\nCo-authored-by: chengshiwen <chengshiwen0103@gmail.com>\nCo-authored-by: Yarlung <turingdojo@163.com>\nCo-authored-by: karlsun <karlsun@tencent.com>\nCo-authored-by: wangxj3 <857234426@qq.com>\nCo-authored-by: chengp <5058557@qq.com>\nCo-authored-by: chengp <chengp@chengp.net>\nCo-authored-by: Saksham Gupta <saksham1319@gmail.com>\nCo-authored-by: Tq <36755957+Tianqi-Dotes@users.noreply.github.com>\nCo-authored-by: Jatham <59549328+Jatham922@users.noreply.github.com>\nCo-authored-by: hailin0 <hailin0@foxmail.com>\nCo-authored-by: zh0122 <zh0122@gmail.com>\nCo-authored-by: geosmart <geosmart@hotmail.com>\nCo-authored-by: ??? <liby-1987@163.com>\nCo-authored-by: 0002939 <licongyang@mininglamp.com>\nCo-authored-by: kamisamak <1057372918@qq.com>\n\n* fix alert-spi error\ntodo sql script\n\n* add page query plugin instance\nadd plugin instance check name\n\n* add page query plugin instance\nadd plugin instance check name\n\n* add props field\n\n* ding talk some filed is not required\n\n* fix bug\n\n* fix error\n\n* revert\n\n* add name field provide to ui\n\n* fix send error\n\n* add ui\n\n* delete useless constant definitions\ncode style\n\n* code style\n\n* fix license head error\n\n* fix ut error\n\n* fix ut error\n\n* del unused jar\n\n* import alert-plugin\n\n* upgrade jboss-logging\n\n* upgrade jboss-logging\n\n* fix ut error\n\n* fix Vulnerabilities\n\n* fix Vulnerabilities\n\n* fix Vulnerabilities\n\n* code smell\n\n* fix Vulnerabilities\n\n* add  public constructors\n\n* fix  Vulnerabilities\n\n* resolve conflicts\n\nCo-authored-by: break60 <790061044@qq.com>\nCo-authored-by: gaojun2048 <32193458+gaojun2048@users.noreply.github.com>\nCo-authored-by: zhuangchong <zhuangchong6@163.com>\nCo-authored-by: dailidong <dailidong66@gmail.com>\nCo-authored-by: samz406 <samz406@foxmail.com>\nCo-authored-by: gaojun2048 <540957506@qq.com>\nCo-authored-by: zhuangchong <37063904+zhuangchong@users.noreply.github.com>\nCo-authored-by: Yichao Yang <1048262223@qq.com>\nCo-authored-by: ?? <62982788+597365581@users.noreply.github.com>\nCo-authored-by: spring-bu <37682426+spring-bu@users.noreply.github.com>\nCo-authored-by: lgcareer <18610854716@163.com>\nCo-authored-by: BoYiZhang <39816903+BoYiZhang@users.noreply.github.com>\nCo-authored-by: xingchun-chen <55787491+xingchun-chen@users.noreply.github.com>\nCo-authored-by: baoliang <baoliang@analysys.com.cn>\nCo-authored-by: BoYiZhang <zhangboyi_mx@163.com>\nCo-authored-by: zixi0825 <649790970@qq.com>\nCo-authored-by: sunchaohe <sunzhaohe@linklogis.com>\nCo-authored-by: bao liang <29528966+lenboo@users.noreply.github.com>\nCo-authored-by: t1mon <178317391@qq.com>\nCo-authored-by: zhanglong <zhanglong@ysstech.com>\nCo-authored-by: ??? <sun.jifeng@outlook.com>\nCo-authored-by: wulingqi <wulingqi@baijiahulian.com>\nCo-authored-by: lgcareer <lgcareer@apache.org>\nCo-authored-by: IamMujuziMoses <49279842+IamMujuziMoses@users.noreply.github.com>\nCo-authored-by: huzekang <1040080742@qq.com>\nCo-authored-by: JinyLeeChina <42576980+JinyLeeChina@users.noreply.github.com>\nCo-authored-by: Eights-LI <yelli.eights@gmail.com>\nCo-authored-by: wuchunfu <319355703@qq.com>\nCo-authored-by: qiaozhanwei <qiaozhanwei@analysys.com.cn>\nCo-authored-by: Yelli <amarantine@my.com>\nCo-authored-by: Eights-Li <yelli.hl@gmail.com>\nCo-authored-by: qiaozhanwei <qiaozhanwei@outlook.com>\nCo-authored-by: XiaotaoYi <v-xiayi@hotmail.com>\nCo-authored-by: zhuangchong <zhuangchong8@163.com>\nCo-authored-by: muzhongjiang <mu_zhongjiang@163.com>\nCo-authored-by: Jave-Chen <baicai.chen@gmail.com>\nCo-authored-by: hailin0 <hailin0@yeah.net>\nCo-authored-by: yangquan <iyeeku@qq.com>\nCo-authored-by: liliang1991 <liliang_68@126.com>\nCo-authored-by: liang.li.c <liang.li.c@17zuoye.com>\nCo-authored-by: felix.wang <59079269+felix-thinkingdata@users.noreply.github.com>\nCo-authored-by: chengshiwen <chengshiwen0103@gmail.com>\nCo-authored-by: Yarlung <turingdojo@163.com>\nCo-authored-by: karlsun <karlsun@tencent.com>\nCo-authored-by: wangxj3 <857234426@qq.com>\nCo-authored-by: chengp <5058557@qq.com>\nCo-authored-by: chengp <chengp@chengp.net>\nCo-authored-by: Saksham Gupta <saksham1319@gmail.com>\nCo-authored-by: Tq <36755957+Tianqi-Dotes@users.noreply.github.com>\nCo-authored-by: Jatham <59549328+Jatham922@users.noreply.github.com>\nCo-authored-by: hailin0 <hailin0@foxmail.com>\nCo-authored-by: zh0122 <zh0122@gmail.com>\nCo-authored-by: geosmart <geosmart@hotmail.com>\nCo-authored-by: ??? <liby-1987@163.com>\nCo-authored-by: 0002939 <licongyang@mininglamp.com>\nCo-authored-by: kamisamak <1057372918@qq.com>","date":"2021-01-22 11:01:46","modifiedFileCount":"56","status":"M","submitter":"Kirs"},{"authorTime":"2020-11-07 19:37:48","codes":[{"authorDate":"2021-01-22 17:35:02","commitOrder":19,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n            String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n            command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        setTaskCache(taskExecutionContext);\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n            taskExecutionContext.getProcessDefineId(),\n            taskExecutionContext.getProcessInstanceId(),\n            taskExecutionContext.getTaskInstanceId()));\n\n        taskExecutionContext.setHost(NetUtils.getHost() + \":\" + workerConfig.getListenPort());\n        taskExecutionContext.setStartTime(new Date());\n        taskExecutionContext.setLogPath(LogUtils.getTaskLogPath(taskExecutionContext));\n        taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirIfAbsent(execLocalPath);\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.of(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n            taskExecutionContextCacheManager.removeByTaskInstanceId(taskExecutionContext.getTaskInstanceId());\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n            new NettyRemoteChannel(channel, command.getOpaque()));\n\n        this.doAck(taskExecutionContext);\n\n        \r\n        workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger));\n    }\n","date":"2021-01-22 17:35:02","endLine":154,"groupId":"1091","id":37,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/e4/3a913e8c42820b58469ac8860d59b6c05b0d50.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n            String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n            command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        setTaskCache(taskExecutionContext);\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n            taskExecutionContext.getProcessDefineId(),\n            taskExecutionContext.getProcessInstanceId(),\n            taskExecutionContext.getTaskInstanceId()));\n\n        taskExecutionContext.setHost(NetUtils.getHost() + \":\" + workerConfig.getListenPort());\n        taskExecutionContext.setStartTime(new Date());\n        taskExecutionContext.setLogPath(LogUtils.getTaskLogPath(taskExecutionContext));\n        taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirIfAbsent(execLocalPath);\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.of(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n            taskExecutionContextCacheManager.removeByTaskInstanceId(taskExecutionContext.getTaskInstanceId());\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n            new NettyRemoteChannel(channel, command.getOpaque()));\n\n        this.doAck(taskExecutionContext);\n\n        \r\n        workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger, alertClientService));\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskExecuteProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":98,"status":"M"},{"authorDate":"2020-11-07 19:37:48","commitOrder":19,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","date":"2020-11-07 19:37:48","endLine":98,"groupId":"2209","id":38,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/21/108d1291f06cc9f363fe9ff727e794f916022b.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"N"}],"commitId":"ab95b16d211f9537760b37d624c69a5b5c828ced","commitMessage":"@@@Revert \"[Feature-#3049] Alert Plugin Design(merge alert_plugin_design to dev) (#4495)\" (#4535)\n\nThis reverts commit 0c8d08cb","date":"2021-01-22 17:35:02","modifiedFileCount":"56","status":"M","submitter":"Kirs"},{"authorTime":"2020-11-07 19:37:48","codes":[{"authorDate":"2021-01-22 19:41:46","commitOrder":20,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n            String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n            command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        setTaskCache(taskExecutionContext);\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n            taskExecutionContext.getProcessDefineId(),\n            taskExecutionContext.getProcessInstanceId(),\n            taskExecutionContext.getTaskInstanceId()));\n\n        taskExecutionContext.setHost(NetUtils.getHost() + \":\" + workerConfig.getListenPort());\n        taskExecutionContext.setStartTime(new Date());\n        taskExecutionContext.setLogPath(LogUtils.getTaskLogPath(taskExecutionContext));\n        taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirIfAbsent(execLocalPath);\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.of(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n            taskExecutionContextCacheManager.removeByTaskInstanceId(taskExecutionContext.getTaskInstanceId());\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n            new NettyRemoteChannel(channel, command.getOpaque()));\n\n        this.doAck(taskExecutionContext);\n\n        \r\n        workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger, alertClientService));\n    }\n","date":"2021-01-22 19:41:46","endLine":169,"groupId":"1091","id":39,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/d8/a6e2bfd860f612a87d58c795dcb9bc47ea92d3.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n            String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n            command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        setTaskCache(taskExecutionContext);\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n            taskExecutionContext.getProcessDefineId(),\n            taskExecutionContext.getProcessInstanceId(),\n            taskExecutionContext.getTaskInstanceId()));\n\n        taskExecutionContext.setHost(NetUtils.getHost() + \":\" + workerConfig.getListenPort());\n        taskExecutionContext.setStartTime(new Date());\n        taskExecutionContext.setLogPath(LogUtils.getTaskLogPath(taskExecutionContext));\n        taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirIfAbsent(execLocalPath);\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.of(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n            taskExecutionContextCacheManager.removeByTaskInstanceId(taskExecutionContext.getTaskInstanceId());\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n            new NettyRemoteChannel(channel, command.getOpaque()));\n\n        this.doAck(taskExecutionContext);\n\n        \r\n        workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger));\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskExecuteProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":113,"status":"M"},{"authorDate":"2020-11-07 19:37:48","commitOrder":20,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","date":"2020-11-07 19:37:48","endLine":98,"groupId":"2209","id":40,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/21/108d1291f06cc9f363fe9ff727e794f916022b.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"N"}],"commitId":"acee4e00ec97ee3b8602402e46843d83ec67d10d","commitMessage":"@@@Merge pull request #4537 from CalvinKris/alert_plugin_design\n\n[Feature-#3049] Alert Plugin Design(merge alert_plugin_design to dev","date":"2021-01-22 19:41:46","modifiedFileCount":"56","status":"M","submitter":"gaojun2048"},{"authorTime":"2020-11-07 19:37:48","codes":[{"authorDate":"2021-02-12 18:50:38","commitOrder":21,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n            String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n            command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        setTaskCache(taskExecutionContext);\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n            taskExecutionContext.getProcessDefineId(),\n            taskExecutionContext.getProcessInstanceId(),\n            taskExecutionContext.getTaskInstanceId()));\n\n        taskExecutionContext.setHost(NetUtils.getHost() + \":\" + workerConfig.getListenPort());\n        taskExecutionContext.setStartTime(new Date());\n        taskExecutionContext.setLogPath(LogUtils.getTaskLogPath(taskExecutionContext));\n        taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n        taskExecutionContext.setExecutePath(execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirIfAbsent(execLocalPath);\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.of(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n            taskExecutionContextCacheManager.removeByTaskInstanceId(taskExecutionContext.getTaskInstanceId());\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n            new NettyRemoteChannel(channel, command.getOpaque()));\n\n        this.doAck(taskExecutionContext);\n\n        \r\n        workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger, alertClientService));\n    }\n","date":"2021-02-12 18:50:38","endLine":170,"groupId":"0","id":41,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/18/971dd363c39d5ad534949d6579541ee51a3712.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n            String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n            command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        setTaskCache(taskExecutionContext);\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n            taskExecutionContext.getProcessDefineId(),\n            taskExecutionContext.getProcessInstanceId(),\n            taskExecutionContext.getTaskInstanceId()));\n\n        taskExecutionContext.setHost(NetUtils.getHost() + \":\" + workerConfig.getListenPort());\n        taskExecutionContext.setStartTime(new Date());\n        taskExecutionContext.setLogPath(LogUtils.getTaskLogPath(taskExecutionContext));\n        taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirIfAbsent(execLocalPath);\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.of(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n            taskExecutionContextCacheManager.removeByTaskInstanceId(taskExecutionContext.getTaskInstanceId());\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n            new NettyRemoteChannel(channel, command.getOpaque()));\n\n        this.doAck(taskExecutionContext);\n\n        \r\n        workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger, alertClientService));\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskExecuteProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":113,"status":"M"},{"authorDate":"2020-11-07 19:37:48","commitOrder":21,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","date":"2020-11-07 19:37:48","endLine":98,"groupId":"2209","id":42,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/21/108d1291f06cc9f363fe9ff727e794f916022b.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"N"}],"commitId":"7a6b905597d974d1c3a3154aa21ec9cbf61e519f","commitMessage":"@@@[Fix-#4716][mater. worker] The task execution path should be calculated by the worker.  not the master (#4717)\n\n* [fix][api. mater. worker] ??master ?????????worker????????\n\n* remove unused import","date":"2021-02-12 18:50:38","modifiedFileCount":"3","status":"M","submitter":"guohaozhang"},{"authorTime":"2020-11-07 19:37:48","codes":[{"authorDate":"2021-02-14 21:33:45","commitOrder":22,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n            String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n            command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        setTaskCache(taskExecutionContext);\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n            taskExecutionContext.getProcessDefineId(),\n            taskExecutionContext.getProcessInstanceId(),\n            taskExecutionContext.getTaskInstanceId()));\n\n        taskExecutionContext.setHost(NetUtils.getAddr(workerConfig.getListenPort()));\n        taskExecutionContext.setStartTime(new Date());\n        taskExecutionContext.setLogPath(LogUtils.getTaskLogPath(taskExecutionContext));\n        taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n        taskExecutionContext.setExecutePath(execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirIfAbsent(execLocalPath);\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.of(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n            taskExecutionContextCacheManager.removeByTaskInstanceId(taskExecutionContext.getTaskInstanceId());\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n            new NettyRemoteChannel(channel, command.getOpaque()));\n\n        this.doAck(taskExecutionContext);\n\n        \r\n        workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger, alertClientService));\n    }\n","date":"2021-02-14 21:33:45","endLine":170,"groupId":"0","id":43,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/fc/8b33a488a8a43f52fafc3c10cbcd3158cfa51a.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n            String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n            command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        setTaskCache(taskExecutionContext);\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n            taskExecutionContext.getProcessDefineId(),\n            taskExecutionContext.getProcessInstanceId(),\n            taskExecutionContext.getTaskInstanceId()));\n\n        taskExecutionContext.setHost(NetUtils.getHost() + \":\" + workerConfig.getListenPort());\n        taskExecutionContext.setStartTime(new Date());\n        taskExecutionContext.setLogPath(LogUtils.getTaskLogPath(taskExecutionContext));\n        taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n        taskExecutionContext.setExecutePath(execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirIfAbsent(execLocalPath);\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.of(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n            taskExecutionContextCacheManager.removeByTaskInstanceId(taskExecutionContext.getTaskInstanceId());\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n            new NettyRemoteChannel(channel, command.getOpaque()));\n\n        this.doAck(taskExecutionContext);\n\n        \r\n        workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger, alertClientService));\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskExecuteProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":113,"status":"M"},{"authorDate":"2020-11-07 19:37:48","commitOrder":22,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","date":"2020-11-07 19:37:48","endLine":98,"groupId":"2209","id":44,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/21/108d1291f06cc9f363fe9ff727e794f916022b.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"N"}],"commitId":"53598fdd18a31797d8c6ac796a9c49e537d6e4e9","commitMessage":"@@@[Fix-3298][K8s] Fix task log disappear after recreating or upgrading helm release (#4755)\n\n* [Improvement][K8s] Alter column host varchar(15) to varchar(135) for long host\n\n* [Improvement][K8s] Improve getHost and getAddr in NetUtils\n\n* [Improvement][K8s] Replace getHost with getAddr","date":"2021-02-14 21:33:45","modifiedFileCount":"14","status":"M","submitter":"Shiwen Cheng"},{"authorTime":"2020-11-07 19:37:48","codes":[{"authorDate":"2021-02-23 10:10:11","commitOrder":23,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n            String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n            command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        setTaskCache(taskExecutionContext);\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n            taskExecutionContext.getProcessDefineId(),\n            taskExecutionContext.getProcessInstanceId(),\n            taskExecutionContext.getTaskInstanceId()));\n\n        taskExecutionContext.setHost(NetUtils.getAddr(workerConfig.getListenPort()));\n        taskExecutionContext.setLogPath(LogUtils.getTaskLogPath(taskExecutionContext));\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n        taskExecutionContext.setExecutePath(execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirIfAbsent(execLocalPath);\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.of(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n            taskExecutionContextCacheManager.removeByTaskInstanceId(taskExecutionContext.getTaskInstanceId());\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n            new NettyRemoteChannel(channel, command.getOpaque()));\n\n        \r\n        long remainTime = DateUtils.getRemainTime(taskExecutionContext.getFirstSubmitTime(), taskExecutionContext.getDelayTime() * 60L);\n        if (remainTime > 0) {\n            logger.info(\"delay the execution of task instance {}, delay time: {} s\", taskExecutionContext.getTaskInstanceId(), remainTime);\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.DELAY_EXECUTION);\n            taskExecutionContext.setStartTime(null);\n        } else {\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n            taskExecutionContext.setStartTime(new Date());\n        }\n\n        this.doAck(taskExecutionContext);\n\n        \r\n        if (!workerManager.offer(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger, alertClientService))) {\n            logger.info(\"submit task to manager error, queue is full, queue size is {}\", workerManager.getQueueSize());\n        }\n    }\n","date":"2021-02-23 10:10:11","endLine":177,"groupId":"506","id":45,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/30/88080849104bcb87aff6d1aa65a8278d6aabe8.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n            String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n            command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        setTaskCache(taskExecutionContext);\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n            taskExecutionContext.getProcessDefineId(),\n            taskExecutionContext.getProcessInstanceId(),\n            taskExecutionContext.getTaskInstanceId()));\n\n        taskExecutionContext.setHost(NetUtils.getAddr(workerConfig.getListenPort()));\n        taskExecutionContext.setStartTime(new Date());\n        taskExecutionContext.setLogPath(LogUtils.getTaskLogPath(taskExecutionContext));\n        taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n        taskExecutionContext.setExecutePath(execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirIfAbsent(execLocalPath);\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.of(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n            taskExecutionContextCacheManager.removeByTaskInstanceId(taskExecutionContext.getTaskInstanceId());\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n            new NettyRemoteChannel(channel, command.getOpaque()));\n\n        this.doAck(taskExecutionContext);\n\n        \r\n        workerExecService.submit(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger, alertClientService));\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskExecuteProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":109,"status":"M"},{"authorDate":"2020-11-07 19:37:48","commitOrder":23,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","date":"2020-11-07 19:37:48","endLine":98,"groupId":"2209","id":46,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/21/108d1291f06cc9f363fe9ff727e794f916022b.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"N"}],"commitId":"ffcb1c22e16107e387ceb21dc5a0faaef0783ae7","commitMessage":"@@@[Improvement-#3735] Make task delayed execution more efficient (#4812)\n\n* [Improvement-3735] improve implementation of delay task execution\n\n* [Improvement][worker] delay task compatible with dev branch and fix test\n\n\nCo-authored-by: vanilla111 <1115690319@qq.com>","date":"2021-02-23 10:10:11","modifiedFileCount":"5","status":"M","submitter":"guohaozhang"},{"authorTime":"2020-11-07 19:37:48","codes":[{"authorDate":"2021-03-18 18:34:42","commitOrder":24,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n            String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n            command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        setTaskCache(taskExecutionContext);\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n            taskExecutionContext.getProcessDefineId(),\n            taskExecutionContext.getProcessInstanceId(),\n            taskExecutionContext.getTaskInstanceId()));\n\n        taskExecutionContext.setHost(NetUtils.getAddr(workerConfig.getListenPort()));\n        taskExecutionContext.setLogPath(LogUtils.getTaskLogPath(taskExecutionContext));\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n        taskExecutionContext.setExecutePath(execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirIfAbsent(execLocalPath);\n            if (workerConfig.getWorkerTenantAutoCreate()) {\n                OSUtils.createUserIfAbsent(taskExecutionContext.getTenantCode());\n            }\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.of(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n            taskExecutionContextCacheManager.removeByTaskInstanceId(taskExecutionContext.getTaskInstanceId());\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n            new NettyRemoteChannel(channel, command.getOpaque()));\n\n        \r\n        long remainTime = DateUtils.getRemainTime(taskExecutionContext.getFirstSubmitTime(), taskExecutionContext.getDelayTime() * 60L);\n        if (remainTime > 0) {\n            logger.info(\"delay the execution of task instance {}, delay time: {} s\", taskExecutionContext.getTaskInstanceId(), remainTime);\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.DELAY_EXECUTION);\n            taskExecutionContext.setStartTime(null);\n        } else {\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n            taskExecutionContext.setStartTime(new Date());\n        }\n\n        this.doAck(taskExecutionContext);\n\n        \r\n        if (!workerManager.offer(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger, alertClientService))) {\n            logger.info(\"submit task to manager error, queue is full, queue size is {}\", workerManager.getQueueSize());\n        }\n    }\n","date":"2021-03-18 18:34:42","endLine":181,"groupId":"1295","id":47,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/cf/d2c3fe2feb2ce668acccd6d7eb5865a7afa521.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n            String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n            command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        setTaskCache(taskExecutionContext);\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n            taskExecutionContext.getProcessDefineId(),\n            taskExecutionContext.getProcessInstanceId(),\n            taskExecutionContext.getTaskInstanceId()));\n\n        taskExecutionContext.setHost(NetUtils.getAddr(workerConfig.getListenPort()));\n        taskExecutionContext.setLogPath(LogUtils.getTaskLogPath(taskExecutionContext));\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance  local execute path : {} \", execLocalPath);\n        taskExecutionContext.setExecutePath(execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirIfAbsent(execLocalPath);\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.of(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n            taskExecutionContextCacheManager.removeByTaskInstanceId(taskExecutionContext.getTaskInstanceId());\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n            new NettyRemoteChannel(channel, command.getOpaque()));\n\n        \r\n        long remainTime = DateUtils.getRemainTime(taskExecutionContext.getFirstSubmitTime(), taskExecutionContext.getDelayTime() * 60L);\n        if (remainTime > 0) {\n            logger.info(\"delay the execution of task instance {}, delay time: {} s\", taskExecutionContext.getTaskInstanceId(), remainTime);\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.DELAY_EXECUTION);\n            taskExecutionContext.setStartTime(null);\n        } else {\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n            taskExecutionContext.setStartTime(new Date());\n        }\n\n        this.doAck(taskExecutionContext);\n\n        \r\n        if (!workerManager.offer(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger, alertClientService))) {\n            logger.info(\"submit task to manager error, queue is full, queue size is {}\", workerManager.getQueueSize());\n        }\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskExecuteProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":110,"status":"M"},{"authorDate":"2020-11-07 19:37:48","commitOrder":24,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","date":"2020-11-07 19:37:48","endLine":98,"groupId":"2209","id":48,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/21/108d1291f06cc9f363fe9ff727e794f916022b.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"N"}],"commitId":"f94cfc620dfd0c51010a49134a073e3848c0bd7e","commitMessage":"@@@[Feature][Worker] Add a configuration item to set whether the tenant is automatically created on Worker (#5007)\n\n","date":"2021-03-18 18:34:42","modifiedFileCount":"4","status":"M","submitter":"Shiwen Cheng"},{"authorTime":"2020-11-07 19:37:48","codes":[{"authorDate":"2021-03-29 11:07:39","commitOrder":25,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n            String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n            command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        setTaskCache(taskExecutionContext);\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n            taskExecutionContext.getProcessDefineId(),\n            taskExecutionContext.getProcessInstanceId(),\n            taskExecutionContext.getTaskInstanceId()));\n\n        taskExecutionContext.setHost(NetUtils.getAddr(workerConfig.getListenPort()));\n        taskExecutionContext.setLogPath(LogUtils.getTaskLogPath(taskExecutionContext));\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance local execute path : {}\", execLocalPath);\n        taskExecutionContext.setExecutePath(execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirIfAbsent(execLocalPath);\n            if (CommonUtils.isSudoEnable() && workerConfig.getWorkerTenantAutoCreate()) {\n                OSUtils.createUserIfAbsent(taskExecutionContext.getTenantCode());\n            }\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.of(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n            taskExecutionContextCacheManager.removeByTaskInstanceId(taskExecutionContext.getTaskInstanceId());\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n            new NettyRemoteChannel(channel, command.getOpaque()));\n\n        \r\n        long remainTime = DateUtils.getRemainTime(taskExecutionContext.getFirstSubmitTime(), taskExecutionContext.getDelayTime() * 60L);\n        if (remainTime > 0) {\n            logger.info(\"delay the execution of task instance {}, delay time: {} s\", taskExecutionContext.getTaskInstanceId(), remainTime);\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.DELAY_EXECUTION);\n            taskExecutionContext.setStartTime(null);\n        } else {\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n            taskExecutionContext.setStartTime(new Date());\n        }\n\n        this.doAck(taskExecutionContext);\n\n        \r\n        if (!workerManager.offer(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger, alertClientService))) {\n            logger.info(\"submit task to manager error, queue is full, queue size is {}\", workerManager.getQueueSize());\n        }\n    }\n","date":"2021-03-29 11:07:39","endLine":182,"groupId":"1295","id":49,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/00/f4956921565262dff6d2fa714dbdf47e46df79.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n            String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n            command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        setTaskCache(taskExecutionContext);\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n            taskExecutionContext.getProcessDefineId(),\n            taskExecutionContext.getProcessInstanceId(),\n            taskExecutionContext.getTaskInstanceId()));\n\n        taskExecutionContext.setHost(NetUtils.getAddr(workerConfig.getListenPort()));\n        taskExecutionContext.setLogPath(LogUtils.getTaskLogPath(taskExecutionContext));\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance local execute path : {}\", execLocalPath);\n        taskExecutionContext.setExecutePath(execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirIfAbsent(execLocalPath);\n            if (workerConfig.getWorkerTenantAutoCreate()) {\n                OSUtils.createUserIfAbsent(taskExecutionContext.getTenantCode());\n            }\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.of(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n            taskExecutionContextCacheManager.removeByTaskInstanceId(taskExecutionContext.getTaskInstanceId());\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n            new NettyRemoteChannel(channel, command.getOpaque()));\n\n        \r\n        long remainTime = DateUtils.getRemainTime(taskExecutionContext.getFirstSubmitTime(), taskExecutionContext.getDelayTime() * 60L);\n        if (remainTime > 0) {\n            logger.info(\"delay the execution of task instance {}, delay time: {} s\", taskExecutionContext.getTaskInstanceId(), remainTime);\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.DELAY_EXECUTION);\n            taskExecutionContext.setStartTime(null);\n        } else {\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n            taskExecutionContext.setStartTime(new Date());\n        }\n\n        this.doAck(taskExecutionContext);\n\n        \r\n        if (!workerManager.offer(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger, alertClientService))) {\n            logger.info(\"submit task to manager error, queue is full, queue size is {}\", workerManager.getQueueSize());\n        }\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskExecuteProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":111,"status":"M"},{"authorDate":"2020-11-07 19:37:48","commitOrder":25,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","date":"2020-11-07 19:37:48","endLine":98,"groupId":"2209","id":50,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/21/108d1291f06cc9f363fe9ff727e794f916022b.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"N"}],"commitId":"a6a1b94df4f5c4d22845fe99f2f778ba53d60e5c","commitMessage":"@@@[Feature-#5128]Support turning off sudo permissions (#5129)\n\n* [Feature-#5128]Support turning off sudo permissions\n\n* [Feature-#5128] without sudo permission do not create tenant user","date":"2021-03-29 11:07:39","modifiedFileCount":"5","status":"M","submitter":"guohaozhang"},{"authorTime":"2020-11-07 19:37:48","codes":[{"authorDate":"2021-05-12 18:44:30","commitOrder":26,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n            String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n            command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        setTaskCache(taskExecutionContext);\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n                taskExecutionContext.getProcessDefineCode(),\n                taskExecutionContext.getProcessDefineVersion(),\n                taskExecutionContext.getProcessInstanceId(),\n                taskExecutionContext.getTaskInstanceId()));\n\n        taskExecutionContext.setHost(NetUtils.getAddr(workerConfig.getListenPort()));\n        taskExecutionContext.setLogPath(LogUtils.getTaskLogPath(taskExecutionContext));\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance local execute path : {}\", execLocalPath);\n        taskExecutionContext.setExecutePath(execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirIfAbsent(execLocalPath);\n            if (CommonUtils.isSudoEnable() && workerConfig.getWorkerTenantAutoCreate()) {\n                OSUtils.createUserIfAbsent(taskExecutionContext.getTenantCode());\n            }\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.of(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n            taskExecutionContextCacheManager.removeByTaskInstanceId(taskExecutionContext.getTaskInstanceId());\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n            new NettyRemoteChannel(channel, command.getOpaque()));\n\n        \r\n        long remainTime = DateUtils.getRemainTime(taskExecutionContext.getFirstSubmitTime(), taskExecutionContext.getDelayTime() * 60L);\n        if (remainTime > 0) {\n            logger.info(\"delay the execution of task instance {}, delay time: {} s\", taskExecutionContext.getTaskInstanceId(), remainTime);\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.DELAY_EXECUTION);\n            taskExecutionContext.setStartTime(null);\n        } else {\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n            taskExecutionContext.setStartTime(new Date());\n        }\n\n        this.doAck(taskExecutionContext);\n\n        \r\n        if (!workerManager.offer(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger, alertClientService))) {\n            logger.info(\"submit task to manager error, queue is full, queue size is {}\", workerManager.getQueueSize());\n        }\n    }\n","date":"2021-05-12 18:44:30","endLine":183,"groupId":"1295","id":51,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/04/7dc6d9ed2b198dfe1986a452f62c00d541ae41.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n            String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n            command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        setTaskCache(taskExecutionContext);\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n            taskExecutionContext.getProcessDefineId(),\n            taskExecutionContext.getProcessInstanceId(),\n            taskExecutionContext.getTaskInstanceId()));\n\n        taskExecutionContext.setHost(NetUtils.getAddr(workerConfig.getListenPort()));\n        taskExecutionContext.setLogPath(LogUtils.getTaskLogPath(taskExecutionContext));\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance local execute path : {}\", execLocalPath);\n        taskExecutionContext.setExecutePath(execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirIfAbsent(execLocalPath);\n            if (CommonUtils.isSudoEnable() && workerConfig.getWorkerTenantAutoCreate()) {\n                OSUtils.createUserIfAbsent(taskExecutionContext.getTenantCode());\n            }\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.of(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n            taskExecutionContextCacheManager.removeByTaskInstanceId(taskExecutionContext.getTaskInstanceId());\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n            new NettyRemoteChannel(channel, command.getOpaque()));\n\n        \r\n        long remainTime = DateUtils.getRemainTime(taskExecutionContext.getFirstSubmitTime(), taskExecutionContext.getDelayTime() * 60L);\n        if (remainTime > 0) {\n            logger.info(\"delay the execution of task instance {}, delay time: {} s\", taskExecutionContext.getTaskInstanceId(), remainTime);\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.DELAY_EXECUTION);\n            taskExecutionContext.setStartTime(null);\n        } else {\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n            taskExecutionContext.setStartTime(new Date());\n        }\n\n        this.doAck(taskExecutionContext);\n\n        \r\n        if (!workerManager.offer(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger, alertClientService))) {\n            logger.info(\"submit task to manager error, queue is full, queue size is {}\", workerManager.getQueueSize());\n        }\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskExecuteProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":111,"status":"M"},{"authorDate":"2020-11-07 19:37:48","commitOrder":26,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","date":"2020-11-07 19:37:48","endLine":98,"groupId":"2209","id":52,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/21/108d1291f06cc9f363fe9ff727e794f916022b.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand,result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"N"}],"commitId":"a3e5dfc146e2ca72e75ee5b270241cea5bd7a478","commitMessage":"@@@Merge pull request #5390 from apache/json_split\n\n[Feature-4417] Process definition json split","date":"2021-05-12 18:44:30","modifiedFileCount":"113","status":"M","submitter":"Kirs"},{"authorTime":"2021-09-08 20:07:54","codes":[{"authorDate":"2021-09-08 20:07:54","commitOrder":27,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n                String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n                command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        setTaskCache(taskExecutionContext);\n        \r\n\n        taskExecutionContext.setHost(NetUtils.getAddr(workerConfig.getListenPort()));\n        taskExecutionContext.setLogPath(LogUtils.getTaskLogPath(taskExecutionContext));\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance local execute path : {}\", execLocalPath);\n        taskExecutionContext.setExecutePath(execLocalPath);\n\n        try {\n            FileUtils.createWorkDirIfAbsent(execLocalPath);\n            if (CommonUtils.isSudoEnable() && workerConfig.getWorkerTenantAutoCreate()) {\n                OSUtils.createUserIfAbsent(taskExecutionContext.getTenantCode());\n            }\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.of(logger), errorLog, ex);\n            TaskExecutionContextCacheManager.removeByTaskInstanceId(taskExecutionContext.getTaskInstanceId());\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        \r\n        long remainTime = DateUtils.getRemainTime(taskExecutionContext.getFirstSubmitTime(), taskExecutionContext.getDelayTime() * 60L);\n        if (remainTime > 0) {\n            logger.info(\"delay the execution of task instance {}, delay time: {} s\", taskExecutionContext.getTaskInstanceId(), remainTime);\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.DELAY_EXECUTION);\n            taskExecutionContext.setStartTime(null);\n        } else {\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n            taskExecutionContext.setStartTime(new Date());\n        }\n\n        this.doAck(taskExecutionContext);\n\n        \r\n        if (!workerManager.offer(new TaskExecuteThread(taskExecutionContext, taskCallbackService, alertClientService, taskPluginManager))) {\n            logger.info(\"submit task to manager error, queue is full, queue size is {}\", workerManager.getQueueSize());\n        }\n    }\n","date":"2021-09-08 20:07:54","endLine":176,"groupId":"1095","id":53,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/aa/751063beb4c74fcd3f0d5272ae5bafbd5583f8.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_EXECUTE_REQUEST == command.getType(),\n            String.format(\"invalid command type : %s\", command.getType()));\n\n        TaskExecuteRequestCommand taskRequestCommand = JSONUtils.parseObject(\n            command.getBody(), TaskExecuteRequestCommand.class);\n\n        logger.info(\"received command : {}\", taskRequestCommand);\n\n        if (taskRequestCommand == null) {\n            logger.error(\"task execute request command is null\");\n            return;\n        }\n\n        String contextJson = taskRequestCommand.getTaskExecutionContext();\n        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(contextJson, TaskExecutionContext.class);\n\n        if (taskExecutionContext == null) {\n            logger.error(\"task execution context is null\");\n            return;\n        }\n\n        setTaskCache(taskExecutionContext);\n        \r\n        Logger taskLogger = LoggerFactory.getLogger(LoggerUtils.buildTaskId(LoggerUtils.TASK_LOGGER_INFO_PREFIX,\n                taskExecutionContext.getProcessDefineCode(),\n                taskExecutionContext.getProcessDefineVersion(),\n                taskExecutionContext.getProcessInstanceId(),\n                taskExecutionContext.getTaskInstanceId()));\n\n        taskExecutionContext.setHost(NetUtils.getAddr(workerConfig.getListenPort()));\n        taskExecutionContext.setLogPath(LogUtils.getTaskLogPath(taskExecutionContext));\n\n        \r\n        String execLocalPath = getExecLocalPath(taskExecutionContext);\n        logger.info(\"task instance local execute path : {}\", execLocalPath);\n        taskExecutionContext.setExecutePath(execLocalPath);\n\n        FileUtils.taskLoggerThreadLocal.set(taskLogger);\n        try {\n            FileUtils.createWorkDirIfAbsent(execLocalPath);\n            if (CommonUtils.isSudoEnable() && workerConfig.getWorkerTenantAutoCreate()) {\n                OSUtils.createUserIfAbsent(taskExecutionContext.getTenantCode());\n            }\n        } catch (Throwable ex) {\n            String errorLog = String.format(\"create execLocalPath : %s\", execLocalPath);\n            LoggerUtils.logError(Optional.of(logger), errorLog, ex);\n            LoggerUtils.logError(Optional.ofNullable(taskLogger), errorLog, ex);\n            taskExecutionContextCacheManager.removeByTaskInstanceId(taskExecutionContext.getTaskInstanceId());\n        }\n        FileUtils.taskLoggerThreadLocal.remove();\n\n        taskCallbackService.addRemoteChannel(taskExecutionContext.getTaskInstanceId(),\n            new NettyRemoteChannel(channel, command.getOpaque()));\n\n        \r\n        long remainTime = DateUtils.getRemainTime(taskExecutionContext.getFirstSubmitTime(), taskExecutionContext.getDelayTime() * 60L);\n        if (remainTime > 0) {\n            logger.info(\"delay the execution of task instance {}, delay time: {} s\", taskExecutionContext.getTaskInstanceId(), remainTime);\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.DELAY_EXECUTION);\n            taskExecutionContext.setStartTime(null);\n        } else {\n            taskExecutionContext.setCurrentExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);\n            taskExecutionContext.setStartTime(new Date());\n        }\n\n        this.doAck(taskExecutionContext);\n\n        \r\n        if (!workerManager.offer(new TaskExecuteThread(taskExecutionContext, taskCallbackService, taskLogger, alertClientService))) {\n            logger.info(\"submit task to manager error, queue is full, queue size is {}\", workerManager.getQueueSize());\n        }\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskExecuteProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":111,"status":"M"},{"authorDate":"2021-09-08 20:07:54","commitOrder":27,"curCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand, result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        TaskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","date":"2021-09-08 20:07:54","endLine":100,"groupId":"1095","id":54,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Channelchannel@Commandcommand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-dolphinscheduler-10-0.7/blobInfo/CC_OUT/blobs/20/fbc9ba3aab074a86b5feccae933554734fb920.src","preCode":"    public void process(Channel channel, Command command) {\n        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(\"invalid command type : %s\", command.getType()));\n        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);\n        logger.info(\"received kill command : {}\", killCommand);\n\n        Pair<Boolean, List<String>> result = doKill(killCommand);\n\n        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(),\n                new NettyRemoteChannel(channel, command.getOpaque()));\n\n        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(killCommand, result);\n        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());\n        taskExecutionContextCacheManager.removeByTaskInstanceId(taskKillResponseCommand.getTaskInstanceId());\n    }\n","realPath":"dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java","repoName":"dolphinscheduler","snippetEndLine":0,"snippetStartLine":0,"startLine":87,"status":"M"}],"commitId":"9d7f70bca777177c14efb3d32e469a54951f4a6b","commitMessage":"@@@Merge pull request #6133 from CalvinKirs/task-end\n\n[Feature][Plugin]TaskSPI","date":"2021-09-08 20:07:54","modifiedFileCount":"37","status":"M","submitter":"Kerwin"}]
