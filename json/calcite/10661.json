[{"authorTime":"2014-11-14 09:39:29","codes":[{"authorDate":"2014-11-14 09:39:29","commitOrder":1,"curCode":"  private void checkJoinNWay(int n) throws Exception {\n    final StringBuilder buf = new StringBuilder();\n    buf.append(\"select *\");\n    for (int i = 0; i < n; i++) {\n      buf.append(i == 0 ? \"\\nfrom \" : \",\\n \")\n          .append(\"\\\"depts\\\" as d\").append(i);\n    }\n    for (int i = 1; i < n; i++) {\n      buf.append(i == 1 ? \"\\nwhere\" : \"\\nand\").append(\" d\")\n          .append(i).append(\".\\\"deptno\\\" = d\")\n          .append(i - 1).append(\".\\\"deptno\\\"\");\n    }\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 6));\n    SqlNode parse = planner.parse(buf.toString());\n\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.convert(validate);\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform), containsString(\n        \"EnumerableJoinRel(condition=[=($0, $3)], joinType=[inner])\"));\n  }\n","date":"2014-11-14 09:39:34","endLine":507,"groupId":"8323","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"checkJoinNWay","params":"(intn)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/ef/d16e3bc08b0bd5db7f408c909ea0257d2122aa.src","preCode":"  private void checkJoinNWay(int n) throws Exception {\n    final StringBuilder buf = new StringBuilder();\n    buf.append(\"select *\");\n    for (int i = 0; i < n; i++) {\n      buf.append(i == 0 ? \"\\nfrom \" : \",\\n \")\n          .append(\"\\\"depts\\\" as d\").append(i);\n    }\n    for (int i = 1; i < n; i++) {\n      buf.append(i == 1 ? \"\\nwhere\" : \"\\nand\").append(\" d\")\n          .append(i).append(\".\\\"deptno\\\" = d\")\n          .append(i - 1).append(\".\\\"deptno\\\"\");\n    }\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 6));\n    SqlNode parse = planner.parse(buf.toString());\n\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.convert(validate);\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform), containsString(\n        \"EnumerableJoinRel(condition=[=($0, $3)], joinType=[inner])\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":484,"status":"B"},{"authorDate":"2014-11-14 09:39:29","commitOrder":1,"curCode":"  private void checkHeuristic(String sql, String expected) throws Exception {\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 0));\n    SqlNode parse = planner.parse(sql);\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.convert(validate);\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform), containsString(expected));\n  }\n","date":"2014-11-14 09:39:34","endLine":582,"groupId":"14817","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"checkHeuristic","params":"(Stringsql@Stringexpected)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/ef/d16e3bc08b0bd5db7f408c909ea0257d2122aa.src","preCode":"  private void checkHeuristic(String sql, String expected) throws Exception {\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 0));\n    SqlNode parse = planner.parse(sql);\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.convert(validate);\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform), containsString(expected));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":572,"status":"B"}],"commitId":"a611d645ad754844a39f3d98f5f814f13dbd9404","commitMessage":"@@@[CALCITE-296] Re-organize package structure;\n[CALCITE-419] Naming convention for planner rules\n\nThis change only renames files (and deletes some obsolete files). There are no content changes.\n","date":"2014-11-14 09:39:34","modifiedFileCount":"0","status":"B","submitter":"Julian Hyde"},{"authorTime":"2014-11-14 09:39:29","codes":[{"authorDate":"2014-11-14 10:11:34","commitOrder":2,"curCode":"  private void checkJoinNWay(int n) throws Exception {\n    final StringBuilder buf = new StringBuilder();\n    buf.append(\"select *\");\n    for (int i = 0; i < n; i++) {\n      buf.append(i == 0 ? \"\\nfrom \" : \",\\n \")\n          .append(\"\\\"depts\\\" as d\").append(i);\n    }\n    for (int i = 1; i < n; i++) {\n      buf.append(i == 1 ? \"\\nwhere\" : \"\\nand\").append(\" d\")\n          .append(i).append(\".\\\"deptno\\\" = d\")\n          .append(i - 1).append(\".\\\"deptno\\\"\");\n    }\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 6));\n    SqlNode parse = planner.parse(buf.toString());\n\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.convert(validate);\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform), containsString(\n        \"EnumerableJoin(condition=[=($0, $3)], joinType=[inner])\"));\n  }\n","date":"2014-11-14 10:22:06","endLine":535,"groupId":"8323","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"checkJoinNWay","params":"(intn)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/db/202f8082780b2f01c7022a346113e884c0c732.src","preCode":"  private void checkJoinNWay(int n) throws Exception {\n    final StringBuilder buf = new StringBuilder();\n    buf.append(\"select *\");\n    for (int i = 0; i < n; i++) {\n      buf.append(i == 0 ? \"\\nfrom \" : \",\\n \")\n          .append(\"\\\"depts\\\" as d\").append(i);\n    }\n    for (int i = 1; i < n; i++) {\n      buf.append(i == 1 ? \"\\nwhere\" : \"\\nand\").append(\" d\")\n          .append(i).append(\".\\\"deptno\\\" = d\")\n          .append(i - 1).append(\".\\\"deptno\\\"\");\n    }\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 6));\n    SqlNode parse = planner.parse(buf.toString());\n\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.convert(validate);\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform), containsString(\n        \"EnumerableJoinRel(condition=[=($0, $3)], joinType=[inner])\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":512,"status":"M"},{"authorDate":"2014-11-14 09:39:29","commitOrder":2,"curCode":"  private void checkHeuristic(String sql, String expected) throws Exception {\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 0));\n    SqlNode parse = planner.parse(sql);\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.convert(validate);\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform), containsString(expected));\n  }\n","date":"2014-11-14 09:39:34","endLine":582,"groupId":"14817","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"checkHeuristic","params":"(Stringsql@Stringexpected)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/ef/d16e3bc08b0bd5db7f408c909ea0257d2122aa.src","preCode":"  private void checkHeuristic(String sql, String expected) throws Exception {\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 0));\n    SqlNode parse = planner.parse(sql);\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.convert(validate);\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform), containsString(expected));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":572,"status":"N"}],"commitId":"a0ba73cd2de76696b96a1cd828d2aa4d3ef9eb55","commitMessage":"@@@[CALCITE-306] Standardize code style for \"import package.*;\"\n\nRename classes and packages and generally fix things up after [CALCITE-296] and [CALCITE-419].\n\nMake many inner classes of EnumerableRules (e.g. EnumerableFilter.  EnumerableFilterRule) top-level classes.\n\nApply a consistent formatting convention for string literals split over multiple lines.\n\nRename generated file org.eigenbase.resource.Resources to org.apache.calcite.runtime.Resources.\n\nChange occurrences of \"optiq\" and \"eigenbase\" in java code to \"calcite\".\n","date":"2014-11-14 10:22:06","modifiedFileCount":"1156","status":"M","submitter":"Julian Hyde"},{"authorTime":"2014-11-14 09:39:29","codes":[{"authorDate":"2015-01-05 10:46:01","commitOrder":3,"curCode":"  private void checkJoinNWay(int n) throws Exception {\n    final StringBuilder buf = new StringBuilder();\n    buf.append(\"select *\");\n    for (int i = 0; i < n; i++) {\n      buf.append(i == 0 ? \"\\nfrom \" : \",\\n \")\n          .append(\"\\\"depts\\\" as d\").append(i);\n    }\n    for (int i = 1; i < n; i++) {\n      buf.append(i == 1 ? \"\\nwhere\" : \"\\nand\").append(\" d\")\n          .append(i).append(\".\\\"deptno\\\" = d\")\n          .append(i - 1).append(\".\\\"deptno\\\"\");\n    }\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 6));\n    SqlNode parse = planner.parse(buf.toString());\n\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.convert(validate);\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform), containsString(\n        \"EnumerableJoin(condition=[=($0, $5)], joinType=[inner])\"));\n  }\n","date":"2015-01-05 10:46:01","endLine":559,"groupId":"8323","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"checkJoinNWay","params":"(intn)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/82/137f56c291e71f864e7bb81f59d9ce6960dac0.src","preCode":"  private void checkJoinNWay(int n) throws Exception {\n    final StringBuilder buf = new StringBuilder();\n    buf.append(\"select *\");\n    for (int i = 0; i < n; i++) {\n      buf.append(i == 0 ? \"\\nfrom \" : \",\\n \")\n          .append(\"\\\"depts\\\" as d\").append(i);\n    }\n    for (int i = 1; i < n; i++) {\n      buf.append(i == 1 ? \"\\nwhere\" : \"\\nand\").append(\" d\")\n          .append(i).append(\".\\\"deptno\\\" = d\")\n          .append(i - 1).append(\".\\\"deptno\\\"\");\n    }\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 6));\n    SqlNode parse = planner.parse(buf.toString());\n\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.convert(validate);\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform), containsString(\n        \"EnumerableJoin(condition=[=($0, $3)], joinType=[inner])\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":536,"status":"M"},{"authorDate":"2014-11-14 09:39:29","commitOrder":3,"curCode":"  private void checkHeuristic(String sql, String expected) throws Exception {\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 0));\n    SqlNode parse = planner.parse(sql);\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.convert(validate);\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform), containsString(expected));\n  }\n","date":"2014-11-14 09:39:34","endLine":582,"groupId":"14817","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"checkHeuristic","params":"(Stringsql@Stringexpected)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/ef/d16e3bc08b0bd5db7f408c909ea0257d2122aa.src","preCode":"  private void checkHeuristic(String sql, String expected) throws Exception {\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 0));\n    SqlNode parse = planner.parse(sql);\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.convert(validate);\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform), containsString(expected));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":572,"status":"N"}],"commitId":"175d0705c308acc6f613ada70d2210908c6e8ccc","commitMessage":"@@@[CALCITE-497] Support optional qualifier for column name references\n\nNow.  if a field is a record type.  you can access its fields (and recursively their fields) without qualifiers if the field names are unique. So.  this is useful for any document-oriented schema that is strongly typed.  not just Phoenix/HBase.\n","date":"2015-01-05 10:46:01","modifiedFileCount":"13","status":"M","submitter":"julianhyde"},{"authorTime":"2015-09-11 10:27:49","codes":[{"authorDate":"2015-09-11 10:27:49","commitOrder":4,"curCode":"  private void checkJoinNWay(int n) throws Exception {\n    final StringBuilder buf = new StringBuilder();\n    buf.append(\"select *\");\n    for (int i = 0; i < n; i++) {\n      buf.append(i == 0 ? \"\\nfrom \" : \",\\n \")\n          .append(\"\\\"depts\\\" as d\").append(i);\n    }\n    for (int i = 1; i < n; i++) {\n      buf.append(i == 1 ? \"\\nwhere\" : \"\\nand\").append(\" d\")\n          .append(i).append(\".\\\"deptno\\\" = d\")\n          .append(i - 1).append(\".\\\"deptno\\\"\");\n    }\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 6));\n    SqlNode parse = planner.parse(buf.toString());\n\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).project();\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform),\n        containsString(\n            \"EnumerableJoin(condition=[=($0, $5)], joinType=[inner])\"));\n  }\n","date":"2016-01-10 16:51:24","endLine":682,"groupId":"8323","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"checkJoinNWay","params":"(intn)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/fa/e8cb9c44f03dfb56fb3288ee677e1dcf600f2a.src","preCode":"  private void checkJoinNWay(int n) throws Exception {\n    final StringBuilder buf = new StringBuilder();\n    buf.append(\"select *\");\n    for (int i = 0; i < n; i++) {\n      buf.append(i == 0 ? \"\\nfrom \" : \",\\n \")\n          .append(\"\\\"depts\\\" as d\").append(i);\n    }\n    for (int i = 1; i < n; i++) {\n      buf.append(i == 1 ? \"\\nwhere\" : \"\\nand\").append(\" d\")\n          .append(i).append(\".\\\"deptno\\\" = d\")\n          .append(i - 1).append(\".\\\"deptno\\\"\");\n    }\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 6));\n    SqlNode parse = planner.parse(buf.toString());\n\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.convert(validate);\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform),\n        containsString(\n            \"EnumerableJoin(condition=[=($0, $5)], joinType=[inner])\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":658,"status":"M"},{"authorDate":"2015-09-11 10:27:49","commitOrder":4,"curCode":"  private void checkHeuristic(String sql, String expected) throws Exception {\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 0));\n    SqlNode parse = planner.parse(sql);\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).rel;\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform), containsString(expected));\n  }\n","date":"2016-01-10 16:51:24","endLine":759,"groupId":"14817","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"checkHeuristic","params":"(Stringsql@Stringexpected)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/fa/e8cb9c44f03dfb56fb3288ee677e1dcf600f2a.src","preCode":"  private void checkHeuristic(String sql, String expected) throws Exception {\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 0));\n    SqlNode parse = planner.parse(sql);\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.convert(validate);\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform), containsString(expected));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":749,"status":"M"}],"commitId":"4ae0298688d402484be7c76610e46c6f610a8bc6","commitMessage":"@@@Deprecate some Util methods.  and upgrade last modules to JDK 1.7\n","date":"2016-01-10 16:51:24","modifiedFileCount":"6","status":"M","submitter":"Julian Hyde"},{"authorTime":"2019-01-04 02:58:55","codes":[{"authorDate":"2019-01-04 02:58:55","commitOrder":5,"curCode":"  private void checkJoinNWay(int n) throws Exception {\n    final StringBuilder buf = new StringBuilder();\n    buf.append(\"select *\");\n    for (int i = 0; i < n; i++) {\n      buf.append(i == 0 ? \"\\nfrom \" : \",\\n \")\n          .append(\"\\\"depts\\\" as d\").append(i);\n    }\n    for (int i = 1; i < n; i++) {\n      buf.append(i == 1 ? \"\\nwhere\" : \"\\nand\").append(\" d\")\n          .append(i).append(\".\\\"deptno\\\" = d\")\n          .append(i - 1).append(\".\\\"deptno\\\"\");\n    }\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 6));\n    SqlNode parse = planner.parse(buf.toString());\n\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).project();\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform),\n        containsString(\n            \"EnumerableJoin(condition=[=($0, $5)], joinType=[inner])\"));\n  }\n","date":"2019-01-04 03:21:44","endLine":739,"groupId":"8323","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"checkJoinNWay","params":"(intn)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/7b/d85b6c07b2bdaa72d19a89d46868aeb6f8a602.src","preCode":"  private void checkJoinNWay(int n) throws Exception {\n    final StringBuilder buf = new StringBuilder();\n    buf.append(\"select *\");\n    for (int i = 0; i < n; i++) {\n      buf.append(i == 0 ? \"\\nfrom \" : \",\\n \")\n          .append(\"\\\"depts\\\" as d\").append(i);\n    }\n    for (int i = 1; i < n; i++) {\n      buf.append(i == 1 ? \"\\nwhere\" : \"\\nand\").append(\" d\")\n          .append(i).append(\".\\\"deptno\\\" = d\")\n          .append(i - 1).append(\".\\\"deptno\\\"\");\n    }\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 6));\n    SqlNode parse = planner.parse(buf.toString());\n\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).project();\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform),\n        containsString(\n            \"EnumerableJoin(condition=[=($0, $5)], joinType=[inner])\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":715,"status":"M"},{"authorDate":"2019-01-04 02:58:55","commitOrder":5,"curCode":"  private void checkHeuristic(String sql, String expected) throws Exception {\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 0));\n    SqlNode parse = planner.parse(sql);\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).rel;\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform), containsString(expected));\n  }\n","date":"2019-01-04 03:21:44","endLine":819,"groupId":"14817","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"checkHeuristic","params":"(Stringsql@Stringexpected)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/7b/d85b6c07b2bdaa72d19a89d46868aeb6f8a602.src","preCode":"  private void checkHeuristic(String sql, String expected) throws Exception {\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 0));\n    SqlNode parse = planner.parse(sql);\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).rel;\n    RelTraitSet traitSet = planner.getEmptyTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform), containsString(expected));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":809,"status":"M"}],"commitId":"b54f6de9d7f87e9853fc9ec01b586555a089b913","commitMessage":"@@@[CALCITE-2768] PlannerTest ignores top-level order by clause (~RootRel.collation)\n","date":"2019-01-04 03:21:44","modifiedFileCount":"2","status":"M","submitter":"Vladimir Sitnikov"},{"authorTime":"2019-01-04 02:58:55","codes":[{"authorDate":"2019-04-12 15:11:30","commitOrder":6,"curCode":"  private void checkJoinNWay(int n) throws Exception {\n    final StringBuilder buf = new StringBuilder();\n    buf.append(\"select *\");\n    for (int i = 0; i < n; i++) {\n      buf.append(i == 0 ? \"\\nfrom \" : \",\\n \")\n          .append(\"\\\"depts\\\" as d\").append(i);\n    }\n    for (int i = 1; i < n; i++) {\n      buf.append(i == 1 ? \"\\nwhere\" : \"\\nand\").append(\" d\")\n          .append(i).append(\".\\\"deptno\\\" = d\")\n          .append(i - 1).append(\".\\\"deptno\\\"\");\n    }\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 6));\n    SqlNode parse = planner.parse(buf.toString());\n\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).project();\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform),\n        containsString(\n            \"EnumerableHashJoin(condition=[=($0, $5)], joinType=[inner])\"));\n  }\n","date":"2019-05-30 11:27:53","endLine":932,"groupId":"8323","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"checkJoinNWay","params":"(intn)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/9e/d4c05a5a81d4a10939223d0688438a54be346b.src","preCode":"  private void checkJoinNWay(int n) throws Exception {\n    final StringBuilder buf = new StringBuilder();\n    buf.append(\"select *\");\n    for (int i = 0; i < n; i++) {\n      buf.append(i == 0 ? \"\\nfrom \" : \",\\n \")\n          .append(\"\\\"depts\\\" as d\").append(i);\n    }\n    for (int i = 1; i < n; i++) {\n      buf.append(i == 1 ? \"\\nwhere\" : \"\\nand\").append(\" d\")\n          .append(i).append(\".\\\"deptno\\\" = d\")\n          .append(i - 1).append(\".\\\"deptno\\\"\");\n    }\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 6));\n    SqlNode parse = planner.parse(buf.toString());\n\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).project();\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform),\n        containsString(\n            \"EnumerableJoin(condition=[=($0, $5)], joinType=[inner])\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":908,"status":"M"},{"authorDate":"2019-01-04 02:58:55","commitOrder":6,"curCode":"  private void checkHeuristic(String sql, String expected) throws Exception {\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 0));\n    SqlNode parse = planner.parse(sql);\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).rel;\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform), containsString(expected));\n  }\n","date":"2019-01-04 03:21:44","endLine":819,"groupId":"14817","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"checkHeuristic","params":"(Stringsql@Stringexpected)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/7b/d85b6c07b2bdaa72d19a89d46868aeb6f8a602.src","preCode":"  private void checkHeuristic(String sql, String expected) throws Exception {\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 0));\n    SqlNode parse = planner.parse(sql);\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).rel;\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform), containsString(expected));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":809,"status":"N"}],"commitId":"48093937ae4db179884d1111fa9d12e978e57e1f","commitMessage":"@@@[CALCITE-2696] Improve design of join-like relational expressions\n\n**Diff**\n- Deprecate SemiJoin.  EnumerableSemiJoin.  SemiJoinType. \nEnumerableSemiJoinRule.  JoinToCorrelateRule#SEMI\n- Add SEMI and ANTI join type to JoinRelType.  add method\nprojectsRight() and isOuterJoin()\n- Correlate use JoinRelType instead of SemiJoinType\n- Rename EnumerableThetaJoin to EnumerableNestedLoopJoin\n- Rename EnumerableJoin to EnumerableHashJoin\n- EnumerableJoinRule converts semi join to EnumerableHashJoin\n(EnumerableSemiJoin's functionality is merged into this rule)\n- Add method isSemiJoin() in Join.java to decide if this join is a semi join\n(comes from SemiJoinRule during decorrelateation). \nthe return value true means the join is a semi join equivalent to\nSemiJoin before this patch.\n- Cache the JoinInfo in Join and use it to get leftKeys and rightKeys. \nmerge SemiJoin#computeSelfCost logic into Join#computeSelfCost\n- For RelBuilder.  removes SemiJoinFactory.  method #semiJoin\nnow returns a LogicalJoin with JoinRelType#SEMI\n- Rename EnumerableDefaults#join to EnumerableDefaults#hashJoin\n- Rename EnumerableDefaults#thetaJoin to EnumerableDefaults#nestedLoopJoin\n\n**Rules tweak**\n- JoinAddRedundantSemiJoinRule now creates LogicalJoin with JoinRelType#SEMI\ninstead of SemiJoin\n- JoinToCorrelateRule deprecates SEMI instance and change the matches\ncondition to !join.getJoinType().generatesNullsOnLeft() which also\nallowed ANTI compared before this patch.\n- SemiJoinRule matches SEMI join specifically.\n\n**Metadata tweak**\n- RelMdAllPredicates.  RelMdExpressionLineage: Add full rowType to\ngetAllPredicates(Join) cause semi join only outputs one side\n- RelMdColumnUniqueness.  RelMdSelectivity.  RelMdDistinctRowCount. \nRelMdSize.  RelMdUniqueKeys: merge semi join logic to join\n\n**Test cases change**\n- MaterializationTest#testJoinMaterialization11 now can materialize\nsuccessfully.  cause i allow logical SemiJoin node to match.  the original\nmatches SemiJoin as SemiJoin.class.isAssignableFrom().  which i think is\nwrong cause this will only matches subClasses of SemiJoin which is only\nEnumerableSemiJoin before this patch.\n- SortRemoveRuleTest#removeSortOverEnumerableCorrelate.  because\nCALCITE-2018.  the final EnumerableSort's cost was cached by the previous\nEnumerableSort with logical children.  so i remove the EnumerableSortRule\nand the best plan is correct\n\nclose apache/calcite#1157\n","date":"2019-05-30 11:27:53","modifiedFileCount":"81","status":"M","submitter":"yuzhao.cyz"},{"authorTime":"2019-01-04 02:58:55","codes":[{"authorDate":"2019-11-29 21:06:30","commitOrder":7,"curCode":"  private void checkJoinNWay(int n) throws Exception {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final StringBuilder buf = new StringBuilder();\n    buf.append(\"select * from \\\"depts\\\" as d0\");\n    for (int i = 1; i < n; i++) {\n      buf.append(\"\\njoin \\\"depts\\\" as d\").append(i);\n      buf.append(\"\\non d\").append(i).append(\".\\\"deptno\\\" = d\").append(i - 1).append(\".\\\"deptno\\\"\");\n    }\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 6));\n    SqlNode parse = planner.parse(buf.toString());\n\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).project();\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform),\n        containsString(\n            \"EnumerableHashJoin(condition=[=($0, $5)], joinType=[inner])\"));\n  }\n","date":"2019-12-12 18:51:09","endLine":966,"groupId":"8323","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"checkJoinNWay","params":"(intn)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/1a/998602c7cf65ab86f2346195f4c4f9268a3e7f.src","preCode":"  private void checkJoinNWay(int n) throws Exception {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final StringBuilder buf = new StringBuilder();\n    buf.append(\"select *\");\n    for (int i = 0; i < n; i++) {\n      buf.append(i == 0 ? \"\\nfrom \" : \",\\n \")\n          .append(\"\\\"depts\\\" as d\").append(i);\n    }\n    for (int i = 1; i < n; i++) {\n      buf.append(i == 1 ? \"\\nwhere\" : \"\\nand\").append(\" d\")\n          .append(i).append(\".\\\"deptno\\\" = d\")\n          .append(i - 1).append(\".\\\"deptno\\\"\");\n    }\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 6));\n    SqlNode parse = planner.parse(buf.toString());\n\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).project();\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform),\n        containsString(\n            \"EnumerableHashJoin(condition=[=($0, $5)], joinType=[inner])\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":929,"status":"M"},{"authorDate":"2019-01-04 02:58:55","commitOrder":7,"curCode":"  private void checkHeuristic(String sql, String expected) throws Exception {\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 0));\n    SqlNode parse = planner.parse(sql);\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).rel;\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform), containsString(expected));\n  }\n","date":"2019-01-04 03:21:44","endLine":819,"groupId":"14817","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"checkHeuristic","params":"(Stringsql@Stringexpected)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/7b/d85b6c07b2bdaa72d19a89d46868aeb6f8a602.src","preCode":"  private void checkHeuristic(String sql, String expected) throws Exception {\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 0));\n    SqlNode parse = planner.parse(sql);\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).rel;\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform), containsString(expected));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":809,"status":"N"}],"commitId":"a4d04a35a9aca3ac1f464c231b998cd2808a4b01","commitMessage":"@@@[CALCITE-3535] EnumerableJoinRule: remove unnecessary Filter on top of INNER Join\n","date":"2019-12-12 18:51:09","modifiedFileCount":"9","status":"M","submitter":"rubenada"},{"authorTime":"2019-01-04 02:58:55","codes":[{"authorDate":"2020-04-29 22:56:19","commitOrder":8,"curCode":"  private void checkJoinNWay(int n) throws Exception {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final StringBuilder buf = new StringBuilder();\n    buf.append(\"select * from \\\"depts\\\" as d0\");\n    for (int i = 1; i < n; i++) {\n      buf.append(\"\\njoin \\\"depts\\\" as d\").append(i);\n      buf.append(\"\\non d\").append(i).append(\".\\\"deptno\\\" = d\").append(i - 1).append(\".\\\"deptno\\\"\");\n    }\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 6));\n    SqlNode parse = planner.parse(buf.toString());\n\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).project();\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform),\n        containsString(\n            \"EnumerableMergeJoin(condition=[=($0, $5)], joinType=[inner])\"));\n  }\n","date":"2020-05-11 11:40:36","endLine":973,"groupId":"8323","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"checkJoinNWay","params":"(intn)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/ed/7105007c2146a8ee4d2fcadc9989336cb8189d.src","preCode":"  private void checkJoinNWay(int n) throws Exception {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final StringBuilder buf = new StringBuilder();\n    buf.append(\"select * from \\\"depts\\\" as d0\");\n    for (int i = 1; i < n; i++) {\n      buf.append(\"\\njoin \\\"depts\\\" as d\").append(i);\n      buf.append(\"\\non d\").append(i).append(\".\\\"deptno\\\" = d\").append(i - 1).append(\".\\\"deptno\\\"\");\n    }\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 6));\n    SqlNode parse = planner.parse(buf.toString());\n\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).project();\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform),\n        containsString(\n            \"EnumerableHashJoin(condition=[=($0, $5)], joinType=[inner])\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":936,"status":"M"},{"authorDate":"2019-01-04 02:58:55","commitOrder":8,"curCode":"  private void checkHeuristic(String sql, String expected) throws Exception {\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 0));\n    SqlNode parse = planner.parse(sql);\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).rel;\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform), containsString(expected));\n  }\n","date":"2019-01-04 03:21:44","endLine":819,"groupId":"14817","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"checkHeuristic","params":"(Stringsql@Stringexpected)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/7b/d85b6c07b2bdaa72d19a89d46868aeb6f8a602.src","preCode":"  private void checkHeuristic(String sql, String expected) throws Exception {\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 0));\n    SqlNode parse = planner.parse(sql);\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).rel;\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform), containsString(expected));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":809,"status":"N"}],"commitId":"9c31d9e83dc718800a36f7719534f9f74633c8a7","commitMessage":"@@@[CALCITE-3896] Top down trait request\n\n1. Top-down trait request\n2. Bottom-up trait derivation\n3. Trait enforcement without AbstractConverter\n\nHow to use?\n\n1. Enable top-down optimization by setting {VolcanoPlanner#setTopDownOpt(boolean)}\nor add 'calcite.planner.topdown.opt=true' to saffron.properties config file.\n\n2. Let your convention's rel interface extends {PhysicalNode}.  see\n{EnumerableRel} as an example.\n\n3. Each physical operator overrides any one of the two methods:\n{PhysicalNode#passThrough(RelTraitSet)} or\n{PhysicalNode#passThroughTraits(RelTraitSet)} depending on your needs.\n\n4. Choose derive mode for each physical operator by overriding\n{PhysicalNode#getDeriveMode()}.\n\n5. If the derive mode is {DeriveMode#OMAKASE}.  override method\n{PhysicalNode#derive(List)} in the physical operator.  otherwise.  override\n{PhysicalNode#derive(RelTraitSet.  int)} or\n{PhysicalNode#deriveTraits(RelTraitSet.  int)}.\n\n6. Mark your enforcer operator by overriding {RelNode#isEnforcer()}.  see\n{Sort#isEnforcer()} as an example. This is important.  because it can help\n{VolcanoPlanner} avoid unnecessary trait propagation and derivation.  therefore\nimprove optimization efficiency.\n\n7. Implement {Convention#enforce(RelNode.  RelTraitSet)} in your convention. \nwhich generates appropriate physical enforcer. See\n{EnumerableConvention#enforce(RelNode.  RelTraitSet)} as example. Simply return\nnull if you don't want physical trait enforcement.\n\nHow does it work?\n\nLet S# denote the seed physical operator in a RelSet after logical and physical\nrules transformation.  P# denote the physical operator generated by passing down\nparent trait requirements.  D# denote the physical operator generated by\nderiving from child delivered traitSets.\n\nThe initial rel list state in a RelSet is as follows:\n    cursor\n      |\n      V\n     S1.  S2\n\nWhen we create a task for RelSubset1.  the task will immediately pass the\nsubset's traitSet to seed operators.  S1 and S2.  now we have:\n    cursor\n      |\n      V\n     S1.  S2.  P1.  P2\n\nThe subset task will create a optimization task for the relnode pointed by\ncursor.  and move cursor to next available physical operator S2. In the task for\nS1.  it will continue optimize its child nodes.  which are RelSubsets. After\nchild inputs optimization is finished.  S1 will derive new relnodes from\ndelivered subsets in input RelSet. Once task for S1 is completed.  we have:\n        cursor\n          |\n          V\n     S1.  S2.  P1.  P2.  D1\n\nThe subset task continues scheduling task for S2.  P1... until there is no more\nrelnode created for the RelSet.  then we have:\n                                cursor\n                                  |\n                                  V\n     S1.  S2.  P1.  P2.  D1.  D2.  D3.  null\n\nWhen a task for another RelSubset2 is created.  the task will try to pass down\nthe subset's traitSet to seed operator S1 and S2.  now the RelSet looks like:\n                                cursor\n                                  |\n                                  V\n     S1.  S2.  P1.  P2.  D1.  D2.  D3.  P3.  P4\n\nThe process continues till there is no more subsets or relnodes created for the\nRelSet.\n\nSee https://t.ly/MmaF for discussion.\n\nClose #1953\n","date":"2020-05-11 11:40:36","modifiedFileCount":"17","status":"M","submitter":"Haisheng Yuan"},{"authorTime":"2019-01-04 02:58:55","codes":[{"authorDate":"2020-05-20 14:52:40","commitOrder":9,"curCode":"  private void checkJoinNWay(int n) throws Exception {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final StringBuilder buf = new StringBuilder();\n    buf.append(\"select * from \\\"depts\\\" as d0\");\n    for (int i = 1; i < n; i++) {\n      buf.append(\"\\njoin \\\"depts\\\" as d\").append(i);\n      buf.append(\"\\non d\").append(i).append(\".\\\"deptno\\\" = d\").append(i - 1).append(\".\\\"deptno\\\"\");\n    }\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 6));\n    SqlNode parse = planner.parse(buf.toString());\n\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).project();\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform),\n        containsString(\n            \"EnumerableHashJoin(condition=[=($0, $5)], joinType=[inner])\"));\n  }\n","date":"2020-05-30 03:06:17","endLine":973,"groupId":"10661","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"checkJoinNWay","params":"(intn)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e6/ce8a05eee1dbae94fa526e1af77f6e77e09e4d.src","preCode":"  private void checkJoinNWay(int n) throws Exception {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final StringBuilder buf = new StringBuilder();\n    buf.append(\"select * from \\\"depts\\\" as d0\");\n    for (int i = 1; i < n; i++) {\n      buf.append(\"\\njoin \\\"depts\\\" as d\").append(i);\n      buf.append(\"\\non d\").append(i).append(\".\\\"deptno\\\" = d\").append(i - 1).append(\".\\\"deptno\\\"\");\n    }\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 6));\n    SqlNode parse = planner.parse(buf.toString());\n\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).project();\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform),\n        containsString(\n            \"EnumerableMergeJoin(condition=[=($0, $5)], joinType=[inner])\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":936,"status":"M"},{"authorDate":"2019-01-04 02:58:55","commitOrder":9,"curCode":"  private void checkHeuristic(String sql, String expected) throws Exception {\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 0));\n    SqlNode parse = planner.parse(sql);\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).rel;\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform), containsString(expected));\n  }\n","date":"2019-01-04 03:21:44","endLine":819,"groupId":"10661","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"checkHeuristic","params":"(Stringsql@Stringexpected)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/7b/d85b6c07b2bdaa72d19a89d46868aeb6f8a602.src","preCode":"  private void checkHeuristic(String sql, String expected) throws Exception {\n    Planner planner = getPlanner(null,\n        Programs.heuristicJoinOrder(Programs.RULE_SET, false, 0));\n    SqlNode parse = planner.parse(sql);\n    SqlNode validate = planner.validate(parse);\n    RelNode convert = planner.rel(validate).rel;\n    RelTraitSet traitSet = convert.getTraitSet()\n        .replace(EnumerableConvention.INSTANCE);\n    RelNode transform = planner.transform(0, traitSet, convert);\n    assertThat(toString(transform), containsString(expected));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":809,"status":"N"}],"commitId":"0af3fd17a293d37125c7cca58257e5f6cbc1a76c","commitMessage":"@@@[CALCITE-4011] Support trait propagation for EnumerableProject and EnumerableFilter (Rui Wang)\n\nTrait propgation includes trait passthrough and trait derivation.\n\nTrait passthrough could happen when Project satisfies the ordering\nrequirement that is defined by collations. Project will not satisfy the\nordering requirement when a requested collation is defined on a\nnon-trivial expression. Usually a RexCall is considered as non-trivial. \nunless it is a CAST that perserves monotonicity. \n\nHere is an example to demonstrate why trait cannot pass through when\ncollations are defined on non-trival expr:\n\nselect a.  b*-1 as b\nfrom foo\norder by a.  b;\n\nwhich generates the logical plan:\nLogicalSort\n  LogicalProject\n     LogicalTableScan\n\nWe cannot move the top sort down through the project. Because b*-1 will\nchange ordering to the opposite. The sort has to remain on top of\nproject for correness.\n\nTrait derivaiton does something simlar to trait pass through.  except for\none difference:\ntrait derivation can return parital collations that are derived from\nchild. For example.  if [a.  b.  c.  d] is derived from child.  and if c is\ndefined on a non-trival expr.  then [a.  b] will be returned cause it\nmight be useful for parents.\n\nAnother example to show why trait derivation could be useful to reutrn\npartial collations:\n\nselect a.  b\nfrom (\n select a.  b.  c*-1.  d\n from foo\n order by a.  b.  c.  d\n)\norder by a.  b;\n\nIn this example.  even though the inner project does not preserve the\ntotal ordering for inner sort.  but the outer sort only want to sort on\n[a.  b].  thus if inner project can derive [a.  b].  the outer project will\nnot need the top sort or enforce a sort for its input.\n\nAfter top-down optimization is enabled.  trait propagation for EnumerableProject\nand EnumerableFilter is supposed to replace ProjectSortTransposeRule and\nSortProjectTransposeRule.\n\nClose #1985\n","date":"2020-05-30 03:06:17","modifiedFileCount":"13","status":"M","submitter":"amaliujia"}]
