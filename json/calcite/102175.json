[{"authorTime":"2015-01-28 17:57:34","codes":[{"authorDate":"2015-02-23 02:56:33","commitOrder":2,"curCode":"  private static TableScanNode createEnumerable(\n      Interpreter interpreter, TableScan rel,\n      Enumerable<Row> enumerable, final ImmutableIntList acceptedProjects,\n      List<RexNode> rejectedFilters, final ImmutableIntList rejectedProjects) {\n    if (!rejectedFilters.isEmpty()) {\n      final RexNode filter =\n          RexUtil.composeConjunction(rel.getCluster().getRexBuilder(),\n              rejectedFilters, false);\n      \r\n      final RexNode filter2;\n      final RelDataType inputRowType;\n      if (acceptedProjects == null) {\n        filter2 = filter;\n        inputRowType = rel.getRowType();\n      } else {\n        final Mapping mapping = Mappings.target(acceptedProjects,\n            rel.getTable().getRowType().getFieldCount());\n        filter2 = RexUtil.apply(mapping, filter);\n        final RelDataTypeFactory.FieldInfoBuilder builder =\n            rel.getCluster().getTypeFactory().builder();\n        final List<RelDataTypeField> fieldList =\n            rel.getTable().getRowType().getFieldList();\n        for (int acceptedProject : acceptedProjects) {\n          builder.add(fieldList.get(acceptedProject));\n        }\n        inputRowType = builder.build();\n      }\n      final Scalar condition =\n          interpreter.compile(\n              ImmutableList.of(filter2), inputRowType);\n      final Context context = interpreter.createContext();\n      enumerable = enumerable.where(\n          new Predicate1<Row>() {\n            @Override public boolean apply(Row row) {\n              context.values = row.getValues();\n              Boolean b = (Boolean) condition.execute(context);\n              return b != null && b;\n            }\n          });\n    }\n    if (rejectedProjects != null) {\n      enumerable = enumerable.select(\n          new Function1<Row, Row>() {\n            final Object[] values = new Object[rejectedProjects.size()];\n            @Override public Row apply(Row row) {\n              final Object[] inValues = row.getValues();\n              for (int i = 0; i < rejectedProjects.size(); i++) {\n                values[i] = inValues[rejectedProjects.get(i)];\n              }\n              return Row.asCopy(values);\n            }\n          });\n    }\n    return new TableScanNode(interpreter, rel, enumerable);\n  }\n","date":"2015-02-24 06:33:59","endLine":307,"groupId":"5097","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"createEnumerable","params":"(Interpreterinterpreter@TableScanrel@Enumerable<Row>enumerable@finalImmutableIntListacceptedProjects@List<RexNode>rejectedFilters@finalImmutableIntListrejectedProjects)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/2b/1865fe8375bec86bdc696b5def01365480a098.src","preCode":"  private static TableScanNode createEnumerable(\n      Interpreter interpreter, TableScan rel,\n      Enumerable<Row> enumerable, final ImmutableIntList acceptedProjects,\n      List<RexNode> rejectedFilters, final ImmutableIntList rejectedProjects) {\n    if (!rejectedFilters.isEmpty()) {\n      final RexNode filter =\n          RexUtil.composeConjunction(rel.getCluster().getRexBuilder(),\n              rejectedFilters, false);\n      \r\n      final RexNode filter2;\n      final RelDataType inputRowType;\n      if (acceptedProjects == null) {\n        filter2 = filter;\n        inputRowType = rel.getRowType();\n      } else {\n        final Mapping mapping = Mappings.target(acceptedProjects,\n            rel.getTable().getRowType().getFieldCount());\n        filter2 = RexUtil.apply(mapping, filter);\n        final RelDataTypeFactory.FieldInfoBuilder builder =\n            rel.getCluster().getTypeFactory().builder();\n        final List<RelDataTypeField> fieldList =\n            rel.getTable().getRowType().getFieldList();\n        for (int acceptedProject : acceptedProjects) {\n          builder.add(fieldList.get(acceptedProject));\n        }\n        inputRowType = builder.build();\n      }\n      final Scalar condition =\n          interpreter.compile(\n              ImmutableList.of(filter2), inputRowType);\n      final Context context = interpreter.createContext();\n      enumerable = enumerable.where(\n          new Predicate1<Row>() {\n            @Override public boolean apply(Row row) {\n              context.values = row.getValues();\n              Boolean b = (Boolean) condition.execute(context);\n              return b != null && b;\n            }\n          });\n    }\n    if (rejectedProjects != null) {\n      enumerable = enumerable.select(\n          new Function1<Row, Row>() {\n            final Object[] values = new Object[rejectedProjects.size()];\n            @Override public Row apply(Row row) {\n              final Object[] inValues = row.getValues();\n              for (int i = 0; i < rejectedProjects.size(); i++) {\n                values[i] = inValues[rejectedProjects.get(i)];\n              }\n              return Row.asCopy(values);\n            }\n          });\n    }\n    return new TableScanNode(interpreter, rel, enumerable);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/interpreter/TableScanNode.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":253,"status":"B"},{"authorDate":"2015-01-28 17:57:34","commitOrder":2,"curCode":"    @Override public RelDataType deriveRowType() {\n      final RelDataTypeFactory.FieldInfoBuilder builder =\n          getCluster().getTypeFactory().builder();\n      final List<RelDataTypeField> fieldList =\n          table.getRowType().getFieldList();\n      for (int project : projects) {\n        builder.add(fieldList.get(project));\n      }\n      return builder.build();\n    }\n","date":"2015-02-22 12:46:51","endLine":207,"groupId":"13034","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"deriveRowType","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/a4/474b4d127bd5354c5bd48742be48dc020c936e.src","preCode":"    @Override public RelDataType deriveRowType() {\n      final RelDataTypeFactory.FieldInfoBuilder builder =\n          getCluster().getTypeFactory().builder();\n      final List<RelDataTypeField> fieldList =\n          table.getRowType().getFieldList();\n      for (int project : projects) {\n        builder.add(fieldList.get(project));\n      }\n      return builder.build();\n    }\n","realPath":"core/src/main/java/org/apache/calcite/interpreter/Bindables.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":198,"status":"NB"}],"commitId":"96cac479615421628dfca3461d2b36e461c2bb16","commitMessage":"@@@Refactor TableScanNode.create method\n","date":"2015-02-24 06:33:59","modifiedFileCount":"1","status":"M","submitter":"Julian Hyde"},{"authorTime":"2017-08-06 15:29:03","codes":[{"authorDate":"2017-08-06 15:29:03","commitOrder":3,"curCode":"  private static TableScanNode createEnumerable(\n      Interpreter interpreter, TableScan rel,\n      Enumerable<Row> enumerable, final ImmutableIntList acceptedProjects,\n      List<RexNode> rejectedFilters, final ImmutableIntList rejectedProjects) {\n    if (!rejectedFilters.isEmpty()) {\n      final RexNode filter =\n          RexUtil.composeConjunction(rel.getCluster().getRexBuilder(),\n              rejectedFilters, false);\n      \r\n      final RexNode filter2;\n      final RelDataType inputRowType;\n      if (acceptedProjects == null) {\n        filter2 = filter;\n        inputRowType = rel.getRowType();\n      } else {\n        final Mapping mapping = Mappings.target(acceptedProjects,\n            rel.getTable().getRowType().getFieldCount());\n        filter2 = RexUtil.apply(mapping, filter);\n        final RelDataTypeFactory.Builder builder =\n            rel.getCluster().getTypeFactory().builder();\n        final List<RelDataTypeField> fieldList =\n            rel.getTable().getRowType().getFieldList();\n        for (int acceptedProject : acceptedProjects) {\n          builder.add(fieldList.get(acceptedProject));\n        }\n        inputRowType = builder.build();\n      }\n      final Scalar condition =\n          interpreter.compile(\n              ImmutableList.of(filter2), inputRowType);\n      final Context context = interpreter.createContext();\n      enumerable = enumerable.where(\n          new Predicate1<Row>() {\n            @Override public boolean apply(Row row) {\n              context.values = row.getValues();\n              Boolean b = (Boolean) condition.execute(context);\n              return b != null && b;\n            }\n          });\n    }\n    if (rejectedProjects != null) {\n      enumerable = enumerable.select(\n          new Function1<Row, Row>() {\n            final Object[] values = new Object[rejectedProjects.size()];\n            @Override public Row apply(Row row) {\n              final Object[] inValues = row.getValues();\n              for (int i = 0; i < rejectedProjects.size(); i++) {\n                values[i] = inValues[rejectedProjects.get(i)];\n              }\n              return Row.asCopy(values);\n            }\n          });\n    }\n    return new TableScanNode(interpreter, rel, enumerable);\n  }\n","date":"2017-08-08 00:14:46","endLine":296,"groupId":"5097","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"createEnumerable","params":"(Interpreterinterpreter@TableScanrel@Enumerable<Row>enumerable@finalImmutableIntListacceptedProjects@List<RexNode>rejectedFilters@finalImmutableIntListrejectedProjects)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/9c/ec9e60c09591321cc94a0f7bfe9b0534c50ccf.src","preCode":"  private static TableScanNode createEnumerable(\n      Interpreter interpreter, TableScan rel,\n      Enumerable<Row> enumerable, final ImmutableIntList acceptedProjects,\n      List<RexNode> rejectedFilters, final ImmutableIntList rejectedProjects) {\n    if (!rejectedFilters.isEmpty()) {\n      final RexNode filter =\n          RexUtil.composeConjunction(rel.getCluster().getRexBuilder(),\n              rejectedFilters, false);\n      \r\n      final RexNode filter2;\n      final RelDataType inputRowType;\n      if (acceptedProjects == null) {\n        filter2 = filter;\n        inputRowType = rel.getRowType();\n      } else {\n        final Mapping mapping = Mappings.target(acceptedProjects,\n            rel.getTable().getRowType().getFieldCount());\n        filter2 = RexUtil.apply(mapping, filter);\n        final RelDataTypeFactory.FieldInfoBuilder builder =\n            rel.getCluster().getTypeFactory().builder();\n        final List<RelDataTypeField> fieldList =\n            rel.getTable().getRowType().getFieldList();\n        for (int acceptedProject : acceptedProjects) {\n          builder.add(fieldList.get(acceptedProject));\n        }\n        inputRowType = builder.build();\n      }\n      final Scalar condition =\n          interpreter.compile(\n              ImmutableList.of(filter2), inputRowType);\n      final Context context = interpreter.createContext();\n      enumerable = enumerable.where(\n          new Predicate1<Row>() {\n            @Override public boolean apply(Row row) {\n              context.values = row.getValues();\n              Boolean b = (Boolean) condition.execute(context);\n              return b != null && b;\n            }\n          });\n    }\n    if (rejectedProjects != null) {\n      enumerable = enumerable.select(\n          new Function1<Row, Row>() {\n            final Object[] values = new Object[rejectedProjects.size()];\n            @Override public Row apply(Row row) {\n              final Object[] inValues = row.getValues();\n              for (int i = 0; i < rejectedProjects.size(); i++) {\n                values[i] = inValues[rejectedProjects.get(i)];\n              }\n              return Row.asCopy(values);\n            }\n          });\n    }\n    return new TableScanNode(interpreter, rel, enumerable);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/interpreter/TableScanNode.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":242,"status":"M"},{"authorDate":"2017-08-06 15:29:03","commitOrder":3,"curCode":"    @Override public RelDataType deriveRowType() {\n      final RelDataTypeFactory.Builder builder =\n          getCluster().getTypeFactory().builder();\n      final List<RelDataTypeField> fieldList =\n          table.getRowType().getFieldList();\n      for (int project : projects) {\n        builder.add(fieldList.get(project));\n      }\n      return builder.build();\n    }\n","date":"2017-08-08 00:14:46","endLine":209,"groupId":"13034","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"deriveRowType","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e0/09cd148cf7bf2d229bddbc7dafa4c5db5d8c1e.src","preCode":"    @Override public RelDataType deriveRowType() {\n      final RelDataTypeFactory.FieldInfoBuilder builder =\n          getCluster().getTypeFactory().builder();\n      final List<RelDataTypeField> fieldList =\n          table.getRowType().getFieldList();\n      for (int project : projects) {\n        builder.add(fieldList.get(project));\n      }\n      return builder.build();\n    }\n","realPath":"core/src/main/java/org/apache/calcite/interpreter/Bindables.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":200,"status":"M"}],"commitId":"a98b21ea33e80d801dd77cd215d23bd0debd8b67","commitMessage":"@@@[CALCITE-1929] Deprecate class RelDataTypeFactory.FieldInfoBuilder\n\nReplace uses of FieldInfoBuilder with new base class\nRelDataTypeFactory.Builder that does not implement deprecated class\nFieldInfo.\n","date":"2017-08-08 00:14:46","modifiedFileCount":"37","status":"M","submitter":"Julian Hyde"},{"authorTime":"2017-08-06 15:29:03","codes":[{"authorDate":"2018-01-09 15:21:54","commitOrder":4,"curCode":"  private static TableScanNode createEnumerable(Compiler compiler,\n      TableScan rel, Enumerable<Row> enumerable,\n      final ImmutableIntList acceptedProjects, List<RexNode> rejectedFilters,\n      final ImmutableIntList rejectedProjects) {\n    if (!rejectedFilters.isEmpty()) {\n      final RexNode filter =\n          RexUtil.composeConjunction(rel.getCluster().getRexBuilder(),\n              rejectedFilters, false);\n      assert filter != null;\n      \r\n      final RexNode filter2;\n      final RelDataType inputRowType;\n      if (acceptedProjects == null) {\n        filter2 = filter;\n        inputRowType = rel.getRowType();\n      } else {\n        final Mapping mapping = Mappings.target(acceptedProjects,\n            rel.getTable().getRowType().getFieldCount());\n        filter2 = RexUtil.apply(mapping, filter);\n        final RelDataTypeFactory.Builder builder =\n            rel.getCluster().getTypeFactory().builder();\n        final List<RelDataTypeField> fieldList =\n            rel.getTable().getRowType().getFieldList();\n        for (int acceptedProject : acceptedProjects) {\n          builder.add(fieldList.get(acceptedProject));\n        }\n        inputRowType = builder.build();\n      }\n      final Scalar condition =\n          compiler.compile(ImmutableList.of(filter2), inputRowType);\n      final Context context = compiler.createContext();\n      enumerable = enumerable.where(\n          new Predicate1<Row>() {\n            @Override public boolean apply(Row row) {\n              context.values = row.getValues();\n              Boolean b = (Boolean) condition.execute(context);\n              return b != null && b;\n            }\n          });\n    }\n    if (rejectedProjects != null) {\n      enumerable = enumerable.select(\n          new Function1<Row, Row>() {\n            final Object[] values = new Object[rejectedProjects.size()];\n            @Override public Row apply(Row row) {\n              final Object[] inValues = row.getValues();\n              for (int i = 0; i < rejectedProjects.size(); i++) {\n                values[i] = inValues[rejectedProjects.get(i)];\n              }\n              return Row.asCopy(values);\n            }\n          });\n    }\n    return new TableScanNode(compiler, rel, enumerable);\n  }\n","date":"2018-01-10 15:01:18","endLine":296,"groupId":"5097","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"createEnumerable","params":"(Compilercompiler@TableScanrel@Enumerable<Row>enumerable@finalImmutableIntListacceptedProjects@List<RexNode>rejectedFilters@finalImmutableIntListrejectedProjects)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/9c/8124e9cf23ad23c30046005a34a3056de497c1.src","preCode":"  private static TableScanNode createEnumerable(\n      Interpreter interpreter, TableScan rel,\n      Enumerable<Row> enumerable, final ImmutableIntList acceptedProjects,\n      List<RexNode> rejectedFilters, final ImmutableIntList rejectedProjects) {\n    if (!rejectedFilters.isEmpty()) {\n      final RexNode filter =\n          RexUtil.composeConjunction(rel.getCluster().getRexBuilder(),\n              rejectedFilters, false);\n      \r\n      final RexNode filter2;\n      final RelDataType inputRowType;\n      if (acceptedProjects == null) {\n        filter2 = filter;\n        inputRowType = rel.getRowType();\n      } else {\n        final Mapping mapping = Mappings.target(acceptedProjects,\n            rel.getTable().getRowType().getFieldCount());\n        filter2 = RexUtil.apply(mapping, filter);\n        final RelDataTypeFactory.Builder builder =\n            rel.getCluster().getTypeFactory().builder();\n        final List<RelDataTypeField> fieldList =\n            rel.getTable().getRowType().getFieldList();\n        for (int acceptedProject : acceptedProjects) {\n          builder.add(fieldList.get(acceptedProject));\n        }\n        inputRowType = builder.build();\n      }\n      final Scalar condition =\n          interpreter.compile(\n              ImmutableList.of(filter2), inputRowType);\n      final Context context = interpreter.createContext();\n      enumerable = enumerable.where(\n          new Predicate1<Row>() {\n            @Override public boolean apply(Row row) {\n              context.values = row.getValues();\n              Boolean b = (Boolean) condition.execute(context);\n              return b != null && b;\n            }\n          });\n    }\n    if (rejectedProjects != null) {\n      enumerable = enumerable.select(\n          new Function1<Row, Row>() {\n            final Object[] values = new Object[rejectedProjects.size()];\n            @Override public Row apply(Row row) {\n              final Object[] inValues = row.getValues();\n              for (int i = 0; i < rejectedProjects.size(); i++) {\n                values[i] = inValues[rejectedProjects.get(i)];\n              }\n              return Row.asCopy(values);\n            }\n          });\n    }\n    return new TableScanNode(interpreter, rel, enumerable);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/interpreter/TableScanNode.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":242,"status":"M"},{"authorDate":"2017-08-06 15:29:03","commitOrder":4,"curCode":"    @Override public RelDataType deriveRowType() {\n      final RelDataTypeFactory.Builder builder =\n          getCluster().getTypeFactory().builder();\n      final List<RelDataTypeField> fieldList =\n          table.getRowType().getFieldList();\n      for (int project : projects) {\n        builder.add(fieldList.get(project));\n      }\n      return builder.build();\n    }\n","date":"2017-08-08 00:14:46","endLine":209,"groupId":"13034","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"deriveRowType","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e0/09cd148cf7bf2d229bddbc7dafa4c5db5d8c1e.src","preCode":"    @Override public RelDataType deriveRowType() {\n      final RelDataTypeFactory.Builder builder =\n          getCluster().getTypeFactory().builder();\n      final List<RelDataTypeField> fieldList =\n          table.getRowType().getFieldList();\n      for (int project : projects) {\n        builder.add(fieldList.get(project));\n      }\n      return builder.build();\n    }\n","realPath":"core/src/main/java/org/apache/calcite/interpreter/Bindables.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":200,"status":"N"}],"commitId":"7b85d445462799926474945c6ab33b1cb8ce33cc","commitMessage":"@@@[CALCITE-2127] In Interpreter.  allow a node to have more than one consumer\n","date":"2018-01-10 15:01:18","modifiedFileCount":"16","status":"M","submitter":"Julian Hyde"},{"authorTime":"2017-08-06 15:29:03","codes":[{"authorDate":"2018-07-06 04:21:59","commitOrder":5,"curCode":"  private static TableScanNode createEnumerable(Compiler compiler,\n      TableScan rel, Enumerable<Row> enumerable,\n      final ImmutableIntList acceptedProjects, List<RexNode> rejectedFilters,\n      final ImmutableIntList rejectedProjects) {\n    if (!rejectedFilters.isEmpty()) {\n      final RexNode filter =\n          RexUtil.composeConjunction(rel.getCluster().getRexBuilder(),\n              rejectedFilters, false);\n      assert filter != null;\n      \r\n      final RexNode filter2;\n      final RelDataType inputRowType;\n      if (acceptedProjects == null) {\n        filter2 = filter;\n        inputRowType = rel.getRowType();\n      } else {\n        final Mapping mapping = Mappings.target(acceptedProjects,\n            rel.getTable().getRowType().getFieldCount());\n        filter2 = RexUtil.apply(mapping, filter);\n        final RelDataTypeFactory.Builder builder =\n            rel.getCluster().getTypeFactory().builder();\n        final List<RelDataTypeField> fieldList =\n            rel.getTable().getRowType().getFieldList();\n        for (int acceptedProject : acceptedProjects) {\n          builder.add(fieldList.get(acceptedProject));\n        }\n        inputRowType = builder.build();\n      }\n      final Scalar condition =\n          compiler.compile(ImmutableList.of(filter2), inputRowType);\n      final Context context = compiler.createContext();\n      enumerable = enumerable.where(row -> {\n        context.values = row.getValues();\n        Boolean b = (Boolean) condition.execute(context);\n        return b != null && b;\n      });\n    }\n    if (rejectedProjects != null) {\n      enumerable = enumerable.select(\n          new Function1<Row, Row>() {\n            final Object[] values = new Object[rejectedProjects.size()];\n            @Override public Row apply(Row row) {\n              final Object[] inValues = row.getValues();\n              for (int i = 0; i < rejectedProjects.size(); i++) {\n                values[i] = inValues[rejectedProjects.get(i)];\n              }\n              return Row.asCopy(values);\n            }\n          });\n    }\n    return new TableScanNode(compiler, rel, enumerable);\n  }\n","date":"2018-07-09 01:16:26","endLine":289,"groupId":"1292","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"createEnumerable","params":"(Compilercompiler@TableScanrel@Enumerable<Row>enumerable@finalImmutableIntListacceptedProjects@List<RexNode>rejectedFilters@finalImmutableIntListrejectedProjects)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/54/217c976faad14a0a220d8ffc678d4e81570d55.src","preCode":"  private static TableScanNode createEnumerable(Compiler compiler,\n      TableScan rel, Enumerable<Row> enumerable,\n      final ImmutableIntList acceptedProjects, List<RexNode> rejectedFilters,\n      final ImmutableIntList rejectedProjects) {\n    if (!rejectedFilters.isEmpty()) {\n      final RexNode filter =\n          RexUtil.composeConjunction(rel.getCluster().getRexBuilder(),\n              rejectedFilters, false);\n      assert filter != null;\n      \r\n      final RexNode filter2;\n      final RelDataType inputRowType;\n      if (acceptedProjects == null) {\n        filter2 = filter;\n        inputRowType = rel.getRowType();\n      } else {\n        final Mapping mapping = Mappings.target(acceptedProjects,\n            rel.getTable().getRowType().getFieldCount());\n        filter2 = RexUtil.apply(mapping, filter);\n        final RelDataTypeFactory.Builder builder =\n            rel.getCluster().getTypeFactory().builder();\n        final List<RelDataTypeField> fieldList =\n            rel.getTable().getRowType().getFieldList();\n        for (int acceptedProject : acceptedProjects) {\n          builder.add(fieldList.get(acceptedProject));\n        }\n        inputRowType = builder.build();\n      }\n      final Scalar condition =\n          compiler.compile(ImmutableList.of(filter2), inputRowType);\n      final Context context = compiler.createContext();\n      enumerable = enumerable.where(\n          new Predicate1<Row>() {\n            @Override public boolean apply(Row row) {\n              context.values = row.getValues();\n              Boolean b = (Boolean) condition.execute(context);\n              return b != null && b;\n            }\n          });\n    }\n    if (rejectedProjects != null) {\n      enumerable = enumerable.select(\n          new Function1<Row, Row>() {\n            final Object[] values = new Object[rejectedProjects.size()];\n            @Override public Row apply(Row row) {\n              final Object[] inValues = row.getValues();\n              for (int i = 0; i < rejectedProjects.size(); i++) {\n                values[i] = inValues[rejectedProjects.get(i)];\n              }\n              return Row.asCopy(values);\n            }\n          });\n    }\n    return new TableScanNode(compiler, rel, enumerable);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/interpreter/TableScanNode.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":238,"status":"M"},{"authorDate":"2017-08-06 15:29:03","commitOrder":5,"curCode":"    @Override public RelDataType deriveRowType() {\n      final RelDataTypeFactory.Builder builder =\n          getCluster().getTypeFactory().builder();\n      final List<RelDataTypeField> fieldList =\n          table.getRowType().getFieldList();\n      for (int project : projects) {\n        builder.add(fieldList.get(project));\n      }\n      return builder.build();\n    }\n","date":"2017-08-08 00:14:46","endLine":209,"groupId":"13034","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"deriveRowType","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e0/09cd148cf7bf2d229bddbc7dafa4c5db5d8c1e.src","preCode":"    @Override public RelDataType deriveRowType() {\n      final RelDataTypeFactory.Builder builder =\n          getCluster().getTypeFactory().builder();\n      final List<RelDataTypeField> fieldList =\n          table.getRowType().getFieldList();\n      for (int project : projects) {\n        builder.add(fieldList.get(project));\n      }\n      return builder.build();\n    }\n","realPath":"core/src/main/java/org/apache/calcite/interpreter/Bindables.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":200,"status":"N"}],"commitId":"d59b639d27da704f00eff616324a2c04aa06f84c","commitMessage":"@@@[CALCITE-2259] Allow Java 8 syntax\n\nIn summary: use lambdas where possible.  switch from Guava function\ntypes to Java function types or lambdas.  but continue to use Guava\ncomponents (such as immutable collections and cache) that have no\nequivalent in the Java runtime.\n\n1. Change single-abstract-method (SAM) classes to lambdas. Preserve\nformatting wherever possible.\n\n2. Change AssertQuery.returns argument type from Guava Function to Java\nConsumer. If you are using a lambda and see 'returns is deprecated'. \nremove the 'return null;' line.  and the lambda will become a Consumer\n(whose return is void).\n\n3. Change RelOptRuleOperand and RelOptRule.operand methods to take Java\nPredicate rather than Guava Predicate.\n\n4. Change the argument of Hook.add and .addThread from Guava Function to\nJava Consumer.\n\n5. Change 'list.toArray(new T[list.size()])' to 'list.toArray(new T[0])'\nbecause the latter is simpler.  and just as efficient on recent Java\nversions.\n\n6. Resource references; change \"try (Closeable ignore = foo())\" to \"try\n  (foo())\".  especially uses of TryThreadLocal and Hook.Closeable.\n\n7. Convert linq4j Function1 to java Function.  Function2 to java BiFunction\n\n8. Fix occurrences of Intellij's \"Explicit type can be replaced with\n<>\" inspection. (Occurs for \"List<String> list = new\nArrayList<String>();\".)\n\n9. Change Guava Preconditions.checkNotNull to Java\nObjects.requireNonNull. (Kevin Risden)\n\n10. Break out anonymous classes and fix dependency problems.\n\n11. Use CacheLoader.of(Function) where possible.\n\n12. Replace sub-classes of ThreadLocal with ThreadLocal.withInitial().\n\n13. Replace Guava collection methods with calls to Java collection types. \nfor example replace Lists.newArrayList() with new ArrayList<>(). \nMaps.newHashSet() with new HashSet<>().  similarly Sets.\n\n14. Replace Guava Joiner with String.join.\n\n15. Replace Collections.emptyList() with ImmutableList.of() in a few\nplaces.\n\nFor backwards compatibility.  we preserved (and deprecated) the old\nmethods that used Guava types. In a few cases where new and old have\nthe same signature (after erasure).  we could not add a method with the\nsame name.  so we gave the new method a \"J\" suffix. Examples include\nHook.property and .propertyJ.  RelOptRule.operand and .operandJ.\n\nIn test code.  we have not slavishly ensured backwards compatibility.\n\nWe do not intend to remove uses of Guava's immutable collections.\n\nWe have ignored Intellij's \"Pseudo functional style code\" inspection\nmost of the time.  but in a few cases have converted Lists.transform(). \nIterables.transform().  and Iterables.filter() into Java streams. Use\nthe Util.toImmutableList() collector if the result is to be an\nimmutable list. Use Util.transform() rather than Lists.transform()\nif you have a Java function rather than a Guava function or lambda.\n\nNot covered in this change (might be done in future):\n* Convert Collections.sort(list) to list.sort.\n* Review uses of 'for (Map.Entry<K.  V> e : map.entrySet())' and see\n  whether it makes sense to convert to 'map.forEach((k.  v) ->\n  ...)'. Intellij inspection is called 'Replace with Map.forEach'.\n\nBreaking changes:\n* LatticeStatisticProvider.Factory.  result of RexUtil.notFun().  and\n  arguments to Mappings.target() are Function (was Guava.  now Java)\n* Argument to SqlSpecialOperator.TokenSequence.parser() is Predicate\n  (was Guava.  now Java)\n* AggregateNode.AccumulatorFactory extends Supplier (was Guava.  now Java)\n","date":"2018-07-09 01:16:26","modifiedFileCount":"514","status":"M","submitter":"Julian Hyde"},{"authorTime":"2017-08-06 15:29:03","codes":[{"authorDate":"2018-09-28 09:34:22","commitOrder":6,"curCode":"  private static TableScanNode createEnumerable(Compiler compiler,\n      TableScan rel, Enumerable<Row> enumerable,\n      final ImmutableIntList acceptedProjects, List<RexNode> rejectedFilters,\n      final ImmutableIntList rejectedProjects) {\n    if (!rejectedFilters.isEmpty()) {\n      final RexNode filter =\n          RexUtil.composeConjunction(rel.getCluster().getRexBuilder(),\n              rejectedFilters);\n      \r\n      final RexNode filter2;\n      final RelDataType inputRowType;\n      if (acceptedProjects == null) {\n        filter2 = filter;\n        inputRowType = rel.getRowType();\n      } else {\n        final Mapping mapping = Mappings.target(acceptedProjects,\n            rel.getTable().getRowType().getFieldCount());\n        filter2 = RexUtil.apply(mapping, filter);\n        final RelDataTypeFactory.Builder builder =\n            rel.getCluster().getTypeFactory().builder();\n        final List<RelDataTypeField> fieldList =\n            rel.getTable().getRowType().getFieldList();\n        for (int acceptedProject : acceptedProjects) {\n          builder.add(fieldList.get(acceptedProject));\n        }\n        inputRowType = builder.build();\n      }\n      final Scalar condition =\n          compiler.compile(ImmutableList.of(filter2), inputRowType);\n      final Context context = compiler.createContext();\n      enumerable = enumerable.where(row -> {\n        context.values = row.getValues();\n        Boolean b = (Boolean) condition.execute(context);\n        return b != null && b;\n      });\n    }\n    if (rejectedProjects != null) {\n      enumerable = enumerable.select(\n          new Function1<Row, Row>() {\n            final Object[] values = new Object[rejectedProjects.size()];\n            @Override public Row apply(Row row) {\n              final Object[] inValues = row.getValues();\n              for (int i = 0; i < rejectedProjects.size(); i++) {\n                values[i] = inValues[rejectedProjects.get(i)];\n              }\n              return Row.asCopy(values);\n            }\n          });\n    }\n    return new TableScanNode(compiler, rel, enumerable);\n  }\n","date":"2018-10-08 04:34:53","endLine":288,"groupId":"1292","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"createEnumerable","params":"(Compilercompiler@TableScanrel@Enumerable<Row>enumerable@finalImmutableIntListacceptedProjects@List<RexNode>rejectedFilters@finalImmutableIntListrejectedProjects)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/a6/a2a4495c64893ca85fca3133e798a0a50de1fd.src","preCode":"  private static TableScanNode createEnumerable(Compiler compiler,\n      TableScan rel, Enumerable<Row> enumerable,\n      final ImmutableIntList acceptedProjects, List<RexNode> rejectedFilters,\n      final ImmutableIntList rejectedProjects) {\n    if (!rejectedFilters.isEmpty()) {\n      final RexNode filter =\n          RexUtil.composeConjunction(rel.getCluster().getRexBuilder(),\n              rejectedFilters, false);\n      assert filter != null;\n      \r\n      final RexNode filter2;\n      final RelDataType inputRowType;\n      if (acceptedProjects == null) {\n        filter2 = filter;\n        inputRowType = rel.getRowType();\n      } else {\n        final Mapping mapping = Mappings.target(acceptedProjects,\n            rel.getTable().getRowType().getFieldCount());\n        filter2 = RexUtil.apply(mapping, filter);\n        final RelDataTypeFactory.Builder builder =\n            rel.getCluster().getTypeFactory().builder();\n        final List<RelDataTypeField> fieldList =\n            rel.getTable().getRowType().getFieldList();\n        for (int acceptedProject : acceptedProjects) {\n          builder.add(fieldList.get(acceptedProject));\n        }\n        inputRowType = builder.build();\n      }\n      final Scalar condition =\n          compiler.compile(ImmutableList.of(filter2), inputRowType);\n      final Context context = compiler.createContext();\n      enumerable = enumerable.where(row -> {\n        context.values = row.getValues();\n        Boolean b = (Boolean) condition.execute(context);\n        return b != null && b;\n      });\n    }\n    if (rejectedProjects != null) {\n      enumerable = enumerable.select(\n          new Function1<Row, Row>() {\n            final Object[] values = new Object[rejectedProjects.size()];\n            @Override public Row apply(Row row) {\n              final Object[] inValues = row.getValues();\n              for (int i = 0; i < rejectedProjects.size(); i++) {\n                values[i] = inValues[rejectedProjects.get(i)];\n              }\n              return Row.asCopy(values);\n            }\n          });\n    }\n    return new TableScanNode(compiler, rel, enumerable);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/interpreter/TableScanNode.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":238,"status":"M"},{"authorDate":"2017-08-06 15:29:03","commitOrder":6,"curCode":"    @Override public RelDataType deriveRowType() {\n      final RelDataTypeFactory.Builder builder =\n          getCluster().getTypeFactory().builder();\n      final List<RelDataTypeField> fieldList =\n          table.getRowType().getFieldList();\n      for (int project : projects) {\n        builder.add(fieldList.get(project));\n      }\n      return builder.build();\n    }\n","date":"2017-08-08 00:14:46","endLine":209,"groupId":"13034","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"deriveRowType","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e0/09cd148cf7bf2d229bddbc7dafa4c5db5d8c1e.src","preCode":"    @Override public RelDataType deriveRowType() {\n      final RelDataTypeFactory.Builder builder =\n          getCluster().getTypeFactory().builder();\n      final List<RelDataTypeField> fieldList =\n          table.getRowType().getFieldList();\n      for (int project : projects) {\n        builder.add(fieldList.get(project));\n      }\n      return builder.build();\n    }\n","realPath":"core/src/main/java/org/apache/calcite/interpreter/Bindables.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":200,"status":"N"}],"commitId":"6b3844c0634792263a5073b8ea93565fb3415f41","commitMessage":"@@@[CALCITE-2604] When simplifying an expression.  say whether an UNKNOWN value will be interpreted as is.  or as TRUE or FALSE\n\nAdd class RexUnknownAs to describe policy.  and make it an argument to\ninternal methods; public methods such as RexSimplify.simplify(RexNode)\nand RexSimplify.simplifyAnds(Iterable) use UNKNOWN. (The RexSimplify\nconstructor that allows a different policy than UNKNOWN is deprecated. \nand even if you use the deprecated constructor.  that policy only\napplies to the top-level expression.  not arguments to it.)\n\nAdd RexSimplify.simplify(RexNode.  RexUnknownAs) (mainly for internal\nuse).  and RexSimplify.simplifyUnknownAsFalse(RexNode) (for public use).\n\nAdd variant of RexUtil.composeConjunction that never returns null. \nwith @Nonnull annotation.\n","date":"2018-10-08 04:34:53","modifiedFileCount":"28","status":"M","submitter":"Julian Hyde"},{"authorTime":"2017-08-06 15:29:03","codes":[{"authorDate":"2020-05-29 00:04:40","commitOrder":7,"curCode":"  private static TableScanNode createEnumerable(Compiler compiler,\n      TableScan rel, Enumerable<Row> enumerable,\n      final @Nullable ImmutableIntList acceptedProjects, List<RexNode> rejectedFilters,\n      final @Nullable ImmutableIntList rejectedProjects) {\n    if (!rejectedFilters.isEmpty()) {\n      final RexNode filter =\n          RexUtil.composeConjunction(rel.getCluster().getRexBuilder(),\n              rejectedFilters);\n      \r\n      final RexNode filter2;\n      final RelDataType inputRowType;\n      if (acceptedProjects == null) {\n        filter2 = filter;\n        inputRowType = rel.getRowType();\n      } else {\n        final Mapping mapping = Mappings.target(acceptedProjects,\n            rel.getTable().getRowType().getFieldCount());\n        filter2 = RexUtil.apply(mapping, filter);\n        final RelDataTypeFactory.Builder builder =\n            rel.getCluster().getTypeFactory().builder();\n        final List<RelDataTypeField> fieldList =\n            rel.getTable().getRowType().getFieldList();\n        for (int acceptedProject : acceptedProjects) {\n          builder.add(fieldList.get(acceptedProject));\n        }\n        inputRowType = builder.build();\n      }\n      final Scalar condition =\n          compiler.compile(ImmutableList.of(filter2), inputRowType);\n      final Context context = compiler.createContext();\n      enumerable = enumerable.where(row -> {\n        context.values = row.getValues();\n        Boolean b = (Boolean) condition.execute(context);\n        return b != null && b;\n      });\n    }\n    if (rejectedProjects != null) {\n      enumerable = enumerable.select(\n          new Function1<Row, Row>() {\n            final @Nullable Object[] values = new Object[rejectedProjects.size()];\n            @Override public Row apply(Row row) {\n              final @Nullable Object[] inValues = row.getValues();\n              for (int i = 0; i < rejectedProjects.size(); i++) {\n                values[i] = inValues[rejectedProjects.get(i)];\n              }\n              return Row.asCopy(values);\n            }\n          });\n    }\n    return new TableScanNode(compiler, rel, enumerable);\n  }\n","date":"2020-11-30 06:45:33","endLine":293,"groupId":"102175","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"createEnumerable","params":"(Compilercompiler@TableScanrel@Enumerable<Row>enumerable@final@NullableImmutableIntListacceptedProjects@List<RexNode>rejectedFilters@final@NullableImmutableIntListrejectedProjects)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/75/a5a930d51a0c59e23ef2d928517884952dcaa0.src","preCode":"  private static TableScanNode createEnumerable(Compiler compiler,\n      TableScan rel, Enumerable<Row> enumerable,\n      final ImmutableIntList acceptedProjects, List<RexNode> rejectedFilters,\n      final ImmutableIntList rejectedProjects) {\n    if (!rejectedFilters.isEmpty()) {\n      final RexNode filter =\n          RexUtil.composeConjunction(rel.getCluster().getRexBuilder(),\n              rejectedFilters);\n      \r\n      final RexNode filter2;\n      final RelDataType inputRowType;\n      if (acceptedProjects == null) {\n        filter2 = filter;\n        inputRowType = rel.getRowType();\n      } else {\n        final Mapping mapping = Mappings.target(acceptedProjects,\n            rel.getTable().getRowType().getFieldCount());\n        filter2 = RexUtil.apply(mapping, filter);\n        final RelDataTypeFactory.Builder builder =\n            rel.getCluster().getTypeFactory().builder();\n        final List<RelDataTypeField> fieldList =\n            rel.getTable().getRowType().getFieldList();\n        for (int acceptedProject : acceptedProjects) {\n          builder.add(fieldList.get(acceptedProject));\n        }\n        inputRowType = builder.build();\n      }\n      final Scalar condition =\n          compiler.compile(ImmutableList.of(filter2), inputRowType);\n      final Context context = compiler.createContext();\n      enumerable = enumerable.where(row -> {\n        context.values = row.getValues();\n        Boolean b = (Boolean) condition.execute(context);\n        return b != null && b;\n      });\n    }\n    if (rejectedProjects != null) {\n      enumerable = enumerable.select(\n          new Function1<Row, Row>() {\n            final Object[] values = new Object[rejectedProjects.size()];\n            @Override public Row apply(Row row) {\n              final Object[] inValues = row.getValues();\n              for (int i = 0; i < rejectedProjects.size(); i++) {\n                values[i] = inValues[rejectedProjects.get(i)];\n              }\n              return Row.asCopy(values);\n            }\n          });\n    }\n    return new TableScanNode(compiler, rel, enumerable);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/interpreter/TableScanNode.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":243,"status":"M"},{"authorDate":"2017-08-06 15:29:03","commitOrder":7,"curCode":"    @Override public RelDataType deriveRowType() {\n      final RelDataTypeFactory.Builder builder =\n          getCluster().getTypeFactory().builder();\n      final List<RelDataTypeField> fieldList =\n          table.getRowType().getFieldList();\n      for (int project : projects) {\n        builder.add(fieldList.get(project));\n      }\n      return builder.build();\n    }\n","date":"2017-08-08 00:14:46","endLine":209,"groupId":"102175","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"deriveRowType","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e0/09cd148cf7bf2d229bddbc7dafa4c5db5d8c1e.src","preCode":"    @Override public RelDataType deriveRowType() {\n      final RelDataTypeFactory.Builder builder =\n          getCluster().getTypeFactory().builder();\n      final List<RelDataTypeField> fieldList =\n          table.getRowType().getFieldList();\n      for (int project : projects) {\n        builder.add(fieldList.get(project));\n      }\n      return builder.build();\n    }\n","realPath":"core/src/main/java/org/apache/calcite/interpreter/Bindables.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":200,"status":"N"}],"commitId":"d9a81b88ad561e7e4cedae93e805e0d7a53a7f1a","commitMessage":"@@@[CALCITE-4199] Add nullability annotations\n\nThe commit includes javadoc updates and refactorings made by Julian Hyde in https://github.com/apache/calcite/pull/2278\n","date":"2020-11-30 06:45:33","modifiedFileCount":"1012","status":"M","submitter":"Vladimir Sitnikov"}]
