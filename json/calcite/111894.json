[{"authorTime":"2019-08-15 13:47:07","codes":[{"authorDate":"2016-07-29 07:22:43","commitOrder":3,"curCode":"  private static void splitCorrelatedFilterCondition(\n      LogicalFilter filter,\n      RexNode condition,\n      List<RexInputRef> joinKeys,\n      List<RexNode> correlatedJoinKeys,\n      List<RexNode> nonEquiList) {\n    if (condition instanceof RexCall) {\n      RexCall call = (RexCall) condition;\n      if (call.getOperator().getKind() == SqlKind.AND) {\n        for (RexNode operand : call.getOperands()) {\n          splitCorrelatedFilterCondition(\n              filter,\n              operand,\n              joinKeys,\n              correlatedJoinKeys,\n              nonEquiList);\n        }\n        return;\n      }\n\n      if (call.getOperator().getKind() == SqlKind.EQUALS) {\n        final List<RexNode> operands = call.getOperands();\n        RexNode op0 = operands.get(0);\n        RexNode op1 = operands.get(1);\n\n        if (!(RexUtil.containsInputRef(op0))\n            && (op1 instanceof RexInputRef)) {\n          correlatedJoinKeys.add(op0);\n          joinKeys.add((RexInputRef) op1);\n          return;\n        } else if (\n            (op0 instanceof RexInputRef)\n                && !(RexUtil.containsInputRef(op1))) {\n          joinKeys.add((RexInputRef) op0);\n          correlatedJoinKeys.add(op1);\n          return;\n        }\n      }\n    }\n\n    \r\n    \r\n    \r\n    nonEquiList.add(condition);\n  }\n","date":"2016-07-31 02:47:31","endLine":1302,"groupId":"14899","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"splitCorrelatedFilterCondition","params":"(LogicalFilterfilter@RexNodecondition@List<RexInputRef>joinKeys@List<RexNode>correlatedJoinKeys@List<RexNode>nonEquiList)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/03/40b1b85042db954809e494f06ab54b1a7a42bc.src","preCode":"  private static void splitCorrelatedFilterCondition(\n      LogicalFilter filter,\n      RexNode condition,\n      List<RexInputRef> joinKeys,\n      List<RexNode> correlatedJoinKeys,\n      List<RexNode> nonEquiList) {\n    if (condition instanceof RexCall) {\n      RexCall call = (RexCall) condition;\n      if (call.getOperator().getKind() == SqlKind.AND) {\n        for (RexNode operand : call.getOperands()) {\n          splitCorrelatedFilterCondition(\n              filter,\n              operand,\n              joinKeys,\n              correlatedJoinKeys,\n              nonEquiList);\n        }\n        return;\n      }\n\n      if (call.getOperator().getKind() == SqlKind.EQUALS) {\n        final List<RexNode> operands = call.getOperands();\n        RexNode op0 = operands.get(0);\n        RexNode op1 = operands.get(1);\n\n        if (!(RexUtil.containsInputRef(op0))\n            && (op1 instanceof RexInputRef)) {\n          correlatedJoinKeys.add(op0);\n          joinKeys.add((RexInputRef) op1);\n          return;\n        } else if (\n            (op0 instanceof RexInputRef)\n                && !(RexUtil.containsInputRef(op1))) {\n          joinKeys.add((RexInputRef) op0);\n          correlatedJoinKeys.add(op1);\n          return;\n        }\n      }\n    }\n\n    \r\n    \r\n    \r\n    nonEquiList.add(condition);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/plan/RelOptUtil.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1258,"status":"NB"},{"authorDate":"2019-08-15 13:47:07","commitOrder":3,"curCode":"  private static void splitCorrelatedFilterCondition(\n      Filter filter,\n      RexNode condition,\n      List<RexNode> joinKeys,\n      List<RexNode> correlatedJoinKeys,\n      List<RexNode> nonEquiList,\n      boolean extractCorrelatedFieldAccess) {\n    if (condition instanceof RexCall) {\n      RexCall call = (RexCall) condition;\n      if (call.getOperator().getKind() == SqlKind.AND) {\n        for (RexNode operand : call.getOperands()) {\n          splitCorrelatedFilterCondition(\n              filter,\n              operand,\n              joinKeys,\n              correlatedJoinKeys,\n              nonEquiList,\n              extractCorrelatedFieldAccess);\n        }\n        return;\n      }\n\n      if (call.getOperator().getKind() == SqlKind.EQUALS) {\n        final List<RexNode> operands = call.getOperands();\n        RexNode op0 = operands.get(0);\n        RexNode op1 = operands.get(1);\n\n        if (extractCorrelatedFieldAccess) {\n          if (!RexUtil.containsFieldAccess(op0)\n              && (op1 instanceof RexFieldAccess)) {\n            joinKeys.add(op0);\n            correlatedJoinKeys.add(op1);\n            return;\n          } else if (\n              (op0 instanceof RexFieldAccess)\n                  && !RexUtil.containsFieldAccess(op1)) {\n            correlatedJoinKeys.add(op0);\n            joinKeys.add(op1);\n            return;\n          }\n        } else {\n          if (!(RexUtil.containsInputRef(op0))\n              && (op1 instanceof RexInputRef)) {\n            correlatedJoinKeys.add(op0);\n            joinKeys.add(op1);\n            return;\n          } else if (\n              (op0 instanceof RexInputRef)\n                  && !(RexUtil.containsInputRef(op1))) {\n            joinKeys.add(op0);\n            correlatedJoinKeys.add(op1);\n            return;\n          }\n        }\n      }\n    }\n\n    \r\n    \r\n    \r\n    nonEquiList.add(condition);\n  }\n","date":"2019-08-21 01:58:52","endLine":1456,"groupId":"11018","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"splitCorrelatedFilterCondition","params":"(Filterfilter@RexNodecondition@List<RexNode>joinKeys@List<RexNode>correlatedJoinKeys@List<RexNode>nonEquiList@booleanextractCorrelatedFieldAccess)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/bc/cb0f5f537a3f575d0ea78cceb3f8ccba5f175b.src","preCode":"  private static void splitCorrelatedFilterCondition(\n      Filter filter,\n      RexNode condition,\n      List<RexNode> joinKeys,\n      List<RexNode> correlatedJoinKeys,\n      List<RexNode> nonEquiList,\n      boolean extractCorrelatedFieldAccess) {\n    if (condition instanceof RexCall) {\n      RexCall call = (RexCall) condition;\n      if (call.getOperator().getKind() == SqlKind.AND) {\n        for (RexNode operand : call.getOperands()) {\n          splitCorrelatedFilterCondition(\n              filter,\n              operand,\n              joinKeys,\n              correlatedJoinKeys,\n              nonEquiList,\n              extractCorrelatedFieldAccess);\n        }\n        return;\n      }\n\n      if (call.getOperator().getKind() == SqlKind.EQUALS) {\n        final List<RexNode> operands = call.getOperands();\n        RexNode op0 = operands.get(0);\n        RexNode op1 = operands.get(1);\n\n        if (extractCorrelatedFieldAccess) {\n          if (!RexUtil.containsFieldAccess(op0)\n              && (op1 instanceof RexFieldAccess)) {\n            joinKeys.add(op0);\n            correlatedJoinKeys.add(op1);\n            return;\n          } else if (\n              (op0 instanceof RexFieldAccess)\n                  && !RexUtil.containsFieldAccess(op1)) {\n            correlatedJoinKeys.add(op0);\n            joinKeys.add(op1);\n            return;\n          }\n        } else {\n          if (!(RexUtil.containsInputRef(op0))\n              && (op1 instanceof RexInputRef)) {\n            correlatedJoinKeys.add(op0);\n            joinKeys.add(op1);\n            return;\n          } else if (\n              (op0 instanceof RexInputRef)\n                  && !(RexUtil.containsInputRef(op1))) {\n            joinKeys.add(op0);\n            correlatedJoinKeys.add(op1);\n            return;\n          }\n        }\n      }\n    }\n\n    \r\n    \r\n    \r\n    nonEquiList.add(condition);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/plan/RelOptUtil.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1395,"status":"B"}],"commitId":"11116f6d03bca7cd97d151033c5d82f24394e229","commitMessage":"@@@[CALCITE-3111] Add RelBuilder.correlate method.  and allow custom implementations of Correlate in RelDecorrelator (Juhwan Kim)\n\nIn RelDecorrelator.  refactor all Logical rels into corresponding\nabstract rels.  and use given RelBuilder when creating a new rel.\nAdd abstract rel visitors in CorelMapBuilder.  and change access\nlevels to allow extending RelDecorrelator.\n\nClose apache/calcite#1334\n","date":"2019-08-21 01:58:52","modifiedFileCount":"6","status":"M","submitter":"Juhwan Kim"},{"authorTime":"2020-09-29 22:24:23","codes":[{"authorDate":"2020-09-29 22:24:23","commitOrder":4,"curCode":"  private static void splitCorrelatedFilterCondition(\n      LogicalFilter filter,\n      RexNode condition,\n      List<RexInputRef> joinKeys,\n      List<RexNode> correlatedJoinKeys,\n      List<RexNode> nonEquiList) {\n    if (condition instanceof RexCall) {\n      RexCall call = (RexCall) condition;\n      if (call.getOperator().getKind() == SqlKind.AND) {\n        for (RexNode operand : call.getOperands()) {\n          splitCorrelatedFilterCondition(\n              filter,\n              operand,\n              joinKeys,\n              correlatedJoinKeys,\n              nonEquiList);\n        }\n        return;\n      }\n\n      if (call.getOperator().getKind() == SqlKind.EQUALS) {\n        final List<RexNode> operands = call.getOperands();\n        RexNode op0 = operands.get(0);\n        RexNode op1 = operands.get(1);\n\n        if (!RexUtil.containsInputRef(op0)\n            && op1 instanceof RexInputRef) {\n          correlatedJoinKeys.add(op0);\n          joinKeys.add((RexInputRef) op1);\n          return;\n        } else if (\n            op0 instanceof RexInputRef\n                && !RexUtil.containsInputRef(op1)) {\n          joinKeys.add((RexInputRef) op0);\n          correlatedJoinKeys.add(op1);\n          return;\n        }\n      }\n    }\n\n    \r\n    \r\n    \r\n    nonEquiList.add(condition);\n  }\n","date":"2020-10-07 05:42:52","endLine":1536,"groupId":"111894","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"splitCorrelatedFilterCondition","params":"(LogicalFilterfilter@RexNodecondition@List<RexInputRef>joinKeys@List<RexNode>correlatedJoinKeys@List<RexNode>nonEquiList)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/13/dcc54e17f279ba1ae1daea5d0b182bd85e6938.src","preCode":"  private static void splitCorrelatedFilterCondition(\n      LogicalFilter filter,\n      RexNode condition,\n      List<RexInputRef> joinKeys,\n      List<RexNode> correlatedJoinKeys,\n      List<RexNode> nonEquiList) {\n    if (condition instanceof RexCall) {\n      RexCall call = (RexCall) condition;\n      if (call.getOperator().getKind() == SqlKind.AND) {\n        for (RexNode operand : call.getOperands()) {\n          splitCorrelatedFilterCondition(\n              filter,\n              operand,\n              joinKeys,\n              correlatedJoinKeys,\n              nonEquiList);\n        }\n        return;\n      }\n\n      if (call.getOperator().getKind() == SqlKind.EQUALS) {\n        final List<RexNode> operands = call.getOperands();\n        RexNode op0 = operands.get(0);\n        RexNode op1 = operands.get(1);\n\n        if (!(RexUtil.containsInputRef(op0))\n            && (op1 instanceof RexInputRef)) {\n          correlatedJoinKeys.add(op0);\n          joinKeys.add((RexInputRef) op1);\n          return;\n        } else if (\n            (op0 instanceof RexInputRef)\n                && !(RexUtil.containsInputRef(op1))) {\n          joinKeys.add((RexInputRef) op0);\n          correlatedJoinKeys.add(op1);\n          return;\n        }\n      }\n    }\n\n    \r\n    \r\n    \r\n    nonEquiList.add(condition);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/plan/RelOptUtil.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1492,"status":"M"},{"authorDate":"2020-09-29 22:24:23","commitOrder":4,"curCode":"  private static void splitCorrelatedFilterCondition(\n      Filter filter,\n      RexNode condition,\n      List<RexNode> joinKeys,\n      List<RexNode> correlatedJoinKeys,\n      List<RexNode> nonEquiList,\n      boolean extractCorrelatedFieldAccess) {\n    if (condition instanceof RexCall) {\n      RexCall call = (RexCall) condition;\n      if (call.getOperator().getKind() == SqlKind.AND) {\n        for (RexNode operand : call.getOperands()) {\n          splitCorrelatedFilterCondition(\n              filter,\n              operand,\n              joinKeys,\n              correlatedJoinKeys,\n              nonEquiList,\n              extractCorrelatedFieldAccess);\n        }\n        return;\n      }\n\n      if (call.getOperator().getKind() == SqlKind.EQUALS) {\n        final List<RexNode> operands = call.getOperands();\n        RexNode op0 = operands.get(0);\n        RexNode op1 = operands.get(1);\n\n        if (extractCorrelatedFieldAccess) {\n          if (!RexUtil.containsFieldAccess(op0)\n              && op1 instanceof RexFieldAccess) {\n            joinKeys.add(op0);\n            correlatedJoinKeys.add(op1);\n            return;\n          } else if (\n              op0 instanceof RexFieldAccess\n                  && !RexUtil.containsFieldAccess(op1)) {\n            correlatedJoinKeys.add(op0);\n            joinKeys.add(op1);\n            return;\n          }\n        } else {\n          if (!RexUtil.containsInputRef(op0)\n              && op1 instanceof RexInputRef) {\n            correlatedJoinKeys.add(op0);\n            joinKeys.add(op1);\n            return;\n          } else if (\n              op0 instanceof RexInputRef\n                  && !RexUtil.containsInputRef(op1)) {\n            joinKeys.add(op0);\n            correlatedJoinKeys.add(op1);\n            return;\n          }\n        }\n      }\n    }\n\n    \r\n    \r\n    \r\n    nonEquiList.add(condition);\n  }\n","date":"2020-10-07 05:42:52","endLine":1615,"groupId":"111894","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"splitCorrelatedFilterCondition","params":"(Filterfilter@RexNodecondition@List<RexNode>joinKeys@List<RexNode>correlatedJoinKeys@List<RexNode>nonEquiList@booleanextractCorrelatedFieldAccess)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/13/dcc54e17f279ba1ae1daea5d0b182bd85e6938.src","preCode":"  private static void splitCorrelatedFilterCondition(\n      Filter filter,\n      RexNode condition,\n      List<RexNode> joinKeys,\n      List<RexNode> correlatedJoinKeys,\n      List<RexNode> nonEquiList,\n      boolean extractCorrelatedFieldAccess) {\n    if (condition instanceof RexCall) {\n      RexCall call = (RexCall) condition;\n      if (call.getOperator().getKind() == SqlKind.AND) {\n        for (RexNode operand : call.getOperands()) {\n          splitCorrelatedFilterCondition(\n              filter,\n              operand,\n              joinKeys,\n              correlatedJoinKeys,\n              nonEquiList,\n              extractCorrelatedFieldAccess);\n        }\n        return;\n      }\n\n      if (call.getOperator().getKind() == SqlKind.EQUALS) {\n        final List<RexNode> operands = call.getOperands();\n        RexNode op0 = operands.get(0);\n        RexNode op1 = operands.get(1);\n\n        if (extractCorrelatedFieldAccess) {\n          if (!RexUtil.containsFieldAccess(op0)\n              && (op1 instanceof RexFieldAccess)) {\n            joinKeys.add(op0);\n            correlatedJoinKeys.add(op1);\n            return;\n          } else if (\n              (op0 instanceof RexFieldAccess)\n                  && !RexUtil.containsFieldAccess(op1)) {\n            correlatedJoinKeys.add(op0);\n            joinKeys.add(op1);\n            return;\n          }\n        } else {\n          if (!(RexUtil.containsInputRef(op0))\n              && (op1 instanceof RexInputRef)) {\n            correlatedJoinKeys.add(op0);\n            joinKeys.add(op1);\n            return;\n          } else if (\n              (op0 instanceof RexInputRef)\n                  && !(RexUtil.containsInputRef(op1))) {\n            joinKeys.add(op0);\n            correlatedJoinKeys.add(op1);\n            return;\n          }\n        }\n      }\n    }\n\n    \r\n    \r\n    \r\n    nonEquiList.add(condition);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/plan/RelOptUtil.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1554,"status":"M"}],"commitId":"b5a94de7d270ecd0defbb7475d797d0e48649955","commitMessage":"@@@[CALCITE-4314] Remove unnecessary parentheses\n\nSee https://errorprone.info/bugpattern/UnnecessaryParentheses\n","date":"2020-10-07 05:42:52","modifiedFileCount":"18","status":"M","submitter":"Vladimir Sitnikov"}]
