[{"authorTime":"2014-11-14 09:39:29","codes":[{"authorDate":"2014-11-14 09:39:29","commitOrder":1,"curCode":"  public static <E> Queryable<E> queryable(DataContext root, Class<E> clazz,\n      Iterable<? extends String> names) {\n    SchemaPlus schema = root.getRootSchema();\n    for (Iterator<? extends String> iterator = names.iterator();;) {\n      String name = iterator.next();\n      if (iterator.hasNext()) {\n        schema = schema.getSubSchema(name);\n      } else {\n        return queryable(root, schema, clazz, name);\n      }\n    }\n  }\n","date":"2014-11-14 09:39:34","endLine":205,"groupId":"5617","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"queryable","params":"(DataContextroot@Class<E>clazz@Iterable<?extendsString>names)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/00/233d7a4e8fc4c4edbdbb97fad65bbad7312f3f.src","preCode":"  public static <E> Queryable<E> queryable(DataContext root, Class<E> clazz,\n      Iterable<? extends String> names) {\n    SchemaPlus schema = root.getRootSchema();\n    for (Iterator<? extends String> iterator = names.iterator();;) {\n      String name = iterator.next();\n      if (iterator.hasNext()) {\n        schema = schema.getSubSchema(name);\n      } else {\n        return queryable(root, schema, clazz, name);\n      }\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/schema/Schemas.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":194,"status":"B"},{"authorDate":"2014-11-14 09:39:29","commitOrder":1,"curCode":"  public static Table table(DataContext root, String... names) {\n    SchemaPlus schema = root.getRootSchema();\n    final List<String> nameList = Arrays.asList(names);\n    for (Iterator<? extends String> iterator = nameList.iterator();;) {\n      String name = iterator.next();\n      if (iterator.hasNext()) {\n        schema = schema.getSubSchema(name);\n      } else {\n        return schema.getTable(name);\n      }\n    }\n  }\n","date":"2014-11-14 09:39:34","endLine":243,"groupId":"8595","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"table","params":"(DataContextroot@String...names)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/00/233d7a4e8fc4c4edbdbb97fad65bbad7312f3f.src","preCode":"  public static Table table(DataContext root, String... names) {\n    SchemaPlus schema = root.getRootSchema();\n    final List<String> nameList = Arrays.asList(names);\n    for (Iterator<? extends String> iterator = nameList.iterator();;) {\n      String name = iterator.next();\n      if (iterator.hasNext()) {\n        schema = schema.getSubSchema(name);\n      } else {\n        return schema.getTable(name);\n      }\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/schema/Schemas.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":232,"status":"B"}],"commitId":"a611d645ad754844a39f3d98f5f814f13dbd9404","commitMessage":"@@@[CALCITE-296] Re-organize package structure;\n[CALCITE-419] Naming convention for planner rules\n\nThis change only renames files (and deletes some obsolete files). There are no content changes.\n","date":"2014-11-14 09:39:34","modifiedFileCount":"0","status":"B","submitter":"Julian Hyde"},{"authorTime":"2020-05-29 00:04:40","codes":[{"authorDate":"2020-05-29 00:04:40","commitOrder":2,"curCode":"  public static <E> Queryable<E> queryable(DataContext root, Class<E> clazz,\n      Iterable<? extends String> names) {\n    SchemaPlus schema = root.getRootSchema();\n    for (Iterator<? extends String> iterator = names.iterator();;) {\n      String name = iterator.next();\n      requireNonNull(schema, \"schema\");\n      if (iterator.hasNext()) {\n        SchemaPlus next = schema.getSubSchema(name);\n        if (next == null) {\n          throw new IllegalArgumentException(\"schema \" + name + \" is not found in \" + schema);\n        }\n        schema = next;\n      } else {\n        return queryable(root, schema, clazz, name);\n      }\n    }\n  }\n","date":"2020-11-30 06:45:33","endLine":215,"groupId":"121702","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"queryable","params":"(DataContextroot@Class<E>clazz@Iterable<?extendsString>names)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/f8/57ba3fc4f73ea14187abbe1a95d51dc8a39d61.src","preCode":"  public static <E> Queryable<E> queryable(DataContext root, Class<E> clazz,\n      Iterable<? extends String> names) {\n    SchemaPlus schema = root.getRootSchema();\n    for (Iterator<? extends String> iterator = names.iterator();;) {\n      String name = iterator.next();\n      if (iterator.hasNext()) {\n        schema = schema.getSubSchema(name);\n      } else {\n        return queryable(root, schema, clazz, name);\n      }\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/schema/Schemas.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":199,"status":"M"},{"authorDate":"2020-05-29 00:04:40","commitOrder":2,"curCode":"  public static @Nullable Table table(DataContext root, String... names) {\n    SchemaPlus schema = root.getRootSchema();\n    final List<String> nameList = Arrays.asList(names);\n    for (Iterator<? extends String> iterator = nameList.iterator();;) {\n      String name = iterator.next();\n      requireNonNull(schema, \"schema\");\n      if (iterator.hasNext()) {\n        SchemaPlus next = schema.getSubSchema(name);\n        if (next == null) {\n          throw new IllegalArgumentException(\"schema \" + name + \" is not found in \" + schema);\n        }\n        schema = next;\n      } else {\n        return schema.getTable(name);\n      }\n    }\n  }\n","date":"2020-11-30 06:45:33","endLine":280,"groupId":"121702","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"table","params":"(DataContextroot@String...names)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/f8/57ba3fc4f73ea14187abbe1a95d51dc8a39d61.src","preCode":"  public static Table table(DataContext root, String... names) {\n    SchemaPlus schema = root.getRootSchema();\n    final List<String> nameList = Arrays.asList(names);\n    for (Iterator<? extends String> iterator = nameList.iterator();;) {\n      String name = iterator.next();\n      if (iterator.hasNext()) {\n        schema = schema.getSubSchema(name);\n      } else {\n        return schema.getTable(name);\n      }\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/schema/Schemas.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":264,"status":"M"}],"commitId":"d9a81b88ad561e7e4cedae93e805e0d7a53a7f1a","commitMessage":"@@@[CALCITE-4199] Add nullability annotations\n\nThe commit includes javadoc updates and refactorings made by Julian Hyde in https://github.com/apache/calcite/pull/2278\n","date":"2020-11-30 06:45:33","modifiedFileCount":"1012","status":"M","submitter":"Vladimir Sitnikov"}]
