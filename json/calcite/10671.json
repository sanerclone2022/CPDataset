[{"authorTime":"2015-02-07 04:47:45","codes":[{"authorDate":"2014-11-14 10:41:22","commitOrder":3,"curCode":"  public String checkTpchQuery(String tpchTestQuery) throws Exception {\n    final SchemaPlus schema =\n        Frameworks.createRootSchema(true).add(\"tpch\",\n            new ReflectiveSchema(new TpchSchema()));\n\n    final FrameworkConfig config = Frameworks.newConfigBuilder()\n        .parserConfig(SqlParser.configBuilder().setLex(Lex.MYSQL).build())\n        .defaultSchema(schema)\n        .programs(Programs.ofRules(Programs.RULE_SET))\n        .build();\n    Planner p = Frameworks.getPlanner(config);\n    SqlNode n = p.parse(tpchTestQuery);\n    n = p.validate(n);\n    RelNode r = p.convert(n);\n    String plan = RelOptUtil.toString(r);\n    p.close();\n    return plan;\n  }\n","date":"2014-11-22 11:14:04","endLine":878,"groupId":"14821","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"checkTpchQuery","params":"(StringtpchTestQuery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/6c/fb1176595a10a4d7dd7494f2e64b98671f183e.src","preCode":"  public String checkTpchQuery(String tpchTestQuery) throws Exception {\n    final SchemaPlus schema =\n        Frameworks.createRootSchema(true).add(\"tpch\",\n            new ReflectiveSchema(new TpchSchema()));\n\n    final FrameworkConfig config = Frameworks.newConfigBuilder()\n        .parserConfig(SqlParser.configBuilder().setLex(Lex.MYSQL).build())\n        .defaultSchema(schema)\n        .programs(Programs.ofRules(Programs.RULE_SET))\n        .build();\n    Planner p = Frameworks.getPlanner(config);\n    SqlNode n = p.parse(tpchTestQuery);\n    n = p.validate(n);\n    RelNode r = p.convert(n);\n    String plan = RelOptUtil.toString(r);\n    p.close();\n    return plan;\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":861,"status":"NB"},{"authorDate":"2015-02-07 04:47:45","commitOrder":3,"curCode":"  @Test public void testOrderByNonSelectColumn() throws Exception {\n    final SchemaPlus schema = Frameworks.createRootSchema(true)\n        .add(\"tpch\", new ReflectiveSchema(new TpchSchema()));\n\n    String query = \"select t.psPartkey from \\n\"\n      + \"(select ps.psPartkey from `tpch`.`partsupp` ps \\n\"\n      + \"order by ps.psPartkey, ps.psSupplyCost) t \\n\"\n      + \"order by t.psPartkey\";\n\n    List<RelTraitDef> traitDefs = new ArrayList<RelTraitDef>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n    final SqlParser.Config parserConfig =\n        SqlParser.configBuilder().setLex(Lex.MYSQL).build();\n    Planner p = Frameworks.getPlanner(\n        Frameworks.newConfigBuilder()\n            .parserConfig(parserConfig)\n            .defaultSchema(schema)\n            .traitDefs(traitDefs)\n            .programs(Programs.ofRules(Programs.RULE_SET))\n            .build());\n    SqlNode n = p.parse(query);\n    n = p.validate(n);\n    RelNode r = p.convert(n);\n    String plan = RelOptUtil.toString(r);\n    plan = Util.toLinux(plan);\n    p.close();\n    assertThat(plan,\n        equalTo(\"LogicalSort(sort0=[$0], dir0=[ASC])\\n\"\n        + \"  LogicalProject(psPartkey=[$0])\\n\"\n        + \"    LogicalProject(psPartkey=[$0])\\n\"\n        + \"      LogicalSort(sort0=[$0], sort1=[$1], dir0=[ASC], dir1=[ASC])\\n\"\n        + \"        LogicalProject(psPartkey=[$0], psSupplyCost=[$1])\\n\"\n        + \"          EnumerableTableScan(table=[[tpch, partsupp]])\\n\"));\n  }\n","date":"2015-02-08 16:23:01","endLine":949,"groupId":"468","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testOrderByNonSelectColumn","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/54/bee88aa245288ce3d7f28b7ed2419aab2892a3.src","preCode":"  @Test public void testOrderByNonSelectColumn() throws Exception {\n    final SchemaPlus schema = Frameworks.createRootSchema(true)\n        .add(\"tpch\", new ReflectiveSchema(new TpchSchema()));\n\n    String query = \"select t.psPartkey from \\n\"\n      + \"(select ps.psPartkey from `tpch`.`partsupp` ps \\n\"\n      + \"order by ps.psPartkey, ps.psSupplyCost) t \\n\"\n      + \"order by t.psPartkey\";\n\n    List<RelTraitDef> traitDefs = new ArrayList<RelTraitDef>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n    final SqlParser.Config parserConfig =\n        SqlParser.configBuilder().setLex(Lex.MYSQL).build();\n    Planner p = Frameworks.getPlanner(\n        Frameworks.newConfigBuilder()\n            .parserConfig(parserConfig)\n            .defaultSchema(schema)\n            .traitDefs(traitDefs)\n            .programs(Programs.ofRules(Programs.RULE_SET))\n            .build());\n    SqlNode n = p.parse(query);\n    n = p.validate(n);\n    RelNode r = p.convert(n);\n    String plan = RelOptUtil.toString(r);\n    plan = Util.toLinux(plan);\n    p.close();\n    assertThat(plan,\n        equalTo(\"LogicalSort(sort0=[$0], dir0=[ASC])\\n\"\n        + \"  LogicalProject(psPartkey=[$0])\\n\"\n        + \"    LogicalProject(psPartkey=[$0])\\n\"\n        + \"      LogicalSort(sort0=[$0], sort1=[$1], dir0=[ASC], dir1=[ASC])\\n\"\n        + \"        LogicalProject(psPartkey=[$0], psSupplyCost=[$1])\\n\"\n        + \"          EnumerableTableScan(table=[[tpch, partsupp]])\\n\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":915,"status":"B"}],"commitId":"c0120dd80bfe5e5fb077a5b631efbccb35afd9eb","commitMessage":"@@@[CALCITE-569] ArrayIndexOutOfBoundsException when deducing collation (Aman Sinha)\n\nThis commit adds a test case. Although Aman's patch provided a fix.  Julian Hyde had already fixed the issue as part of [CALCITE-88].\n","date":"2015-02-08 16:23:01","modifiedFileCount":"1","status":"M","submitter":"Julian Hyde"},{"authorTime":"2015-03-27 10:35:34","codes":[{"authorDate":"2014-11-14 10:41:22","commitOrder":4,"curCode":"  public String checkTpchQuery(String tpchTestQuery) throws Exception {\n    final SchemaPlus schema =\n        Frameworks.createRootSchema(true).add(\"tpch\",\n            new ReflectiveSchema(new TpchSchema()));\n\n    final FrameworkConfig config = Frameworks.newConfigBuilder()\n        .parserConfig(SqlParser.configBuilder().setLex(Lex.MYSQL).build())\n        .defaultSchema(schema)\n        .programs(Programs.ofRules(Programs.RULE_SET))\n        .build();\n    Planner p = Frameworks.getPlanner(config);\n    SqlNode n = p.parse(tpchTestQuery);\n    n = p.validate(n);\n    RelNode r = p.convert(n);\n    String plan = RelOptUtil.toString(r);\n    p.close();\n    return plan;\n  }\n","date":"2014-11-22 11:14:04","endLine":878,"groupId":"14821","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"checkTpchQuery","params":"(StringtpchTestQuery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/6c/fb1176595a10a4d7dd7494f2e64b98671f183e.src","preCode":"  public String checkTpchQuery(String tpchTestQuery) throws Exception {\n    final SchemaPlus schema =\n        Frameworks.createRootSchema(true).add(\"tpch\",\n            new ReflectiveSchema(new TpchSchema()));\n\n    final FrameworkConfig config = Frameworks.newConfigBuilder()\n        .parserConfig(SqlParser.configBuilder().setLex(Lex.MYSQL).build())\n        .defaultSchema(schema)\n        .programs(Programs.ofRules(Programs.RULE_SET))\n        .build();\n    Planner p = Frameworks.getPlanner(config);\n    SqlNode n = p.parse(tpchTestQuery);\n    n = p.validate(n);\n    RelNode r = p.convert(n);\n    String plan = RelOptUtil.toString(r);\n    p.close();\n    return plan;\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":861,"status":"N"},{"authorDate":"2015-03-27 10:35:34","commitOrder":4,"curCode":"  @Test public void testOrderByNonSelectColumn() throws Exception {\n    final SchemaPlus schema = Frameworks.createRootSchema(true)\n        .add(\"tpch\", new ReflectiveSchema(new TpchSchema()));\n\n    String query = \"select t.psPartkey from \\n\"\n      + \"(select ps.psPartkey from `tpch`.`partsupp` ps \\n\"\n      + \"order by ps.psPartkey, ps.psSupplyCost) t \\n\"\n      + \"order by t.psPartkey\";\n\n    List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n    final SqlParser.Config parserConfig =\n        SqlParser.configBuilder().setLex(Lex.MYSQL).build();\n    Planner p = Frameworks.getPlanner(\n        Frameworks.newConfigBuilder()\n            .parserConfig(parserConfig)\n            .defaultSchema(schema)\n            .traitDefs(traitDefs)\n            .programs(Programs.ofRules(Programs.RULE_SET))\n            .build());\n    SqlNode n = p.parse(query);\n    n = p.validate(n);\n    RelNode r = p.convert(n);\n    String plan = RelOptUtil.toString(r);\n    plan = Util.toLinux(plan);\n    p.close();\n    assertThat(plan,\n        equalTo(\"LogicalSort(sort0=[$0], dir0=[ASC])\\n\"\n        + \"  LogicalProject(psPartkey=[$0])\\n\"\n        + \"    LogicalProject(psPartkey=[$0])\\n\"\n        + \"      LogicalSort(sort0=[$0], sort1=[$1], dir0=[ASC], dir1=[ASC])\\n\"\n        + \"        LogicalProject(psPartkey=[$0], psSupplyCost=[$1])\\n\"\n        + \"          EnumerableTableScan(table=[[tpch, partsupp]])\\n\"));\n  }\n","date":"2015-03-27 10:35:34","endLine":1009,"groupId":"468","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testOrderByNonSelectColumn","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/ff/6094ab5b9ff4cb1733e212bf7b4354fff59c7c.src","preCode":"  @Test public void testOrderByNonSelectColumn() throws Exception {\n    final SchemaPlus schema = Frameworks.createRootSchema(true)\n        .add(\"tpch\", new ReflectiveSchema(new TpchSchema()));\n\n    String query = \"select t.psPartkey from \\n\"\n      + \"(select ps.psPartkey from `tpch`.`partsupp` ps \\n\"\n      + \"order by ps.psPartkey, ps.psSupplyCost) t \\n\"\n      + \"order by t.psPartkey\";\n\n    List<RelTraitDef> traitDefs = new ArrayList<RelTraitDef>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n    final SqlParser.Config parserConfig =\n        SqlParser.configBuilder().setLex(Lex.MYSQL).build();\n    Planner p = Frameworks.getPlanner(\n        Frameworks.newConfigBuilder()\n            .parserConfig(parserConfig)\n            .defaultSchema(schema)\n            .traitDefs(traitDefs)\n            .programs(Programs.ofRules(Programs.RULE_SET))\n            .build());\n    SqlNode n = p.parse(query);\n    n = p.validate(n);\n    RelNode r = p.convert(n);\n    String plan = RelOptUtil.toString(r);\n    plan = Util.toLinux(plan);\n    p.close();\n    assertThat(plan,\n        equalTo(\"LogicalSort(sort0=[$0], dir0=[ASC])\\n\"\n        + \"  LogicalProject(psPartkey=[$0])\\n\"\n        + \"    LogicalProject(psPartkey=[$0])\\n\"\n        + \"      LogicalSort(sort0=[$0], sort1=[$1], dir0=[ASC], dir1=[ASC])\\n\"\n        + \"        LogicalProject(psPartkey=[$0], psSupplyCost=[$1])\\n\"\n        + \"          EnumerableTableScan(table=[[tpch, partsupp]])\\n\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":975,"status":"M"}],"commitId":"a24b3c1f0877db1da64108af9bceb3e7023dc049","commitMessage":"@@@[CALCITE-648] Update ProjectMergeRule description for new naming convention (Jinfeng Ni)\n","date":"2015-03-27 10:35:34","modifiedFileCount":"2","status":"M","submitter":"Julian Hyde"},{"authorTime":"2015-09-11 10:27:49","codes":[{"authorDate":"2015-09-11 10:27:49","commitOrder":5,"curCode":"  public String checkTpchQuery(String tpchTestQuery) throws Exception {\n    final SchemaPlus schema =\n        Frameworks.createRootSchema(true).add(\"tpch\",\n            new ReflectiveSchema(new TpchSchema()));\n\n    final FrameworkConfig config = Frameworks.newConfigBuilder()\n        .parserConfig(SqlParser.configBuilder().setLex(Lex.MYSQL).build())\n        .defaultSchema(schema)\n        .programs(Programs.ofRules(Programs.RULE_SET))\n        .build();\n    Planner p = Frameworks.getPlanner(config);\n    SqlNode n = p.parse(tpchTestQuery);\n    n = p.validate(n);\n    RelNode r = p.rel(n).project();\n    String plan = RelOptUtil.toString(r);\n    p.close();\n    return plan;\n  }\n","date":"2016-01-10 16:51:24","endLine":1001,"groupId":"14821","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"checkTpchQuery","params":"(StringtpchTestQuery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/fa/e8cb9c44f03dfb56fb3288ee677e1dcf600f2a.src","preCode":"  public String checkTpchQuery(String tpchTestQuery) throws Exception {\n    final SchemaPlus schema =\n        Frameworks.createRootSchema(true).add(\"tpch\",\n            new ReflectiveSchema(new TpchSchema()));\n\n    final FrameworkConfig config = Frameworks.newConfigBuilder()\n        .parserConfig(SqlParser.configBuilder().setLex(Lex.MYSQL).build())\n        .defaultSchema(schema)\n        .programs(Programs.ofRules(Programs.RULE_SET))\n        .build();\n    Planner p = Frameworks.getPlanner(config);\n    SqlNode n = p.parse(tpchTestQuery);\n    n = p.validate(n);\n    RelNode r = p.convert(n);\n    String plan = RelOptUtil.toString(r);\n    p.close();\n    return plan;\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":984,"status":"M"},{"authorDate":"2015-09-11 10:27:49","commitOrder":5,"curCode":"  @Test public void testOrderByNonSelectColumn() throws Exception {\n    final SchemaPlus schema = Frameworks.createRootSchema(true)\n        .add(\"tpch\", new ReflectiveSchema(new TpchSchema()));\n\n    String query = \"select t.psPartkey from \\n\"\n      + \"(select ps.psPartkey from `tpch`.`partsupp` ps \\n\"\n      + \"order by ps.psPartkey, ps.psSupplyCost) t \\n\"\n      + \"order by t.psPartkey\";\n\n    List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n    final SqlParser.Config parserConfig =\n        SqlParser.configBuilder().setLex(Lex.MYSQL).build();\n    Planner p = Frameworks.getPlanner(\n        Frameworks.newConfigBuilder()\n            .parserConfig(parserConfig)\n            .defaultSchema(schema)\n            .traitDefs(traitDefs)\n            .programs(Programs.ofRules(Programs.RULE_SET))\n            .build());\n    SqlNode n = p.parse(query);\n    n = p.validate(n);\n    RelNode r = p.rel(n).project();\n    String plan = RelOptUtil.toString(r);\n    plan = Util.toLinux(plan);\n    p.close();\n    assertThat(plan,\n        equalTo(\"LogicalSort(sort0=[$0], dir0=[ASC])\\n\"\n        + \"  LogicalProject(psPartkey=[$0])\\n\"\n        + \"    LogicalProject(psPartkey=[$0])\\n\"\n        + \"      LogicalSort(sort0=[$0], sort1=[$1], dir0=[ASC], dir1=[ASC])\\n\"\n        + \"        LogicalProject(psPartkey=[$0], psSupplyCost=[$1])\\n\"\n        + \"          EnumerableTableScan(table=[[tpch, partsupp]])\\n\"));\n  }\n","date":"2016-01-10 16:51:24","endLine":1066,"groupId":"468","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testOrderByNonSelectColumn","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/fa/e8cb9c44f03dfb56fb3288ee677e1dcf600f2a.src","preCode":"  @Test public void testOrderByNonSelectColumn() throws Exception {\n    final SchemaPlus schema = Frameworks.createRootSchema(true)\n        .add(\"tpch\", new ReflectiveSchema(new TpchSchema()));\n\n    String query = \"select t.psPartkey from \\n\"\n      + \"(select ps.psPartkey from `tpch`.`partsupp` ps \\n\"\n      + \"order by ps.psPartkey, ps.psSupplyCost) t \\n\"\n      + \"order by t.psPartkey\";\n\n    List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n    final SqlParser.Config parserConfig =\n        SqlParser.configBuilder().setLex(Lex.MYSQL).build();\n    Planner p = Frameworks.getPlanner(\n        Frameworks.newConfigBuilder()\n            .parserConfig(parserConfig)\n            .defaultSchema(schema)\n            .traitDefs(traitDefs)\n            .programs(Programs.ofRules(Programs.RULE_SET))\n            .build());\n    SqlNode n = p.parse(query);\n    n = p.validate(n);\n    RelNode r = p.convert(n);\n    String plan = RelOptUtil.toString(r);\n    plan = Util.toLinux(plan);\n    p.close();\n    assertThat(plan,\n        equalTo(\"LogicalSort(sort0=[$0], dir0=[ASC])\\n\"\n        + \"  LogicalProject(psPartkey=[$0])\\n\"\n        + \"    LogicalProject(psPartkey=[$0])\\n\"\n        + \"      LogicalSort(sort0=[$0], sort1=[$1], dir0=[ASC], dir1=[ASC])\\n\"\n        + \"        LogicalProject(psPartkey=[$0], psSupplyCost=[$1])\\n\"\n        + \"          EnumerableTableScan(table=[[tpch, partsupp]])\\n\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1032,"status":"M"}],"commitId":"4ae0298688d402484be7c76610e46c6f610a8bc6","commitMessage":"@@@Deprecate some Util methods.  and upgrade last modules to JDK 1.7\n","date":"2016-01-10 16:51:24","modifiedFileCount":"6","status":"M","submitter":"Julian Hyde"},{"authorTime":"2016-10-22 14:17:28","codes":[{"authorDate":"2016-10-22 14:17:28","commitOrder":6,"curCode":"  public String checkTpchQuery(String tpchTestQuery) throws Exception {\n    final SchemaPlus schema =\n        Frameworks.createRootSchema(true).add(\"tpch\",\n            new ReflectiveSchema(new TpchSchema()));\n\n    final FrameworkConfig config = Frameworks.newConfigBuilder()\n        .parserConfig(SqlParser.configBuilder().setLex(Lex.MYSQL).build())\n        .defaultSchema(schema)\n        .programs(Programs.ofRules(Programs.RULE_SET))\n        .build();\n    String plan;\n    try (Planner p = Frameworks.getPlanner(config)) {\n      SqlNode n = p.parse(tpchTestQuery);\n      n = p.validate(n);\n      RelNode r = p.rel(n).project();\n      plan = RelOptUtil.toString(r);\n    }\n    return plan;\n  }\n","date":"2016-11-01 16:54:04","endLine":1032,"groupId":"4527","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"checkTpchQuery","params":"(StringtpchTestQuery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/01/c8f94a8e7b430051c6cec330383c9733ec491b.src","preCode":"  public String checkTpchQuery(String tpchTestQuery) throws Exception {\n    final SchemaPlus schema =\n        Frameworks.createRootSchema(true).add(\"tpch\",\n            new ReflectiveSchema(new TpchSchema()));\n\n    final FrameworkConfig config = Frameworks.newConfigBuilder()\n        .parserConfig(SqlParser.configBuilder().setLex(Lex.MYSQL).build())\n        .defaultSchema(schema)\n        .programs(Programs.ofRules(Programs.RULE_SET))\n        .build();\n    Planner p = Frameworks.getPlanner(config);\n    SqlNode n = p.parse(tpchTestQuery);\n    n = p.validate(n);\n    RelNode r = p.rel(n).project();\n    String plan = RelOptUtil.toString(r);\n    p.close();\n    return plan;\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1014,"status":"M"},{"authorDate":"2016-10-22 14:17:28","commitOrder":6,"curCode":"  @Test public void testOrderByNonSelectColumn() throws Exception {\n    final SchemaPlus schema = Frameworks.createRootSchema(true)\n        .add(\"tpch\", new ReflectiveSchema(new TpchSchema()));\n\n    String query = \"select t.psPartkey from \\n\"\n      + \"(select ps.psPartkey from `tpch`.`partsupp` ps \\n\"\n      + \"order by ps.psPartkey, ps.psSupplyCost) t \\n\"\n      + \"order by t.psPartkey\";\n\n    List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n    final SqlParser.Config parserConfig =\n        SqlParser.configBuilder().setLex(Lex.MYSQL).build();\n    FrameworkConfig config = Frameworks.newConfigBuilder()\n      .parserConfig(parserConfig)\n      .defaultSchema(schema)\n      .traitDefs(traitDefs)\n      .programs(Programs.ofRules(Programs.RULE_SET))\n      .build();\n    String plan;\n    try (Planner p = Frameworks.getPlanner(config)) {\n      SqlNode n = p.parse(query);\n      n = p.validate(n);\n      RelNode r = p.rel(n).project();\n      plan = RelOptUtil.toString(r);\n      plan = Util.toLinux(plan);\n    }\n    assertThat(plan,\n        equalTo(\"LogicalSort(sort0=[$0], dir0=[ASC])\\n\"\n        + \"  LogicalProject(psPartkey=[$0])\\n\"\n        + \"    LogicalProject(psPartkey=[$0])\\n\"\n        + \"      LogicalSort(sort0=[$0], sort1=[$1], dir0=[ASC], dir1=[ASC])\\n\"\n        + \"        LogicalProject(psPartkey=[$0], psSupplyCost=[$1])\\n\"\n        + \"          EnumerableTableScan(table=[[tpch, partsupp]])\\n\"));\n  }\n","date":"2016-11-01 16:54:04","endLine":1098,"groupId":"6521","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testOrderByNonSelectColumn","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/01/c8f94a8e7b430051c6cec330383c9733ec491b.src","preCode":"  @Test public void testOrderByNonSelectColumn() throws Exception {\n    final SchemaPlus schema = Frameworks.createRootSchema(true)\n        .add(\"tpch\", new ReflectiveSchema(new TpchSchema()));\n\n    String query = \"select t.psPartkey from \\n\"\n      + \"(select ps.psPartkey from `tpch`.`partsupp` ps \\n\"\n      + \"order by ps.psPartkey, ps.psSupplyCost) t \\n\"\n      + \"order by t.psPartkey\";\n\n    List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n    final SqlParser.Config parserConfig =\n        SqlParser.configBuilder().setLex(Lex.MYSQL).build();\n    Planner p = Frameworks.getPlanner(\n        Frameworks.newConfigBuilder()\n            .parserConfig(parserConfig)\n            .defaultSchema(schema)\n            .traitDefs(traitDefs)\n            .programs(Programs.ofRules(Programs.RULE_SET))\n            .build());\n    SqlNode n = p.parse(query);\n    n = p.validate(n);\n    RelNode r = p.rel(n).project();\n    String plan = RelOptUtil.toString(r);\n    plan = Util.toLinux(plan);\n    p.close();\n    assertThat(plan,\n        equalTo(\"LogicalSort(sort0=[$0], dir0=[ASC])\\n\"\n        + \"  LogicalProject(psPartkey=[$0])\\n\"\n        + \"    LogicalProject(psPartkey=[$0])\\n\"\n        + \"      LogicalSort(sort0=[$0], sort1=[$1], dir0=[ASC], dir1=[ASC])\\n\"\n        + \"        LogicalProject(psPartkey=[$0], psSupplyCost=[$1])\\n\"\n        + \"          EnumerableTableScan(table=[[tpch, partsupp]])\\n\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1063,"status":"M"}],"commitId":"6378fa6889a2527f13ef70a223ee4ee305bb51fb","commitMessage":"@@@[CALCITE-1416] Make classes implement AutoCloseable where possible (Chinmay Kolhatkar)\n\nClasses include Planner.  Interpreter.  Source.  Hook.Closeable.  SqlTesterImpl.\n\nAdd class Closer.  which closes AutoCloseable resources (Julian Hyde).\n\nClose apache/calcite#316\n","date":"2016-11-01 16:54:04","modifiedFileCount":"8","status":"M","submitter":"Chinmay Kolhatkar"},{"authorTime":"2018-08-16 16:26:13","codes":[{"authorDate":"2016-10-22 14:17:28","commitOrder":7,"curCode":"  public String checkTpchQuery(String tpchTestQuery) throws Exception {\n    final SchemaPlus schema =\n        Frameworks.createRootSchema(true).add(\"tpch\",\n            new ReflectiveSchema(new TpchSchema()));\n\n    final FrameworkConfig config = Frameworks.newConfigBuilder()\n        .parserConfig(SqlParser.configBuilder().setLex(Lex.MYSQL).build())\n        .defaultSchema(schema)\n        .programs(Programs.ofRules(Programs.RULE_SET))\n        .build();\n    String plan;\n    try (Planner p = Frameworks.getPlanner(config)) {\n      SqlNode n = p.parse(tpchTestQuery);\n      n = p.validate(n);\n      RelNode r = p.rel(n).project();\n      plan = RelOptUtil.toString(r);\n    }\n    return plan;\n  }\n","date":"2016-11-01 16:54:04","endLine":1032,"groupId":"4527","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"checkTpchQuery","params":"(StringtpchTestQuery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/01/c8f94a8e7b430051c6cec330383c9733ec491b.src","preCode":"  public String checkTpchQuery(String tpchTestQuery) throws Exception {\n    final SchemaPlus schema =\n        Frameworks.createRootSchema(true).add(\"tpch\",\n            new ReflectiveSchema(new TpchSchema()));\n\n    final FrameworkConfig config = Frameworks.newConfigBuilder()\n        .parserConfig(SqlParser.configBuilder().setLex(Lex.MYSQL).build())\n        .defaultSchema(schema)\n        .programs(Programs.ofRules(Programs.RULE_SET))\n        .build();\n    String plan;\n    try (Planner p = Frameworks.getPlanner(config)) {\n      SqlNode n = p.parse(tpchTestQuery);\n      n = p.validate(n);\n      RelNode r = p.rel(n).project();\n      plan = RelOptUtil.toString(r);\n    }\n    return plan;\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1014,"status":"N"},{"authorDate":"2018-08-16 16:26:13","commitOrder":7,"curCode":"  @Test public void testOrderByNonSelectColumn() throws Exception {\n    final SchemaPlus schema = Frameworks.createRootSchema(true)\n        .add(\"tpch\", new ReflectiveSchema(new TpchSchema()));\n\n    String query = \"select t.psPartkey from \\n\"\n        + \"(select ps.psPartkey from `tpch`.`partsupp` ps \\n\"\n        + \"order by ps.psPartkey, ps.psSupplyCost) t \\n\"\n        + \"order by t.psPartkey\";\n\n    List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n    final SqlParser.Config parserConfig =\n        SqlParser.configBuilder().setLex(Lex.MYSQL).build();\n    FrameworkConfig config = Frameworks.newConfigBuilder()\n        .parserConfig(parserConfig)\n        .defaultSchema(schema)\n        .traitDefs(traitDefs)\n        .programs(Programs.ofRules(Programs.RULE_SET))\n        .build();\n    String plan;\n    try (Planner p = Frameworks.getPlanner(config)) {\n      SqlNode n = p.parse(query);\n      n = p.validate(n);\n      RelNode r = p.rel(n).project();\n      plan = RelOptUtil.toString(r);\n      plan = Util.toLinux(plan);\n    }\n    assertThat(plan,\n        equalTo(\"LogicalSort(sort0=[$0], dir0=[ASC])\\n\"\n        + \"  LogicalProject(psPartkey=[$0])\\n\"\n        + \"    LogicalSort(sort0=[$0], sort1=[$1], dir0=[ASC], dir1=[ASC])\\n\"\n        + \"      LogicalProject(psPartkey=[$0], psSupplyCost=[$1])\\n\"\n        + \"        EnumerableTableScan(table=[[tpch, partsupp]])\\n\"));\n  }\n","date":"2018-08-31 14:03:22","endLine":1123,"groupId":"6521","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testOrderByNonSelectColumn","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/04/c3746ce6836a5dc6290963724749e86b45dcdc.src","preCode":"  @Test public void testOrderByNonSelectColumn() throws Exception {\n    final SchemaPlus schema = Frameworks.createRootSchema(true)\n        .add(\"tpch\", new ReflectiveSchema(new TpchSchema()));\n\n    String query = \"select t.psPartkey from \\n\"\n        + \"(select ps.psPartkey from `tpch`.`partsupp` ps \\n\"\n        + \"order by ps.psPartkey, ps.psSupplyCost) t \\n\"\n        + \"order by t.psPartkey\";\n\n    List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n    final SqlParser.Config parserConfig =\n        SqlParser.configBuilder().setLex(Lex.MYSQL).build();\n    FrameworkConfig config = Frameworks.newConfigBuilder()\n        .parserConfig(parserConfig)\n        .defaultSchema(schema)\n        .traitDefs(traitDefs)\n        .programs(Programs.ofRules(Programs.RULE_SET))\n        .build();\n    String plan;\n    try (Planner p = Frameworks.getPlanner(config)) {\n      SqlNode n = p.parse(query);\n      n = p.validate(n);\n      RelNode r = p.rel(n).project();\n      plan = RelOptUtil.toString(r);\n      plan = Util.toLinux(plan);\n    }\n    assertThat(plan,\n        equalTo(\"LogicalSort(sort0=[$0], dir0=[ASC])\\n\"\n        + \"  LogicalProject(psPartkey=[$0])\\n\"\n        + \"    LogicalProject(psPartkey=[$0])\\n\"\n        + \"      LogicalSort(sort0=[$0], sort1=[$1], dir0=[ASC], dir1=[ASC])\\n\"\n        + \"        LogicalProject(psPartkey=[$0], psSupplyCost=[$1])\\n\"\n        + \"          EnumerableTableScan(table=[[tpch, partsupp]])\\n\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1089,"status":"M"}],"commitId":"370e95ab8557946023ce209e975e1c321765559e","commitMessage":"@@@[CALCITE-2470] In RelBuilder.  project method should combine expressions if the underlying node is a Project\n\nAdd RelBuilder.shouldMergeProject() to allow sub-classes to disable\nmerging.\n\nImprove the message given by CompositeMatcher when match fails.\n\nWhen RelStructuredTypeFlattener rewrites a RexInputRef be sure to use\nthe field's new type. (It might have strengthened from say INTEGER to\nINTEGER NOT NULL.)\n\nAdd a test case inspired by Drill (it passes in Calcite.  but I gather\nit fails in Drill).\n","date":"2018-08-31 14:03:22","modifiedFileCount":"13","status":"M","submitter":"Julian Hyde"},{"authorTime":"2019-01-31 09:12:38","codes":[{"authorDate":"2016-10-22 14:17:28","commitOrder":8,"curCode":"  public String checkTpchQuery(String tpchTestQuery) throws Exception {\n    final SchemaPlus schema =\n        Frameworks.createRootSchema(true).add(\"tpch\",\n            new ReflectiveSchema(new TpchSchema()));\n\n    final FrameworkConfig config = Frameworks.newConfigBuilder()\n        .parserConfig(SqlParser.configBuilder().setLex(Lex.MYSQL).build())\n        .defaultSchema(schema)\n        .programs(Programs.ofRules(Programs.RULE_SET))\n        .build();\n    String plan;\n    try (Planner p = Frameworks.getPlanner(config)) {\n      SqlNode n = p.parse(tpchTestQuery);\n      n = p.validate(n);\n      RelNode r = p.rel(n).project();\n      plan = RelOptUtil.toString(r);\n    }\n    return plan;\n  }\n","date":"2016-11-01 16:54:04","endLine":1032,"groupId":"4527","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"checkTpchQuery","params":"(StringtpchTestQuery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/01/c8f94a8e7b430051c6cec330383c9733ec491b.src","preCode":"  public String checkTpchQuery(String tpchTestQuery) throws Exception {\n    final SchemaPlus schema =\n        Frameworks.createRootSchema(true).add(\"tpch\",\n            new ReflectiveSchema(new TpchSchema()));\n\n    final FrameworkConfig config = Frameworks.newConfigBuilder()\n        .parserConfig(SqlParser.configBuilder().setLex(Lex.MYSQL).build())\n        .defaultSchema(schema)\n        .programs(Programs.ofRules(Programs.RULE_SET))\n        .build();\n    String plan;\n    try (Planner p = Frameworks.getPlanner(config)) {\n      SqlNode n = p.parse(tpchTestQuery);\n      n = p.validate(n);\n      RelNode r = p.rel(n).project();\n      plan = RelOptUtil.toString(r);\n    }\n    return plan;\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1014,"status":"N"},{"authorDate":"2019-01-31 09:12:38","commitOrder":8,"curCode":"  @Test public void testOrderByNonSelectColumn() throws Exception {\n    final SchemaPlus schema = Frameworks.createRootSchema(true)\n        .add(\"tpch\", new ReflectiveSchema(new TpchSchema()));\n\n    String query = \"select t.psPartkey from \\n\"\n        + \"(select ps.psPartkey from `tpch`.`partsupp` ps \\n\"\n        + \"order by ps.psPartkey, ps.psSupplyCost) t \\n\"\n        + \"order by t.psPartkey\";\n\n    List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n    final SqlParser.Config parserConfig =\n        SqlParser.configBuilder().setLex(Lex.MYSQL).build();\n    FrameworkConfig config = Frameworks.newConfigBuilder()\n        .parserConfig(parserConfig)\n        .defaultSchema(schema)\n        .traitDefs(traitDefs)\n        .programs(Programs.ofRules(Programs.RULE_SET))\n        .build();\n    String plan;\n    try (Planner p = Frameworks.getPlanner(config)) {\n      SqlNode n = p.parse(query);\n      n = p.validate(n);\n      RelNode r = p.rel(n).project();\n      plan = RelOptUtil.toString(r);\n      plan = Util.toLinux(plan);\n    }\n    assertThat(plan,\n        equalTo(\"LogicalSort(sort0=[$0], dir0=[ASC])\\n\"\n        + \"  LogicalProject(psPartkey=[$0])\\n\"\n        + \"    EnumerableTableScan(table=[[tpch, partsupp]])\\n\"));\n  }\n","date":"2019-02-01 02:17:36","endLine":1177,"groupId":"6521","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testOrderByNonSelectColumn","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/bb/706f7d11ab6449cb4909bf3e1a8f8d3ea20c67.src","preCode":"  @Test public void testOrderByNonSelectColumn() throws Exception {\n    final SchemaPlus schema = Frameworks.createRootSchema(true)\n        .add(\"tpch\", new ReflectiveSchema(new TpchSchema()));\n\n    String query = \"select t.psPartkey from \\n\"\n        + \"(select ps.psPartkey from `tpch`.`partsupp` ps \\n\"\n        + \"order by ps.psPartkey, ps.psSupplyCost) t \\n\"\n        + \"order by t.psPartkey\";\n\n    List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n    final SqlParser.Config parserConfig =\n        SqlParser.configBuilder().setLex(Lex.MYSQL).build();\n    FrameworkConfig config = Frameworks.newConfigBuilder()\n        .parserConfig(parserConfig)\n        .defaultSchema(schema)\n        .traitDefs(traitDefs)\n        .programs(Programs.ofRules(Programs.RULE_SET))\n        .build();\n    String plan;\n    try (Planner p = Frameworks.getPlanner(config)) {\n      SqlNode n = p.parse(query);\n      n = p.validate(n);\n      RelNode r = p.rel(n).project();\n      plan = RelOptUtil.toString(r);\n      plan = Util.toLinux(plan);\n    }\n    assertThat(plan,\n        equalTo(\"LogicalSort(sort0=[$0], dir0=[ASC])\\n\"\n        + \"  LogicalProject(psPartkey=[$0])\\n\"\n        + \"    LogicalSort(sort0=[$0], sort1=[$1], dir0=[ASC], dir1=[ASC])\\n\"\n        + \"      LogicalProject(psPartkey=[$0], psSupplyCost=[$1])\\n\"\n        + \"        EnumerableTableScan(table=[[tpch, partsupp]])\\n\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1145,"status":"M"}],"commitId":"cf363b5989d35bd8b4d5f14c7a99acea6e9f0f5a","commitMessage":"@@@[CALCITE-2798] Remove ORDER BY in sub-query.  provided it has no LIMIT or OFFSET.  during SQL-to-RelNode conversion (Haisheng Yuan)\n\nStandard SQL says that ORDER BY in sub-queries should have no effect;\nusually we prefer to make optimizations via planner rules.  but we do\nthis change in SqlToRelConverter because a planner rule would have\ndifficulty telling whether a RelNode's consumers care about the order\nin which it produces records.\n\nClose apache/calcite#1021\n","date":"2019-02-01 02:17:36","modifiedFileCount":"3","status":"M","submitter":"Haisheng Yuan"},{"authorTime":"2020-02-07 17:06:16","codes":[{"authorDate":"2016-10-22 14:17:28","commitOrder":9,"curCode":"  public String checkTpchQuery(String tpchTestQuery) throws Exception {\n    final SchemaPlus schema =\n        Frameworks.createRootSchema(true).add(\"tpch\",\n            new ReflectiveSchema(new TpchSchema()));\n\n    final FrameworkConfig config = Frameworks.newConfigBuilder()\n        .parserConfig(SqlParser.configBuilder().setLex(Lex.MYSQL).build())\n        .defaultSchema(schema)\n        .programs(Programs.ofRules(Programs.RULE_SET))\n        .build();\n    String plan;\n    try (Planner p = Frameworks.getPlanner(config)) {\n      SqlNode n = p.parse(tpchTestQuery);\n      n = p.validate(n);\n      RelNode r = p.rel(n).project();\n      plan = RelOptUtil.toString(r);\n    }\n    return plan;\n  }\n","date":"2016-11-01 16:54:04","endLine":1032,"groupId":"4527","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"checkTpchQuery","params":"(StringtpchTestQuery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/01/c8f94a8e7b430051c6cec330383c9733ec491b.src","preCode":"  public String checkTpchQuery(String tpchTestQuery) throws Exception {\n    final SchemaPlus schema =\n        Frameworks.createRootSchema(true).add(\"tpch\",\n            new ReflectiveSchema(new TpchSchema()));\n\n    final FrameworkConfig config = Frameworks.newConfigBuilder()\n        .parserConfig(SqlParser.configBuilder().setLex(Lex.MYSQL).build())\n        .defaultSchema(schema)\n        .programs(Programs.ofRules(Programs.RULE_SET))\n        .build();\n    String plan;\n    try (Planner p = Frameworks.getPlanner(config)) {\n      SqlNode n = p.parse(tpchTestQuery);\n      n = p.validate(n);\n      RelNode r = p.rel(n).project();\n      plan = RelOptUtil.toString(r);\n    }\n    return plan;\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1014,"status":"N"},{"authorDate":"2020-02-07 17:06:16","commitOrder":9,"curCode":"  @Test public void testOrderByNonSelectColumn() throws Exception {\n    final SchemaPlus schema = Frameworks.createRootSchema(true)\n        .add(\"tpch\", new ReflectiveSchema(new TpchSchema()));\n\n    String query = \"select t.psPartkey from\\n\"\n        + \"(select ps.psPartkey from `tpch`.`partsupp` ps\\n\"\n        + \"order by ps.psPartkey, ps.psSupplyCost) t\\n\"\n        + \"order by t.psPartkey\";\n\n    List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n    final SqlParser.Config parserConfig =\n        SqlParser.configBuilder().setLex(Lex.MYSQL).build();\n    FrameworkConfig config = Frameworks.newConfigBuilder()\n        .parserConfig(parserConfig)\n        .defaultSchema(schema)\n        .traitDefs(traitDefs)\n        .programs(Programs.ofRules(Programs.RULE_SET))\n        .build();\n    String plan;\n    try (Planner p = Frameworks.getPlanner(config)) {\n      SqlNode n = p.parse(query);\n      n = p.validate(n);\n      RelNode r = p.rel(n).project();\n      plan = RelOptUtil.toString(r);\n      plan = Util.toLinux(plan);\n    }\n    assertThat(plan,\n        equalTo(\"LogicalSort(sort0=[$0], dir0=[ASC])\\n\"\n        + \"  LogicalProject(psPartkey=[$0])\\n\"\n        + \"    LogicalTableScan(table=[[tpch, partsupp]])\\n\"));\n  }\n","date":"2020-02-14 10:24:24","endLine":1381,"groupId":"6521","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testOrderByNonSelectColumn","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/5d/edb3162d1dca61baa746a07f0a95890cfe9982.src","preCode":"  @Test public void testOrderByNonSelectColumn() throws Exception {\n    final SchemaPlus schema = Frameworks.createRootSchema(true)\n        .add(\"tpch\", new ReflectiveSchema(new TpchSchema()));\n\n    String query = \"select t.psPartkey from\\n\"\n        + \"(select ps.psPartkey from `tpch`.`partsupp` ps\\n\"\n        + \"order by ps.psPartkey, ps.psSupplyCost) t\\n\"\n        + \"order by t.psPartkey\";\n\n    List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n    final SqlParser.Config parserConfig =\n        SqlParser.configBuilder().setLex(Lex.MYSQL).build();\n    FrameworkConfig config = Frameworks.newConfigBuilder()\n        .parserConfig(parserConfig)\n        .defaultSchema(schema)\n        .traitDefs(traitDefs)\n        .programs(Programs.ofRules(Programs.RULE_SET))\n        .build();\n    String plan;\n    try (Planner p = Frameworks.getPlanner(config)) {\n      SqlNode n = p.parse(query);\n      n = p.validate(n);\n      RelNode r = p.rel(n).project();\n      plan = RelOptUtil.toString(r);\n      plan = Util.toLinux(plan);\n    }\n    assertThat(plan,\n        equalTo(\"LogicalSort(sort0=[$0], dir0=[ASC])\\n\"\n        + \"  LogicalProject(psPartkey=[$0])\\n\"\n        + \"    EnumerableTableScan(table=[[tpch, partsupp]])\\n\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1349,"status":"M"}],"commitId":"6a322f9fff51362744b326246e49590f850449bb","commitMessage":"@@@[CALCITE-3769] Deprecate TableScanRule\n\n* Deprecate TableScanRule and always invoke RelOptTable#toRel for\nRelBuilder#scan\n* RelOptTableImpl#toRel does not translate to EnumerableTableScan\nanymore.  the EnumerableTableScan conversion logic has been moved to\nEnumerableTableScanRule\n* Remove the BindableTableScanRule from the default prepare ruleset.  we\nonly add it where we really need that\n* Fix the plan change\n","date":"2020-02-14 10:24:24","modifiedFileCount":"21","status":"M","submitter":"yuzhao.cyz"},{"authorTime":"2020-04-02 10:39:10","codes":[{"authorDate":"2016-10-22 14:17:28","commitOrder":10,"curCode":"  public String checkTpchQuery(String tpchTestQuery) throws Exception {\n    final SchemaPlus schema =\n        Frameworks.createRootSchema(true).add(\"tpch\",\n            new ReflectiveSchema(new TpchSchema()));\n\n    final FrameworkConfig config = Frameworks.newConfigBuilder()\n        .parserConfig(SqlParser.configBuilder().setLex(Lex.MYSQL).build())\n        .defaultSchema(schema)\n        .programs(Programs.ofRules(Programs.RULE_SET))\n        .build();\n    String plan;\n    try (Planner p = Frameworks.getPlanner(config)) {\n      SqlNode n = p.parse(tpchTestQuery);\n      n = p.validate(n);\n      RelNode r = p.rel(n).project();\n      plan = RelOptUtil.toString(r);\n    }\n    return plan;\n  }\n","date":"2016-11-01 16:54:04","endLine":1032,"groupId":"4527","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"checkTpchQuery","params":"(StringtpchTestQuery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/01/c8f94a8e7b430051c6cec330383c9733ec491b.src","preCode":"  public String checkTpchQuery(String tpchTestQuery) throws Exception {\n    final SchemaPlus schema =\n        Frameworks.createRootSchema(true).add(\"tpch\",\n            new ReflectiveSchema(new TpchSchema()));\n\n    final FrameworkConfig config = Frameworks.newConfigBuilder()\n        .parserConfig(SqlParser.configBuilder().setLex(Lex.MYSQL).build())\n        .defaultSchema(schema)\n        .programs(Programs.ofRules(Programs.RULE_SET))\n        .build();\n    String plan;\n    try (Planner p = Frameworks.getPlanner(config)) {\n      SqlNode n = p.parse(tpchTestQuery);\n      n = p.validate(n);\n      RelNode r = p.rel(n).project();\n      plan = RelOptUtil.toString(r);\n    }\n    return plan;\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1014,"status":"N"},{"authorDate":"2020-04-02 10:39:10","commitOrder":10,"curCode":"  @Test void testOrderByNonSelectColumn() throws Exception {\n    final SchemaPlus schema = Frameworks.createRootSchema(true)\n        .add(\"tpch\", new ReflectiveSchema(new TpchSchema()));\n\n    String query = \"select t.psPartkey from\\n\"\n        + \"(select ps.psPartkey from `tpch`.`partsupp` ps\\n\"\n        + \"order by ps.psPartkey, ps.psSupplyCost) t\\n\"\n        + \"order by t.psPartkey\";\n\n    List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n    final SqlParser.Config parserConfig =\n        SqlParser.configBuilder().setLex(Lex.MYSQL).build();\n    FrameworkConfig config = Frameworks.newConfigBuilder()\n        .parserConfig(parserConfig)\n        .defaultSchema(schema)\n        .traitDefs(traitDefs)\n        .programs(Programs.ofRules(Programs.RULE_SET))\n        .build();\n    String plan;\n    try (Planner p = Frameworks.getPlanner(config)) {\n      SqlNode n = p.parse(query);\n      n = p.validate(n);\n      RelNode r = p.rel(n).project();\n      plan = RelOptUtil.toString(r);\n      plan = Util.toLinux(plan);\n    }\n    assertThat(plan,\n        equalTo(\"LogicalSort(sort0=[$0], dir0=[ASC])\\n\"\n        + \"  LogicalProject(psPartkey=[$0])\\n\"\n        + \"    LogicalTableScan(table=[[tpch, partsupp]])\\n\"));\n  }\n","date":"2020-04-06 04:57:49","endLine":1381,"groupId":"6521","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testOrderByNonSelectColumn","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e6/ce8a05eee1dbae94fa526e1af77f6e77e09e4d.src","preCode":"  @Test public void testOrderByNonSelectColumn() throws Exception {\n    final SchemaPlus schema = Frameworks.createRootSchema(true)\n        .add(\"tpch\", new ReflectiveSchema(new TpchSchema()));\n\n    String query = \"select t.psPartkey from\\n\"\n        + \"(select ps.psPartkey from `tpch`.`partsupp` ps\\n\"\n        + \"order by ps.psPartkey, ps.psSupplyCost) t\\n\"\n        + \"order by t.psPartkey\";\n\n    List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n    final SqlParser.Config parserConfig =\n        SqlParser.configBuilder().setLex(Lex.MYSQL).build();\n    FrameworkConfig config = Frameworks.newConfigBuilder()\n        .parserConfig(parserConfig)\n        .defaultSchema(schema)\n        .traitDefs(traitDefs)\n        .programs(Programs.ofRules(Programs.RULE_SET))\n        .build();\n    String plan;\n    try (Planner p = Frameworks.getPlanner(config)) {\n      SqlNode n = p.parse(query);\n      n = p.validate(n);\n      RelNode r = p.rel(n).project();\n      plan = RelOptUtil.toString(r);\n      plan = Util.toLinux(plan);\n    }\n    assertThat(plan,\n        equalTo(\"LogicalSort(sort0=[$0], dir0=[ASC])\\n\"\n        + \"  LogicalProject(psPartkey=[$0])\\n\"\n        + \"    LogicalTableScan(table=[[tpch, partsupp]])\\n\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1349,"status":"M"}],"commitId":"9492dd4146f63ddc028010d6c4e86f6a5cb29a8d","commitMessage":"@@@[CALCITE-3892] Make junit test classes and methods non-public where possible\n\nPrior to junit 5.  classes and methods had to be public. This is no\nlonger the case.\n\nSome classes need to remain public because they are referenced from\nelsewhere.  or if they use reflection somehow. The remaining 'public'\nkeyword will be informative to maintainers.\n","date":"2020-04-06 04:57:49","modifiedFileCount":"196","status":"M","submitter":"Julian Hyde"},{"authorTime":"2020-09-11 16:38:46","codes":[{"authorDate":"2020-09-11 16:38:46","commitOrder":11,"curCode":"  public String checkTpchQuery(String tpchTestQuery) throws Exception {\n    final SchemaPlus schema =\n        Frameworks.createRootSchema(true).add(\"tpch\",\n            new ReflectiveSchema(new TpchSchema()));\n\n    final FrameworkConfig config = Frameworks.newConfigBuilder()\n        .parserConfig(SqlParser.config().withLex(Lex.MYSQL))\n        .defaultSchema(schema)\n        .programs(Programs.ofRules(Programs.RULE_SET))\n        .build();\n    String plan;\n    try (Planner p = Frameworks.getPlanner(config)) {\n      SqlNode n = p.parse(tpchTestQuery);\n      n = p.validate(n);\n      RelNode r = p.rel(n).project();\n      plan = RelOptUtil.toString(r);\n    }\n    return plan;\n  }\n","date":"2020-09-18 10:35:31","endLine":1359,"groupId":"10671","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"checkTpchQuery","params":"(StringtpchTestQuery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/03/a9ab1f8a8a67910d06bc98002d9c26e58df02c.src","preCode":"  public String checkTpchQuery(String tpchTestQuery) throws Exception {\n    final SchemaPlus schema =\n        Frameworks.createRootSchema(true).add(\"tpch\",\n            new ReflectiveSchema(new TpchSchema()));\n\n    final FrameworkConfig config = Frameworks.newConfigBuilder()\n        .parserConfig(SqlParser.configBuilder().setLex(Lex.MYSQL).build())\n        .defaultSchema(schema)\n        .programs(Programs.ofRules(Programs.RULE_SET))\n        .build();\n    String plan;\n    try (Planner p = Frameworks.getPlanner(config)) {\n      SqlNode n = p.parse(tpchTestQuery);\n      n = p.validate(n);\n      RelNode r = p.rel(n).project();\n      plan = RelOptUtil.toString(r);\n    }\n    return plan;\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1341,"status":"M"},{"authorDate":"2020-09-11 16:38:46","commitOrder":11,"curCode":"  @Test void testOrderByNonSelectColumn() throws Exception {\n    final SchemaPlus schema = Frameworks.createRootSchema(true)\n        .add(\"tpch\", new ReflectiveSchema(new TpchSchema()));\n\n    String query = \"select t.psPartkey from\\n\"\n        + \"(select ps.psPartkey from `tpch`.`partsupp` ps\\n\"\n        + \"order by ps.psPartkey, ps.psSupplyCost) t\\n\"\n        + \"order by t.psPartkey\";\n\n    List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n    final SqlParser.Config parserConfig = SqlParser.config().withLex(Lex.MYSQL);\n    FrameworkConfig config = Frameworks.newConfigBuilder()\n        .parserConfig(parserConfig)\n        .defaultSchema(schema)\n        .traitDefs(traitDefs)\n        .programs(Programs.ofRules(Programs.RULE_SET))\n        .build();\n    String plan;\n    try (Planner p = Frameworks.getPlanner(config)) {\n      SqlNode n = p.parse(query);\n      n = p.validate(n);\n      RelNode r = p.rel(n).project();\n      plan = RelOptUtil.toString(r);\n      plan = Util.toLinux(plan);\n    }\n    assertThat(plan,\n        equalTo(\"LogicalSort(sort0=[$0], dir0=[ASC])\\n\"\n        + \"  LogicalProject(psPartkey=[$0])\\n\"\n        + \"    LogicalTableScan(table=[[tpch, partsupp]])\\n\"));\n  }\n","date":"2020-09-18 10:35:31","endLine":1424,"groupId":"10671","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"testOrderByNonSelectColumn","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/03/a9ab1f8a8a67910d06bc98002d9c26e58df02c.src","preCode":"  @Test void testOrderByNonSelectColumn() throws Exception {\n    final SchemaPlus schema = Frameworks.createRootSchema(true)\n        .add(\"tpch\", new ReflectiveSchema(new TpchSchema()));\n\n    String query = \"select t.psPartkey from\\n\"\n        + \"(select ps.psPartkey from `tpch`.`partsupp` ps\\n\"\n        + \"order by ps.psPartkey, ps.psSupplyCost) t\\n\"\n        + \"order by t.psPartkey\";\n\n    List<RelTraitDef> traitDefs = new ArrayList<>();\n    traitDefs.add(ConventionTraitDef.INSTANCE);\n    traitDefs.add(RelCollationTraitDef.INSTANCE);\n    final SqlParser.Config parserConfig =\n        SqlParser.configBuilder().setLex(Lex.MYSQL).build();\n    FrameworkConfig config = Frameworks.newConfigBuilder()\n        .parserConfig(parserConfig)\n        .defaultSchema(schema)\n        .traitDefs(traitDefs)\n        .programs(Programs.ofRules(Programs.RULE_SET))\n        .build();\n    String plan;\n    try (Planner p = Frameworks.getPlanner(config)) {\n      SqlNode n = p.parse(query);\n      n = p.validate(n);\n      RelNode r = p.rel(n).project();\n      plan = RelOptUtil.toString(r);\n      plan = Util.toLinux(plan);\n    }\n    assertThat(plan,\n        equalTo(\"LogicalSort(sort0=[$0], dir0=[ASC])\\n\"\n        + \"  LogicalProject(psPartkey=[$0])\\n\"\n        + \"    LogicalTableScan(table=[[tpch, partsupp]])\\n\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/tools/PlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1393,"status":"M"}],"commitId":"76ff19135f8bf9ee19b47d999d23bc1e2ab75e15","commitMessage":"@@@[CALCITE-4248] Deprecate SqlParser.ConfigBuilder\n","date":"2020-09-18 10:35:31","modifiedFileCount":"20","status":"M","submitter":"Julian Hyde"}]
