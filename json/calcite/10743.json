[{"authorTime":"2017-03-03 16:05:23","codes":[{"authorDate":"2019-07-19 02:18:57","commitOrder":4,"curCode":"  private static Calendar getFixedCalendar() {\n    Calendar calendar = Util.calendar();\n    calendar.set(Calendar.YEAR, 2014);\n    calendar.set(Calendar.MONTH, 8);\n    calendar.set(Calendar.DATE, 7);\n    calendar.set(Calendar.HOUR_OF_DAY, 17);\n    calendar.set(Calendar.MINUTE, 8);\n    calendar.set(Calendar.SECOND, 48);\n    calendar.set(Calendar.MILLISECOND, 15);\n    return calendar;\n  }\n","date":"2019-11-27 14:34:16","endLine":1517,"groupId":"2084","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"getFixedCalendar","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/36/32339ca441133de6483ccef9e5d788a7111e90.src","preCode":"  private static Calendar getFixedCalendar() {\n    Calendar calendar = Util.calendar();\n    calendar.set(Calendar.YEAR, 2014);\n    calendar.set(Calendar.MONTH, 8);\n    calendar.set(Calendar.DATE, 7);\n    calendar.set(Calendar.HOUR_OF_DAY, 17);\n    calendar.set(Calendar.MINUTE, 8);\n    calendar.set(Calendar.SECOND, 48);\n    calendar.set(Calendar.MILLISECOND, 15);\n    return calendar;\n  }\n","realPath":"core/src/test/java/org/apache/calcite/sql/test/SqlOperatorBaseTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1507,"status":"B"},{"authorDate":"2017-03-03 16:05:23","commitOrder":4,"curCode":"  public Object getLimit(\n      boolean sign,\n      Limit limit,\n      boolean beyond,\n      int precision,\n      int scale) {\n    assert allowsPrecScale(precision != -1, scale != -1) : this;\n    if (limit == Limit.ZERO) {\n      if (beyond) {\n        return null;\n      }\n      sign = true;\n    }\n    Calendar calendar;\n\n    switch (this) {\n    case BOOLEAN:\n      switch (limit) {\n      case ZERO:\n        return false;\n      case UNDERFLOW:\n        return null;\n      case OVERFLOW:\n        if (beyond || !sign) {\n          return null;\n        } else {\n          return true;\n        }\n      default:\n        throw Util.unexpected(limit);\n      }\n\n    case TINYINT:\n      return getNumericLimit(2, 8, sign, limit, beyond);\n\n    case SMALLINT:\n      return getNumericLimit(2, 16, sign, limit, beyond);\n\n    case INTEGER:\n      return getNumericLimit(2, 32, sign, limit, beyond);\n\n    case BIGINT:\n      return getNumericLimit(2, 64, sign, limit, beyond);\n\n    case DECIMAL:\n      BigDecimal decimal =\n          getNumericLimit(10, precision, sign, limit, beyond);\n      if (decimal == null) {\n        return null;\n      }\n\n      \r\n      \r\n      switch (limit) {\n      case OVERFLOW:\n        final BigDecimal other =\n            (BigDecimal) BIGINT.getLimit(sign, limit, beyond, -1, -1);\n        if (decimal.compareTo(other) == (sign ? 1 : -1)) {\n          decimal = other;\n        }\n      }\n\n      \r\n      if (scale == 0) {\n        \r\n      } else if (scale > 0) {\n        decimal = decimal.divide(BigDecimal.TEN.pow(scale));\n      } else {\n        decimal = decimal.multiply(BigDecimal.TEN.pow(-scale));\n      }\n      return decimal;\n\n    case CHAR:\n    case VARCHAR:\n      if (!sign) {\n        return null; \r\n      }\n      StringBuilder buf = new StringBuilder();\n      switch (limit) {\n      case ZERO:\n        break;\n      case UNDERFLOW:\n        if (beyond) {\n          \r\n          \r\n          return null;\n        }\n        buf.append(\"a\");\n        break;\n      case OVERFLOW:\n        for (int i = 0; i < precision; ++i) {\n          buf.append(\"Z\");\n        }\n        if (beyond) {\n          buf.append(\"Z\");\n        }\n        break;\n      }\n      return buf.toString();\n\n    case BINARY:\n    case VARBINARY:\n      if (!sign) {\n        return null; \r\n      }\n      byte[] bytes;\n      switch (limit) {\n      case ZERO:\n        bytes = new byte[0];\n        break;\n      case UNDERFLOW:\n        if (beyond) {\n          \r\n          \r\n          return null;\n        }\n        bytes = new byte[]{0x00};\n        break;\n      case OVERFLOW:\n        bytes = new byte[precision + (beyond ? 1 : 0)];\n        Arrays.fill(bytes, (byte) 0xff);\n        break;\n      default:\n        throw Util.unexpected(limit);\n      }\n      return bytes;\n\n    case DATE:\n      calendar = Util.calendar();\n      switch (limit) {\n      case ZERO:\n\n        \r\n        calendar.set(Calendar.YEAR, 1970);\n        calendar.set(Calendar.MONTH, 0);\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        break;\n      case UNDERFLOW:\n        return null;\n      case OVERFLOW:\n        if (beyond) {\n          \r\n          \r\n          \r\n          \r\n          \r\n          \r\n          return null;\n        }\n\n        \r\n        \r\n        \r\n        if (sign) {\n          calendar.set(Calendar.YEAR, 9999);\n          calendar.set(Calendar.MONTH, 11);\n          calendar.set(Calendar.DAY_OF_MONTH, 31);\n        } else {\n          calendar.set(Calendar.YEAR, 1);\n          calendar.set(Calendar.MONTH, 0);\n          calendar.set(Calendar.DAY_OF_MONTH, 1);\n        }\n        break;\n      }\n      calendar.set(Calendar.HOUR_OF_DAY, 0);\n      calendar.set(Calendar.MINUTE, 0);\n      calendar.set(Calendar.SECOND, 0);\n      return calendar;\n\n    case TIME:\n      if (!sign) {\n        return null; \r\n      }\n      if (beyond) {\n        return null; \r\n      }\n      calendar = Util.calendar();\n      switch (limit) {\n      case ZERO:\n\n        \r\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        break;\n      case UNDERFLOW:\n        return null;\n      case OVERFLOW:\n        calendar.set(Calendar.HOUR_OF_DAY, 23);\n        calendar.set(Calendar.MINUTE, 59);\n        calendar.set(Calendar.SECOND, 59);\n        int millis =\n            (precision >= 3) ? 999\n                : ((precision == 2) ? 990 : ((precision == 1) ? 900 : 0));\n        calendar.set(Calendar.MILLISECOND, millis);\n        break;\n      }\n      return calendar;\n\n    case TIMESTAMP:\n      calendar = Util.calendar();\n      switch (limit) {\n      case ZERO:\n\n        \r\n        calendar.set(Calendar.YEAR, 1970);\n        calendar.set(Calendar.MONTH, 0);\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        break;\n      case UNDERFLOW:\n        return null;\n      case OVERFLOW:\n        if (beyond) {\n          \r\n          \r\n          \r\n          \r\n          \r\n          \r\n          return null;\n        }\n\n        \r\n        \r\n        \r\n        if (sign) {\n          calendar.set(Calendar.YEAR, 9999);\n          calendar.set(Calendar.MONTH, 11);\n          calendar.set(Calendar.DAY_OF_MONTH, 31);\n          calendar.set(Calendar.HOUR_OF_DAY, 23);\n          calendar.set(Calendar.MINUTE, 59);\n          calendar.set(Calendar.SECOND, 59);\n          int millis =\n              (precision >= 3) ? 999\n                  : ((precision == 2) ? 990\n                      : ((precision == 1) ? 900 : 0));\n          calendar.set(Calendar.MILLISECOND, millis);\n        } else {\n          calendar.set(Calendar.YEAR, 1);\n          calendar.set(Calendar.MONTH, 0);\n          calendar.set(Calendar.DAY_OF_MONTH, 1);\n          calendar.set(Calendar.HOUR_OF_DAY, 0);\n          calendar.set(Calendar.MINUTE, 0);\n          calendar.set(Calendar.SECOND, 0);\n          calendar.set(Calendar.MILLISECOND, 0);\n        }\n        break;\n      }\n      return calendar;\n\n    default:\n      throw Util.unexpected(this);\n    }\n  }\n","date":"2017-03-04 03:04:28","endLine":723,"groupId":"8073","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getLimit","params":"(booleansign@Limitlimit@booleanbeyond@intprecision@intscale)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/f3/4ea11eccf0bdfc6b6ea7c0405218a8c47c909f.src","preCode":"  public Object getLimit(\n      boolean sign,\n      Limit limit,\n      boolean beyond,\n      int precision,\n      int scale) {\n    assert allowsPrecScale(precision != -1, scale != -1) : this;\n    if (limit == Limit.ZERO) {\n      if (beyond) {\n        return null;\n      }\n      sign = true;\n    }\n    Calendar calendar;\n\n    switch (this) {\n    case BOOLEAN:\n      switch (limit) {\n      case ZERO:\n        return false;\n      case UNDERFLOW:\n        return null;\n      case OVERFLOW:\n        if (beyond || !sign) {\n          return null;\n        } else {\n          return true;\n        }\n      default:\n        throw Util.unexpected(limit);\n      }\n\n    case TINYINT:\n      return getNumericLimit(2, 8, sign, limit, beyond);\n\n    case SMALLINT:\n      return getNumericLimit(2, 16, sign, limit, beyond);\n\n    case INTEGER:\n      return getNumericLimit(2, 32, sign, limit, beyond);\n\n    case BIGINT:\n      return getNumericLimit(2, 64, sign, limit, beyond);\n\n    case DECIMAL:\n      BigDecimal decimal =\n          getNumericLimit(10, precision, sign, limit, beyond);\n      if (decimal == null) {\n        return null;\n      }\n\n      \r\n      \r\n      switch (limit) {\n      case OVERFLOW:\n        final BigDecimal other =\n            (BigDecimal) BIGINT.getLimit(sign, limit, beyond, -1, -1);\n        if (decimal.compareTo(other) == (sign ? 1 : -1)) {\n          decimal = other;\n        }\n      }\n\n      \r\n      if (scale == 0) {\n        \r\n      } else if (scale > 0) {\n        decimal = decimal.divide(BigDecimal.TEN.pow(scale));\n      } else {\n        decimal = decimal.multiply(BigDecimal.TEN.pow(-scale));\n      }\n      return decimal;\n\n    case CHAR:\n    case VARCHAR:\n      if (!sign) {\n        return null; \r\n      }\n      StringBuilder buf = new StringBuilder();\n      switch (limit) {\n      case ZERO:\n        break;\n      case UNDERFLOW:\n        if (beyond) {\n          \r\n          \r\n          return null;\n        }\n        buf.append(\"a\");\n        break;\n      case OVERFLOW:\n        for (int i = 0; i < precision; ++i) {\n          buf.append(\"Z\");\n        }\n        if (beyond) {\n          buf.append(\"Z\");\n        }\n        break;\n      }\n      return buf.toString();\n\n    case BINARY:\n    case VARBINARY:\n      if (!sign) {\n        return null; \r\n      }\n      byte[] bytes;\n      switch (limit) {\n      case ZERO:\n        bytes = new byte[0];\n        break;\n      case UNDERFLOW:\n        if (beyond) {\n          \r\n          \r\n          return null;\n        }\n        bytes = new byte[]{0x00};\n        break;\n      case OVERFLOW:\n        bytes = new byte[precision + (beyond ? 1 : 0)];\n        Arrays.fill(bytes, (byte) 0xff);\n        break;\n      default:\n        throw Util.unexpected(limit);\n      }\n      return bytes;\n\n    case DATE:\n      calendar = Util.calendar();\n      switch (limit) {\n      case ZERO:\n\n        \r\n        calendar.set(Calendar.YEAR, 1970);\n        calendar.set(Calendar.MONTH, 0);\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        break;\n      case UNDERFLOW:\n        return null;\n      case OVERFLOW:\n        if (beyond) {\n          \r\n          \r\n          \r\n          \r\n          \r\n          \r\n          return null;\n        }\n\n        \r\n        \r\n        \r\n        if (sign) {\n          calendar.set(Calendar.YEAR, 9999);\n          calendar.set(Calendar.MONTH, 11);\n          calendar.set(Calendar.DAY_OF_MONTH, 31);\n        } else {\n          calendar.set(Calendar.YEAR, 1);\n          calendar.set(Calendar.MONTH, 0);\n          calendar.set(Calendar.DAY_OF_MONTH, 1);\n        }\n        break;\n      }\n      calendar.set(Calendar.HOUR_OF_DAY, 0);\n      calendar.set(Calendar.MINUTE, 0);\n      calendar.set(Calendar.SECOND, 0);\n      return calendar;\n\n    case TIME:\n      if (!sign) {\n        return null; \r\n      }\n      if (beyond) {\n        return null; \r\n      }\n      calendar = Util.calendar();\n      switch (limit) {\n      case ZERO:\n\n        \r\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        break;\n      case UNDERFLOW:\n        return null;\n      case OVERFLOW:\n        calendar.set(Calendar.HOUR_OF_DAY, 23);\n        calendar.set(Calendar.MINUTE, 59);\n        calendar.set(Calendar.SECOND, 59);\n        int millis =\n            (precision >= 3) ? 999\n                : ((precision == 2) ? 990 : ((precision == 1) ? 900 : 0));\n        calendar.set(Calendar.MILLISECOND, millis);\n        break;\n      }\n      return calendar;\n\n    case TIMESTAMP:\n      calendar = Util.calendar();\n      switch (limit) {\n      case ZERO:\n\n        \r\n        calendar.set(Calendar.YEAR, 1970);\n        calendar.set(Calendar.MONTH, 0);\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        break;\n      case UNDERFLOW:\n        return null;\n      case OVERFLOW:\n        if (beyond) {\n          \r\n          \r\n          \r\n          \r\n          \r\n          \r\n          return null;\n        }\n\n        \r\n        \r\n        \r\n        if (sign) {\n          calendar.set(Calendar.YEAR, 9999);\n          calendar.set(Calendar.MONTH, 11);\n          calendar.set(Calendar.DAY_OF_MONTH, 31);\n          calendar.set(Calendar.HOUR_OF_DAY, 23);\n          calendar.set(Calendar.MINUTE, 59);\n          calendar.set(Calendar.SECOND, 59);\n          int millis =\n              (precision >= 3) ? 999\n                  : ((precision == 2) ? 990\n                      : ((precision == 1) ? 900 : 0));\n          calendar.set(Calendar.MILLISECOND, millis);\n        } else {\n          calendar.set(Calendar.YEAR, 1);\n          calendar.set(Calendar.MONTH, 0);\n          calendar.set(Calendar.DAY_OF_MONTH, 1);\n          calendar.set(Calendar.HOUR_OF_DAY, 0);\n          calendar.set(Calendar.MINUTE, 0);\n          calendar.set(Calendar.SECOND, 0);\n          calendar.set(Calendar.MILLISECOND, 0);\n        }\n        break;\n      }\n      return calendar;\n\n    default:\n      throw Util.unexpected(this);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/type/SqlTypeName.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":465,"status":"NB"}],"commitId":"eb71946c843b3dc9618a2c128dcaa9bf52afe9c7","commitMessage":"@@@[CALCITE-3141] Slow tests are not run in continuous integration\n\n1. Replace @Category(SlowTests.class) with @Tag(\"slow\").\n2. Replace junit4 APIs with junit5 APIs when @Tag annotation is used since mixed usages do not work well together.\n3. Use exclusively the @Tag(\"slow\") annotation for tagging slow tests.\n4. Remove usages of calcite.test.slow system property for annotating slow tests.\n5. Replace @Ignore(\"slow\") with @Tag(\"slow\") enabling a few more slow tests.\n6. Add testSlow task in Gradle for running slow tests.\n7. Exclude slow test execution from normal Gradle build and test.\n8. Add GitHub Action for running slow tests on demand (by adding\n'slow-tests-needed' label) in a PR and on every push to the master.\n9. Update site instructions for running slow tests.\n10. Silence logger in SqlOperatorBaseTest since it generates huge logs.\n11. Remove execution of slow test from Travis.\n12. Refactor FoodmartTest based on the needs of the new @ParameterizedTest API.\n13. Add header and description in main.yml file.\n","date":"2019-11-27 14:34:16","modifiedFileCount":"13","status":"M","submitter":"Stamatis Zampetakis"},{"authorTime":"2020-09-30 01:31:14","codes":[{"authorDate":"2019-07-19 02:18:57","commitOrder":5,"curCode":"  private static Calendar getFixedCalendar() {\n    Calendar calendar = Util.calendar();\n    calendar.set(Calendar.YEAR, 2014);\n    calendar.set(Calendar.MONTH, 8);\n    calendar.set(Calendar.DATE, 7);\n    calendar.set(Calendar.HOUR_OF_DAY, 17);\n    calendar.set(Calendar.MINUTE, 8);\n    calendar.set(Calendar.SECOND, 48);\n    calendar.set(Calendar.MILLISECOND, 15);\n    return calendar;\n  }\n","date":"2019-11-27 14:34:16","endLine":1517,"groupId":"2084","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"getFixedCalendar","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/36/32339ca441133de6483ccef9e5d788a7111e90.src","preCode":"  private static Calendar getFixedCalendar() {\n    Calendar calendar = Util.calendar();\n    calendar.set(Calendar.YEAR, 2014);\n    calendar.set(Calendar.MONTH, 8);\n    calendar.set(Calendar.DATE, 7);\n    calendar.set(Calendar.HOUR_OF_DAY, 17);\n    calendar.set(Calendar.MINUTE, 8);\n    calendar.set(Calendar.SECOND, 48);\n    calendar.set(Calendar.MILLISECOND, 15);\n    return calendar;\n  }\n","realPath":"core/src/test/java/org/apache/calcite/sql/test/SqlOperatorBaseTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1507,"status":"N"},{"authorDate":"2020-09-30 01:31:14","commitOrder":5,"curCode":"  public Object getLimit(\n      boolean sign,\n      Limit limit,\n      boolean beyond,\n      int precision,\n      int scale) {\n    assert allowsPrecScale(precision != -1, scale != -1) : this;\n    if (limit == Limit.ZERO) {\n      if (beyond) {\n        return null;\n      }\n      sign = true;\n    }\n    Calendar calendar;\n\n    switch (this) {\n    case BOOLEAN:\n      switch (limit) {\n      case ZERO:\n        return false;\n      case UNDERFLOW:\n        return null;\n      case OVERFLOW:\n        if (beyond || !sign) {\n          return null;\n        } else {\n          return true;\n        }\n      default:\n        throw Util.unexpected(limit);\n      }\n\n    case TINYINT:\n      return getNumericLimit(2, 8, sign, limit, beyond);\n\n    case SMALLINT:\n      return getNumericLimit(2, 16, sign, limit, beyond);\n\n    case INTEGER:\n      return getNumericLimit(2, 32, sign, limit, beyond);\n\n    case BIGINT:\n      return getNumericLimit(2, 64, sign, limit, beyond);\n\n    case DECIMAL:\n      BigDecimal decimal =\n          getNumericLimit(10, precision, sign, limit, beyond);\n      if (decimal == null) {\n        return null;\n      }\n\n      \r\n      \r\n      switch (limit) {\n      case OVERFLOW:\n        final BigDecimal other =\n            (BigDecimal) BIGINT.getLimit(sign, limit, beyond, -1, -1);\n        if (decimal.compareTo(other) == (sign ? 1 : -1)) {\n          decimal = other;\n        }\n        break;\n      default:\n        break;\n      }\n\n      \r\n      if (scale == 0) {\n        \r\n      } else if (scale > 0) {\n        decimal = decimal.divide(BigDecimal.TEN.pow(scale));\n      } else {\n        decimal = decimal.multiply(BigDecimal.TEN.pow(-scale));\n      }\n      return decimal;\n\n    case CHAR:\n    case VARCHAR:\n      if (!sign) {\n        return null; \r\n      }\n      StringBuilder buf = new StringBuilder();\n      switch (limit) {\n      case ZERO:\n        break;\n      case UNDERFLOW:\n        if (beyond) {\n          \r\n          \r\n          return null;\n        }\n        buf.append(\"a\");\n        break;\n      case OVERFLOW:\n        for (int i = 0; i < precision; ++i) {\n          buf.append(\"Z\");\n        }\n        if (beyond) {\n          buf.append(\"Z\");\n        }\n        break;\n      default:\n        break;\n      }\n      return buf.toString();\n\n    case BINARY:\n    case VARBINARY:\n      if (!sign) {\n        return null; \r\n      }\n      byte[] bytes;\n      switch (limit) {\n      case ZERO:\n        bytes = new byte[0];\n        break;\n      case UNDERFLOW:\n        if (beyond) {\n          \r\n          \r\n          return null;\n        }\n        bytes = new byte[]{0x00};\n        break;\n      case OVERFLOW:\n        bytes = new byte[precision + (beyond ? 1 : 0)];\n        Arrays.fill(bytes, (byte) 0xff);\n        break;\n      default:\n        throw Util.unexpected(limit);\n      }\n      return bytes;\n\n    case DATE:\n      calendar = Util.calendar();\n      switch (limit) {\n      case ZERO:\n        \r\n        calendar.set(Calendar.YEAR, 1970);\n        calendar.set(Calendar.MONTH, 0);\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        break;\n      case UNDERFLOW:\n        return null;\n      case OVERFLOW:\n        if (beyond) {\n          \r\n          \r\n          \r\n          \r\n          \r\n          \r\n          return null;\n        }\n\n        \r\n        \r\n        \r\n        if (sign) {\n          calendar.set(Calendar.YEAR, 9999);\n          calendar.set(Calendar.MONTH, 11);\n          calendar.set(Calendar.DAY_OF_MONTH, 31);\n        } else {\n          calendar.set(Calendar.YEAR, 1);\n          calendar.set(Calendar.MONTH, 0);\n          calendar.set(Calendar.DAY_OF_MONTH, 1);\n        }\n        break;\n      default:\n        break;\n      }\n      calendar.set(Calendar.HOUR_OF_DAY, 0);\n      calendar.set(Calendar.MINUTE, 0);\n      calendar.set(Calendar.SECOND, 0);\n      return calendar;\n\n    case TIME:\n      if (!sign) {\n        return null; \r\n      }\n      if (beyond) {\n        return null; \r\n      }\n      calendar = Util.calendar();\n      switch (limit) {\n      case ZERO:\n\n        \r\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        break;\n      case UNDERFLOW:\n        return null;\n      case OVERFLOW:\n        calendar.set(Calendar.HOUR_OF_DAY, 23);\n        calendar.set(Calendar.MINUTE, 59);\n        calendar.set(Calendar.SECOND, 59);\n        int millis =\n            (precision >= 3) ? 999\n                : ((precision == 2) ? 990 : ((precision == 1) ? 900 : 0));\n        calendar.set(Calendar.MILLISECOND, millis);\n        break;\n      default:\n        break;\n      }\n      return calendar;\n\n    case TIMESTAMP:\n      calendar = Util.calendar();\n      switch (limit) {\n      case ZERO:\n        \r\n        calendar.set(Calendar.YEAR, 1970);\n        calendar.set(Calendar.MONTH, 0);\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        break;\n      case UNDERFLOW:\n        return null;\n      case OVERFLOW:\n        if (beyond) {\n          \r\n          \r\n          \r\n          \r\n          \r\n          \r\n          return null;\n        }\n\n        \r\n        \r\n        \r\n        if (sign) {\n          calendar.set(Calendar.YEAR, 9999);\n          calendar.set(Calendar.MONTH, 11);\n          calendar.set(Calendar.DAY_OF_MONTH, 31);\n          calendar.set(Calendar.HOUR_OF_DAY, 23);\n          calendar.set(Calendar.MINUTE, 59);\n          calendar.set(Calendar.SECOND, 59);\n          int millis =\n              (precision >= 3) ? 999\n                  : ((precision == 2) ? 990\n                      : ((precision == 1) ? 900 : 0));\n          calendar.set(Calendar.MILLISECOND, millis);\n        } else {\n          calendar.set(Calendar.YEAR, 1);\n          calendar.set(Calendar.MONTH, 0);\n          calendar.set(Calendar.DAY_OF_MONTH, 1);\n          calendar.set(Calendar.HOUR_OF_DAY, 0);\n          calendar.set(Calendar.MINUTE, 0);\n          calendar.set(Calendar.SECOND, 0);\n          calendar.set(Calendar.MILLISECOND, 0);\n        }\n        break;\n      default:\n        break;\n      }\n      return calendar;\n\n    default:\n      throw Util.unexpected(this);\n    }\n  }\n","date":"2020-10-07 05:43:06","endLine":740,"groupId":"9087","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getLimit","params":"(booleansign@Limitlimit@booleanbeyond@intprecision@intscale)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/bd/1a745edb2a3fbde5735b263136819ad4effdb6.src","preCode":"  public Object getLimit(\n      boolean sign,\n      Limit limit,\n      boolean beyond,\n      int precision,\n      int scale) {\n    assert allowsPrecScale(precision != -1, scale != -1) : this;\n    if (limit == Limit.ZERO) {\n      if (beyond) {\n        return null;\n      }\n      sign = true;\n    }\n    Calendar calendar;\n\n    switch (this) {\n    case BOOLEAN:\n      switch (limit) {\n      case ZERO:\n        return false;\n      case UNDERFLOW:\n        return null;\n      case OVERFLOW:\n        if (beyond || !sign) {\n          return null;\n        } else {\n          return true;\n        }\n      default:\n        throw Util.unexpected(limit);\n      }\n\n    case TINYINT:\n      return getNumericLimit(2, 8, sign, limit, beyond);\n\n    case SMALLINT:\n      return getNumericLimit(2, 16, sign, limit, beyond);\n\n    case INTEGER:\n      return getNumericLimit(2, 32, sign, limit, beyond);\n\n    case BIGINT:\n      return getNumericLimit(2, 64, sign, limit, beyond);\n\n    case DECIMAL:\n      BigDecimal decimal =\n          getNumericLimit(10, precision, sign, limit, beyond);\n      if (decimal == null) {\n        return null;\n      }\n\n      \r\n      \r\n      switch (limit) {\n      case OVERFLOW:\n        final BigDecimal other =\n            (BigDecimal) BIGINT.getLimit(sign, limit, beyond, -1, -1);\n        if (decimal.compareTo(other) == (sign ? 1 : -1)) {\n          decimal = other;\n        }\n      }\n\n      \r\n      if (scale == 0) {\n        \r\n      } else if (scale > 0) {\n        decimal = decimal.divide(BigDecimal.TEN.pow(scale));\n      } else {\n        decimal = decimal.multiply(BigDecimal.TEN.pow(-scale));\n      }\n      return decimal;\n\n    case CHAR:\n    case VARCHAR:\n      if (!sign) {\n        return null; \r\n      }\n      StringBuilder buf = new StringBuilder();\n      switch (limit) {\n      case ZERO:\n        break;\n      case UNDERFLOW:\n        if (beyond) {\n          \r\n          \r\n          return null;\n        }\n        buf.append(\"a\");\n        break;\n      case OVERFLOW:\n        for (int i = 0; i < precision; ++i) {\n          buf.append(\"Z\");\n        }\n        if (beyond) {\n          buf.append(\"Z\");\n        }\n        break;\n      }\n      return buf.toString();\n\n    case BINARY:\n    case VARBINARY:\n      if (!sign) {\n        return null; \r\n      }\n      byte[] bytes;\n      switch (limit) {\n      case ZERO:\n        bytes = new byte[0];\n        break;\n      case UNDERFLOW:\n        if (beyond) {\n          \r\n          \r\n          return null;\n        }\n        bytes = new byte[]{0x00};\n        break;\n      case OVERFLOW:\n        bytes = new byte[precision + (beyond ? 1 : 0)];\n        Arrays.fill(bytes, (byte) 0xff);\n        break;\n      default:\n        throw Util.unexpected(limit);\n      }\n      return bytes;\n\n    case DATE:\n      calendar = Util.calendar();\n      switch (limit) {\n      case ZERO:\n\n        \r\n        calendar.set(Calendar.YEAR, 1970);\n        calendar.set(Calendar.MONTH, 0);\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        break;\n      case UNDERFLOW:\n        return null;\n      case OVERFLOW:\n        if (beyond) {\n          \r\n          \r\n          \r\n          \r\n          \r\n          \r\n          return null;\n        }\n\n        \r\n        \r\n        \r\n        if (sign) {\n          calendar.set(Calendar.YEAR, 9999);\n          calendar.set(Calendar.MONTH, 11);\n          calendar.set(Calendar.DAY_OF_MONTH, 31);\n        } else {\n          calendar.set(Calendar.YEAR, 1);\n          calendar.set(Calendar.MONTH, 0);\n          calendar.set(Calendar.DAY_OF_MONTH, 1);\n        }\n        break;\n      }\n      calendar.set(Calendar.HOUR_OF_DAY, 0);\n      calendar.set(Calendar.MINUTE, 0);\n      calendar.set(Calendar.SECOND, 0);\n      return calendar;\n\n    case TIME:\n      if (!sign) {\n        return null; \r\n      }\n      if (beyond) {\n        return null; \r\n      }\n      calendar = Util.calendar();\n      switch (limit) {\n      case ZERO:\n\n        \r\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        break;\n      case UNDERFLOW:\n        return null;\n      case OVERFLOW:\n        calendar.set(Calendar.HOUR_OF_DAY, 23);\n        calendar.set(Calendar.MINUTE, 59);\n        calendar.set(Calendar.SECOND, 59);\n        int millis =\n            (precision >= 3) ? 999\n                : ((precision == 2) ? 990 : ((precision == 1) ? 900 : 0));\n        calendar.set(Calendar.MILLISECOND, millis);\n        break;\n      }\n      return calendar;\n\n    case TIMESTAMP:\n      calendar = Util.calendar();\n      switch (limit) {\n      case ZERO:\n\n        \r\n        calendar.set(Calendar.YEAR, 1970);\n        calendar.set(Calendar.MONTH, 0);\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        break;\n      case UNDERFLOW:\n        return null;\n      case OVERFLOW:\n        if (beyond) {\n          \r\n          \r\n          \r\n          \r\n          \r\n          \r\n          return null;\n        }\n\n        \r\n        \r\n        \r\n        if (sign) {\n          calendar.set(Calendar.YEAR, 9999);\n          calendar.set(Calendar.MONTH, 11);\n          calendar.set(Calendar.DAY_OF_MONTH, 31);\n          calendar.set(Calendar.HOUR_OF_DAY, 23);\n          calendar.set(Calendar.MINUTE, 59);\n          calendar.set(Calendar.SECOND, 59);\n          int millis =\n              (precision >= 3) ? 999\n                  : ((precision == 2) ? 990\n                      : ((precision == 1) ? 900 : 0));\n          calendar.set(Calendar.MILLISECOND, millis);\n        } else {\n          calendar.set(Calendar.YEAR, 1);\n          calendar.set(Calendar.MONTH, 0);\n          calendar.set(Calendar.DAY_OF_MONTH, 1);\n          calendar.set(Calendar.HOUR_OF_DAY, 0);\n          calendar.set(Calendar.MINUTE, 0);\n          calendar.set(Calendar.SECOND, 0);\n          calendar.set(Calendar.MILLISECOND, 0);\n        }\n        break;\n      }\n      return calendar;\n\n    default:\n      throw Util.unexpected(this);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/type/SqlTypeName.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":473,"status":"M"}],"commitId":"1b94f37e888cf2d186362473529e6c147afe0f6e","commitMessage":"@@@[CALCITE-4314] Add missing default branches to switch statement\n\nNote: the changes are mechanical.\nThe intention is to keep the previous behavior and prevent adding new\nnon exchaustive switch statements in the future.\n\nSee https://errorprone.info/bugpattern/MissingCasesInEnumSwitch\n","date":"2020-10-07 05:43:06","modifiedFileCount":"98","status":"M","submitter":"Vladimir Sitnikov"},{"authorTime":"2020-05-29 00:04:40","codes":[{"authorDate":"2019-07-19 02:18:57","commitOrder":6,"curCode":"  private static Calendar getFixedCalendar() {\n    Calendar calendar = Util.calendar();\n    calendar.set(Calendar.YEAR, 2014);\n    calendar.set(Calendar.MONTH, 8);\n    calendar.set(Calendar.DATE, 7);\n    calendar.set(Calendar.HOUR_OF_DAY, 17);\n    calendar.set(Calendar.MINUTE, 8);\n    calendar.set(Calendar.SECOND, 48);\n    calendar.set(Calendar.MILLISECOND, 15);\n    return calendar;\n  }\n","date":"2019-11-27 14:34:16","endLine":1517,"groupId":"10743","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"getFixedCalendar","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/36/32339ca441133de6483ccef9e5d788a7111e90.src","preCode":"  private static Calendar getFixedCalendar() {\n    Calendar calendar = Util.calendar();\n    calendar.set(Calendar.YEAR, 2014);\n    calendar.set(Calendar.MONTH, 8);\n    calendar.set(Calendar.DATE, 7);\n    calendar.set(Calendar.HOUR_OF_DAY, 17);\n    calendar.set(Calendar.MINUTE, 8);\n    calendar.set(Calendar.SECOND, 48);\n    calendar.set(Calendar.MILLISECOND, 15);\n    return calendar;\n  }\n","realPath":"core/src/test/java/org/apache/calcite/sql/test/SqlOperatorBaseTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1507,"status":"N"},{"authorDate":"2020-05-29 00:04:40","commitOrder":6,"curCode":"  public @Nullable Object getLimit(\n      boolean sign,\n      Limit limit,\n      boolean beyond,\n      int precision,\n      int scale) {\n    assert allowsPrecScale(precision != -1, scale != -1) : this;\n    if (limit == Limit.ZERO) {\n      if (beyond) {\n        return null;\n      }\n      sign = true;\n    }\n    Calendar calendar;\n\n    switch (this) {\n    case BOOLEAN:\n      switch (limit) {\n      case ZERO:\n        return false;\n      case UNDERFLOW:\n        return null;\n      case OVERFLOW:\n        if (beyond || !sign) {\n          return null;\n        } else {\n          return true;\n        }\n      default:\n        throw Util.unexpected(limit);\n      }\n\n    case TINYINT:\n      return getNumericLimit(2, 8, sign, limit, beyond);\n\n    case SMALLINT:\n      return getNumericLimit(2, 16, sign, limit, beyond);\n\n    case INTEGER:\n      return getNumericLimit(2, 32, sign, limit, beyond);\n\n    case BIGINT:\n      return getNumericLimit(2, 64, sign, limit, beyond);\n\n    case DECIMAL:\n      BigDecimal decimal =\n          getNumericLimit(10, precision, sign, limit, beyond);\n      if (decimal == null) {\n        return null;\n      }\n\n      \r\n      \r\n      switch (limit) {\n      case OVERFLOW:\n        final BigDecimal other =\n            (BigDecimal) BIGINT.getLimit(sign, limit, beyond, -1, -1);\n        if (other != null && decimal.compareTo(other) == (sign ? 1 : -1)) {\n          decimal = other;\n        }\n        break;\n      default:\n        break;\n      }\n\n      \r\n      if (scale == 0) {\n        \r\n      } else if (scale > 0) {\n        decimal = decimal.divide(BigDecimal.TEN.pow(scale));\n      } else {\n        decimal = decimal.multiply(BigDecimal.TEN.pow(-scale));\n      }\n      return decimal;\n\n    case CHAR:\n    case VARCHAR:\n      if (!sign) {\n        return null; \r\n      }\n      StringBuilder buf = new StringBuilder();\n      switch (limit) {\n      case ZERO:\n        break;\n      case UNDERFLOW:\n        if (beyond) {\n          \r\n          \r\n          return null;\n        }\n        buf.append(\"a\");\n        break;\n      case OVERFLOW:\n        for (int i = 0; i < precision; ++i) {\n          buf.append(\"Z\");\n        }\n        if (beyond) {\n          buf.append(\"Z\");\n        }\n        break;\n      default:\n        break;\n      }\n      return buf.toString();\n\n    case BINARY:\n    case VARBINARY:\n      if (!sign) {\n        return null; \r\n      }\n      byte[] bytes;\n      switch (limit) {\n      case ZERO:\n        bytes = new byte[0];\n        break;\n      case UNDERFLOW:\n        if (beyond) {\n          \r\n          \r\n          return null;\n        }\n        bytes = new byte[]{0x00};\n        break;\n      case OVERFLOW:\n        bytes = new byte[precision + (beyond ? 1 : 0)];\n        Arrays.fill(bytes, (byte) 0xff);\n        break;\n      default:\n        throw Util.unexpected(limit);\n      }\n      return bytes;\n\n    case DATE:\n      calendar = Util.calendar();\n      switch (limit) {\n      case ZERO:\n        \r\n        calendar.set(Calendar.YEAR, 1970);\n        calendar.set(Calendar.MONTH, 0);\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        break;\n      case UNDERFLOW:\n        return null;\n      case OVERFLOW:\n        if (beyond) {\n          \r\n          \r\n          \r\n          \r\n          \r\n          \r\n          return null;\n        }\n\n        \r\n        \r\n        \r\n        if (sign) {\n          calendar.set(Calendar.YEAR, 9999);\n          calendar.set(Calendar.MONTH, 11);\n          calendar.set(Calendar.DAY_OF_MONTH, 31);\n        } else {\n          calendar.set(Calendar.YEAR, 1);\n          calendar.set(Calendar.MONTH, 0);\n          calendar.set(Calendar.DAY_OF_MONTH, 1);\n        }\n        break;\n      default:\n        break;\n      }\n      calendar.set(Calendar.HOUR_OF_DAY, 0);\n      calendar.set(Calendar.MINUTE, 0);\n      calendar.set(Calendar.SECOND, 0);\n      return calendar;\n\n    case TIME:\n      if (!sign) {\n        return null; \r\n      }\n      if (beyond) {\n        return null; \r\n      }\n      calendar = Util.calendar();\n      switch (limit) {\n      case ZERO:\n\n        \r\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        break;\n      case UNDERFLOW:\n        return null;\n      case OVERFLOW:\n        calendar.set(Calendar.HOUR_OF_DAY, 23);\n        calendar.set(Calendar.MINUTE, 59);\n        calendar.set(Calendar.SECOND, 59);\n        int millis =\n            (precision >= 3) ? 999\n                : ((precision == 2) ? 990 : ((precision == 1) ? 900 : 0));\n        calendar.set(Calendar.MILLISECOND, millis);\n        break;\n      default:\n        break;\n      }\n      return calendar;\n\n    case TIMESTAMP:\n      calendar = Util.calendar();\n      switch (limit) {\n      case ZERO:\n        \r\n        calendar.set(Calendar.YEAR, 1970);\n        calendar.set(Calendar.MONTH, 0);\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        break;\n      case UNDERFLOW:\n        return null;\n      case OVERFLOW:\n        if (beyond) {\n          \r\n          \r\n          \r\n          \r\n          \r\n          \r\n          return null;\n        }\n\n        \r\n        \r\n        \r\n        if (sign) {\n          calendar.set(Calendar.YEAR, 9999);\n          calendar.set(Calendar.MONTH, 11);\n          calendar.set(Calendar.DAY_OF_MONTH, 31);\n          calendar.set(Calendar.HOUR_OF_DAY, 23);\n          calendar.set(Calendar.MINUTE, 59);\n          calendar.set(Calendar.SECOND, 59);\n          int millis =\n              (precision >= 3) ? 999\n                  : ((precision == 2) ? 990\n                      : ((precision == 1) ? 900 : 0));\n          calendar.set(Calendar.MILLISECOND, millis);\n        } else {\n          calendar.set(Calendar.YEAR, 1);\n          calendar.set(Calendar.MONTH, 0);\n          calendar.set(Calendar.DAY_OF_MONTH, 1);\n          calendar.set(Calendar.HOUR_OF_DAY, 0);\n          calendar.set(Calendar.MINUTE, 0);\n          calendar.set(Calendar.SECOND, 0);\n          calendar.set(Calendar.MILLISECOND, 0);\n        }\n        break;\n      default:\n        break;\n      }\n      return calendar;\n\n    default:\n      throw Util.unexpected(this);\n    }\n  }\n","date":"2020-11-30 06:45:33","endLine":742,"groupId":"10743","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"getLimit","params":"(booleansign@Limitlimit@booleanbeyond@intprecision@intscale)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/82/63fb5cf9ece4b155963216582711574060041f.src","preCode":"  public Object getLimit(\n      boolean sign,\n      Limit limit,\n      boolean beyond,\n      int precision,\n      int scale) {\n    assert allowsPrecScale(precision != -1, scale != -1) : this;\n    if (limit == Limit.ZERO) {\n      if (beyond) {\n        return null;\n      }\n      sign = true;\n    }\n    Calendar calendar;\n\n    switch (this) {\n    case BOOLEAN:\n      switch (limit) {\n      case ZERO:\n        return false;\n      case UNDERFLOW:\n        return null;\n      case OVERFLOW:\n        if (beyond || !sign) {\n          return null;\n        } else {\n          return true;\n        }\n      default:\n        throw Util.unexpected(limit);\n      }\n\n    case TINYINT:\n      return getNumericLimit(2, 8, sign, limit, beyond);\n\n    case SMALLINT:\n      return getNumericLimit(2, 16, sign, limit, beyond);\n\n    case INTEGER:\n      return getNumericLimit(2, 32, sign, limit, beyond);\n\n    case BIGINT:\n      return getNumericLimit(2, 64, sign, limit, beyond);\n\n    case DECIMAL:\n      BigDecimal decimal =\n          getNumericLimit(10, precision, sign, limit, beyond);\n      if (decimal == null) {\n        return null;\n      }\n\n      \r\n      \r\n      switch (limit) {\n      case OVERFLOW:\n        final BigDecimal other =\n            (BigDecimal) BIGINT.getLimit(sign, limit, beyond, -1, -1);\n        if (decimal.compareTo(other) == (sign ? 1 : -1)) {\n          decimal = other;\n        }\n        break;\n      default:\n        break;\n      }\n\n      \r\n      if (scale == 0) {\n        \r\n      } else if (scale > 0) {\n        decimal = decimal.divide(BigDecimal.TEN.pow(scale));\n      } else {\n        decimal = decimal.multiply(BigDecimal.TEN.pow(-scale));\n      }\n      return decimal;\n\n    case CHAR:\n    case VARCHAR:\n      if (!sign) {\n        return null; \r\n      }\n      StringBuilder buf = new StringBuilder();\n      switch (limit) {\n      case ZERO:\n        break;\n      case UNDERFLOW:\n        if (beyond) {\n          \r\n          \r\n          return null;\n        }\n        buf.append(\"a\");\n        break;\n      case OVERFLOW:\n        for (int i = 0; i < precision; ++i) {\n          buf.append(\"Z\");\n        }\n        if (beyond) {\n          buf.append(\"Z\");\n        }\n        break;\n      default:\n        break;\n      }\n      return buf.toString();\n\n    case BINARY:\n    case VARBINARY:\n      if (!sign) {\n        return null; \r\n      }\n      byte[] bytes;\n      switch (limit) {\n      case ZERO:\n        bytes = new byte[0];\n        break;\n      case UNDERFLOW:\n        if (beyond) {\n          \r\n          \r\n          return null;\n        }\n        bytes = new byte[]{0x00};\n        break;\n      case OVERFLOW:\n        bytes = new byte[precision + (beyond ? 1 : 0)];\n        Arrays.fill(bytes, (byte) 0xff);\n        break;\n      default:\n        throw Util.unexpected(limit);\n      }\n      return bytes;\n\n    case DATE:\n      calendar = Util.calendar();\n      switch (limit) {\n      case ZERO:\n        \r\n        calendar.set(Calendar.YEAR, 1970);\n        calendar.set(Calendar.MONTH, 0);\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        break;\n      case UNDERFLOW:\n        return null;\n      case OVERFLOW:\n        if (beyond) {\n          \r\n          \r\n          \r\n          \r\n          \r\n          \r\n          return null;\n        }\n\n        \r\n        \r\n        \r\n        if (sign) {\n          calendar.set(Calendar.YEAR, 9999);\n          calendar.set(Calendar.MONTH, 11);\n          calendar.set(Calendar.DAY_OF_MONTH, 31);\n        } else {\n          calendar.set(Calendar.YEAR, 1);\n          calendar.set(Calendar.MONTH, 0);\n          calendar.set(Calendar.DAY_OF_MONTH, 1);\n        }\n        break;\n      default:\n        break;\n      }\n      calendar.set(Calendar.HOUR_OF_DAY, 0);\n      calendar.set(Calendar.MINUTE, 0);\n      calendar.set(Calendar.SECOND, 0);\n      return calendar;\n\n    case TIME:\n      if (!sign) {\n        return null; \r\n      }\n      if (beyond) {\n        return null; \r\n      }\n      calendar = Util.calendar();\n      switch (limit) {\n      case ZERO:\n\n        \r\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        break;\n      case UNDERFLOW:\n        return null;\n      case OVERFLOW:\n        calendar.set(Calendar.HOUR_OF_DAY, 23);\n        calendar.set(Calendar.MINUTE, 59);\n        calendar.set(Calendar.SECOND, 59);\n        int millis =\n            (precision >= 3) ? 999\n                : ((precision == 2) ? 990 : ((precision == 1) ? 900 : 0));\n        calendar.set(Calendar.MILLISECOND, millis);\n        break;\n      default:\n        break;\n      }\n      return calendar;\n\n    case TIMESTAMP:\n      calendar = Util.calendar();\n      switch (limit) {\n      case ZERO:\n        \r\n        calendar.set(Calendar.YEAR, 1970);\n        calendar.set(Calendar.MONTH, 0);\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        break;\n      case UNDERFLOW:\n        return null;\n      case OVERFLOW:\n        if (beyond) {\n          \r\n          \r\n          \r\n          \r\n          \r\n          \r\n          return null;\n        }\n\n        \r\n        \r\n        \r\n        if (sign) {\n          calendar.set(Calendar.YEAR, 9999);\n          calendar.set(Calendar.MONTH, 11);\n          calendar.set(Calendar.DAY_OF_MONTH, 31);\n          calendar.set(Calendar.HOUR_OF_DAY, 23);\n          calendar.set(Calendar.MINUTE, 59);\n          calendar.set(Calendar.SECOND, 59);\n          int millis =\n              (precision >= 3) ? 999\n                  : ((precision == 2) ? 990\n                      : ((precision == 1) ? 900 : 0));\n          calendar.set(Calendar.MILLISECOND, millis);\n        } else {\n          calendar.set(Calendar.YEAR, 1);\n          calendar.set(Calendar.MONTH, 0);\n          calendar.set(Calendar.DAY_OF_MONTH, 1);\n          calendar.set(Calendar.HOUR_OF_DAY, 0);\n          calendar.set(Calendar.MINUTE, 0);\n          calendar.set(Calendar.SECOND, 0);\n          calendar.set(Calendar.MILLISECOND, 0);\n        }\n        break;\n      default:\n        break;\n      }\n      return calendar;\n\n    default:\n      throw Util.unexpected(this);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/type/SqlTypeName.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":475,"status":"M"}],"commitId":"d9a81b88ad561e7e4cedae93e805e0d7a53a7f1a","commitMessage":"@@@[CALCITE-4199] Add nullability annotations\n\nThe commit includes javadoc updates and refactorings made by Julian Hyde in https://github.com/apache/calcite/pull/2278\n","date":"2020-11-30 06:45:33","modifiedFileCount":"1012","status":"M","submitter":"Vladimir Sitnikov"}]
