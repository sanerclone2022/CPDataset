[{"authorTime":"2020-09-26 22:54:58","codes":[{"authorDate":"2020-05-16 23:51:59","commitOrder":9,"curCode":"  private RelOptPredicateList getAllFilterPredicates(RelNode rel,\n      RelMetadataQuery mq, RexNode pred) {\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n    final RelOptPredicateList predsBelow = mq.getAllPredicates(rel);\n    if (predsBelow == null) {\n      \r\n      return null;\n    }\n\n    \r\n    final Set<RelDataTypeField> inputExtraFields = new LinkedHashSet<>();\n    final RelOptUtil.InputFinder inputFinder = new RelOptUtil.InputFinder(inputExtraFields);\n    pred.accept(inputFinder);\n    final ImmutableBitSet inputFieldsUsed = inputFinder.build();\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(rel, ref);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    final Set<RexNode> allExprs =\n        RelMdExpressionLineage.createAllPossibleExpressions(rexBuilder, pred, mapping);\n    if (allExprs == null) {\n      return null;\n    }\n    return predsBelow.union(rexBuilder, RelOptPredicateList.of(rexBuilder, allExprs));\n  }\n","date":"2020-11-20 16:24:32","endLine":182,"groupId":"3722","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"getAllFilterPredicates","params":"(RelNoderel@RelMetadataQuerymq@RexNodepred)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/0e/ce7579e1cb368d6bf2e73f92e75dfa55e09615.src","preCode":"  private RelOptPredicateList getAllFilterPredicates(RelNode rel,\n      RelMetadataQuery mq, RexNode pred) {\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n    final RelOptPredicateList predsBelow = mq.getAllPredicates(rel);\n    if (predsBelow == null) {\n      \r\n      return null;\n    }\n\n    \r\n    final Set<RelDataTypeField> inputExtraFields = new LinkedHashSet<>();\n    final RelOptUtil.InputFinder inputFinder = new RelOptUtil.InputFinder(inputExtraFields);\n    pred.accept(inputFinder);\n    final ImmutableBitSet inputFieldsUsed = inputFinder.build();\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(rel, ref);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    final Set<RexNode> allExprs =\n        RelMdExpressionLineage.createAllPossibleExpressions(rexBuilder, pred, mapping);\n    if (allExprs == null) {\n      return null;\n    }\n    return predsBelow.union(rexBuilder, RelOptPredicateList.of(rexBuilder, allExprs));\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/metadata/RelMdAllPredicates.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":148,"status":"B"},{"authorDate":"2020-09-26 22:54:58","commitOrder":9,"curCode":"  public RelOptPredicateList getAllPredicates(Join join, RelMetadataQuery mq) {\n    if (join.getJoinType().isOuterJoin()) {\n      \r\n      return null;\n    }\n\n    final RexBuilder rexBuilder = join.getCluster().getRexBuilder();\n    final RexNode pred = join.getCondition();\n\n    final Multimap<List<String>, RelTableRef> qualifiedNamesToRefs = HashMultimap.create();\n    RelOptPredicateList newPreds = RelOptPredicateList.EMPTY;\n    for (RelNode input : join.getInputs()) {\n      final RelOptPredicateList inputPreds = mq.getAllPredicates(input);\n      if (inputPreds == null) {\n        \r\n        return null;\n      }\n      \r\n      final Set<RelTableRef> tableRefs = mq.getTableReferences(input);\n      if (input == join.getLeft()) {\n        \r\n        for (RelTableRef leftRef : tableRefs) {\n          qualifiedNamesToRefs.put(leftRef.getQualifiedName(), leftRef);\n        }\n        newPreds = newPreds.union(rexBuilder, inputPreds);\n      } else {\n        \r\n        \r\n        final Map<RelTableRef, RelTableRef> currentTablesMapping = new HashMap<>();\n        for (RelTableRef rightRef : tableRefs) {\n          int shift = 0;\n          Collection<RelTableRef> lRefs = qualifiedNamesToRefs.get(\n              rightRef.getQualifiedName());\n          if (lRefs != null) {\n            shift = lRefs.size();\n          }\n          currentTablesMapping.put(rightRef,\n              RelTableRef.of(rightRef.getTable(), shift + rightRef.getEntityNumber()));\n        }\n        final List<RexNode> updatedPreds =\n            Util.transform(inputPreds.pulledUpPredicates,\n                e -> RexUtil.swapTableReferences(rexBuilder, e,\n                    currentTablesMapping));\n        newPreds = newPreds.union(rexBuilder,\n            RelOptPredicateList.of(rexBuilder, updatedPreds));\n      }\n    }\n\n    \r\n    final Set<RelDataTypeField> inputExtraFields = new LinkedHashSet<>();\n    final RelOptUtil.InputFinder inputFinder = new RelOptUtil.InputFinder(inputExtraFields);\n    pred.accept(inputFinder);\n    final ImmutableBitSet inputFieldsUsed = inputFinder.build();\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    final RelDataType fullRowType = SqlValidatorUtil.createJoinType(\n        rexBuilder.getTypeFactory(),\n        join.getLeft().getRowType(),\n        join.getRight().getRowType(),\n        null,\n        ImmutableList.of());\n    for (int idx : inputFieldsUsed) {\n      final RexInputRef inputRef = RexInputRef.of(idx, fullRowType.getFieldList());\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(join, inputRef);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, fullRowType.getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    final Set<RexNode> allExprs =\n        RelMdExpressionLineage.createAllPossibleExpressions(rexBuilder, pred, mapping);\n    if (allExprs == null) {\n      return null;\n    }\n    return newPreds.union(rexBuilder, RelOptPredicateList.of(rexBuilder, allExprs));\n  }\n","date":"2020-09-30 16:54:11","endLine":246,"groupId":"3721","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getAllPredicates","params":"(Joinjoin@RelMetadataQuerymq)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/2a/e457156dfe0184029de9661320ffde1bdaa29e.src","preCode":"  public RelOptPredicateList getAllPredicates(Join join, RelMetadataQuery mq) {\n    if (join.getJoinType().isOuterJoin()) {\n      \r\n      return null;\n    }\n\n    final RexBuilder rexBuilder = join.getCluster().getRexBuilder();\n    final RexNode pred = join.getCondition();\n\n    final Multimap<List<String>, RelTableRef> qualifiedNamesToRefs = HashMultimap.create();\n    RelOptPredicateList newPreds = RelOptPredicateList.EMPTY;\n    for (RelNode input : join.getInputs()) {\n      final RelOptPredicateList inputPreds = mq.getAllPredicates(input);\n      if (inputPreds == null) {\n        \r\n        return null;\n      }\n      \r\n      final Set<RelTableRef> tableRefs = mq.getTableReferences(input);\n      if (input == join.getLeft()) {\n        \r\n        for (RelTableRef leftRef : tableRefs) {\n          qualifiedNamesToRefs.put(leftRef.getQualifiedName(), leftRef);\n        }\n        newPreds = newPreds.union(rexBuilder, inputPreds);\n      } else {\n        \r\n        \r\n        final Map<RelTableRef, RelTableRef> currentTablesMapping = new HashMap<>();\n        for (RelTableRef rightRef : tableRefs) {\n          int shift = 0;\n          Collection<RelTableRef> lRefs = qualifiedNamesToRefs.get(\n              rightRef.getQualifiedName());\n          if (lRefs != null) {\n            shift = lRefs.size();\n          }\n          currentTablesMapping.put(rightRef,\n              RelTableRef.of(rightRef.getTable(), shift + rightRef.getEntityNumber()));\n        }\n        final List<RexNode> updatedPreds =\n            Util.transform(inputPreds.pulledUpPredicates,\n                e -> RexUtil.swapTableReferences(rexBuilder, e,\n                    currentTablesMapping));\n        newPreds = newPreds.union(rexBuilder,\n            RelOptPredicateList.of(rexBuilder, updatedPreds));\n      }\n    }\n\n    \r\n    final Set<RelDataTypeField> inputExtraFields = new LinkedHashSet<>();\n    final RelOptUtil.InputFinder inputFinder = new RelOptUtil.InputFinder(inputExtraFields);\n    pred.accept(inputFinder);\n    final ImmutableBitSet inputFieldsUsed = inputFinder.build();\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    final RelDataType fullRowType = SqlValidatorUtil.createJoinType(\n        rexBuilder.getTypeFactory(),\n        join.getLeft().getRowType(),\n        join.getRight().getRowType(),\n        null,\n        ImmutableList.of());\n    for (int idx : inputFieldsUsed) {\n      final RexInputRef inputRef = RexInputRef.of(idx, fullRowType.getFieldList());\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(join, inputRef);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, fullRowType.getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    final Set<RexNode> allExprs =\n        RelMdExpressionLineage.createAllPossibleExpressions(rexBuilder, pred, mapping);\n    if (allExprs == null) {\n      return null;\n    }\n    return newPreds.union(rexBuilder, RelOptPredicateList.of(rexBuilder, allExprs));\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/metadata/RelMdAllPredicates.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":166,"status":"NB"}],"commitId":"99251a51842483bc80688364195a159b740bd53f","commitMessage":"@@@[CALCITE-4251] Support Calc and SetOp operator in RelMdAllPredicates (Xu Zhaohui)\n","date":"2020-11-20 16:24:32","modifiedFileCount":"2","status":"M","submitter":"xzh"},{"authorTime":"2020-05-29 00:04:40","codes":[{"authorDate":"2020-05-29 00:04:40","commitOrder":10,"curCode":"  private @Nullable RelOptPredicateList getAllFilterPredicates(RelNode rel,\n      RelMetadataQuery mq, RexNode pred) {\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n    final RelOptPredicateList predsBelow = mq.getAllPredicates(rel);\n    if (predsBelow == null) {\n      \r\n      return null;\n    }\n\n    \r\n    final Set<RelDataTypeField> inputExtraFields = new LinkedHashSet<>();\n    final RelOptUtil.InputFinder inputFinder = new RelOptUtil.InputFinder(inputExtraFields);\n    pred.accept(inputFinder);\n    final ImmutableBitSet inputFieldsUsed = inputFinder.build();\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(rel, ref);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    final Set<RexNode> allExprs =\n        RelMdExpressionLineage.createAllPossibleExpressions(rexBuilder, pred, mapping);\n    if (allExprs == null) {\n      return null;\n    }\n    return predsBelow.union(rexBuilder, RelOptPredicateList.of(rexBuilder, allExprs));\n  }\n","date":"2020-11-30 06:45:33","endLine":188,"groupId":"3722","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"getAllFilterPredicates","params":"(RelNoderel@RelMetadataQuerymq@RexNodepred)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/72/a998433b54c1868b1f5068eb12944da831e6df.src","preCode":"  private RelOptPredicateList getAllFilterPredicates(RelNode rel,\n      RelMetadataQuery mq, RexNode pred) {\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n    final RelOptPredicateList predsBelow = mq.getAllPredicates(rel);\n    if (predsBelow == null) {\n      \r\n      return null;\n    }\n\n    \r\n    final Set<RelDataTypeField> inputExtraFields = new LinkedHashSet<>();\n    final RelOptUtil.InputFinder inputFinder = new RelOptUtil.InputFinder(inputExtraFields);\n    pred.accept(inputFinder);\n    final ImmutableBitSet inputFieldsUsed = inputFinder.build();\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(rel, ref);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    final Set<RexNode> allExprs =\n        RelMdExpressionLineage.createAllPossibleExpressions(rexBuilder, pred, mapping);\n    if (allExprs == null) {\n      return null;\n    }\n    return predsBelow.union(rexBuilder, RelOptPredicateList.of(rexBuilder, allExprs));\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/metadata/RelMdAllPredicates.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":154,"status":"M"},{"authorDate":"2020-05-29 00:04:40","commitOrder":10,"curCode":"  public @Nullable RelOptPredicateList getAllPredicates(Join join, RelMetadataQuery mq) {\n    if (join.getJoinType().isOuterJoin()) {\n      \r\n      return null;\n    }\n\n    final RexBuilder rexBuilder = join.getCluster().getRexBuilder();\n    final RexNode pred = join.getCondition();\n\n    final Multimap<List<String>, RelTableRef> qualifiedNamesToRefs = HashMultimap.create();\n    RelOptPredicateList newPreds = RelOptPredicateList.EMPTY;\n    for (RelNode input : join.getInputs()) {\n      final RelOptPredicateList inputPreds = mq.getAllPredicates(input);\n      if (inputPreds == null) {\n        \r\n        return null;\n      }\n      \r\n      final Set<RelTableRef> tableRefs = mq.getTableReferences(input);\n      if (tableRefs == null) {\n        return null;\n      }\n      if (input == join.getLeft()) {\n        \r\n        for (RelTableRef leftRef : tableRefs) {\n          qualifiedNamesToRefs.put(leftRef.getQualifiedName(), leftRef);\n        }\n        newPreds = newPreds.union(rexBuilder, inputPreds);\n      } else {\n        \r\n        \r\n        final Map<RelTableRef, RelTableRef> currentTablesMapping = new HashMap<>();\n        for (RelTableRef rightRef : tableRefs) {\n          int shift = 0;\n          Collection<RelTableRef> lRefs = qualifiedNamesToRefs.get(\n              rightRef.getQualifiedName());\n          if (lRefs != null) {\n            shift = lRefs.size();\n          }\n          currentTablesMapping.put(rightRef,\n              RelTableRef.of(rightRef.getTable(), shift + rightRef.getEntityNumber()));\n        }\n        final List<RexNode> updatedPreds =\n            Util.transform(inputPreds.pulledUpPredicates,\n                e -> RexUtil.swapTableReferences(rexBuilder, e,\n                    currentTablesMapping));\n        newPreds = newPreds.union(rexBuilder,\n            RelOptPredicateList.of(rexBuilder, updatedPreds));\n      }\n    }\n\n    \r\n    final Set<RelDataTypeField> inputExtraFields = new LinkedHashSet<>();\n    final RelOptUtil.InputFinder inputFinder = new RelOptUtil.InputFinder(inputExtraFields);\n    pred.accept(inputFinder);\n    final ImmutableBitSet inputFieldsUsed = inputFinder.build();\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    final RelDataType fullRowType = SqlValidatorUtil.createJoinType(\n        rexBuilder.getTypeFactory(),\n        join.getLeft().getRowType(),\n        join.getRight().getRowType(),\n        null,\n        ImmutableList.of());\n    for (int idx : inputFieldsUsed) {\n      final RexInputRef inputRef = RexInputRef.of(idx, fullRowType.getFieldList());\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(join, inputRef);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, fullRowType.getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    final Set<RexNode> allExprs =\n        RelMdExpressionLineage.createAllPossibleExpressions(rexBuilder, pred, mapping);\n    if (allExprs == null) {\n      return null;\n    }\n    return newPreds.union(rexBuilder, RelOptPredicateList.of(rexBuilder, allExprs));\n  }\n","date":"2020-11-30 06:45:33","endLine":276,"groupId":"3721","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getAllPredicates","params":"(Joinjoin@RelMetadataQuerymq)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/72/a998433b54c1868b1f5068eb12944da831e6df.src","preCode":"  public RelOptPredicateList getAllPredicates(Join join, RelMetadataQuery mq) {\n    if (join.getJoinType().isOuterJoin()) {\n      \r\n      return null;\n    }\n\n    final RexBuilder rexBuilder = join.getCluster().getRexBuilder();\n    final RexNode pred = join.getCondition();\n\n    final Multimap<List<String>, RelTableRef> qualifiedNamesToRefs = HashMultimap.create();\n    RelOptPredicateList newPreds = RelOptPredicateList.EMPTY;\n    for (RelNode input : join.getInputs()) {\n      final RelOptPredicateList inputPreds = mq.getAllPredicates(input);\n      if (inputPreds == null) {\n        \r\n        return null;\n      }\n      \r\n      final Set<RelTableRef> tableRefs = mq.getTableReferences(input);\n      if (input == join.getLeft()) {\n        \r\n        for (RelTableRef leftRef : tableRefs) {\n          qualifiedNamesToRefs.put(leftRef.getQualifiedName(), leftRef);\n        }\n        newPreds = newPreds.union(rexBuilder, inputPreds);\n      } else {\n        \r\n        \r\n        final Map<RelTableRef, RelTableRef> currentTablesMapping = new HashMap<>();\n        for (RelTableRef rightRef : tableRefs) {\n          int shift = 0;\n          Collection<RelTableRef> lRefs = qualifiedNamesToRefs.get(\n              rightRef.getQualifiedName());\n          if (lRefs != null) {\n            shift = lRefs.size();\n          }\n          currentTablesMapping.put(rightRef,\n              RelTableRef.of(rightRef.getTable(), shift + rightRef.getEntityNumber()));\n        }\n        final List<RexNode> updatedPreds =\n            Util.transform(inputPreds.pulledUpPredicates,\n                e -> RexUtil.swapTableReferences(rexBuilder, e,\n                    currentTablesMapping));\n        newPreds = newPreds.union(rexBuilder,\n            RelOptPredicateList.of(rexBuilder, updatedPreds));\n      }\n    }\n\n    \r\n    final Set<RelDataTypeField> inputExtraFields = new LinkedHashSet<>();\n    final RelOptUtil.InputFinder inputFinder = new RelOptUtil.InputFinder(inputExtraFields);\n    pred.accept(inputFinder);\n    final ImmutableBitSet inputFieldsUsed = inputFinder.build();\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    final RelDataType fullRowType = SqlValidatorUtil.createJoinType(\n        rexBuilder.getTypeFactory(),\n        join.getLeft().getRowType(),\n        join.getRight().getRowType(),\n        null,\n        ImmutableList.of());\n    for (int idx : inputFieldsUsed) {\n      final RexInputRef inputRef = RexInputRef.of(idx, fullRowType.getFieldList());\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(join, inputRef);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, fullRowType.getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    final Set<RexNode> allExprs =\n        RelMdExpressionLineage.createAllPossibleExpressions(rexBuilder, pred, mapping);\n    if (allExprs == null) {\n      return null;\n    }\n    return newPreds.union(rexBuilder, RelOptPredicateList.of(rexBuilder, allExprs));\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/metadata/RelMdAllPredicates.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":193,"status":"M"}],"commitId":"d9a81b88ad561e7e4cedae93e805e0d7a53a7f1a","commitMessage":"@@@[CALCITE-4199] Add nullability annotations\n\nThe commit includes javadoc updates and refactorings made by Julian Hyde in https://github.com/apache/calcite/pull/2278\n","date":"2020-11-30 06:45:33","modifiedFileCount":"1012","status":"M","submitter":"Vladimir Sitnikov"},{"authorTime":"2020-05-29 00:04:40","codes":[{"authorDate":"2020-12-02 05:40:39","commitOrder":11,"curCode":"  private static @Nullable RelOptPredicateList getAllFilterPredicates(RelNode rel,\n      RelMetadataQuery mq, RexNode pred) {\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n    final RelOptPredicateList predsBelow = mq.getAllPredicates(rel);\n    if (predsBelow == null) {\n      \r\n      return null;\n    }\n\n    \r\n    final Set<RelDataTypeField> inputExtraFields = new LinkedHashSet<>();\n    final RelOptUtil.InputFinder inputFinder = new RelOptUtil.InputFinder(inputExtraFields);\n    pred.accept(inputFinder);\n    final ImmutableBitSet inputFieldsUsed = inputFinder.build();\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(rel, ref);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    final Set<RexNode> allExprs =\n        RelMdExpressionLineage.createAllPossibleExpressions(rexBuilder, pred, mapping);\n    if (allExprs == null) {\n      return null;\n    }\n    return predsBelow.union(rexBuilder, RelOptPredicateList.of(rexBuilder, allExprs));\n  }\n","date":"2020-12-08 15:07:23","endLine":188,"groupId":"121938","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"getAllFilterPredicates","params":"(RelNoderel@RelMetadataQuerymq@RexNodepred)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/ef/02613573e0b3acf16495631a2f0cec0201cb93.src","preCode":"  private @Nullable RelOptPredicateList getAllFilterPredicates(RelNode rel,\n      RelMetadataQuery mq, RexNode pred) {\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n    final RelOptPredicateList predsBelow = mq.getAllPredicates(rel);\n    if (predsBelow == null) {\n      \r\n      return null;\n    }\n\n    \r\n    final Set<RelDataTypeField> inputExtraFields = new LinkedHashSet<>();\n    final RelOptUtil.InputFinder inputFinder = new RelOptUtil.InputFinder(inputExtraFields);\n    pred.accept(inputFinder);\n    final ImmutableBitSet inputFieldsUsed = inputFinder.build();\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(rel, ref);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    final Set<RexNode> allExprs =\n        RelMdExpressionLineage.createAllPossibleExpressions(rexBuilder, pred, mapping);\n    if (allExprs == null) {\n      return null;\n    }\n    return predsBelow.union(rexBuilder, RelOptPredicateList.of(rexBuilder, allExprs));\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/metadata/RelMdAllPredicates.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":154,"status":"M"},{"authorDate":"2020-05-29 00:04:40","commitOrder":11,"curCode":"  public @Nullable RelOptPredicateList getAllPredicates(Join join, RelMetadataQuery mq) {\n    if (join.getJoinType().isOuterJoin()) {\n      \r\n      return null;\n    }\n\n    final RexBuilder rexBuilder = join.getCluster().getRexBuilder();\n    final RexNode pred = join.getCondition();\n\n    final Multimap<List<String>, RelTableRef> qualifiedNamesToRefs = HashMultimap.create();\n    RelOptPredicateList newPreds = RelOptPredicateList.EMPTY;\n    for (RelNode input : join.getInputs()) {\n      final RelOptPredicateList inputPreds = mq.getAllPredicates(input);\n      if (inputPreds == null) {\n        \r\n        return null;\n      }\n      \r\n      final Set<RelTableRef> tableRefs = mq.getTableReferences(input);\n      if (tableRefs == null) {\n        return null;\n      }\n      if (input == join.getLeft()) {\n        \r\n        for (RelTableRef leftRef : tableRefs) {\n          qualifiedNamesToRefs.put(leftRef.getQualifiedName(), leftRef);\n        }\n        newPreds = newPreds.union(rexBuilder, inputPreds);\n      } else {\n        \r\n        \r\n        final Map<RelTableRef, RelTableRef> currentTablesMapping = new HashMap<>();\n        for (RelTableRef rightRef : tableRefs) {\n          int shift = 0;\n          Collection<RelTableRef> lRefs = qualifiedNamesToRefs.get(\n              rightRef.getQualifiedName());\n          if (lRefs != null) {\n            shift = lRefs.size();\n          }\n          currentTablesMapping.put(rightRef,\n              RelTableRef.of(rightRef.getTable(), shift + rightRef.getEntityNumber()));\n        }\n        final List<RexNode> updatedPreds =\n            Util.transform(inputPreds.pulledUpPredicates,\n                e -> RexUtil.swapTableReferences(rexBuilder, e,\n                    currentTablesMapping));\n        newPreds = newPreds.union(rexBuilder,\n            RelOptPredicateList.of(rexBuilder, updatedPreds));\n      }\n    }\n\n    \r\n    final Set<RelDataTypeField> inputExtraFields = new LinkedHashSet<>();\n    final RelOptUtil.InputFinder inputFinder = new RelOptUtil.InputFinder(inputExtraFields);\n    pred.accept(inputFinder);\n    final ImmutableBitSet inputFieldsUsed = inputFinder.build();\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    final RelDataType fullRowType = SqlValidatorUtil.createJoinType(\n        rexBuilder.getTypeFactory(),\n        join.getLeft().getRowType(),\n        join.getRight().getRowType(),\n        null,\n        ImmutableList.of());\n    for (int idx : inputFieldsUsed) {\n      final RexInputRef inputRef = RexInputRef.of(idx, fullRowType.getFieldList());\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(join, inputRef);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, fullRowType.getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    final Set<RexNode> allExprs =\n        RelMdExpressionLineage.createAllPossibleExpressions(rexBuilder, pred, mapping);\n    if (allExprs == null) {\n      return null;\n    }\n    return newPreds.union(rexBuilder, RelOptPredicateList.of(rexBuilder, allExprs));\n  }\n","date":"2020-11-30 06:45:33","endLine":276,"groupId":"121938","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"getAllPredicates","params":"(Joinjoin@RelMetadataQuerymq)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/72/a998433b54c1868b1f5068eb12944da831e6df.src","preCode":"  public @Nullable RelOptPredicateList getAllPredicates(Join join, RelMetadataQuery mq) {\n    if (join.getJoinType().isOuterJoin()) {\n      \r\n      return null;\n    }\n\n    final RexBuilder rexBuilder = join.getCluster().getRexBuilder();\n    final RexNode pred = join.getCondition();\n\n    final Multimap<List<String>, RelTableRef> qualifiedNamesToRefs = HashMultimap.create();\n    RelOptPredicateList newPreds = RelOptPredicateList.EMPTY;\n    for (RelNode input : join.getInputs()) {\n      final RelOptPredicateList inputPreds = mq.getAllPredicates(input);\n      if (inputPreds == null) {\n        \r\n        return null;\n      }\n      \r\n      final Set<RelTableRef> tableRefs = mq.getTableReferences(input);\n      if (tableRefs == null) {\n        return null;\n      }\n      if (input == join.getLeft()) {\n        \r\n        for (RelTableRef leftRef : tableRefs) {\n          qualifiedNamesToRefs.put(leftRef.getQualifiedName(), leftRef);\n        }\n        newPreds = newPreds.union(rexBuilder, inputPreds);\n      } else {\n        \r\n        \r\n        final Map<RelTableRef, RelTableRef> currentTablesMapping = new HashMap<>();\n        for (RelTableRef rightRef : tableRefs) {\n          int shift = 0;\n          Collection<RelTableRef> lRefs = qualifiedNamesToRefs.get(\n              rightRef.getQualifiedName());\n          if (lRefs != null) {\n            shift = lRefs.size();\n          }\n          currentTablesMapping.put(rightRef,\n              RelTableRef.of(rightRef.getTable(), shift + rightRef.getEntityNumber()));\n        }\n        final List<RexNode> updatedPreds =\n            Util.transform(inputPreds.pulledUpPredicates,\n                e -> RexUtil.swapTableReferences(rexBuilder, e,\n                    currentTablesMapping));\n        newPreds = newPreds.union(rexBuilder,\n            RelOptPredicateList.of(rexBuilder, updatedPreds));\n      }\n    }\n\n    \r\n    final Set<RelDataTypeField> inputExtraFields = new LinkedHashSet<>();\n    final RelOptUtil.InputFinder inputFinder = new RelOptUtil.InputFinder(inputExtraFields);\n    pred.accept(inputFinder);\n    final ImmutableBitSet inputFieldsUsed = inputFinder.build();\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    final RelDataType fullRowType = SqlValidatorUtil.createJoinType(\n        rexBuilder.getTypeFactory(),\n        join.getLeft().getRowType(),\n        join.getRight().getRowType(),\n        null,\n        ImmutableList.of());\n    for (int idx : inputFieldsUsed) {\n      final RexInputRef inputRef = RexInputRef.of(idx, fullRowType.getFieldList());\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(join, inputRef);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, fullRowType.getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    final Set<RexNode> allExprs =\n        RelMdExpressionLineage.createAllPossibleExpressions(rexBuilder, pred, mapping);\n    if (allExprs == null) {\n      return null;\n    }\n    return newPreds.union(rexBuilder, RelOptPredicateList.of(rexBuilder, allExprs));\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/metadata/RelMdAllPredicates.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":193,"status":"N"}],"commitId":"404f968f6079360621896e6ee20ec12488a40bc2","commitMessage":"@@@[CALCITE-4422] Add MethodCanBeStatic check via ErrorProne\n\nprivate and final methods can be made static.  so it is clear they do not access instance fields\n","date":"2020-12-08 15:07:23","modifiedFileCount":"169","status":"M","submitter":"Vladimir Sitnikov"}]
