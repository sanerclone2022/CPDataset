[{"authorTime":"2014-12-14 15:49:02","codes":[{"authorDate":"2014-12-14 15:49:02","commitOrder":1,"curCode":"  public static EnumerableFilter create(final RelNode input,\n      RexNode condition) {\n    final RelOptCluster cluster = input.getCluster();\n    final RelTraitSet traitSet =\n        cluster.traitSetOf(EnumerableConvention.INSTANCE)\n            .replaceIf(RelCollationTraitDef.INSTANCE,\n                new Supplier<List<RelCollation>>() {\n                public List<RelCollation> get() {\n                  return RelMdCollation.filter(input);\n                }\n              });\n    return new EnumerableFilter(cluster, traitSet, input, condition);\n  }\n","date":"2015-02-08 16:45:51","endLine":62,"groupId":"8931","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"create","params":"(finalRelNodeinput@RexNodecondition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/f4/cc5e9d9d33c88d4290cf1b69156485b8f4c5cf.src","preCode":"  public static EnumerableFilter create(final RelNode input,\n      RexNode condition) {\n    final RelOptCluster cluster = input.getCluster();\n    final RelTraitSet traitSet =\n        cluster.traitSetOf(EnumerableConvention.INSTANCE)\n            .replaceIf(RelCollationTraitDef.INSTANCE,\n                new Supplier<List<RelCollation>>() {\n                public List<RelCollation> get() {\n                  return RelMdCollation.filter(input);\n                }\n              });\n    return new EnumerableFilter(cluster, traitSet, input, condition);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableFilter.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":50,"status":"B"},{"authorDate":"2014-12-14 15:49:02","commitOrder":1,"curCode":"  public static EnumerableLimit create(final RelNode input, RexNode offset,\n      RexNode fetch) {\n    final RelOptCluster cluster = input.getCluster();\n    final RelTraitSet traitSet =\n        cluster.traitSetOf(EnumerableConvention.INSTANCE)\n            .replaceIf(RelCollationTraitDef.INSTANCE,\n                new Supplier<List<RelCollation>>() {\n                  public List<RelCollation> get() {\n                    return RelMdCollation.filter(input);\n                  }\n                });\n    return new EnumerableLimit(cluster, traitSet, input, offset, fetch);\n  }\n","date":"2015-02-08 16:45:51","endLine":72,"groupId":"8931","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"create","params":"(finalRelNodeinput@RexNodeoffset@RexNodefetch)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/2b/ef8c87d99c87b5bb09bbb15e0f883306eb2522.src","preCode":"  public static EnumerableLimit create(final RelNode input, RexNode offset,\n      RexNode fetch) {\n    final RelOptCluster cluster = input.getCluster();\n    final RelTraitSet traitSet =\n        cluster.traitSetOf(EnumerableConvention.INSTANCE)\n            .replaceIf(RelCollationTraitDef.INSTANCE,\n                new Supplier<List<RelCollation>>() {\n                  public List<RelCollation> get() {\n                    return RelMdCollation.filter(input);\n                  }\n                });\n    return new EnumerableLimit(cluster, traitSet, input, offset, fetch);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableLimit.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":60,"status":"B"}],"commitId":"2709896eb176c14605b1ddc4be57d916ebeb0fe8","commitMessage":"@@@[CALCITE-88] Add collation as a trait and a kind of RelNode metadata\n\n[CALCITE-526] Add EnumerableMergeJoin.  which exploits sorted inputs\n\n[CALCITE-71] Provide a way to declare that tables are sorted\n\n[CALCITE-576] Make RelCollation trait and AbstractRelNode.getCollationList consistent\n\n[CALCITE-581] Add LogicalSort relational expression.  and make Sort abstract\n\n[CALCITE-254] Propagate RelCollation on aliased columns in JoinRule\n\n[CALCITE-569] ArrayIndexOutOfBoundsException when deducing collation\n\nMore efficient algorithm to check for cycles in the tree of equivalence sets.\n\nFilterJoinRule now propagates traits.\n\nOrd.zip returns random-access list.\n\nReplace references to \"Bug#upgrade\" with \"Deprecated // to be removed before ...\"\n\nAdd composite traits (RelCompositeTrait); subsets only ever have a simple trait.  but other RelNodes can have multiple traits.  and appear in each subset that those traits. Each composite trait is canonized within its trait definition.  and each of the component traits.\n\nRename RelTraitSet.subsumes and RelTrait.subsumes to satisfies.\n","date":"2015-02-08 16:45:51","modifiedFileCount":"128","status":"B","submitter":"Julian Hyde"},{"authorTime":"2015-02-13 12:42:23","codes":[{"authorDate":"2015-02-13 12:42:23","commitOrder":2,"curCode":"  public static EnumerableFilter create(final RelNode input,\n      RexNode condition) {\n    final RelOptCluster cluster = input.getCluster();\n    final RelTraitSet traitSet =\n        cluster.traitSetOf(EnumerableConvention.INSTANCE)\n            .replaceIfs(\n                RelCollationTraitDef.INSTANCE,\n                new Supplier<List<RelCollation>>() {\n                  public List<RelCollation> get() {\n                    return RelMdCollation.filter(input);\n                  }\n                })\n            .replaceIf(RelDistributionTraitDef.INSTANCE,\n                new Supplier<RelDistribution>() {\n                  public RelDistribution get() {\n                    return RelMdDistribution.filter(input);\n                  }\n                });\n    return new EnumerableFilter(cluster, traitSet, input, condition);\n  }\n","date":"2015-02-18 09:18:19","endLine":72,"groupId":"8931","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"create","params":"(finalRelNodeinput@RexNodecondition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/7d/ccf91f755a8bd39b9e999020085668f146703d.src","preCode":"  public static EnumerableFilter create(final RelNode input,\n      RexNode condition) {\n    final RelOptCluster cluster = input.getCluster();\n    final RelTraitSet traitSet =\n        cluster.traitSetOf(EnumerableConvention.INSTANCE)\n            .replaceIf(RelCollationTraitDef.INSTANCE,\n                new Supplier<List<RelCollation>>() {\n                public List<RelCollation> get() {\n                  return RelMdCollation.filter(input);\n                }\n              });\n    return new EnumerableFilter(cluster, traitSet, input, condition);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableFilter.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":53,"status":"M"},{"authorDate":"2015-02-13 12:42:23","commitOrder":2,"curCode":"  public static EnumerableLimit create(final RelNode input, RexNode offset,\n      RexNode fetch) {\n    final RelOptCluster cluster = input.getCluster();\n    final RelTraitSet traitSet =\n        cluster.traitSetOf(EnumerableConvention.INSTANCE)\n            .replaceIfs(\n                RelCollationTraitDef.INSTANCE,\n                new Supplier<List<RelCollation>>() {\n                  public List<RelCollation> get() {\n                    return RelMdCollation.limit(input);\n                  }\n                })\n            .replaceIf(RelDistributionTraitDef.INSTANCE,\n                new Supplier<RelDistribution>() {\n                  public RelDistribution get() {\n                    return RelMdDistribution.limit(input);\n                  }\n                });\n    return new EnumerableLimit(cluster, traitSet, input, offset, fetch);\n  }\n","date":"2015-02-18 09:18:19","endLine":82,"groupId":"8931","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"create","params":"(finalRelNodeinput@RexNodeoffset@RexNodefetch)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/5d/1dc633ca7d228710fa7cf11ec9f0a89ba4b895.src","preCode":"  public static EnumerableLimit create(final RelNode input, RexNode offset,\n      RexNode fetch) {\n    final RelOptCluster cluster = input.getCluster();\n    final RelTraitSet traitSet =\n        cluster.traitSetOf(EnumerableConvention.INSTANCE)\n            .replaceIf(RelCollationTraitDef.INSTANCE,\n                new Supplier<List<RelCollation>>() {\n                  public List<RelCollation> get() {\n                    return RelMdCollation.filter(input);\n                  }\n                });\n    return new EnumerableLimit(cluster, traitSet, input, offset, fetch);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableLimit.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"M"}],"commitId":"18d4f70a7ebd5f5b3b0d8b83820f8d770be1d19e","commitMessage":"@@@[CALCITE-594] Add RelDistribution trait and Exchange relational expression\n\nClose apache/incubator-calcite#52\n","date":"2015-02-18 09:18:19","modifiedFileCount":"41","status":"M","submitter":"Julian Hyde"},{"authorTime":"2015-07-12 05:56:42","codes":[{"authorDate":"2015-07-12 05:56:42","commitOrder":3,"curCode":"  public static EnumerableFilter create(final RelNode input,\n      RexNode condition) {\n    final RelOptCluster cluster = input.getCluster();\n    final RelMetadataQuery mq = RelMetadataQuery.instance();\n    final RelTraitSet traitSet =\n        cluster.traitSetOf(EnumerableConvention.INSTANCE)\n            .replaceIfs(\n                RelCollationTraitDef.INSTANCE,\n                new Supplier<List<RelCollation>>() {\n                  public List<RelCollation> get() {\n                    return RelMdCollation.filter(mq, input);\n                  }\n                })\n            .replaceIf(RelDistributionTraitDef.INSTANCE,\n                new Supplier<RelDistribution>() {\n                  public RelDistribution get() {\n                    return RelMdDistribution.filter(mq, input);\n                  }\n                });\n    return new EnumerableFilter(cluster, traitSet, input, condition);\n  }\n","date":"2016-01-10 16:51:25","endLine":74,"groupId":"11884","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"create","params":"(finalRelNodeinput@RexNodecondition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/89/4ff167850de528b0ff8f9edd23958e237c99fd.src","preCode":"  public static EnumerableFilter create(final RelNode input,\n      RexNode condition) {\n    final RelOptCluster cluster = input.getCluster();\n    final RelTraitSet traitSet =\n        cluster.traitSetOf(EnumerableConvention.INSTANCE)\n            .replaceIfs(\n                RelCollationTraitDef.INSTANCE,\n                new Supplier<List<RelCollation>>() {\n                  public List<RelCollation> get() {\n                    return RelMdCollation.filter(input);\n                  }\n                })\n            .replaceIf(RelDistributionTraitDef.INSTANCE,\n                new Supplier<RelDistribution>() {\n                  public RelDistribution get() {\n                    return RelMdDistribution.filter(input);\n                  }\n                });\n    return new EnumerableFilter(cluster, traitSet, input, condition);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableFilter.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":54,"status":"M"},{"authorDate":"2015-07-12 05:56:42","commitOrder":3,"curCode":"  public static EnumerableLimit create(final RelNode input, RexNode offset,\n      RexNode fetch) {\n    final RelOptCluster cluster = input.getCluster();\n    final RelMetadataQuery mq = RelMetadataQuery.instance();\n    final RelTraitSet traitSet =\n        cluster.traitSetOf(EnumerableConvention.INSTANCE)\n            .replaceIfs(\n                RelCollationTraitDef.INSTANCE,\n                new Supplier<List<RelCollation>>() {\n                  public List<RelCollation> get() {\n                    return RelMdCollation.limit(mq, input);\n                  }\n                })\n            .replaceIf(RelDistributionTraitDef.INSTANCE,\n                new Supplier<RelDistribution>() {\n                  public RelDistribution get() {\n                    return RelMdDistribution.limit(mq, input);\n                  }\n                });\n    return new EnumerableLimit(cluster, traitSet, input, offset, fetch);\n  }\n","date":"2016-01-10 16:51:25","endLine":84,"groupId":"11884","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"create","params":"(finalRelNodeinput@RexNodeoffset@RexNodefetch)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/82/7944f375e6a7c72e58a822c8180be9b209a449.src","preCode":"  public static EnumerableLimit create(final RelNode input, RexNode offset,\n      RexNode fetch) {\n    final RelOptCluster cluster = input.getCluster();\n    final RelTraitSet traitSet =\n        cluster.traitSetOf(EnumerableConvention.INSTANCE)\n            .replaceIfs(\n                RelCollationTraitDef.INSTANCE,\n                new Supplier<List<RelCollation>>() {\n                  public List<RelCollation> get() {\n                    return RelMdCollation.limit(input);\n                  }\n                })\n            .replaceIf(RelDistributionTraitDef.INSTANCE,\n                new Supplier<RelDistribution>() {\n                  public RelDistribution get() {\n                    return RelMdDistribution.limit(input);\n                  }\n                });\n    return new EnumerableLimit(cluster, traitSet, input, offset, fetch);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableLimit.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":64,"status":"M"}],"commitId":"cabdcf44e4aec4d4ceea7f97c8c6fd9e9dbd36b1","commitMessage":"@@@[CALCITE-794] Detect cycles when computing statistics\n\nMake RelMetadataQuery methods non-static. Each active call is\nregistered in the RelMetadataQuery instance; it throws\nCyclicMetadataException when it detects a cycle.  and the caller can\ncatch it to return a sensible default value for the particular kind of\nmetadata.\n\nChange signature of FlatLists.of(Object...) to\nFlatLists.copyOf(Comparable...).\n\nTemporarily disable all failing tests.\n\nAdd metadata for EnumerableLimit.\n","date":"2016-01-10 16:51:25","modifiedFileCount":"122","status":"M","submitter":"Julian Hyde"},{"authorTime":"2017-05-31 15:54:26","codes":[{"authorDate":"2017-05-31 15:54:26","commitOrder":4,"curCode":"  public static EnumerableFilter create(final RelNode input,\n      RexNode condition) {\n    final RelOptCluster cluster = input.getCluster();\n    final RelMetadataQuery mq = cluster.getMetadataQuery();\n    final RelTraitSet traitSet =\n        cluster.traitSetOf(EnumerableConvention.INSTANCE)\n            .replaceIfs(\n                RelCollationTraitDef.INSTANCE,\n                new Supplier<List<RelCollation>>() {\n                  public List<RelCollation> get() {\n                    return RelMdCollation.filter(mq, input);\n                  }\n                })\n            .replaceIf(RelDistributionTraitDef.INSTANCE,\n                new Supplier<RelDistribution>() {\n                  public RelDistribution get() {\n                    return RelMdDistribution.filter(mq, input);\n                  }\n                });\n    return new EnumerableFilter(cluster, traitSet, input, condition);\n  }\n","date":"2017-06-10 04:55:16","endLine":74,"groupId":"11884","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"create","params":"(finalRelNodeinput@RexNodecondition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/da/1cefa6cff7cb2504bdf058869d0ba01e99040f.src","preCode":"  public static EnumerableFilter create(final RelNode input,\n      RexNode condition) {\n    final RelOptCluster cluster = input.getCluster();\n    final RelMetadataQuery mq = RelMetadataQuery.instance();\n    final RelTraitSet traitSet =\n        cluster.traitSetOf(EnumerableConvention.INSTANCE)\n            .replaceIfs(\n                RelCollationTraitDef.INSTANCE,\n                new Supplier<List<RelCollation>>() {\n                  public List<RelCollation> get() {\n                    return RelMdCollation.filter(mq, input);\n                  }\n                })\n            .replaceIf(RelDistributionTraitDef.INSTANCE,\n                new Supplier<RelDistribution>() {\n                  public RelDistribution get() {\n                    return RelMdDistribution.filter(mq, input);\n                  }\n                });\n    return new EnumerableFilter(cluster, traitSet, input, condition);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableFilter.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":54,"status":"M"},{"authorDate":"2017-05-31 15:54:26","commitOrder":4,"curCode":"  public static EnumerableLimit create(final RelNode input, RexNode offset,\n      RexNode fetch) {\n    final RelOptCluster cluster = input.getCluster();\n    final RelMetadataQuery mq = cluster.getMetadataQuery();\n    final RelTraitSet traitSet =\n        cluster.traitSetOf(EnumerableConvention.INSTANCE)\n            .replaceIfs(\n                RelCollationTraitDef.INSTANCE,\n                new Supplier<List<RelCollation>>() {\n                  public List<RelCollation> get() {\n                    return RelMdCollation.limit(mq, input);\n                  }\n                })\n            .replaceIf(RelDistributionTraitDef.INSTANCE,\n                new Supplier<RelDistribution>() {\n                  public RelDistribution get() {\n                    return RelMdDistribution.limit(mq, input);\n                  }\n                });\n    return new EnumerableLimit(cluster, traitSet, input, offset, fetch);\n  }\n","date":"2017-06-10 04:55:16","endLine":84,"groupId":"11884","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"create","params":"(finalRelNodeinput@RexNodeoffset@RexNodefetch)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/0e/00dda207e5f8dc1ba6978380d798980d70a606.src","preCode":"  public static EnumerableLimit create(final RelNode input, RexNode offset,\n      RexNode fetch) {\n    final RelOptCluster cluster = input.getCluster();\n    final RelMetadataQuery mq = RelMetadataQuery.instance();\n    final RelTraitSet traitSet =\n        cluster.traitSetOf(EnumerableConvention.INSTANCE)\n            .replaceIfs(\n                RelCollationTraitDef.INSTANCE,\n                new Supplier<List<RelCollation>>() {\n                  public List<RelCollation> get() {\n                    return RelMdCollation.limit(mq, input);\n                  }\n                })\n            .replaceIf(RelDistributionTraitDef.INSTANCE,\n                new Supplier<RelDistribution>() {\n                  public RelDistribution get() {\n                    return RelMdDistribution.limit(mq, input);\n                  }\n                });\n    return new EnumerableLimit(cluster, traitSet, input, offset, fetch);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableLimit.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":64,"status":"M"}],"commitId":"56d5261abb893dd92b0a2cc4893292876a2b7880","commitMessage":"@@@[CALCITE-1812] Cache RelMetadataQuery.  invalidating when a rule registers new RelNodes (Remus Rusanu)\n\nRelMetadataQuery is cached in RelOptCluster; it is invalidated when a\nrule calls RelOptRuleCall.transformTo.  because that may affect costs\nand other statistics; rules (and other code) should get it via\nRelOptRuleCall.getMetadataQuery whenever possible.\n\nClose apache/calcite#462\n","date":"2017-06-10 04:55:16","modifiedFileCount":"43","status":"M","submitter":"Remus Rusanu"},{"authorTime":"2018-07-06 04:21:59","codes":[{"authorDate":"2018-07-06 04:21:59","commitOrder":5,"curCode":"  public static EnumerableFilter create(final RelNode input,\n      RexNode condition) {\n    final RelOptCluster cluster = input.getCluster();\n    final RelMetadataQuery mq = cluster.getMetadataQuery();\n    final RelTraitSet traitSet =\n        cluster.traitSetOf(EnumerableConvention.INSTANCE)\n            .replaceIfs(\n                RelCollationTraitDef.INSTANCE,\n                () -> RelMdCollation.filter(mq, input))\n            .replaceIf(RelDistributionTraitDef.INSTANCE,\n                () -> RelMdDistribution.filter(mq, input));\n    return new EnumerableFilter(cluster, traitSet, input, condition);\n  }\n","date":"2018-07-09 01:16:26","endLine":60,"groupId":"11137","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"create","params":"(finalRelNodeinput@RexNodecondition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/51/4c8ad72c4db23ae5edd82dbdb934ba57090e76.src","preCode":"  public static EnumerableFilter create(final RelNode input,\n      RexNode condition) {\n    final RelOptCluster cluster = input.getCluster();\n    final RelMetadataQuery mq = cluster.getMetadataQuery();\n    final RelTraitSet traitSet =\n        cluster.traitSetOf(EnumerableConvention.INSTANCE)\n            .replaceIfs(\n                RelCollationTraitDef.INSTANCE,\n                new Supplier<List<RelCollation>>() {\n                  public List<RelCollation> get() {\n                    return RelMdCollation.filter(mq, input);\n                  }\n                })\n            .replaceIf(RelDistributionTraitDef.INSTANCE,\n                new Supplier<RelDistribution>() {\n                  public RelDistribution get() {\n                    return RelMdDistribution.filter(mq, input);\n                  }\n                });\n    return new EnumerableFilter(cluster, traitSet, input, condition);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableFilter.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":48,"status":"M"},{"authorDate":"2018-07-06 04:21:59","commitOrder":5,"curCode":"  public static EnumerableLimit create(final RelNode input, RexNode offset,\n      RexNode fetch) {\n    final RelOptCluster cluster = input.getCluster();\n    final RelMetadataQuery mq = cluster.getMetadataQuery();\n    final RelTraitSet traitSet =\n        cluster.traitSetOf(EnumerableConvention.INSTANCE)\n            .replaceIfs(\n                RelCollationTraitDef.INSTANCE,\n                () -> RelMdCollation.limit(mq, input))\n            .replaceIf(RelDistributionTraitDef.INSTANCE,\n                () -> RelMdDistribution.limit(mq, input));\n    return new EnumerableLimit(cluster, traitSet, input, offset, fetch);\n  }\n","date":"2018-07-09 01:16:26","endLine":74,"groupId":"11137","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"create","params":"(finalRelNodeinput@RexNodeoffset@RexNodefetch)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/82/5aa7d9be9877ed53903e15cd6e94c89adb3a93.src","preCode":"  public static EnumerableLimit create(final RelNode input, RexNode offset,\n      RexNode fetch) {\n    final RelOptCluster cluster = input.getCluster();\n    final RelMetadataQuery mq = cluster.getMetadataQuery();\n    final RelTraitSet traitSet =\n        cluster.traitSetOf(EnumerableConvention.INSTANCE)\n            .replaceIfs(\n                RelCollationTraitDef.INSTANCE,\n                new Supplier<List<RelCollation>>() {\n                  public List<RelCollation> get() {\n                    return RelMdCollation.limit(mq, input);\n                  }\n                })\n            .replaceIf(RelDistributionTraitDef.INSTANCE,\n                new Supplier<RelDistribution>() {\n                  public RelDistribution get() {\n                    return RelMdDistribution.limit(mq, input);\n                  }\n                });\n    return new EnumerableLimit(cluster, traitSet, input, offset, fetch);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableLimit.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":62,"status":"M"}],"commitId":"d59b639d27da704f00eff616324a2c04aa06f84c","commitMessage":"@@@[CALCITE-2259] Allow Java 8 syntax\n\nIn summary: use lambdas where possible.  switch from Guava function\ntypes to Java function types or lambdas.  but continue to use Guava\ncomponents (such as immutable collections and cache) that have no\nequivalent in the Java runtime.\n\n1. Change single-abstract-method (SAM) classes to lambdas. Preserve\nformatting wherever possible.\n\n2. Change AssertQuery.returns argument type from Guava Function to Java\nConsumer. If you are using a lambda and see 'returns is deprecated'. \nremove the 'return null;' line.  and the lambda will become a Consumer\n(whose return is void).\n\n3. Change RelOptRuleOperand and RelOptRule.operand methods to take Java\nPredicate rather than Guava Predicate.\n\n4. Change the argument of Hook.add and .addThread from Guava Function to\nJava Consumer.\n\n5. Change 'list.toArray(new T[list.size()])' to 'list.toArray(new T[0])'\nbecause the latter is simpler.  and just as efficient on recent Java\nversions.\n\n6. Resource references; change \"try (Closeable ignore = foo())\" to \"try\n  (foo())\".  especially uses of TryThreadLocal and Hook.Closeable.\n\n7. Convert linq4j Function1 to java Function.  Function2 to java BiFunction\n\n8. Fix occurrences of Intellij's \"Explicit type can be replaced with\n<>\" inspection. (Occurs for \"List<String> list = new\nArrayList<String>();\".)\n\n9. Change Guava Preconditions.checkNotNull to Java\nObjects.requireNonNull. (Kevin Risden)\n\n10. Break out anonymous classes and fix dependency problems.\n\n11. Use CacheLoader.of(Function) where possible.\n\n12. Replace sub-classes of ThreadLocal with ThreadLocal.withInitial().\n\n13. Replace Guava collection methods with calls to Java collection types. \nfor example replace Lists.newArrayList() with new ArrayList<>(). \nMaps.newHashSet() with new HashSet<>().  similarly Sets.\n\n14. Replace Guava Joiner with String.join.\n\n15. Replace Collections.emptyList() with ImmutableList.of() in a few\nplaces.\n\nFor backwards compatibility.  we preserved (and deprecated) the old\nmethods that used Guava types. In a few cases where new and old have\nthe same signature (after erasure).  we could not add a method with the\nsame name.  so we gave the new method a \"J\" suffix. Examples include\nHook.property and .propertyJ.  RelOptRule.operand and .operandJ.\n\nIn test code.  we have not slavishly ensured backwards compatibility.\n\nWe do not intend to remove uses of Guava's immutable collections.\n\nWe have ignored Intellij's \"Pseudo functional style code\" inspection\nmost of the time.  but in a few cases have converted Lists.transform(). \nIterables.transform().  and Iterables.filter() into Java streams. Use\nthe Util.toImmutableList() collector if the result is to be an\nimmutable list. Use Util.transform() rather than Lists.transform()\nif you have a Java function rather than a Guava function or lambda.\n\nNot covered in this change (might be done in future):\n* Convert Collections.sort(list) to list.sort.\n* Review uses of 'for (Map.Entry<K.  V> e : map.entrySet())' and see\n  whether it makes sense to convert to 'map.forEach((k.  v) ->\n  ...)'. Intellij inspection is called 'Replace with Map.forEach'.\n\nBreaking changes:\n* LatticeStatisticProvider.Factory.  result of RexUtil.notFun().  and\n  arguments to Mappings.target() are Function (was Guava.  now Java)\n* Argument to SqlSpecialOperator.TokenSequence.parser() is Predicate\n  (was Guava.  now Java)\n* AggregateNode.AccumulatorFactory extends Supplier (was Guava.  now Java)\n","date":"2018-07-09 01:16:26","modifiedFileCount":"514","status":"M","submitter":"Julian Hyde"},{"authorTime":"2020-05-29 00:04:40","codes":[{"authorDate":"2018-07-06 04:21:59","commitOrder":6,"curCode":"  public static EnumerableFilter create(final RelNode input,\n      RexNode condition) {\n    final RelOptCluster cluster = input.getCluster();\n    final RelMetadataQuery mq = cluster.getMetadataQuery();\n    final RelTraitSet traitSet =\n        cluster.traitSetOf(EnumerableConvention.INSTANCE)\n            .replaceIfs(\n                RelCollationTraitDef.INSTANCE,\n                () -> RelMdCollation.filter(mq, input))\n            .replaceIf(RelDistributionTraitDef.INSTANCE,\n                () -> RelMdDistribution.filter(mq, input));\n    return new EnumerableFilter(cluster, traitSet, input, condition);\n  }\n","date":"2018-07-09 01:16:26","endLine":60,"groupId":"102132","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"create","params":"(finalRelNodeinput@RexNodecondition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/51/4c8ad72c4db23ae5edd82dbdb934ba57090e76.src","preCode":"  public static EnumerableFilter create(final RelNode input,\n      RexNode condition) {\n    final RelOptCluster cluster = input.getCluster();\n    final RelMetadataQuery mq = cluster.getMetadataQuery();\n    final RelTraitSet traitSet =\n        cluster.traitSetOf(EnumerableConvention.INSTANCE)\n            .replaceIfs(\n                RelCollationTraitDef.INSTANCE,\n                () -> RelMdCollation.filter(mq, input))\n            .replaceIf(RelDistributionTraitDef.INSTANCE,\n                () -> RelMdDistribution.filter(mq, input));\n    return new EnumerableFilter(cluster, traitSet, input, condition);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableFilter.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":48,"status":"N"},{"authorDate":"2020-05-29 00:04:40","commitOrder":6,"curCode":"  public static EnumerableLimit create(final RelNode input, @Nullable RexNode offset,\n      @Nullable RexNode fetch) {\n    final RelOptCluster cluster = input.getCluster();\n    final RelMetadataQuery mq = cluster.getMetadataQuery();\n    final RelTraitSet traitSet =\n        cluster.traitSetOf(EnumerableConvention.INSTANCE)\n            .replaceIfs(\n                RelCollationTraitDef.INSTANCE,\n                () -> RelMdCollation.limit(mq, input))\n            .replaceIf(RelDistributionTraitDef.INSTANCE,\n                () -> RelMdDistribution.limit(mq, input));\n    return new EnumerableLimit(cluster, traitSet, input, offset, fetch);\n  }\n","date":"2020-11-30 06:45:33","endLine":76,"groupId":"102132","id":12,"instanceNumber":2,"isCurCommit":1,"methodName":"create","params":"(finalRelNodeinput@@NullableRexNodeoffset@@NullableRexNodefetch)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/3b/1694f7f2e10c3a0369ac994d9c710d4e1778fe.src","preCode":"  public static EnumerableLimit create(final RelNode input, RexNode offset,\n      RexNode fetch) {\n    final RelOptCluster cluster = input.getCluster();\n    final RelMetadataQuery mq = cluster.getMetadataQuery();\n    final RelTraitSet traitSet =\n        cluster.traitSetOf(EnumerableConvention.INSTANCE)\n            .replaceIfs(\n                RelCollationTraitDef.INSTANCE,\n                () -> RelMdCollation.limit(mq, input))\n            .replaceIf(RelDistributionTraitDef.INSTANCE,\n                () -> RelMdDistribution.limit(mq, input));\n    return new EnumerableLimit(cluster, traitSet, input, offset, fetch);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableLimit.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":64,"status":"M"}],"commitId":"d9a81b88ad561e7e4cedae93e805e0d7a53a7f1a","commitMessage":"@@@[CALCITE-4199] Add nullability annotations\n\nThe commit includes javadoc updates and refactorings made by Julian Hyde in https://github.com/apache/calcite/pull/2278\n","date":"2020-11-30 06:45:33","modifiedFileCount":"1012","status":"M","submitter":"Vladimir Sitnikov"}]
