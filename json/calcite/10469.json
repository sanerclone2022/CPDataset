[{"authorTime":"2016-03-04 10:39:39","codes":[{"authorDate":"2016-03-04 10:39:39","commitOrder":1,"curCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalcitePrepareImpl.DEBUG) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \" + new String(bytes));\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw Throwables.propagate(e);\n      }\n    }\n\n    try (final JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          expectScalarField(parser, \"timestamp\");\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              parseFields(fieldNames, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          expectScalarField(parser, \"timestamp\");\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"pagingIdentifiers\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              switch (parser.nextToken()) {\n              case FIELD_NAME:\n                page.pagingIdentifier = parser.getCurrentName();\n                if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                  page.offset = parser.getIntValue();\n                }\n                expect(parser, JsonToken.END_OBJECT);\n                break;\n              case END_OBJECT:\n              }\n            }\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"events\")\n                && parser.nextToken() == JsonToken.START_ARRAY) {\n              while (parser.nextToken() == JsonToken.START_OBJECT) {\n                expectScalarField(parser, \"segmentId\");\n                expectScalarField(parser, \"offset\");\n                if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"event\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n                  parseFields(fieldNames, rowBuilder, parser);\n                  sink.send(rowBuilder.build());\n                  rowBuilder.reset();\n                }\n                expect(parser, JsonToken.END_OBJECT);\n              }\n              parser.nextToken();\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            expectScalarField(parser, \"timestamp\");\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              parseFields(fieldNames, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw Throwables.propagate(e);\n    }\n  }\n","date":"2016-04-22 08:26:48","endLine":168,"groupId":"10272","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"(QueryTypequeryType@InputStreamin@Sinksink@List<String>fieldNames@Pagepage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/dd/462b6812ea4cbea3f8e6fc1f315d4f546f88f1.src","preCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalcitePrepareImpl.DEBUG) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \" + new String(bytes));\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw Throwables.propagate(e);\n      }\n    }\n\n    try (final JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          expectScalarField(parser, \"timestamp\");\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              parseFields(fieldNames, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          expectScalarField(parser, \"timestamp\");\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"pagingIdentifiers\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              switch (parser.nextToken()) {\n              case FIELD_NAME:\n                page.pagingIdentifier = parser.getCurrentName();\n                if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                  page.offset = parser.getIntValue();\n                }\n                expect(parser, JsonToken.END_OBJECT);\n                break;\n              case END_OBJECT:\n              }\n            }\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"events\")\n                && parser.nextToken() == JsonToken.START_ARRAY) {\n              while (parser.nextToken() == JsonToken.START_OBJECT) {\n                expectScalarField(parser, \"segmentId\");\n                expectScalarField(parser, \"offset\");\n                if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"event\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n                  parseFields(fieldNames, rowBuilder, parser);\n                  sink.send(rowBuilder.build());\n                  rowBuilder.reset();\n                }\n                expect(parser, JsonToken.END_OBJECT);\n              }\n              parser.nextToken();\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            expectScalarField(parser, \"timestamp\");\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              parseFields(fieldNames, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw Throwables.propagate(e);\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":71,"status":"B"},{"authorDate":"2016-03-04 10:39:39","commitOrder":1,"curCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","date":"2016-04-22 08:26:48","endLine":246,"groupId":"644","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"expectObjectField","params":"(JsonParserparser@Stringname)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/dd/462b6812ea4cbea3f8e6fc1f315d4f546f88f1.src","preCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":235,"status":"B"}],"commitId":"dd8d3c5888618d1568db49f0deb8b4a2f7c2b56f","commitMessage":"@@@[CALCITE-1121] Druid adapter\n\nDepends on \"foodmart\" and \"wikiticker\" data sets in calcite-test-dataset.\n\nGenerates \"select\" and \"groupBy\" query types;\ncan push project and filter into DruidQuery;\nfilters can consist of AND.  OR.  NOT.  =.  !=.  <.  <=.  >.  >=;\nsplits projects.  pushing down the parts that Druid can handle;\nfetches large Druid \"select\" queries a page at a time;\ndoes not yet push down HAVING.  ORDER BY or LIMIT.\n\nAdd CalciteAssert.returnsOrdered.\n\nAdd druid to sqlline path.\n\nRename cassandra.md to cassandra_adapter.md.\n","date":"2016-04-22 08:26:48","modifiedFileCount":"5","status":"B","submitter":"Julian Hyde"},{"authorTime":"2016-03-04 10:39:39","codes":[{"authorDate":"2016-06-09 08:03:17","commitOrder":2,"curCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<Primitive> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalcitePrepareImpl.DEBUG) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \" + new String(bytes));\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw Throwables.propagate(e);\n      }\n    }\n\n    try (final JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          expectScalarField(parser, \"timestamp\");\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          expectScalarField(parser, \"timestamp\");\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"pagingIdentifiers\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              switch (parser.nextToken()) {\n              case FIELD_NAME:\n                page.pagingIdentifier = parser.getCurrentName();\n                if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                  page.offset = parser.getIntValue();\n                }\n                expect(parser, JsonToken.END_OBJECT);\n                break;\n              case END_OBJECT:\n              }\n            }\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"events\")\n                && parser.nextToken() == JsonToken.START_ARRAY) {\n              while (parser.nextToken() == JsonToken.START_OBJECT) {\n                expectScalarField(parser, \"segmentId\");\n                expectScalarField(parser, \"offset\");\n                if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"event\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n                  parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n                  sink.send(rowBuilder.build());\n                  rowBuilder.reset();\n                }\n                expect(parser, JsonToken.END_OBJECT);\n              }\n              parser.nextToken();\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            expectScalarField(parser, \"timestamp\");\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw Throwables.propagate(e);\n    }\n  }\n","date":"2016-06-09 08:35:03","endLine":192,"groupId":"10272","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"(QueryTypequeryType@InputStreamin@Sinksink@List<String>fieldNames@List<Primitive>fieldTypes@Pagepage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/75/20d70e663ac8e1efceeecef822724afd081c50.src","preCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalcitePrepareImpl.DEBUG) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \" + new String(bytes));\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw Throwables.propagate(e);\n      }\n    }\n\n    try (final JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          expectScalarField(parser, \"timestamp\");\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              parseFields(fieldNames, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          expectScalarField(parser, \"timestamp\");\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"pagingIdentifiers\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              switch (parser.nextToken()) {\n              case FIELD_NAME:\n                page.pagingIdentifier = parser.getCurrentName();\n                if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                  page.offset = parser.getIntValue();\n                }\n                expect(parser, JsonToken.END_OBJECT);\n                break;\n              case END_OBJECT:\n              }\n            }\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"events\")\n                && parser.nextToken() == JsonToken.START_ARRAY) {\n              while (parser.nextToken() == JsonToken.START_OBJECT) {\n                expectScalarField(parser, \"segmentId\");\n                expectScalarField(parser, \"offset\");\n                if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"event\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n                  parseFields(fieldNames, rowBuilder, parser);\n                  sink.send(rowBuilder.build());\n                  rowBuilder.reset();\n                }\n                expect(parser, JsonToken.END_OBJECT);\n              }\n              parser.nextToken();\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            expectScalarField(parser, \"timestamp\");\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              parseFields(fieldNames, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw Throwables.propagate(e);\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":95,"status":"M"},{"authorDate":"2016-03-04 10:39:39","commitOrder":2,"curCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","date":"2016-04-22 08:26:48","endLine":246,"groupId":"644","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"expectObjectField","params":"(JsonParserparser@Stringname)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/dd/462b6812ea4cbea3f8e6fc1f315d4f546f88f1.src","preCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":235,"status":"N"}],"commitId":"ec49a0fa37195bb4b34945b53ce39b27d558d6ab","commitMessage":"@@@[CALCITE-1281] Druid adapter wrongly returns all numeric values as int or float\n","date":"2016-06-09 08:35:03","modifiedFileCount":"3","status":"M","submitter":"Julian Hyde"},{"authorTime":"2016-03-04 10:39:39","codes":[{"authorDate":"2016-07-31 03:56:19","commitOrder":3,"curCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<ColumnMetaData.Rep> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalcitePrepareImpl.DEBUG) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \" + new String(bytes));\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw Throwables.propagate(e);\n      }\n    }\n\n    try (final JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          expectScalarField(parser, \"timestamp\");\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          expectScalarField(parser, \"timestamp\");\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"pagingIdentifiers\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              switch (parser.nextToken()) {\n              case FIELD_NAME:\n                page.pagingIdentifier = parser.getCurrentName();\n                if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                  page.offset = parser.getIntValue();\n                }\n                expect(parser, JsonToken.END_OBJECT);\n                break;\n              case END_OBJECT:\n              }\n            }\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"events\")\n                && parser.nextToken() == JsonToken.START_ARRAY) {\n              while (parser.nextToken() == JsonToken.START_OBJECT) {\n                expectScalarField(parser, \"segmentId\");\n                expectScalarField(parser, \"offset\");\n                if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"event\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n                  parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n                  sink.send(rowBuilder.build());\n                  rowBuilder.reset();\n                }\n                expect(parser, JsonToken.END_OBJECT);\n              }\n              parser.nextToken();\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            expectScalarField(parser, \"timestamp\");\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw Throwables.propagate(e);\n    }\n  }\n","date":"2016-09-07 02:39:10","endLine":208,"groupId":"10272","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"(QueryTypequeryType@InputStreamin@Sinksink@List<String>fieldNames@List<ColumnMetaData.Rep>fieldTypes@Pagepage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/77/bb81798252adcc990ce8e6d487642d08b246f4.src","preCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<Primitive> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalcitePrepareImpl.DEBUG) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \" + new String(bytes));\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw Throwables.propagate(e);\n      }\n    }\n\n    try (final JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          expectScalarField(parser, \"timestamp\");\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          expectScalarField(parser, \"timestamp\");\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"pagingIdentifiers\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              switch (parser.nextToken()) {\n              case FIELD_NAME:\n                page.pagingIdentifier = parser.getCurrentName();\n                if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                  page.offset = parser.getIntValue();\n                }\n                expect(parser, JsonToken.END_OBJECT);\n                break;\n              case END_OBJECT:\n              }\n            }\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"events\")\n                && parser.nextToken() == JsonToken.START_ARRAY) {\n              while (parser.nextToken() == JsonToken.START_OBJECT) {\n                expectScalarField(parser, \"segmentId\");\n                expectScalarField(parser, \"offset\");\n                if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"event\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n                  parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n                  sink.send(rowBuilder.build());\n                  rowBuilder.reset();\n                }\n                expect(parser, JsonToken.END_OBJECT);\n              }\n              parser.nextToken();\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            expectScalarField(parser, \"timestamp\");\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw Throwables.propagate(e);\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":111,"status":"M"},{"authorDate":"2016-03-04 10:39:39","commitOrder":3,"curCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","date":"2016-04-22 08:26:48","endLine":246,"groupId":"644","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"expectObjectField","params":"(JsonParserparser@Stringname)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/dd/462b6812ea4cbea3f8e6fc1f315d4f546f88f1.src","preCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":235,"status":"N"}],"commitId":"87435a9b86e0d44a6c9123c028e5c5180fe3da88","commitMessage":"@@@[CALCITE-1334] Convert predicates on EXTRACT function calls into date ranges\n\nTest the code on the 'timestamp' column of a Druid table.\n\nThis change requires RangeSet.  and therefore Guava 14 or higher.\n","date":"2016-09-07 02:39:10","modifiedFileCount":"14","status":"M","submitter":"Julian Hyde"},{"authorTime":"2016-03-04 10:39:39","codes":[{"authorDate":"2016-08-24 06:57:16","commitOrder":4,"curCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<ColumnMetaData.Rep> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalcitePrepareImpl.DEBUG) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \" + new String(bytes));\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw Throwables.propagate(e);\n      }\n    }\n\n    try (final JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TIMESERIES:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            \r\n            expectScalarField(parser, \"timestamp\");\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"result\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          expectScalarField(parser, \"timestamp\");\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          expectScalarField(parser, \"timestamp\");\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"pagingIdentifiers\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              switch (parser.nextToken()) {\n              case FIELD_NAME:\n                page.pagingIdentifier = parser.getCurrentName();\n                if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                  page.offset = parser.getIntValue();\n                }\n                expect(parser, JsonToken.END_OBJECT);\n                break;\n              case END_OBJECT:\n              }\n            }\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"events\")\n                && parser.nextToken() == JsonToken.START_ARRAY) {\n              while (parser.nextToken() == JsonToken.START_OBJECT) {\n                expectScalarField(parser, \"segmentId\");\n                expectScalarField(parser, \"offset\");\n                if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"event\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n                  parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n                  sink.send(rowBuilder.build());\n                  rowBuilder.reset();\n                }\n                expect(parser, JsonToken.END_OBJECT);\n              }\n              parser.nextToken();\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            expectScalarField(parser, \"timestamp\");\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw Throwables.propagate(e);\n    }\n  }\n","date":"2016-09-15 12:46:04","endLine":226,"groupId":"10272","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"(QueryTypequeryType@InputStreamin@Sinksink@List<String>fieldNames@List<ColumnMetaData.Rep>fieldTypes@Pagepage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/2b/fc6637a37441d2ac1db4504aa7ec172acfe165.src","preCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<ColumnMetaData.Rep> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalcitePrepareImpl.DEBUG) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \" + new String(bytes));\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw Throwables.propagate(e);\n      }\n    }\n\n    try (final JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          expectScalarField(parser, \"timestamp\");\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          expectScalarField(parser, \"timestamp\");\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"pagingIdentifiers\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              switch (parser.nextToken()) {\n              case FIELD_NAME:\n                page.pagingIdentifier = parser.getCurrentName();\n                if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                  page.offset = parser.getIntValue();\n                }\n                expect(parser, JsonToken.END_OBJECT);\n                break;\n              case END_OBJECT:\n              }\n            }\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"events\")\n                && parser.nextToken() == JsonToken.START_ARRAY) {\n              while (parser.nextToken() == JsonToken.START_OBJECT) {\n                expectScalarField(parser, \"segmentId\");\n                expectScalarField(parser, \"offset\");\n                if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"event\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n                  parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n                  sink.send(rowBuilder.build());\n                  rowBuilder.reset();\n                }\n                expect(parser, JsonToken.END_OBJECT);\n              }\n              parser.nextToken();\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            expectScalarField(parser, \"timestamp\");\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw Throwables.propagate(e);\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":112,"status":"M"},{"authorDate":"2016-03-04 10:39:39","commitOrder":4,"curCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","date":"2016-04-22 08:26:48","endLine":246,"groupId":"644","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"expectObjectField","params":"(JsonParserparser@Stringname)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/dd/462b6812ea4cbea3f8e6fc1f315d4f546f88f1.src","preCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":235,"status":"N"}],"commitId":"962eac566cb19a95d8581a1b10fc120657069b1c","commitMessage":"@@@[CALCITE-1357] Recognize Druid Timeseries and TopN queries in DruidQuery\n\n[CALCITE-1358] Push filters on time dimension to Druid\n\nClose apache/calcite#280\n","date":"2016-09-15 12:46:04","modifiedFileCount":"14","status":"M","submitter":"Jesus Camacho Rodriguez"},{"authorTime":"2016-03-04 10:39:39","codes":[{"authorDate":"2016-10-06 23:14:34","commitOrder":5,"curCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<ColumnMetaData.Rep> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalcitePrepareImpl.DEBUG) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \" + new String(bytes));\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw Throwables.propagate(e);\n      }\n    }\n\n    int posTimestampField = -1;\n    for (int i = 0; i < fieldTypes.size(); i++) {\n      if (fieldTypes.get(i) == ColumnMetaData.Rep.JAVA_SQL_TIMESTAMP) {\n        posTimestampField = i;\n        break;\n      }\n    }\n\n    try (final JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TIMESERIES:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n           \r\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"result\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          final Long timeValue = extractTimestampField(parser);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          expectScalarField(parser, DEFAULT_RESPONSE_TIMESTAMP_COLUMN);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"pagingIdentifiers\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              switch (parser.nextToken()) {\n              case FIELD_NAME:\n                page.pagingIdentifier = parser.getCurrentName();\n                if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                  page.offset = parser.getIntValue();\n                }\n                expect(parser, JsonToken.END_OBJECT);\n                break;\n              case END_OBJECT:\n              }\n            }\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"events\")\n                && parser.nextToken() == JsonToken.START_ARRAY) {\n              while (parser.nextToken() == JsonToken.START_OBJECT) {\n                expectScalarField(parser, \"segmentId\");\n                expectScalarField(parser, \"offset\");\n                if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"event\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n                  parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n                  sink.send(rowBuilder.build());\n                  rowBuilder.reset();\n                }\n                expect(parser, JsonToken.END_OBJECT);\n              }\n              parser.nextToken();\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw Throwables.propagate(e);\n    }\n  }\n","date":"2016-10-06 23:14:34","endLine":246,"groupId":"2785","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"(QueryTypequeryType@InputStreamin@Sinksink@List<String>fieldNames@List<ColumnMetaData.Rep>fieldTypes@Pagepage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/69/ded346918de32d74a15491744766bc5a88c4f4.src","preCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<ColumnMetaData.Rep> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalcitePrepareImpl.DEBUG) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \" + new String(bytes));\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw Throwables.propagate(e);\n      }\n    }\n\n    try (final JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TIMESERIES:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            \r\n            expectScalarField(parser, \"timestamp\");\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"result\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          expectScalarField(parser, \"timestamp\");\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          expectScalarField(parser, \"timestamp\");\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"pagingIdentifiers\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              switch (parser.nextToken()) {\n              case FIELD_NAME:\n                page.pagingIdentifier = parser.getCurrentName();\n                if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                  page.offset = parser.getIntValue();\n                }\n                expect(parser, JsonToken.END_OBJECT);\n                break;\n              case END_OBJECT:\n              }\n            }\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"events\")\n                && parser.nextToken() == JsonToken.START_ARRAY) {\n              while (parser.nextToken() == JsonToken.START_OBJECT) {\n                expectScalarField(parser, \"segmentId\");\n                expectScalarField(parser, \"offset\");\n                if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"event\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n                  parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n                  sink.send(rowBuilder.build());\n                  rowBuilder.reset();\n                }\n                expect(parser, JsonToken.END_OBJECT);\n              }\n              parser.nextToken();\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            expectScalarField(parser, \"timestamp\");\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw Throwables.propagate(e);\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":115,"status":"M"},{"authorDate":"2016-03-04 10:39:39","commitOrder":5,"curCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","date":"2016-04-22 08:26:48","endLine":246,"groupId":"644","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"expectObjectField","params":"(JsonParserparser@Stringname)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/dd/462b6812ea4cbea3f8e6fc1f315d4f546f88f1.src","preCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":235,"status":"N"}],"commitId":"66274481fbca9c3ed9cd1f6f690bb2163ff07ba9","commitMessage":"@@@[CALCITE-1392] Druid default time column not properly recognized (addendum)\n\n* Handling of time column referenced in the query result\n","date":"2016-10-06 23:14:34","modifiedFileCount":"5","status":"M","submitter":"Jesus Camacho Rodriguez"},{"authorTime":"2016-03-04 10:39:39","codes":[{"authorDate":"2016-10-11 22:59:13","commitOrder":6,"curCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<ColumnMetaData.Rep> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalcitePrepareImpl.DEBUG) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \" + new String(bytes));\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw Throwables.propagate(e);\n      }\n    }\n\n    int posTimestampField = -1;\n    for (int i = 0; i < fieldTypes.size(); i++) {\n      if (fieldTypes.get(i) == ColumnMetaData.Rep.JAVA_SQL_TIMESTAMP) {\n        posTimestampField = i;\n        break;\n      }\n    }\n\n    try (final JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TIMESERIES:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n           \r\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"result\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          final Long timeValue = extractTimestampField(parser);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          expectScalarField(parser, DEFAULT_RESPONSE_TIMESTAMP_COLUMN);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"pagingIdentifiers\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              JsonToken token = parser.nextToken();\n              while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {\n                page.pagingIdentifier = parser.getCurrentName();\n                if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                  page.offset = parser.getIntValue();\n                }\n                token = parser.nextToken();\n              }\n              expect(token, JsonToken.END_OBJECT);\n            }\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"events\")\n                && parser.nextToken() == JsonToken.START_ARRAY) {\n              while (parser.nextToken() == JsonToken.START_OBJECT) {\n                expectScalarField(parser, \"segmentId\");\n                expectScalarField(parser, \"offset\");\n                if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"event\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n                  parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n                  sink.send(rowBuilder.build());\n                  rowBuilder.reset();\n                }\n                expect(parser, JsonToken.END_OBJECT);\n              }\n              parser.nextToken();\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw Throwables.propagate(e);\n    }\n  }\n","date":"2016-10-19 07:33:01","endLine":242,"groupId":"2785","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"(QueryTypequeryType@InputStreamin@Sinksink@List<String>fieldNames@List<ColumnMetaData.Rep>fieldTypes@Pagepage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/83/9d2c97fb29f0542c7fb10b696a1dcc22c9ce7c.src","preCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<ColumnMetaData.Rep> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalcitePrepareImpl.DEBUG) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \" + new String(bytes));\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw Throwables.propagate(e);\n      }\n    }\n\n    int posTimestampField = -1;\n    for (int i = 0; i < fieldTypes.size(); i++) {\n      if (fieldTypes.get(i) == ColumnMetaData.Rep.JAVA_SQL_TIMESTAMP) {\n        posTimestampField = i;\n        break;\n      }\n    }\n\n    try (final JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TIMESERIES:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n           \r\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"result\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          final Long timeValue = extractTimestampField(parser);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          expectScalarField(parser, DEFAULT_RESPONSE_TIMESTAMP_COLUMN);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"pagingIdentifiers\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              switch (parser.nextToken()) {\n              case FIELD_NAME:\n                page.pagingIdentifier = parser.getCurrentName();\n                if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                  page.offset = parser.getIntValue();\n                }\n                expect(parser, JsonToken.END_OBJECT);\n                break;\n              case END_OBJECT:\n              }\n            }\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"events\")\n                && parser.nextToken() == JsonToken.START_ARRAY) {\n              while (parser.nextToken() == JsonToken.START_OBJECT) {\n                expectScalarField(parser, \"segmentId\");\n                expectScalarField(parser, \"offset\");\n                if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"event\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n                  parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n                  sink.send(rowBuilder.build());\n                  rowBuilder.reset();\n                }\n                expect(parser, JsonToken.END_OBJECT);\n              }\n              parser.nextToken();\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw Throwables.propagate(e);\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":112,"status":"M"},{"authorDate":"2016-03-04 10:39:39","commitOrder":6,"curCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","date":"2016-04-22 08:26:48","endLine":246,"groupId":"644","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"expectObjectField","params":"(JsonParserparser@Stringname)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/dd/462b6812ea4cbea3f8e6fc1f315d4f546f88f1.src","preCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":235,"status":"N"}],"commitId":"aad03def2ab2995dfdfedfe8f62605a43c7d2858","commitMessage":"@@@[CALCITE-1430] In Druid adapter.  pagingIdentifiers might have more than one value (Jiarong Wei)\n\nRequires the latest calcite-test-dataset.\n\nClose apache/calcite#302\n","date":"2016-10-19 07:33:01","modifiedFileCount":"1","status":"M","submitter":"Jiarong Wei"},{"authorTime":"2016-03-04 10:39:39","codes":[{"authorDate":"2016-10-11 22:53:55","commitOrder":7,"curCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<ColumnMetaData.Rep> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalcitePrepareImpl.DEBUG) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \" + new String(bytes));\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw Throwables.propagate(e);\n      }\n    }\n\n    int posTimestampField = -1;\n    for (int i = 0; i < fieldTypes.size(); i++) {\n      if (fieldTypes.get(i) == ColumnMetaData.Rep.JAVA_SQL_TIMESTAMP) {\n        posTimestampField = i;\n        break;\n      }\n    }\n\n    try (final JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TIMESERIES:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n           \r\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"result\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          final Long timeValue = extractTimestampField(parser);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          page.totalRowCount = 0;\n          expectScalarField(parser, DEFAULT_RESPONSE_TIMESTAMP_COLUMN);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"pagingIdentifiers\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              JsonToken token = parser.nextToken();\n              while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {\n                page.pagingIdentifier = parser.getCurrentName();\n                if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                  page.offset = parser.getIntValue();\n                }\n                token = parser.nextToken();\n              }\n              expect(token, JsonToken.END_OBJECT);\n            }\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"events\")\n                && parser.nextToken() == JsonToken.START_ARRAY) {\n              while (parser.nextToken() == JsonToken.START_OBJECT) {\n                expectScalarField(parser, \"segmentId\");\n                expectScalarField(parser, \"offset\");\n                if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"event\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n                  parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n                  sink.send(rowBuilder.build());\n                  rowBuilder.reset();\n                  page.totalRowCount += 1;\n                }\n                expect(parser, JsonToken.END_OBJECT);\n              }\n              parser.nextToken();\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw Throwables.propagate(e);\n    }\n  }\n","date":"2016-10-19 07:38:05","endLine":244,"groupId":"865","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"(QueryTypequeryType@InputStreamin@Sinksink@List<String>fieldNames@List<ColumnMetaData.Rep>fieldTypes@Pagepage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/87/2b6e93c92fafe3c08fecc8265ee0c4dcc9b9d0.src","preCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<ColumnMetaData.Rep> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalcitePrepareImpl.DEBUG) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \" + new String(bytes));\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw Throwables.propagate(e);\n      }\n    }\n\n    int posTimestampField = -1;\n    for (int i = 0; i < fieldTypes.size(); i++) {\n      if (fieldTypes.get(i) == ColumnMetaData.Rep.JAVA_SQL_TIMESTAMP) {\n        posTimestampField = i;\n        break;\n      }\n    }\n\n    try (final JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TIMESERIES:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n           \r\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"result\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          final Long timeValue = extractTimestampField(parser);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          expectScalarField(parser, DEFAULT_RESPONSE_TIMESTAMP_COLUMN);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"pagingIdentifiers\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              JsonToken token = parser.nextToken();\n              while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {\n                page.pagingIdentifier = parser.getCurrentName();\n                if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                  page.offset = parser.getIntValue();\n                }\n                token = parser.nextToken();\n              }\n              expect(token, JsonToken.END_OBJECT);\n            }\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"events\")\n                && parser.nextToken() == JsonToken.START_ARRAY) {\n              while (parser.nextToken() == JsonToken.START_OBJECT) {\n                expectScalarField(parser, \"segmentId\");\n                expectScalarField(parser, \"offset\");\n                if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"event\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n                  parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n                  sink.send(rowBuilder.build());\n                  rowBuilder.reset();\n                }\n                expect(parser, JsonToken.END_OBJECT);\n              }\n              parser.nextToken();\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw Throwables.propagate(e);\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":112,"status":"M"},{"authorDate":"2016-03-04 10:39:39","commitOrder":7,"curCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","date":"2016-04-22 08:26:48","endLine":246,"groupId":"644","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"expectObjectField","params":"(JsonParserparser@Stringname)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/dd/462b6812ea4cbea3f8e6fc1f315d4f546f88f1.src","preCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":235,"status":"N"}],"commitId":"97ccd6ded2b9910a551d12f610100371aad6c6a8","commitMessage":"@@@[CALCITE-1429] Druid adapter must send \"fromNext\" when requesting rows from Druid (Jiarong Wei)\n\nClose apache/calcite#303\n","date":"2016-10-19 07:38:05","modifiedFileCount":"3","status":"M","submitter":"Jiarong Wei"},{"authorTime":"2016-03-04 10:39:39","codes":[{"authorDate":"2017-01-23 17:38:12","commitOrder":8,"curCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<ColumnMetaData.Rep> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalcitePrepareImpl.DEBUG) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \" + new String(bytes));\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    int posTimestampField = -1;\n    for (int i = 0; i < fieldTypes.size(); i++) {\n      if (fieldTypes.get(i) == ColumnMetaData.Rep.JAVA_SQL_TIMESTAMP) {\n        posTimestampField = i;\n        break;\n      }\n    }\n\n    try (final JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TIMESERIES:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n           \r\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"result\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          final Long timeValue = extractTimestampField(parser);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          page.totalRowCount = 0;\n          expectScalarField(parser, DEFAULT_RESPONSE_TIMESTAMP_COLUMN);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"pagingIdentifiers\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              JsonToken token = parser.nextToken();\n              while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {\n                page.pagingIdentifier = parser.getCurrentName();\n                if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                  page.offset = parser.getIntValue();\n                }\n                token = parser.nextToken();\n              }\n              expect(token, JsonToken.END_OBJECT);\n            }\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"events\")\n                && parser.nextToken() == JsonToken.START_ARRAY) {\n              while (parser.nextToken() == JsonToken.START_OBJECT) {\n                expectScalarField(parser, \"segmentId\");\n                expectScalarField(parser, \"offset\");\n                if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"event\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n                  parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n                  sink.send(rowBuilder.build());\n                  rowBuilder.reset();\n                  page.totalRowCount += 1;\n                }\n                expect(parser, JsonToken.END_OBJECT);\n              }\n              parser.nextToken();\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","date":"2017-01-26 03:00:12","endLine":244,"groupId":"865","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"(QueryTypequeryType@InputStreamin@Sinksink@List<String>fieldNames@List<ColumnMetaData.Rep>fieldTypes@Pagepage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/07/740c28c713a02fe4a9ae6306c0858458cb28c9.src","preCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<ColumnMetaData.Rep> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalcitePrepareImpl.DEBUG) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \" + new String(bytes));\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw Throwables.propagate(e);\n      }\n    }\n\n    int posTimestampField = -1;\n    for (int i = 0; i < fieldTypes.size(); i++) {\n      if (fieldTypes.get(i) == ColumnMetaData.Rep.JAVA_SQL_TIMESTAMP) {\n        posTimestampField = i;\n        break;\n      }\n    }\n\n    try (final JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TIMESERIES:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n           \r\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"result\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          final Long timeValue = extractTimestampField(parser);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          page.totalRowCount = 0;\n          expectScalarField(parser, DEFAULT_RESPONSE_TIMESTAMP_COLUMN);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"pagingIdentifiers\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              JsonToken token = parser.nextToken();\n              while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {\n                page.pagingIdentifier = parser.getCurrentName();\n                if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                  page.offset = parser.getIntValue();\n                }\n                token = parser.nextToken();\n              }\n              expect(token, JsonToken.END_OBJECT);\n            }\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"events\")\n                && parser.nextToken() == JsonToken.START_ARRAY) {\n              while (parser.nextToken() == JsonToken.START_OBJECT) {\n                expectScalarField(parser, \"segmentId\");\n                expectScalarField(parser, \"offset\");\n                if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"event\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n                  parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n                  sink.send(rowBuilder.build());\n                  rowBuilder.reset();\n                  page.totalRowCount += 1;\n                }\n                expect(parser, JsonToken.END_OBJECT);\n              }\n              parser.nextToken();\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw Throwables.propagate(e);\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":112,"status":"M"},{"authorDate":"2016-03-04 10:39:39","commitOrder":8,"curCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","date":"2016-04-22 08:26:48","endLine":246,"groupId":"644","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"expectObjectField","params":"(JsonParserparser@Stringname)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/dd/462b6812ea4cbea3f8e6fc1f315d4f546f88f1.src","preCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":235,"status":"N"}],"commitId":"603648bc2466ab699fa6646ffc1ad717b8c11880","commitMessage":"@@@[CALCITE-1597] Obsolete Util.newInternal.  .pre.  .post.  .permAssert and Throwables.propagate\n\nReplace Util.newInternal with new AssertionError in some contexts. \nnew RuntimeException in others. Replace methods pre.  pos.  permAssert\nin Util with methods in Preconditions.\n\nRemove uses of Throwables.propagate and .propagateIfPossible because\nthey are deprecated as of Guava 20. Create method\nUtil.throwIfUnchecked because we can't use Guava's\nThrowables.throwIfUnchecked yet.\n","date":"2017-01-26 03:00:12","modifiedFileCount":"82","status":"M","submitter":"Julian Hyde"},{"authorTime":"2016-03-04 10:39:39","codes":[{"authorDate":"2017-03-03 16:05:23","commitOrder":9,"curCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<ColumnMetaData.Rep> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalcitePrepareImpl.DEBUG) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \"\n            + new String(bytes, StandardCharsets.UTF_8));\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    int posTimestampField = -1;\n    for (int i = 0; i < fieldTypes.size(); i++) {\n      if (fieldTypes.get(i) == ColumnMetaData.Rep.JAVA_SQL_TIMESTAMP) {\n        posTimestampField = i;\n        break;\n      }\n    }\n\n    try (final JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TIMESERIES:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n           \r\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"result\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          final Long timeValue = extractTimestampField(parser);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          page.totalRowCount = 0;\n          expectScalarField(parser, DEFAULT_RESPONSE_TIMESTAMP_COLUMN);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"pagingIdentifiers\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              JsonToken token = parser.nextToken();\n              while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {\n                page.pagingIdentifier = parser.getCurrentName();\n                if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                  page.offset = parser.getIntValue();\n                }\n                token = parser.nextToken();\n              }\n              expect(token, JsonToken.END_OBJECT);\n            }\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"events\")\n                && parser.nextToken() == JsonToken.START_ARRAY) {\n              while (parser.nextToken() == JsonToken.START_OBJECT) {\n                expectScalarField(parser, \"segmentId\");\n                expectScalarField(parser, \"offset\");\n                if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"event\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n                  parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n                  sink.send(rowBuilder.build());\n                  rowBuilder.reset();\n                  page.totalRowCount += 1;\n                }\n                expect(parser, JsonToken.END_OBJECT);\n              }\n              parser.nextToken();\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","date":"2017-03-04 03:04:28","endLine":248,"groupId":"865","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"(QueryTypequeryType@InputStreamin@Sinksink@List<String>fieldNames@List<ColumnMetaData.Rep>fieldTypes@Pagepage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/03/6a2e1d5da03c44cbc0db16305d719754822ba4.src","preCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<ColumnMetaData.Rep> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalcitePrepareImpl.DEBUG) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \" + new String(bytes));\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    int posTimestampField = -1;\n    for (int i = 0; i < fieldTypes.size(); i++) {\n      if (fieldTypes.get(i) == ColumnMetaData.Rep.JAVA_SQL_TIMESTAMP) {\n        posTimestampField = i;\n        break;\n      }\n    }\n\n    try (final JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TIMESERIES:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n           \r\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"result\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          final Long timeValue = extractTimestampField(parser);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          page.totalRowCount = 0;\n          expectScalarField(parser, DEFAULT_RESPONSE_TIMESTAMP_COLUMN);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"pagingIdentifiers\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              JsonToken token = parser.nextToken();\n              while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {\n                page.pagingIdentifier = parser.getCurrentName();\n                if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                  page.offset = parser.getIntValue();\n                }\n                token = parser.nextToken();\n              }\n              expect(token, JsonToken.END_OBJECT);\n            }\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"events\")\n                && parser.nextToken() == JsonToken.START_ARRAY) {\n              while (parser.nextToken() == JsonToken.START_OBJECT) {\n                expectScalarField(parser, \"segmentId\");\n                expectScalarField(parser, \"offset\");\n                if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"event\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n                  parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n                  sink.send(rowBuilder.build());\n                  rowBuilder.reset();\n                  page.totalRowCount += 1;\n                }\n                expect(parser, JsonToken.END_OBJECT);\n              }\n              parser.nextToken();\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":115,"status":"M"},{"authorDate":"2016-03-04 10:39:39","commitOrder":9,"curCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","date":"2016-04-22 08:26:48","endLine":246,"groupId":"644","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"expectObjectField","params":"(JsonParserparser@Stringname)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/dd/462b6812ea4cbea3f8e6fc1f315d4f546f88f1.src","preCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":235,"status":"N"}],"commitId":"75152c5b7fd62f60c6cdfb86605af8b34a129898","commitMessage":"@@@[CALCITE-1667] Forbid calls to JDK APIs that use the default locale.  time zone or character set\n\nUse the \"forbidden-apis\" maven plugin to detect calls to such APIs.\nEliminate calls to such APIs.\n","date":"2017-03-04 03:04:28","modifiedFileCount":"79","status":"M","submitter":"Julian Hyde"},{"authorTime":"2016-03-04 10:39:39","codes":[{"authorDate":"2017-04-10 16:22:31","commitOrder":10,"curCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<ColumnMetaData.Rep> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalcitePrepareImpl.DEBUG) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \"\n            + new String(bytes, StandardCharsets.UTF_8));\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    int posTimestampField = -1;\n    for (int i = 0; i < fieldTypes.size(); i++) {\n      if (fieldTypes.get(i) == ColumnMetaData.Rep.JAVA_SQL_TIMESTAMP) {\n        posTimestampField = i;\n        break;\n      }\n    }\n\n    try (final JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TIMESERIES:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n           \r\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"result\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          final Long timeValue = extractTimestampField(parser);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          page.totalRowCount = 0;\n          expectScalarField(parser, DEFAULT_RESPONSE_TIMESTAMP_COLUMN);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            while (parser.nextToken() == JsonToken.FIELD_NAME) {\n              if (parser.getCurrentName().equals(\"pagingIdentifiers\")\n                  && parser.nextToken() == JsonToken.START_OBJECT) {\n                JsonToken token = parser.nextToken();\n                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {\n                  page.pagingIdentifier = parser.getCurrentName();\n                  if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                    page.offset = parser.getIntValue();\n                  }\n                  token = parser.nextToken();\n                }\n                expect(token, JsonToken.END_OBJECT);\n              } else if (parser.getCurrentName().equals(\"events\")\n                  && parser.nextToken() == JsonToken.START_ARRAY) {\n                while (parser.nextToken() == JsonToken.START_OBJECT) {\n                  expectScalarField(parser, \"segmentId\");\n                  expectScalarField(parser, \"offset\");\n                  if (parser.nextToken() == JsonToken.FIELD_NAME\n                      && parser.getCurrentName().equals(\"event\")\n                      && parser.nextToken() == JsonToken.START_OBJECT) {\n                    parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n                    sink.send(rowBuilder.build());\n                    rowBuilder.reset();\n                    page.totalRowCount += 1;\n                  }\n                  expect(parser, JsonToken.END_OBJECT);\n                }\n                parser.nextToken();\n              } else if (parser.getCurrentName().equals(\"dimensions\")\n                  || parser.getCurrentName().equals(\"metrics\")) {\n                expect(parser, JsonToken.START_ARRAY);\n                while (parser.nextToken() != JsonToken.END_ARRAY) {\n                  \r\n                }\n              }\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","date":"2017-04-10 16:23:07","endLine":253,"groupId":"1925","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"(QueryTypequeryType@InputStreamin@Sinksink@List<String>fieldNames@List<ColumnMetaData.Rep>fieldTypes@Pagepage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/b9/b860a9c4fd721fd50886718c5cb4be57473830.src","preCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<ColumnMetaData.Rep> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalcitePrepareImpl.DEBUG) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \"\n            + new String(bytes, StandardCharsets.UTF_8));\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    int posTimestampField = -1;\n    for (int i = 0; i < fieldTypes.size(); i++) {\n      if (fieldTypes.get(i) == ColumnMetaData.Rep.JAVA_SQL_TIMESTAMP) {\n        posTimestampField = i;\n        break;\n      }\n    }\n\n    try (final JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TIMESERIES:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n           \r\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"result\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          final Long timeValue = extractTimestampField(parser);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          page.totalRowCount = 0;\n          expectScalarField(parser, DEFAULT_RESPONSE_TIMESTAMP_COLUMN);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"pagingIdentifiers\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              JsonToken token = parser.nextToken();\n              while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {\n                page.pagingIdentifier = parser.getCurrentName();\n                if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                  page.offset = parser.getIntValue();\n                }\n                token = parser.nextToken();\n              }\n              expect(token, JsonToken.END_OBJECT);\n            }\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"events\")\n                && parser.nextToken() == JsonToken.START_ARRAY) {\n              while (parser.nextToken() == JsonToken.START_OBJECT) {\n                expectScalarField(parser, \"segmentId\");\n                expectScalarField(parser, \"offset\");\n                if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"event\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n                  parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n                  sink.send(rowBuilder.build());\n                  rowBuilder.reset();\n                  page.totalRowCount += 1;\n                }\n                expect(parser, JsonToken.END_OBJECT);\n              }\n              parser.nextToken();\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":115,"status":"M"},{"authorDate":"2016-03-04 10:39:39","commitOrder":10,"curCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","date":"2016-04-22 08:26:48","endLine":246,"groupId":"644","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"expectObjectField","params":"(JsonParserparser@Stringname)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/dd/462b6812ea4cbea3f8e6fc1f315d4f546f88f1.src","preCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":235,"status":"N"}],"commitId":"9f87b666976181d7946aa9c6c4fefef01c53858c","commitMessage":"@@@[CALCITE-1734] Fix select query result parsing with druid 0.9.2 (Nishant Bangarwa)\n\nClose apache/calcite#416\n","date":"2017-04-10 16:23:07","modifiedFileCount":"1","status":"M","submitter":"Nishant Bangarwa"},{"authorTime":"2016-03-04 10:39:39","codes":[{"authorDate":"2017-04-06 18:32:27","commitOrder":11,"curCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<ColumnMetaData.Rep> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalcitePrepareImpl.DEBUG) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \"\n            + new String(bytes, StandardCharsets.UTF_8));\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    int posTimestampField = -1;\n    for (int i = 0; i < fieldTypes.size(); i++) {\n      if (fieldTypes.get(i) == ColumnMetaData.Rep.JAVA_SQL_TIMESTAMP) {\n        posTimestampField = i;\n        break;\n      }\n    }\n\n    try (final JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TIMESERIES:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n           \r\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"result\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          final Long timeValue = extractTimestampField(parser);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          page.totalRowCount = 0;\n          expectScalarField(parser, DEFAULT_RESPONSE_TIMESTAMP_COLUMN);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            while (parser.nextToken() == JsonToken.FIELD_NAME) {\n              if (parser.getCurrentName().equals(\"pagingIdentifiers\")\n                  && parser.nextToken() == JsonToken.START_OBJECT) {\n                JsonToken token = parser.nextToken();\n                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {\n                  page.pagingIdentifier = parser.getCurrentName();\n                  if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                    page.offset = parser.getIntValue();\n                  }\n                  token = parser.nextToken();\n                }\n                expect(token, JsonToken.END_OBJECT);\n              } else if (parser.getCurrentName().equals(\"events\")\n                  && parser.nextToken() == JsonToken.START_ARRAY) {\n                while (parser.nextToken() == JsonToken.START_OBJECT) {\n                  expectScalarField(parser, \"segmentId\");\n                  expectScalarField(parser, \"offset\");\n                  if (parser.nextToken() == JsonToken.FIELD_NAME\n                      && parser.getCurrentName().equals(\"event\")\n                      && parser.nextToken() == JsonToken.START_OBJECT) {\n                    parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n                    sink.send(rowBuilder.build());\n                    rowBuilder.reset();\n                    page.totalRowCount += 1;\n                  }\n                  expect(parser, JsonToken.END_OBJECT);\n                }\n                parser.nextToken();\n              } else if (parser.getCurrentName().equals(\"dimensions\")\n                  || parser.getCurrentName().equals(\"metrics\")) {\n                expect(parser, JsonToken.START_ARRAY);\n                while (parser.nextToken() != JsonToken.END_ARRAY) {\n                  \r\n                }\n              }\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","date":"2017-04-10 16:56:20","endLine":253,"groupId":"1925","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"(QueryTypequeryType@InputStreamin@Sinksink@List<String>fieldNames@List<ColumnMetaData.Rep>fieldTypes@Pagepage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/c7/360989ba28631ec87d6229c35b06ce48dabe9f.src","preCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<ColumnMetaData.Rep> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalcitePrepareImpl.DEBUG) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \"\n            + new String(bytes, StandardCharsets.UTF_8));\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    int posTimestampField = -1;\n    for (int i = 0; i < fieldTypes.size(); i++) {\n      if (fieldTypes.get(i) == ColumnMetaData.Rep.JAVA_SQL_TIMESTAMP) {\n        posTimestampField = i;\n        break;\n      }\n    }\n\n    try (final JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TIMESERIES:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n           \r\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"result\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          final Long timeValue = extractTimestampField(parser);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          page.totalRowCount = 0;\n          expectScalarField(parser, DEFAULT_RESPONSE_TIMESTAMP_COLUMN);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            while (parser.nextToken() == JsonToken.FIELD_NAME) {\n              if (parser.getCurrentName().equals(\"pagingIdentifiers\")\n                  && parser.nextToken() == JsonToken.START_OBJECT) {\n                JsonToken token = parser.nextToken();\n                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {\n                  page.pagingIdentifier = parser.getCurrentName();\n                  if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                    page.offset = parser.getIntValue();\n                  }\n                  token = parser.nextToken();\n                }\n                expect(token, JsonToken.END_OBJECT);\n              } else if (parser.getCurrentName().equals(\"events\")\n                  && parser.nextToken() == JsonToken.START_ARRAY) {\n                while (parser.nextToken() == JsonToken.START_OBJECT) {\n                  expectScalarField(parser, \"segmentId\");\n                  expectScalarField(parser, \"offset\");\n                  if (parser.nextToken() == JsonToken.FIELD_NAME\n                      && parser.getCurrentName().equals(\"event\")\n                      && parser.nextToken() == JsonToken.START_OBJECT) {\n                    parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n                    sink.send(rowBuilder.build());\n                    rowBuilder.reset();\n                    page.totalRowCount += 1;\n                  }\n                  expect(parser, JsonToken.END_OBJECT);\n                }\n                parser.nextToken();\n              } else if (parser.getCurrentName().equals(\"dimensions\")\n                  || parser.getCurrentName().equals(\"metrics\")) {\n                expect(parser, JsonToken.START_ARRAY);\n                while (parser.nextToken() != JsonToken.END_ARRAY) {\n                  \r\n                }\n              }\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":115,"status":"M"},{"authorDate":"2016-03-04 10:39:39","commitOrder":11,"curCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","date":"2016-04-22 08:26:48","endLine":246,"groupId":"644","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"expectObjectField","params":"(JsonParserparser@Stringname)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/dd/462b6812ea4cbea3f8e6fc1f315d4f546f88f1.src","preCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":235,"status":"N"}],"commitId":"ef03b6e4c6dbae800e7c1aaa1deb5bbd7960e911","commitMessage":"@@@[CALCITE-1725] Push project aggregate of time extract to druid (Slim Bouguerra)\n\nClose apache/calcite#412\n","date":"2017-04-10 16:56:20","modifiedFileCount":"5","status":"M","submitter":"Slim Bouguerra"},{"authorTime":"2016-03-04 10:39:39","codes":[{"authorDate":"2017-12-22 04:16:10","commitOrder":12,"curCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<ColumnMetaData.Rep> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalcitePrepareImpl.DEBUG) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \"\n            + new String(bytes, StandardCharsets.UTF_8));\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    int posTimestampField = -1;\n    for (int i = 0; i < fieldTypes.size(); i++) {\n      if (fieldTypes.get(i) == ColumnMetaData.Rep.JAVA_SQL_TIMESTAMP) {\n        posTimestampField = i;\n        break;\n      }\n    }\n\n    try (final JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TIMESERIES:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n           \r\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"result\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          final Long timeValue = extractTimestampField(parser);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          page.totalRowCount = 0;\n          expectScalarField(parser, DEFAULT_RESPONSE_TIMESTAMP_COLUMN);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            while (parser.nextToken() == JsonToken.FIELD_NAME) {\n              if (parser.getCurrentName().equals(\"pagingIdentifiers\")\n                  && parser.nextToken() == JsonToken.START_OBJECT) {\n                JsonToken token = parser.nextToken();\n                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {\n                  page.pagingIdentifier = parser.getCurrentName();\n                  if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                    page.offset = parser.getIntValue();\n                  }\n                  token = parser.nextToken();\n                }\n                expect(token, JsonToken.END_OBJECT);\n              } else if (parser.getCurrentName().equals(\"events\")\n                  && parser.nextToken() == JsonToken.START_ARRAY) {\n                while (parser.nextToken() == JsonToken.START_OBJECT) {\n                  expectScalarField(parser, \"segmentId\");\n                  expectScalarField(parser, \"offset\");\n                  if (parser.nextToken() == JsonToken.FIELD_NAME\n                      && parser.getCurrentName().equals(\"event\")\n                      && parser.nextToken() == JsonToken.START_OBJECT) {\n                    parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n                    sink.send(rowBuilder.build());\n                    rowBuilder.reset();\n                    page.totalRowCount += 1;\n                  }\n                  expect(parser, JsonToken.END_OBJECT);\n                }\n                parser.nextToken();\n              } else if (parser.getCurrentName().equals(\"dimensions\")\n                  || parser.getCurrentName().equals(\"metrics\")) {\n                expect(parser, JsonToken.START_ARRAY);\n                while (parser.nextToken() != JsonToken.END_ARRAY) {\n                  \r\n                }\n              }\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case SCAN:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"segmentId\");\n\n            expect(parser, JsonToken.FIELD_NAME);\n            if (parser.getCurrentName().equals(\"columns\")) {\n              expect(parser, JsonToken.START_ARRAY);\n              while (parser.nextToken() != JsonToken.END_ARRAY) {\n                \r\n              }\n            }\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"events\")\n                && parser.nextToken() == JsonToken.START_ARRAY) {\n              \r\n              while (parser.nextToken() == JsonToken.START_ARRAY) {\n                for (String field : fieldNames) {\n                  parseFieldForName(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser,\n                      field);\n                }\n                expect(parser, JsonToken.END_ARRAY);\n                Row row = rowBuilder.build();\n                sink.send(row);\n                rowBuilder.reset();\n                page.totalRowCount += 1;\n              }\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","date":"2017-12-22 04:16:18","endLine":288,"groupId":"1925","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"(QueryTypequeryType@InputStreamin@Sinksink@List<String>fieldNames@List<ColumnMetaData.Rep>fieldTypes@Pagepage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/4f/65dff85a7b400d2408f498fabc8910911105b4.src","preCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<ColumnMetaData.Rep> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalcitePrepareImpl.DEBUG) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \"\n            + new String(bytes, StandardCharsets.UTF_8));\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    int posTimestampField = -1;\n    for (int i = 0; i < fieldTypes.size(); i++) {\n      if (fieldTypes.get(i) == ColumnMetaData.Rep.JAVA_SQL_TIMESTAMP) {\n        posTimestampField = i;\n        break;\n      }\n    }\n\n    try (final JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TIMESERIES:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n           \r\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"result\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          final Long timeValue = extractTimestampField(parser);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          page.totalRowCount = 0;\n          expectScalarField(parser, DEFAULT_RESPONSE_TIMESTAMP_COLUMN);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            while (parser.nextToken() == JsonToken.FIELD_NAME) {\n              if (parser.getCurrentName().equals(\"pagingIdentifiers\")\n                  && parser.nextToken() == JsonToken.START_OBJECT) {\n                JsonToken token = parser.nextToken();\n                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {\n                  page.pagingIdentifier = parser.getCurrentName();\n                  if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                    page.offset = parser.getIntValue();\n                  }\n                  token = parser.nextToken();\n                }\n                expect(token, JsonToken.END_OBJECT);\n              } else if (parser.getCurrentName().equals(\"events\")\n                  && parser.nextToken() == JsonToken.START_ARRAY) {\n                while (parser.nextToken() == JsonToken.START_OBJECT) {\n                  expectScalarField(parser, \"segmentId\");\n                  expectScalarField(parser, \"offset\");\n                  if (parser.nextToken() == JsonToken.FIELD_NAME\n                      && parser.getCurrentName().equals(\"event\")\n                      && parser.nextToken() == JsonToken.START_OBJECT) {\n                    parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n                    sink.send(rowBuilder.build());\n                    rowBuilder.reset();\n                    page.totalRowCount += 1;\n                  }\n                  expect(parser, JsonToken.END_OBJECT);\n                }\n                parser.nextToken();\n              } else if (parser.getCurrentName().equals(\"dimensions\")\n                  || parser.getCurrentName().equals(\"metrics\")) {\n                expect(parser, JsonToken.START_ARRAY);\n                while (parser.nextToken() != JsonToken.END_ARRAY) {\n                  \r\n                }\n              }\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":117,"status":"M"},{"authorDate":"2016-03-04 10:39:39","commitOrder":12,"curCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","date":"2016-04-22 08:26:48","endLine":246,"groupId":"644","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"expectObjectField","params":"(JsonParserparser@Stringname)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/dd/462b6812ea4cbea3f8e6fc1f315d4f546f88f1.src","preCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":235,"status":"N"}],"commitId":"159bcab20d2024b938cdc52ca9152631279d63df","commitMessage":"@@@[CALCITE-2077] Druid adapter: Use 'scan' query rather than 'select' query (Nishant Bangarwa)\n\nClose apache/calcite#577\n","date":"2017-12-22 04:16:18","modifiedFileCount":"4","status":"M","submitter":"Nishant Bangarwa"},{"authorTime":"2016-03-04 10:39:39","codes":[{"authorDate":"2018-09-16 18:12:25","commitOrder":13,"curCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<ColumnMetaData.Rep> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalcitePrepareImpl.DEBUG) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \"\n            + new String(bytes, StandardCharsets.UTF_8)); \r\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    int posTimestampField = -1;\n    for (int i = 0; i < fieldTypes.size(); i++) {\n      \r\n\r\n\r\n\n      if (fieldTypes.get(i) == ColumnMetaData.Rep.JAVA_SQL_TIMESTAMP) {\n        posTimestampField = i;\n        break;\n      }\n    }\n\n    try (JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TIMESERIES:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n           \r\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"result\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          final Long timeValue = extractTimestampField(parser);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          page.totalRowCount = 0;\n          expectScalarField(parser, DEFAULT_RESPONSE_TIMESTAMP_COLUMN);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            while (parser.nextToken() == JsonToken.FIELD_NAME) {\n              if (parser.getCurrentName().equals(\"pagingIdentifiers\")\n                  && parser.nextToken() == JsonToken.START_OBJECT) {\n                JsonToken token = parser.nextToken();\n                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {\n                  page.pagingIdentifier = parser.getCurrentName();\n                  if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                    page.offset = parser.getIntValue();\n                  }\n                  token = parser.nextToken();\n                }\n                expect(token, JsonToken.END_OBJECT);\n              } else if (parser.getCurrentName().equals(\"events\")\n                  && parser.nextToken() == JsonToken.START_ARRAY) {\n                while (parser.nextToken() == JsonToken.START_OBJECT) {\n                  expectScalarField(parser, \"segmentId\");\n                  expectScalarField(parser, \"offset\");\n                  if (parser.nextToken() == JsonToken.FIELD_NAME\n                      && parser.getCurrentName().equals(\"event\")\n                      && parser.nextToken() == JsonToken.START_OBJECT) {\n                    parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n                    sink.send(rowBuilder.build());\n                    rowBuilder.reset();\n                    page.totalRowCount += 1;\n                  }\n                  expect(parser, JsonToken.END_OBJECT);\n                }\n                parser.nextToken();\n              } else if (parser.getCurrentName().equals(\"dimensions\")\n                  || parser.getCurrentName().equals(\"metrics\")) {\n                expect(parser, JsonToken.START_ARRAY);\n                while (parser.nextToken() != JsonToken.END_ARRAY) {\n                  \r\n                }\n              }\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case SCAN:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"segmentId\");\n\n            expect(parser, JsonToken.FIELD_NAME);\n            if (parser.getCurrentName().equals(\"columns\")) {\n              expect(parser, JsonToken.START_ARRAY);\n              while (parser.nextToken() != JsonToken.END_ARRAY) {\n                \r\n              }\n            }\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"events\")\n                && parser.nextToken() == JsonToken.START_ARRAY) {\n              \r\n              while (parser.nextToken() == JsonToken.START_ARRAY) {\n                for (String field : fieldNames) {\n                  parseFieldForName(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser,\n                      field);\n                }\n                expect(parser, JsonToken.END_ARRAY);\n                Row row = rowBuilder.build();\n                sink.send(row);\n                rowBuilder.reset();\n                page.totalRowCount += 1;\n              }\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","date":"2018-09-16 20:33:59","endLine":295,"groupId":"1925","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"(QueryTypequeryType@InputStreamin@Sinksink@List<String>fieldNames@List<ColumnMetaData.Rep>fieldTypes@Pagepage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e1/a8f66aaa6d329c8a815396431294b787e8c546.src","preCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<ColumnMetaData.Rep> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalcitePrepareImpl.DEBUG) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \"\n            + new String(bytes, StandardCharsets.UTF_8));\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    int posTimestampField = -1;\n    for (int i = 0; i < fieldTypes.size(); i++) {\n      \r\n\r\n\r\n\n      if (fieldTypes.get(i) == ColumnMetaData.Rep.JAVA_SQL_TIMESTAMP) {\n        posTimestampField = i;\n        break;\n      }\n    }\n\n    try (final JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TIMESERIES:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n           \r\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"result\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          final Long timeValue = extractTimestampField(parser);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          page.totalRowCount = 0;\n          expectScalarField(parser, DEFAULT_RESPONSE_TIMESTAMP_COLUMN);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            while (parser.nextToken() == JsonToken.FIELD_NAME) {\n              if (parser.getCurrentName().equals(\"pagingIdentifiers\")\n                  && parser.nextToken() == JsonToken.START_OBJECT) {\n                JsonToken token = parser.nextToken();\n                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {\n                  page.pagingIdentifier = parser.getCurrentName();\n                  if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                    page.offset = parser.getIntValue();\n                  }\n                  token = parser.nextToken();\n                }\n                expect(token, JsonToken.END_OBJECT);\n              } else if (parser.getCurrentName().equals(\"events\")\n                  && parser.nextToken() == JsonToken.START_ARRAY) {\n                while (parser.nextToken() == JsonToken.START_OBJECT) {\n                  expectScalarField(parser, \"segmentId\");\n                  expectScalarField(parser, \"offset\");\n                  if (parser.nextToken() == JsonToken.FIELD_NAME\n                      && parser.getCurrentName().equals(\"event\")\n                      && parser.nextToken() == JsonToken.START_OBJECT) {\n                    parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n                    sink.send(rowBuilder.build());\n                    rowBuilder.reset();\n                    page.totalRowCount += 1;\n                  }\n                  expect(parser, JsonToken.END_OBJECT);\n                }\n                parser.nextToken();\n              } else if (parser.getCurrentName().equals(\"dimensions\")\n                  || parser.getCurrentName().equals(\"metrics\")) {\n                expect(parser, JsonToken.START_ARRAY);\n                while (parser.nextToken() != JsonToken.END_ARRAY) {\n                  \r\n                }\n              }\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case SCAN:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"segmentId\");\n\n            expect(parser, JsonToken.FIELD_NAME);\n            if (parser.getCurrentName().equals(\"columns\")) {\n              expect(parser, JsonToken.START_ARRAY);\n              while (parser.nextToken() != JsonToken.END_ARRAY) {\n                \r\n              }\n            }\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"events\")\n                && parser.nextToken() == JsonToken.START_ARRAY) {\n              \r\n              while (parser.nextToken() == JsonToken.START_ARRAY) {\n                for (String field : fieldNames) {\n                  parseFieldForName(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser,\n                      field);\n                }\n                expect(parser, JsonToken.END_ARRAY);\n                Row row = rowBuilder.build();\n                sink.send(row);\n                rowBuilder.reset();\n                page.totalRowCount += 1;\n              }\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":120,"status":"M"},{"authorDate":"2016-03-04 10:39:39","commitOrder":13,"curCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","date":"2016-04-22 08:26:48","endLine":246,"groupId":"644","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"expectObjectField","params":"(JsonParserparser@Stringname)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/dd/462b6812ea4cbea3f8e6fc1f315d4f546f88f1.src","preCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":235,"status":"N"}],"commitId":"4b4d8037c5073e4eb5702b12bc4ecade31476616","commitMessage":"@@@[CALCITE-2559] Update Checkstyle to 7.8.2\n\nIt catches violations better and it caches validation results.  so repeated validations are faster\n","date":"2018-09-16 20:33:59","modifiedFileCount":"47","status":"M","submitter":"Vladimir Sitnikov"},{"authorTime":"2016-03-04 10:39:39","codes":[{"authorDate":"2019-02-22 18:30:45","commitOrder":14,"curCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<ColumnMetaData.Rep> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalciteSystemProperty.DEBUG.value()) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \"\n            + new String(bytes, StandardCharsets.UTF_8)); \r\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    int posTimestampField = -1;\n    for (int i = 0; i < fieldTypes.size(); i++) {\n      \r\n\r\n\r\n\n      if (fieldTypes.get(i) == ColumnMetaData.Rep.JAVA_SQL_TIMESTAMP) {\n        posTimestampField = i;\n        break;\n      }\n    }\n\n    try (JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TIMESERIES:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n           \r\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"result\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          final Long timeValue = extractTimestampField(parser);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          page.totalRowCount = 0;\n          expectScalarField(parser, DEFAULT_RESPONSE_TIMESTAMP_COLUMN);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            while (parser.nextToken() == JsonToken.FIELD_NAME) {\n              if (parser.getCurrentName().equals(\"pagingIdentifiers\")\n                  && parser.nextToken() == JsonToken.START_OBJECT) {\n                JsonToken token = parser.nextToken();\n                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {\n                  page.pagingIdentifier = parser.getCurrentName();\n                  if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                    page.offset = parser.getIntValue();\n                  }\n                  token = parser.nextToken();\n                }\n                expect(token, JsonToken.END_OBJECT);\n              } else if (parser.getCurrentName().equals(\"events\")\n                  && parser.nextToken() == JsonToken.START_ARRAY) {\n                while (parser.nextToken() == JsonToken.START_OBJECT) {\n                  expectScalarField(parser, \"segmentId\");\n                  expectScalarField(parser, \"offset\");\n                  if (parser.nextToken() == JsonToken.FIELD_NAME\n                      && parser.getCurrentName().equals(\"event\")\n                      && parser.nextToken() == JsonToken.START_OBJECT) {\n                    parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n                    sink.send(rowBuilder.build());\n                    rowBuilder.reset();\n                    page.totalRowCount += 1;\n                  }\n                  expect(parser, JsonToken.END_OBJECT);\n                }\n                parser.nextToken();\n              } else if (parser.getCurrentName().equals(\"dimensions\")\n                  || parser.getCurrentName().equals(\"metrics\")) {\n                expect(parser, JsonToken.START_ARRAY);\n                while (parser.nextToken() != JsonToken.END_ARRAY) {\n                  \r\n                }\n              }\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case SCAN:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"segmentId\");\n\n            expect(parser, JsonToken.FIELD_NAME);\n            if (parser.getCurrentName().equals(\"columns\")) {\n              expect(parser, JsonToken.START_ARRAY);\n              while (parser.nextToken() != JsonToken.END_ARRAY) {\n                \r\n              }\n            }\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"events\")\n                && parser.nextToken() == JsonToken.START_ARRAY) {\n              \r\n              while (parser.nextToken() == JsonToken.START_ARRAY) {\n                for (String field : fieldNames) {\n                  parseFieldForName(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser,\n                      field);\n                }\n                expect(parser, JsonToken.END_ARRAY);\n                Row row = rowBuilder.build();\n                sink.send(row);\n                rowBuilder.reset();\n                page.totalRowCount += 1;\n              }\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","date":"2019-02-28 18:05:41","endLine":295,"groupId":"1925","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"(QueryTypequeryType@InputStreamin@Sinksink@List<String>fieldNames@List<ColumnMetaData.Rep>fieldTypes@Pagepage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/09/d90f9930d4932a39f5427a9518b3b4384f84ce.src","preCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<ColumnMetaData.Rep> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalcitePrepareImpl.DEBUG) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \"\n            + new String(bytes, StandardCharsets.UTF_8)); \r\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    int posTimestampField = -1;\n    for (int i = 0; i < fieldTypes.size(); i++) {\n      \r\n\r\n\r\n\n      if (fieldTypes.get(i) == ColumnMetaData.Rep.JAVA_SQL_TIMESTAMP) {\n        posTimestampField = i;\n        break;\n      }\n    }\n\n    try (JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TIMESERIES:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n           \r\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"result\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          final Long timeValue = extractTimestampField(parser);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          page.totalRowCount = 0;\n          expectScalarField(parser, DEFAULT_RESPONSE_TIMESTAMP_COLUMN);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            while (parser.nextToken() == JsonToken.FIELD_NAME) {\n              if (parser.getCurrentName().equals(\"pagingIdentifiers\")\n                  && parser.nextToken() == JsonToken.START_OBJECT) {\n                JsonToken token = parser.nextToken();\n                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {\n                  page.pagingIdentifier = parser.getCurrentName();\n                  if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                    page.offset = parser.getIntValue();\n                  }\n                  token = parser.nextToken();\n                }\n                expect(token, JsonToken.END_OBJECT);\n              } else if (parser.getCurrentName().equals(\"events\")\n                  && parser.nextToken() == JsonToken.START_ARRAY) {\n                while (parser.nextToken() == JsonToken.START_OBJECT) {\n                  expectScalarField(parser, \"segmentId\");\n                  expectScalarField(parser, \"offset\");\n                  if (parser.nextToken() == JsonToken.FIELD_NAME\n                      && parser.getCurrentName().equals(\"event\")\n                      && parser.nextToken() == JsonToken.START_OBJECT) {\n                    parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n                    sink.send(rowBuilder.build());\n                    rowBuilder.reset();\n                    page.totalRowCount += 1;\n                  }\n                  expect(parser, JsonToken.END_OBJECT);\n                }\n                parser.nextToken();\n              } else if (parser.getCurrentName().equals(\"dimensions\")\n                  || parser.getCurrentName().equals(\"metrics\")) {\n                expect(parser, JsonToken.START_ARRAY);\n                while (parser.nextToken() != JsonToken.END_ARRAY) {\n                  \r\n                }\n              }\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case SCAN:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"segmentId\");\n\n            expect(parser, JsonToken.FIELD_NAME);\n            if (parser.getCurrentName().equals(\"columns\")) {\n              expect(parser, JsonToken.START_ARRAY);\n              while (parser.nextToken() != JsonToken.END_ARRAY) {\n                \r\n              }\n            }\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"events\")\n                && parser.nextToken() == JsonToken.START_ARRAY) {\n              \r\n              while (parser.nextToken() == JsonToken.START_ARRAY) {\n                for (String field : fieldNames) {\n                  parseFieldForName(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser,\n                      field);\n                }\n                expect(parser, JsonToken.END_ARRAY);\n                Row row = rowBuilder.build();\n                sink.send(row);\n                rowBuilder.reset();\n                page.totalRowCount += 1;\n              }\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":120,"status":"M"},{"authorDate":"2016-03-04 10:39:39","commitOrder":14,"curCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","date":"2016-04-22 08:26:48","endLine":246,"groupId":"644","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"expectObjectField","params":"(JsonParserparser@Stringname)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/dd/462b6812ea4cbea3f8e6fc1f315d4f546f88f1.src","preCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":235,"status":"N"}],"commitId":"280642a02a4bcfd1fb9cbe8c5ab672d3619860e7","commitMessage":"@@@[CALCITE-2859] Centralize Calcite system properties\n\n1. Move all system properties with \"calcite\" namespace under a common class.\n2. Improve the documentation (javadoc) of existing properties.\n3. Add review comments regarding a few properties.\n4. Deprecate SaffronProperties and move them all under CalciteSystemProperty.\n","date":"2019-02-28 18:05:41","modifiedFileCount":"58","status":"M","submitter":"Stamatis Zampetakis"},{"authorTime":"2016-03-04 10:39:39","codes":[{"authorDate":"2020-09-30 01:31:14","commitOrder":15,"curCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<ColumnMetaData.Rep> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalciteSystemProperty.DEBUG.value()) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \"\n            + new String(bytes, StandardCharsets.UTF_8)); \r\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    int posTimestampField = -1;\n    for (int i = 0; i < fieldTypes.size(); i++) {\n      \r\n\r\n\r\n\n      if (fieldTypes.get(i) == ColumnMetaData.Rep.JAVA_SQL_TIMESTAMP) {\n        posTimestampField = i;\n        break;\n      }\n    }\n\n    try (JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TIMESERIES:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n           \r\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"result\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          final Long timeValue = extractTimestampField(parser);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          page.totalRowCount = 0;\n          expectScalarField(parser, DEFAULT_RESPONSE_TIMESTAMP_COLUMN);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            while (parser.nextToken() == JsonToken.FIELD_NAME) {\n              if (parser.getCurrentName().equals(\"pagingIdentifiers\")\n                  && parser.nextToken() == JsonToken.START_OBJECT) {\n                JsonToken token = parser.nextToken();\n                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {\n                  page.pagingIdentifier = parser.getCurrentName();\n                  if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                    page.offset = parser.getIntValue();\n                  }\n                  token = parser.nextToken();\n                }\n                expect(token, JsonToken.END_OBJECT);\n              } else if (parser.getCurrentName().equals(\"events\")\n                  && parser.nextToken() == JsonToken.START_ARRAY) {\n                while (parser.nextToken() == JsonToken.START_OBJECT) {\n                  expectScalarField(parser, \"segmentId\");\n                  expectScalarField(parser, \"offset\");\n                  if (parser.nextToken() == JsonToken.FIELD_NAME\n                      && parser.getCurrentName().equals(\"event\")\n                      && parser.nextToken() == JsonToken.START_OBJECT) {\n                    parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n                    sink.send(rowBuilder.build());\n                    rowBuilder.reset();\n                    page.totalRowCount += 1;\n                  }\n                  expect(parser, JsonToken.END_OBJECT);\n                }\n                parser.nextToken();\n              } else if (parser.getCurrentName().equals(\"dimensions\")\n                  || parser.getCurrentName().equals(\"metrics\")) {\n                expect(parser, JsonToken.START_ARRAY);\n                while (parser.nextToken() != JsonToken.END_ARRAY) {\n                  \r\n                }\n              }\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case SCAN:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"segmentId\");\n\n            expect(parser, JsonToken.FIELD_NAME);\n            if (parser.getCurrentName().equals(\"columns\")) {\n              expect(parser, JsonToken.START_ARRAY);\n              while (parser.nextToken() != JsonToken.END_ARRAY) {\n                \r\n              }\n            }\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"events\")\n                && parser.nextToken() == JsonToken.START_ARRAY) {\n              \r\n              while (parser.nextToken() == JsonToken.START_ARRAY) {\n                for (String field : fieldNames) {\n                  parseFieldForName(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser,\n                      field);\n                }\n                expect(parser, JsonToken.END_ARRAY);\n                Row row = rowBuilder.build();\n                sink.send(row);\n                rowBuilder.reset();\n                page.totalRowCount += 1;\n              }\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n      default:\n        break;\n      }\n    } catch (IOException | InterruptedException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","date":"2020-10-07 05:43:06","endLine":295,"groupId":"1925","id":29,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"(QueryTypequeryType@InputStreamin@Sinksink@List<String>fieldNames@List<ColumnMetaData.Rep>fieldTypes@Pagepage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/b4/7d02e9967e38b40a4cdb82352d1bd8d92b0f65.src","preCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<ColumnMetaData.Rep> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalciteSystemProperty.DEBUG.value()) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \"\n            + new String(bytes, StandardCharsets.UTF_8)); \r\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    int posTimestampField = -1;\n    for (int i = 0; i < fieldTypes.size(); i++) {\n      \r\n\r\n\r\n\n      if (fieldTypes.get(i) == ColumnMetaData.Rep.JAVA_SQL_TIMESTAMP) {\n        posTimestampField = i;\n        break;\n      }\n    }\n\n    try (JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TIMESERIES:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n           \r\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"result\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          final Long timeValue = extractTimestampField(parser);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          page.totalRowCount = 0;\n          expectScalarField(parser, DEFAULT_RESPONSE_TIMESTAMP_COLUMN);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            while (parser.nextToken() == JsonToken.FIELD_NAME) {\n              if (parser.getCurrentName().equals(\"pagingIdentifiers\")\n                  && parser.nextToken() == JsonToken.START_OBJECT) {\n                JsonToken token = parser.nextToken();\n                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {\n                  page.pagingIdentifier = parser.getCurrentName();\n                  if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                    page.offset = parser.getIntValue();\n                  }\n                  token = parser.nextToken();\n                }\n                expect(token, JsonToken.END_OBJECT);\n              } else if (parser.getCurrentName().equals(\"events\")\n                  && parser.nextToken() == JsonToken.START_ARRAY) {\n                while (parser.nextToken() == JsonToken.START_OBJECT) {\n                  expectScalarField(parser, \"segmentId\");\n                  expectScalarField(parser, \"offset\");\n                  if (parser.nextToken() == JsonToken.FIELD_NAME\n                      && parser.getCurrentName().equals(\"event\")\n                      && parser.nextToken() == JsonToken.START_OBJECT) {\n                    parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n                    sink.send(rowBuilder.build());\n                    rowBuilder.reset();\n                    page.totalRowCount += 1;\n                  }\n                  expect(parser, JsonToken.END_OBJECT);\n                }\n                parser.nextToken();\n              } else if (parser.getCurrentName().equals(\"dimensions\")\n                  || parser.getCurrentName().equals(\"metrics\")) {\n                expect(parser, JsonToken.START_ARRAY);\n                while (parser.nextToken() != JsonToken.END_ARRAY) {\n                  \r\n                }\n              }\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case SCAN:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"segmentId\");\n\n            expect(parser, JsonToken.FIELD_NAME);\n            if (parser.getCurrentName().equals(\"columns\")) {\n              expect(parser, JsonToken.START_ARRAY);\n              while (parser.nextToken() != JsonToken.END_ARRAY) {\n                \r\n              }\n            }\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"events\")\n                && parser.nextToken() == JsonToken.START_ARRAY) {\n              \r\n              while (parser.nextToken() == JsonToken.START_ARRAY) {\n                for (String field : fieldNames) {\n                  parseFieldForName(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser,\n                      field);\n                }\n                expect(parser, JsonToken.END_ARRAY);\n                Row row = rowBuilder.build();\n                sink.send(row);\n                rowBuilder.reset();\n                page.totalRowCount += 1;\n              }\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n      }\n    } catch (IOException | InterruptedException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":117,"status":"M"},{"authorDate":"2016-03-04 10:39:39","commitOrder":15,"curCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","date":"2016-04-22 08:26:48","endLine":246,"groupId":"644","id":30,"instanceNumber":2,"isCurCommit":0,"methodName":"expectObjectField","params":"(JsonParserparser@Stringname)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/dd/462b6812ea4cbea3f8e6fc1f315d4f546f88f1.src","preCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n        \r\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":235,"status":"N"}],"commitId":"1b94f37e888cf2d186362473529e6c147afe0f6e","commitMessage":"@@@[CALCITE-4314] Add missing default branches to switch statement\n\nNote: the changes are mechanical.\nThe intention is to keep the previous behavior and prevent adding new\nnon exchaustive switch statements in the future.\n\nSee https://errorprone.info/bugpattern/MissingCasesInEnumSwitch\n","date":"2020-10-07 05:43:06","modifiedFileCount":"98","status":"M","submitter":"Vladimir Sitnikov"},{"authorTime":"2020-12-02 05:40:39","codes":[{"authorDate":"2020-12-02 05:40:39","commitOrder":16,"curCode":"  private static void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<ColumnMetaData.Rep> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalciteSystemProperty.DEBUG.value()) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \"\n            + new String(bytes, StandardCharsets.UTF_8)); \r\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    int posTimestampField = -1;\n    for (int i = 0; i < fieldTypes.size(); i++) {\n      \r\n\r\n\r\n\n      if (fieldTypes.get(i) == ColumnMetaData.Rep.JAVA_SQL_TIMESTAMP) {\n        posTimestampField = i;\n        break;\n      }\n    }\n\n    try (JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TIMESERIES:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n           \r\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"result\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          final Long timeValue = extractTimestampField(parser);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          page.totalRowCount = 0;\n          expectScalarField(parser, DEFAULT_RESPONSE_TIMESTAMP_COLUMN);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            while (parser.nextToken() == JsonToken.FIELD_NAME) {\n              if (parser.getCurrentName().equals(\"pagingIdentifiers\")\n                  && parser.nextToken() == JsonToken.START_OBJECT) {\n                JsonToken token = parser.nextToken();\n                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {\n                  page.pagingIdentifier = parser.getCurrentName();\n                  if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                    page.offset = parser.getIntValue();\n                  }\n                  token = parser.nextToken();\n                }\n                expect(token, JsonToken.END_OBJECT);\n              } else if (parser.getCurrentName().equals(\"events\")\n                  && parser.nextToken() == JsonToken.START_ARRAY) {\n                while (parser.nextToken() == JsonToken.START_OBJECT) {\n                  expectScalarField(parser, \"segmentId\");\n                  expectScalarField(parser, \"offset\");\n                  if (parser.nextToken() == JsonToken.FIELD_NAME\n                      && parser.getCurrentName().equals(\"event\")\n                      && parser.nextToken() == JsonToken.START_OBJECT) {\n                    parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n                    sink.send(rowBuilder.build());\n                    rowBuilder.reset();\n                    page.totalRowCount += 1;\n                  }\n                  expect(parser, JsonToken.END_OBJECT);\n                }\n                parser.nextToken();\n              } else if (parser.getCurrentName().equals(\"dimensions\")\n                  || parser.getCurrentName().equals(\"metrics\")) {\n                expect(parser, JsonToken.START_ARRAY);\n                while (parser.nextToken() != JsonToken.END_ARRAY) {\n                  \r\n                }\n              }\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case SCAN:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"segmentId\");\n\n            expect(parser, JsonToken.FIELD_NAME);\n            if (parser.getCurrentName().equals(\"columns\")) {\n              expect(parser, JsonToken.START_ARRAY);\n              while (parser.nextToken() != JsonToken.END_ARRAY) {\n                \r\n              }\n            }\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"events\")\n                && parser.nextToken() == JsonToken.START_ARRAY) {\n              \r\n              while (parser.nextToken() == JsonToken.START_ARRAY) {\n                for (String field : fieldNames) {\n                  parseFieldForName(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser,\n                      field);\n                }\n                expect(parser, JsonToken.END_ARRAY);\n                Row row = rowBuilder.build();\n                sink.send(row);\n                rowBuilder.reset();\n                page.totalRowCount += 1;\n              }\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n      default:\n        break;\n      }\n    } catch (IOException | InterruptedException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","date":"2020-12-08 15:07:23","endLine":295,"groupId":"10469","id":31,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"(QueryTypequeryType@InputStreamin@Sinksink@List<String>fieldNames@List<ColumnMetaData.Rep>fieldTypes@Pagepage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/c5/54860a5c7512bcccdd8f59592ff49c1fda4aef.src","preCode":"  private void parse(QueryType queryType, InputStream in, Sink sink,\n      List<String> fieldNames, List<ColumnMetaData.Rep> fieldTypes, Page page) {\n    final JsonFactory factory = new JsonFactory();\n    final Row.RowBuilder rowBuilder = Row.newBuilder(fieldNames.size());\n\n    if (CalciteSystemProperty.DEBUG.value()) {\n      try {\n        final byte[] bytes = AvaticaUtils.readFullyToBytes(in);\n        System.out.println(\"Response: \"\n            + new String(bytes, StandardCharsets.UTF_8)); \r\n        in = new ByteArrayInputStream(bytes);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    int posTimestampField = -1;\n    for (int i = 0; i < fieldTypes.size(); i++) {\n      \r\n\r\n\r\n\n      if (fieldTypes.get(i) == ColumnMetaData.Rep.JAVA_SQL_TIMESTAMP) {\n        posTimestampField = i;\n        break;\n      }\n    }\n\n    try (JsonParser parser = factory.createParser(in)) {\n      switch (queryType) {\n      case TIMESERIES:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n           \r\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                    && parser.getCurrentName().equals(\"result\")\n                    && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case TOP_N:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          final Long timeValue = extractTimestampField(parser);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_ARRAY) {\n            while (parser.nextToken() == JsonToken.START_OBJECT) {\n              \r\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n          }\n        }\n        break;\n\n      case SELECT:\n        if (parser.nextToken() == JsonToken.START_ARRAY\n            && parser.nextToken() == JsonToken.START_OBJECT) {\n          page.pagingIdentifier = null;\n          page.offset = -1;\n          page.totalRowCount = 0;\n          expectScalarField(parser, DEFAULT_RESPONSE_TIMESTAMP_COLUMN);\n          if (parser.nextToken() == JsonToken.FIELD_NAME\n              && parser.getCurrentName().equals(\"result\")\n              && parser.nextToken() == JsonToken.START_OBJECT) {\n            while (parser.nextToken() == JsonToken.FIELD_NAME) {\n              if (parser.getCurrentName().equals(\"pagingIdentifiers\")\n                  && parser.nextToken() == JsonToken.START_OBJECT) {\n                JsonToken token = parser.nextToken();\n                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {\n                  page.pagingIdentifier = parser.getCurrentName();\n                  if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {\n                    page.offset = parser.getIntValue();\n                  }\n                  token = parser.nextToken();\n                }\n                expect(token, JsonToken.END_OBJECT);\n              } else if (parser.getCurrentName().equals(\"events\")\n                  && parser.nextToken() == JsonToken.START_ARRAY) {\n                while (parser.nextToken() == JsonToken.START_OBJECT) {\n                  expectScalarField(parser, \"segmentId\");\n                  expectScalarField(parser, \"offset\");\n                  if (parser.nextToken() == JsonToken.FIELD_NAME\n                      && parser.getCurrentName().equals(\"event\")\n                      && parser.nextToken() == JsonToken.START_OBJECT) {\n                    parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n                    sink.send(rowBuilder.build());\n                    rowBuilder.reset();\n                    page.totalRowCount += 1;\n                  }\n                  expect(parser, JsonToken.END_OBJECT);\n                }\n                parser.nextToken();\n              } else if (parser.getCurrentName().equals(\"dimensions\")\n                  || parser.getCurrentName().equals(\"metrics\")) {\n                expect(parser, JsonToken.START_ARRAY);\n                while (parser.nextToken() != JsonToken.END_ARRAY) {\n                  \r\n                }\n              }\n            }\n          }\n        }\n        break;\n\n      case GROUP_BY:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"version\");\n            final Long timeValue = extractTimestampField(parser);\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"event\")\n                && parser.nextToken() == JsonToken.START_OBJECT) {\n              if (posTimestampField != -1) {\n                rowBuilder.set(posTimestampField, timeValue);\n              }\n              parseFields(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser);\n              sink.send(rowBuilder.build());\n              rowBuilder.reset();\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n\n      case SCAN:\n        if (parser.nextToken() == JsonToken.START_ARRAY) {\n          while (parser.nextToken() == JsonToken.START_OBJECT) {\n            expectScalarField(parser, \"segmentId\");\n\n            expect(parser, JsonToken.FIELD_NAME);\n            if (parser.getCurrentName().equals(\"columns\")) {\n              expect(parser, JsonToken.START_ARRAY);\n              while (parser.nextToken() != JsonToken.END_ARRAY) {\n                \r\n              }\n            }\n            if (parser.nextToken() == JsonToken.FIELD_NAME\n                && parser.getCurrentName().equals(\"events\")\n                && parser.nextToken() == JsonToken.START_ARRAY) {\n              \r\n              while (parser.nextToken() == JsonToken.START_ARRAY) {\n                for (String field : fieldNames) {\n                  parseFieldForName(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser,\n                      field);\n                }\n                expect(parser, JsonToken.END_ARRAY);\n                Row row = rowBuilder.build();\n                sink.send(row);\n                rowBuilder.reset();\n                page.totalRowCount += 1;\n              }\n            }\n            expect(parser, JsonToken.END_OBJECT);\n          }\n        }\n        break;\n      default:\n        break;\n      }\n    } catch (IOException | InterruptedException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":117,"status":"M"},{"authorDate":"2020-12-02 05:40:39","commitOrder":16,"curCode":"  private static void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n      \r\n    }\n  }\n","date":"2020-12-08 15:07:23","endLine":499,"groupId":"10469","id":32,"instanceNumber":2,"isCurCommit":0,"methodName":"expectObjectField","params":"(JsonParserparser@Stringname)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/c5/54860a5c7512bcccdd8f59592ff49c1fda4aef.src","preCode":"  private void expectObjectField(JsonParser parser, String name)\n      throws IOException {\n    expect(parser, JsonToken.FIELD_NAME);\n    if (!parser.getCurrentName().equals(name)) {\n      throw new RuntimeException(\"expected field \" + name + \", got \"\n          + parser.getCurrentName());\n    }\n    expect(parser, JsonToken.START_OBJECT);\n    while (parser.nextToken() != JsonToken.END_OBJECT) {\n      \r\n    }\n  }\n","realPath":"druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":488,"status":"M"}],"commitId":"404f968f6079360621896e6ee20ec12488a40bc2","commitMessage":"@@@[CALCITE-4422] Add MethodCanBeStatic check via ErrorProne\n\nprivate and final methods can be made static.  so it is clear they do not access instance fields\n","date":"2020-12-08 15:07:23","modifiedFileCount":"169","status":"M","submitter":"Vladimir Sitnikov"}]
