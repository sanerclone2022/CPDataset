[{"authorTime":"2019-01-24 06:32:00","codes":[{"authorDate":"2016-04-14 16:15:02","commitOrder":2,"curCode":"  @Test public void testSplitJoinConditionExpandedIsNotDistinctFrom() {\n    int leftJoinIndex = EMP_SCAN.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = DEPT_ROW.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(EMP_ROW.getFieldCount() + rightJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexNode joinCond = REL_BUILDER.call(SqlStdOperatorTable.OR,\n        REL_BUILDER.call(SqlStdOperatorTable.EQUALS, leftKeyInputRef, rightKeyInputRef),\n        REL_BUILDER.call(SqlStdOperatorTable.AND,\n            REL_BUILDER.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n            REL_BUILDER.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef)));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        REL_BUILDER.literal(true));\n  }\n","date":"2016-04-30 09:21:04","endLine":188,"groupId":"16492","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testSplitJoinConditionExpandedIsNotDistinctFrom","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/03/bd725ce54599af328b5c610e92b2b4500ccb67.src","preCode":"  @Test public void testSplitJoinConditionExpandedIsNotDistinctFrom() {\n    int leftJoinIndex = EMP_SCAN.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = DEPT_ROW.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(EMP_ROW.getFieldCount() + rightJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexNode joinCond = REL_BUILDER.call(SqlStdOperatorTable.OR,\n        REL_BUILDER.call(SqlStdOperatorTable.EQUALS, leftKeyInputRef, rightKeyInputRef),\n        REL_BUILDER.call(SqlStdOperatorTable.AND,\n            REL_BUILDER.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n            REL_BUILDER.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef)));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        REL_BUILDER.literal(true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/RelOptUtilTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":169,"status":"NB"},{"authorDate":"2019-01-24 06:32:00","commitOrder":2,"curCode":"  @Test public void testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2() {\n    int leftJoinIndex = EMP_SCAN.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = DEPT_ROW.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(EMP_ROW.getFieldCount() + rightJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexNode joinCond = REL_BUILDER.call(SqlStdOperatorTable.CASE,\n        REL_BUILDER.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        REL_BUILDER.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        REL_BUILDER.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        REL_BUILDER.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        REL_BUILDER.call(SqlStdOperatorTable.EQUALS, leftKeyInputRef, rightKeyInputRef));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        REL_BUILDER.literal(true));\n  }\n","date":"2019-05-14 04:17:07","endLine":241,"groupId":"622","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/27/5203497e8e6473b927ac7fc607fc705c3feada.src","preCode":"  @Test public void testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2() {\n    int leftJoinIndex = EMP_SCAN.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = DEPT_ROW.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(EMP_ROW.getFieldCount() + rightJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexNode joinCond = REL_BUILDER.call(SqlStdOperatorTable.CASE,\n        REL_BUILDER.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        REL_BUILDER.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        REL_BUILDER.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        REL_BUILDER.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        REL_BUILDER.call(SqlStdOperatorTable.EQUALS, leftKeyInputRef, rightKeyInputRef));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        REL_BUILDER.literal(true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/RelOptUtilTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":221,"status":"B"}],"commitId":"c25b29c0c1cae3a57bf91ddfd9f6a0622ca974a4","commitMessage":"@@@[CALCITE-2803] ProjectTransposeJoinRule messes INDF expressions\n\nProjectTransposeJoinRule does not identify expanded versions of IS NOT\nDISTINCT FROM expressions in the join filter.  and might push them below\nthe join operator in a way which makes impossible for\nRelOptUtil#splitJoinCondition() to identify the INDF condition and mis-\ncategorize the join as not being an equi-join.\n\nFix the issue by collapsing INDF expressions before invoking PushProjector.\nAlso add support for expanded form CASE(WHEN A IS NULL THEN B IS NULL\nWHEN B IS NULL THEN A IS NULL ELSE A = B).\n","date":"2019-05-14 04:17:07","modifiedFileCount":"4","status":"M","submitter":"Laurent Goujon"},{"authorTime":"2019-01-25 07:35:43","codes":[{"authorDate":"2019-01-25 07:35:43","commitOrder":3,"curCode":"  @Test public void testSplitJoinConditionExpandedIsNotDistinctFrom() {\n    int leftJoinIndex = EMP_SCAN.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = DEPT_ROW.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(EMP_ROW.getFieldCount() + rightJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.OR,\n        relBuilder.call(SqlStdOperatorTable.EQUALS, leftKeyInputRef, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.AND,\n            relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n            relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef)));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        relBuilder.literal(true));\n  }\n","date":"2019-05-23 01:23:56","endLine":206,"groupId":"16492","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testSplitJoinConditionExpandedIsNotDistinctFrom","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/a7/2df310ff3d69fa9b24ccfe79a88ceb35fbf4cd.src","preCode":"  @Test public void testSplitJoinConditionExpandedIsNotDistinctFrom() {\n    int leftJoinIndex = EMP_SCAN.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = DEPT_ROW.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(EMP_ROW.getFieldCount() + rightJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexNode joinCond = REL_BUILDER.call(SqlStdOperatorTable.OR,\n        REL_BUILDER.call(SqlStdOperatorTable.EQUALS, leftKeyInputRef, rightKeyInputRef),\n        REL_BUILDER.call(SqlStdOperatorTable.AND,\n            REL_BUILDER.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n            REL_BUILDER.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef)));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        REL_BUILDER.literal(true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/RelOptUtilTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":187,"status":"M"},{"authorDate":"2019-01-25 07:35:43","commitOrder":3,"curCode":"  @Test public void testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2() {\n    int leftJoinIndex = EMP_SCAN.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = DEPT_ROW.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(EMP_ROW.getFieldCount() + rightJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.CASE,\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.EQUALS, leftKeyInputRef, rightKeyInputRef));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        relBuilder.literal(true));\n  }\n","date":"2019-05-23 01:23:56","endLine":258,"groupId":"622","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/a7/2df310ff3d69fa9b24ccfe79a88ceb35fbf4cd.src","preCode":"  @Test public void testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2() {\n    int leftJoinIndex = EMP_SCAN.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = DEPT_ROW.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(EMP_ROW.getFieldCount() + rightJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexNode joinCond = REL_BUILDER.call(SqlStdOperatorTable.CASE,\n        REL_BUILDER.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        REL_BUILDER.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        REL_BUILDER.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        REL_BUILDER.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        REL_BUILDER.call(SqlStdOperatorTable.EQUALS, leftKeyInputRef, rightKeyInputRef));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        REL_BUILDER.literal(true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/RelOptUtilTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":238,"status":"M"}],"commitId":"82e7d4e760cb203d31956c55e38e0fdd56119d58","commitMessage":"@@@[CALCITE-2807] Fix `IS NOT DISTINCT FROM` expression identification in RelOptUtil#pushDownJoinConditions()\n\nRelOptUtil#pushDownJoinConditions do not identify and preserve\nexpanded versions of `IS NOT DISTINCT FROM` expressions.  causing\nequi-joins to be miscategorized as inequality joins.\n\nModify the function to try to collapse the expression back to a\ncanonical `IS NOT DISTINCT FROM` expression if possible before\nvisiting the expression and pushing it below the join.\n","date":"2019-05-23 01:23:56","modifiedFileCount":"4","status":"M","submitter":"Laurent Goujon"},{"authorTime":"2019-05-30 05:04:46","codes":[{"authorDate":"2019-05-30 05:04:46","commitOrder":4,"curCode":"  @Test public void testSplitJoinConditionExpandedIsNotDistinctFrom() {\n    int leftJoinIndex = empScan.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = deptRow.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, empDeptJoinRelFields);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(empRow.getFieldCount() + rightJoinIndex, empDeptJoinRelFields);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.OR,\n        relBuilder.call(SqlStdOperatorTable.EQUALS, leftKeyInputRef, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.AND,\n            relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n            relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef)));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        relBuilder.literal(true));\n  }\n","date":"2019-05-30 08:16:45","endLine":209,"groupId":"16492","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testSplitJoinConditionExpandedIsNotDistinctFrom","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/a2/84e101e07e1d680143f9cedfa4521cf69fa6c2.src","preCode":"  @Test public void testSplitJoinConditionExpandedIsNotDistinctFrom() {\n    int leftJoinIndex = EMP_SCAN.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = DEPT_ROW.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(EMP_ROW.getFieldCount() + rightJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.OR,\n        relBuilder.call(SqlStdOperatorTable.EQUALS, leftKeyInputRef, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.AND,\n            relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n            relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef)));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        relBuilder.literal(true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/RelOptUtilTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":190,"status":"M"},{"authorDate":"2019-05-30 05:04:46","commitOrder":4,"curCode":"  @Test public void testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2() {\n    int leftJoinIndex = empScan.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = deptRow.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, empDeptJoinRelFields);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(empRow.getFieldCount() + rightJoinIndex, empDeptJoinRelFields);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.CASE,\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.EQUALS, leftKeyInputRef, rightKeyInputRef));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        relBuilder.literal(true));\n  }\n","date":"2019-05-30 08:16:45","endLine":261,"groupId":"622","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/a2/84e101e07e1d680143f9cedfa4521cf69fa6c2.src","preCode":"  @Test public void testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2() {\n    int leftJoinIndex = EMP_SCAN.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = DEPT_ROW.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(EMP_ROW.getFieldCount() + rightJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.CASE,\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.EQUALS, leftKeyInputRef, rightKeyInputRef));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        relBuilder.literal(true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/RelOptUtilTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":241,"status":"M"}],"commitId":"00f8b5f5ca1d45ce5029a474c42e674bec31634f","commitMessage":"@@@RelOptUtilTest concurrency fixup\n\nRelOptUtilTest was creating a static RelOptCluster which could be used\nduring tests running in parallel to acces the associated RelMetadataQuery\ninstance.  Alas the object is not safe to access from multiple threads\nand in some occasions tests would fail with CyclicMetadataException.\n\nFixing the test class by creating a new RelOptCluster/RelBuilder\ninstance for each test.  and removing the static instances.\n","date":"2019-05-30 08:16:45","modifiedFileCount":"1","status":"M","submitter":"Laurent Goujon"},{"authorTime":"2020-04-02 10:39:10","codes":[{"authorDate":"2020-04-02 10:39:10","commitOrder":5,"curCode":"  @Test void testSplitJoinConditionExpandedIsNotDistinctFrom() {\n    int leftJoinIndex = empScan.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = deptRow.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, empDeptJoinRelFields);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(empRow.getFieldCount() + rightJoinIndex, empDeptJoinRelFields);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.OR,\n        relBuilder.call(SqlStdOperatorTable.EQUALS, leftKeyInputRef, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.AND,\n            relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n            relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef)));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        relBuilder.literal(true));\n  }\n","date":"2020-04-06 04:57:49","endLine":283,"groupId":"16492","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testSplitJoinConditionExpandedIsNotDistinctFrom","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/d5/67ce1b0e03643d2f43cda079b7e52f3be701d2.src","preCode":"  @Test public void testSplitJoinConditionExpandedIsNotDistinctFrom() {\n    int leftJoinIndex = empScan.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = deptRow.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, empDeptJoinRelFields);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(empRow.getFieldCount() + rightJoinIndex, empDeptJoinRelFields);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.OR,\n        relBuilder.call(SqlStdOperatorTable.EQUALS, leftKeyInputRef, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.AND,\n            relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n            relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef)));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        relBuilder.literal(true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/RelOptUtilTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":264,"status":"M"},{"authorDate":"2020-04-02 10:39:10","commitOrder":5,"curCode":"  @Test void testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2() {\n    int leftJoinIndex = empScan.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = deptRow.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, empDeptJoinRelFields);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(empRow.getFieldCount() + rightJoinIndex, empDeptJoinRelFields);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.CASE,\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.EQUALS, leftKeyInputRef, rightKeyInputRef));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        relBuilder.literal(true));\n  }\n","date":"2020-04-06 04:57:49","endLine":335,"groupId":"622","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/d5/67ce1b0e03643d2f43cda079b7e52f3be701d2.src","preCode":"  @Test public void testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2() {\n    int leftJoinIndex = empScan.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = deptRow.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, empDeptJoinRelFields);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(empRow.getFieldCount() + rightJoinIndex, empDeptJoinRelFields);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.CASE,\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.EQUALS, leftKeyInputRef, rightKeyInputRef));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        relBuilder.literal(true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/RelOptUtilTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":315,"status":"M"}],"commitId":"9492dd4146f63ddc028010d6c4e86f6a5cb29a8d","commitMessage":"@@@[CALCITE-3892] Make junit test classes and methods non-public where possible\n\nPrior to junit 5.  classes and methods had to be public. This is no\nlonger the case.\n\nSome classes need to remain public because they are referenced from\nelsewhere.  or if they use reflection somehow. The remaining 'public'\nkeyword will be informative to maintainers.\n","date":"2020-04-06 04:57:49","modifiedFileCount":"196","status":"M","submitter":"Julian Hyde"},{"authorTime":"2021-09-17 17:38:52","codes":[{"authorDate":"2021-09-17 17:38:52","commitOrder":6,"curCode":"  @Test void testSplitJoinConditionExpandedIsNotDistinctFrom() {\n    int leftJoinIndex = empScan.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = deptRow.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, empDeptJoinRelFields);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(empRow.getFieldCount() + rightJoinIndex, empDeptJoinRelFields);\n    RexNode joinCond = relBuilder.or(\n        relBuilder.equals(leftKeyInputRef, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.AND,\n            relBuilder.isNull(leftKeyInputRef),\n            relBuilder.isNull(rightKeyInputRef)));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        relBuilder.literal(true));\n  }\n","date":"2021-09-18 03:08:56","endLine":331,"groupId":"101459","id":9,"instanceNumber":1,"isCurCommit":1,"methodName":"testSplitJoinConditionExpandedIsNotDistinctFrom","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/ce/571c33cf435d0922678e9dbf8e75006b71d838.src","preCode":"  @Test void testSplitJoinConditionExpandedIsNotDistinctFrom() {\n    int leftJoinIndex = empScan.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = deptRow.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, empDeptJoinRelFields);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(empRow.getFieldCount() + rightJoinIndex, empDeptJoinRelFields);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.OR,\n        relBuilder.call(SqlStdOperatorTable.EQUALS, leftKeyInputRef, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.AND,\n            relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n            relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef)));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        relBuilder.literal(true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/RelOptUtilTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":312,"status":"M"},{"authorDate":"2021-09-17 17:38:52","commitOrder":6,"curCode":"  @Test void testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2() {\n    int leftJoinIndex = empScan.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = deptRow.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, empDeptJoinRelFields);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(empRow.getFieldCount() + rightJoinIndex, empDeptJoinRelFields);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.CASE,\n        relBuilder.isNull(leftKeyInputRef),\n        relBuilder.isNull(rightKeyInputRef),\n        relBuilder.isNull(rightKeyInputRef),\n        relBuilder.isNull(leftKeyInputRef),\n        relBuilder.equals(leftKeyInputRef, rightKeyInputRef));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        relBuilder.literal(true));\n  }\n","date":"2021-09-18 03:08:56","endLine":385,"groupId":"101459","id":10,"instanceNumber":2,"isCurCommit":1,"methodName":"testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/ce/571c33cf435d0922678e9dbf8e75006b71d838.src","preCode":"  @Test void testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2() {\n    int leftJoinIndex = empScan.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = deptRow.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, empDeptJoinRelFields);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(empRow.getFieldCount() + rightJoinIndex, empDeptJoinRelFields);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.CASE,\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.EQUALS, leftKeyInputRef, rightKeyInputRef));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        relBuilder.literal(true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/RelOptUtilTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":365,"status":"M"}],"commitId":"4d82c5346292b32a1301214376366c2e8c5a892e","commitMessage":"@@@Add RelBuilder.lessThan.  and use RelBuilder shorthands\n","date":"2021-09-18 03:08:56","modifiedFileCount":"9","status":"M","submitter":"Julian Hyde"}]
