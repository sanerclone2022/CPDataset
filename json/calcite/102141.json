[{"authorTime":"2019-04-12 15:11:30","codes":[{"authorDate":"2019-04-12 15:11:30","commitOrder":1,"curCode":"  @Override public RelOptCost computeSelfCost(RelOptPlanner planner,\n      RelMetadataQuery mq) {\n    double rowCount = mq.getRowCount(this);\n\n    if (!isSemiJoin()) {\n      \r\n      \r\n      \r\n      switch (joinType) {\n      case RIGHT:\n        rowCount = RelMdUtil.addEpsilon(rowCount);\n        break;\n      default:\n        if (RelNodes.COMPARATOR.compare(left, right) > 0) {\n          rowCount = RelMdUtil.addEpsilon(rowCount);\n        }\n      }\n    }\n\n    \r\n    \r\n    final double rightRowCount = right.estimateRowCount(mq);\n    final double leftRowCount = left.estimateRowCount(mq);\n    if (Double.isInfinite(leftRowCount)) {\n      rowCount = leftRowCount;\n    } else {\n      rowCount += Util.nLogN(leftRowCount);\n    }\n    if (Double.isInfinite(rightRowCount)) {\n      rowCount = rightRowCount;\n    } else {\n      rowCount += rightRowCount;\n    }\n    if (isSemiJoin()) {\n      return planner.getCostFactory().makeCost(rowCount, 0, 0).multiplyBy(.01d);\n    } else {\n      return planner.getCostFactory().makeCost(rowCount, 0, 0);\n    }\n  }\n","date":"2019-05-30 11:27:53","endLine":147,"groupId":"3929","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"computeSelfCost","params":"(RelOptPlannerplanner@RelMetadataQuerymq)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/be/dbbeb3d759d705f5a079c895bd41879ada57d3.src","preCode":"  @Override public RelOptCost computeSelfCost(RelOptPlanner planner,\n      RelMetadataQuery mq) {\n    double rowCount = mq.getRowCount(this);\n\n    if (!isSemiJoin()) {\n      \r\n      \r\n      \r\n      switch (joinType) {\n      case RIGHT:\n        rowCount = RelMdUtil.addEpsilon(rowCount);\n        break;\n      default:\n        if (RelNodes.COMPARATOR.compare(left, right) > 0) {\n          rowCount = RelMdUtil.addEpsilon(rowCount);\n        }\n      }\n    }\n\n    \r\n    \r\n    final double rightRowCount = right.estimateRowCount(mq);\n    final double leftRowCount = left.estimateRowCount(mq);\n    if (Double.isInfinite(leftRowCount)) {\n      rowCount = leftRowCount;\n    } else {\n      rowCount += Util.nLogN(leftRowCount);\n    }\n    if (Double.isInfinite(rightRowCount)) {\n      rowCount = rightRowCount;\n    } else {\n      rowCount += rightRowCount;\n    }\n    if (isSemiJoin()) {\n      return planner.getCostFactory().makeCost(rowCount, 0, 0).multiplyBy(.01d);\n    } else {\n      return planner.getCostFactory().makeCost(rowCount, 0, 0);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableHashJoin.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":109,"status":"B"},{"authorDate":"2019-04-12 15:11:30","commitOrder":1,"curCode":"  @Override public RelOptCost computeSelfCost(RelOptPlanner planner,\n      RelMetadataQuery mq) {\n    double rowCount = mq.getRowCount(this);\n\n    \r\n    \r\n    \r\n    switch (joinType) {\n    case RIGHT:\n      rowCount = RelMdUtil.addEpsilon(rowCount);\n      break;\n    default:\n      if (left.getId() > right.getId()) {\n        rowCount = RelMdUtil.addEpsilon(rowCount);\n      }\n    }\n\n    final double rightRowCount = right.estimateRowCount(mq);\n    final double leftRowCount = left.estimateRowCount(mq);\n    if (Double.isInfinite(leftRowCount)) {\n      rowCount = leftRowCount;\n    }\n    if (Double.isInfinite(rightRowCount)) {\n      rowCount = rightRowCount;\n    }\n    return planner.getCostFactory().makeCost(rowCount, 0, 0);\n  }\n","date":"2019-05-30 11:27:53","endLine":122,"groupId":"9590","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"computeSelfCost","params":"(RelOptPlannerplanner@RelMetadataQuerymq)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/c7/37cac6fad979f9d0515536a9657a5936e2fccc.src","preCode":"  @Override public RelOptCost computeSelfCost(RelOptPlanner planner,\n      RelMetadataQuery mq) {\n    double rowCount = mq.getRowCount(this);\n\n    \r\n    \r\n    \r\n    switch (joinType) {\n    case RIGHT:\n      rowCount = RelMdUtil.addEpsilon(rowCount);\n      break;\n    default:\n      if (left.getId() > right.getId()) {\n        rowCount = RelMdUtil.addEpsilon(rowCount);\n      }\n    }\n\n    final double rightRowCount = right.estimateRowCount(mq);\n    final double leftRowCount = left.estimateRowCount(mq);\n    if (Double.isInfinite(leftRowCount)) {\n      rowCount = leftRowCount;\n    }\n    if (Double.isInfinite(rightRowCount)) {\n      rowCount = rightRowCount;\n    }\n    return planner.getCostFactory().makeCost(rowCount, 0, 0);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableNestedLoopJoin.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":96,"status":"B"}],"commitId":"48093937ae4db179884d1111fa9d12e978e57e1f","commitMessage":"@@@[CALCITE-2696] Improve design of join-like relational expressions\n\n**Diff**\n- Deprecate SemiJoin.  EnumerableSemiJoin.  SemiJoinType. \nEnumerableSemiJoinRule.  JoinToCorrelateRule#SEMI\n- Add SEMI and ANTI join type to JoinRelType.  add method\nprojectsRight() and isOuterJoin()\n- Correlate use JoinRelType instead of SemiJoinType\n- Rename EnumerableThetaJoin to EnumerableNestedLoopJoin\n- Rename EnumerableJoin to EnumerableHashJoin\n- EnumerableJoinRule converts semi join to EnumerableHashJoin\n(EnumerableSemiJoin's functionality is merged into this rule)\n- Add method isSemiJoin() in Join.java to decide if this join is a semi join\n(comes from SemiJoinRule during decorrelateation). \nthe return value true means the join is a semi join equivalent to\nSemiJoin before this patch.\n- Cache the JoinInfo in Join and use it to get leftKeys and rightKeys. \nmerge SemiJoin#computeSelfCost logic into Join#computeSelfCost\n- For RelBuilder.  removes SemiJoinFactory.  method #semiJoin\nnow returns a LogicalJoin with JoinRelType#SEMI\n- Rename EnumerableDefaults#join to EnumerableDefaults#hashJoin\n- Rename EnumerableDefaults#thetaJoin to EnumerableDefaults#nestedLoopJoin\n\n**Rules tweak**\n- JoinAddRedundantSemiJoinRule now creates LogicalJoin with JoinRelType#SEMI\ninstead of SemiJoin\n- JoinToCorrelateRule deprecates SEMI instance and change the matches\ncondition to !join.getJoinType().generatesNullsOnLeft() which also\nallowed ANTI compared before this patch.\n- SemiJoinRule matches SEMI join specifically.\n\n**Metadata tweak**\n- RelMdAllPredicates.  RelMdExpressionLineage: Add full rowType to\ngetAllPredicates(Join) cause semi join only outputs one side\n- RelMdColumnUniqueness.  RelMdSelectivity.  RelMdDistinctRowCount. \nRelMdSize.  RelMdUniqueKeys: merge semi join logic to join\n\n**Test cases change**\n- MaterializationTest#testJoinMaterialization11 now can materialize\nsuccessfully.  cause i allow logical SemiJoin node to match.  the original\nmatches SemiJoin as SemiJoin.class.isAssignableFrom().  which i think is\nwrong cause this will only matches subClasses of SemiJoin which is only\nEnumerableSemiJoin before this patch.\n- SortRemoveRuleTest#removeSortOverEnumerableCorrelate.  because\nCALCITE-2018.  the final EnumerableSort's cost was cached by the previous\nEnumerableSort with logical children.  so i remove the EnumerableSortRule\nand the best plan is correct\n\nclose apache/calcite#1157\n","date":"2019-05-30 11:27:53","modifiedFileCount":"81","status":"B","submitter":"yuzhao.cyz"},{"authorTime":"2019-04-12 15:11:30","codes":[{"authorDate":"2019-06-01 00:16:42","commitOrder":2,"curCode":"  @Override public RelOptCost computeSelfCost(RelOptPlanner planner,\n      RelMetadataQuery mq) {\n    double rowCount = mq.getRowCount(this);\n\n    \r\n    \r\n    \r\n    switch (joinType) {\n    case SEMI:\n    case ANTI:\n      \r\n      break;\n    case RIGHT:\n      rowCount = RelMdUtil.addEpsilon(rowCount);\n      break;\n    default:\n      if (RelNodes.COMPARATOR.compare(left, right) > 0) {\n        rowCount = RelMdUtil.addEpsilon(rowCount);\n      }\n    }\n\n    \r\n    \r\n    final double rightRowCount = right.estimateRowCount(mq);\n    final double leftRowCount = left.estimateRowCount(mq);\n    if (Double.isInfinite(leftRowCount)) {\n      rowCount = leftRowCount;\n    } else {\n      rowCount += Util.nLogN(leftRowCount);\n    }\n    if (Double.isInfinite(rightRowCount)) {\n      rowCount = rightRowCount;\n    } else {\n      rowCount += rightRowCount;\n    }\n    if (isSemiJoin()) {\n      return planner.getCostFactory().makeCost(rowCount, 0, 0).multiplyBy(.01d);\n    } else {\n      return planner.getCostFactory().makeCost(rowCount, 0, 0);\n    }\n  }\n","date":"2019-06-07 22:58:45","endLine":150,"groupId":"3929","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"computeSelfCost","params":"(RelOptPlannerplanner@RelMetadataQuerymq)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/ec/0264a08424589d3bcf65ee63de7a428859351c.src","preCode":"  @Override public RelOptCost computeSelfCost(RelOptPlanner planner,\n      RelMetadataQuery mq) {\n    double rowCount = mq.getRowCount(this);\n\n    if (!isSemiJoin()) {\n      \r\n      \r\n      \r\n      switch (joinType) {\n      case RIGHT:\n        rowCount = RelMdUtil.addEpsilon(rowCount);\n        break;\n      default:\n        if (RelNodes.COMPARATOR.compare(left, right) > 0) {\n          rowCount = RelMdUtil.addEpsilon(rowCount);\n        }\n      }\n    }\n\n    \r\n    \r\n    final double rightRowCount = right.estimateRowCount(mq);\n    final double leftRowCount = left.estimateRowCount(mq);\n    if (Double.isInfinite(leftRowCount)) {\n      rowCount = leftRowCount;\n    } else {\n      rowCount += Util.nLogN(leftRowCount);\n    }\n    if (Double.isInfinite(rightRowCount)) {\n      rowCount = rightRowCount;\n    } else {\n      rowCount += rightRowCount;\n    }\n    if (isSemiJoin()) {\n      return planner.getCostFactory().makeCost(rowCount, 0, 0).multiplyBy(.01d);\n    } else {\n      return planner.getCostFactory().makeCost(rowCount, 0, 0);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableHashJoin.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":110,"status":"M"},{"authorDate":"2019-04-12 15:11:30","commitOrder":2,"curCode":"  @Override public RelOptCost computeSelfCost(RelOptPlanner planner,\n      RelMetadataQuery mq) {\n    double rowCount = mq.getRowCount(this);\n\n    \r\n    \r\n    \r\n    switch (joinType) {\n    case RIGHT:\n      rowCount = RelMdUtil.addEpsilon(rowCount);\n      break;\n    default:\n      if (left.getId() > right.getId()) {\n        rowCount = RelMdUtil.addEpsilon(rowCount);\n      }\n    }\n\n    final double rightRowCount = right.estimateRowCount(mq);\n    final double leftRowCount = left.estimateRowCount(mq);\n    if (Double.isInfinite(leftRowCount)) {\n      rowCount = leftRowCount;\n    }\n    if (Double.isInfinite(rightRowCount)) {\n      rowCount = rightRowCount;\n    }\n    return planner.getCostFactory().makeCost(rowCount, 0, 0);\n  }\n","date":"2019-05-30 11:27:53","endLine":122,"groupId":"9590","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"computeSelfCost","params":"(RelOptPlannerplanner@RelMetadataQuerymq)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/c7/37cac6fad979f9d0515536a9657a5936e2fccc.src","preCode":"  @Override public RelOptCost computeSelfCost(RelOptPlanner planner,\n      RelMetadataQuery mq) {\n    double rowCount = mq.getRowCount(this);\n\n    \r\n    \r\n    \r\n    switch (joinType) {\n    case RIGHT:\n      rowCount = RelMdUtil.addEpsilon(rowCount);\n      break;\n    default:\n      if (left.getId() > right.getId()) {\n        rowCount = RelMdUtil.addEpsilon(rowCount);\n      }\n    }\n\n    final double rightRowCount = right.estimateRowCount(mq);\n    final double leftRowCount = left.estimateRowCount(mq);\n    if (Double.isInfinite(leftRowCount)) {\n      rowCount = leftRowCount;\n    }\n    if (Double.isInfinite(rightRowCount)) {\n      rowCount = rightRowCount;\n    }\n    return planner.getCostFactory().makeCost(rowCount, 0, 0);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableNestedLoopJoin.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":96,"status":"N"}],"commitId":"be2b97905548a5b24067c8636567b364529332cc","commitMessage":"@@@[CALCITE-2968] New AntiJoin relational expression\n\nClose apache/calcite#1246\n","date":"2019-06-07 22:58:45","modifiedFileCount":"16","status":"M","submitter":"rubenada"},{"authorTime":"2019-11-27 16:39:35","codes":[{"authorDate":"2019-06-01 00:16:42","commitOrder":3,"curCode":"  @Override public RelOptCost computeSelfCost(RelOptPlanner planner,\n      RelMetadataQuery mq) {\n    double rowCount = mq.getRowCount(this);\n\n    \r\n    \r\n    \r\n    switch (joinType) {\n    case SEMI:\n    case ANTI:\n      \r\n      break;\n    case RIGHT:\n      rowCount = RelMdUtil.addEpsilon(rowCount);\n      break;\n    default:\n      if (RelNodes.COMPARATOR.compare(left, right) > 0) {\n        rowCount = RelMdUtil.addEpsilon(rowCount);\n      }\n    }\n\n    \r\n    \r\n    final double rightRowCount = right.estimateRowCount(mq);\n    final double leftRowCount = left.estimateRowCount(mq);\n    if (Double.isInfinite(leftRowCount)) {\n      rowCount = leftRowCount;\n    } else {\n      rowCount += Util.nLogN(leftRowCount);\n    }\n    if (Double.isInfinite(rightRowCount)) {\n      rowCount = rightRowCount;\n    } else {\n      rowCount += rightRowCount;\n    }\n    if (isSemiJoin()) {\n      return planner.getCostFactory().makeCost(rowCount, 0, 0).multiplyBy(.01d);\n    } else {\n      return planner.getCostFactory().makeCost(rowCount, 0, 0);\n    }\n  }\n","date":"2019-06-07 22:58:45","endLine":150,"groupId":"3929","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"computeSelfCost","params":"(RelOptPlannerplanner@RelMetadataQuerymq)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/ec/0264a08424589d3bcf65ee63de7a428859351c.src","preCode":"  @Override public RelOptCost computeSelfCost(RelOptPlanner planner,\n      RelMetadataQuery mq) {\n    double rowCount = mq.getRowCount(this);\n\n    \r\n    \r\n    \r\n    switch (joinType) {\n    case SEMI:\n    case ANTI:\n      \r\n      break;\n    case RIGHT:\n      rowCount = RelMdUtil.addEpsilon(rowCount);\n      break;\n    default:\n      if (RelNodes.COMPARATOR.compare(left, right) > 0) {\n        rowCount = RelMdUtil.addEpsilon(rowCount);\n      }\n    }\n\n    \r\n    \r\n    final double rightRowCount = right.estimateRowCount(mq);\n    final double leftRowCount = left.estimateRowCount(mq);\n    if (Double.isInfinite(leftRowCount)) {\n      rowCount = leftRowCount;\n    } else {\n      rowCount += Util.nLogN(leftRowCount);\n    }\n    if (Double.isInfinite(rightRowCount)) {\n      rowCount = rightRowCount;\n    } else {\n      rowCount += rightRowCount;\n    }\n    if (isSemiJoin()) {\n      return planner.getCostFactory().makeCost(rowCount, 0, 0).multiplyBy(.01d);\n    } else {\n      return planner.getCostFactory().makeCost(rowCount, 0, 0);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableHashJoin.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":110,"status":"N"},{"authorDate":"2019-11-27 16:39:35","commitOrder":3,"curCode":"  @Override public RelOptCost computeSelfCost(RelOptPlanner planner,\n      RelMetadataQuery mq) {\n    double rowCount = mq.getRowCount(this);\n\n    \r\n    \r\n    \r\n    switch (joinType) {\n    case SEMI:\n    case ANTI:\n      \r\n      break;\n    case RIGHT:\n      rowCount = RelMdUtil.addEpsilon(rowCount);\n      break;\n    default:\n      if (RelNodes.COMPARATOR.compare(left, right) > 0) {\n        rowCount = RelMdUtil.addEpsilon(rowCount);\n      }\n    }\n\n    final double rightRowCount = right.estimateRowCount(mq);\n    final double leftRowCount = left.estimateRowCount(mq);\n    if (Double.isInfinite(leftRowCount)) {\n      rowCount = leftRowCount;\n    }\n    if (Double.isInfinite(rightRowCount)) {\n      rowCount = rightRowCount;\n    }\n    return planner.getCostFactory().makeCost(rowCount, 0, 0);\n  }\n","date":"2019-11-28 23:46:31","endLine":115,"groupId":"3929","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"computeSelfCost","params":"(RelOptPlannerplanner@RelMetadataQuerymq)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/4f/1968c4dc771113b47e3aeeb4224c8a085c7af2.src","preCode":"  @Override public RelOptCost computeSelfCost(RelOptPlanner planner,\n      RelMetadataQuery mq) {\n    double rowCount = mq.getRowCount(this);\n\n    \r\n    \r\n    \r\n    switch (joinType) {\n    case RIGHT:\n      rowCount = RelMdUtil.addEpsilon(rowCount);\n      break;\n    default:\n      if (left.getId() > right.getId()) {\n        rowCount = RelMdUtil.addEpsilon(rowCount);\n      }\n    }\n\n    final double rightRowCount = right.estimateRowCount(mq);\n    final double leftRowCount = left.estimateRowCount(mq);\n    if (Double.isInfinite(leftRowCount)) {\n      rowCount = leftRowCount;\n    }\n    if (Double.isInfinite(rightRowCount)) {\n      rowCount = rightRowCount;\n    }\n    return planner.getCostFactory().makeCost(rowCount, 0, 0);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableNestedLoopJoin.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"M"}],"commitId":"ca27fe99b5d1367c2d7ceb20a02ad80c6a2fce63","commitMessage":"@@@[CALCITE-3539] EnumerableDefaults#nestedLoopJoin returns duplicates for JoinType.SEMI\n","date":"2019-11-28 23:46:31","modifiedFileCount":"3","status":"M","submitter":"rubenada"},{"authorTime":"2019-12-16 09:31:00","codes":[{"authorDate":"2019-06-01 00:16:42","commitOrder":4,"curCode":"  @Override public RelOptCost computeSelfCost(RelOptPlanner planner,\n      RelMetadataQuery mq) {\n    double rowCount = mq.getRowCount(this);\n\n    \r\n    \r\n    \r\n    switch (joinType) {\n    case SEMI:\n    case ANTI:\n      \r\n      break;\n    case RIGHT:\n      rowCount = RelMdUtil.addEpsilon(rowCount);\n      break;\n    default:\n      if (RelNodes.COMPARATOR.compare(left, right) > 0) {\n        rowCount = RelMdUtil.addEpsilon(rowCount);\n      }\n    }\n\n    \r\n    \r\n    final double rightRowCount = right.estimateRowCount(mq);\n    final double leftRowCount = left.estimateRowCount(mq);\n    if (Double.isInfinite(leftRowCount)) {\n      rowCount = leftRowCount;\n    } else {\n      rowCount += Util.nLogN(leftRowCount);\n    }\n    if (Double.isInfinite(rightRowCount)) {\n      rowCount = rightRowCount;\n    } else {\n      rowCount += rightRowCount;\n    }\n    if (isSemiJoin()) {\n      return planner.getCostFactory().makeCost(rowCount, 0, 0).multiplyBy(.01d);\n    } else {\n      return planner.getCostFactory().makeCost(rowCount, 0, 0);\n    }\n  }\n","date":"2019-06-07 22:58:45","endLine":150,"groupId":"3929","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"computeSelfCost","params":"(RelOptPlannerplanner@RelMetadataQuerymq)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/ec/0264a08424589d3bcf65ee63de7a428859351c.src","preCode":"  @Override public RelOptCost computeSelfCost(RelOptPlanner planner,\n      RelMetadataQuery mq) {\n    double rowCount = mq.getRowCount(this);\n\n    \r\n    \r\n    \r\n    switch (joinType) {\n    case SEMI:\n    case ANTI:\n      \r\n      break;\n    case RIGHT:\n      rowCount = RelMdUtil.addEpsilon(rowCount);\n      break;\n    default:\n      if (RelNodes.COMPARATOR.compare(left, right) > 0) {\n        rowCount = RelMdUtil.addEpsilon(rowCount);\n      }\n    }\n\n    \r\n    \r\n    final double rightRowCount = right.estimateRowCount(mq);\n    final double leftRowCount = left.estimateRowCount(mq);\n    if (Double.isInfinite(leftRowCount)) {\n      rowCount = leftRowCount;\n    } else {\n      rowCount += Util.nLogN(leftRowCount);\n    }\n    if (Double.isInfinite(rightRowCount)) {\n      rowCount = rightRowCount;\n    } else {\n      rowCount += rightRowCount;\n    }\n    if (isSemiJoin()) {\n      return planner.getCostFactory().makeCost(rowCount, 0, 0).multiplyBy(.01d);\n    } else {\n      return planner.getCostFactory().makeCost(rowCount, 0, 0);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableHashJoin.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":110,"status":"N"},{"authorDate":"2019-12-16 09:31:00","commitOrder":4,"curCode":"  @Override public RelOptCost computeSelfCost(RelOptPlanner planner,\n      RelMetadataQuery mq) {\n    double rowCount = mq.getRowCount(this);\n\n    \r\n    \r\n    \r\n    switch (joinType) {\n    case SEMI:\n    case ANTI:\n      \r\n      break;\n    case RIGHT:\n      rowCount = RelMdUtil.addEpsilon(rowCount);\n      break;\n    default:\n      if (RelNodes.COMPARATOR.compare(left, right) > 0) {\n        rowCount = RelMdUtil.addEpsilon(rowCount);\n      }\n    }\n\n    final double rightRowCount = right.estimateRowCount(mq);\n    final double leftRowCount = left.estimateRowCount(mq);\n    if (Double.isInfinite(leftRowCount)) {\n      rowCount = leftRowCount;\n    }\n    if (Double.isInfinite(rightRowCount)) {\n      rowCount = rightRowCount;\n    }\n\n    RelOptCost cost = planner.getCostFactory().makeCost(rowCount, 0, 0);\n    \r\n    cost = cost.multiplyBy(10);\n    return cost;\n  }\n","date":"2020-04-14 09:18:11","endLine":119,"groupId":"3929","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"computeSelfCost","params":"(RelOptPlannerplanner@RelMetadataQuerymq)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/5b/925b15788ddd115e5a47b4c383987e27566842.src","preCode":"  @Override public RelOptCost computeSelfCost(RelOptPlanner planner,\n      RelMetadataQuery mq) {\n    double rowCount = mq.getRowCount(this);\n\n    \r\n    \r\n    \r\n    switch (joinType) {\n    case SEMI:\n    case ANTI:\n      \r\n      break;\n    case RIGHT:\n      rowCount = RelMdUtil.addEpsilon(rowCount);\n      break;\n    default:\n      if (RelNodes.COMPARATOR.compare(left, right) > 0) {\n        rowCount = RelMdUtil.addEpsilon(rowCount);\n      }\n    }\n\n    final double rightRowCount = right.estimateRowCount(mq);\n    final double leftRowCount = left.estimateRowCount(mq);\n    if (Double.isInfinite(leftRowCount)) {\n      rowCount = leftRowCount;\n    }\n    if (Double.isInfinite(rightRowCount)) {\n      rowCount = rightRowCount;\n    }\n    return planner.getCostFactory().makeCost(rowCount, 0, 0);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableNestedLoopJoin.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"M"}],"commitId":"147b7a52ee5c3231adf8382989b3702222c20024","commitMessage":"@@@[CALCITE-3576] Remove enumerable convention check in FilterIntoJoinRule\n\nAlso tuned nestedloop join cost model to give it some penalty to favor\nnon-nestedloop joins.\n\nClose #1889\n","date":"2020-04-14 09:18:11","modifiedFileCount":"3","status":"M","submitter":"Haisheng Yuan"},{"authorTime":"2020-05-29 00:04:40","codes":[{"authorDate":"2020-05-29 00:04:40","commitOrder":5,"curCode":"  @Override public @Nullable RelOptCost computeSelfCost(RelOptPlanner planner,\n      RelMetadataQuery mq) {\n    double rowCount = mq.getRowCount(this);\n\n    \r\n    \r\n    \r\n    switch (joinType) {\n    case SEMI:\n    case ANTI:\n      \r\n      break;\n    case RIGHT:\n      rowCount = RelMdUtil.addEpsilon(rowCount);\n      break;\n    default:\n      if (RelNodes.COMPARATOR.compare(left, right) > 0) {\n        rowCount = RelMdUtil.addEpsilon(rowCount);\n      }\n    }\n\n    \r\n    \r\n    final double rightRowCount = right.estimateRowCount(mq);\n    final double leftRowCount = left.estimateRowCount(mq);\n    if (Double.isInfinite(leftRowCount)) {\n      rowCount = leftRowCount;\n    } else {\n      rowCount += Util.nLogN(leftRowCount);\n    }\n    if (Double.isInfinite(rightRowCount)) {\n      rowCount = rightRowCount;\n    } else {\n      rowCount += rightRowCount;\n    }\n    if (isSemiJoin()) {\n      return planner.getCostFactory().makeCost(rowCount, 0, 0).multiplyBy(.01d);\n    } else {\n      return planner.getCostFactory().makeCost(rowCount, 0, 0);\n    }\n  }\n","date":"2020-11-30 06:45:33","endLine":169,"groupId":"102141","id":9,"instanceNumber":1,"isCurCommit":1,"methodName":"computeSelfCost","params":"(RelOptPlannerplanner@RelMetadataQuerymq)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/eb/73acdf6e9ca8baac6dad09a1727a8d5b11a621.src","preCode":"  @Override public RelOptCost computeSelfCost(RelOptPlanner planner,\n      RelMetadataQuery mq) {\n    double rowCount = mq.getRowCount(this);\n\n    \r\n    \r\n    \r\n    switch (joinType) {\n    case SEMI:\n    case ANTI:\n      \r\n      break;\n    case RIGHT:\n      rowCount = RelMdUtil.addEpsilon(rowCount);\n      break;\n    default:\n      if (RelNodes.COMPARATOR.compare(left, right) > 0) {\n        rowCount = RelMdUtil.addEpsilon(rowCount);\n      }\n    }\n\n    \r\n    \r\n    final double rightRowCount = right.estimateRowCount(mq);\n    final double leftRowCount = left.estimateRowCount(mq);\n    if (Double.isInfinite(leftRowCount)) {\n      rowCount = leftRowCount;\n    } else {\n      rowCount += Util.nLogN(leftRowCount);\n    }\n    if (Double.isInfinite(rightRowCount)) {\n      rowCount = rightRowCount;\n    } else {\n      rowCount += rightRowCount;\n    }\n    if (isSemiJoin()) {\n      return planner.getCostFactory().makeCost(rowCount, 0, 0).multiplyBy(.01d);\n    } else {\n      return planner.getCostFactory().makeCost(rowCount, 0, 0);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableHashJoin.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":129,"status":"M"},{"authorDate":"2020-05-29 00:04:40","commitOrder":5,"curCode":"  @Override public @Nullable RelOptCost computeSelfCost(RelOptPlanner planner,\n      RelMetadataQuery mq) {\n    double rowCount = mq.getRowCount(this);\n\n    \r\n    \r\n    \r\n    switch (joinType) {\n    case SEMI:\n    case ANTI:\n      \r\n      break;\n    case RIGHT:\n      rowCount = RelMdUtil.addEpsilon(rowCount);\n      break;\n    default:\n      if (RelNodes.COMPARATOR.compare(left, right) > 0) {\n        rowCount = RelMdUtil.addEpsilon(rowCount);\n      }\n    }\n\n    final double rightRowCount = right.estimateRowCount(mq);\n    final double leftRowCount = left.estimateRowCount(mq);\n    if (Double.isInfinite(leftRowCount)) {\n      rowCount = leftRowCount;\n    }\n    if (Double.isInfinite(rightRowCount)) {\n      rowCount = rightRowCount;\n    }\n\n    RelOptCost cost = planner.getCostFactory().makeCost(rowCount, 0, 0);\n    \r\n    cost = cost.multiplyBy(10);\n    return cost;\n  }\n","date":"2020-11-30 06:45:33","endLine":124,"groupId":"102141","id":10,"instanceNumber":2,"isCurCommit":1,"methodName":"computeSelfCost","params":"(RelOptPlannerplanner@RelMetadataQuerymq)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/bd/0d28827cb2d3d8e4cbf7830a4d4650f5dcbf14.src","preCode":"  @Override public RelOptCost computeSelfCost(RelOptPlanner planner,\n      RelMetadataQuery mq) {\n    double rowCount = mq.getRowCount(this);\n\n    \r\n    \r\n    \r\n    switch (joinType) {\n    case SEMI:\n    case ANTI:\n      \r\n      break;\n    case RIGHT:\n      rowCount = RelMdUtil.addEpsilon(rowCount);\n      break;\n    default:\n      if (RelNodes.COMPARATOR.compare(left, right) > 0) {\n        rowCount = RelMdUtil.addEpsilon(rowCount);\n      }\n    }\n\n    final double rightRowCount = right.estimateRowCount(mq);\n    final double leftRowCount = left.estimateRowCount(mq);\n    if (Double.isInfinite(leftRowCount)) {\n      rowCount = leftRowCount;\n    }\n    if (Double.isInfinite(rightRowCount)) {\n      rowCount = rightRowCount;\n    }\n\n    RelOptCost cost = planner.getCostFactory().makeCost(rowCount, 0, 0);\n    \r\n    cost = cost.multiplyBy(10);\n    return cost;\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableNestedLoopJoin.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":90,"status":"M"}],"commitId":"d9a81b88ad561e7e4cedae93e805e0d7a53a7f1a","commitMessage":"@@@[CALCITE-4199] Add nullability annotations\n\nThe commit includes javadoc updates and refactorings made by Julian Hyde in https://github.com/apache/calcite/pull/2278\n","date":"2020-11-30 06:45:33","modifiedFileCount":"1012","status":"M","submitter":"Vladimir Sitnikov"}]
