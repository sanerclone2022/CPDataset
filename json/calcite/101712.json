[{"authorTime":"2017-05-02 12:53:12","codes":[{"authorDate":"2017-05-02 12:53:12","commitOrder":1,"curCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (value == null || clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((ByteString) value).getBytes());\n      }\n      break;\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Integer.class) {\n        return clazz.cast(((DateString) value).getDaysSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Integer.class) {\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n      if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      }\n      break;\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot convert \" + typeName\n        + \" literal to \" + clazz);\n  }\n","date":"2017-05-31 23:17:28","endLine":797,"groupId":"13267","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"getValueAs","params":"(Class<T>clazz)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/97/e3055bf5fe4afa159b5868ebde6f9c1d6a3f5f.src","preCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (value == null || clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((ByteString) value).getBytes());\n      }\n      break;\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Integer.class) {\n        return clazz.cast(((DateString) value).getDaysSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Integer.class) {\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n      if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      }\n      break;\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot convert \" + typeName\n        + \" literal to \" + clazz);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rex/RexLiteral.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":708,"status":"B"},{"authorDate":"2017-05-02 12:53:12","commitOrder":1,"curCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case DATE:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n      if (clazz == Long.class) {\n        final SqlIntervalLiteral.IntervalValue valMonth =\n            (SqlIntervalLiteral.IntervalValue) value;\n        return clazz.cast(valMonth.getSign()\n            * SqlParserUtil.intervalToMonths(valMonth));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      }\n      break;\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Long.class) {\n        final SqlIntervalLiteral.IntervalValue valTime =\n            (SqlIntervalLiteral.IntervalValue) value;\n        return clazz.cast(valTime.getSign()\n            * SqlParserUtil.intervalToMillis(valTime));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot cast \" + value + \" as \" + clazz);\n  }\n","date":"2017-05-31 23:17:28","endLine":312,"groupId":"5867","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getValueAs","params":"(Class<T>clazz)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/4f/cafb93646199d3113049583104f2d9feddac30.src","preCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case DATE:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n      if (clazz == Long.class) {\n        final SqlIntervalLiteral.IntervalValue valMonth =\n            (SqlIntervalLiteral.IntervalValue) value;\n        return clazz.cast(valMonth.getSign()\n            * SqlParserUtil.intervalToMonths(valMonth));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      }\n      break;\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Long.class) {\n        final SqlIntervalLiteral.IntervalValue valTime =\n            (SqlIntervalLiteral.IntervalValue) value;\n        return clazz.cast(valTime.getSign()\n            * SqlParserUtil.intervalToMillis(valTime));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot cast \" + value + \" as \" + clazz);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/SqlLiteral.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":259,"status":"B"}],"commitId":"205af8134857ba312415b9a5b4a48020fe0ce888","commitMessage":"@@@[CALCITE-1690] Calcite timestamp literals cannot express precision above millisecond.  TIMESTAMP(3)\n","date":"2017-05-31 23:17:28","modifiedFileCount":"34","status":"B","submitter":"Julian Hyde"},{"authorTime":"2017-05-02 12:53:12","codes":[{"authorDate":"2017-06-03 04:52:45","commitOrder":2,"curCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (value == null || clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((ByteString) value).getBytes());\n      }\n      break;\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      } else if (clazz == Character.class) {\n        return clazz.cast(((NlsString) value).getValue().charAt(0));\n      }\n      break;\n    case VARCHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Integer.class) {\n        return clazz.cast(((DateString) value).getDaysSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Integer.class) {\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n      if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      }\n      break;\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot convert \" + typeName\n        + \" literal to \" + clazz);\n  }\n","date":"2017-06-06 09:41:27","endLine":804,"groupId":"13267","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"getValueAs","params":"(Class<T>clazz)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/67/4cdd820e088f061ff5e2e129e8bb39554f14b0.src","preCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (value == null || clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((ByteString) value).getBytes());\n      }\n      break;\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Integer.class) {\n        return clazz.cast(((DateString) value).getDaysSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Integer.class) {\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n      if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      }\n      break;\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot convert \" + typeName\n        + \" literal to \" + clazz);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rex/RexLiteral.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":708,"status":"M"},{"authorDate":"2017-05-02 12:53:12","commitOrder":2,"curCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case DATE:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n      if (clazz == Long.class) {\n        final SqlIntervalLiteral.IntervalValue valMonth =\n            (SqlIntervalLiteral.IntervalValue) value;\n        return clazz.cast(valMonth.getSign()\n            * SqlParserUtil.intervalToMonths(valMonth));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      }\n      break;\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Long.class) {\n        final SqlIntervalLiteral.IntervalValue valTime =\n            (SqlIntervalLiteral.IntervalValue) value;\n        return clazz.cast(valTime.getSign()\n            * SqlParserUtil.intervalToMillis(valTime));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot cast \" + value + \" as \" + clazz);\n  }\n","date":"2017-05-31 23:17:28","endLine":312,"groupId":"5867","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getValueAs","params":"(Class<T>clazz)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/4f/cafb93646199d3113049583104f2d9feddac30.src","preCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case DATE:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n      if (clazz == Long.class) {\n        final SqlIntervalLiteral.IntervalValue valMonth =\n            (SqlIntervalLiteral.IntervalValue) value;\n        return clazz.cast(valMonth.getSign()\n            * SqlParserUtil.intervalToMonths(valMonth));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      }\n      break;\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Long.class) {\n        final SqlIntervalLiteral.IntervalValue valTime =\n            (SqlIntervalLiteral.IntervalValue) value;\n        return clazz.cast(valTime.getSign()\n            * SqlParserUtil.intervalToMillis(valTime));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot cast \" + value + \" as \" + clazz);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/SqlLiteral.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":259,"status":"N"}],"commitId":"419b810fe67539cf7a3d653e918352fbaf10e8b0","commitMessage":"@@@[CALCITE-1829] Add TIME/TIMESTAMP/DATE datatype handling to RexImplicationChecker\n\nClose apache/calcite#467\n","date":"2017-06-06 09:41:27","modifiedFileCount":"3","status":"M","submitter":"Minji Kim"},{"authorTime":"2017-05-02 12:53:12","codes":[{"authorDate":"2017-08-07 21:39:15","commitOrder":3,"curCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (value == null || clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((ByteString) value).getBytes());\n      }\n      break;\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      } else if (clazz == Character.class) {\n        return clazz.cast(((NlsString) value).getValue().charAt(0));\n      }\n      break;\n    case VARCHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Integer.class) {\n        return clazz.cast(((DateString) value).getDaysSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Integer.class) {\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == String.class) {\n        return clazz.cast(intervalString(getValueAs(BigDecimal.class).abs()));\n      } else if (clazz == Boolean.class) {\n        \r\n        return clazz.cast(getValueAs(BigDecimal.class).signum() < 0);\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot convert \" + typeName\n        + \" literal to \" + clazz);\n  }\n","date":"2017-08-24 02:20:35","endLine":874,"groupId":"13267","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"getValueAs","params":"(Class<T>clazz)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/8c/4c732778e538c4ffa29afe253de3b4a7bf3925.src","preCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (value == null || clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((ByteString) value).getBytes());\n      }\n      break;\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      } else if (clazz == Character.class) {\n        return clazz.cast(((NlsString) value).getValue().charAt(0));\n      }\n      break;\n    case VARCHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Integer.class) {\n        return clazz.cast(((DateString) value).getDaysSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Integer.class) {\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n      if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      }\n      break;\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot convert \" + typeName\n        + \" literal to \" + clazz);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rex/RexLiteral.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":775,"status":"M"},{"authorDate":"2017-05-02 12:53:12","commitOrder":3,"curCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case DATE:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n      if (clazz == Long.class) {\n        final SqlIntervalLiteral.IntervalValue valMonth =\n            (SqlIntervalLiteral.IntervalValue) value;\n        return clazz.cast(valMonth.getSign()\n            * SqlParserUtil.intervalToMonths(valMonth));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      }\n      break;\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Long.class) {\n        final SqlIntervalLiteral.IntervalValue valTime =\n            (SqlIntervalLiteral.IntervalValue) value;\n        return clazz.cast(valTime.getSign()\n            * SqlParserUtil.intervalToMillis(valTime));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot cast \" + value + \" as \" + clazz);\n  }\n","date":"2017-05-31 23:17:28","endLine":312,"groupId":"5867","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"getValueAs","params":"(Class<T>clazz)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/4f/cafb93646199d3113049583104f2d9feddac30.src","preCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case DATE:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n      if (clazz == Long.class) {\n        final SqlIntervalLiteral.IntervalValue valMonth =\n            (SqlIntervalLiteral.IntervalValue) value;\n        return clazz.cast(valMonth.getSign()\n            * SqlParserUtil.intervalToMonths(valMonth));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      }\n      break;\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Long.class) {\n        final SqlIntervalLiteral.IntervalValue valTime =\n            (SqlIntervalLiteral.IntervalValue) value;\n        return clazz.cast(valTime.getSign()\n            * SqlParserUtil.intervalToMillis(valTime));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot cast \" + value + \" as \" + clazz);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/SqlLiteral.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":259,"status":"N"}],"commitId":"dfe251d7e5136ce93b1172ad1822bd908e953c86","commitMessage":"@@@[CALCITE-1911] In MATCH_RECOGNIZE.  support WITHIN sub-clause (Dian Fu)\n\nClose apache/calcite#509\n","date":"2017-08-24 02:20:35","modifiedFileCount":"14","status":"M","submitter":"Dian Fu"},{"authorTime":"2017-05-02 12:53:12","codes":[{"authorDate":"2017-08-15 08:46:42","commitOrder":4,"curCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (value == null || clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((ByteString) value).getBytes());\n      }\n      break;\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      } else if (clazz == Character.class) {\n        return clazz.cast(((NlsString) value).getValue().charAt(0));\n      }\n      break;\n    case VARCHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Integer.class) {\n        return clazz.cast(((DateString) value).getDaysSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Integer.class) {\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIME_WITH_LOCAL_TIME_ZONE:\n      if (clazz == Integer.class) {\n        \r\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == String.class) {\n        return clazz.cast(intervalString(getValueAs(BigDecimal.class).abs()));\n      } else if (clazz == Boolean.class) {\n        \r\n        return clazz.cast(getValueAs(BigDecimal.class).signum() < 0);\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot convert \" + typeName\n        + \" literal to \" + clazz);\n  }\n","date":"2017-09-06 06:00:36","endLine":900,"groupId":"13267","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"getValueAs","params":"(Class<T>clazz)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/a5/ed9188b3cf3e8f6f0f0198ef785f02650e75d3.src","preCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (value == null || clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((ByteString) value).getBytes());\n      }\n      break;\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      } else if (clazz == Character.class) {\n        return clazz.cast(((NlsString) value).getValue().charAt(0));\n      }\n      break;\n    case VARCHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Integer.class) {\n        return clazz.cast(((DateString) value).getDaysSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Integer.class) {\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == String.class) {\n        return clazz.cast(intervalString(getValueAs(BigDecimal.class).abs()));\n      } else if (clazz == Boolean.class) {\n        \r\n        return clazz.cast(getValueAs(BigDecimal.class).signum() < 0);\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot convert \" + typeName\n        + \" literal to \" + clazz);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rex/RexLiteral.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":789,"status":"M"},{"authorDate":"2017-05-02 12:53:12","commitOrder":4,"curCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case DATE:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n      if (clazz == Long.class) {\n        final SqlIntervalLiteral.IntervalValue valMonth =\n            (SqlIntervalLiteral.IntervalValue) value;\n        return clazz.cast(valMonth.getSign()\n            * SqlParserUtil.intervalToMonths(valMonth));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      }\n      break;\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Long.class) {\n        final SqlIntervalLiteral.IntervalValue valTime =\n            (SqlIntervalLiteral.IntervalValue) value;\n        return clazz.cast(valTime.getSign()\n            * SqlParserUtil.intervalToMillis(valTime));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot cast \" + value + \" as \" + clazz);\n  }\n","date":"2017-05-31 23:17:28","endLine":312,"groupId":"5867","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"getValueAs","params":"(Class<T>clazz)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/4f/cafb93646199d3113049583104f2d9feddac30.src","preCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case DATE:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n      if (clazz == Long.class) {\n        final SqlIntervalLiteral.IntervalValue valMonth =\n            (SqlIntervalLiteral.IntervalValue) value;\n        return clazz.cast(valMonth.getSign()\n            * SqlParserUtil.intervalToMonths(valMonth));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      }\n      break;\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Long.class) {\n        final SqlIntervalLiteral.IntervalValue valTime =\n            (SqlIntervalLiteral.IntervalValue) value;\n        return clazz.cast(valTime.getSign()\n            * SqlParserUtil.intervalToMillis(valTime));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot cast \" + value + \" as \" + clazz);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/SqlLiteral.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":259,"status":"N"}],"commitId":"939c9a62b4905d2cfffcb4adaefd76a809aa3520","commitMessage":"@@@[CALCITE-1947] Add time/timestamp with local time zone types to optimizer\n\nClose apache/calcite#519\n","date":"2017-09-06 06:00:36","modifiedFileCount":"34","status":"M","submitter":"Jesus Camacho Rodriguez"},{"authorTime":"2017-11-07 07:24:58","codes":[{"authorDate":"2017-08-15 08:46:42","commitOrder":5,"curCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (value == null || clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((ByteString) value).getBytes());\n      }\n      break;\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      } else if (clazz == Character.class) {\n        return clazz.cast(((NlsString) value).getValue().charAt(0));\n      }\n      break;\n    case VARCHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Integer.class) {\n        return clazz.cast(((DateString) value).getDaysSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Integer.class) {\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIME_WITH_LOCAL_TIME_ZONE:\n      if (clazz == Integer.class) {\n        \r\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == String.class) {\n        return clazz.cast(intervalString(getValueAs(BigDecimal.class).abs()));\n      } else if (clazz == Boolean.class) {\n        \r\n        return clazz.cast(getValueAs(BigDecimal.class).signum() < 0);\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot convert \" + typeName\n        + \" literal to \" + clazz);\n  }\n","date":"2017-09-06 06:00:36","endLine":900,"groupId":"13267","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"getValueAs","params":"(Class<T>clazz)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/a5/ed9188b3cf3e8f6f0f0198ef785f02650e75d3.src","preCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (value == null || clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((ByteString) value).getBytes());\n      }\n      break;\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      } else if (clazz == Character.class) {\n        return clazz.cast(((NlsString) value).getValue().charAt(0));\n      }\n      break;\n    case VARCHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Integer.class) {\n        return clazz.cast(((DateString) value).getDaysSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Integer.class) {\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIME_WITH_LOCAL_TIME_ZONE:\n      if (clazz == Integer.class) {\n        \r\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == String.class) {\n        return clazz.cast(intervalString(getValueAs(BigDecimal.class).abs()));\n      } else if (clazz == Boolean.class) {\n        \r\n        return clazz.cast(getValueAs(BigDecimal.class).signum() < 0);\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot convert \" + typeName\n        + \" literal to \" + clazz);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rex/RexLiteral.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":789,"status":"N"},{"authorDate":"2017-11-07 07:24:58","commitOrder":5,"curCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((BitString) value).getAsByteArray());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n      final SqlIntervalLiteral.IntervalValue valMonth =\n          (SqlIntervalLiteral.IntervalValue) value;\n      if (clazz == Long.class) {\n        return clazz.cast(valMonth.getSign()\n            * SqlParserUtil.intervalToMonths(valMonth));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      } else if (clazz == TimeUnitRange.class) {\n        return clazz.cast(valMonth.getIntervalQualifier().timeUnitRange);\n      }\n      break;\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      final SqlIntervalLiteral.IntervalValue valTime =\n          (SqlIntervalLiteral.IntervalValue) value;\n      if (clazz == Long.class) {\n        return clazz.cast(valTime.getSign()\n            * SqlParserUtil.intervalToMillis(valTime));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      } else if (clazz == TimeUnitRange.class) {\n        return clazz.cast(valTime.getIntervalQualifier().timeUnitRange);\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot cast \" + value + \" as \" + clazz);\n  }\n","date":"2017-11-16 14:45:49","endLine":352,"groupId":"5271","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"getValueAs","params":"(Class<T>clazz)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/81/5bf91308b632c6baf27c7e4cde76dac7ff7e27.src","preCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case DATE:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n      if (clazz == Long.class) {\n        final SqlIntervalLiteral.IntervalValue valMonth =\n            (SqlIntervalLiteral.IntervalValue) value;\n        return clazz.cast(valMonth.getSign()\n            * SqlParserUtil.intervalToMonths(valMonth));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      }\n      break;\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Long.class) {\n        final SqlIntervalLiteral.IntervalValue valTime =\n            (SqlIntervalLiteral.IntervalValue) value;\n        return clazz.cast(valTime.getSign()\n            * SqlParserUtil.intervalToMillis(valTime));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot cast \" + value + \" as \" + clazz);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/SqlLiteral.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":259,"status":"M"}],"commitId":"e8481e506171a7305449b709efa03312a187aed3","commitMessage":"@@@Add parameter to SqlCallBinding.getOperandLiteralValue(int) to specify desired value type\n","date":"2017-11-16 14:45:49","modifiedFileCount":"11","status":"M","submitter":"Julian Hyde"},{"authorTime":"2017-11-07 07:24:58","codes":[{"authorDate":"2018-01-11 04:54:26","commitOrder":6,"curCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (value == null || clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((ByteString) value).getBytes());\n      }\n      break;\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      } else if (clazz == Character.class) {\n        return clazz.cast(((NlsString) value).getValue().charAt(0));\n      }\n      break;\n    case VARCHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Integer.class) {\n        return clazz.cast(((DateString) value).getDaysSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Integer.class) {\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIME_WITH_LOCAL_TIME_ZONE:\n      if (clazz == Integer.class) {\n        \r\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == String.class) {\n        return clazz.cast(intervalString(getValueAs(BigDecimal.class).abs()));\n      } else if (clazz == Boolean.class) {\n        \r\n        return clazz.cast(getValueAs(BigDecimal.class).signum() < 0);\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot convert \" + typeName\n        + \" literal to \" + clazz);\n  }\n","date":"2018-01-12 11:53:24","endLine":903,"groupId":"13267","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"getValueAs","params":"(Class<T>clazz)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/b5/900bb4394a0925f40ea8a6a6bdaa9693eeaeb8.src","preCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (value == null || clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((ByteString) value).getBytes());\n      }\n      break;\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      } else if (clazz == Character.class) {\n        return clazz.cast(((NlsString) value).getValue().charAt(0));\n      }\n      break;\n    case VARCHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Integer.class) {\n        return clazz.cast(((DateString) value).getDaysSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Integer.class) {\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIME_WITH_LOCAL_TIME_ZONE:\n      if (clazz == Integer.class) {\n        \r\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == String.class) {\n        return clazz.cast(intervalString(getValueAs(BigDecimal.class).abs()));\n      } else if (clazz == Boolean.class) {\n        \r\n        return clazz.cast(getValueAs(BigDecimal.class).signum() < 0);\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot convert \" + typeName\n        + \" literal to \" + clazz);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rex/RexLiteral.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":789,"status":"M"},{"authorDate":"2017-11-07 07:24:58","commitOrder":6,"curCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((BitString) value).getAsByteArray());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n      final SqlIntervalLiteral.IntervalValue valMonth =\n          (SqlIntervalLiteral.IntervalValue) value;\n      if (clazz == Long.class) {\n        return clazz.cast(valMonth.getSign()\n            * SqlParserUtil.intervalToMonths(valMonth));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      } else if (clazz == TimeUnitRange.class) {\n        return clazz.cast(valMonth.getIntervalQualifier().timeUnitRange);\n      }\n      break;\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      final SqlIntervalLiteral.IntervalValue valTime =\n          (SqlIntervalLiteral.IntervalValue) value;\n      if (clazz == Long.class) {\n        return clazz.cast(valTime.getSign()\n            * SqlParserUtil.intervalToMillis(valTime));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      } else if (clazz == TimeUnitRange.class) {\n        return clazz.cast(valTime.getIntervalQualifier().timeUnitRange);\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot cast \" + value + \" as \" + clazz);\n  }\n","date":"2017-11-16 14:45:49","endLine":352,"groupId":"5271","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"getValueAs","params":"(Class<T>clazz)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/81/5bf91308b632c6baf27c7e4cde76dac7ff7e27.src","preCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((BitString) value).getAsByteArray());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n      final SqlIntervalLiteral.IntervalValue valMonth =\n          (SqlIntervalLiteral.IntervalValue) value;\n      if (clazz == Long.class) {\n        return clazz.cast(valMonth.getSign()\n            * SqlParserUtil.intervalToMonths(valMonth));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      } else if (clazz == TimeUnitRange.class) {\n        return clazz.cast(valMonth.getIntervalQualifier().timeUnitRange);\n      }\n      break;\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      final SqlIntervalLiteral.IntervalValue valTime =\n          (SqlIntervalLiteral.IntervalValue) value;\n      if (clazz == Long.class) {\n        return clazz.cast(valTime.getSign()\n            * SqlParserUtil.intervalToMillis(valTime));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      } else if (clazz == TimeUnitRange.class) {\n        return clazz.cast(valTime.getIntervalQualifier().timeUnitRange);\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot cast \" + value + \" as \" + clazz);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/SqlLiteral.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":259,"status":"N"}],"commitId":"fa19580ecfe404b75fcb6c9c174cfe9da73d2db8","commitMessage":"@@@[CALCITE-2090] Convert FLOOR and CEIL into time ranges (Nishant Bangarwa)\n\nAdd test for multiple operands.\n\nAllow RexLiteral.getValueAs(Calendar) on TIMESTAMP_WITH_LOCAL_TIME_ZONE\nliterals.\n\nClose apache/calcite#603\n","date":"2018-01-12 11:53:24","modifiedFileCount":"4","status":"M","submitter":"Nishant"},{"authorTime":"2020-07-21 04:33:06","codes":[{"authorDate":"2018-01-11 04:54:26","commitOrder":7,"curCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (value == null || clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((ByteString) value).getBytes());\n      }\n      break;\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      } else if (clazz == Character.class) {\n        return clazz.cast(((NlsString) value).getValue().charAt(0));\n      }\n      break;\n    case VARCHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Integer.class) {\n        return clazz.cast(((DateString) value).getDaysSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Integer.class) {\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIME_WITH_LOCAL_TIME_ZONE:\n      if (clazz == Integer.class) {\n        \r\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == String.class) {\n        return clazz.cast(intervalString(getValueAs(BigDecimal.class).abs()));\n      } else if (clazz == Boolean.class) {\n        \r\n        return clazz.cast(getValueAs(BigDecimal.class).signum() < 0);\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot convert \" + typeName\n        + \" literal to \" + clazz);\n  }\n","date":"2018-01-12 11:53:24","endLine":903,"groupId":"13267","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"getValueAs","params":"(Class<T>clazz)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/b5/900bb4394a0925f40ea8a6a6bdaa9693eeaeb8.src","preCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (value == null || clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((ByteString) value).getBytes());\n      }\n      break;\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      } else if (clazz == Character.class) {\n        return clazz.cast(((NlsString) value).getValue().charAt(0));\n      }\n      break;\n    case VARCHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Integer.class) {\n        return clazz.cast(((DateString) value).getDaysSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Integer.class) {\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIME_WITH_LOCAL_TIME_ZONE:\n      if (clazz == Integer.class) {\n        \r\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == String.class) {\n        return clazz.cast(intervalString(getValueAs(BigDecimal.class).abs()));\n      } else if (clazz == Boolean.class) {\n        \r\n        return clazz.cast(getValueAs(BigDecimal.class).signum() < 0);\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot convert \" + typeName\n        + \" literal to \" + clazz);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rex/RexLiteral.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":789,"status":"N"},{"authorDate":"2020-07-21 04:33:06","commitOrder":7,"curCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((BitString) value).getAsByteArray());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n      final SqlIntervalLiteral.IntervalValue valMonth =\n          (SqlIntervalLiteral.IntervalValue) value;\n      if (clazz == Long.class) {\n        return clazz.cast(valMonth.getSign()\n            * SqlParserUtil.intervalToMonths(valMonth));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      } else if (clazz == TimeUnitRange.class) {\n        return clazz.cast(valMonth.getIntervalQualifier().timeUnitRange);\n      } else if (clazz == SqlIntervalQualifier.class) {\n        return clazz.cast(valMonth.getIntervalQualifier());\n      }\n      break;\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      final SqlIntervalLiteral.IntervalValue valTime =\n          (SqlIntervalLiteral.IntervalValue) value;\n      if (clazz == Long.class) {\n        return clazz.cast(valTime.getSign()\n            * SqlParserUtil.intervalToMillis(valTime));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      } else if (clazz == TimeUnitRange.class) {\n        return clazz.cast(valTime.getIntervalQualifier().timeUnitRange);\n      } else if (clazz == SqlIntervalQualifier.class) {\n        return clazz.cast(valTime.getIntervalQualifier());\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot cast \" + value + \" as \" + clazz);\n  }\n","date":"2020-07-29 03:09:43","endLine":366,"groupId":"5271","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"getValueAs","params":"(Class<T>clazz)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/7c/e5fa184c342d6e95365c57d11b0e3b0c0eba21.src","preCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((BitString) value).getAsByteArray());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n      final SqlIntervalLiteral.IntervalValue valMonth =\n          (SqlIntervalLiteral.IntervalValue) value;\n      if (clazz == Long.class) {\n        return clazz.cast(valMonth.getSign()\n            * SqlParserUtil.intervalToMonths(valMonth));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      } else if (clazz == TimeUnitRange.class) {\n        return clazz.cast(valMonth.getIntervalQualifier().timeUnitRange);\n      }\n      break;\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      final SqlIntervalLiteral.IntervalValue valTime =\n          (SqlIntervalLiteral.IntervalValue) value;\n      if (clazz == Long.class) {\n        return clazz.cast(valTime.getSign()\n            * SqlParserUtil.intervalToMillis(valTime));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      } else if (clazz == TimeUnitRange.class) {\n        return clazz.cast(valTime.getIntervalQualifier().timeUnitRange);\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot cast \" + value + \" as \" + clazz);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/SqlLiteral.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":269,"status":"M"}],"commitId":"03c76a7d2b896042ab417ddc36f1849f874ad3dd","commitMessage":"@@@[CALCITE-4134] Interval expressions\n","date":"2020-07-29 03:09:43","modifiedFileCount":"20","status":"M","submitter":"Julian Hyde"},{"authorTime":"2018-06-19 05:10:50","codes":[{"authorDate":"2018-01-11 04:54:26","commitOrder":8,"curCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (value == null || clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((ByteString) value).getBytes());\n      }\n      break;\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      } else if (clazz == Character.class) {\n        return clazz.cast(((NlsString) value).getValue().charAt(0));\n      }\n      break;\n    case VARCHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Integer.class) {\n        return clazz.cast(((DateString) value).getDaysSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Integer.class) {\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIME_WITH_LOCAL_TIME_ZONE:\n      if (clazz == Integer.class) {\n        \r\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == String.class) {\n        return clazz.cast(intervalString(getValueAs(BigDecimal.class).abs()));\n      } else if (clazz == Boolean.class) {\n        \r\n        return clazz.cast(getValueAs(BigDecimal.class).signum() < 0);\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot convert \" + typeName\n        + \" literal to \" + clazz);\n  }\n","date":"2018-01-12 11:53:24","endLine":903,"groupId":"13267","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"getValueAs","params":"(Class<T>clazz)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/b5/900bb4394a0925f40ea8a6a6bdaa9693eeaeb8.src","preCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (value == null || clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((ByteString) value).getBytes());\n      }\n      break;\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      } else if (clazz == Character.class) {\n        return clazz.cast(((NlsString) value).getValue().charAt(0));\n      }\n      break;\n    case VARCHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Integer.class) {\n        return clazz.cast(((DateString) value).getDaysSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Integer.class) {\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIME_WITH_LOCAL_TIME_ZONE:\n      if (clazz == Integer.class) {\n        \r\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == String.class) {\n        return clazz.cast(intervalString(getValueAs(BigDecimal.class).abs()));\n      } else if (clazz == Boolean.class) {\n        \r\n        return clazz.cast(getValueAs(BigDecimal.class).signum() < 0);\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot convert \" + typeName\n        + \" literal to \" + clazz);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rex/RexLiteral.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":789,"status":"N"},{"authorDate":"2018-06-19 05:10:50","commitOrder":8,"curCode":"  @Nonnull public <T> T getValueAs(Class<T> clazz) {\n    if (clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case NULL:\n      return clazz.cast(NullSentinel.INSTANCE);\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((BitString) value).getAsByteArray());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n      final SqlIntervalLiteral.IntervalValue valMonth =\n          (SqlIntervalLiteral.IntervalValue) value;\n      if (clazz == Long.class) {\n        return clazz.cast(valMonth.getSign()\n            * SqlParserUtil.intervalToMonths(valMonth));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      } else if (clazz == TimeUnitRange.class) {\n        return clazz.cast(valMonth.getIntervalQualifier().timeUnitRange);\n      } else if (clazz == SqlIntervalQualifier.class) {\n        return clazz.cast(valMonth.getIntervalQualifier());\n      }\n      break;\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      final SqlIntervalLiteral.IntervalValue valTime =\n          (SqlIntervalLiteral.IntervalValue) value;\n      if (clazz == Long.class) {\n        return clazz.cast(valTime.getSign()\n            * SqlParserUtil.intervalToMillis(valTime));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      } else if (clazz == TimeUnitRange.class) {\n        return clazz.cast(valTime.getIntervalQualifier().timeUnitRange);\n      } else if (clazz == SqlIntervalQualifier.class) {\n        return clazz.cast(valTime.getIntervalQualifier());\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot cast \" + value + \" as \" + clazz);\n  }\n","date":"2020-07-29 03:09:43","endLine":377,"groupId":"5271","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"getValueAs","params":"(Class<T>clazz)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/c3/b7981f09385a2bbb211f7486f0b01703163aa0.src","preCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((BitString) value).getAsByteArray());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n      final SqlIntervalLiteral.IntervalValue valMonth =\n          (SqlIntervalLiteral.IntervalValue) value;\n      if (clazz == Long.class) {\n        return clazz.cast(valMonth.getSign()\n            * SqlParserUtil.intervalToMonths(valMonth));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      } else if (clazz == TimeUnitRange.class) {\n        return clazz.cast(valMonth.getIntervalQualifier().timeUnitRange);\n      } else if (clazz == SqlIntervalQualifier.class) {\n        return clazz.cast(valMonth.getIntervalQualifier());\n      }\n      break;\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      final SqlIntervalLiteral.IntervalValue valTime =\n          (SqlIntervalLiteral.IntervalValue) value;\n      if (clazz == Long.class) {\n        return clazz.cast(valTime.getSign()\n            * SqlParserUtil.intervalToMillis(valTime));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      } else if (clazz == TimeUnitRange.class) {\n        return clazz.cast(valTime.getIntervalQualifier().timeUnitRange);\n      } else if (clazz == SqlIntervalQualifier.class) {\n        return clazz.cast(valTime.getIntervalQualifier());\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot cast \" + value + \" as \" + clazz);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/SqlLiteral.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":278,"status":"M"}],"commitId":"19edf52c76c6a1507721f5bd37f2a33497aa0c4c","commitMessage":"@@@[CALCITE-2569] UDFs that are table functions must implement SqlTableFunction and have CURSOR as their return type\n\nValidate that table functions are not used in contexts that require\nscalar functions.  such as the SELECT clause.\n\nChange operand type ANY to mean 'scalar expression of any type (but\nnot a cursor)'.  and add operand type IGNORE to mean skip validation -\nfor an operand that is not an expression. TABLE is one of the few\noperators that accepts a CURSOR operand.\n\nAdd SqlKind.INTERVAL_QUALIFIER.\n","date":"2020-07-29 03:09:43","modifiedFileCount":"32","status":"M","submitter":"Julian Hyde"},{"authorTime":"2020-09-30 01:31:14","codes":[{"authorDate":"2020-09-30 01:31:14","commitOrder":9,"curCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (value == null || clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((ByteString) value).getBytes());\n      }\n      break;\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      } else if (clazz == Character.class) {\n        return clazz.cast(((NlsString) value).getValue().charAt(0));\n      }\n      break;\n    case VARCHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Integer.class) {\n        return clazz.cast(((DateString) value).getDaysSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Integer.class) {\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIME_WITH_LOCAL_TIME_ZONE:\n      if (clazz == Integer.class) {\n        \r\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == String.class) {\n        return clazz.cast(intervalString(getValueAs(BigDecimal.class).abs()));\n      } else if (clazz == Boolean.class) {\n        \r\n        return clazz.cast(getValueAs(BigDecimal.class).signum() < 0);\n      }\n      break;\n    default:\n      break;\n    }\n    throw new AssertionError(\"cannot convert \" + typeName\n        + \" literal to \" + clazz);\n  }\n","date":"2020-10-07 05:43:06","endLine":1113,"groupId":"13267","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"getValueAs","params":"(Class<T>clazz)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/21/f9de3052c3a3be80d004df52aae5a0804fc9b2.src","preCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (value == null || clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((ByteString) value).getBytes());\n      }\n      break;\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      } else if (clazz == Character.class) {\n        return clazz.cast(((NlsString) value).getValue().charAt(0));\n      }\n      break;\n    case VARCHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Integer.class) {\n        return clazz.cast(((DateString) value).getDaysSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Integer.class) {\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIME_WITH_LOCAL_TIME_ZONE:\n      if (clazz == Integer.class) {\n        \r\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == String.class) {\n        return clazz.cast(intervalString(getValueAs(BigDecimal.class).abs()));\n      } else if (clazz == Boolean.class) {\n        \r\n        return clazz.cast(getValueAs(BigDecimal.class).signum() < 0);\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot convert \" + typeName\n        + \" literal to \" + clazz);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rex/RexLiteral.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":997,"status":"M"},{"authorDate":"2020-09-30 01:31:14","commitOrder":9,"curCode":"  @Nonnull public <T> T getValueAs(Class<T> clazz) {\n    if (clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case NULL:\n      return clazz.cast(NullSentinel.INSTANCE);\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((BitString) value).getAsByteArray());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n      final SqlIntervalLiteral.IntervalValue valMonth =\n          (SqlIntervalLiteral.IntervalValue) value;\n      if (clazz == Long.class) {\n        return clazz.cast(valMonth.getSign()\n            * SqlParserUtil.intervalToMonths(valMonth));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      } else if (clazz == TimeUnitRange.class) {\n        return clazz.cast(valMonth.getIntervalQualifier().timeUnitRange);\n      } else if (clazz == SqlIntervalQualifier.class) {\n        return clazz.cast(valMonth.getIntervalQualifier());\n      }\n      break;\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      final SqlIntervalLiteral.IntervalValue valTime =\n          (SqlIntervalLiteral.IntervalValue) value;\n      if (clazz == Long.class) {\n        return clazz.cast(valTime.getSign()\n            * SqlParserUtil.intervalToMillis(valTime));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      } else if (clazz == TimeUnitRange.class) {\n        return clazz.cast(valTime.getIntervalQualifier().timeUnitRange);\n      } else if (clazz == SqlIntervalQualifier.class) {\n        return clazz.cast(valTime.getIntervalQualifier());\n      }\n      break;\n    default:\n      break;\n    }\n    throw new AssertionError(\"cannot cast \" + value + \" as \" + clazz);\n  }\n","date":"2020-10-07 05:43:06","endLine":379,"groupId":"5271","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"getValueAs","params":"(Class<T>clazz)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/df/a6fcb6a9cb209dc1f2706fe636756f3db8ab82.src","preCode":"  @Nonnull public <T> T getValueAs(Class<T> clazz) {\n    if (clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case NULL:\n      return clazz.cast(NullSentinel.INSTANCE);\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((BitString) value).getAsByteArray());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n      final SqlIntervalLiteral.IntervalValue valMonth =\n          (SqlIntervalLiteral.IntervalValue) value;\n      if (clazz == Long.class) {\n        return clazz.cast(valMonth.getSign()\n            * SqlParserUtil.intervalToMonths(valMonth));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      } else if (clazz == TimeUnitRange.class) {\n        return clazz.cast(valMonth.getIntervalQualifier().timeUnitRange);\n      } else if (clazz == SqlIntervalQualifier.class) {\n        return clazz.cast(valMonth.getIntervalQualifier());\n      }\n      break;\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      final SqlIntervalLiteral.IntervalValue valTime =\n          (SqlIntervalLiteral.IntervalValue) value;\n      if (clazz == Long.class) {\n        return clazz.cast(valTime.getSign()\n            * SqlParserUtil.intervalToMillis(valTime));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      } else if (clazz == TimeUnitRange.class) {\n        return clazz.cast(valTime.getIntervalQualifier().timeUnitRange);\n      } else if (clazz == SqlIntervalQualifier.class) {\n        return clazz.cast(valTime.getIntervalQualifier());\n      }\n      break;\n    }\n    throw new AssertionError(\"cannot cast \" + value + \" as \" + clazz);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/SqlLiteral.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":278,"status":"M"}],"commitId":"1b94f37e888cf2d186362473529e6c147afe0f6e","commitMessage":"@@@[CALCITE-4314] Add missing default branches to switch statement\n\nNote: the changes are mechanical.\nThe intention is to keep the previous behavior and prevent adding new\nnon exchaustive switch statements in the future.\n\nSee https://errorprone.info/bugpattern/MissingCasesInEnumSwitch\n","date":"2020-10-07 05:43:06","modifiedFileCount":"98","status":"M","submitter":"Vladimir Sitnikov"},{"authorTime":"2020-05-29 00:04:40","codes":[{"authorDate":"2020-05-29 00:04:40","commitOrder":10,"curCode":"  public <T> @Nullable T getValueAs(Class<T> clazz) {\n    if (value == null || clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((ByteString) value).getBytes());\n      }\n      break;\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      } else if (clazz == Character.class) {\n        return clazz.cast(((NlsString) value).getValue().charAt(0));\n      }\n      break;\n    case VARCHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Integer.class) {\n        return clazz.cast(((DateString) value).getDaysSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Integer.class) {\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIME_WITH_LOCAL_TIME_ZONE:\n      if (clazz == Integer.class) {\n        \r\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == String.class) {\n        return clazz.cast(intervalString(castNonNull(getValueAs(BigDecimal.class)).abs()));\n      } else if (clazz == Boolean.class) {\n        \r\n        return clazz.cast(castNonNull(getValueAs(BigDecimal.class)).signum() < 0);\n      }\n      break;\n    default:\n      break;\n    }\n    throw new AssertionError(\"cannot convert \" + typeName\n        + \" literal to \" + clazz);\n  }\n","date":"2020-11-30 06:45:33","endLine":1136,"groupId":"101712","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"getValueAs","params":"(Class<T>clazz)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/8d/7cf44e96d41e75c4a6b9b0c3339338d9d5cb2f.src","preCode":"  public <T> T getValueAs(Class<T> clazz) {\n    if (value == null || clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((ByteString) value).getBytes());\n      }\n      break;\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      } else if (clazz == Character.class) {\n        return clazz.cast(((NlsString) value).getValue().charAt(0));\n      }\n      break;\n    case VARCHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Integer.class) {\n        return clazz.cast(((DateString) value).getDaysSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Integer.class) {\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIME_WITH_LOCAL_TIME_ZONE:\n      if (clazz == Integer.class) {\n        \r\n        return clazz.cast(((TimeString) value).getMillisOfDay());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n      if (clazz == Long.class) {\n        \r\n        return clazz.cast(((TimestampString) value).getMillisSinceEpoch());\n      } else if (clazz == Calendar.class) {\n        \r\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == String.class) {\n        return clazz.cast(intervalString(getValueAs(BigDecimal.class).abs()));\n      } else if (clazz == Boolean.class) {\n        \r\n        return clazz.cast(getValueAs(BigDecimal.class).signum() < 0);\n      }\n      break;\n    default:\n      break;\n    }\n    throw new AssertionError(\"cannot convert \" + typeName\n        + \" literal to \" + clazz);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rex/RexLiteral.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1020,"status":"M"},{"authorDate":"2020-05-29 00:04:40","commitOrder":10,"curCode":"  public <T extends Object> T getValueAs(Class<T> clazz) {\n    Object value = this.value;\n    if (clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    if (typeName == SqlTypeName.NULL) {\n      return clazz.cast(NullSentinel.INSTANCE);\n    }\n    requireNonNull(value, \"value\");\n    switch (typeName) {\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((BitString) value).getAsByteArray());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValueExact());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValueExact());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValueExact());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValueExact());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValueExact());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n      final SqlIntervalLiteral.IntervalValue valMonth =\n          (SqlIntervalLiteral.IntervalValue) value;\n      if (clazz == Long.class) {\n        return clazz.cast(valMonth.getSign()\n            * SqlParserUtil.intervalToMonths(valMonth));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      } else if (clazz == TimeUnitRange.class) {\n        return clazz.cast(valMonth.getIntervalQualifier().timeUnitRange);\n      } else if (clazz == SqlIntervalQualifier.class) {\n        return clazz.cast(valMonth.getIntervalQualifier());\n      }\n      break;\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      final SqlIntervalLiteral.IntervalValue valTime =\n          (SqlIntervalLiteral.IntervalValue) value;\n      if (clazz == Long.class) {\n        return clazz.cast(valTime.getSign()\n            * SqlParserUtil.intervalToMillis(valTime));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      } else if (clazz == TimeUnitRange.class) {\n        return clazz.cast(valTime.getIntervalQualifier().timeUnitRange);\n      } else if (clazz == SqlIntervalQualifier.class) {\n        return clazz.cast(valTime.getIntervalQualifier());\n      }\n      break;\n    default:\n      break;\n    }\n    throw new AssertionError(\"cannot cast \" + value + \" as \" + clazz);\n  }\n","date":"2020-11-30 06:45:33","endLine":386,"groupId":"101712","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"getValueAs","params":"(Class<T>clazz)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/4d/017599f0886d3f013fccd2a5969aa8c749ac50.src","preCode":"  @Nonnull public <T> T getValueAs(Class<T> clazz) {\n    if (clazz.isInstance(value)) {\n      return clazz.cast(value);\n    }\n    switch (typeName) {\n    case NULL:\n      return clazz.cast(NullSentinel.INSTANCE);\n    case CHAR:\n      if (clazz == String.class) {\n        return clazz.cast(((NlsString) value).getValue());\n      }\n      break;\n    case BINARY:\n      if (clazz == byte[].class) {\n        return clazz.cast(((BitString) value).getAsByteArray());\n      }\n      break;\n    case DECIMAL:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).unscaledValue().longValue());\n      }\n      \r\n    case BIGINT:\n    case INTEGER:\n    case SMALLINT:\n    case TINYINT:\n    case DOUBLE:\n    case REAL:\n    case FLOAT:\n      if (clazz == Long.class) {\n        return clazz.cast(((BigDecimal) value).longValue());\n      } else if (clazz == Integer.class) {\n        return clazz.cast(((BigDecimal) value).intValue());\n      } else if (clazz == Short.class) {\n        return clazz.cast(((BigDecimal) value).shortValue());\n      } else if (clazz == Byte.class) {\n        return clazz.cast(((BigDecimal) value).byteValue());\n      } else if (clazz == Double.class) {\n        return clazz.cast(((BigDecimal) value).doubleValue());\n      } else if (clazz == Float.class) {\n        return clazz.cast(((BigDecimal) value).floatValue());\n      }\n      break;\n    case DATE:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((DateString) value).toCalendar());\n      }\n      break;\n    case TIME:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimeString) value).toCalendar());\n      }\n      break;\n    case TIMESTAMP:\n      if (clazz == Calendar.class) {\n        return clazz.cast(((TimestampString) value).toCalendar());\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n      final SqlIntervalLiteral.IntervalValue valMonth =\n          (SqlIntervalLiteral.IntervalValue) value;\n      if (clazz == Long.class) {\n        return clazz.cast(valMonth.getSign()\n            * SqlParserUtil.intervalToMonths(valMonth));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      } else if (clazz == TimeUnitRange.class) {\n        return clazz.cast(valMonth.getIntervalQualifier().timeUnitRange);\n      } else if (clazz == SqlIntervalQualifier.class) {\n        return clazz.cast(valMonth.getIntervalQualifier());\n      }\n      break;\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      final SqlIntervalLiteral.IntervalValue valTime =\n          (SqlIntervalLiteral.IntervalValue) value;\n      if (clazz == Long.class) {\n        return clazz.cast(valTime.getSign()\n            * SqlParserUtil.intervalToMillis(valTime));\n      } else if (clazz == BigDecimal.class) {\n        return clazz.cast(BigDecimal.valueOf(getValueAs(Long.class)));\n      } else if (clazz == TimeUnitRange.class) {\n        return clazz.cast(valTime.getIntervalQualifier().timeUnitRange);\n      } else if (clazz == SqlIntervalQualifier.class) {\n        return clazz.cast(valTime.getIntervalQualifier());\n      }\n      break;\n    default:\n      break;\n    }\n    throw new AssertionError(\"cannot cast \" + value + \" as \" + clazz);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/SqlLiteral.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":282,"status":"M"}],"commitId":"d9a81b88ad561e7e4cedae93e805e0d7a53a7f1a","commitMessage":"@@@[CALCITE-4199] Add nullability annotations\n\nThe commit includes javadoc updates and refactorings made by Julian Hyde in https://github.com/apache/calcite/pull/2278\n","date":"2020-11-30 06:45:33","modifiedFileCount":"1012","status":"M","submitter":"Vladimir Sitnikov"}]
