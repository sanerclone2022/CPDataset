[{"authorTime":"2020-09-22 18:02:11","codes":[{"authorDate":"2018-11-14 00:42:35","commitOrder":3,"curCode":"  public Set<RexNode> getExpressionLineage(Aggregate rel,\n      RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = rel.getInput();\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n\n    \r\n    final ImmutableBitSet inputFieldsUsed = extractInputRefs(outputExpression);\n\n    for (int idx : inputFieldsUsed) {\n      if (idx >= rel.getGroupCount()) {\n        \r\n        return null;\n      }\n    }\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexInputRef inputRef = RexInputRef.of(rel.getGroupSet().nth(idx),\n          input.getRowType().getFieldList());\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputRef);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","date":"2018-11-14 00:42:52","endLine":171,"groupId":"15828","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"getExpressionLineage","params":"(Aggregaterel@RelMetadataQuerymq@RexNodeoutputExpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/fc/bf571a68b552ff661d1670a32a16809cf4c59a.src","preCode":"  public Set<RexNode> getExpressionLineage(Aggregate rel,\n      RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = rel.getInput();\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n\n    \r\n    final ImmutableBitSet inputFieldsUsed = extractInputRefs(outputExpression);\n\n    for (int idx : inputFieldsUsed) {\n      if (idx >= rel.getGroupCount()) {\n        \r\n        return null;\n      }\n    }\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexInputRef inputRef = RexInputRef.of(rel.getGroupSet().nth(idx),\n          input.getRowType().getFieldList());\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputRef);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/metadata/RelMdExpressionLineage.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":140,"status":"NB"},{"authorDate":"2020-09-22 18:02:11","commitOrder":3,"curCode":"  public Set<RexNode> getExpressionLineage(Calc calc,\n      RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = calc.getInput();\n    final RexBuilder rexBuilder = calc.getCluster().getRexBuilder();\n    \r\n    final ImmutableBitSet inputFieldsUsed = extractInputRefs(outputExpression);\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    Pair<ImmutableList<RexNode>, ImmutableList<RexNode>> calcProjectsAndFilter =\n        calc.getProgram().split();\n    for (int idx : inputFieldsUsed) {\n      final RexNode inputExpr = calcProjectsAndFilter.getKey().get(idx);\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputExpr);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, calc.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","date":"2020-11-04 08:19:22","endLine":438,"groupId":"5085","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getExpressionLineage","params":"(Calccalc@RelMetadataQuerymq@RexNodeoutputExpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/f1/c97cb7a7706f1a38d3109322ca3843ce618f98.src","preCode":"  public Set<RexNode> getExpressionLineage(Calc calc,\n      RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = calc.getInput();\n    final RexBuilder rexBuilder = calc.getCluster().getRexBuilder();\n    \r\n    final ImmutableBitSet inputFieldsUsed = extractInputRefs(outputExpression);\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    Pair<ImmutableList<RexNode>, ImmutableList<RexNode>> calcProjectsAndFilter =\n        calc.getProgram().split();\n    for (int idx : inputFieldsUsed) {\n      final RexNode inputExpr = calcProjectsAndFilter.getKey().get(idx);\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputExpr);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, calc.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/metadata/RelMdExpressionLineage.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":414,"status":"B"}],"commitId":"2e9edae7fc57ab9c9c7c097008724ac99a1791a3","commitMessage":"@@@[CALCITE-4273] Support get expression lineage for Calc\n","date":"2020-11-04 08:19:22","modifiedFileCount":"2","status":"M","submitter":"yanlin-Lynn"},{"authorTime":"2020-05-29 00:04:40","codes":[{"authorDate":"2020-05-29 00:04:40","commitOrder":4,"curCode":"  public @Nullable Set<RexNode> getExpressionLineage(Aggregate rel,\n      RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = rel.getInput();\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n\n    \r\n    final ImmutableBitSet inputFieldsUsed = extractInputRefs(outputExpression);\n\n    for (int idx : inputFieldsUsed) {\n      if (idx >= rel.getGroupCount()) {\n        \r\n        return null;\n      }\n    }\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexInputRef inputRef = RexInputRef.of(rel.getGroupSet().nth(idx),\n          input.getRowType().getFieldList());\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputRef);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","date":"2020-11-30 06:45:33","endLine":185,"groupId":"111955","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"getExpressionLineage","params":"(Aggregaterel@RelMetadataQuerymq@RexNodeoutputExpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/43/be0ac23a8334ce5ec957a1175aa4f314a52b8b.src","preCode":"  public Set<RexNode> getExpressionLineage(Aggregate rel,\n      RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = rel.getInput();\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n\n    \r\n    final ImmutableBitSet inputFieldsUsed = extractInputRefs(outputExpression);\n\n    for (int idx : inputFieldsUsed) {\n      if (idx >= rel.getGroupCount()) {\n        \r\n        return null;\n      }\n    }\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexInputRef inputRef = RexInputRef.of(rel.getGroupSet().nth(idx),\n          input.getRowType().getFieldList());\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputRef);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/metadata/RelMdExpressionLineage.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":154,"status":"M"},{"authorDate":"2020-05-29 00:04:40","commitOrder":4,"curCode":"  public @Nullable Set<RexNode> getExpressionLineage(Calc calc,\n      RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = calc.getInput();\n    final RexBuilder rexBuilder = calc.getCluster().getRexBuilder();\n    \r\n    final ImmutableBitSet inputFieldsUsed = extractInputRefs(outputExpression);\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    Pair<ImmutableList<RexNode>, ImmutableList<RexNode>> calcProjectsAndFilter =\n        calc.getProgram().split();\n    for (int idx : inputFieldsUsed) {\n      final RexNode inputExpr = calcProjectsAndFilter.getKey().get(idx);\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputExpr);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, calc.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","date":"2020-11-30 06:45:33","endLine":446,"groupId":"111955","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"getExpressionLineage","params":"(Calccalc@RelMetadataQuerymq@RexNodeoutputExpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/43/be0ac23a8334ce5ec957a1175aa4f314a52b8b.src","preCode":"  public Set<RexNode> getExpressionLineage(Calc calc,\n      RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = calc.getInput();\n    final RexBuilder rexBuilder = calc.getCluster().getRexBuilder();\n    \r\n    final ImmutableBitSet inputFieldsUsed = extractInputRefs(outputExpression);\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    Pair<ImmutableList<RexNode>, ImmutableList<RexNode>> calcProjectsAndFilter =\n        calc.getProgram().split();\n    for (int idx : inputFieldsUsed) {\n      final RexNode inputExpr = calcProjectsAndFilter.getKey().get(idx);\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputExpr);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, calc.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/metadata/RelMdExpressionLineage.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":422,"status":"M"}],"commitId":"d9a81b88ad561e7e4cedae93e805e0d7a53a7f1a","commitMessage":"@@@[CALCITE-4199] Add nullability annotations\n\nThe commit includes javadoc updates and refactorings made by Julian Hyde in https://github.com/apache/calcite/pull/2278\n","date":"2020-11-30 06:45:33","modifiedFileCount":"1012","status":"M","submitter":"Vladimir Sitnikov"}]
