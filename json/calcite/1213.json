[{"authorTime":"2014-11-14 10:11:34","codes":[{"authorDate":"2014-11-14 10:11:34","commitOrder":1,"curCode":"    public Result implementSpark(Implementor implementor) {\n\r\n\r\n\r\n\r\n\r\n\r\n\n      final JavaTypeFactory typeFactory =\n          (JavaTypeFactory) getCluster().getTypeFactory();\n      final BlockBuilder builder = new BlockBuilder();\n      final PhysType physType =\n          PhysTypeImpl.of(implementor.getTypeFactory(),\n              getRowType(),\n              JavaRowFormat.CUSTOM);\n      final Type rowClass = physType.getJavaRowType();\n\n      final List<Expression> expressions = new ArrayList<Expression>();\n      final List<RelDataTypeField> fields = rowType.getFieldList();\n      for (List<RexLiteral> tuple : tuples) {\n        final List<Expression> literals = new ArrayList<Expression>();\n        for (Pair<RelDataTypeField, RexLiteral> pair\n            : Pair.zip(fields, tuple)) {\n          literals.add(\n              RexToLixTranslator.translateLiteral(\n                  pair.right,\n                  pair.left.getType(),\n                  typeFactory,\n                  RexImpTable.NullAs.NULL));\n        }\n        expressions.add(physType.record(literals));\n      }\n      builder.add(\n          Expressions.return_(null,\n              Expressions.call(SparkMethod.ARRAY_TO_RDD.method,\n                  Expressions.call(SparkMethod.GET_SPARK_CONTEXT.method,\n                      implementor.getRootExpression()),\n                  Expressions.newArrayInit(Primitive.box(rowClass),\n                      expressions))));\n      return implementor.result(physType, builder.toBlock());\n    }\n","date":"2014-11-14 10:22:06","endLine":206,"groupId":"15209","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"implementSpark","params":"(Implementorimplementor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/4b/d0304e3dc5e997cbcbb6a24847593d5d74fcbc.src","preCode":"    public Result implementSpark(Implementor implementor) {\n\r\n\r\n\r\n\r\n\r\n\r\n\n      final JavaTypeFactory typeFactory =\n          (JavaTypeFactory) getCluster().getTypeFactory();\n      final BlockBuilder builder = new BlockBuilder();\n      final PhysType physType =\n          PhysTypeImpl.of(implementor.getTypeFactory(),\n              getRowType(),\n              JavaRowFormat.CUSTOM);\n      final Type rowClass = physType.getJavaRowType();\n\n      final List<Expression> expressions = new ArrayList<Expression>();\n      final List<RelDataTypeField> fields = rowType.getFieldList();\n      for (List<RexLiteral> tuple : tuples) {\n        final List<Expression> literals = new ArrayList<Expression>();\n        for (Pair<RelDataTypeField, RexLiteral> pair\n            : Pair.zip(fields, tuple)) {\n          literals.add(\n              RexToLixTranslator.translateLiteral(\n                  pair.right,\n                  pair.left.getType(),\n                  typeFactory,\n                  RexImpTable.NullAs.NULL));\n        }\n        expressions.add(physType.record(literals));\n      }\n      builder.add(\n          Expressions.return_(null,\n              Expressions.call(SparkMethod.ARRAY_TO_RDD.method,\n                  Expressions.call(SparkMethod.GET_SPARK_CONTEXT.method,\n                      implementor.getRootExpression()),\n                  Expressions.newArrayInit(Primitive.box(rowClass),\n                      expressions))));\n      return implementor.result(physType, builder.toBlock());\n    }\n","realPath":"spark/src/main/java/org/apache/calcite/adapter/spark/SparkRules.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":166,"status":"B"},{"authorDate":"2014-11-14 10:11:34","commitOrder":1,"curCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n\r\n\r\n\r\n\r\n\r\n\r\n\n    final JavaTypeFactory typeFactory =\n        (JavaTypeFactory) getCluster().getTypeFactory();\n    final BlockBuilder builder = new BlockBuilder();\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.preferCustom());\n    final Type rowClass = physType.getJavaRowType();\n\n    final List<Expression> expressions = new ArrayList<Expression>();\n    final List<RelDataTypeField> fields = rowType.getFieldList();\n    for (List<RexLiteral> tuple : tuples) {\n      final List<Expression> literals = new ArrayList<Expression>();\n      for (Pair<RelDataTypeField, RexLiteral> pair\n          : Pair.zip(fields, tuple)) {\n        literals.add(\n            RexToLixTranslator.translateLiteral(\n                pair.right,\n                pair.left.getType(),\n                typeFactory,\n                RexImpTable.NullAs.NULL));\n      }\n      expressions.add(physType.record(literals));\n    }\n    builder.add(\n        Expressions.return_(\n            null,\n            Expressions.call(\n                BuiltInMethod.AS_ENUMERABLE.method,\n                Expressions.newArrayInit(\n                    Primitive.box(rowClass), expressions))));\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2014-11-14 10:22:06","endLine":93,"groupId":"3225","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/36/504b1246027872d377eb557e92c42d2bd0af10.src","preCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n\r\n\r\n\r\n\r\n\r\n\r\n\n    final JavaTypeFactory typeFactory =\n        (JavaTypeFactory) getCluster().getTypeFactory();\n    final BlockBuilder builder = new BlockBuilder();\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.preferCustom());\n    final Type rowClass = physType.getJavaRowType();\n\n    final List<Expression> expressions = new ArrayList<Expression>();\n    final List<RelDataTypeField> fields = rowType.getFieldList();\n    for (List<RexLiteral> tuple : tuples) {\n      final List<Expression> literals = new ArrayList<Expression>();\n      for (Pair<RelDataTypeField, RexLiteral> pair\n          : Pair.zip(fields, tuple)) {\n        literals.add(\n            RexToLixTranslator.translateLiteral(\n                pair.right,\n                pair.left.getType(),\n                typeFactory,\n                RexImpTable.NullAs.NULL));\n      }\n      expressions.add(physType.record(literals));\n    }\n    builder.add(\n        Expressions.return_(\n            null,\n            Expressions.call(\n                BuiltInMethod.AS_ENUMERABLE.method,\n                Expressions.newArrayInit(\n                    Primitive.box(rowClass), expressions))));\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableValues.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":52,"status":"B"}],"commitId":"a0ba73cd2de76696b96a1cd828d2aa4d3ef9eb55","commitMessage":"@@@[CALCITE-306] Standardize code style for \"import package.*;\"\n\nRename classes and packages and generally fix things up after [CALCITE-296] and [CALCITE-419].\n\nMake many inner classes of EnumerableRules (e.g. EnumerableFilter.  EnumerableFilterRule) top-level classes.\n\nApply a consistent formatting convention for string literals split over multiple lines.\n\nRename generated file org.eigenbase.resource.Resources to org.apache.calcite.runtime.Resources.\n\nChange occurrences of \"optiq\" and \"eigenbase\" in java code to \"calcite\".\n","date":"2014-11-14 10:22:06","modifiedFileCount":"1156","status":"B","submitter":"Julian Hyde"},{"authorTime":"2018-09-16 20:24:07","codes":[{"authorDate":"2018-09-16 20:24:07","commitOrder":2,"curCode":"    public Result implementSpark(Implementor implementor) {\n\r\n\r\n\r\n\r\n\r\n\r\n\n      final JavaTypeFactory typeFactory =\n          (JavaTypeFactory) getCluster().getTypeFactory();\n      final BlockBuilder builder = new BlockBuilder();\n      final PhysType physType =\n          PhysTypeImpl.of(implementor.getTypeFactory(),\n              getRowType(),\n              JavaRowFormat.CUSTOM);\n      final Type rowClass = physType.getJavaRowType();\n\n      final List<Expression> expressions = new ArrayList<>();\n      final List<RelDataTypeField> fields = rowType.getFieldList();\n      for (List<RexLiteral> tuple : tuples) {\n        final List<Expression> literals = new ArrayList<>();\n        for (Pair<RelDataTypeField, RexLiteral> pair\n            : Pair.zip(fields, tuple)) {\n          literals.add(\n              RexToLixTranslator.translateLiteral(\n                  pair.right,\n                  pair.left.getType(),\n                  typeFactory,\n                  RexImpTable.NullAs.NULL));\n        }\n        expressions.add(physType.record(literals));\n      }\n      builder.add(\n          Expressions.return_(null,\n              Expressions.call(SparkMethod.ARRAY_TO_RDD.method,\n                  Expressions.call(SparkMethod.GET_SPARK_CONTEXT.method,\n                      implementor.getRootExpression()),\n                  Expressions.newArrayInit(Primitive.box(rowClass),\n                      expressions))));\n      return implementor.result(physType, builder.toBlock());\n    }\n","date":"2018-09-20 16:51:04","endLine":209,"groupId":"3166","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"implementSpark","params":"(Implementorimplementor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/53/cb7b216cbb6aa3458c2d278e3c071e10ea629e.src","preCode":"    public Result implementSpark(Implementor implementor) {\n\r\n\r\n\r\n\r\n\r\n\r\n\n      final JavaTypeFactory typeFactory =\n          (JavaTypeFactory) getCluster().getTypeFactory();\n      final BlockBuilder builder = new BlockBuilder();\n      final PhysType physType =\n          PhysTypeImpl.of(implementor.getTypeFactory(),\n              getRowType(),\n              JavaRowFormat.CUSTOM);\n      final Type rowClass = physType.getJavaRowType();\n\n      final List<Expression> expressions = new ArrayList<Expression>();\n      final List<RelDataTypeField> fields = rowType.getFieldList();\n      for (List<RexLiteral> tuple : tuples) {\n        final List<Expression> literals = new ArrayList<Expression>();\n        for (Pair<RelDataTypeField, RexLiteral> pair\n            : Pair.zip(fields, tuple)) {\n          literals.add(\n              RexToLixTranslator.translateLiteral(\n                  pair.right,\n                  pair.left.getType(),\n                  typeFactory,\n                  RexImpTable.NullAs.NULL));\n        }\n        expressions.add(physType.record(literals));\n      }\n      builder.add(\n          Expressions.return_(null,\n              Expressions.call(SparkMethod.ARRAY_TO_RDD.method,\n                  Expressions.call(SparkMethod.GET_SPARK_CONTEXT.method,\n                      implementor.getRootExpression()),\n                  Expressions.newArrayInit(Primitive.box(rowClass),\n                      expressions))));\n      return implementor.result(physType, builder.toBlock());\n    }\n","realPath":"spark/src/main/java/org/apache/calcite/adapter/spark/SparkRules.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":169,"status":"M"},{"authorDate":"2018-09-16 20:24:07","commitOrder":2,"curCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n\r\n\r\n\r\n\r\n\r\n\r\n\n    final JavaTypeFactory typeFactory =\n        (JavaTypeFactory) getCluster().getTypeFactory();\n    final BlockBuilder builder = new BlockBuilder();\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.preferCustom());\n    final Type rowClass = physType.getJavaRowType();\n\n    final List<Expression> expressions = new ArrayList<>();\n    final List<RelDataTypeField> fields = rowType.getFieldList();\n    for (List<RexLiteral> tuple : tuples) {\n      final List<Expression> literals = new ArrayList<>();\n      for (Pair<RelDataTypeField, RexLiteral> pair\n          : Pair.zip(fields, tuple)) {\n        literals.add(\n            RexToLixTranslator.translateLiteral(\n                pair.right,\n                pair.left.getType(),\n                typeFactory,\n                RexImpTable.NullAs.NULL));\n      }\n      expressions.add(physType.record(literals));\n    }\n    builder.add(\n        Expressions.return_(\n            null,\n            Expressions.call(\n                BuiltInMethod.AS_ENUMERABLE.method,\n                Expressions.newArrayInit(\n                    Primitive.box(rowClass), expressions))));\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2018-09-20 16:51:04","endLine":114,"groupId":"12680","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/82/b2f8717f18e764783eba9767f66643e1636c8e.src","preCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n\r\n\r\n\r\n\r\n\r\n\r\n\n    final JavaTypeFactory typeFactory =\n        (JavaTypeFactory) getCluster().getTypeFactory();\n    final BlockBuilder builder = new BlockBuilder();\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.preferCustom());\n    final Type rowClass = physType.getJavaRowType();\n\n    final List<Expression> expressions = new ArrayList<Expression>();\n    final List<RelDataTypeField> fields = rowType.getFieldList();\n    for (List<RexLiteral> tuple : tuples) {\n      final List<Expression> literals = new ArrayList<Expression>();\n      for (Pair<RelDataTypeField, RexLiteral> pair\n          : Pair.zip(fields, tuple)) {\n        literals.add(\n            RexToLixTranslator.translateLiteral(\n                pair.right,\n                pair.left.getType(),\n                typeFactory,\n                RexImpTable.NullAs.NULL));\n      }\n      expressions.add(physType.record(literals));\n    }\n    builder.add(\n        Expressions.return_(\n            null,\n            Expressions.call(\n                BuiltInMethod.AS_ENUMERABLE.method,\n                Expressions.newArrayInit(\n                    Primitive.box(rowClass), expressions))));\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableValues.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":73,"status":"M"}],"commitId":"295ab13e8338bdd0e0c29e051907371c9b2929aa","commitMessage":"@@@Apply small refactorings to Calcite codebase (Java 5.  Java 7.  Java 8)\n\nUse Objects.equals when possible\nReplace for with foreach in Mappings\nUse Java 7 diamond operator to reduce code verbosity\nCollapse identical catch blocks to multi-catch\nUse Double/Float/Long/Boolean hashCode from Java 8\nRemove unnecessary substring call arguments\nFix sqlTypeName -> SqlTypeName typo\nMake floorKey/ceilingKey non-static so their use in NameMap makes more sense\nNameMap uses COMPARATOR.floorKey(name) which is a bit weird when floorKey is static\nAdd @SafeVarargs to methods that are obviously safe\nReplace anonymous types with Java 8 lambdas\nUse Collection#removeIf when possible\nUse Integer.compare when possible\nSuppress AssertWithSideEffects warnings\nAdd missing check to Permutation#isValid\nPermutation#isValid had occurCount[target] != 0 check.  however the array was never updated.  so the check was useless.\nRemove duplicate keys from Strong#MAP\nReplace remove+add with set in ReduceExpressionsRule\nRemove redundant initializers\nMove dead code inside if (false) branch in org.apache.calcite.plan.volcano.RelSubset#add\nRevert removal of UtilTest#testHash\n\ncloses #834\n","date":"2018-09-20 16:51:04","modifiedFileCount":"130","status":"M","submitter":"Vladimir Sitnikov"},{"authorTime":"2020-09-29 22:09:05","codes":[{"authorDate":"2020-09-29 22:09:05","commitOrder":3,"curCode":"    @Override public Result implementSpark(Implementor implementor) {\n\r\n\r\n\r\n\r\n\r\n\r\n\n      final JavaTypeFactory typeFactory =\n          (JavaTypeFactory) getCluster().getTypeFactory();\n      final BlockBuilder builder = new BlockBuilder();\n      final PhysType physType =\n          PhysTypeImpl.of(implementor.getTypeFactory(),\n              getRowType(),\n              JavaRowFormat.CUSTOM);\n      final Type rowClass = physType.getJavaRowType();\n\n      final List<Expression> expressions = new ArrayList<>();\n      final List<RelDataTypeField> fields = rowType.getFieldList();\n      for (List<RexLiteral> tuple : tuples) {\n        final List<Expression> literals = new ArrayList<>();\n        for (Pair<RelDataTypeField, RexLiteral> pair\n            : Pair.zip(fields, tuple)) {\n          literals.add(\n              RexToLixTranslator.translateLiteral(\n                  pair.right,\n                  pair.left.getType(),\n                  typeFactory,\n                  RexImpTable.NullAs.NULL));\n        }\n        expressions.add(physType.record(literals));\n      }\n      builder.add(\n          Expressions.return_(null,\n              Expressions.call(SparkMethod.ARRAY_TO_RDD.method,\n                  Expressions.call(SparkMethod.GET_SPARK_CONTEXT.method,\n                      implementor.getRootExpression()),\n                  Expressions.newArrayInit(Primitive.box(rowClass),\n                      expressions))));\n      return implementor.result(physType, builder.toBlock());\n    }\n","date":"2020-10-07 05:42:47","endLine":238,"groupId":"3166","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"implementSpark","params":"(Implementorimplementor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/6c/ac1c0c0a2a72e80789a94d1c2302d36174a296.src","preCode":"    public Result implementSpark(Implementor implementor) {\n\r\n\r\n\r\n\r\n\r\n\r\n\n      final JavaTypeFactory typeFactory =\n          (JavaTypeFactory) getCluster().getTypeFactory();\n      final BlockBuilder builder = new BlockBuilder();\n      final PhysType physType =\n          PhysTypeImpl.of(implementor.getTypeFactory(),\n              getRowType(),\n              JavaRowFormat.CUSTOM);\n      final Type rowClass = physType.getJavaRowType();\n\n      final List<Expression> expressions = new ArrayList<>();\n      final List<RelDataTypeField> fields = rowType.getFieldList();\n      for (List<RexLiteral> tuple : tuples) {\n        final List<Expression> literals = new ArrayList<>();\n        for (Pair<RelDataTypeField, RexLiteral> pair\n            : Pair.zip(fields, tuple)) {\n          literals.add(\n              RexToLixTranslator.translateLiteral(\n                  pair.right,\n                  pair.left.getType(),\n                  typeFactory,\n                  RexImpTable.NullAs.NULL));\n        }\n        expressions.add(physType.record(literals));\n      }\n      builder.add(\n          Expressions.return_(null,\n              Expressions.call(SparkMethod.ARRAY_TO_RDD.method,\n                  Expressions.call(SparkMethod.GET_SPARK_CONTEXT.method,\n                      implementor.getRootExpression()),\n                  Expressions.newArrayInit(Primitive.box(rowClass),\n                      expressions))));\n      return implementor.result(physType, builder.toBlock());\n    }\n","realPath":"spark/src/main/java/org/apache/calcite/adapter/spark/SparkRules.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":198,"status":"M"},{"authorDate":"2020-09-29 22:09:05","commitOrder":3,"curCode":"  @Override public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n\r\n\r\n\r\n\r\n\r\n\r\n\n    final JavaTypeFactory typeFactory =\n        (JavaTypeFactory) getCluster().getTypeFactory();\n    final BlockBuilder builder = new BlockBuilder();\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.preferCustom());\n    final Type rowClass = physType.getJavaRowType();\n\n    final List<Expression> expressions = new ArrayList<>();\n    final List<RelDataTypeField> fields = rowType.getFieldList();\n    for (List<RexLiteral> tuple : tuples) {\n      final List<Expression> literals = new ArrayList<>();\n      for (Pair<RelDataTypeField, RexLiteral> pair\n          : Pair.zip(fields, tuple)) {\n        literals.add(\n            RexToLixTranslator.translateLiteral(\n                pair.right,\n                pair.left.getType(),\n                typeFactory,\n                RexImpTable.NullAs.NULL));\n      }\n      expressions.add(physType.record(literals));\n    }\n    builder.add(\n        Expressions.return_(\n            null,\n            Expressions.call(\n                BuiltInMethod.AS_ENUMERABLE.method,\n                Expressions.newArrayInit(\n                    Primitive.box(rowClass), expressions))));\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2020-10-07 05:42:47","endLine":151,"groupId":"12680","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/4a/624a8a4dad8faeb4009e2d080389a979590add.src","preCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n\r\n\r\n\r\n\r\n\r\n\r\n\n    final JavaTypeFactory typeFactory =\n        (JavaTypeFactory) getCluster().getTypeFactory();\n    final BlockBuilder builder = new BlockBuilder();\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.preferCustom());\n    final Type rowClass = physType.getJavaRowType();\n\n    final List<Expression> expressions = new ArrayList<>();\n    final List<RelDataTypeField> fields = rowType.getFieldList();\n    for (List<RexLiteral> tuple : tuples) {\n      final List<Expression> literals = new ArrayList<>();\n      for (Pair<RelDataTypeField, RexLiteral> pair\n          : Pair.zip(fields, tuple)) {\n        literals.add(\n            RexToLixTranslator.translateLiteral(\n                pair.right,\n                pair.left.getType(),\n                typeFactory,\n                RexImpTable.NullAs.NULL));\n      }\n      expressions.add(physType.record(literals));\n    }\n    builder.add(\n        Expressions.return_(\n            null,\n            Expressions.call(\n                BuiltInMethod.AS_ENUMERABLE.method,\n                Expressions.newArrayInit(\n                    Primitive.box(rowClass), expressions))));\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableValues.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":110,"status":"M"}],"commitId":"66caa54c5e272f8287ca132ca012733898a38768","commitMessage":"@@@[CALCITE-4314] Add missing @Override annotations\n","date":"2020-10-07 05:42:47","modifiedFileCount":"745","status":"M","submitter":"Vladimir Sitnikov"},{"authorTime":"2020-05-29 00:04:40","codes":[{"authorDate":"2020-09-29 22:09:05","commitOrder":4,"curCode":"    @Override public Result implementSpark(Implementor implementor) {\n\r\n\r\n\r\n\r\n\r\n\r\n\n      final JavaTypeFactory typeFactory =\n          (JavaTypeFactory) getCluster().getTypeFactory();\n      final BlockBuilder builder = new BlockBuilder();\n      final PhysType physType =\n          PhysTypeImpl.of(implementor.getTypeFactory(),\n              getRowType(),\n              JavaRowFormat.CUSTOM);\n      final Type rowClass = physType.getJavaRowType();\n\n      final List<Expression> expressions = new ArrayList<>();\n      final List<RelDataTypeField> fields = rowType.getFieldList();\n      for (List<RexLiteral> tuple : tuples) {\n        final List<Expression> literals = new ArrayList<>();\n        for (Pair<RelDataTypeField, RexLiteral> pair\n            : Pair.zip(fields, tuple)) {\n          literals.add(\n              RexToLixTranslator.translateLiteral(\n                  pair.right,\n                  pair.left.getType(),\n                  typeFactory,\n                  RexImpTable.NullAs.NULL));\n        }\n        expressions.add(physType.record(literals));\n      }\n      builder.add(\n          Expressions.return_(null,\n              Expressions.call(SparkMethod.ARRAY_TO_RDD.method,\n                  Expressions.call(SparkMethod.GET_SPARK_CONTEXT.method,\n                      implementor.getRootExpression()),\n                  Expressions.newArrayInit(Primitive.box(rowClass),\n                      expressions))));\n      return implementor.result(physType, builder.toBlock());\n    }\n","date":"2020-10-07 05:42:47","endLine":238,"groupId":"1213","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"implementSpark","params":"(Implementorimplementor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/6c/ac1c0c0a2a72e80789a94d1c2302d36174a296.src","preCode":"    @Override public Result implementSpark(Implementor implementor) {\n\r\n\r\n\r\n\r\n\r\n\r\n\n      final JavaTypeFactory typeFactory =\n          (JavaTypeFactory) getCluster().getTypeFactory();\n      final BlockBuilder builder = new BlockBuilder();\n      final PhysType physType =\n          PhysTypeImpl.of(implementor.getTypeFactory(),\n              getRowType(),\n              JavaRowFormat.CUSTOM);\n      final Type rowClass = physType.getJavaRowType();\n\n      final List<Expression> expressions = new ArrayList<>();\n      final List<RelDataTypeField> fields = rowType.getFieldList();\n      for (List<RexLiteral> tuple : tuples) {\n        final List<Expression> literals = new ArrayList<>();\n        for (Pair<RelDataTypeField, RexLiteral> pair\n            : Pair.zip(fields, tuple)) {\n          literals.add(\n              RexToLixTranslator.translateLiteral(\n                  pair.right,\n                  pair.left.getType(),\n                  typeFactory,\n                  RexImpTable.NullAs.NULL));\n        }\n        expressions.add(physType.record(literals));\n      }\n      builder.add(\n          Expressions.return_(null,\n              Expressions.call(SparkMethod.ARRAY_TO_RDD.method,\n                  Expressions.call(SparkMethod.GET_SPARK_CONTEXT.method,\n                      implementor.getRootExpression()),\n                  Expressions.newArrayInit(Primitive.box(rowClass),\n                      expressions))));\n      return implementor.result(physType, builder.toBlock());\n    }\n","realPath":"spark/src/main/java/org/apache/calcite/adapter/spark/SparkRules.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":198,"status":"N"},{"authorDate":"2020-05-29 00:04:40","commitOrder":4,"curCode":"  @Override public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n\r\n\r\n\r\n\r\n\r\n\r\n\n    final JavaTypeFactory typeFactory =\n        (JavaTypeFactory) getCluster().getTypeFactory();\n    final BlockBuilder builder = new BlockBuilder();\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.preferCustom());\n    final Type rowClass = physType.getJavaRowType();\n\n    final List<Expression> expressions = new ArrayList<>();\n    final List<RelDataTypeField> fields = getRowType().getFieldList();\n    for (List<RexLiteral> tuple : tuples) {\n      final List<Expression> literals = new ArrayList<>();\n      for (Pair<RelDataTypeField, RexLiteral> pair\n          : Pair.zip(fields, tuple)) {\n        literals.add(\n            RexToLixTranslator.translateLiteral(\n                pair.right,\n                pair.left.getType(),\n                typeFactory,\n                RexImpTable.NullAs.NULL));\n      }\n      expressions.add(physType.record(literals));\n    }\n    builder.add(\n        Expressions.return_(\n            null,\n            Expressions.call(\n                BuiltInMethod.AS_ENUMERABLE.method,\n                Expressions.newArrayInit(\n                    Primitive.box(rowClass), expressions))));\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2020-11-30 06:45:33","endLine":155,"groupId":"1213","id":8,"instanceNumber":2,"isCurCommit":1,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/c7/32d14319dd22cab627f469233523fe7707b0dd.src","preCode":"  @Override public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n\r\n\r\n\r\n\r\n\r\n\r\n\n    final JavaTypeFactory typeFactory =\n        (JavaTypeFactory) getCluster().getTypeFactory();\n    final BlockBuilder builder = new BlockBuilder();\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.preferCustom());\n    final Type rowClass = physType.getJavaRowType();\n\n    final List<Expression> expressions = new ArrayList<>();\n    final List<RelDataTypeField> fields = rowType.getFieldList();\n    for (List<RexLiteral> tuple : tuples) {\n      final List<Expression> literals = new ArrayList<>();\n      for (Pair<RelDataTypeField, RexLiteral> pair\n          : Pair.zip(fields, tuple)) {\n        literals.add(\n            RexToLixTranslator.translateLiteral(\n                pair.right,\n                pair.left.getType(),\n                typeFactory,\n                RexImpTable.NullAs.NULL));\n      }\n      expressions.add(physType.record(literals));\n    }\n    builder.add(\n        Expressions.return_(\n            null,\n            Expressions.call(\n                BuiltInMethod.AS_ENUMERABLE.method,\n                Expressions.newArrayInit(\n                    Primitive.box(rowClass), expressions))));\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableValues.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":114,"status":"M"}],"commitId":"d9a81b88ad561e7e4cedae93e805e0d7a53a7f1a","commitMessage":"@@@[CALCITE-4199] Add nullability annotations\n\nThe commit includes javadoc updates and refactorings made by Julian Hyde in https://github.com/apache/calcite/pull/2278\n","date":"2020-11-30 06:45:33","modifiedFileCount":"1012","status":"M","submitter":"Vladimir Sitnikov"}]
