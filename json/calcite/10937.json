[{"authorTime":"2017-07-28 06:52:51","codes":[{"authorDate":"2015-10-14 09:27:19","commitOrder":2,"curCode":"  public void checkMazeTableFunction(Boolean solution, String maze)\n      throws SQLException, ClassNotFoundException {\n    Connection connection = DriverManager.getConnection(\"jdbc:calcite:\");\n    CalciteConnection calciteConnection =\n        connection.unwrap(CalciteConnection.class);\n    SchemaPlus rootSchema = calciteConnection.getRootSchema();\n    SchemaPlus schema = rootSchema.add(\"s\", new AbstractSchema());\n    final TableFunction table = TableFunctionImpl.create(MAZE_METHOD);\n    schema.add(\"Maze\", table);\n    final TableFunction table2 = TableFunctionImpl.create(SOLVE_METHOD);\n    schema.add(\"Solve\", table2);\n    final String sql;\n    if (solution) {\n      sql = \"select *\\n\"\n          + \"from table(\\\"s\\\".\\\"Solve\\\"(5, 3, 1)) as t(s)\";\n    } else {\n      sql = \"select *\\n\"\n          + \"from table(\\\"s\\\".\\\"Maze\\\"(5, 3, 1)) as t(s)\";\n    }\n    ResultSet resultSet = connection.createStatement().executeQuery(sql);\n    final StringBuilder b = new StringBuilder();\n    while (resultSet.next()) {\n      b.append(resultSet.getString(1)).append(\"\\n\");\n    }\n    assertThat(b.toString(), is(maze));\n  }\n","date":"2015-10-14 09:27:19","endLine":102,"groupId":"1534","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"checkMazeTableFunction","params":"(Booleansolution@Stringmaze)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/5d/2726c14a3797714ea68b1c555bdcae0c59f217.src","preCode":"  public void checkMazeTableFunction(Boolean solution, String maze)\n      throws SQLException, ClassNotFoundException {\n    Connection connection = DriverManager.getConnection(\"jdbc:calcite:\");\n    CalciteConnection calciteConnection =\n        connection.unwrap(CalciteConnection.class);\n    SchemaPlus rootSchema = calciteConnection.getRootSchema();\n    SchemaPlus schema = rootSchema.add(\"s\", new AbstractSchema());\n    final TableFunction table = TableFunctionImpl.create(MAZE_METHOD);\n    schema.add(\"Maze\", table);\n    final TableFunction table2 = TableFunctionImpl.create(SOLVE_METHOD);\n    schema.add(\"Solve\", table2);\n    final String sql;\n    if (solution) {\n      sql = \"select *\\n\"\n          + \"from table(\\\"s\\\".\\\"Solve\\\"(5, 3, 1)) as t(s)\";\n    } else {\n      sql = \"select *\\n\"\n          + \"from table(\\\"s\\\".\\\"Maze\\\"(5, 3, 1)) as t(s)\";\n    }\n    ResultSet resultSet = connection.createStatement().executeQuery(sql);\n    final StringBuilder b = new StringBuilder();\n    while (resultSet.next()) {\n      b.append(resultSet.getString(1)).append(\"\\n\");\n    }\n    assertThat(b.toString(), is(maze));\n  }\n","realPath":"example/function/src/test/java/org/apache/calcite/test/ExampleFunctionTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":77,"status":"NB"},{"authorDate":"2017-07-28 06:52:51","commitOrder":2,"curCode":"  private Connection getConnectionWithMultiplyFunction()\n      throws ClassNotFoundException, SQLException {\n    Connection connection =\n        DriverManager.getConnection(\"jdbc:calcite:\");\n    CalciteConnection calciteConnection =\n        connection.unwrap(CalciteConnection.class);\n    SchemaPlus rootSchema = calciteConnection.getRootSchema();\n    SchemaPlus schema = rootSchema.add(\"s\", new AbstractSchema());\n    final TableFunction table =\n        TableFunctionImpl.create(Smalls.MULTIPLICATION_TABLE_METHOD);\n    schema.add(\"multiplication\", table);\n    return connection;\n  }\n","date":"2017-07-28 07:02:54","endLine":258,"groupId":"5637","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getConnectionWithMultiplyFunction","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/12/392b374dcf3019da6967e5fffbb8e034dc8ce3.src","preCode":"  private Connection getConnectionWithMultiplyFunction()\n      throws ClassNotFoundException, SQLException {\n    Connection connection =\n        DriverManager.getConnection(\"jdbc:calcite:\");\n    CalciteConnection calciteConnection =\n        connection.unwrap(CalciteConnection.class);\n    SchemaPlus rootSchema = calciteConnection.getRootSchema();\n    SchemaPlus schema = rootSchema.add(\"s\", new AbstractSchema());\n    final TableFunction table =\n        TableFunctionImpl.create(Smalls.MULTIPLICATION_TABLE_METHOD);\n    schema.add(\"multiplication\", table);\n    return connection;\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/TableFunctionTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":246,"status":"B"}],"commitId":"a473eca597300395ff89f949401505ec122a9774","commitMessage":"@@@[CALCITE-1907] Table function with 1 column gives ClassCastException\n\nCreate a new test class.  TableFunctionTest. Move some existing tests for\nuser-defined table functions from JdbcTest and UdfTest into\nTableFunctionTest.  and add some new ones.\n\nStdinTableFunction.  to be added in [CALCITE-1896].  also relies on this\nfix.\n","date":"2017-07-28 07:02:54","modifiedFileCount":"7","status":"M","submitter":"Julian Hyde"},{"authorTime":"2018-05-30 12:16:57","codes":[{"authorDate":"2015-10-14 09:27:19","commitOrder":3,"curCode":"  public void checkMazeTableFunction(Boolean solution, String maze)\n      throws SQLException, ClassNotFoundException {\n    Connection connection = DriverManager.getConnection(\"jdbc:calcite:\");\n    CalciteConnection calciteConnection =\n        connection.unwrap(CalciteConnection.class);\n    SchemaPlus rootSchema = calciteConnection.getRootSchema();\n    SchemaPlus schema = rootSchema.add(\"s\", new AbstractSchema());\n    final TableFunction table = TableFunctionImpl.create(MAZE_METHOD);\n    schema.add(\"Maze\", table);\n    final TableFunction table2 = TableFunctionImpl.create(SOLVE_METHOD);\n    schema.add(\"Solve\", table2);\n    final String sql;\n    if (solution) {\n      sql = \"select *\\n\"\n          + \"from table(\\\"s\\\".\\\"Solve\\\"(5, 3, 1)) as t(s)\";\n    } else {\n      sql = \"select *\\n\"\n          + \"from table(\\\"s\\\".\\\"Maze\\\"(5, 3, 1)) as t(s)\";\n    }\n    ResultSet resultSet = connection.createStatement().executeQuery(sql);\n    final StringBuilder b = new StringBuilder();\n    while (resultSet.next()) {\n      b.append(resultSet.getString(1)).append(\"\\n\");\n    }\n    assertThat(b.toString(), is(maze));\n  }\n","date":"2015-10-14 09:27:19","endLine":102,"groupId":"1534","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"checkMazeTableFunction","params":"(Booleansolution@Stringmaze)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/5d/2726c14a3797714ea68b1c555bdcae0c59f217.src","preCode":"  public void checkMazeTableFunction(Boolean solution, String maze)\n      throws SQLException, ClassNotFoundException {\n    Connection connection = DriverManager.getConnection(\"jdbc:calcite:\");\n    CalciteConnection calciteConnection =\n        connection.unwrap(CalciteConnection.class);\n    SchemaPlus rootSchema = calciteConnection.getRootSchema();\n    SchemaPlus schema = rootSchema.add(\"s\", new AbstractSchema());\n    final TableFunction table = TableFunctionImpl.create(MAZE_METHOD);\n    schema.add(\"Maze\", table);\n    final TableFunction table2 = TableFunctionImpl.create(SOLVE_METHOD);\n    schema.add(\"Solve\", table2);\n    final String sql;\n    if (solution) {\n      sql = \"select *\\n\"\n          + \"from table(\\\"s\\\".\\\"Solve\\\"(5, 3, 1)) as t(s)\";\n    } else {\n      sql = \"select *\\n\"\n          + \"from table(\\\"s\\\".\\\"Maze\\\"(5, 3, 1)) as t(s)\";\n    }\n    ResultSet resultSet = connection.createStatement().executeQuery(sql);\n    final StringBuilder b = new StringBuilder();\n    while (resultSet.next()) {\n      b.append(resultSet.getString(1)).append(\"\\n\");\n    }\n    assertThat(b.toString(), is(maze));\n  }\n","realPath":"example/function/src/test/java/org/apache/calcite/test/ExampleFunctionTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":77,"status":"N"},{"authorDate":"2018-05-30 12:16:57","commitOrder":3,"curCode":"  private Connection getConnectionWithMultiplyFunction() throws SQLException {\n    Connection connection =\n        DriverManager.getConnection(\"jdbc:calcite:\");\n    CalciteConnection calciteConnection =\n        connection.unwrap(CalciteConnection.class);\n    SchemaPlus rootSchema = calciteConnection.getRootSchema();\n    SchemaPlus schema = rootSchema.add(\"s\", new AbstractSchema());\n    final TableFunction table =\n        TableFunctionImpl.create(Smalls.MULTIPLICATION_TABLE_METHOD);\n    schema.add(\"multiplication\", table);\n    return connection;\n  }\n","date":"2019-08-29 17:01:46","endLine":259,"groupId":"5637","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getConnectionWithMultiplyFunction","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e9/d1f75826de6155e2f71c25e0b4455947c0865d.src","preCode":"  private Connection getConnectionWithMultiplyFunction()\n      throws ClassNotFoundException, SQLException {\n    Connection connection =\n        DriverManager.getConnection(\"jdbc:calcite:\");\n    CalciteConnection calciteConnection =\n        connection.unwrap(CalciteConnection.class);\n    SchemaPlus rootSchema = calciteConnection.getRootSchema();\n    SchemaPlus schema = rootSchema.add(\"s\", new AbstractSchema());\n    final TableFunction table =\n        TableFunctionImpl.create(Smalls.MULTIPLICATION_TABLE_METHOD);\n    schema.add(\"multiplication\", table);\n    return connection;\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/TableFunctionTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":248,"status":"M"}],"commitId":"01477c42ded991aaa7b14cf72a6e4ea1a20edf5e","commitMessage":"@@@[CALCITE-2302] Implicit type cast support\n\nChanges:\n* Support full implicit type coercion for SQL contexts:\nSet operation.  binary arithmetic exprs.  binary equality\nexprs.  binary comparison exprs.  case when(COALESCE). \nIN operation.  builtin functions.  user defined function(UDF);\n* The SqlValidator now takes a component named `TypeCoercion`\nresponsible for the coercion work.  you can turn off the coercion with\n`SqlValidator#setEnableTypeCoercion(false)`;\n* We follow PostgreSQL and SQL-SERVER conversion style for two integers division. \ni.e. `'9'/2` returns INTEGER 4.\n","date":"2019-08-29 17:01:46","modifiedFileCount":"50","status":"M","submitter":"yuzhao.cyz"},{"authorTime":"2018-05-30 12:16:57","codes":[{"authorDate":"2018-06-19 05:10:50","commitOrder":4,"curCode":"  public void checkMazeTableFunction(Boolean solution, String maze)\n      throws SQLException {\n    Connection connection = DriverManager.getConnection(\"jdbc:calcite:\");\n    CalciteConnection calciteConnection =\n        connection.unwrap(CalciteConnection.class);\n    SchemaPlus rootSchema = calciteConnection.getRootSchema();\n    SchemaPlus schema = rootSchema.add(\"s\", new AbstractSchema());\n    final TableFunction table = TableFunctionImpl.create(MAZE_METHOD);\n    schema.add(\"Maze\", table);\n    final TableFunction table2 = TableFunctionImpl.create(SOLVE_METHOD);\n    schema.add(\"Solve\", table2);\n    final String sql;\n    if (solution) {\n      sql = \"select *\\n\"\n          + \"from table(\\\"s\\\".\\\"Solve\\\"(5, 3, 1)) as t(s)\";\n    } else {\n      sql = \"select *\\n\"\n          + \"from table(\\\"s\\\".\\\"Maze\\\"(5, 3, 1)) as t(s)\";\n    }\n    ResultSet resultSet = connection.createStatement().executeQuery(sql);\n    final StringBuilder b = new StringBuilder();\n    while (resultSet.next()) {\n      b.append(resultSet.getString(1)).append(\"\\n\");\n    }\n    assertThat(b.toString(), is(maze));\n  }\n","date":"2020-07-29 03:09:43","endLine":102,"groupId":"10937","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"checkMazeTableFunction","params":"(Booleansolution@Stringmaze)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/f4/cc0eaec6887254203e82a40af7be6be7b6cae4.src","preCode":"  public void checkMazeTableFunction(Boolean solution, String maze)\n      throws SQLException, ClassNotFoundException {\n    Connection connection = DriverManager.getConnection(\"jdbc:calcite:\");\n    CalciteConnection calciteConnection =\n        connection.unwrap(CalciteConnection.class);\n    SchemaPlus rootSchema = calciteConnection.getRootSchema();\n    SchemaPlus schema = rootSchema.add(\"s\", new AbstractSchema());\n    final TableFunction table = TableFunctionImpl.create(MAZE_METHOD);\n    schema.add(\"Maze\", table);\n    final TableFunction table2 = TableFunctionImpl.create(SOLVE_METHOD);\n    schema.add(\"Solve\", table2);\n    final String sql;\n    if (solution) {\n      sql = \"select *\\n\"\n          + \"from table(\\\"s\\\".\\\"Solve\\\"(5, 3, 1)) as t(s)\";\n    } else {\n      sql = \"select *\\n\"\n          + \"from table(\\\"s\\\".\\\"Maze\\\"(5, 3, 1)) as t(s)\";\n    }\n    ResultSet resultSet = connection.createStatement().executeQuery(sql);\n    final StringBuilder b = new StringBuilder();\n    while (resultSet.next()) {\n      b.append(resultSet.getString(1)).append(\"\\n\");\n    }\n    assertThat(b.toString(), is(maze));\n  }\n","realPath":"example/function/src/test/java/org/apache/calcite/test/ExampleFunctionTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":77,"status":"M"},{"authorDate":"2018-05-30 12:16:57","commitOrder":4,"curCode":"  private Connection getConnectionWithMultiplyFunction() throws SQLException {\n    Connection connection =\n        DriverManager.getConnection(\"jdbc:calcite:\");\n    CalciteConnection calciteConnection =\n        connection.unwrap(CalciteConnection.class);\n    SchemaPlus rootSchema = calciteConnection.getRootSchema();\n    SchemaPlus schema = rootSchema.add(\"s\", new AbstractSchema());\n    final TableFunction table =\n        TableFunctionImpl.create(Smalls.MULTIPLICATION_TABLE_METHOD);\n    schema.add(\"multiplication\", table);\n    return connection;\n  }\n","date":"2019-08-29 17:01:46","endLine":259,"groupId":"10937","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"getConnectionWithMultiplyFunction","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e9/d1f75826de6155e2f71c25e0b4455947c0865d.src","preCode":"  private Connection getConnectionWithMultiplyFunction() throws SQLException {\n    Connection connection =\n        DriverManager.getConnection(\"jdbc:calcite:\");\n    CalciteConnection calciteConnection =\n        connection.unwrap(CalciteConnection.class);\n    SchemaPlus rootSchema = calciteConnection.getRootSchema();\n    SchemaPlus schema = rootSchema.add(\"s\", new AbstractSchema());\n    final TableFunction table =\n        TableFunctionImpl.create(Smalls.MULTIPLICATION_TABLE_METHOD);\n    schema.add(\"multiplication\", table);\n    return connection;\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/TableFunctionTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":248,"status":"N"}],"commitId":"19edf52c76c6a1507721f5bd37f2a33497aa0c4c","commitMessage":"@@@[CALCITE-2569] UDFs that are table functions must implement SqlTableFunction and have CURSOR as their return type\n\nValidate that table functions are not used in contexts that require\nscalar functions.  such as the SELECT clause.\n\nChange operand type ANY to mean 'scalar expression of any type (but\nnot a cursor)'.  and add operand type IGNORE to mean skip validation -\nfor an operand that is not an expression. TABLE is one of the few\noperators that accepts a CURSOR operand.\n\nAdd SqlKind.INTERVAL_QUALIFIER.\n","date":"2020-07-29 03:09:43","modifiedFileCount":"32","status":"M","submitter":"Julian Hyde"}]
