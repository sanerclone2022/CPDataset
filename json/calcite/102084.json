[{"authorTime":"2017-06-20 17:22:24","codes":[{"authorDate":"2020-01-11 19:49:04","commitOrder":10,"curCode":"  @Override public boolean matches(RelOptRuleCall call) {\n    \r\n    final SetOp topOp = call.rel(0);\n    @SuppressWarnings(\"unchecked\") final Class<? extends SetOp> setOpClass =\n        (Class<? extends SetOp>) operands.get(0).getMatchedClass();\n    final SetOp bottomOp;\n    if (setOpClass.isInstance(call.rel(2))\n        && !Minus.class.isAssignableFrom(setOpClass)) {\n      bottomOp = call.rel(2);\n    } else if (setOpClass.isInstance(call.rel(1))) {\n      bottomOp = call.rel(1);\n    } else {\n      return false;\n    }\n\n    if (topOp.all && !bottomOp.all) {\n      return false;\n    }\n\n    return true;\n  }\n","date":"2020-01-11 21:13:42","endLine":93,"groupId":"12488","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"matches","params":"(RelOptRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/34/ccb3f4b8b1d3932b9d6db9570c48a40c75e9dd.src","preCode":"  @Override public boolean matches(RelOptRuleCall call) {\n    \r\n    final SetOp topOp = call.rel(0);\n    @SuppressWarnings(\"unchecked\") final Class<? extends SetOp> setOpClass =\n        (Class<? extends SetOp>) operands.get(0).getMatchedClass();\n    final SetOp bottomOp;\n    if (setOpClass.isInstance(call.rel(2))\n        && !Minus.class.isAssignableFrom(setOpClass)) {\n      bottomOp = call.rel(2);\n    } else if (setOpClass.isInstance(call.rel(1))) {\n      bottomOp = call.rel(1);\n    } else {\n      return false;\n    }\n\n    if (topOp.all && !bottomOp.all) {\n      return false;\n    }\n\n    return true;\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/UnionMergeRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":73,"status":"B"},{"authorDate":"2017-06-20 17:22:24","commitOrder":10,"curCode":"  public void onMatch(RelOptRuleCall call) {\n    final SetOp topOp = call.rel(0);\n    @SuppressWarnings(\"unchecked\") final Class<? extends SetOp> setOpClass =\n        (Class) operands.get(0).getMatchedClass();\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final SetOp bottomOp;\n    if (setOpClass.isInstance(call.rel(2))\n        && !Minus.class.isAssignableFrom(setOpClass)) {\n      bottomOp = call.rel(2);\n    } else if (setOpClass.isInstance(call.rel(1))) {\n      bottomOp = call.rel(1);\n    } else {\n      return;\n    }\n\n    \r\n    \r\n    \r\n    if (topOp.all && !bottomOp.all) {\n      return;\n    }\n\n    \r\n    \r\n    final RelBuilder relBuilder = call.builder();\n    if (setOpClass.isInstance(call.rel(2))\n        && !Minus.class.isAssignableFrom(setOpClass)) {\n      relBuilder.push(topOp.getInput(0));\n      relBuilder.pushAll(bottomOp.getInputs());\n      \r\n      for (int index = 2; index < topOp.getInputs().size(); index++) {\n        relBuilder.push(topOp.getInput(index));\n      }\n    } else {\n      relBuilder.pushAll(bottomOp.getInputs());\n      relBuilder.pushAll(Util.skip(topOp.getInputs()));\n    }\n    int n = bottomOp.getInputs().size()\n        + topOp.getInputs().size()\n        - 1;\n    if (topOp instanceof Union) {\n      relBuilder.union(topOp.all, n);\n    } else if (topOp instanceof Intersect) {\n      relBuilder.intersect(topOp.all, n);\n    } else if (topOp instanceof Minus) {\n      relBuilder.minus(topOp.all, n);\n    }\n    call.transformTo(relBuilder.build());\n  }\n","date":"2017-06-20 18:12:37","endLine":141,"groupId":"12489","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"onMatch","params":"(RelOptRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/20/fbcd94abfef8900e0ba1c24584c50306a8c101.src","preCode":"  public void onMatch(RelOptRuleCall call) {\n    final SetOp topOp = call.rel(0);\n    @SuppressWarnings(\"unchecked\") final Class<? extends SetOp> setOpClass =\n        (Class) operands.get(0).getMatchedClass();\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final SetOp bottomOp;\n    if (setOpClass.isInstance(call.rel(2))\n        && !Minus.class.isAssignableFrom(setOpClass)) {\n      bottomOp = call.rel(2);\n    } else if (setOpClass.isInstance(call.rel(1))) {\n      bottomOp = call.rel(1);\n    } else {\n      return;\n    }\n\n    \r\n    \r\n    \r\n    if (topOp.all && !bottomOp.all) {\n      return;\n    }\n\n    \r\n    \r\n    final RelBuilder relBuilder = call.builder();\n    if (setOpClass.isInstance(call.rel(2))\n        && !Minus.class.isAssignableFrom(setOpClass)) {\n      relBuilder.push(topOp.getInput(0));\n      relBuilder.pushAll(bottomOp.getInputs());\n      \r\n      for (int index = 2; index < topOp.getInputs().size(); index++) {\n        relBuilder.push(topOp.getInput(index));\n      }\n    } else {\n      relBuilder.pushAll(bottomOp.getInputs());\n      relBuilder.pushAll(Util.skip(topOp.getInputs()));\n    }\n    int n = bottomOp.getInputs().size()\n        + topOp.getInputs().size()\n        - 1;\n    if (topOp instanceof Union) {\n      relBuilder.union(topOp.all, n);\n    } else if (topOp instanceof Intersect) {\n      relBuilder.intersect(topOp.all, n);\n    } else if (topOp instanceof Minus) {\n      relBuilder.minus(topOp.all, n);\n    }\n    call.transformTo(relBuilder.build());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/UnionMergeRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":73,"status":"NB"}],"commitId":"e387deddb0cce39f5827de8744645286b2cb1d7f","commitMessage":"@@@Refine rules so they produce less no-op matches\n\nUnionMergeRule produced lots of unrelated matches because it\nmatched only the top operand as SetOp.\nBottom operand classes were compared in onMatch method only.  so\nit resulted in lots of false positives for the optimizer.\n\nNot it does not get added to the optimizer queue at all.\n","date":"2020-01-11 21:13:42","modifiedFileCount":"4","status":"M","submitter":"Vladimir Sitnikov"},{"authorTime":"2020-07-09 05:31:40","codes":[{"authorDate":"2020-01-11 19:49:04","commitOrder":11,"curCode":"  @Override public boolean matches(RelOptRuleCall call) {\n    \r\n    final SetOp topOp = call.rel(0);\n    @SuppressWarnings(\"unchecked\") final Class<? extends SetOp> setOpClass =\n        (Class<? extends SetOp>) operands.get(0).getMatchedClass();\n    final SetOp bottomOp;\n    if (setOpClass.isInstance(call.rel(2))\n        && !Minus.class.isAssignableFrom(setOpClass)) {\n      bottomOp = call.rel(2);\n    } else if (setOpClass.isInstance(call.rel(1))) {\n      bottomOp = call.rel(1);\n    } else {\n      return false;\n    }\n\n    if (topOp.all && !bottomOp.all) {\n      return false;\n    }\n\n    return true;\n  }\n","date":"2020-01-11 21:13:42","endLine":93,"groupId":"102084","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"matches","params":"(RelOptRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/34/ccb3f4b8b1d3932b9d6db9570c48a40c75e9dd.src","preCode":"  @Override public boolean matches(RelOptRuleCall call) {\n    \r\n    final SetOp topOp = call.rel(0);\n    @SuppressWarnings(\"unchecked\") final Class<? extends SetOp> setOpClass =\n        (Class<? extends SetOp>) operands.get(0).getMatchedClass();\n    final SetOp bottomOp;\n    if (setOpClass.isInstance(call.rel(2))\n        && !Minus.class.isAssignableFrom(setOpClass)) {\n      bottomOp = call.rel(2);\n    } else if (setOpClass.isInstance(call.rel(1))) {\n      bottomOp = call.rel(1);\n    } else {\n      return false;\n    }\n\n    if (topOp.all && !bottomOp.all) {\n      return false;\n    }\n\n    return true;\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/UnionMergeRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":73,"status":"N"},{"authorDate":"2020-07-09 05:31:40","commitOrder":11,"curCode":"  @Override public void onMatch(RelOptRuleCall call) {\n    final SetOp topOp = call.rel(0);\n    @SuppressWarnings(\"unchecked\") final Class<? extends SetOp> setOpClass =\n        (Class) operands.get(0).getMatchedClass();\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final SetOp bottomOp;\n    if (setOpClass.isInstance(call.rel(2))\n        && !Minus.class.isAssignableFrom(setOpClass)) {\n      bottomOp = call.rel(2);\n    } else if (setOpClass.isInstance(call.rel(1))) {\n      bottomOp = call.rel(1);\n    } else {\n      return;\n    }\n\n    \r\n    \r\n    \r\n    if (topOp.all && !bottomOp.all) {\n      return;\n    }\n\n    \r\n    \r\n    final RelBuilder relBuilder = call.builder();\n    if (setOpClass.isInstance(call.rel(2))\n        && !Minus.class.isAssignableFrom(setOpClass)) {\n      relBuilder.push(topOp.getInput(0));\n      relBuilder.pushAll(bottomOp.getInputs());\n      \r\n      for (int index = 2; index < topOp.getInputs().size(); index++) {\n        relBuilder.push(topOp.getInput(index));\n      }\n    } else {\n      relBuilder.pushAll(bottomOp.getInputs());\n      relBuilder.pushAll(Util.skip(topOp.getInputs()));\n    }\n    int n = bottomOp.getInputs().size()\n        + topOp.getInputs().size()\n        - 1;\n    if (topOp instanceof Union) {\n      relBuilder.union(topOp.all, n);\n    } else if (topOp instanceof Intersect) {\n      relBuilder.intersect(topOp.all, n);\n    } else if (topOp instanceof Minus) {\n      relBuilder.minus(topOp.all, n);\n    }\n    call.transformTo(relBuilder.build());\n  }\n","date":"2020-07-29 02:27:24","endLine":160,"groupId":"102084","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"onMatch","params":"(RelOptRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/95/c9ca46de0b7297a251993d75ca8c6e988df044.src","preCode":"  public void onMatch(RelOptRuleCall call) {\n    final SetOp topOp = call.rel(0);\n    @SuppressWarnings(\"unchecked\") final Class<? extends SetOp> setOpClass =\n        (Class) operands.get(0).getMatchedClass();\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final SetOp bottomOp;\n    if (setOpClass.isInstance(call.rel(2))\n        && !Minus.class.isAssignableFrom(setOpClass)) {\n      bottomOp = call.rel(2);\n    } else if (setOpClass.isInstance(call.rel(1))) {\n      bottomOp = call.rel(1);\n    } else {\n      return;\n    }\n\n    \r\n    \r\n    \r\n    if (topOp.all && !bottomOp.all) {\n      return;\n    }\n\n    \r\n    \r\n    final RelBuilder relBuilder = call.builder();\n    if (setOpClass.isInstance(call.rel(2))\n        && !Minus.class.isAssignableFrom(setOpClass)) {\n      relBuilder.push(topOp.getInput(0));\n      relBuilder.pushAll(bottomOp.getInputs());\n      \r\n      for (int index = 2; index < topOp.getInputs().size(); index++) {\n        relBuilder.push(topOp.getInput(index));\n      }\n    } else {\n      relBuilder.pushAll(bottomOp.getInputs());\n      relBuilder.pushAll(Util.skip(topOp.getInputs()));\n    }\n    int n = bottomOp.getInputs().size()\n        + topOp.getInputs().size()\n        - 1;\n    if (topOp instanceof Union) {\n      relBuilder.union(topOp.all, n);\n    } else if (topOp instanceof Intersect) {\n      relBuilder.intersect(topOp.all, n);\n    } else if (topOp instanceof Minus) {\n      relBuilder.minus(topOp.all, n);\n    }\n    call.transformTo(relBuilder.build());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/UnionMergeRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":92,"status":"M"}],"commitId":"998cd83ebe2fcd7ff3ee565299fed6e199269715","commitMessage":"@@@[CALCITE-3923] Refactor how planner rules are parameterized\n\nCreate operands using a builder interface.  OperandBuilder.  and\ndeprecate methods RelOptRule.operand etc.\n\nThe change is backwards compatible.  in the sense that\nexisting rule constructors are deprecated but still work.\nFrom now on.  to create rules.  call RelOptRule.Config.toRule()\n(which calls the rule's (Config) constructor).\n\nSub-classes of ConverterRule are a little different.  They\ndon't need their own sub-class of Config.  You just need to\ncall Config.withRuleFactory to specify the constructor of the\nsub-class of ConverterRule.\n\nMove rule instances into holder classes such as CoreRules. \nMaterializedViewRules. Deprecate existing rule INSTANCE fields\n(to be removed in 1.25). Deprecate previous rule constructors\n(to be removed in 2.0).\n\nDescribe how to write rules in howto and tutorial.\n\nRemove rule instances marked 'deprecated.  to be removed before\n1.25'.\n\nClose apache/calcite#2024\n","date":"2020-07-29 02:27:24","modifiedFileCount":"191","status":"M","submitter":"Julian Hyde"}]
