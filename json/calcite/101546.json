[{"authorTime":"2018-08-28 15:30:07","codes":[{"authorDate":"2018-08-28 15:30:07","commitOrder":1,"curCode":"  @Test public void testUnparseInStruct1() {\n    final RexNode condition =\n        builder.call(SqlStdOperatorTable.IN,\n            builder.call(SqlStdOperatorTable.ROW, builder.field(\"DEPTNO\"),\n                builder.field(\"JOB\")),\n            builder.call(SqlStdOperatorTable.ROW, builder.literal(1),\n                builder.literal(\"PRESIDENT\")));\n    final String sql = unparseRelTree(empScan.filter(condition).build());\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE ROW(\\\"DEPTNO\\\", \\\"JOB\\\") IN (ROW(1, 'PRESIDENT'))\";\n    assertThat(sql, is(expectedSql));\n  }\n","date":"2018-09-18 00:43:03","endLine":422,"groupId":"5791","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnparseInStruct1","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/c3/c724e1ed484270383ed1e48a855318bdcc350c.src","preCode":"  @Test public void testUnparseInStruct1() {\n    final RexNode condition =\n        builder.call(SqlStdOperatorTable.IN,\n            builder.call(SqlStdOperatorTable.ROW, builder.field(\"DEPTNO\"),\n                builder.field(\"JOB\")),\n            builder.call(SqlStdOperatorTable.ROW, builder.literal(1),\n                builder.literal(\"PRESIDENT\")));\n    final String sql = unparseRelTree(empScan.filter(condition).build());\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE ROW(\\\"DEPTNO\\\", \\\"JOB\\\") IN (ROW(1, 'PRESIDENT'))\";\n    assertThat(sql, is(expectedSql));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":410,"status":"B"},{"authorDate":"2018-08-28 15:30:07","commitOrder":1,"curCode":"  @Test public void testUnparseInStruct2() {\n    final RexNode condition =\n        builder.call(SqlStdOperatorTable.IN,\n            builder.call(SqlStdOperatorTable.ROW, builder.field(\"DEPTNO\"),\n                builder.field(\"JOB\")),\n            builder.call(SqlStdOperatorTable.ROW, builder.literal(1),\n                builder.literal(\"PRESIDENT\")),\n            builder.call(SqlStdOperatorTable.ROW, builder.literal(2),\n                builder.literal(\"PRESIDENT\")));\n    final String sql = unparseRelTree(empScan.filter(condition).build());\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE ROW(\\\"DEPTNO\\\", \\\"JOB\\\") IN (ROW(1, 'PRESIDENT'), ROW(2, 'PRESIDENT'))\";\n    assertThat(sql, is(expectedSql));\n  }\n","date":"2018-09-18 00:43:03","endLine":438,"groupId":"5791","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnparseInStruct2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/c3/c724e1ed484270383ed1e48a855318bdcc350c.src","preCode":"  @Test public void testUnparseInStruct2() {\n    final RexNode condition =\n        builder.call(SqlStdOperatorTable.IN,\n            builder.call(SqlStdOperatorTable.ROW, builder.field(\"DEPTNO\"),\n                builder.field(\"JOB\")),\n            builder.call(SqlStdOperatorTable.ROW, builder.literal(1),\n                builder.literal(\"PRESIDENT\")),\n            builder.call(SqlStdOperatorTable.ROW, builder.literal(2),\n                builder.literal(\"PRESIDENT\")));\n    final String sql = unparseRelTree(empScan.filter(condition).build());\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE ROW(\\\"DEPTNO\\\", \\\"JOB\\\") IN (ROW(1, 'PRESIDENT'), ROW(2, 'PRESIDENT'))\";\n    assertThat(sql, is(expectedSql));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":424,"status":"B"}],"commitId":"37a6f9f4f85d59185225e8883df74ffa8ca94c1b","commitMessage":"@@@[CALCITE-2444] Handle IN expressions when converting SqlNode to SQL (Zoltan Haindrich)\n\nPreviously RelToSqlConverter could not handle IN expressions because\nit never saw them: SqlToRelConverter had converted them to OR.  and if\nan IN expression had been created internally - say via RelBuilder -\nRelToSqlConverter would throw a ClassCastException.\n\nNow we convert IN expressions to \"IN\" SQL.  as you would expect.\n\nClose apache/calcite#805\n","date":"2018-09-18 00:43:03","modifiedFileCount":"2","status":"B","submitter":"Zoltan Haindrich"},{"authorTime":"2018-09-18 17:16:19","codes":[{"authorDate":"2018-09-18 17:16:19","commitOrder":2,"curCode":"  @Test public void testUnparseInStruct1() {\n    final RexNode condition =\n        builder.call(SqlStdOperatorTable.IN,\n            builder.call(SqlStdOperatorTable.ROW, builder.field(\"DEPTNO\"),\n                builder.field(\"JOB\")),\n            builder.call(SqlStdOperatorTable.ROW, builder.literal(1),\n                builder.literal(\"PRESIDENT\")));\n    final String sql = unparseRelTree(empScan.filter(condition).build());\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE ROW(\\\"DEPTNO\\\", \\\"JOB\\\") IN (ROW(1, 'PRESIDENT'))\";\n    assertThat(sql, isLinux(expectedSql));\n  }\n","date":"2018-09-20 11:11:29","endLine":422,"groupId":"5791","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnparseInStruct1","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e9/a37bd9146d723a10793bc463320cf78c32a6fb.src","preCode":"  @Test public void testUnparseInStruct1() {\n    final RexNode condition =\n        builder.call(SqlStdOperatorTable.IN,\n            builder.call(SqlStdOperatorTable.ROW, builder.field(\"DEPTNO\"),\n                builder.field(\"JOB\")),\n            builder.call(SqlStdOperatorTable.ROW, builder.literal(1),\n                builder.literal(\"PRESIDENT\")));\n    final String sql = unparseRelTree(empScan.filter(condition).build());\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE ROW(\\\"DEPTNO\\\", \\\"JOB\\\") IN (ROW(1, 'PRESIDENT'))\";\n    assertThat(sql, is(expectedSql));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":410,"status":"M"},{"authorDate":"2018-09-18 17:16:19","commitOrder":2,"curCode":"  @Test public void testUnparseInStruct2() {\n    final RexNode condition =\n        builder.call(SqlStdOperatorTable.IN,\n            builder.call(SqlStdOperatorTable.ROW, builder.field(\"DEPTNO\"),\n                builder.field(\"JOB\")),\n            builder.call(SqlStdOperatorTable.ROW, builder.literal(1),\n                builder.literal(\"PRESIDENT\")),\n            builder.call(SqlStdOperatorTable.ROW, builder.literal(2),\n                builder.literal(\"PRESIDENT\")));\n    final String sql = unparseRelTree(empScan.filter(condition).build());\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE ROW(\\\"DEPTNO\\\", \\\"JOB\\\") IN (ROW(1, 'PRESIDENT'), ROW(2, 'PRESIDENT'))\";\n    assertThat(sql, isLinux(expectedSql));\n  }\n","date":"2018-09-20 11:11:29","endLine":438,"groupId":"5791","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnparseInStruct2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e9/a37bd9146d723a10793bc463320cf78c32a6fb.src","preCode":"  @Test public void testUnparseInStruct2() {\n    final RexNode condition =\n        builder.call(SqlStdOperatorTable.IN,\n            builder.call(SqlStdOperatorTable.ROW, builder.field(\"DEPTNO\"),\n                builder.field(\"JOB\")),\n            builder.call(SqlStdOperatorTable.ROW, builder.literal(1),\n                builder.literal(\"PRESIDENT\")),\n            builder.call(SqlStdOperatorTable.ROW, builder.literal(2),\n                builder.literal(\"PRESIDENT\")));\n    final String sql = unparseRelTree(empScan.filter(condition).build());\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE ROW(\\\"DEPTNO\\\", \\\"JOB\\\") IN (ROW(1, 'PRESIDENT'), ROW(2, 'PRESIDENT'))\";\n    assertThat(sql, is(expectedSql));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":424,"status":"M"}],"commitId":"19826da5bae2b390ea0cdbb060d2d3f1e28c07ac","commitMessage":"@@@Fix Windows tests broken by [CALCITE-2444] Handle IN expressions when converting SqlNode to SQL (Zoltan Haindrich)\n\nClose apache/calcite#837\n","date":"2018-09-20 11:11:29","modifiedFileCount":"1","status":"M","submitter":"Zoltan Haindrich"},{"authorTime":"2018-10-17 09:47:44","codes":[{"authorDate":"2018-10-17 09:47:44","commitOrder":3,"curCode":"  @Test public void testUnparseInStruct1() {\n    final RelBuilder builder = relBuilder().scan(\"EMP\");\n    final RexNode condition =\n        builder.call(SqlStdOperatorTable.IN,\n            builder.call(SqlStdOperatorTable.ROW, builder.field(\"DEPTNO\"),\n                builder.field(\"JOB\")),\n            builder.call(SqlStdOperatorTable.ROW, builder.literal(1),\n                builder.literal(\"PRESIDENT\")));\n    final RelNode root = relBuilder().scan(\"EMP\").filter(condition).build();\n    final String sql = toSql(root);\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE ROW(\\\"DEPTNO\\\", \\\"JOB\\\") IN (ROW(1, 'PRESIDENT'))\";\n    assertThat(sql, isLinux(expectedSql));\n  }\n","date":"2018-10-25 14:04:46","endLine":475,"groupId":"15951","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnparseInStruct1","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/7e/5115842871c6c3b4273e514149109fdf78a071.src","preCode":"  @Test public void testUnparseInStruct1() {\n    final RexNode condition =\n        builder.call(SqlStdOperatorTable.IN,\n            builder.call(SqlStdOperatorTable.ROW, builder.field(\"DEPTNO\"),\n                builder.field(\"JOB\")),\n            builder.call(SqlStdOperatorTable.ROW, builder.literal(1),\n                builder.literal(\"PRESIDENT\")));\n    final String sql = unparseRelTree(empScan.filter(condition).build());\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE ROW(\\\"DEPTNO\\\", \\\"JOB\\\") IN (ROW(1, 'PRESIDENT'))\";\n    assertThat(sql, isLinux(expectedSql));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":461,"status":"M"},{"authorDate":"2018-10-17 09:47:44","commitOrder":3,"curCode":"  @Test public void testUnparseInStruct2() {\n    final RelBuilder builder = relBuilder().scan(\"EMP\");\n    final RexNode condition =\n        builder.call(SqlStdOperatorTable.IN,\n            builder.call(SqlStdOperatorTable.ROW, builder.field(\"DEPTNO\"),\n                builder.field(\"JOB\")),\n            builder.call(SqlStdOperatorTable.ROW, builder.literal(1),\n                builder.literal(\"PRESIDENT\")),\n            builder.call(SqlStdOperatorTable.ROW, builder.literal(2),\n                builder.literal(\"PRESIDENT\")));\n    final RelNode root = relBuilder().scan(\"EMP\").filter(condition).build();\n    final String sql = toSql(root);\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE ROW(\\\"DEPTNO\\\", \\\"JOB\\\") IN (ROW(1, 'PRESIDENT'), ROW(2, 'PRESIDENT'))\";\n    assertThat(sql, isLinux(expectedSql));\n  }\n","date":"2018-10-25 14:04:46","endLine":493,"groupId":"16118","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnparseInStruct2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/7e/5115842871c6c3b4273e514149109fdf78a071.src","preCode":"  @Test public void testUnparseInStruct2() {\n    final RexNode condition =\n        builder.call(SqlStdOperatorTable.IN,\n            builder.call(SqlStdOperatorTable.ROW, builder.field(\"DEPTNO\"),\n                builder.field(\"JOB\")),\n            builder.call(SqlStdOperatorTable.ROW, builder.literal(1),\n                builder.literal(\"PRESIDENT\")),\n            builder.call(SqlStdOperatorTable.ROW, builder.literal(2),\n                builder.literal(\"PRESIDENT\")));\n    final String sql = unparseRelTree(empScan.filter(condition).build());\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE ROW(\\\"DEPTNO\\\", \\\"JOB\\\") IN (ROW(1, 'PRESIDENT'), ROW(2, 'PRESIDENT'))\";\n    assertThat(sql, isLinux(expectedSql));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":477,"status":"M"}],"commitId":"784372debb2b51c3041c0d5b420a6f93a2457a16","commitMessage":"@@@[CALCITE-2628] JDBC adapter throws NullPointerException while generating GROUP BY query for MySQL\n\nAlso.  refactor RelToSqlConverterTest a little.\n","date":"2018-10-25 14:04:46","modifiedFileCount":"2","status":"M","submitter":"Julian Hyde"},{"authorTime":"2020-02-21 10:29:14","codes":[{"authorDate":"2020-02-21 10:29:14","commitOrder":4,"curCode":"  @Test public void testUnparseInStruct1() {\n    final Function<RelBuilder, RelNode> relFn = b ->\n        b.scan(\"EMP\")\n            .filter(\n                b.call(SqlStdOperatorTable.IN,\n                    b.call(SqlStdOperatorTable.ROW,\n                        b.field(\"DEPTNO\"), b.field(\"JOB\")),\n                    b.call(SqlStdOperatorTable.ROW, b.literal(1),\n                        b.literal(\"PRESIDENT\"))))\n            .build();\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE ROW(\\\"DEPTNO\\\", \\\"JOB\\\") IN (ROW(1, 'PRESIDENT'))\";\n    relFn(relFn).ok(expectedSql);\n  }\n","date":"2020-02-22 01:55:43","endLine":1221,"groupId":"3662","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnparseInStruct1","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/d2/8abea1fd2182ece1feb8d73e94b8b494b4d043.src","preCode":"  @Test public void testUnparseInStruct1() {\n    final RelBuilder builder = relBuilder().scan(\"EMP\");\n    final RexNode condition =\n        builder.call(SqlStdOperatorTable.IN,\n            builder.call(SqlStdOperatorTable.ROW, builder.field(\"DEPTNO\"),\n                builder.field(\"JOB\")),\n            builder.call(SqlStdOperatorTable.ROW, builder.literal(1),\n                builder.literal(\"PRESIDENT\")));\n    final RelNode root = relBuilder().scan(\"EMP\").filter(condition).build();\n    final String sql = toSql(root);\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE ROW(\\\"DEPTNO\\\", \\\"JOB\\\") IN (ROW(1, 'PRESIDENT'))\";\n    assertThat(sql, isLinux(expectedSql));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1207,"status":"M"},{"authorDate":"2020-02-21 10:29:14","commitOrder":4,"curCode":"  @Test public void testUnparseInStruct2() {\n    final Function<RelBuilder, RelNode> relFn = b ->\n        b.scan(\"EMP\")\n            .filter(\n                b.call(SqlStdOperatorTable.IN,\n                    b.call(SqlStdOperatorTable.ROW,\n                        b.field(\"DEPTNO\"), b.field(\"JOB\")),\n                    b.call(SqlStdOperatorTable.ROW, b.literal(1),\n                b.literal(\"PRESIDENT\")),\n                    b.call(SqlStdOperatorTable.ROW, b.literal(2),\n                        b.literal(\"PRESIDENT\"))))\n            .build();\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE ROW(\\\"DEPTNO\\\", \\\"JOB\\\") IN (ROW(1, 'PRESIDENT'), ROW(2, 'PRESIDENT'))\";\n    relFn(relFn).ok(expectedSql);\n  }\n","date":"2020-02-22 01:55:43","endLine":1239,"groupId":"3662","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnparseInStruct2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/d2/8abea1fd2182ece1feb8d73e94b8b494b4d043.src","preCode":"  @Test public void testUnparseInStruct2() {\n    final RelBuilder builder = relBuilder().scan(\"EMP\");\n    final RexNode condition =\n        builder.call(SqlStdOperatorTable.IN,\n            builder.call(SqlStdOperatorTable.ROW, builder.field(\"DEPTNO\"),\n                builder.field(\"JOB\")),\n            builder.call(SqlStdOperatorTable.ROW, builder.literal(1),\n                builder.literal(\"PRESIDENT\")),\n            builder.call(SqlStdOperatorTable.ROW, builder.literal(2),\n                builder.literal(\"PRESIDENT\")));\n    final RelNode root = relBuilder().scan(\"EMP\").filter(condition).build();\n    final String sql = toSql(root);\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE ROW(\\\"DEPTNO\\\", \\\"JOB\\\") IN (ROW(1, 'PRESIDENT'), ROW(2, 'PRESIDENT'))\";\n    assertThat(sql, isLinux(expectedSql));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1223,"status":"M"}],"commitId":"6d974f1b23bdca566d01cb7cbb1ec46d7ef5e84c","commitMessage":"@@@Refactor RelToSqlConverterTest\n\nMake test cases that use RelBuilder fluent.  like test cases that use SQL.\n","date":"2020-02-22 01:55:43","modifiedFileCount":"2","status":"M","submitter":"Julian Hyde"},{"authorTime":"2020-04-02 10:39:10","codes":[{"authorDate":"2020-04-02 10:39:10","commitOrder":5,"curCode":"  @Test void testUnparseInStruct1() {\n    final Function<RelBuilder, RelNode> relFn = b ->\n        b.scan(\"EMP\")\n            .filter(\n                b.call(SqlStdOperatorTable.IN,\n                    b.call(SqlStdOperatorTable.ROW,\n                        b.field(\"DEPTNO\"), b.field(\"JOB\")),\n                    b.call(SqlStdOperatorTable.ROW, b.literal(1),\n                        b.literal(\"PRESIDENT\"))))\n            .build();\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE ROW(\\\"DEPTNO\\\", \\\"JOB\\\") IN (ROW(1, 'PRESIDENT'))\";\n    relFn(relFn).ok(expectedSql);\n  }\n","date":"2020-04-06 04:57:49","endLine":1384,"groupId":"3662","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnparseInStruct1","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/a7/568223fb7dbbd6fb8b19514d3893973975f662.src","preCode":"  @Test public void testUnparseInStruct1() {\n    final Function<RelBuilder, RelNode> relFn = b ->\n        b.scan(\"EMP\")\n            .filter(\n                b.call(SqlStdOperatorTable.IN,\n                    b.call(SqlStdOperatorTable.ROW,\n                        b.field(\"DEPTNO\"), b.field(\"JOB\")),\n                    b.call(SqlStdOperatorTable.ROW, b.literal(1),\n                        b.literal(\"PRESIDENT\"))))\n            .build();\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE ROW(\\\"DEPTNO\\\", \\\"JOB\\\") IN (ROW(1, 'PRESIDENT'))\";\n    relFn(relFn).ok(expectedSql);\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1370,"status":"M"},{"authorDate":"2020-04-02 10:39:10","commitOrder":5,"curCode":"  @Test void testUnparseInStruct2() {\n    final Function<RelBuilder, RelNode> relFn = b ->\n        b.scan(\"EMP\")\n            .filter(\n                b.call(SqlStdOperatorTable.IN,\n                    b.call(SqlStdOperatorTable.ROW,\n                        b.field(\"DEPTNO\"), b.field(\"JOB\")),\n                    b.call(SqlStdOperatorTable.ROW, b.literal(1),\n                b.literal(\"PRESIDENT\")),\n                    b.call(SqlStdOperatorTable.ROW, b.literal(2),\n                        b.literal(\"PRESIDENT\"))))\n            .build();\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE ROW(\\\"DEPTNO\\\", \\\"JOB\\\") IN (ROW(1, 'PRESIDENT'), ROW(2, 'PRESIDENT'))\";\n    relFn(relFn).ok(expectedSql);\n  }\n","date":"2020-04-06 04:57:49","endLine":1402,"groupId":"3662","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnparseInStruct2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/a7/568223fb7dbbd6fb8b19514d3893973975f662.src","preCode":"  @Test public void testUnparseInStruct2() {\n    final Function<RelBuilder, RelNode> relFn = b ->\n        b.scan(\"EMP\")\n            .filter(\n                b.call(SqlStdOperatorTable.IN,\n                    b.call(SqlStdOperatorTable.ROW,\n                        b.field(\"DEPTNO\"), b.field(\"JOB\")),\n                    b.call(SqlStdOperatorTable.ROW, b.literal(1),\n                b.literal(\"PRESIDENT\")),\n                    b.call(SqlStdOperatorTable.ROW, b.literal(2),\n                        b.literal(\"PRESIDENT\"))))\n            .build();\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE ROW(\\\"DEPTNO\\\", \\\"JOB\\\") IN (ROW(1, 'PRESIDENT'), ROW(2, 'PRESIDENT'))\";\n    relFn(relFn).ok(expectedSql);\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1386,"status":"M"}],"commitId":"9492dd4146f63ddc028010d6c4e86f6a5cb29a8d","commitMessage":"@@@[CALCITE-3892] Make junit test classes and methods non-public where possible\n\nPrior to junit 5.  classes and methods had to be public. This is no\nlonger the case.\n\nSome classes need to remain public because they are referenced from\nelsewhere.  or if they use reflection somehow. The remaining 'public'\nkeyword will be informative to maintainers.\n","date":"2020-04-06 04:57:49","modifiedFileCount":"196","status":"M","submitter":"Julian Hyde"},{"authorTime":"2020-08-13 15:59:15","codes":[{"authorDate":"2020-08-13 15:59:15","commitOrder":6,"curCode":"  @Test void testUnparseInStruct1() {\n    final Function<RelBuilder, RelNode> relFn = b ->\n        b.scan(\"EMP\")\n            .filter(\n                b.in(\n                    b.call(SqlStdOperatorTable.ROW,\n                        b.field(\"DEPTNO\"), b.field(\"JOB\")),\n                    b.call(SqlStdOperatorTable.ROW, b.literal(1),\n                        b.literal(\"PRESIDENT\"))))\n            .build();\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE ROW(\\\"DEPTNO\\\", \\\"JOB\\\") = ROW(1, 'PRESIDENT')\";\n    relFn(relFn).ok(expectedSql);\n  }\n","date":"2020-09-05 00:58:49","endLine":1482,"groupId":"101546","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnparseInStruct1","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/71/df0dec66d409be480715d898d5ea0bcd1a8bc9.src","preCode":"  @Test void testUnparseInStruct1() {\n    final Function<RelBuilder, RelNode> relFn = b ->\n        b.scan(\"EMP\")\n            .filter(\n                b.call(SqlStdOperatorTable.IN,\n                    b.call(SqlStdOperatorTable.ROW,\n                        b.field(\"DEPTNO\"), b.field(\"JOB\")),\n                    b.call(SqlStdOperatorTable.ROW, b.literal(1),\n                        b.literal(\"PRESIDENT\"))))\n            .build();\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE ROW(\\\"DEPTNO\\\", \\\"JOB\\\") IN (ROW(1, 'PRESIDENT'))\";\n    relFn(relFn).ok(expectedSql);\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1468,"status":"M"},{"authorDate":"2020-08-13 15:59:15","commitOrder":6,"curCode":"  @Test void testUnparseInStruct2() {\n    final Function<RelBuilder, RelNode> relFn = b ->\n        b.scan(\"EMP\")\n            .filter(\n                b.in(\n                    b.call(SqlStdOperatorTable.ROW,\n                        b.field(\"DEPTNO\"), b.field(\"JOB\")),\n                    b.call(SqlStdOperatorTable.ROW, b.literal(1),\n                        b.literal(\"PRESIDENT\")),\n                    b.call(SqlStdOperatorTable.ROW, b.literal(2),\n                        b.literal(\"PRESIDENT\"))))\n            .build();\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE ROW(\\\"DEPTNO\\\", \\\"JOB\\\") IN (ROW(1, 'PRESIDENT'), ROW(2, 'PRESIDENT'))\";\n    relFn(relFn).ok(expectedSql);\n  }\n","date":"2020-09-05 00:58:49","endLine":1500,"groupId":"101546","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnparseInStruct2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/71/df0dec66d409be480715d898d5ea0bcd1a8bc9.src","preCode":"  @Test void testUnparseInStruct2() {\n    final Function<RelBuilder, RelNode> relFn = b ->\n        b.scan(\"EMP\")\n            .filter(\n                b.call(SqlStdOperatorTable.IN,\n                    b.call(SqlStdOperatorTable.ROW,\n                        b.field(\"DEPTNO\"), b.field(\"JOB\")),\n                    b.call(SqlStdOperatorTable.ROW, b.literal(1),\n                b.literal(\"PRESIDENT\")),\n                    b.call(SqlStdOperatorTable.ROW, b.literal(2),\n                        b.literal(\"PRESIDENT\"))))\n            .build();\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE ROW(\\\"DEPTNO\\\", \\\"JOB\\\") IN (ROW(1, 'PRESIDENT'), ROW(2, 'PRESIDENT'))\";\n    relFn(relFn).ok(expectedSql);\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1484,"status":"M"}],"commitId":"850f0f4a04fc2399b8fd1c1fed532cd8e1e39514","commitMessage":"@@@[CALCITE-4173] Add internal SEARCH operator and Sarg literal that represents a set of values or ranges\n\nObsolete use of IN in RexCall; in Druid.  replace some uses\nwith DRUID_IN operator.\n\nCreate Sarg instances during RexSimplify of AND.  OR. Also\nduring simplify.  strengthen Sarg.containsNull from true to\nfalse if predicates prove that NULL values are impossible.\n\nIn JDBC adapter we handle SEARCH natively.  but in Geode. \nMongoDB and Spark adapters.  expand SEARCH before translating\nto target query language. Later.  it may be better to handle\nSEARCH explicitly. For instance.  it will be easier to recognize\nexpressions that can be translated to Geode's 'IN SET'\nconstruct.\n\nClose apache/calcite#2124\n","date":"2020-09-05 00:58:49","modifiedFileCount":"44","status":"M","submitter":"Julian Hyde"}]
