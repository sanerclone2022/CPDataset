[{"authorTime":"2019-08-05 21:28:29","codes":[{"authorDate":"2016-06-28 14:57:41","commitOrder":2,"curCode":"  public int getMinScale() {\n    switch (this) {\n    \r\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      return MIN_INTERVAL_FRACTIONAL_SECOND_PRECISION;\n    default:\n      return -1;\n    }\n  }\n","date":"2016-07-02 02:11:10","endLine":788,"groupId":"9088","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"getMinScale","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/f5/5f9b929bd2862fb7fe2f15538b744383be5f0c.src","preCode":"  public int getMinScale() {\n    switch (this) {\n    \r\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      return MIN_INTERVAL_FRACTIONAL_SECOND_PRECISION;\n    default:\n      return -1;\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/type/SqlTypeName.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":768,"status":"NB"},{"authorDate":"2019-08-05 21:28:29","commitOrder":2,"curCode":"    @Override Expression implementSafe(final RexToLixTranslator translator,\n        final RexCall call, final List<Expression> argValueList) {\n      final TimeUnitRange timeUnitRange =\n          (TimeUnitRange) translator.getLiteralValue(argValueList.get(0));\n      final TimeUnit unit = timeUnitRange.startUnit;\n      Expression operand = argValueList.get(1);\n      final SqlTypeName sqlTypeName =\n          call.operands.get(1).getType().getSqlTypeName();\n      switch (unit) {\n      case MILLENNIUM:\n      case CENTURY:\n      case YEAR:\n      case QUARTER:\n      case MONTH:\n      case DAY:\n      case DOW:\n      case DECADE:\n      case DOY:\n      case ISODOW:\n      case ISOYEAR:\n      case WEEK:\n        switch (sqlTypeName) {\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          break;\n        case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n          operand = Expressions.call(\n              BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, translator.getRoot()));\n          \r\n        case TIMESTAMP:\n          operand = Expressions.call(BuiltInMethod.FLOOR_DIV.method,\n              operand, Expressions.constant(TimeUnit.DAY.multiplier.longValue()));\n          \r\n        case DATE:\n          return Expressions.call(BuiltInMethod.UNIX_DATE_EXTRACT.method,\n              argValueList.get(0), operand);\n        default:\n          throw new AssertionError(\"unexpected \" + sqlTypeName);\n        }\n        break;\n      case MILLISECOND:\n      case MICROSECOND:\n      case NANOSECOND:\n        if (sqlTypeName == SqlTypeName.DATE) {\n          return Expressions.constant(0L);\n        }\n        operand = mod(operand, TimeUnit.MINUTE.multiplier.longValue());\n        return Expressions.multiply(\n            operand, Expressions.constant((long) (1 / unit.multiplier.doubleValue())));\n      case EPOCH:\n        switch (sqlTypeName) {\n        case DATE:\n          \r\n          operand = Expressions.multiply(operand,\n              Expressions.constant(TimeUnit.DAY.multiplier.longValue()));\n          \r\n        case TIMESTAMP:\n          \r\n          return Expressions.divide(operand,\n              Expressions.constant(TimeUnit.SECOND.multiplier.longValue()));\n        case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n          operand = Expressions.call(\n              BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, translator.getRoot()));\n          return Expressions.divide(operand,\n              Expressions.constant(TimeUnit.SECOND.multiplier.longValue()));\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          \r\n          throw new AssertionError(\"unexpected \" + sqlTypeName);\n        }\n        break;\n      case HOUR:\n      case MINUTE:\n      case SECOND:\n        switch (sqlTypeName) {\n        case DATE:\n          return Expressions.multiply(operand, Expressions.constant(0L));\n        }\n        break;\n      }\n\n      operand = mod(operand, getFactor(unit));\n      if (unit == TimeUnit.QUARTER) {\n        operand = Expressions.subtract(operand, Expressions.constant(1L));\n      }\n      operand = Expressions.divide(operand,\n          Expressions.constant(unit.multiplier.longValue()));\n      if (unit == TimeUnit.QUARTER) {\n        operand = Expressions.add(operand, Expressions.constant(1L));\n      }\n      return operand;\n    }\n","date":"2020-06-26 14:19:13","endLine":2316,"groupId":"8140","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"implementSafe","params":"(finalRexToLixTranslatortranslator@finalRexCallcall@finalList<Expression>argValueList)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e0/457e95186624c2bd9540162a894a9efe4588a6.src","preCode":"    @Override Expression implementSafe(final RexToLixTranslator translator,\n        final RexCall call, final List<Expression> argValueList) {\n      final TimeUnitRange timeUnitRange =\n          (TimeUnitRange) translator.getLiteralValue(argValueList.get(0));\n      final TimeUnit unit = timeUnitRange.startUnit;\n      Expression operand = argValueList.get(1);\n      final SqlTypeName sqlTypeName =\n          call.operands.get(1).getType().getSqlTypeName();\n      switch (unit) {\n      case MILLENNIUM:\n      case CENTURY:\n      case YEAR:\n      case QUARTER:\n      case MONTH:\n      case DAY:\n      case DOW:\n      case DECADE:\n      case DOY:\n      case ISODOW:\n      case ISOYEAR:\n      case WEEK:\n        switch (sqlTypeName) {\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          break;\n        case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n          operand = Expressions.call(\n              BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, translator.getRoot()));\n          \r\n        case TIMESTAMP:\n          operand = Expressions.call(BuiltInMethod.FLOOR_DIV.method,\n              operand, Expressions.constant(TimeUnit.DAY.multiplier.longValue()));\n          \r\n        case DATE:\n          return Expressions.call(BuiltInMethod.UNIX_DATE_EXTRACT.method,\n              argValueList.get(0), operand);\n        default:\n          throw new AssertionError(\"unexpected \" + sqlTypeName);\n        }\n        break;\n      case MILLISECOND:\n      case MICROSECOND:\n      case NANOSECOND:\n        if (sqlTypeName == SqlTypeName.DATE) {\n          return Expressions.constant(0L);\n        }\n        operand = mod(operand, TimeUnit.MINUTE.multiplier.longValue());\n        return Expressions.multiply(\n            operand, Expressions.constant((long) (1 / unit.multiplier.doubleValue())));\n      case EPOCH:\n        switch (sqlTypeName) {\n        case DATE:\n          \r\n          operand = Expressions.multiply(operand,\n              Expressions.constant(TimeUnit.DAY.multiplier.longValue()));\n          \r\n        case TIMESTAMP:\n          \r\n          return Expressions.divide(operand,\n              Expressions.constant(TimeUnit.SECOND.multiplier.longValue()));\n        case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n          operand = Expressions.call(\n              BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, translator.getRoot()));\n          return Expressions.divide(operand,\n              Expressions.constant(TimeUnit.SECOND.multiplier.longValue()));\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          \r\n          throw new AssertionError(\"unexpected \" + sqlTypeName);\n        }\n        break;\n      case HOUR:\n      case MINUTE:\n      case SECOND:\n        switch (sqlTypeName) {\n        case DATE:\n          return Expressions.multiply(operand, Expressions.constant(0L));\n        }\n        break;\n      }\n\n      operand = mod(operand, getFactor(unit));\n      if (unit == TimeUnit.QUARTER) {\n        operand = Expressions.subtract(operand, Expressions.constant(1L));\n      }\n      operand = Expressions.divide(operand,\n          Expressions.constant(unit.multiplier.longValue()));\n      if (unit == TimeUnit.QUARTER) {\n        operand = Expressions.add(operand, Expressions.constant(1L));\n      }\n      return operand;\n    }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":2199,"status":"B"}],"commitId":"dae53ef7917c46f6d5593477b2ef81b16427c541","commitMessage":"@@@[CALCITE-3224] New implementation of RexNode-to-Expression code generation\n\nFixes various issues where.  due to common sub-expression\nelimination.  a guarded value would be accessed before the\ncondition had been evaluated. For example.  division-by-zero\noccurs if the quotient is computed before the zero check.\n\nIssues fixed:\n * [CALCITE-3142] NullPointerException when rounding a\n   nullable numeric\n * [CALCITE-3143] Dividing by NULLIF may cause\n   \"ArithmeticException: Division by zero\"\n * [CALCITE-3150] NullPointerException when UPPER is repeated\n   and combined with LIKE\n * [CALCITE-3717] Dividing by nullable numeric throws\n   \"ArithmeticException: Division by zero\"\n\nRestore type to RexCall.equals.  necessary to distinguish CAST calls (a\nbug introduced by [CALCITE-3786]).\n\nClose apache/calcite#1347\n","date":"2020-06-26 14:19:13","modifiedFileCount":"10","status":"M","submitter":"wellfengzhu"},{"authorTime":"2020-09-30 01:31:14","codes":[{"authorDate":"2016-06-28 14:57:41","commitOrder":3,"curCode":"  public int getMinScale() {\n    switch (this) {\n    \r\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      return MIN_INTERVAL_FRACTIONAL_SECOND_PRECISION;\n    default:\n      return -1;\n    }\n  }\n","date":"2016-07-02 02:11:10","endLine":788,"groupId":"9088","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"getMinScale","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/f5/5f9b929bd2862fb7fe2f15538b744383be5f0c.src","preCode":"  public int getMinScale() {\n    switch (this) {\n    \r\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      return MIN_INTERVAL_FRACTIONAL_SECOND_PRECISION;\n    default:\n      return -1;\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/type/SqlTypeName.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":768,"status":"N"},{"authorDate":"2020-09-30 01:31:14","commitOrder":3,"curCode":"    @Override Expression implementSafe(final RexToLixTranslator translator,\n        final RexCall call, final List<Expression> argValueList) {\n      final TimeUnitRange timeUnitRange =\n          (TimeUnitRange) translator.getLiteralValue(argValueList.get(0));\n      final TimeUnit unit = timeUnitRange.startUnit;\n      Expression operand = argValueList.get(1);\n      final SqlTypeName sqlTypeName =\n          call.operands.get(1).getType().getSqlTypeName();\n      switch (unit) {\n      case MILLENNIUM:\n      case CENTURY:\n      case YEAR:\n      case QUARTER:\n      case MONTH:\n      case DAY:\n      case DOW:\n      case DECADE:\n      case DOY:\n      case ISODOW:\n      case ISOYEAR:\n      case WEEK:\n        switch (sqlTypeName) {\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          break;\n        case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n          operand = Expressions.call(\n              BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, translator.getRoot()));\n          \r\n        case TIMESTAMP:\n          operand = Expressions.call(BuiltInMethod.FLOOR_DIV.method,\n              operand, Expressions.constant(TimeUnit.DAY.multiplier.longValue()));\n          \r\n        case DATE:\n          return Expressions.call(BuiltInMethod.UNIX_DATE_EXTRACT.method,\n              argValueList.get(0), operand);\n        default:\n          throw new AssertionError(\"unexpected \" + sqlTypeName);\n        }\n        break;\n      case MILLISECOND:\n      case MICROSECOND:\n      case NANOSECOND:\n        if (sqlTypeName == SqlTypeName.DATE) {\n          return Expressions.constant(0L);\n        }\n        operand = mod(operand, TimeUnit.MINUTE.multiplier.longValue());\n        return Expressions.multiply(\n            operand, Expressions.constant((long) (1 / unit.multiplier.doubleValue())));\n      case EPOCH:\n        switch (sqlTypeName) {\n        case DATE:\n          \r\n          operand = Expressions.multiply(operand,\n              Expressions.constant(TimeUnit.DAY.multiplier.longValue()));\n          \r\n        case TIMESTAMP:\n          \r\n          return Expressions.divide(operand,\n              Expressions.constant(TimeUnit.SECOND.multiplier.longValue()));\n        case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n          operand = Expressions.call(\n              BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, translator.getRoot()));\n          return Expressions.divide(operand,\n              Expressions.constant(TimeUnit.SECOND.multiplier.longValue()));\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          \r\n          throw new AssertionError(\"unexpected \" + sqlTypeName);\n        default:\n          break;\n        }\n        break;\n      case HOUR:\n      case MINUTE:\n      case SECOND:\n        switch (sqlTypeName) {\n        case DATE:\n          return Expressions.multiply(operand, Expressions.constant(0L));\n        default:\n          break;\n        }\n        break;\n      }\n\n      operand = mod(operand, getFactor(unit));\n      if (unit == TimeUnit.QUARTER) {\n        operand = Expressions.subtract(operand, Expressions.constant(1L));\n      }\n      operand = Expressions.divide(operand,\n          Expressions.constant(unit.multiplier.longValue()));\n      if (unit == TimeUnit.QUARTER) {\n        operand = Expressions.add(operand, Expressions.constant(1L));\n      }\n      return operand;\n    }\n","date":"2020-10-07 05:43:06","endLine":2362,"groupId":"8140","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"implementSafe","params":"(finalRexToLixTranslatortranslator@finalRexCallcall@finalList<Expression>argValueList)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/82/8ed066eedec77069d14d918310e957cc8c39f2.src","preCode":"    @Override Expression implementSafe(final RexToLixTranslator translator,\n        final RexCall call, final List<Expression> argValueList) {\n      final TimeUnitRange timeUnitRange =\n          (TimeUnitRange) translator.getLiteralValue(argValueList.get(0));\n      final TimeUnit unit = timeUnitRange.startUnit;\n      Expression operand = argValueList.get(1);\n      final SqlTypeName sqlTypeName =\n          call.operands.get(1).getType().getSqlTypeName();\n      switch (unit) {\n      case MILLENNIUM:\n      case CENTURY:\n      case YEAR:\n      case QUARTER:\n      case MONTH:\n      case DAY:\n      case DOW:\n      case DECADE:\n      case DOY:\n      case ISODOW:\n      case ISOYEAR:\n      case WEEK:\n        switch (sqlTypeName) {\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          break;\n        case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n          operand = Expressions.call(\n              BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, translator.getRoot()));\n          \r\n        case TIMESTAMP:\n          operand = Expressions.call(BuiltInMethod.FLOOR_DIV.method,\n              operand, Expressions.constant(TimeUnit.DAY.multiplier.longValue()));\n          \r\n        case DATE:\n          return Expressions.call(BuiltInMethod.UNIX_DATE_EXTRACT.method,\n              argValueList.get(0), operand);\n        default:\n          throw new AssertionError(\"unexpected \" + sqlTypeName);\n        }\n        break;\n      case MILLISECOND:\n      case MICROSECOND:\n      case NANOSECOND:\n        if (sqlTypeName == SqlTypeName.DATE) {\n          return Expressions.constant(0L);\n        }\n        operand = mod(operand, TimeUnit.MINUTE.multiplier.longValue());\n        return Expressions.multiply(\n            operand, Expressions.constant((long) (1 / unit.multiplier.doubleValue())));\n      case EPOCH:\n        switch (sqlTypeName) {\n        case DATE:\n          \r\n          operand = Expressions.multiply(operand,\n              Expressions.constant(TimeUnit.DAY.multiplier.longValue()));\n          \r\n        case TIMESTAMP:\n          \r\n          return Expressions.divide(operand,\n              Expressions.constant(TimeUnit.SECOND.multiplier.longValue()));\n        case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n          operand = Expressions.call(\n              BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, translator.getRoot()));\n          return Expressions.divide(operand,\n              Expressions.constant(TimeUnit.SECOND.multiplier.longValue()));\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          \r\n          throw new AssertionError(\"unexpected \" + sqlTypeName);\n        }\n        break;\n      case HOUR:\n      case MINUTE:\n      case SECOND:\n        switch (sqlTypeName) {\n        case DATE:\n          return Expressions.multiply(operand, Expressions.constant(0L));\n        }\n        break;\n      }\n\n      operand = mod(operand, getFactor(unit));\n      if (unit == TimeUnit.QUARTER) {\n        operand = Expressions.subtract(operand, Expressions.constant(1L));\n      }\n      operand = Expressions.divide(operand,\n          Expressions.constant(unit.multiplier.longValue()));\n      if (unit == TimeUnit.QUARTER) {\n        operand = Expressions.add(operand, Expressions.constant(1L));\n      }\n      return operand;\n    }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":2241,"status":"M"}],"commitId":"1b94f37e888cf2d186362473529e6c147afe0f6e","commitMessage":"@@@[CALCITE-4314] Add missing default branches to switch statement\n\nNote: the changes are mechanical.\nThe intention is to keep the previous behavior and prevent adding new\nnon exchaustive switch statements in the future.\n\nSee https://errorprone.info/bugpattern/MissingCasesInEnumSwitch\n","date":"2020-10-07 05:43:06","modifiedFileCount":"98","status":"M","submitter":"Vladimir Sitnikov"},{"authorTime":"2020-05-29 00:04:40","codes":[{"authorDate":"2016-06-28 14:57:41","commitOrder":4,"curCode":"  public int getMinScale() {\n    switch (this) {\n    \r\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      return MIN_INTERVAL_FRACTIONAL_SECOND_PRECISION;\n    default:\n      return -1;\n    }\n  }\n","date":"2016-07-02 02:11:10","endLine":788,"groupId":"121815","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"getMinScale","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/f5/5f9b929bd2862fb7fe2f15538b744383be5f0c.src","preCode":"  public int getMinScale() {\n    switch (this) {\n    \r\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      return MIN_INTERVAL_FRACTIONAL_SECOND_PRECISION;\n    default:\n      return -1;\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/type/SqlTypeName.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":768,"status":"N"},{"authorDate":"2020-05-29 00:04:40","commitOrder":4,"curCode":"    @Override Expression implementSafe(final RexToLixTranslator translator,\n        final RexCall call, final List<Expression> argValueList) {\n      final TimeUnitRange timeUnitRange =\n          (TimeUnitRange) translator.getLiteralValue(argValueList.get(0));\n      final TimeUnit unit = requireNonNull(timeUnitRange, \"timeUnitRange\").startUnit;\n      Expression operand = argValueList.get(1);\n      final SqlTypeName sqlTypeName =\n          call.operands.get(1).getType().getSqlTypeName();\n      switch (unit) {\n      case MILLENNIUM:\n      case CENTURY:\n      case YEAR:\n      case QUARTER:\n      case MONTH:\n      case DAY:\n      case DOW:\n      case DECADE:\n      case DOY:\n      case ISODOW:\n      case ISOYEAR:\n      case WEEK:\n        switch (sqlTypeName) {\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          break;\n        case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n          operand = Expressions.call(\n              BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, translator.getRoot()));\n          \r\n        case TIMESTAMP:\n          operand = Expressions.call(BuiltInMethod.FLOOR_DIV.method,\n              operand, Expressions.constant(TimeUnit.DAY.multiplier.longValue()));\n          \r\n        case DATE:\n          return Expressions.call(BuiltInMethod.UNIX_DATE_EXTRACT.method,\n              argValueList.get(0), operand);\n        default:\n          throw new AssertionError(\"unexpected \" + sqlTypeName);\n        }\n        break;\n      case MILLISECOND:\n      case MICROSECOND:\n      case NANOSECOND:\n        if (sqlTypeName == SqlTypeName.DATE) {\n          return Expressions.constant(0L);\n        }\n        operand = mod(operand, TimeUnit.MINUTE.multiplier.longValue());\n        return Expressions.multiply(\n            operand, Expressions.constant((long) (1 / unit.multiplier.doubleValue())));\n      case EPOCH:\n        switch (sqlTypeName) {\n        case DATE:\n          \r\n          operand = Expressions.multiply(operand,\n              Expressions.constant(TimeUnit.DAY.multiplier.longValue()));\n          \r\n        case TIMESTAMP:\n          \r\n          return Expressions.divide(operand,\n              Expressions.constant(TimeUnit.SECOND.multiplier.longValue()));\n        case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n          operand = Expressions.call(\n              BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, translator.getRoot()));\n          return Expressions.divide(operand,\n              Expressions.constant(TimeUnit.SECOND.multiplier.longValue()));\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          \r\n          throw new AssertionError(\"unexpected \" + sqlTypeName);\n        default:\n          break;\n        }\n        break;\n      case HOUR:\n      case MINUTE:\n      case SECOND:\n        switch (sqlTypeName) {\n        case DATE:\n          return Expressions.multiply(operand, Expressions.constant(0L));\n        default:\n          break;\n        }\n        break;\n      }\n\n      operand = mod(operand, getFactor(unit));\n      if (unit == TimeUnit.QUARTER) {\n        operand = Expressions.subtract(operand, Expressions.constant(1L));\n      }\n      operand = Expressions.divide(operand,\n          Expressions.constant(unit.multiplier.longValue()));\n      if (unit == TimeUnit.QUARTER) {\n        operand = Expressions.add(operand, Expressions.constant(1L));\n      }\n      return operand;\n    }\n","date":"2020-11-30 06:45:33","endLine":2391,"groupId":"121815","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"implementSafe","params":"(finalRexToLixTranslatortranslator@finalRexCallcall@finalList<Expression>argValueList)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/42/aae7e106e89f2be0ba56c3bb8a2c1cd31ed0e0.src","preCode":"    @Override Expression implementSafe(final RexToLixTranslator translator,\n        final RexCall call, final List<Expression> argValueList) {\n      final TimeUnitRange timeUnitRange =\n          (TimeUnitRange) translator.getLiteralValue(argValueList.get(0));\n      final TimeUnit unit = timeUnitRange.startUnit;\n      Expression operand = argValueList.get(1);\n      final SqlTypeName sqlTypeName =\n          call.operands.get(1).getType().getSqlTypeName();\n      switch (unit) {\n      case MILLENNIUM:\n      case CENTURY:\n      case YEAR:\n      case QUARTER:\n      case MONTH:\n      case DAY:\n      case DOW:\n      case DECADE:\n      case DOY:\n      case ISODOW:\n      case ISOYEAR:\n      case WEEK:\n        switch (sqlTypeName) {\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          break;\n        case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n          operand = Expressions.call(\n              BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, translator.getRoot()));\n          \r\n        case TIMESTAMP:\n          operand = Expressions.call(BuiltInMethod.FLOOR_DIV.method,\n              operand, Expressions.constant(TimeUnit.DAY.multiplier.longValue()));\n          \r\n        case DATE:\n          return Expressions.call(BuiltInMethod.UNIX_DATE_EXTRACT.method,\n              argValueList.get(0), operand);\n        default:\n          throw new AssertionError(\"unexpected \" + sqlTypeName);\n        }\n        break;\n      case MILLISECOND:\n      case MICROSECOND:\n      case NANOSECOND:\n        if (sqlTypeName == SqlTypeName.DATE) {\n          return Expressions.constant(0L);\n        }\n        operand = mod(operand, TimeUnit.MINUTE.multiplier.longValue());\n        return Expressions.multiply(\n            operand, Expressions.constant((long) (1 / unit.multiplier.doubleValue())));\n      case EPOCH:\n        switch (sqlTypeName) {\n        case DATE:\n          \r\n          operand = Expressions.multiply(operand,\n              Expressions.constant(TimeUnit.DAY.multiplier.longValue()));\n          \r\n        case TIMESTAMP:\n          \r\n          return Expressions.divide(operand,\n              Expressions.constant(TimeUnit.SECOND.multiplier.longValue()));\n        case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n          operand = Expressions.call(\n              BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, translator.getRoot()));\n          return Expressions.divide(operand,\n              Expressions.constant(TimeUnit.SECOND.multiplier.longValue()));\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          \r\n          throw new AssertionError(\"unexpected \" + sqlTypeName);\n        default:\n          break;\n        }\n        break;\n      case HOUR:\n      case MINUTE:\n      case SECOND:\n        switch (sqlTypeName) {\n        case DATE:\n          return Expressions.multiply(operand, Expressions.constant(0L));\n        default:\n          break;\n        }\n        break;\n      }\n\n      operand = mod(operand, getFactor(unit));\n      if (unit == TimeUnit.QUARTER) {\n        operand = Expressions.subtract(operand, Expressions.constant(1L));\n      }\n      operand = Expressions.divide(operand,\n          Expressions.constant(unit.multiplier.longValue()));\n      if (unit == TimeUnit.QUARTER) {\n        operand = Expressions.add(operand, Expressions.constant(1L));\n      }\n      return operand;\n    }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":2270,"status":"M"}],"commitId":"d9a81b88ad561e7e4cedae93e805e0d7a53a7f1a","commitMessage":"@@@[CALCITE-4199] Add nullability annotations\n\nThe commit includes javadoc updates and refactorings made by Julian Hyde in https://github.com/apache/calcite/pull/2278\n","date":"2020-11-30 06:45:33","modifiedFileCount":"1012","status":"M","submitter":"Vladimir Sitnikov"}]
