[{"authorTime":"2020-01-09 16:03:30","codes":[{"authorDate":"2020-01-09 16:03:30","commitOrder":1,"curCode":"  private static RexNode convertDecode(SqlRexContext cx, SqlCall call) {\n    final RexBuilder rexBuilder = cx.getRexBuilder();\n    final List<RexNode> operands = convertExpressionList(cx,\n        call.getOperandList(), SqlOperandTypeChecker.Consistency.NONE);\n    final RelDataType type =\n        cx.getValidator().getValidatedNodeType(call);\n    final List<RexNode> exprs = new ArrayList<>();\n    for (int i = 1; i < operands.size() - 1; i += 2) {\n      exprs.add(\n          RelOptUtil.isDistinctFrom(rexBuilder, operands.get(0),\n              operands.get(i), true));\n      exprs.add(operands.get(i + 1));\n    }\n    if (operands.size() % 2 == 0) {\n      exprs.add(Util.last(operands));\n    } else {\n      exprs.add(rexBuilder.makeNullLiteral(type));\n    }\n    return rexBuilder.makeCall(type, SqlStdOperatorTable.CASE, exprs);\n  }\n","date":"2020-10-16 05:53:42","endLine":303,"groupId":"3545","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"convertDecode","params":"(SqlRexContextcx@SqlCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/eb/4ecc597e1a384c7b98a882f141ae7547ffd6d6.src","preCode":"  private static RexNode convertDecode(SqlRexContext cx, SqlCall call) {\n    final RexBuilder rexBuilder = cx.getRexBuilder();\n    final List<RexNode> operands = convertExpressionList(cx,\n        call.getOperandList(), SqlOperandTypeChecker.Consistency.NONE);\n    final RelDataType type =\n        cx.getValidator().getValidatedNodeType(call);\n    final List<RexNode> exprs = new ArrayList<>();\n    for (int i = 1; i < operands.size() - 1; i += 2) {\n      exprs.add(\n          RelOptUtil.isDistinctFrom(rexBuilder, operands.get(0),\n              operands.get(i), true));\n      exprs.add(operands.get(i + 1));\n    }\n    if (operands.size() % 2 == 0) {\n      exprs.add(Util.last(operands));\n    } else {\n      exprs.add(rexBuilder.makeNullLiteral(type));\n    }\n    return rexBuilder.makeCall(type, SqlStdOperatorTable.CASE, exprs);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":284,"status":"B"},{"authorDate":"2020-01-09 16:03:30","commitOrder":1,"curCode":"  private static RexNode convertIf(SqlRexContext cx, SqlCall call) {\n    final RexBuilder rexBuilder = cx.getRexBuilder();\n    final List<RexNode> operands = convertExpressionList(cx,\n        call.getOperandList(), SqlOperandTypeChecker.Consistency.NONE);\n    final RelDataType type =\n        cx.getValidator().getValidatedNodeType(call);\n    return rexBuilder.makeCall(type, SqlStdOperatorTable.CASE, operands);\n  }\n","date":"2020-10-16 05:53:42","endLine":315,"groupId":"3545","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"convertIf","params":"(SqlRexContextcx@SqlCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/eb/4ecc597e1a384c7b98a882f141ae7547ffd6d6.src","preCode":"  private static RexNode convertIf(SqlRexContext cx, SqlCall call) {\n    final RexBuilder rexBuilder = cx.getRexBuilder();\n    final List<RexNode> operands = convertExpressionList(cx,\n        call.getOperandList(), SqlOperandTypeChecker.Consistency.NONE);\n    final RelDataType type =\n        cx.getValidator().getValidatedNodeType(call);\n    return rexBuilder.makeCall(type, SqlStdOperatorTable.CASE, operands);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":308,"status":"B"}],"commitId":"a186f02ab79374dc7a6ff0b2ae0c3cb661fbd86a","commitMessage":"@@@[CALCITE-3731] Add IF function for BigQuery.  Hive and Spark dialects (Vaibhav Jain)\n\nAdd Hive and Spark function tables (fun=hive and fun=spark).\n\nRework to implement IF by expanding to CASE (Julian Hyde).\nThe original PR used a runtime function. By desugaring.  we\ninherit the logic to simplify CASE.  etc.\n\nRemove code that supports IF in a JDBC function call.  and\nclean up the SQL reference (Julian Hyde).\n\nRemove 'throws' from InterpreterTest (Julian Hyde).\n\nClose apache/calcite#1764\n","date":"2020-10-16 05:53:42","modifiedFileCount":"7","status":"B","submitter":"yuzhao.cyz"},{"authorTime":"2020-11-12 09:36:13","codes":[{"authorDate":"2020-11-12 09:36:13","commitOrder":2,"curCode":"  private static RexNode convertDecode(SqlRexContext cx, SqlCall call) {\n    final RexBuilder rexBuilder = cx.getRexBuilder();\n    final List<RexNode> operands =\n        convertOperands(cx, call, SqlOperandTypeChecker.Consistency.NONE);\n    final RelDataType type =\n        cx.getValidator().getValidatedNodeType(call);\n    final List<RexNode> exprs = new ArrayList<>();\n    for (int i = 1; i < operands.size() - 1; i += 2) {\n      exprs.add(\n          RelOptUtil.isDistinctFrom(rexBuilder, operands.get(0),\n              operands.get(i), true));\n      exprs.add(operands.get(i + 1));\n    }\n    if (operands.size() % 2 == 0) {\n      exprs.add(Util.last(operands));\n    } else {\n      exprs.add(rexBuilder.makeNullLiteral(type));\n    }\n    return rexBuilder.makeCall(type, SqlStdOperatorTable.CASE, exprs);\n  }\n","date":"2020-11-13 12:58:41","endLine":301,"groupId":"102166","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"convertDecode","params":"(SqlRexContextcx@SqlCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/4f/bd5e80138c8dafeb78f38f3ca77efb7b8e63d1.src","preCode":"  private static RexNode convertDecode(SqlRexContext cx, SqlCall call) {\n    final RexBuilder rexBuilder = cx.getRexBuilder();\n    final List<RexNode> operands = convertExpressionList(cx,\n        call.getOperandList(), SqlOperandTypeChecker.Consistency.NONE);\n    final RelDataType type =\n        cx.getValidator().getValidatedNodeType(call);\n    final List<RexNode> exprs = new ArrayList<>();\n    for (int i = 1; i < operands.size() - 1; i += 2) {\n      exprs.add(\n          RelOptUtil.isDistinctFrom(rexBuilder, operands.get(0),\n              operands.get(i), true));\n      exprs.add(operands.get(i + 1));\n    }\n    if (operands.size() % 2 == 0) {\n      exprs.add(Util.last(operands));\n    } else {\n      exprs.add(rexBuilder.makeNullLiteral(type));\n    }\n    return rexBuilder.makeCall(type, SqlStdOperatorTable.CASE, exprs);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":282,"status":"M"},{"authorDate":"2020-11-12 09:36:13","commitOrder":2,"curCode":"  private static RexNode convertIf(SqlRexContext cx, SqlCall call) {\n    final RexBuilder rexBuilder = cx.getRexBuilder();\n    final List<RexNode> operands =\n        convertOperands(cx, call, SqlOperandTypeChecker.Consistency.NONE);\n    final RelDataType type =\n        cx.getValidator().getValidatedNodeType(call);\n    return rexBuilder.makeCall(type, SqlStdOperatorTable.CASE, operands);\n  }\n","date":"2020-11-13 12:58:41","endLine":313,"groupId":"102166","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"convertIf","params":"(SqlRexContextcx@SqlCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/4f/bd5e80138c8dafeb78f38f3ca77efb7b8e63d1.src","preCode":"  private static RexNode convertIf(SqlRexContext cx, SqlCall call) {\n    final RexBuilder rexBuilder = cx.getRexBuilder();\n    final List<RexNode> operands = convertExpressionList(cx,\n        call.getOperandList(), SqlOperandTypeChecker.Consistency.NONE);\n    final RelDataType type =\n        cx.getValidator().getValidatedNodeType(call);\n    return rexBuilder.makeCall(type, SqlStdOperatorTable.CASE, operands);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":306,"status":"M"}],"commitId":"e819b4611e883c54708a75f6856300462c92b8ae","commitMessage":"@@@[CALCITE-4394] When generating code for a function call.  take the inferred types of the operands into account\n\nRefactor SqlOperatorBaseTest.testConcatFunc for the various\nvariants of CONCAT in PostgreSQL.  MySQL.  Oracle dialects.\n\nFix code generation that uses built-in functions with\nvarargs. In particular.  SqlFunctions has\nconcat(String.  String) and concat(String...). The fix for\n[CALCITE-3563] changed the information used by the\nimplementor from Method to Class + methodName.  which has a\ncouple of problems: it is lossy if the method is overloaded. \nand does not allow us to see whether the method has varargs\nparameters. In this commit.  we change it back.  and add\ndifferent code path for varargs methods. We now require\nvarargs methods to have different names to non-vargs methods.\n","date":"2020-11-13 12:58:41","modifiedFileCount":"16","status":"M","submitter":"Julian Hyde"}]
