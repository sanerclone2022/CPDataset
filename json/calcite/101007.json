[{"authorTime":"2016-11-23 23:31:17","codes":[{"authorDate":"2016-11-23 23:31:17","commitOrder":1,"curCode":"  @Test public void testOverRowsBetweenBoundFollowingAndFollowing() {\n    CalciteAssert\n        .model(JdbcTest.FOODMART_MODEL)\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.POSTGRESQL)\n        .query(\"select \\\"store_id\\\", \\\"account_id\\\", \\\"exp_date\\\",\"\n            + \" \\\"time_id\\\", \\\"category_id\\\", \\\"currency_id\\\", \\\"amount\\\",\"\n            + \" last_value(\\\"time_id\\\") over (partition by \\\"account_id\\\"\"\n            + \" order by \\\"time_id\\\" rows between 1 following and 10 following)\"\n            + \" as \\\"last_version\\\" from \\\"expense_fact\\\"\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(store_id=[$0], account_id=[$1], exp_date=[$2], \"\n            + \"time_id=[$3], category_id=[$4], currency_id=[$5], amount=[$6],\"\n            + \" last_version=[LAST_VALUE($3) OVER (PARTITION BY $1\"\n            + \" ORDER BY $3 ROWS BETWEEN 1 FOLLOWING AND 10 FOLLOWING)])\\n\"\n            + \"    JdbcTableScan(table=[[foodmart, expense_fact]])\\n\")\n        .runs()\n        .planHasSql(\"SELECT \\\"store_id\\\", \\\"account_id\\\", \\\"exp_date\\\",\"\n            + \" \\\"time_id\\\", \\\"category_id\\\", \\\"currency_id\\\", \\\"amount\\\",\"\n            + \" LAST_VALUE(\\\"time_id\\\") OVER (PARTITION BY \\\"account_id\\\"\"\n            + \" ORDER BY \\\"time_id\\\" ROWS BETWEEN 1 FOLLOWING\"\n            + \" AND 10 FOLLOWING) AS \\\"last_version\\\"\\n\"\n            + \"FROM \\\"foodmart\\\".\\\"expense_fact\\\"\");\n  }\n","date":"2016-11-29 00:45:43","endLine":431,"groupId":"7241","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testOverRowsBetweenBoundFollowingAndFollowing","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/f4/5a9b54a48c0a2e4f17b2f2db1c8fcb75b19245.src","preCode":"  @Test public void testOverRowsBetweenBoundFollowingAndFollowing() {\n    CalciteAssert\n        .model(JdbcTest.FOODMART_MODEL)\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.POSTGRESQL)\n        .query(\"select \\\"store_id\\\", \\\"account_id\\\", \\\"exp_date\\\",\"\n            + \" \\\"time_id\\\", \\\"category_id\\\", \\\"currency_id\\\", \\\"amount\\\",\"\n            + \" last_value(\\\"time_id\\\") over (partition by \\\"account_id\\\"\"\n            + \" order by \\\"time_id\\\" rows between 1 following and 10 following)\"\n            + \" as \\\"last_version\\\" from \\\"expense_fact\\\"\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(store_id=[$0], account_id=[$1], exp_date=[$2], \"\n            + \"time_id=[$3], category_id=[$4], currency_id=[$5], amount=[$6],\"\n            + \" last_version=[LAST_VALUE($3) OVER (PARTITION BY $1\"\n            + \" ORDER BY $3 ROWS BETWEEN 1 FOLLOWING AND 10 FOLLOWING)])\\n\"\n            + \"    JdbcTableScan(table=[[foodmart, expense_fact]])\\n\")\n        .runs()\n        .planHasSql(\"SELECT \\\"store_id\\\", \\\"account_id\\\", \\\"exp_date\\\",\"\n            + \" \\\"time_id\\\", \\\"category_id\\\", \\\"currency_id\\\", \\\"amount\\\",\"\n            + \" LAST_VALUE(\\\"time_id\\\") OVER (PARTITION BY \\\"account_id\\\"\"\n            + \" ORDER BY \\\"time_id\\\" ROWS BETWEEN 1 FOLLOWING\"\n            + \" AND 10 FOLLOWING) AS \\\"last_version\\\"\\n\"\n            + \"FROM \\\"foodmart\\\".\\\"expense_fact\\\"\");\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":409,"status":"B"},{"authorDate":"2016-11-23 23:31:17","commitOrder":1,"curCode":"  @Test public void testOverDisallowPartial() {\n    CalciteAssert\n        .model(JdbcTest.FOODMART_MODEL)\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.POSTGRESQL)\n        .query(\"select \\\"store_id\\\", \\\"account_id\\\", \\\"exp_date\\\",\"\n            + \" \\\"time_id\\\", \\\"category_id\\\", \\\"currency_id\\\", \\\"amount\\\",\"\n            + \" last_value(\\\"time_id\\\") over (partition by \\\"account_id\\\"\"\n            + \" order by \\\"time_id\\\" rows 3 preceding disallow partial)\"\n            + \" as \\\"last_version\\\" from \\\"expense_fact\\\"\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(store_id=[$0], account_id=[$1], exp_date=[$2],\"\n            + \" time_id=[$3], category_id=[$4], currency_id=[$5],\"\n            + \" amount=[$6], last_version=[CASE(>=(COUNT() OVER\"\n            + \" (PARTITION BY $1 ORDER BY $3 ROWS BETWEEN 3 PRECEDING AND\"\n            + \" CURRENT ROW), 2), LAST_VALUE($3) OVER (PARTITION BY $1\"\n            + \" ORDER BY $3 ROWS BETWEEN 3 PRECEDING AND CURRENT ROW),\"\n            + \" null)])\\n    JdbcTableScan(table=[[foodmart,\"\n            + \" expense_fact]])\\n\")\n        .runs()\n        .planHasSql(\"SELECT \\\"store_id\\\", \\\"account_id\\\", \\\"exp_date\\\",\"\n            + \" \\\"time_id\\\", \\\"category_id\\\", \\\"currency_id\\\", \\\"amount\\\",\"\n            + \" CASE WHEN (COUNT(*) OVER (PARTITION BY \\\"account_id\\\"\"\n            + \" ORDER BY \\\"time_id\\\" ROWS BETWEEN 3 PRECEDING\"\n            + \" AND CURRENT ROW)) >= 2 THEN LAST_VALUE(\\\"time_id\\\")\"\n            + \" OVER (PARTITION BY \\\"account_id\\\" ORDER BY \\\"time_id\\\"\"\n            + \" ROWS BETWEEN 3 PRECEDING AND CURRENT ROW)\"\n            + \" ELSE NULL END AS \\\"last_version\\\"\\n\"\n            + \"FROM \\\"foodmart\\\".\\\"expense_fact\\\"\");\n  }\n","date":"2016-11-29 00:45:43","endLine":485,"groupId":"7241","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testOverDisallowPartial","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/f4/5a9b54a48c0a2e4f17b2f2db1c8fcb75b19245.src","preCode":"  @Test public void testOverDisallowPartial() {\n    CalciteAssert\n        .model(JdbcTest.FOODMART_MODEL)\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.POSTGRESQL)\n        .query(\"select \\\"store_id\\\", \\\"account_id\\\", \\\"exp_date\\\",\"\n            + \" \\\"time_id\\\", \\\"category_id\\\", \\\"currency_id\\\", \\\"amount\\\",\"\n            + \" last_value(\\\"time_id\\\") over (partition by \\\"account_id\\\"\"\n            + \" order by \\\"time_id\\\" rows 3 preceding disallow partial)\"\n            + \" as \\\"last_version\\\" from \\\"expense_fact\\\"\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(store_id=[$0], account_id=[$1], exp_date=[$2],\"\n            + \" time_id=[$3], category_id=[$4], currency_id=[$5],\"\n            + \" amount=[$6], last_version=[CASE(>=(COUNT() OVER\"\n            + \" (PARTITION BY $1 ORDER BY $3 ROWS BETWEEN 3 PRECEDING AND\"\n            + \" CURRENT ROW), 2), LAST_VALUE($3) OVER (PARTITION BY $1\"\n            + \" ORDER BY $3 ROWS BETWEEN 3 PRECEDING AND CURRENT ROW),\"\n            + \" null)])\\n    JdbcTableScan(table=[[foodmart,\"\n            + \" expense_fact]])\\n\")\n        .runs()\n        .planHasSql(\"SELECT \\\"store_id\\\", \\\"account_id\\\", \\\"exp_date\\\",\"\n            + \" \\\"time_id\\\", \\\"category_id\\\", \\\"currency_id\\\", \\\"amount\\\",\"\n            + \" CASE WHEN (COUNT(*) OVER (PARTITION BY \\\"account_id\\\"\"\n            + \" ORDER BY \\\"time_id\\\" ROWS BETWEEN 3 PRECEDING\"\n            + \" AND CURRENT ROW)) >= 2 THEN LAST_VALUE(\\\"time_id\\\")\"\n            + \" OVER (PARTITION BY \\\"account_id\\\" ORDER BY \\\"time_id\\\"\"\n            + \" ROWS BETWEEN 3 PRECEDING AND CURRENT ROW)\"\n            + \" ELSE NULL END AS \\\"last_version\\\"\\n\"\n            + \"FROM \\\"foodmart\\\".\\\"expense_fact\\\"\");\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":457,"status":"B"}],"commitId":"e4fb4c4ed46febbbc2790f142e9e2b1d18b0ee18","commitMessage":"@@@[CALCITE-1506] Push OVER Clause to underlying SQL via JDBC adapter (Christian Tzolov)\n\nClose apache/calcite#329\n","date":"2016-11-29 00:45:43","modifiedFileCount":"2","status":"B","submitter":"Christian Tzolov"},{"authorTime":"2020-04-02 10:39:10","codes":[{"authorDate":"2020-04-02 10:39:10","commitOrder":2,"curCode":"  @Test void testOverRowsBetweenBoundFollowingAndFollowing() {\n    CalciteAssert\n        .model(JdbcTest.FOODMART_MODEL)\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.POSTGRESQL)\n        .query(\"select \\\"store_id\\\", \\\"account_id\\\", \\\"exp_date\\\",\"\n            + \" \\\"time_id\\\", \\\"category_id\\\", \\\"currency_id\\\", \\\"amount\\\",\"\n            + \" last_value(\\\"time_id\\\") over (partition by \\\"account_id\\\"\"\n            + \" order by \\\"time_id\\\" rows between 1 following and 10 following)\"\n            + \" as \\\"last_version\\\" from \\\"expense_fact\\\"\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(store_id=[$0], account_id=[$1], exp_date=[$2], \"\n            + \"time_id=[$3], category_id=[$4], currency_id=[$5], amount=[$6],\"\n            + \" last_version=[LAST_VALUE($3) OVER (PARTITION BY $1\"\n            + \" ORDER BY $3 ROWS BETWEEN 1 FOLLOWING AND 10 FOLLOWING)])\\n\"\n            + \"    JdbcTableScan(table=[[foodmart, expense_fact]])\\n\")\n        .runs()\n        .planHasSql(\"SELECT \\\"store_id\\\", \\\"account_id\\\", \\\"exp_date\\\",\"\n            + \" \\\"time_id\\\", \\\"category_id\\\", \\\"currency_id\\\", \\\"amount\\\",\"\n            + \" LAST_VALUE(\\\"time_id\\\") OVER (PARTITION BY \\\"account_id\\\"\"\n            + \" ORDER BY \\\"time_id\\\" ROWS BETWEEN 1 FOLLOWING\"\n            + \" AND 10 FOLLOWING) AS \\\"last_version\\\"\\n\"\n            + \"FROM \\\"foodmart\\\".\\\"expense_fact\\\"\");\n  }\n","date":"2020-04-06 04:57:49","endLine":608,"groupId":"101007","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testOverRowsBetweenBoundFollowingAndFollowing","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/93/d9225e24795985dc38bb15e55325e153eec03d.src","preCode":"  @Test public void testOverRowsBetweenBoundFollowingAndFollowing() {\n    CalciteAssert\n        .model(JdbcTest.FOODMART_MODEL)\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.POSTGRESQL)\n        .query(\"select \\\"store_id\\\", \\\"account_id\\\", \\\"exp_date\\\",\"\n            + \" \\\"time_id\\\", \\\"category_id\\\", \\\"currency_id\\\", \\\"amount\\\",\"\n            + \" last_value(\\\"time_id\\\") over (partition by \\\"account_id\\\"\"\n            + \" order by \\\"time_id\\\" rows between 1 following and 10 following)\"\n            + \" as \\\"last_version\\\" from \\\"expense_fact\\\"\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(store_id=[$0], account_id=[$1], exp_date=[$2], \"\n            + \"time_id=[$3], category_id=[$4], currency_id=[$5], amount=[$6],\"\n            + \" last_version=[LAST_VALUE($3) OVER (PARTITION BY $1\"\n            + \" ORDER BY $3 ROWS BETWEEN 1 FOLLOWING AND 10 FOLLOWING)])\\n\"\n            + \"    JdbcTableScan(table=[[foodmart, expense_fact]])\\n\")\n        .runs()\n        .planHasSql(\"SELECT \\\"store_id\\\", \\\"account_id\\\", \\\"exp_date\\\",\"\n            + \" \\\"time_id\\\", \\\"category_id\\\", \\\"currency_id\\\", \\\"amount\\\",\"\n            + \" LAST_VALUE(\\\"time_id\\\") OVER (PARTITION BY \\\"account_id\\\"\"\n            + \" ORDER BY \\\"time_id\\\" ROWS BETWEEN 1 FOLLOWING\"\n            + \" AND 10 FOLLOWING) AS \\\"last_version\\\"\\n\"\n            + \"FROM \\\"foodmart\\\".\\\"expense_fact\\\"\");\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":586,"status":"M"},{"authorDate":"2020-04-02 10:39:10","commitOrder":2,"curCode":"  @Test void testOverDisallowPartial() {\n    CalciteAssert\n        .model(JdbcTest.FOODMART_MODEL)\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.POSTGRESQL)\n        .query(\"select \\\"store_id\\\", \\\"account_id\\\", \\\"exp_date\\\",\"\n            + \" \\\"time_id\\\", \\\"category_id\\\", \\\"currency_id\\\", \\\"amount\\\",\"\n            + \" last_value(\\\"time_id\\\") over (partition by \\\"account_id\\\"\"\n            + \" order by \\\"time_id\\\" rows 3 preceding disallow partial)\"\n            + \" as \\\"last_version\\\" from \\\"expense_fact\\\"\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(store_id=[$0], account_id=[$1], exp_date=[$2],\"\n            + \" time_id=[$3], category_id=[$4], currency_id=[$5],\"\n            + \" amount=[$6], last_version=[CASE(>=(COUNT() OVER\"\n            + \" (PARTITION BY $1 ORDER BY $3 ROWS BETWEEN 3 PRECEDING AND\"\n            + \" CURRENT ROW), 2), LAST_VALUE($3) OVER (PARTITION BY $1\"\n            + \" ORDER BY $3 ROWS BETWEEN 3 PRECEDING AND CURRENT ROW),\"\n            + \" null)])\\n    JdbcTableScan(table=[[foodmart,\"\n            + \" expense_fact]])\\n\")\n        .runs()\n        .planHasSql(\"SELECT \\\"store_id\\\", \\\"account_id\\\", \\\"exp_date\\\",\"\n            + \" \\\"time_id\\\", \\\"category_id\\\", \\\"currency_id\\\", \\\"amount\\\",\"\n            + \" CASE WHEN (COUNT(*) OVER (PARTITION BY \\\"account_id\\\"\"\n            + \" ORDER BY \\\"time_id\\\" ROWS BETWEEN 3 PRECEDING\"\n            + \" AND CURRENT ROW)) >= 2 THEN LAST_VALUE(\\\"time_id\\\")\"\n            + \" OVER (PARTITION BY \\\"account_id\\\" ORDER BY \\\"time_id\\\"\"\n            + \" ROWS BETWEEN 3 PRECEDING AND CURRENT ROW)\"\n            + \" ELSE NULL END AS \\\"last_version\\\"\\n\"\n            + \"FROM \\\"foodmart\\\".\\\"expense_fact\\\"\");\n  }\n","date":"2020-04-06 04:57:49","endLine":662,"groupId":"101007","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testOverDisallowPartial","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/93/d9225e24795985dc38bb15e55325e153eec03d.src","preCode":"  @Test public void testOverDisallowPartial() {\n    CalciteAssert\n        .model(JdbcTest.FOODMART_MODEL)\n        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.POSTGRESQL)\n        .query(\"select \\\"store_id\\\", \\\"account_id\\\", \\\"exp_date\\\",\"\n            + \" \\\"time_id\\\", \\\"category_id\\\", \\\"currency_id\\\", \\\"amount\\\",\"\n            + \" last_value(\\\"time_id\\\") over (partition by \\\"account_id\\\"\"\n            + \" order by \\\"time_id\\\" rows 3 preceding disallow partial)\"\n            + \" as \\\"last_version\\\" from \\\"expense_fact\\\"\")\n        .explainContains(\"PLAN=JdbcToEnumerableConverter\\n\"\n            + \"  JdbcProject(store_id=[$0], account_id=[$1], exp_date=[$2],\"\n            + \" time_id=[$3], category_id=[$4], currency_id=[$5],\"\n            + \" amount=[$6], last_version=[CASE(>=(COUNT() OVER\"\n            + \" (PARTITION BY $1 ORDER BY $3 ROWS BETWEEN 3 PRECEDING AND\"\n            + \" CURRENT ROW), 2), LAST_VALUE($3) OVER (PARTITION BY $1\"\n            + \" ORDER BY $3 ROWS BETWEEN 3 PRECEDING AND CURRENT ROW),\"\n            + \" null)])\\n    JdbcTableScan(table=[[foodmart,\"\n            + \" expense_fact]])\\n\")\n        .runs()\n        .planHasSql(\"SELECT \\\"store_id\\\", \\\"account_id\\\", \\\"exp_date\\\",\"\n            + \" \\\"time_id\\\", \\\"category_id\\\", \\\"currency_id\\\", \\\"amount\\\",\"\n            + \" CASE WHEN (COUNT(*) OVER (PARTITION BY \\\"account_id\\\"\"\n            + \" ORDER BY \\\"time_id\\\" ROWS BETWEEN 3 PRECEDING\"\n            + \" AND CURRENT ROW)) >= 2 THEN LAST_VALUE(\\\"time_id\\\")\"\n            + \" OVER (PARTITION BY \\\"account_id\\\" ORDER BY \\\"time_id\\\"\"\n            + \" ROWS BETWEEN 3 PRECEDING AND CURRENT ROW)\"\n            + \" ELSE NULL END AS \\\"last_version\\\"\\n\"\n            + \"FROM \\\"foodmart\\\".\\\"expense_fact\\\"\");\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":634,"status":"M"}],"commitId":"9492dd4146f63ddc028010d6c4e86f6a5cb29a8d","commitMessage":"@@@[CALCITE-3892] Make junit test classes and methods non-public where possible\n\nPrior to junit 5.  classes and methods had to be public. This is no\nlonger the case.\n\nSome classes need to remain public because they are referenced from\nelsewhere.  or if they use reflection somehow. The remaining 'public'\nkeyword will be informative to maintainers.\n","date":"2020-04-06 04:57:49","modifiedFileCount":"196","status":"M","submitter":"Julian Hyde"}]
