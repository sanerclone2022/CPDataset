[{"authorTime":"2020-04-16 08:58:02","codes":[{"authorDate":"2020-04-02 10:39:10","commitOrder":6,"curCode":"  @Test void testSubsetRule() {\n    VolcanoPlanner planner = new VolcanoPlanner();\n    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n    planner.addRelTraitDef(RelCollationTraitDef.INSTANCE);\n\n    planner.addRule(new PhysLeafRule());\n    planner.addRule(new GoodSingleRule());\n    final List<String> buf = new ArrayList<>();\n    planner.addRule(new SubsetRule(buf));\n\n    RelOptCluster cluster = newCluster(planner);\n    NoneLeafRel leafRel =\n        new NoneLeafRel(\n            cluster,\n            \"a\");\n    NoneSingleRel singleRel =\n        new NoneSingleRel(\n            cluster,\n            leafRel);\n    RelNode convertedRel =\n        planner.changeTraits(\n            singleRel,\n            cluster.traitSetOf(PHYS_CALLING_CONVENTION));\n    planner.changeTraits(leafRel,\n        cluster.traitSetOf(PHYS_CALLING_CONVENTION)\n        .plus(RelCollations.of(0)));\n    planner.setRoot(convertedRel);\n    RelNode result = planner.chooseDelegate().findBestExp();\n    assertTrue(result instanceof PhysSingleRel);\n    assertThat(sort(buf),\n        equalTo(\n            sort(\n                \"NoneSingleRel:Subset#0.NONE.[]\",\n                \"PhysSingleRel:Subset#0.PHYS.[0]\",\n                \"PhysSingleRel:Subset#0.PHYS.[]\")));\n  }\n","date":"2020-04-06 04:57:49","endLine":244,"groupId":"8077","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testSubsetRule","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/5f/ae0cd2afad01213a0363723d9e4e922e7406d9.src","preCode":"  @Test void testSubsetRule() {\n    VolcanoPlanner planner = new VolcanoPlanner();\n    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n    planner.addRelTraitDef(RelCollationTraitDef.INSTANCE);\n\n    planner.addRule(new PhysLeafRule());\n    planner.addRule(new GoodSingleRule());\n    final List<String> buf = new ArrayList<>();\n    planner.addRule(new SubsetRule(buf));\n\n    RelOptCluster cluster = newCluster(planner);\n    NoneLeafRel leafRel =\n        new NoneLeafRel(\n            cluster,\n            \"a\");\n    NoneSingleRel singleRel =\n        new NoneSingleRel(\n            cluster,\n            leafRel);\n    RelNode convertedRel =\n        planner.changeTraits(\n            singleRel,\n            cluster.traitSetOf(PHYS_CALLING_CONVENTION));\n    planner.changeTraits(leafRel,\n        cluster.traitSetOf(PHYS_CALLING_CONVENTION)\n        .plus(RelCollations.of(0)));\n    planner.setRoot(convertedRel);\n    RelNode result = planner.chooseDelegate().findBestExp();\n    assertTrue(result instanceof PhysSingleRel);\n    assertThat(sort(buf),\n        equalTo(\n            sort(\n                \"NoneSingleRel:Subset#0.NONE.[]\",\n                \"PhysSingleRel:Subset#0.PHYS.[0]\",\n                \"PhysSingleRel:Subset#0.PHYS.[]\")));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/volcano/VolcanoPlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":209,"status":"NB"},{"authorDate":"2020-04-16 08:58:02","commitOrder":6,"curCode":"  @Test void testSetMergeMatchSubsetRule() {\n    VolcanoPlanner planner = new VolcanoPlanner();\n    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n    planner.addRelTraitDef(RelCollationTraitDef.INSTANCE);\n\n    planner.addRule(new PhysLeafRule());\n    planner.addRule(new GoodSingleRule());\n    planner.addRule(new PhysSingleInputSetMergeRule());\n    final List<String> buf = new ArrayList<>();\n    planner.addRule(new PhysSingleSubsetRule(buf));\n\n    RelOptCluster cluster = newCluster(planner);\n    NoneLeafRel leafRel = new NoneLeafRel(cluster, \"a\");\n    NoneSingleRel singleRel = new NoneSingleRel(cluster, leafRel);\n    RelNode convertedRel = planner\n        .changeTraits(singleRel, cluster.traitSetOf(PHYS_CALLING_CONVENTION));\n    planner.setRoot(convertedRel);\n    RelNode result = planner.chooseDelegate().findBestExp();\n    assertTrue(result instanceof PhysSingleRel);\n    assertThat(sort(buf),\n        equalTo(\n            sort(\"PhysSingleRel:Subset#0.PHYS.[]\",\n            \"PhysSingleRel:Subset#0.PHYS_3.[]\")));\n  }\n","date":"2020-04-22 02:24:25","endLine":286,"groupId":"5953","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testSetMergeMatchSubsetRule","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/d9/3a223554f2a2b50c53b3065c41d0b04c792ce5.src","preCode":"  @Test void testSetMergeMatchSubsetRule() {\n    VolcanoPlanner planner = new VolcanoPlanner();\n    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n    planner.addRelTraitDef(RelCollationTraitDef.INSTANCE);\n\n    planner.addRule(new PhysLeafRule());\n    planner.addRule(new GoodSingleRule());\n    planner.addRule(new PhysSingleInputSetMergeRule());\n    final List<String> buf = new ArrayList<>();\n    planner.addRule(new PhysSingleSubsetRule(buf));\n\n    RelOptCluster cluster = newCluster(planner);\n    NoneLeafRel leafRel = new NoneLeafRel(cluster, \"a\");\n    NoneSingleRel singleRel = new NoneSingleRel(cluster, leafRel);\n    RelNode convertedRel = planner\n        .changeTraits(singleRel, cluster.traitSetOf(PHYS_CALLING_CONVENTION));\n    planner.setRoot(convertedRel);\n    RelNode result = planner.chooseDelegate().findBestExp();\n    assertTrue(result instanceof PhysSingleRel);\n    assertThat(sort(buf),\n        equalTo(\n            sort(\"PhysSingleRel:Subset#0.PHYS.[]\",\n            \"PhysSingleRel:Subset#0.PHYS_3.[]\")));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/volcano/VolcanoPlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":263,"status":"B"}],"commitId":"ff71266352df23208a75b9076045e89f30b9bb0b","commitMessage":"@@@[CALCITE-3927] RelSubset is not fired for rule when set gets merged (Botong Huang)\n\nIn VolcanoPlanner.  when set gets merged.  planner fires rules again for RelNodes\nin both sets.  but not for RelSubset. We might miss something because of this.\n\nIf all the logical transformation rules and physical implementation rules are\nseparated out in different stage and physical rules don't do logical work.  we\nmight be OK. But the reality is that all the things are mixed together at the\nmoment.\n\nClose #1922\n","date":"2020-04-22 02:24:25","modifiedFileCount":"3","status":"M","submitter":"botong.huang"},{"authorTime":"2020-06-09 21:16:22","codes":[{"authorDate":"2020-06-09 21:16:22","commitOrder":7,"curCode":"  @Test void testSubsetRule() {\n    VolcanoPlanner planner = new VolcanoPlanner();\n    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n    planner.addRelTraitDef(RelCollationTraitDef.INSTANCE);\n\n    planner.addRule(new PhysLeafRule());\n    planner.addRule(new GoodSingleRule());\n    final List<String> buf = new ArrayList<>();\n    planner.addRule(new SubsetRule(buf));\n\n    RelOptCluster cluster = newCluster(planner);\n    NoneLeafRel leafRel =\n        new NoneLeafRel(\n            cluster,\n            \"a\");\n    NoneSingleRel singleRel =\n        new NoneSingleRel(\n            cluster,\n            leafRel);\n    RelNode convertedRel =\n        planner.changeTraits(\n            singleRel,\n            cluster.traitSetOf(PHYS_CALLING_CONVENTION));\n    planner.changeTraits(leafRel,\n        cluster.traitSetOf(PHYS_CALLING_CONVENTION)\n        .plus(RelCollations.of(0)));\n    planner.setRoot(convertedRel);\n    RelNode result = planner.chooseDelegate().findBestExp();\n    assertTrue(result instanceof PhysSingleRel);\n    assertThat(sort(buf),\n        equalTo(\n            sort(\n                \"NoneSingleRel:RelSubset#0.NONE.[]\",\n                \"PhysSingleRel:RelSubset#0.PHYS.[0]\",\n                \"PhysSingleRel:RelSubset#0.PHYS.[]\")));\n  }\n","date":"2020-06-16 11:11:13","endLine":246,"groupId":"8077","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testSubsetRule","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/d9/8b2bf08c9438fbf135785c11034a230a14ee73.src","preCode":"  @Test void testSubsetRule() {\n    VolcanoPlanner planner = new VolcanoPlanner();\n    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n    planner.addRelTraitDef(RelCollationTraitDef.INSTANCE);\n\n    planner.addRule(new PhysLeafRule());\n    planner.addRule(new GoodSingleRule());\n    final List<String> buf = new ArrayList<>();\n    planner.addRule(new SubsetRule(buf));\n\n    RelOptCluster cluster = newCluster(planner);\n    NoneLeafRel leafRel =\n        new NoneLeafRel(\n            cluster,\n            \"a\");\n    NoneSingleRel singleRel =\n        new NoneSingleRel(\n            cluster,\n            leafRel);\n    RelNode convertedRel =\n        planner.changeTraits(\n            singleRel,\n            cluster.traitSetOf(PHYS_CALLING_CONVENTION));\n    planner.changeTraits(leafRel,\n        cluster.traitSetOf(PHYS_CALLING_CONVENTION)\n        .plus(RelCollations.of(0)));\n    planner.setRoot(convertedRel);\n    RelNode result = planner.chooseDelegate().findBestExp();\n    assertTrue(result instanceof PhysSingleRel);\n    assertThat(sort(buf),\n        equalTo(\n            sort(\n                \"NoneSingleRel:Subset#0.NONE.[]\",\n                \"PhysSingleRel:Subset#0.PHYS.[0]\",\n                \"PhysSingleRel:Subset#0.PHYS.[]\")));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/volcano/VolcanoPlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":211,"status":"M"},{"authorDate":"2020-06-09 21:16:22","commitOrder":7,"curCode":"  @Test void testSetMergeMatchSubsetRule() {\n    VolcanoPlanner planner = new VolcanoPlanner();\n    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n    planner.addRelTraitDef(RelCollationTraitDef.INSTANCE);\n\n    planner.addRule(new PhysLeafRule());\n    planner.addRule(new GoodSingleRule());\n    planner.addRule(new PhysSingleInputSetMergeRule());\n    final List<String> buf = new ArrayList<>();\n    planner.addRule(new PhysSingleSubsetRule(buf));\n\n    RelOptCluster cluster = newCluster(planner);\n    NoneLeafRel leafRel = new NoneLeafRel(cluster, \"a\");\n    NoneSingleRel singleRel = new NoneSingleRel(cluster, leafRel);\n    RelNode convertedRel = planner\n        .changeTraits(singleRel, cluster.traitSetOf(PHYS_CALLING_CONVENTION));\n    planner.setRoot(convertedRel);\n    RelNode result = planner.chooseDelegate().findBestExp();\n    assertTrue(result instanceof PhysSingleRel);\n    assertThat(sort(buf),\n        equalTo(\n            sort(\"PhysSingleRel:RelSubset#0.PHYS.[]\",\n            \"PhysSingleRel:RelSubset#0.PHYS_3.[]\")));\n  }\n","date":"2020-06-16 11:11:13","endLine":286,"groupId":"5953","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testSetMergeMatchSubsetRule","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/d9/8b2bf08c9438fbf135785c11034a230a14ee73.src","preCode":"  @Test void testSetMergeMatchSubsetRule() {\n    VolcanoPlanner planner = new VolcanoPlanner();\n    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n    planner.addRelTraitDef(RelCollationTraitDef.INSTANCE);\n\n    planner.addRule(new PhysLeafRule());\n    planner.addRule(new GoodSingleRule());\n    planner.addRule(new PhysSingleInputSetMergeRule());\n    final List<String> buf = new ArrayList<>();\n    planner.addRule(new PhysSingleSubsetRule(buf));\n\n    RelOptCluster cluster = newCluster(planner);\n    NoneLeafRel leafRel = new NoneLeafRel(cluster, \"a\");\n    NoneSingleRel singleRel = new NoneSingleRel(cluster, leafRel);\n    RelNode convertedRel = planner\n        .changeTraits(singleRel, cluster.traitSetOf(PHYS_CALLING_CONVENTION));\n    planner.setRoot(convertedRel);\n    RelNode result = planner.chooseDelegate().findBestExp();\n    assertTrue(result instanceof PhysSingleRel);\n    assertThat(sort(buf),\n        equalTo(\n            sort(\"PhysSingleRel:Subset#0.PHYS.[]\",\n            \"PhysSingleRel:Subset#0.PHYS_3.[]\")));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/volcano/VolcanoPlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":263,"status":"M"}],"commitId":"69f25863f5f4197c17927a39a82cbf1cffd12b80","commitMessage":"@@@[CALCITE-3786] Add Digest interface to enable efficient hashCode(equals) for RexNode and RelNode\n\n* Add class Digest used to identify the node;\n* There is a pre-computed hashcode to speedup #hashCode and #equals;\n* Change RexCall to use object#equals instead of pure string digest\ncomparison;\n* We only support RexInputRef normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing complicated. \nRexNode can always be normalized(default true).\n","date":"2020-06-16 11:11:13","modifiedFileCount":"51","status":"M","submitter":"yuzhao.cyz"},{"authorTime":"2020-07-09 05:31:40","codes":[{"authorDate":"2020-07-09 05:31:40","commitOrder":8,"curCode":"  @Test void testSubsetRule() {\n    VolcanoPlanner planner = new VolcanoPlanner();\n    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n    planner.addRelTraitDef(RelCollationTraitDef.INSTANCE);\n\n    planner.addRule(PhysLeafRule.INSTANCE);\n    planner.addRule(GoodSingleRule.INSTANCE);\n    final List<String> buf = new ArrayList<>();\n    planner.addRule(SubsetRule.config(buf).toRule());\n\n    RelOptCluster cluster = newCluster(planner);\n    NoneLeafRel leafRel =\n        new NoneLeafRel(\n            cluster,\n            \"a\");\n    NoneSingleRel singleRel =\n        new NoneSingleRel(\n            cluster,\n            leafRel);\n    RelNode convertedRel =\n        planner.changeTraits(\n            singleRel,\n            cluster.traitSetOf(PHYS_CALLING_CONVENTION));\n    planner.changeTraits(leafRel,\n        cluster.traitSetOf(PHYS_CALLING_CONVENTION)\n        .plus(RelCollations.of(0)));\n    planner.setRoot(convertedRel);\n    RelNode result = planner.chooseDelegate().findBestExp();\n    assertTrue(result instanceof PhysSingleRel);\n    assertThat(sort(buf),\n        equalTo(\n            sort(\n                \"NoneSingleRel:RelSubset#0.NONE.[]\",\n                \"PhysSingleRel:RelSubset#0.PHYS.[0]\",\n                \"PhysSingleRel:RelSubset#0.PHYS.[]\")));\n  }\n","date":"2020-07-29 02:27:24","endLine":261,"groupId":"101435","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testSubsetRule","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/17/093226350298484f1667b1c8fea7ddee78c549.src","preCode":"  @Test void testSubsetRule() {\n    VolcanoPlanner planner = new VolcanoPlanner();\n    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n    planner.addRelTraitDef(RelCollationTraitDef.INSTANCE);\n\n    planner.addRule(new PhysLeafRule());\n    planner.addRule(new GoodSingleRule());\n    final List<String> buf = new ArrayList<>();\n    planner.addRule(new SubsetRule(buf));\n\n    RelOptCluster cluster = newCluster(planner);\n    NoneLeafRel leafRel =\n        new NoneLeafRel(\n            cluster,\n            \"a\");\n    NoneSingleRel singleRel =\n        new NoneSingleRel(\n            cluster,\n            leafRel);\n    RelNode convertedRel =\n        planner.changeTraits(\n            singleRel,\n            cluster.traitSetOf(PHYS_CALLING_CONVENTION));\n    planner.changeTraits(leafRel,\n        cluster.traitSetOf(PHYS_CALLING_CONVENTION)\n        .plus(RelCollations.of(0)));\n    planner.setRoot(convertedRel);\n    RelNode result = planner.chooseDelegate().findBestExp();\n    assertTrue(result instanceof PhysSingleRel);\n    assertThat(sort(buf),\n        equalTo(\n            sort(\n                \"NoneSingleRel:RelSubset#0.NONE.[]\",\n                \"PhysSingleRel:RelSubset#0.PHYS.[0]\",\n                \"PhysSingleRel:RelSubset#0.PHYS.[]\")));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/volcano/VolcanoPlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":226,"status":"M"},{"authorDate":"2020-07-09 05:31:40","commitOrder":8,"curCode":"  @Test void testSetMergeMatchSubsetRule() {\n    VolcanoPlanner planner = new VolcanoPlanner();\n    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n    planner.addRelTraitDef(RelCollationTraitDef.INSTANCE);\n\n    planner.addRule(PhysLeafRule.INSTANCE);\n    planner.addRule(GoodSingleRule.INSTANCE);\n    planner.addRule(PhysSingleInputSetMergeRule.INSTANCE);\n    final List<String> buf = new ArrayList<>();\n    planner.addRule(PhysSingleSubsetRule.config(buf).toRule());\n\n    RelOptCluster cluster = newCluster(planner);\n    NoneLeafRel leafRel = new NoneLeafRel(cluster, \"a\");\n    NoneSingleRel singleRel = new NoneSingleRel(cluster, leafRel);\n    RelNode convertedRel = planner\n        .changeTraits(singleRel, cluster.traitSetOf(PHYS_CALLING_CONVENTION));\n    planner.setRoot(convertedRel);\n    RelNode result = planner.chooseDelegate().findBestExp();\n    assertTrue(result instanceof PhysSingleRel);\n    assertThat(sort(buf),\n        equalTo(\n            sort(\"PhysSingleRel:RelSubset#0.PHYS.[]\",\n            \"PhysSingleRel:RelSubset#0.PHYS_3.[]\")));\n  }\n","date":"2020-07-29 02:27:24","endLine":301,"groupId":"101435","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testSetMergeMatchSubsetRule","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/17/093226350298484f1667b1c8fea7ddee78c549.src","preCode":"  @Test void testSetMergeMatchSubsetRule() {\n    VolcanoPlanner planner = new VolcanoPlanner();\n    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n    planner.addRelTraitDef(RelCollationTraitDef.INSTANCE);\n\n    planner.addRule(new PhysLeafRule());\n    planner.addRule(new GoodSingleRule());\n    planner.addRule(new PhysSingleInputSetMergeRule());\n    final List<String> buf = new ArrayList<>();\n    planner.addRule(new PhysSingleSubsetRule(buf));\n\n    RelOptCluster cluster = newCluster(planner);\n    NoneLeafRel leafRel = new NoneLeafRel(cluster, \"a\");\n    NoneSingleRel singleRel = new NoneSingleRel(cluster, leafRel);\n    RelNode convertedRel = planner\n        .changeTraits(singleRel, cluster.traitSetOf(PHYS_CALLING_CONVENTION));\n    planner.setRoot(convertedRel);\n    RelNode result = planner.chooseDelegate().findBestExp();\n    assertTrue(result instanceof PhysSingleRel);\n    assertThat(sort(buf),\n        equalTo(\n            sort(\"PhysSingleRel:RelSubset#0.PHYS.[]\",\n            \"PhysSingleRel:RelSubset#0.PHYS_3.[]\")));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/volcano/VolcanoPlannerTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":278,"status":"M"}],"commitId":"998cd83ebe2fcd7ff3ee565299fed6e199269715","commitMessage":"@@@[CALCITE-3923] Refactor how planner rules are parameterized\n\nCreate operands using a builder interface.  OperandBuilder.  and\ndeprecate methods RelOptRule.operand etc.\n\nThe change is backwards compatible.  in the sense that\nexisting rule constructors are deprecated but still work.\nFrom now on.  to create rules.  call RelOptRule.Config.toRule()\n(which calls the rule's (Config) constructor).\n\nSub-classes of ConverterRule are a little different.  They\ndon't need their own sub-class of Config.  You just need to\ncall Config.withRuleFactory to specify the constructor of the\nsub-class of ConverterRule.\n\nMove rule instances into holder classes such as CoreRules. \nMaterializedViewRules. Deprecate existing rule INSTANCE fields\n(to be removed in 1.25). Deprecate previous rule constructors\n(to be removed in 2.0).\n\nDescribe how to write rules in howto and tutorial.\n\nRemove rule instances marked 'deprecated.  to be removed before\n1.25'.\n\nClose apache/calcite#2024\n","date":"2020-07-29 02:27:24","modifiedFileCount":"191","status":"M","submitter":"Julian Hyde"}]
