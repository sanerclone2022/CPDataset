[{"authorTime":"2019-09-10 06:04:05","codes":[{"authorDate":"2019-09-10 06:04:05","commitOrder":1,"curCode":"  @Override protected ViewPartialRewriting compensateViewPartial(\n      RelBuilder relBuilder,\n      RexBuilder rexBuilder,\n      RelMetadataQuery mq,\n      RelNode input,\n      Project topProject,\n      RelNode node,\n      Set<RelTableRef> queryTableRefs,\n      EquivalenceClasses queryEC,\n      Project topViewProject,\n      RelNode viewNode,\n      Set<RelTableRef> viewTableRefs) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    if (fastBailOut) {\n      for (RelNode joinInput : node.getInputs()) {\n        if (mq.getTableReferences(joinInput).containsAll(viewTableRefs)) {\n          return null;\n        }\n      }\n    }\n\n    \r\n    final Set<RelTableRef> extraTableRefs = new HashSet<>();\n    for (RelTableRef tRef : queryTableRefs) {\n      if (!viewTableRefs.contains(tRef)) {\n        \r\n        extraTableRefs.add(tRef);\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    Collection<RelNode> tableScanNodes = mq.getNodeTypes(node).get(TableScan.class);\n    List<RelNode> newRels = new ArrayList<>();\n    for (RelTableRef tRef : extraTableRefs) {\n      int i = 0;\n      for (RelNode relNode : tableScanNodes) {\n        if (tRef.getQualifiedName().equals(relNode.getTable().getQualifiedName())) {\n          if (tRef.getEntityNumber() == i++) {\n            newRels.add(relNode);\n            break;\n          }\n        }\n      }\n    }\n    assert extraTableRefs.size() == newRels.size();\n\n    relBuilder.push(input);\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n    }\n    final RelNode newView = relBuilder.build();\n\n    relBuilder.push(topViewProject != null ? topViewProject : viewNode);\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n    }\n    final RelNode newViewNode = relBuilder.build();\n\n    return ViewPartialRewriting.of(newView, null, newViewNode);\n  }\n","date":"2020-03-05 12:57:25","endLine":138,"groupId":"15083","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"compensateViewPartial","params":"(RelBuilderrelBuilder@RexBuilderrexBuilder@RelMetadataQuerymq@RelNodeinput@ProjecttopProject@RelNodenode@Set<RelTableRef>queryTableRefs@EquivalenceClassesqueryEC@ProjecttopViewProject@RelNodeviewNode@Set<RelTableRef>viewTableRefs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/7b/470fb93872624e49a03ce218a9c76f4d5a4b03.src","preCode":"  @Override protected ViewPartialRewriting compensateViewPartial(\n      RelBuilder relBuilder,\n      RexBuilder rexBuilder,\n      RelMetadataQuery mq,\n      RelNode input,\n      Project topProject,\n      RelNode node,\n      Set<RelTableRef> queryTableRefs,\n      EquivalenceClasses queryEC,\n      Project topViewProject,\n      RelNode viewNode,\n      Set<RelTableRef> viewTableRefs) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    if (fastBailOut) {\n      for (RelNode joinInput : node.getInputs()) {\n        if (mq.getTableReferences(joinInput).containsAll(viewTableRefs)) {\n          return null;\n        }\n      }\n    }\n\n    \r\n    final Set<RelTableRef> extraTableRefs = new HashSet<>();\n    for (RelTableRef tRef : queryTableRefs) {\n      if (!viewTableRefs.contains(tRef)) {\n        \r\n        extraTableRefs.add(tRef);\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    Collection<RelNode> tableScanNodes = mq.getNodeTypes(node).get(TableScan.class);\n    List<RelNode> newRels = new ArrayList<>();\n    for (RelTableRef tRef : extraTableRefs) {\n      int i = 0;\n      for (RelNode relNode : tableScanNodes) {\n        if (tRef.getQualifiedName().equals(relNode.getTable().getQualifiedName())) {\n          if (tRef.getEntityNumber() == i++) {\n            newRels.add(relNode);\n            break;\n          }\n        }\n      }\n    }\n    assert extraTableRefs.size() == newRels.size();\n\n    relBuilder.push(input);\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n    }\n    final RelNode newView = relBuilder.build();\n\n    relBuilder.push(topViewProject != null ? topViewProject : viewNode);\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n    }\n    final RelNode newViewNode = relBuilder.build();\n\n    return ViewPartialRewriting.of(newView, null, newViewNode);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewJoinRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"B"},{"authorDate":"2019-09-10 06:04:05","commitOrder":1,"curCode":"  @Override protected ViewPartialRewriting compensateViewPartial(\n      RelBuilder relBuilder,\n      RexBuilder rexBuilder,\n      RelMetadataQuery mq,\n      RelNode input,\n      Project topProject,\n      RelNode node,\n      Set<RelTableRef> queryTableRefs,\n      EquivalenceClasses queryEC,\n      Project topViewProject,\n      RelNode viewNode,\n      Set<RelTableRef> viewTableRefs) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final Set<RelTableRef> extraTableRefs = new HashSet<>();\n    for (RelTableRef tRef : queryTableRefs) {\n      if (!viewTableRefs.contains(tRef)) {\n        \r\n        extraTableRefs.add(tRef);\n      }\n    }\n    Collection<RelNode> tableScanNodes = mq.getNodeTypes(node).get(TableScan.class);\n    List<RelNode> newRels = new ArrayList<>();\n    for (RelTableRef tRef : extraTableRefs) {\n      int i = 0;\n      for (RelNode relNode : tableScanNodes) {\n        if (tRef.getQualifiedName().equals(relNode.getTable().getQualifiedName())) {\n          if (tRef.getEntityNumber() == i++) {\n            newRels.add(relNode);\n            break;\n          }\n        }\n      }\n    }\n    assert extraTableRefs.size() == newRels.size();\n\n    relBuilder.push(input);\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n    }\n    final RelNode newView = relBuilder.build();\n\n    final Aggregate aggregateViewNode = (Aggregate) viewNode;\n    relBuilder.push(aggregateViewNode.getInput());\n    int offset = 0;\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n      offset += newRel.getRowType().getFieldCount();\n    }\n    \r\n    ImmutableBitSet.Builder groupSet = ImmutableBitSet.builder();\n    groupSet.addAll(aggregateViewNode.getGroupSet());\n    groupSet.addAll(\n        ImmutableBitSet.range(\n            aggregateViewNode.getInput().getRowType().getFieldCount(),\n            aggregateViewNode.getInput().getRowType().getFieldCount() + offset));\n    final Aggregate newViewNode = aggregateViewNode.copy(\n        aggregateViewNode.getTraitSet(), relBuilder.build(),\n        groupSet.build(), null, aggregateViewNode.getAggCallList());\n\n    relBuilder.push(newViewNode);\n    List<RexNode> nodes = new ArrayList<>();\n    List<String> fieldNames = new ArrayList<>();\n    if (topViewProject != null) {\n      \r\n      \r\n      Mappings.TargetMapping shiftMapping = Mappings.createShiftMapping(\n          newViewNode.getRowType().getFieldCount(),\n          0, 0, aggregateViewNode.getGroupCount(),\n          newViewNode.getGroupCount(), aggregateViewNode.getGroupCount(),\n          aggregateViewNode.getAggCallList().size());\n      for (int i = 0; i < topViewProject.getChildExps().size(); i++) {\n        nodes.add(\n            topViewProject.getChildExps().get(i).accept(\n                new RexPermuteInputsShuttle(shiftMapping, newViewNode)));\n        fieldNames.add(topViewProject.getRowType().getFieldNames().get(i));\n      }\n      for (int i = aggregateViewNode.getRowType().getFieldCount();\n           i < newViewNode.getRowType().getFieldCount(); i++) {\n        int idx = i - aggregateViewNode.getAggCallList().size();\n        nodes.add(rexBuilder.makeInputRef(newViewNode, idx));\n        fieldNames.add(newViewNode.getRowType().getFieldNames().get(idx));\n      }\n    } else {\n      \r\n      for (int i = 0; i < newViewNode.getRowType().getFieldCount(); i++) {\n        int idx;\n        if (i < aggregateViewNode.getGroupCount()) {\n          idx = i;\n        } else if (i < aggregateViewNode.getRowType().getFieldCount()) {\n          idx = i + offset;\n        } else {\n          idx = i - aggregateViewNode.getAggCallList().size();\n        }\n        nodes.add(rexBuilder.makeInputRef(newViewNode, idx));\n        fieldNames.add(newViewNode.getRowType().getFieldNames().get(idx));\n      }\n    }\n    relBuilder.project(nodes, fieldNames, true);\n    final Project newTopViewProject = (Project) relBuilder.build();\n\n    return ViewPartialRewriting.of(newView, newTopViewProject, newViewNode);\n  }\n","date":"2020-03-05 12:57:25","endLine":258,"groupId":"11409","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"compensateViewPartial","params":"(RelBuilderrelBuilder@RexBuilderrexBuilder@RelMetadataQuerymq@RelNodeinput@ProjecttopProject@RelNodenode@Set<RelTableRef>queryTableRefs@EquivalenceClassesqueryEC@ProjecttopViewProject@RelNodeviewNode@Set<RelTableRef>viewTableRefs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/de/48ccd992fb9ad6757078e1bb987767a64e039f.src","preCode":"  @Override protected ViewPartialRewriting compensateViewPartial(\n      RelBuilder relBuilder,\n      RexBuilder rexBuilder,\n      RelMetadataQuery mq,\n      RelNode input,\n      Project topProject,\n      RelNode node,\n      Set<RelTableRef> queryTableRefs,\n      EquivalenceClasses queryEC,\n      Project topViewProject,\n      RelNode viewNode,\n      Set<RelTableRef> viewTableRefs) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final Set<RelTableRef> extraTableRefs = new HashSet<>();\n    for (RelTableRef tRef : queryTableRefs) {\n      if (!viewTableRefs.contains(tRef)) {\n        \r\n        extraTableRefs.add(tRef);\n      }\n    }\n    Collection<RelNode> tableScanNodes = mq.getNodeTypes(node).get(TableScan.class);\n    List<RelNode> newRels = new ArrayList<>();\n    for (RelTableRef tRef : extraTableRefs) {\n      int i = 0;\n      for (RelNode relNode : tableScanNodes) {\n        if (tRef.getQualifiedName().equals(relNode.getTable().getQualifiedName())) {\n          if (tRef.getEntityNumber() == i++) {\n            newRels.add(relNode);\n            break;\n          }\n        }\n      }\n    }\n    assert extraTableRefs.size() == newRels.size();\n\n    relBuilder.push(input);\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n    }\n    final RelNode newView = relBuilder.build();\n\n    final Aggregate aggregateViewNode = (Aggregate) viewNode;\n    relBuilder.push(aggregateViewNode.getInput());\n    int offset = 0;\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n      offset += newRel.getRowType().getFieldCount();\n    }\n    \r\n    ImmutableBitSet.Builder groupSet = ImmutableBitSet.builder();\n    groupSet.addAll(aggregateViewNode.getGroupSet());\n    groupSet.addAll(\n        ImmutableBitSet.range(\n            aggregateViewNode.getInput().getRowType().getFieldCount(),\n            aggregateViewNode.getInput().getRowType().getFieldCount() + offset));\n    final Aggregate newViewNode = aggregateViewNode.copy(\n        aggregateViewNode.getTraitSet(), relBuilder.build(),\n        groupSet.build(), null, aggregateViewNode.getAggCallList());\n\n    relBuilder.push(newViewNode);\n    List<RexNode> nodes = new ArrayList<>();\n    List<String> fieldNames = new ArrayList<>();\n    if (topViewProject != null) {\n      \r\n      \r\n      Mappings.TargetMapping shiftMapping = Mappings.createShiftMapping(\n          newViewNode.getRowType().getFieldCount(),\n          0, 0, aggregateViewNode.getGroupCount(),\n          newViewNode.getGroupCount(), aggregateViewNode.getGroupCount(),\n          aggregateViewNode.getAggCallList().size());\n      for (int i = 0; i < topViewProject.getChildExps().size(); i++) {\n        nodes.add(\n            topViewProject.getChildExps().get(i).accept(\n                new RexPermuteInputsShuttle(shiftMapping, newViewNode)));\n        fieldNames.add(topViewProject.getRowType().getFieldNames().get(i));\n      }\n      for (int i = aggregateViewNode.getRowType().getFieldCount();\n           i < newViewNode.getRowType().getFieldCount(); i++) {\n        int idx = i - aggregateViewNode.getAggCallList().size();\n        nodes.add(rexBuilder.makeInputRef(newViewNode, idx));\n        fieldNames.add(newViewNode.getRowType().getFieldNames().get(idx));\n      }\n    } else {\n      \r\n      for (int i = 0; i < newViewNode.getRowType().getFieldCount(); i++) {\n        int idx;\n        if (i < aggregateViewNode.getGroupCount()) {\n          idx = i;\n        } else if (i < aggregateViewNode.getRowType().getFieldCount()) {\n          idx = i + offset;\n        } else {\n          idx = i - aggregateViewNode.getAggCallList().size();\n        }\n        nodes.add(rexBuilder.makeInputRef(newViewNode, idx));\n        fieldNames.add(newViewNode.getRowType().getFieldNames().get(idx));\n      }\n    }\n    relBuilder.project(nodes, fieldNames, true);\n    final Project newTopViewProject = (Project) relBuilder.build();\n\n    return ViewPartialRewriting.of(newView, newTopViewProject, newViewNode);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewAggregateRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":145,"status":"B"}],"commitId":"5dea67890a1916771e9a335e45969f2a4d4f7d3c","commitMessage":"@@@[CALCITE-3825] Split AbstractMaterializedViewRule into multiple classes\n\nClose apache/calcite#1831\n","date":"2020-03-05 12:57:25","modifiedFileCount":"2","status":"B","submitter":"Jesus Camacho Rodriguez"},{"authorTime":"2020-06-09 21:16:22","codes":[{"authorDate":"2019-09-10 06:04:05","commitOrder":2,"curCode":"  @Override protected ViewPartialRewriting compensateViewPartial(\n      RelBuilder relBuilder,\n      RexBuilder rexBuilder,\n      RelMetadataQuery mq,\n      RelNode input,\n      Project topProject,\n      RelNode node,\n      Set<RelTableRef> queryTableRefs,\n      EquivalenceClasses queryEC,\n      Project topViewProject,\n      RelNode viewNode,\n      Set<RelTableRef> viewTableRefs) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    if (fastBailOut) {\n      for (RelNode joinInput : node.getInputs()) {\n        if (mq.getTableReferences(joinInput).containsAll(viewTableRefs)) {\n          return null;\n        }\n      }\n    }\n\n    \r\n    final Set<RelTableRef> extraTableRefs = new HashSet<>();\n    for (RelTableRef tRef : queryTableRefs) {\n      if (!viewTableRefs.contains(tRef)) {\n        \r\n        extraTableRefs.add(tRef);\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    Collection<RelNode> tableScanNodes = mq.getNodeTypes(node).get(TableScan.class);\n    List<RelNode> newRels = new ArrayList<>();\n    for (RelTableRef tRef : extraTableRefs) {\n      int i = 0;\n      for (RelNode relNode : tableScanNodes) {\n        if (tRef.getQualifiedName().equals(relNode.getTable().getQualifiedName())) {\n          if (tRef.getEntityNumber() == i++) {\n            newRels.add(relNode);\n            break;\n          }\n        }\n      }\n    }\n    assert extraTableRefs.size() == newRels.size();\n\n    relBuilder.push(input);\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n    }\n    final RelNode newView = relBuilder.build();\n\n    relBuilder.push(topViewProject != null ? topViewProject : viewNode);\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n    }\n    final RelNode newViewNode = relBuilder.build();\n\n    return ViewPartialRewriting.of(newView, null, newViewNode);\n  }\n","date":"2020-03-05 12:57:25","endLine":138,"groupId":"15083","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"compensateViewPartial","params":"(RelBuilderrelBuilder@RexBuilderrexBuilder@RelMetadataQuerymq@RelNodeinput@ProjecttopProject@RelNodenode@Set<RelTableRef>queryTableRefs@EquivalenceClassesqueryEC@ProjecttopViewProject@RelNodeviewNode@Set<RelTableRef>viewTableRefs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/7b/470fb93872624e49a03ce218a9c76f4d5a4b03.src","preCode":"  @Override protected ViewPartialRewriting compensateViewPartial(\n      RelBuilder relBuilder,\n      RexBuilder rexBuilder,\n      RelMetadataQuery mq,\n      RelNode input,\n      Project topProject,\n      RelNode node,\n      Set<RelTableRef> queryTableRefs,\n      EquivalenceClasses queryEC,\n      Project topViewProject,\n      RelNode viewNode,\n      Set<RelTableRef> viewTableRefs) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    if (fastBailOut) {\n      for (RelNode joinInput : node.getInputs()) {\n        if (mq.getTableReferences(joinInput).containsAll(viewTableRefs)) {\n          return null;\n        }\n      }\n    }\n\n    \r\n    final Set<RelTableRef> extraTableRefs = new HashSet<>();\n    for (RelTableRef tRef : queryTableRefs) {\n      if (!viewTableRefs.contains(tRef)) {\n        \r\n        extraTableRefs.add(tRef);\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    Collection<RelNode> tableScanNodes = mq.getNodeTypes(node).get(TableScan.class);\n    List<RelNode> newRels = new ArrayList<>();\n    for (RelTableRef tRef : extraTableRefs) {\n      int i = 0;\n      for (RelNode relNode : tableScanNodes) {\n        if (tRef.getQualifiedName().equals(relNode.getTable().getQualifiedName())) {\n          if (tRef.getEntityNumber() == i++) {\n            newRels.add(relNode);\n            break;\n          }\n        }\n      }\n    }\n    assert extraTableRefs.size() == newRels.size();\n\n    relBuilder.push(input);\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n    }\n    final RelNode newView = relBuilder.build();\n\n    relBuilder.push(topViewProject != null ? topViewProject : viewNode);\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n    }\n    final RelNode newViewNode = relBuilder.build();\n\n    return ViewPartialRewriting.of(newView, null, newViewNode);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewJoinRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"N"},{"authorDate":"2020-06-09 21:16:22","commitOrder":2,"curCode":"  @Override protected ViewPartialRewriting compensateViewPartial(\n      RelBuilder relBuilder,\n      RexBuilder rexBuilder,\n      RelMetadataQuery mq,\n      RelNode input,\n      Project topProject,\n      RelNode node,\n      Set<RelTableRef> queryTableRefs,\n      EquivalenceClasses queryEC,\n      Project topViewProject,\n      RelNode viewNode,\n      Set<RelTableRef> viewTableRefs) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final Set<RelTableRef> extraTableRefs = new HashSet<>();\n    for (RelTableRef tRef : queryTableRefs) {\n      if (!viewTableRefs.contains(tRef)) {\n        \r\n        extraTableRefs.add(tRef);\n      }\n    }\n    Collection<RelNode> tableScanNodes = mq.getNodeTypes(node).get(TableScan.class);\n    List<RelNode> newRels = new ArrayList<>();\n    for (RelTableRef tRef : extraTableRefs) {\n      int i = 0;\n      for (RelNode relNode : tableScanNodes) {\n        if (tRef.getQualifiedName().equals(relNode.getTable().getQualifiedName())) {\n          if (tRef.getEntityNumber() == i++) {\n            newRels.add(relNode);\n            break;\n          }\n        }\n      }\n    }\n    assert extraTableRefs.size() == newRels.size();\n\n    relBuilder.push(input);\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n    }\n    final RelNode newView = relBuilder.build();\n\n    final Aggregate aggregateViewNode = (Aggregate) viewNode;\n    relBuilder.push(aggregateViewNode.getInput());\n    int offset = 0;\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n      offset += newRel.getRowType().getFieldCount();\n    }\n    \r\n    ImmutableBitSet.Builder groupSet = ImmutableBitSet.builder();\n    groupSet.addAll(aggregateViewNode.getGroupSet());\n    groupSet.addAll(\n        ImmutableBitSet.range(\n            aggregateViewNode.getInput().getRowType().getFieldCount(),\n            aggregateViewNode.getInput().getRowType().getFieldCount() + offset));\n    final Aggregate newViewNode = aggregateViewNode.copy(\n        aggregateViewNode.getTraitSet(), relBuilder.build(),\n        groupSet.build(), null, aggregateViewNode.getAggCallList());\n\n    relBuilder.push(newViewNode);\n    List<RexNode> nodes = new ArrayList<>();\n    List<String> fieldNames = new ArrayList<>();\n    if (topViewProject != null) {\n      \r\n      \r\n      Mappings.TargetMapping shiftMapping = Mappings.createShiftMapping(\n          newViewNode.getRowType().getFieldCount(),\n          0, 0, aggregateViewNode.getGroupCount(),\n          newViewNode.getGroupCount(), aggregateViewNode.getGroupCount(),\n          aggregateViewNode.getAggCallList().size());\n      for (int i = 0; i < topViewProject.getProjects().size(); i++) {\n        nodes.add(\n            topViewProject.getProjects().get(i).accept(\n                new RexPermuteInputsShuttle(shiftMapping, newViewNode)));\n        fieldNames.add(topViewProject.getRowType().getFieldNames().get(i));\n      }\n      for (int i = aggregateViewNode.getRowType().getFieldCount();\n           i < newViewNode.getRowType().getFieldCount(); i++) {\n        int idx = i - aggregateViewNode.getAggCallList().size();\n        nodes.add(rexBuilder.makeInputRef(newViewNode, idx));\n        fieldNames.add(newViewNode.getRowType().getFieldNames().get(idx));\n      }\n    } else {\n      \r\n      for (int i = 0; i < newViewNode.getRowType().getFieldCount(); i++) {\n        int idx;\n        if (i < aggregateViewNode.getGroupCount()) {\n          idx = i;\n        } else if (i < aggregateViewNode.getRowType().getFieldCount()) {\n          idx = i + offset;\n        } else {\n          idx = i - aggregateViewNode.getAggCallList().size();\n        }\n        nodes.add(rexBuilder.makeInputRef(newViewNode, idx));\n        fieldNames.add(newViewNode.getRowType().getFieldNames().get(idx));\n      }\n    }\n    relBuilder.project(nodes, fieldNames, true);\n    final Project newTopViewProject = (Project) relBuilder.build();\n\n    return ViewPartialRewriting.of(newView, newTopViewProject, newViewNode);\n  }\n","date":"2020-06-16 11:11:13","endLine":259,"groupId":"11409","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"compensateViewPartial","params":"(RelBuilderrelBuilder@RexBuilderrexBuilder@RelMetadataQuerymq@RelNodeinput@ProjecttopProject@RelNodenode@Set<RelTableRef>queryTableRefs@EquivalenceClassesqueryEC@ProjecttopViewProject@RelNodeviewNode@Set<RelTableRef>viewTableRefs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/9c/cacf67582041d98bdbee91219b5e2e5970e33d.src","preCode":"  @Override protected ViewPartialRewriting compensateViewPartial(\n      RelBuilder relBuilder,\n      RexBuilder rexBuilder,\n      RelMetadataQuery mq,\n      RelNode input,\n      Project topProject,\n      RelNode node,\n      Set<RelTableRef> queryTableRefs,\n      EquivalenceClasses queryEC,\n      Project topViewProject,\n      RelNode viewNode,\n      Set<RelTableRef> viewTableRefs) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final Set<RelTableRef> extraTableRefs = new HashSet<>();\n    for (RelTableRef tRef : queryTableRefs) {\n      if (!viewTableRefs.contains(tRef)) {\n        \r\n        extraTableRefs.add(tRef);\n      }\n    }\n    Collection<RelNode> tableScanNodes = mq.getNodeTypes(node).get(TableScan.class);\n    List<RelNode> newRels = new ArrayList<>();\n    for (RelTableRef tRef : extraTableRefs) {\n      int i = 0;\n      for (RelNode relNode : tableScanNodes) {\n        if (tRef.getQualifiedName().equals(relNode.getTable().getQualifiedName())) {\n          if (tRef.getEntityNumber() == i++) {\n            newRels.add(relNode);\n            break;\n          }\n        }\n      }\n    }\n    assert extraTableRefs.size() == newRels.size();\n\n    relBuilder.push(input);\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n    }\n    final RelNode newView = relBuilder.build();\n\n    final Aggregate aggregateViewNode = (Aggregate) viewNode;\n    relBuilder.push(aggregateViewNode.getInput());\n    int offset = 0;\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n      offset += newRel.getRowType().getFieldCount();\n    }\n    \r\n    ImmutableBitSet.Builder groupSet = ImmutableBitSet.builder();\n    groupSet.addAll(aggregateViewNode.getGroupSet());\n    groupSet.addAll(\n        ImmutableBitSet.range(\n            aggregateViewNode.getInput().getRowType().getFieldCount(),\n            aggregateViewNode.getInput().getRowType().getFieldCount() + offset));\n    final Aggregate newViewNode = aggregateViewNode.copy(\n        aggregateViewNode.getTraitSet(), relBuilder.build(),\n        groupSet.build(), null, aggregateViewNode.getAggCallList());\n\n    relBuilder.push(newViewNode);\n    List<RexNode> nodes = new ArrayList<>();\n    List<String> fieldNames = new ArrayList<>();\n    if (topViewProject != null) {\n      \r\n      \r\n      Mappings.TargetMapping shiftMapping = Mappings.createShiftMapping(\n          newViewNode.getRowType().getFieldCount(),\n          0, 0, aggregateViewNode.getGroupCount(),\n          newViewNode.getGroupCount(), aggregateViewNode.getGroupCount(),\n          aggregateViewNode.getAggCallList().size());\n      for (int i = 0; i < topViewProject.getChildExps().size(); i++) {\n        nodes.add(\n            topViewProject.getChildExps().get(i).accept(\n                new RexPermuteInputsShuttle(shiftMapping, newViewNode)));\n        fieldNames.add(topViewProject.getRowType().getFieldNames().get(i));\n      }\n      for (int i = aggregateViewNode.getRowType().getFieldCount();\n           i < newViewNode.getRowType().getFieldCount(); i++) {\n        int idx = i - aggregateViewNode.getAggCallList().size();\n        nodes.add(rexBuilder.makeInputRef(newViewNode, idx));\n        fieldNames.add(newViewNode.getRowType().getFieldNames().get(idx));\n      }\n    } else {\n      \r\n      for (int i = 0; i < newViewNode.getRowType().getFieldCount(); i++) {\n        int idx;\n        if (i < aggregateViewNode.getGroupCount()) {\n          idx = i;\n        } else if (i < aggregateViewNode.getRowType().getFieldCount()) {\n          idx = i + offset;\n        } else {\n          idx = i - aggregateViewNode.getAggCallList().size();\n        }\n        nodes.add(rexBuilder.makeInputRef(newViewNode, idx));\n        fieldNames.add(newViewNode.getRowType().getFieldNames().get(idx));\n      }\n    }\n    relBuilder.project(nodes, fieldNames, true);\n    final Project newTopViewProject = (Project) relBuilder.build();\n\n    return ViewPartialRewriting.of(newView, newTopViewProject, newViewNode);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewAggregateRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":146,"status":"M"}],"commitId":"69f25863f5f4197c17927a39a82cbf1cffd12b80","commitMessage":"@@@[CALCITE-3786] Add Digest interface to enable efficient hashCode(equals) for RexNode and RelNode\n\n* Add class Digest used to identify the node;\n* There is a pre-computed hashcode to speedup #hashCode and #equals;\n* Change RexCall to use object#equals instead of pure string digest\ncomparison;\n* We only support RexInputRef normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing complicated. \nRexNode can always be normalized(default true).\n","date":"2020-06-16 11:11:13","modifiedFileCount":"51","status":"M","submitter":"yuzhao.cyz"},{"authorTime":"2020-06-09 21:16:22","codes":[{"authorDate":"2020-07-09 05:31:40","commitOrder":3,"curCode":"  @Override protected ViewPartialRewriting compensateViewPartial(\n      RelBuilder relBuilder,\n      RexBuilder rexBuilder,\n      RelMetadataQuery mq,\n      RelNode input,\n      Project topProject,\n      RelNode node,\n      Set<RelTableRef> queryTableRefs,\n      EquivalenceClasses queryEC,\n      Project topViewProject,\n      RelNode viewNode,\n      Set<RelTableRef> viewTableRefs) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    if (config.fastBailOut()) {\n      for (RelNode joinInput : node.getInputs()) {\n        if (mq.getTableReferences(joinInput).containsAll(viewTableRefs)) {\n          return null;\n        }\n      }\n    }\n\n    \r\n    final Set<RelTableRef> extraTableRefs = new HashSet<>();\n    for (RelTableRef tRef : queryTableRefs) {\n      if (!viewTableRefs.contains(tRef)) {\n        \r\n        extraTableRefs.add(tRef);\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    Collection<RelNode> tableScanNodes = mq.getNodeTypes(node).get(TableScan.class);\n    List<RelNode> newRels = new ArrayList<>();\n    for (RelTableRef tRef : extraTableRefs) {\n      int i = 0;\n      for (RelNode relNode : tableScanNodes) {\n        if (tRef.getQualifiedName().equals(relNode.getTable().getQualifiedName())) {\n          if (tRef.getEntityNumber() == i++) {\n            newRels.add(relNode);\n            break;\n          }\n        }\n      }\n    }\n    assert extraTableRefs.size() == newRels.size();\n\n    relBuilder.push(input);\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n    }\n    final RelNode newView = relBuilder.build();\n\n    relBuilder.push(topViewProject != null ? topViewProject : viewNode);\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n    }\n    final RelNode newViewNode = relBuilder.build();\n\n    return ViewPartialRewriting.of(newView, null, newViewNode);\n  }\n","date":"2020-07-29 02:27:24","endLine":135,"groupId":"15083","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"compensateViewPartial","params":"(RelBuilderrelBuilder@RexBuilderrexBuilder@RelMetadataQuerymq@RelNodeinput@ProjecttopProject@RelNodenode@Set<RelTableRef>queryTableRefs@EquivalenceClassesqueryEC@ProjecttopViewProject@RelNodeviewNode@Set<RelTableRef>viewTableRefs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/d6/4c39b12e9ba93fd9f5742085196b03b92c4704.src","preCode":"  @Override protected ViewPartialRewriting compensateViewPartial(\n      RelBuilder relBuilder,\n      RexBuilder rexBuilder,\n      RelMetadataQuery mq,\n      RelNode input,\n      Project topProject,\n      RelNode node,\n      Set<RelTableRef> queryTableRefs,\n      EquivalenceClasses queryEC,\n      Project topViewProject,\n      RelNode viewNode,\n      Set<RelTableRef> viewTableRefs) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    if (fastBailOut) {\n      for (RelNode joinInput : node.getInputs()) {\n        if (mq.getTableReferences(joinInput).containsAll(viewTableRefs)) {\n          return null;\n        }\n      }\n    }\n\n    \r\n    final Set<RelTableRef> extraTableRefs = new HashSet<>();\n    for (RelTableRef tRef : queryTableRefs) {\n      if (!viewTableRefs.contains(tRef)) {\n        \r\n        extraTableRefs.add(tRef);\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    Collection<RelNode> tableScanNodes = mq.getNodeTypes(node).get(TableScan.class);\n    List<RelNode> newRels = new ArrayList<>();\n    for (RelTableRef tRef : extraTableRefs) {\n      int i = 0;\n      for (RelNode relNode : tableScanNodes) {\n        if (tRef.getQualifiedName().equals(relNode.getTable().getQualifiedName())) {\n          if (tRef.getEntityNumber() == i++) {\n            newRels.add(relNode);\n            break;\n          }\n        }\n      }\n    }\n    assert extraTableRefs.size() == newRels.size();\n\n    relBuilder.push(input);\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n    }\n    final RelNode newView = relBuilder.build();\n\n    relBuilder.push(topViewProject != null ? topViewProject : viewNode);\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n    }\n    final RelNode newViewNode = relBuilder.build();\n\n    return ViewPartialRewriting.of(newView, null, newViewNode);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewJoinRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":60,"status":"M"},{"authorDate":"2020-06-09 21:16:22","commitOrder":3,"curCode":"  @Override protected ViewPartialRewriting compensateViewPartial(\n      RelBuilder relBuilder,\n      RexBuilder rexBuilder,\n      RelMetadataQuery mq,\n      RelNode input,\n      Project topProject,\n      RelNode node,\n      Set<RelTableRef> queryTableRefs,\n      EquivalenceClasses queryEC,\n      Project topViewProject,\n      RelNode viewNode,\n      Set<RelTableRef> viewTableRefs) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final Set<RelTableRef> extraTableRefs = new HashSet<>();\n    for (RelTableRef tRef : queryTableRefs) {\n      if (!viewTableRefs.contains(tRef)) {\n        \r\n        extraTableRefs.add(tRef);\n      }\n    }\n    Collection<RelNode> tableScanNodes = mq.getNodeTypes(node).get(TableScan.class);\n    List<RelNode> newRels = new ArrayList<>();\n    for (RelTableRef tRef : extraTableRefs) {\n      int i = 0;\n      for (RelNode relNode : tableScanNodes) {\n        if (tRef.getQualifiedName().equals(relNode.getTable().getQualifiedName())) {\n          if (tRef.getEntityNumber() == i++) {\n            newRels.add(relNode);\n            break;\n          }\n        }\n      }\n    }\n    assert extraTableRefs.size() == newRels.size();\n\n    relBuilder.push(input);\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n    }\n    final RelNode newView = relBuilder.build();\n\n    final Aggregate aggregateViewNode = (Aggregate) viewNode;\n    relBuilder.push(aggregateViewNode.getInput());\n    int offset = 0;\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n      offset += newRel.getRowType().getFieldCount();\n    }\n    \r\n    ImmutableBitSet.Builder groupSet = ImmutableBitSet.builder();\n    groupSet.addAll(aggregateViewNode.getGroupSet());\n    groupSet.addAll(\n        ImmutableBitSet.range(\n            aggregateViewNode.getInput().getRowType().getFieldCount(),\n            aggregateViewNode.getInput().getRowType().getFieldCount() + offset));\n    final Aggregate newViewNode = aggregateViewNode.copy(\n        aggregateViewNode.getTraitSet(), relBuilder.build(),\n        groupSet.build(), null, aggregateViewNode.getAggCallList());\n\n    relBuilder.push(newViewNode);\n    List<RexNode> nodes = new ArrayList<>();\n    List<String> fieldNames = new ArrayList<>();\n    if (topViewProject != null) {\n      \r\n      \r\n      Mappings.TargetMapping shiftMapping = Mappings.createShiftMapping(\n          newViewNode.getRowType().getFieldCount(),\n          0, 0, aggregateViewNode.getGroupCount(),\n          newViewNode.getGroupCount(), aggregateViewNode.getGroupCount(),\n          aggregateViewNode.getAggCallList().size());\n      for (int i = 0; i < topViewProject.getProjects().size(); i++) {\n        nodes.add(\n            topViewProject.getProjects().get(i).accept(\n                new RexPermuteInputsShuttle(shiftMapping, newViewNode)));\n        fieldNames.add(topViewProject.getRowType().getFieldNames().get(i));\n      }\n      for (int i = aggregateViewNode.getRowType().getFieldCount();\n           i < newViewNode.getRowType().getFieldCount(); i++) {\n        int idx = i - aggregateViewNode.getAggCallList().size();\n        nodes.add(rexBuilder.makeInputRef(newViewNode, idx));\n        fieldNames.add(newViewNode.getRowType().getFieldNames().get(idx));\n      }\n    } else {\n      \r\n      for (int i = 0; i < newViewNode.getRowType().getFieldCount(); i++) {\n        int idx;\n        if (i < aggregateViewNode.getGroupCount()) {\n          idx = i;\n        } else if (i < aggregateViewNode.getRowType().getFieldCount()) {\n          idx = i + offset;\n        } else {\n          idx = i - aggregateViewNode.getAggCallList().size();\n        }\n        nodes.add(rexBuilder.makeInputRef(newViewNode, idx));\n        fieldNames.add(newViewNode.getRowType().getFieldNames().get(idx));\n      }\n    }\n    relBuilder.project(nodes, fieldNames, true);\n    final Project newTopViewProject = (Project) relBuilder.build();\n\n    return ViewPartialRewriting.of(newView, newTopViewProject, newViewNode);\n  }\n","date":"2020-06-16 11:11:13","endLine":259,"groupId":"11409","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"compensateViewPartial","params":"(RelBuilderrelBuilder@RexBuilderrexBuilder@RelMetadataQuerymq@RelNodeinput@ProjecttopProject@RelNodenode@Set<RelTableRef>queryTableRefs@EquivalenceClassesqueryEC@ProjecttopViewProject@RelNodeviewNode@Set<RelTableRef>viewTableRefs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/9c/cacf67582041d98bdbee91219b5e2e5970e33d.src","preCode":"  @Override protected ViewPartialRewriting compensateViewPartial(\n      RelBuilder relBuilder,\n      RexBuilder rexBuilder,\n      RelMetadataQuery mq,\n      RelNode input,\n      Project topProject,\n      RelNode node,\n      Set<RelTableRef> queryTableRefs,\n      EquivalenceClasses queryEC,\n      Project topViewProject,\n      RelNode viewNode,\n      Set<RelTableRef> viewTableRefs) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final Set<RelTableRef> extraTableRefs = new HashSet<>();\n    for (RelTableRef tRef : queryTableRefs) {\n      if (!viewTableRefs.contains(tRef)) {\n        \r\n        extraTableRefs.add(tRef);\n      }\n    }\n    Collection<RelNode> tableScanNodes = mq.getNodeTypes(node).get(TableScan.class);\n    List<RelNode> newRels = new ArrayList<>();\n    for (RelTableRef tRef : extraTableRefs) {\n      int i = 0;\n      for (RelNode relNode : tableScanNodes) {\n        if (tRef.getQualifiedName().equals(relNode.getTable().getQualifiedName())) {\n          if (tRef.getEntityNumber() == i++) {\n            newRels.add(relNode);\n            break;\n          }\n        }\n      }\n    }\n    assert extraTableRefs.size() == newRels.size();\n\n    relBuilder.push(input);\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n    }\n    final RelNode newView = relBuilder.build();\n\n    final Aggregate aggregateViewNode = (Aggregate) viewNode;\n    relBuilder.push(aggregateViewNode.getInput());\n    int offset = 0;\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n      offset += newRel.getRowType().getFieldCount();\n    }\n    \r\n    ImmutableBitSet.Builder groupSet = ImmutableBitSet.builder();\n    groupSet.addAll(aggregateViewNode.getGroupSet());\n    groupSet.addAll(\n        ImmutableBitSet.range(\n            aggregateViewNode.getInput().getRowType().getFieldCount(),\n            aggregateViewNode.getInput().getRowType().getFieldCount() + offset));\n    final Aggregate newViewNode = aggregateViewNode.copy(\n        aggregateViewNode.getTraitSet(), relBuilder.build(),\n        groupSet.build(), null, aggregateViewNode.getAggCallList());\n\n    relBuilder.push(newViewNode);\n    List<RexNode> nodes = new ArrayList<>();\n    List<String> fieldNames = new ArrayList<>();\n    if (topViewProject != null) {\n      \r\n      \r\n      Mappings.TargetMapping shiftMapping = Mappings.createShiftMapping(\n          newViewNode.getRowType().getFieldCount(),\n          0, 0, aggregateViewNode.getGroupCount(),\n          newViewNode.getGroupCount(), aggregateViewNode.getGroupCount(),\n          aggregateViewNode.getAggCallList().size());\n      for (int i = 0; i < topViewProject.getProjects().size(); i++) {\n        nodes.add(\n            topViewProject.getProjects().get(i).accept(\n                new RexPermuteInputsShuttle(shiftMapping, newViewNode)));\n        fieldNames.add(topViewProject.getRowType().getFieldNames().get(i));\n      }\n      for (int i = aggregateViewNode.getRowType().getFieldCount();\n           i < newViewNode.getRowType().getFieldCount(); i++) {\n        int idx = i - aggregateViewNode.getAggCallList().size();\n        nodes.add(rexBuilder.makeInputRef(newViewNode, idx));\n        fieldNames.add(newViewNode.getRowType().getFieldNames().get(idx));\n      }\n    } else {\n      \r\n      for (int i = 0; i < newViewNode.getRowType().getFieldCount(); i++) {\n        int idx;\n        if (i < aggregateViewNode.getGroupCount()) {\n          idx = i;\n        } else if (i < aggregateViewNode.getRowType().getFieldCount()) {\n          idx = i + offset;\n        } else {\n          idx = i - aggregateViewNode.getAggCallList().size();\n        }\n        nodes.add(rexBuilder.makeInputRef(newViewNode, idx));\n        fieldNames.add(newViewNode.getRowType().getFieldNames().get(idx));\n      }\n    }\n    relBuilder.project(nodes, fieldNames, true);\n    final Project newTopViewProject = (Project) relBuilder.build();\n\n    return ViewPartialRewriting.of(newView, newTopViewProject, newViewNode);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewAggregateRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":146,"status":"N"}],"commitId":"998cd83ebe2fcd7ff3ee565299fed6e199269715","commitMessage":"@@@[CALCITE-3923] Refactor how planner rules are parameterized\n\nCreate operands using a builder interface.  OperandBuilder.  and\ndeprecate methods RelOptRule.operand etc.\n\nThe change is backwards compatible.  in the sense that\nexisting rule constructors are deprecated but still work.\nFrom now on.  to create rules.  call RelOptRule.Config.toRule()\n(which calls the rule's (Config) constructor).\n\nSub-classes of ConverterRule are a little different.  They\ndon't need their own sub-class of Config.  You just need to\ncall Config.withRuleFactory to specify the constructor of the\nsub-class of ConverterRule.\n\nMove rule instances into holder classes such as CoreRules. \nMaterializedViewRules. Deprecate existing rule INSTANCE fields\n(to be removed in 1.25). Deprecate previous rule constructors\n(to be removed in 2.0).\n\nDescribe how to write rules in howto and tutorial.\n\nRemove rule instances marked 'deprecated.  to be removed before\n1.25'.\n\nClose apache/calcite#2024\n","date":"2020-07-29 02:27:24","modifiedFileCount":"191","status":"M","submitter":"Julian Hyde"},{"authorTime":"2020-05-29 00:04:40","codes":[{"authorDate":"2020-05-29 00:04:40","commitOrder":4,"curCode":"  @Override protected @Nullable ViewPartialRewriting compensateViewPartial(\n      RelBuilder relBuilder,\n      RexBuilder rexBuilder,\n      RelMetadataQuery mq,\n      RelNode input,\n      @Nullable Project topProject,\n      RelNode node,\n      Set<RelTableRef> queryTableRefs,\n      EquivalenceClasses queryEC,\n      @Nullable Project topViewProject,\n      RelNode viewNode,\n      Set<RelTableRef> viewTableRefs) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    if (config.fastBailOut()) {\n      for (RelNode joinInput : node.getInputs()) {\n        Set<RelTableRef> tableReferences = mq.getTableReferences(joinInput);\n        if (tableReferences == null || tableReferences.containsAll(viewTableRefs)) {\n          return null;\n        }\n      }\n    }\n\n    \r\n    final Set<RelTableRef> extraTableRefs = new HashSet<>();\n    for (RelTableRef tRef : queryTableRefs) {\n      if (!viewTableRefs.contains(tRef)) {\n        \r\n        extraTableRefs.add(tRef);\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    Multimap<Class<? extends RelNode>, RelNode> nodeTypes = mq.getNodeTypes(node);\n    if (nodeTypes == null) {\n      return null;\n    }\n    Collection<RelNode> tableScanNodes = nodeTypes.get(TableScan.class);\n    List<RelNode> newRels = new ArrayList<>();\n    for (RelTableRef tRef : extraTableRefs) {\n      int i = 0;\n      for (RelNode relNode : tableScanNodes) {\n        TableScan scan = (TableScan) relNode;\n        if (tRef.getQualifiedName().equals(scan.getTable().getQualifiedName())) {\n          if (tRef.getEntityNumber() == i++) {\n            newRels.add(relNode);\n            break;\n          }\n        }\n      }\n    }\n    assert extraTableRefs.size() == newRels.size();\n\n    relBuilder.push(input);\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n    }\n    final RelNode newView = relBuilder.build();\n\n    relBuilder.push(topViewProject != null ? topViewProject : viewNode);\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n    }\n    final RelNode newViewNode = relBuilder.build();\n\n    return ViewPartialRewriting.of(newView, null, newViewNode);\n  }\n","date":"2020-11-30 06:45:33","endLine":145,"groupId":"102034","id":7,"instanceNumber":1,"isCurCommit":1,"methodName":"compensateViewPartial","params":"(RelBuilderrelBuilder@RexBuilderrexBuilder@RelMetadataQuerymq@RelNodeinput@@NullableProjecttopProject@RelNodenode@Set<RelTableRef>queryTableRefs@EquivalenceClassesqueryEC@@NullableProjecttopViewProject@RelNodeviewNode@Set<RelTableRef>viewTableRefs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/b4/d83099adda16a787a173c83d1d010d8077f8ff.src","preCode":"  @Override protected ViewPartialRewriting compensateViewPartial(\n      RelBuilder relBuilder,\n      RexBuilder rexBuilder,\n      RelMetadataQuery mq,\n      RelNode input,\n      Project topProject,\n      RelNode node,\n      Set<RelTableRef> queryTableRefs,\n      EquivalenceClasses queryEC,\n      Project topViewProject,\n      RelNode viewNode,\n      Set<RelTableRef> viewTableRefs) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    if (config.fastBailOut()) {\n      for (RelNode joinInput : node.getInputs()) {\n        if (mq.getTableReferences(joinInput).containsAll(viewTableRefs)) {\n          return null;\n        }\n      }\n    }\n\n    \r\n    final Set<RelTableRef> extraTableRefs = new HashSet<>();\n    for (RelTableRef tRef : queryTableRefs) {\n      if (!viewTableRefs.contains(tRef)) {\n        \r\n        extraTableRefs.add(tRef);\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    Collection<RelNode> tableScanNodes = mq.getNodeTypes(node).get(TableScan.class);\n    List<RelNode> newRels = new ArrayList<>();\n    for (RelTableRef tRef : extraTableRefs) {\n      int i = 0;\n      for (RelNode relNode : tableScanNodes) {\n        if (tRef.getQualifiedName().equals(relNode.getTable().getQualifiedName())) {\n          if (tRef.getEntityNumber() == i++) {\n            newRels.add(relNode);\n            break;\n          }\n        }\n      }\n    }\n    assert extraTableRefs.size() == newRels.size();\n\n    relBuilder.push(input);\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n    }\n    final RelNode newView = relBuilder.build();\n\n    relBuilder.push(topViewProject != null ? topViewProject : viewNode);\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n    }\n    final RelNode newViewNode = relBuilder.build();\n\n    return ViewPartialRewriting.of(newView, null, newViewNode);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewJoinRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":64,"status":"M"},{"authorDate":"2020-05-29 00:04:40","commitOrder":4,"curCode":"  @Override protected @Nullable ViewPartialRewriting compensateViewPartial(\n      RelBuilder relBuilder,\n      RexBuilder rexBuilder,\n      RelMetadataQuery mq,\n      RelNode input,\n      @Nullable Project topProject,\n      RelNode node,\n      Set<RelTableRef> queryTableRefs,\n      EquivalenceClasses queryEC,\n      @Nullable Project topViewProject,\n      RelNode viewNode,\n      Set<RelTableRef> viewTableRefs) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final Set<RelTableRef> extraTableRefs = new HashSet<>();\n    for (RelTableRef tRef : queryTableRefs) {\n      if (!viewTableRefs.contains(tRef)) {\n        \r\n        extraTableRefs.add(tRef);\n      }\n    }\n    Multimap<Class<? extends RelNode>, RelNode> nodeTypes = mq.getNodeTypes(node);\n    if (nodeTypes == null) {\n      return null;\n    }\n    Collection<RelNode> tableScanNodes = nodeTypes.get(TableScan.class);\n    if (tableScanNodes == null) {\n      return null;\n    }\n    List<RelNode> newRels = new ArrayList<>();\n    for (RelTableRef tRef : extraTableRefs) {\n      int i = 0;\n      for (RelNode relNode : tableScanNodes) {\n        TableScan scan = (TableScan) relNode;\n        if (tRef.getQualifiedName().equals(scan.getTable().getQualifiedName())) {\n          if (tRef.getEntityNumber() == i++) {\n            newRels.add(relNode);\n            break;\n          }\n        }\n      }\n    }\n    assert extraTableRefs.size() == newRels.size();\n\n    relBuilder.push(input);\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n    }\n    final RelNode newView = relBuilder.build();\n\n    final Aggregate aggregateViewNode = (Aggregate) viewNode;\n    relBuilder.push(aggregateViewNode.getInput());\n    int offset = 0;\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n      offset += newRel.getRowType().getFieldCount();\n    }\n    \r\n    ImmutableBitSet.Builder groupSet = ImmutableBitSet.builder();\n    groupSet.addAll(aggregateViewNode.getGroupSet());\n    groupSet.addAll(\n        ImmutableBitSet.range(\n            aggregateViewNode.getInput().getRowType().getFieldCount(),\n            aggregateViewNode.getInput().getRowType().getFieldCount() + offset));\n    final Aggregate newViewNode = aggregateViewNode.copy(\n        aggregateViewNode.getTraitSet(), relBuilder.build(),\n        groupSet.build(), null, aggregateViewNode.getAggCallList());\n\n    relBuilder.push(newViewNode);\n    List<RexNode> nodes = new ArrayList<>();\n    List<String> fieldNames = new ArrayList<>();\n    if (topViewProject != null) {\n      \r\n      \r\n      Mappings.TargetMapping shiftMapping = Mappings.createShiftMapping(\n          newViewNode.getRowType().getFieldCount(),\n          0, 0, aggregateViewNode.getGroupCount(),\n          newViewNode.getGroupCount(), aggregateViewNode.getGroupCount(),\n          aggregateViewNode.getAggCallList().size());\n      for (int i = 0; i < topViewProject.getProjects().size(); i++) {\n        nodes.add(\n            topViewProject.getProjects().get(i).accept(\n                new RexPermuteInputsShuttle(shiftMapping, newViewNode)));\n        fieldNames.add(topViewProject.getRowType().getFieldNames().get(i));\n      }\n      for (int i = aggregateViewNode.getRowType().getFieldCount();\n           i < newViewNode.getRowType().getFieldCount(); i++) {\n        int idx = i - aggregateViewNode.getAggCallList().size();\n        nodes.add(rexBuilder.makeInputRef(newViewNode, idx));\n        fieldNames.add(newViewNode.getRowType().getFieldNames().get(idx));\n      }\n    } else {\n      \r\n      for (int i = 0; i < newViewNode.getRowType().getFieldCount(); i++) {\n        int idx;\n        if (i < aggregateViewNode.getGroupCount()) {\n          idx = i;\n        } else if (i < aggregateViewNode.getRowType().getFieldCount()) {\n          idx = i + offset;\n        } else {\n          idx = i - aggregateViewNode.getAggCallList().size();\n        }\n        nodes.add(rexBuilder.makeInputRef(newViewNode, idx));\n        fieldNames.add(newViewNode.getRowType().getFieldNames().get(idx));\n      }\n    }\n    relBuilder.project(nodes, fieldNames, true);\n    final Project newTopViewProject = (Project) relBuilder.build();\n\n    return ViewPartialRewriting.of(newView, newTopViewProject, newViewNode);\n  }\n","date":"2020-11-30 06:45:33","endLine":235,"groupId":"102034","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"compensateViewPartial","params":"(RelBuilderrelBuilder@RexBuilderrexBuilder@RelMetadataQuerymq@RelNodeinput@@NullableProjecttopProject@RelNodenode@Set<RelTableRef>queryTableRefs@EquivalenceClassesqueryEC@@NullableProjecttopViewProject@RelNodeviewNode@Set<RelTableRef>viewTableRefs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/34/ae63927160934747d90d9559c4fb0728d09f55.src","preCode":"  @Override protected ViewPartialRewriting compensateViewPartial(\n      RelBuilder relBuilder,\n      RexBuilder rexBuilder,\n      RelMetadataQuery mq,\n      RelNode input,\n      Project topProject,\n      RelNode node,\n      Set<RelTableRef> queryTableRefs,\n      EquivalenceClasses queryEC,\n      Project topViewProject,\n      RelNode viewNode,\n      Set<RelTableRef> viewTableRefs) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final Set<RelTableRef> extraTableRefs = new HashSet<>();\n    for (RelTableRef tRef : queryTableRefs) {\n      if (!viewTableRefs.contains(tRef)) {\n        \r\n        extraTableRefs.add(tRef);\n      }\n    }\n    Collection<RelNode> tableScanNodes = mq.getNodeTypes(node).get(TableScan.class);\n    List<RelNode> newRels = new ArrayList<>();\n    for (RelTableRef tRef : extraTableRefs) {\n      int i = 0;\n      for (RelNode relNode : tableScanNodes) {\n        if (tRef.getQualifiedName().equals(relNode.getTable().getQualifiedName())) {\n          if (tRef.getEntityNumber() == i++) {\n            newRels.add(relNode);\n            break;\n          }\n        }\n      }\n    }\n    assert extraTableRefs.size() == newRels.size();\n\n    relBuilder.push(input);\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n    }\n    final RelNode newView = relBuilder.build();\n\n    final Aggregate aggregateViewNode = (Aggregate) viewNode;\n    relBuilder.push(aggregateViewNode.getInput());\n    int offset = 0;\n    for (RelNode newRel : newRels) {\n      \r\n      relBuilder.push(newRel);\n      relBuilder.join(JoinRelType.INNER, rexBuilder.makeLiteral(true));\n      offset += newRel.getRowType().getFieldCount();\n    }\n    \r\n    ImmutableBitSet.Builder groupSet = ImmutableBitSet.builder();\n    groupSet.addAll(aggregateViewNode.getGroupSet());\n    groupSet.addAll(\n        ImmutableBitSet.range(\n            aggregateViewNode.getInput().getRowType().getFieldCount(),\n            aggregateViewNode.getInput().getRowType().getFieldCount() + offset));\n    final Aggregate newViewNode = aggregateViewNode.copy(\n        aggregateViewNode.getTraitSet(), relBuilder.build(),\n        groupSet.build(), null, aggregateViewNode.getAggCallList());\n\n    relBuilder.push(newViewNode);\n    List<RexNode> nodes = new ArrayList<>();\n    List<String> fieldNames = new ArrayList<>();\n    if (topViewProject != null) {\n      \r\n      \r\n      Mappings.TargetMapping shiftMapping = Mappings.createShiftMapping(\n          newViewNode.getRowType().getFieldCount(),\n          0, 0, aggregateViewNode.getGroupCount(),\n          newViewNode.getGroupCount(), aggregateViewNode.getGroupCount(),\n          aggregateViewNode.getAggCallList().size());\n      for (int i = 0; i < topViewProject.getProjects().size(); i++) {\n        nodes.add(\n            topViewProject.getProjects().get(i).accept(\n                new RexPermuteInputsShuttle(shiftMapping, newViewNode)));\n        fieldNames.add(topViewProject.getRowType().getFieldNames().get(i));\n      }\n      for (int i = aggregateViewNode.getRowType().getFieldCount();\n           i < newViewNode.getRowType().getFieldCount(); i++) {\n        int idx = i - aggregateViewNode.getAggCallList().size();\n        nodes.add(rexBuilder.makeInputRef(newViewNode, idx));\n        fieldNames.add(newViewNode.getRowType().getFieldNames().get(idx));\n      }\n    } else {\n      \r\n      for (int i = 0; i < newViewNode.getRowType().getFieldCount(); i++) {\n        int idx;\n        if (i < aggregateViewNode.getGroupCount()) {\n          idx = i;\n        } else if (i < aggregateViewNode.getRowType().getFieldCount()) {\n          idx = i + offset;\n        } else {\n          idx = i - aggregateViewNode.getAggCallList().size();\n        }\n        nodes.add(rexBuilder.makeInputRef(newViewNode, idx));\n        fieldNames.add(newViewNode.getRowType().getFieldNames().get(idx));\n      }\n    }\n    relBuilder.project(nodes, fieldNames, true);\n    final Project newTopViewProject = (Project) relBuilder.build();\n\n    return ViewPartialRewriting.of(newView, newTopViewProject, newViewNode);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewAggregateRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":114,"status":"M"}],"commitId":"d9a81b88ad561e7e4cedae93e805e0d7a53a7f1a","commitMessage":"@@@[CALCITE-4199] Add nullability annotations\n\nThe commit includes javadoc updates and refactorings made by Julian Hyde in https://github.com/apache/calcite/pull/2278\n","date":"2020-11-30 06:45:33","modifiedFileCount":"1012","status":"M","submitter":"Vladimir Sitnikov"}]
