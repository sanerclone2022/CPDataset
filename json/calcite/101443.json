[{"authorTime":"2016-03-09 13:31:20","codes":[{"authorDate":"2016-03-09 13:31:20","commitOrder":1,"curCode":"  @Test public void testTraitConversion() {\n    final VolcanoPlanner planner = new VolcanoPlanner();\n    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n    planner.addRelTraitDef(NEW_TRAIT_DEF_INSTANCE);\n\n    planner.addRule(new RandomSingleTraitRule());\n    planner.addRule(new SingleLeafTraitRule());\n    planner.addRule(ExpandConversionRule.INSTANCE);\n\n    final RelOptCluster cluster = newCluster(planner);\n    final NoneLeafRel leafRel = new NoneLeafRel(cluster, \"a\");\n    final NoneSingleRel singleRel = new NoneSingleRel(cluster, leafRel);\n    final RelNode convertedRel =\n        planner.changeTraits(singleRel,\n            cluster.traitSetOf(PHYS_CALLING_CONVENTION));\n    planner.setRoot(convertedRel);\n    final RelNode result = planner.chooseDelegate().findBestExp();\n\n    assertTrue(result instanceof RandomSingleRel);\n    assertTrue(result.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n    assertTrue(result.getTraitSet().contains(SIMPLE_DISTRIBUTION_RANDOM));\n\n    final RelNode input = result.getInput(0);\n    assertTrue(input instanceof BridgeRel);\n    assertTrue(input.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n    assertTrue(input.getTraitSet().contains(SIMPLE_DISTRIBUTION_RANDOM));\n\n    final RelNode input2 = input.getInput(0);\n    assertTrue(input2 instanceof SingletonLeafRel);\n    assertTrue(input2.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n    assertTrue(input2.getTraitSet().contains(SIMPLE_DISTRIBUTION_SINGLETON));\n  }\n","date":"2016-07-08 14:44:51","endLine":90,"groupId":"1216","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testTraitConversion","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/b3/ae329f298672cd55c391cee58382880d8b03e8.src","preCode":"  @Test public void testTraitConversion() {\n    final VolcanoPlanner planner = new VolcanoPlanner();\n    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n    planner.addRelTraitDef(NEW_TRAIT_DEF_INSTANCE);\n\n    planner.addRule(new RandomSingleTraitRule());\n    planner.addRule(new SingleLeafTraitRule());\n    planner.addRule(ExpandConversionRule.INSTANCE);\n\n    final RelOptCluster cluster = newCluster(planner);\n    final NoneLeafRel leafRel = new NoneLeafRel(cluster, \"a\");\n    final NoneSingleRel singleRel = new NoneSingleRel(cluster, leafRel);\n    final RelNode convertedRel =\n        planner.changeTraits(singleRel,\n            cluster.traitSetOf(PHYS_CALLING_CONVENTION));\n    planner.setRoot(convertedRel);\n    final RelNode result = planner.chooseDelegate().findBestExp();\n\n    assertTrue(result instanceof RandomSingleRel);\n    assertTrue(result.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n    assertTrue(result.getTraitSet().contains(SIMPLE_DISTRIBUTION_RANDOM));\n\n    final RelNode input = result.getInput(0);\n    assertTrue(input instanceof BridgeRel);\n    assertTrue(input.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n    assertTrue(input.getTraitSet().contains(SIMPLE_DISTRIBUTION_RANDOM));\n\n    final RelNode input2 = input.getInput(0);\n    assertTrue(input2 instanceof SingletonLeafRel);\n    assertTrue(input2.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n    assertTrue(input2.getTraitSet().contains(SIMPLE_DISTRIBUTION_SINGLETON));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/volcano/TraitConversionTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":59,"status":"B"},{"authorDate":"2016-03-09 13:31:20","commitOrder":1,"curCode":"  @Test public void testCollationConversion() {\n    final VolcanoPlanner planner = new VolcanoPlanner();\n    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n    planner.addRelTraitDef(COLLATION_TRAIT_DEF);\n\n    planner.addRule(new SingleNodeRule());\n    planner.addRule(new LeafTraitRule());\n    planner.addRule(ExpandConversionRule.INSTANCE);\n\n    final RelOptCluster cluster = newCluster(planner);\n    final NoneLeafRel leafRel = new NoneLeafRel(cluster, \"a\");\n    final NoneSingleRel singleRel = new NoneSingleRel(cluster, leafRel);\n    final RelNode convertedRel =\n        planner.changeTraits(singleRel,\n            cluster.traitSetOf(PHYS_CALLING_CONVENTION).plus(ROOT_COLLATION));\n    planner.setRoot(convertedRel);\n    RelNode result = planner.chooseDelegate().findBestExp();\n    assertTrue(result instanceof RootSingleRel);\n    assertTrue(result.getTraitSet().contains(ROOT_COLLATION));\n    assertTrue(result.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n\n    final RelNode input = result.getInput(0);\n    assertTrue(input instanceof PhysicalSort);\n    assertTrue(result.getTraitSet().contains(ROOT_COLLATION));\n    assertTrue(input.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n\n    final RelNode input2 = input.getInput(0);\n    assertTrue(input2 instanceof LeafRel);\n    assertTrue(input2.getTraitSet().contains(LEAF_COLLATION));\n    assertTrue(input.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n  }\n","date":"2016-07-08 14:44:51","endLine":95,"groupId":"3011","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testCollationConversion","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/ff/8b50d37f270c5c5877157273979a6002901f69.src","preCode":"  @Test public void testCollationConversion() {\n    final VolcanoPlanner planner = new VolcanoPlanner();\n    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n    planner.addRelTraitDef(COLLATION_TRAIT_DEF);\n\n    planner.addRule(new SingleNodeRule());\n    planner.addRule(new LeafTraitRule());\n    planner.addRule(ExpandConversionRule.INSTANCE);\n\n    final RelOptCluster cluster = newCluster(planner);\n    final NoneLeafRel leafRel = new NoneLeafRel(cluster, \"a\");\n    final NoneSingleRel singleRel = new NoneSingleRel(cluster, leafRel);\n    final RelNode convertedRel =\n        planner.changeTraits(singleRel,\n            cluster.traitSetOf(PHYS_CALLING_CONVENTION).plus(ROOT_COLLATION));\n    planner.setRoot(convertedRel);\n    RelNode result = planner.chooseDelegate().findBestExp();\n    assertTrue(result instanceof RootSingleRel);\n    assertTrue(result.getTraitSet().contains(ROOT_COLLATION));\n    assertTrue(result.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n\n    final RelNode input = result.getInput(0);\n    assertTrue(input instanceof PhysicalSort);\n    assertTrue(result.getTraitSet().contains(ROOT_COLLATION));\n    assertTrue(input.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n\n    final RelNode input2 = input.getInput(0);\n    assertTrue(input2 instanceof LeafRel);\n    assertTrue(input2.getTraitSet().contains(LEAF_COLLATION));\n    assertTrue(input.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/volcano/CollationConversionTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":65,"status":"B"}],"commitId":"a3bc0d8ea3c1f320b96a4ab9641becee90a388bc","commitMessage":"@@@[CALCITE-1148] Fix RelTrait conversion (e.g. distribution.  collation) (Minji Kim)\n\nIn the current calcite.  trait conversion is not handled properly.  e.g.\ncollation/distribution traits are not converted (shown by the tests).\nThis patch fixes this issue.\n\nFor each RelCollationTrait.  introduce a new API.  canConvert() which\nshould return true if the conversion from a trait to the other is\npossible.\n\nFor each Convention.  introduce two new APIs.  canConvertConvention()\nreturns true if the convernsion is possible.  and useAbstractConverters()\nreturns true if the trait conversion should be handle via\nAbstractConverters.  By default.  both functions return false.\n\nIn RelSet.  when adding a new RelSubset.  if the convention returns false\nfor useAbstractConverters().  we do not add AbstractConverters.  Even if\nconvention.useAbstractConverters() return true.  we only add\nAbstractConverters if the AbstractConverters can convert (i.e. if\nRelCollationTrait.canConvert() returns true) and the conversion is\nneeded (i.e. if RelTrait.satisfies() returns false).\n\nAdded test cases.\n\nClose apache/calcite#210\n","date":"2016-07-08 14:44:51","modifiedFileCount":"14","status":"B","submitter":"Minji Kim"},{"authorTime":"2020-04-02 10:39:10","codes":[{"authorDate":"2020-04-02 10:39:10","commitOrder":2,"curCode":"  @Test void testTraitConversion() {\n    final VolcanoPlanner planner = new VolcanoPlanner();\n    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n    planner.addRelTraitDef(NEW_TRAIT_DEF_INSTANCE);\n\n    planner.addRule(new RandomSingleTraitRule());\n    planner.addRule(new SingleLeafTraitRule());\n    planner.addRule(ExpandConversionRule.INSTANCE);\n\n    final RelOptCluster cluster = newCluster(planner);\n    final NoneLeafRel leafRel = new NoneLeafRel(cluster, \"a\");\n    final NoneSingleRel singleRel = new NoneSingleRel(cluster, leafRel);\n    final RelNode convertedRel =\n        planner.changeTraits(singleRel,\n            cluster.traitSetOf(PHYS_CALLING_CONVENTION));\n    planner.setRoot(convertedRel);\n    final RelNode result = planner.chooseDelegate().findBestExp();\n\n    assertTrue(result instanceof RandomSingleRel);\n    assertTrue(result.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n    assertTrue(result.getTraitSet().contains(SIMPLE_DISTRIBUTION_RANDOM));\n\n    final RelNode input = result.getInput(0);\n    assertTrue(input instanceof BridgeRel);\n    assertTrue(input.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n    assertTrue(input.getTraitSet().contains(SIMPLE_DISTRIBUTION_RANDOM));\n\n    final RelNode input2 = input.getInput(0);\n    assertTrue(input2 instanceof SingletonLeafRel);\n    assertTrue(input2.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n    assertTrue(input2.getTraitSet().contains(SIMPLE_DISTRIBUTION_SINGLETON));\n  }\n","date":"2020-04-06 04:57:49","endLine":89,"groupId":"1216","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testTraitConversion","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e0/d65c81702434c43aa0e5f622a427f9e966c528.src","preCode":"  @Test public void testTraitConversion() {\n    final VolcanoPlanner planner = new VolcanoPlanner();\n    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n    planner.addRelTraitDef(NEW_TRAIT_DEF_INSTANCE);\n\n    planner.addRule(new RandomSingleTraitRule());\n    planner.addRule(new SingleLeafTraitRule());\n    planner.addRule(ExpandConversionRule.INSTANCE);\n\n    final RelOptCluster cluster = newCluster(planner);\n    final NoneLeafRel leafRel = new NoneLeafRel(cluster, \"a\");\n    final NoneSingleRel singleRel = new NoneSingleRel(cluster, leafRel);\n    final RelNode convertedRel =\n        planner.changeTraits(singleRel,\n            cluster.traitSetOf(PHYS_CALLING_CONVENTION));\n    planner.setRoot(convertedRel);\n    final RelNode result = planner.chooseDelegate().findBestExp();\n\n    assertTrue(result instanceof RandomSingleRel);\n    assertTrue(result.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n    assertTrue(result.getTraitSet().contains(SIMPLE_DISTRIBUTION_RANDOM));\n\n    final RelNode input = result.getInput(0);\n    assertTrue(input instanceof BridgeRel);\n    assertTrue(input.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n    assertTrue(input.getTraitSet().contains(SIMPLE_DISTRIBUTION_RANDOM));\n\n    final RelNode input2 = input.getInput(0);\n    assertTrue(input2 instanceof SingletonLeafRel);\n    assertTrue(input2.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n    assertTrue(input2.getTraitSet().contains(SIMPLE_DISTRIBUTION_SINGLETON));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/volcano/TraitConversionTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"M"},{"authorDate":"2020-04-02 10:39:10","commitOrder":2,"curCode":"  @Test void testCollationConversion() {\n    final VolcanoPlanner planner = new VolcanoPlanner();\n    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n    planner.addRelTraitDef(COLLATION_TRAIT_DEF);\n\n    planner.addRule(new SingleNodeRule());\n    planner.addRule(new LeafTraitRule());\n    planner.addRule(ExpandConversionRule.INSTANCE);\n\n    final RelOptCluster cluster = newCluster(planner);\n    final NoneLeafRel leafRel = new NoneLeafRel(cluster, \"a\");\n    final NoneSingleRel singleRel = new NoneSingleRel(cluster, leafRel);\n    final RelNode convertedRel =\n        planner.changeTraits(singleRel,\n            cluster.traitSetOf(PHYS_CALLING_CONVENTION).plus(ROOT_COLLATION));\n    planner.setRoot(convertedRel);\n    RelNode result = planner.chooseDelegate().findBestExp();\n    assertTrue(result instanceof RootSingleRel);\n    assertTrue(result.getTraitSet().contains(ROOT_COLLATION));\n    assertTrue(result.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n\n    final RelNode input = result.getInput(0);\n    assertTrue(input instanceof PhysicalSort);\n    assertTrue(result.getTraitSet().contains(ROOT_COLLATION));\n    assertTrue(input.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n\n    final RelNode input2 = input.getInput(0);\n    assertTrue(input2 instanceof LeafRel);\n    assertTrue(input2.getTraitSet().contains(LEAF_COLLATION));\n    assertTrue(input.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n  }\n","date":"2020-04-06 04:57:49","endLine":95,"groupId":"3011","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testCollationConversion","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/93/2d59b94f8c41608028371f03f7d5019111775c.src","preCode":"  @Test public void testCollationConversion() {\n    final VolcanoPlanner planner = new VolcanoPlanner();\n    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n    planner.addRelTraitDef(COLLATION_TRAIT_DEF);\n\n    planner.addRule(new SingleNodeRule());\n    planner.addRule(new LeafTraitRule());\n    planner.addRule(ExpandConversionRule.INSTANCE);\n\n    final RelOptCluster cluster = newCluster(planner);\n    final NoneLeafRel leafRel = new NoneLeafRel(cluster, \"a\");\n    final NoneSingleRel singleRel = new NoneSingleRel(cluster, leafRel);\n    final RelNode convertedRel =\n        planner.changeTraits(singleRel,\n            cluster.traitSetOf(PHYS_CALLING_CONVENTION).plus(ROOT_COLLATION));\n    planner.setRoot(convertedRel);\n    RelNode result = planner.chooseDelegate().findBestExp();\n    assertTrue(result instanceof RootSingleRel);\n    assertTrue(result.getTraitSet().contains(ROOT_COLLATION));\n    assertTrue(result.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n\n    final RelNode input = result.getInput(0);\n    assertTrue(input instanceof PhysicalSort);\n    assertTrue(result.getTraitSet().contains(ROOT_COLLATION));\n    assertTrue(input.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n\n    final RelNode input2 = input.getInput(0);\n    assertTrue(input2 instanceof LeafRel);\n    assertTrue(input2.getTraitSet().contains(LEAF_COLLATION));\n    assertTrue(input.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/volcano/CollationConversionTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":65,"status":"M"}],"commitId":"9492dd4146f63ddc028010d6c4e86f6a5cb29a8d","commitMessage":"@@@[CALCITE-3892] Make junit test classes and methods non-public where possible\n\nPrior to junit 5.  classes and methods had to be public. This is no\nlonger the case.\n\nSome classes need to remain public because they are referenced from\nelsewhere.  or if they use reflection somehow. The remaining 'public'\nkeyword will be informative to maintainers.\n","date":"2020-04-06 04:57:49","modifiedFileCount":"196","status":"M","submitter":"Julian Hyde"},{"authorTime":"2020-04-29 22:56:19","codes":[{"authorDate":"2020-04-29 22:56:19","commitOrder":3,"curCode":"  @Test void testTraitConversion() {\n    final VolcanoPlanner planner = new VolcanoPlanner();\n    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n    planner.addRelTraitDef(NEW_TRAIT_DEF_INSTANCE);\n\n    planner.addRule(new RandomSingleTraitRule());\n    planner.addRule(new SingleLeafTraitRule());\n    planner.addRule(ExpandConversionRule.INSTANCE);\n    planner.setTopDownOpt(false);\n\n    final RelOptCluster cluster = newCluster(planner);\n    final NoneLeafRel leafRel = new NoneLeafRel(cluster, \"a\");\n    final NoneSingleRel singleRel = new NoneSingleRel(cluster, leafRel);\n    final RelNode convertedRel =\n        planner.changeTraits(singleRel,\n            cluster.traitSetOf(PHYS_CALLING_CONVENTION));\n    planner.setRoot(convertedRel);\n    final RelNode result = planner.chooseDelegate().findBestExp();\n\n    assertTrue(result instanceof RandomSingleRel);\n    assertTrue(result.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n    assertTrue(result.getTraitSet().contains(SIMPLE_DISTRIBUTION_RANDOM));\n\n    final RelNode input = result.getInput(0);\n    assertTrue(input instanceof BridgeRel);\n    assertTrue(input.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n    assertTrue(input.getTraitSet().contains(SIMPLE_DISTRIBUTION_RANDOM));\n\n    final RelNode input2 = input.getInput(0);\n    assertTrue(input2 instanceof SingletonLeafRel);\n    assertTrue(input2.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n    assertTrue(input2.getTraitSet().contains(SIMPLE_DISTRIBUTION_SINGLETON));\n  }\n","date":"2020-05-11 11:40:36","endLine":90,"groupId":"1216","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testTraitConversion","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/ab/4151f8dc32cdf59ad4af31a7879b273ca56b1d.src","preCode":"  @Test void testTraitConversion() {\n    final VolcanoPlanner planner = new VolcanoPlanner();\n    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n    planner.addRelTraitDef(NEW_TRAIT_DEF_INSTANCE);\n\n    planner.addRule(new RandomSingleTraitRule());\n    planner.addRule(new SingleLeafTraitRule());\n    planner.addRule(ExpandConversionRule.INSTANCE);\n\n    final RelOptCluster cluster = newCluster(planner);\n    final NoneLeafRel leafRel = new NoneLeafRel(cluster, \"a\");\n    final NoneSingleRel singleRel = new NoneSingleRel(cluster, leafRel);\n    final RelNode convertedRel =\n        planner.changeTraits(singleRel,\n            cluster.traitSetOf(PHYS_CALLING_CONVENTION));\n    planner.setRoot(convertedRel);\n    final RelNode result = planner.chooseDelegate().findBestExp();\n\n    assertTrue(result instanceof RandomSingleRel);\n    assertTrue(result.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n    assertTrue(result.getTraitSet().contains(SIMPLE_DISTRIBUTION_RANDOM));\n\n    final RelNode input = result.getInput(0);\n    assertTrue(input instanceof BridgeRel);\n    assertTrue(input.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n    assertTrue(input.getTraitSet().contains(SIMPLE_DISTRIBUTION_RANDOM));\n\n    final RelNode input2 = input.getInput(0);\n    assertTrue(input2 instanceof SingletonLeafRel);\n    assertTrue(input2.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n    assertTrue(input2.getTraitSet().contains(SIMPLE_DISTRIBUTION_SINGLETON));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/volcano/TraitConversionTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"M"},{"authorDate":"2020-04-29 22:56:19","commitOrder":3,"curCode":"  @Test void testCollationConversion() {\n    final VolcanoPlanner planner = new VolcanoPlanner();\n    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n    planner.addRelTraitDef(COLLATION_TRAIT_DEF);\n\n    planner.addRule(new SingleNodeRule());\n    planner.addRule(new LeafTraitRule());\n    planner.addRule(ExpandConversionRule.INSTANCE);\n    planner.setTopDownOpt(false);\n\n    final RelOptCluster cluster = newCluster(planner);\n    final NoneLeafRel leafRel = new NoneLeafRel(cluster, \"a\");\n    final NoneSingleRel singleRel = new NoneSingleRel(cluster, leafRel);\n    final RelNode convertedRel =\n        planner.changeTraits(singleRel,\n            cluster.traitSetOf(PHYS_CALLING_CONVENTION).plus(ROOT_COLLATION));\n    planner.setRoot(convertedRel);\n    RelNode result = planner.chooseDelegate().findBestExp();\n    assertTrue(result instanceof RootSingleRel);\n    assertTrue(result.getTraitSet().contains(ROOT_COLLATION));\n    assertTrue(result.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n\n    final RelNode input = result.getInput(0);\n    assertTrue(input instanceof PhysicalSort);\n    assertTrue(result.getTraitSet().contains(ROOT_COLLATION));\n    assertTrue(input.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n\n    final RelNode input2 = input.getInput(0);\n    assertTrue(input2 instanceof LeafRel);\n    assertTrue(input2.getTraitSet().contains(LEAF_COLLATION));\n    assertTrue(input.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n  }\n","date":"2020-05-11 11:40:36","endLine":96,"groupId":"3011","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testCollationConversion","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/41/5457ed1f9add7f71515e268091212c764f4337.src","preCode":"  @Test void testCollationConversion() {\n    final VolcanoPlanner planner = new VolcanoPlanner();\n    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n    planner.addRelTraitDef(COLLATION_TRAIT_DEF);\n\n    planner.addRule(new SingleNodeRule());\n    planner.addRule(new LeafTraitRule());\n    planner.addRule(ExpandConversionRule.INSTANCE);\n\n    final RelOptCluster cluster = newCluster(planner);\n    final NoneLeafRel leafRel = new NoneLeafRel(cluster, \"a\");\n    final NoneSingleRel singleRel = new NoneSingleRel(cluster, leafRel);\n    final RelNode convertedRel =\n        planner.changeTraits(singleRel,\n            cluster.traitSetOf(PHYS_CALLING_CONVENTION).plus(ROOT_COLLATION));\n    planner.setRoot(convertedRel);\n    RelNode result = planner.chooseDelegate().findBestExp();\n    assertTrue(result instanceof RootSingleRel);\n    assertTrue(result.getTraitSet().contains(ROOT_COLLATION));\n    assertTrue(result.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n\n    final RelNode input = result.getInput(0);\n    assertTrue(input instanceof PhysicalSort);\n    assertTrue(result.getTraitSet().contains(ROOT_COLLATION));\n    assertTrue(input.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n\n    final RelNode input2 = input.getInput(0);\n    assertTrue(input2 instanceof LeafRel);\n    assertTrue(input2.getTraitSet().contains(LEAF_COLLATION));\n    assertTrue(input.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/volcano/CollationConversionTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":65,"status":"M"}],"commitId":"9c31d9e83dc718800a36f7719534f9f74633c8a7","commitMessage":"@@@[CALCITE-3896] Top down trait request\n\n1. Top-down trait request\n2. Bottom-up trait derivation\n3. Trait enforcement without AbstractConverter\n\nHow to use?\n\n1. Enable top-down optimization by setting {VolcanoPlanner#setTopDownOpt(boolean)}\nor add 'calcite.planner.topdown.opt=true' to saffron.properties config file.\n\n2. Let your convention's rel interface extends {PhysicalNode}.  see\n{EnumerableRel} as an example.\n\n3. Each physical operator overrides any one of the two methods:\n{PhysicalNode#passThrough(RelTraitSet)} or\n{PhysicalNode#passThroughTraits(RelTraitSet)} depending on your needs.\n\n4. Choose derive mode for each physical operator by overriding\n{PhysicalNode#getDeriveMode()}.\n\n5. If the derive mode is {DeriveMode#OMAKASE}.  override method\n{PhysicalNode#derive(List)} in the physical operator.  otherwise.  override\n{PhysicalNode#derive(RelTraitSet.  int)} or\n{PhysicalNode#deriveTraits(RelTraitSet.  int)}.\n\n6. Mark your enforcer operator by overriding {RelNode#isEnforcer()}.  see\n{Sort#isEnforcer()} as an example. This is important.  because it can help\n{VolcanoPlanner} avoid unnecessary trait propagation and derivation.  therefore\nimprove optimization efficiency.\n\n7. Implement {Convention#enforce(RelNode.  RelTraitSet)} in your convention. \nwhich generates appropriate physical enforcer. See\n{EnumerableConvention#enforce(RelNode.  RelTraitSet)} as example. Simply return\nnull if you don't want physical trait enforcement.\n\nHow does it work?\n\nLet S# denote the seed physical operator in a RelSet after logical and physical\nrules transformation.  P# denote the physical operator generated by passing down\nparent trait requirements.  D# denote the physical operator generated by\nderiving from child delivered traitSets.\n\nThe initial rel list state in a RelSet is as follows:\n    cursor\n      |\n      V\n     S1.  S2\n\nWhen we create a task for RelSubset1.  the task will immediately pass the\nsubset's traitSet to seed operators.  S1 and S2.  now we have:\n    cursor\n      |\n      V\n     S1.  S2.  P1.  P2\n\nThe subset task will create a optimization task for the relnode pointed by\ncursor.  and move cursor to next available physical operator S2. In the task for\nS1.  it will continue optimize its child nodes.  which are RelSubsets. After\nchild inputs optimization is finished.  S1 will derive new relnodes from\ndelivered subsets in input RelSet. Once task for S1 is completed.  we have:\n        cursor\n          |\n          V\n     S1.  S2.  P1.  P2.  D1\n\nThe subset task continues scheduling task for S2.  P1... until there is no more\nrelnode created for the RelSet.  then we have:\n                                cursor\n                                  |\n                                  V\n     S1.  S2.  P1.  P2.  D1.  D2.  D3.  null\n\nWhen a task for another RelSubset2 is created.  the task will try to pass down\nthe subset's traitSet to seed operator S1 and S2.  now the RelSet looks like:\n                                cursor\n                                  |\n                                  V\n     S1.  S2.  P1.  P2.  D1.  D2.  D3.  P3.  P4\n\nThe process continues till there is no more subsets or relnodes created for the\nRelSet.\n\nSee https://t.ly/MmaF for discussion.\n\nClose #1953\n","date":"2020-05-11 11:40:36","modifiedFileCount":"17","status":"M","submitter":"Haisheng Yuan"},{"authorTime":"2020-07-09 05:31:40","codes":[{"authorDate":"2020-07-09 05:31:40","commitOrder":4,"curCode":"  @Test void testTraitConversion() {\n    final VolcanoPlanner planner = new VolcanoPlanner();\n    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n    planner.addRelTraitDef(NEW_TRAIT_DEF_INSTANCE);\n\n    planner.addRule(RandomSingleTraitRule.INSTANCE);\n    planner.addRule(SingleLeafTraitRule.INSTANCE);\n    planner.addRule(ExpandConversionRule.INSTANCE);\n    planner.setTopDownOpt(false);\n\n    final RelOptCluster cluster = newCluster(planner);\n    final NoneLeafRel leafRel = new NoneLeafRel(cluster, \"a\");\n    final NoneSingleRel singleRel = new NoneSingleRel(cluster, leafRel);\n    final RelNode convertedRel =\n        planner.changeTraits(singleRel,\n            cluster.traitSetOf(PHYS_CALLING_CONVENTION));\n    planner.setRoot(convertedRel);\n    final RelNode result = planner.chooseDelegate().findBestExp();\n\n    assertTrue(result instanceof RandomSingleRel);\n    assertTrue(result.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n    assertTrue(result.getTraitSet().contains(SIMPLE_DISTRIBUTION_RANDOM));\n\n    final RelNode input = result.getInput(0);\n    assertTrue(input instanceof BridgeRel);\n    assertTrue(input.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n    assertTrue(input.getTraitSet().contains(SIMPLE_DISTRIBUTION_RANDOM));\n\n    final RelNode input2 = input.getInput(0);\n    assertTrue(input2 instanceof SingletonLeafRel);\n    assertTrue(input2.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n    assertTrue(input2.getTraitSet().contains(SIMPLE_DISTRIBUTION_SINGLETON));\n  }\n","date":"2020-07-29 02:27:24","endLine":90,"groupId":"101443","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testTraitConversion","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/fe/28158f3978802eb60da4714490803df46e29d3.src","preCode":"  @Test void testTraitConversion() {\n    final VolcanoPlanner planner = new VolcanoPlanner();\n    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n    planner.addRelTraitDef(NEW_TRAIT_DEF_INSTANCE);\n\n    planner.addRule(new RandomSingleTraitRule());\n    planner.addRule(new SingleLeafTraitRule());\n    planner.addRule(ExpandConversionRule.INSTANCE);\n    planner.setTopDownOpt(false);\n\n    final RelOptCluster cluster = newCluster(planner);\n    final NoneLeafRel leafRel = new NoneLeafRel(cluster, \"a\");\n    final NoneSingleRel singleRel = new NoneSingleRel(cluster, leafRel);\n    final RelNode convertedRel =\n        planner.changeTraits(singleRel,\n            cluster.traitSetOf(PHYS_CALLING_CONVENTION));\n    planner.setRoot(convertedRel);\n    final RelNode result = planner.chooseDelegate().findBestExp();\n\n    assertTrue(result instanceof RandomSingleRel);\n    assertTrue(result.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n    assertTrue(result.getTraitSet().contains(SIMPLE_DISTRIBUTION_RANDOM));\n\n    final RelNode input = result.getInput(0);\n    assertTrue(input instanceof BridgeRel);\n    assertTrue(input.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n    assertTrue(input.getTraitSet().contains(SIMPLE_DISTRIBUTION_RANDOM));\n\n    final RelNode input2 = input.getInput(0);\n    assertTrue(input2 instanceof SingletonLeafRel);\n    assertTrue(input2.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n    assertTrue(input2.getTraitSet().contains(SIMPLE_DISTRIBUTION_SINGLETON));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/volcano/TraitConversionTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"M"},{"authorDate":"2020-07-09 05:31:40","commitOrder":4,"curCode":"  @Test void testCollationConversion() {\n    final VolcanoPlanner planner = new VolcanoPlanner();\n    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n    planner.addRelTraitDef(COLLATION_TRAIT_DEF);\n\n    planner.addRule(SingleNodeRule.INSTANCE);\n    planner.addRule(LeafTraitRule.INSTANCE);\n    planner.addRule(ExpandConversionRule.INSTANCE);\n    planner.setTopDownOpt(false);\n\n    final RelOptCluster cluster = newCluster(planner);\n    final NoneLeafRel leafRel = new NoneLeafRel(cluster, \"a\");\n    final NoneSingleRel singleRel = new NoneSingleRel(cluster, leafRel);\n    final RelNode convertedRel =\n        planner.changeTraits(singleRel,\n            cluster.traitSetOf(PHYS_CALLING_CONVENTION).plus(ROOT_COLLATION));\n    planner.setRoot(convertedRel);\n    RelNode result = planner.chooseDelegate().findBestExp();\n    assertTrue(result instanceof RootSingleRel);\n    assertTrue(result.getTraitSet().contains(ROOT_COLLATION));\n    assertTrue(result.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n\n    final RelNode input = result.getInput(0);\n    assertTrue(input instanceof PhysicalSort);\n    assertTrue(result.getTraitSet().contains(ROOT_COLLATION));\n    assertTrue(input.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n\n    final RelNode input2 = input.getInput(0);\n    assertTrue(input2 instanceof LeafRel);\n    assertTrue(input2.getTraitSet().contains(LEAF_COLLATION));\n    assertTrue(input.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n  }\n","date":"2020-07-29 02:27:24","endLine":96,"groupId":"101443","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testCollationConversion","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/02/caab20d3ff9396d827cdd879e8fdfc3044d850.src","preCode":"  @Test void testCollationConversion() {\n    final VolcanoPlanner planner = new VolcanoPlanner();\n    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n    planner.addRelTraitDef(COLLATION_TRAIT_DEF);\n\n    planner.addRule(new SingleNodeRule());\n    planner.addRule(new LeafTraitRule());\n    planner.addRule(ExpandConversionRule.INSTANCE);\n    planner.setTopDownOpt(false);\n\n    final RelOptCluster cluster = newCluster(planner);\n    final NoneLeafRel leafRel = new NoneLeafRel(cluster, \"a\");\n    final NoneSingleRel singleRel = new NoneSingleRel(cluster, leafRel);\n    final RelNode convertedRel =\n        planner.changeTraits(singleRel,\n            cluster.traitSetOf(PHYS_CALLING_CONVENTION).plus(ROOT_COLLATION));\n    planner.setRoot(convertedRel);\n    RelNode result = planner.chooseDelegate().findBestExp();\n    assertTrue(result instanceof RootSingleRel);\n    assertTrue(result.getTraitSet().contains(ROOT_COLLATION));\n    assertTrue(result.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n\n    final RelNode input = result.getInput(0);\n    assertTrue(input instanceof PhysicalSort);\n    assertTrue(result.getTraitSet().contains(ROOT_COLLATION));\n    assertTrue(input.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n\n    final RelNode input2 = input.getInput(0);\n    assertTrue(input2 instanceof LeafRel);\n    assertTrue(input2.getTraitSet().contains(LEAF_COLLATION));\n    assertTrue(input.getTraitSet().contains(PHYS_CALLING_CONVENTION));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/volcano/CollationConversionTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":65,"status":"M"}],"commitId":"998cd83ebe2fcd7ff3ee565299fed6e199269715","commitMessage":"@@@[CALCITE-3923] Refactor how planner rules are parameterized\n\nCreate operands using a builder interface.  OperandBuilder.  and\ndeprecate methods RelOptRule.operand etc.\n\nThe change is backwards compatible.  in the sense that\nexisting rule constructors are deprecated but still work.\nFrom now on.  to create rules.  call RelOptRule.Config.toRule()\n(which calls the rule's (Config) constructor).\n\nSub-classes of ConverterRule are a little different.  They\ndon't need their own sub-class of Config.  You just need to\ncall Config.withRuleFactory to specify the constructor of the\nsub-class of ConverterRule.\n\nMove rule instances into holder classes such as CoreRules. \nMaterializedViewRules. Deprecate existing rule INSTANCE fields\n(to be removed in 1.25). Deprecate previous rule constructors\n(to be removed in 2.0).\n\nDescribe how to write rules in howto and tutorial.\n\nRemove rule instances marked 'deprecated.  to be removed before\n1.25'.\n\nClose apache/calcite#2024\n","date":"2020-07-29 02:27:24","modifiedFileCount":"191","status":"M","submitter":"Julian Hyde"}]
