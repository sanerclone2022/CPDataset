[{"authorTime":"2016-02-19 03:14:52","codes":[{"authorDate":"2016-02-19 03:14:52","commitOrder":1,"curCode":"  @Test public void testLeftAssociative() {\n    final PrecedenceClimbingParser p = new PrecedenceClimbingParser.Builder()\n        .atom(\"a\")\n        .infix(\"*\", 2, true)\n        .atom(\"b\")\n        .infix(\"+\", 1, true)\n        .atom(\"c\")\n        .infix(\"+\", 1, true)\n        .atom(\"d\")\n        .infix(\"+\", 1, true)\n        .atom(\"e\")\n        .infix(\"*\", 2, true)\n        .atom(\"f\")\n        .build();\n    final PrecedenceClimbingParser.Token token = p.parse();\n    assertThat(p.print(token), is(\"((((a * b) + c) + d) + (e * f))\"));\n  }\n","date":"2016-09-16 08:02:42","endLine":108,"groupId":"13179","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testLeftAssociative","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/3f/beac45d15700cc029152dff696c4b606a018f5.src","preCode":"  @Test public void testLeftAssociative() {\n    final PrecedenceClimbingParser p = new PrecedenceClimbingParser.Builder()\n        .atom(\"a\")\n        .infix(\"*\", 2, true)\n        .atom(\"b\")\n        .infix(\"+\", 1, true)\n        .atom(\"c\")\n        .infix(\"+\", 1, true)\n        .atom(\"d\")\n        .infix(\"+\", 1, true)\n        .atom(\"e\")\n        .infix(\"*\", 2, true)\n        .atom(\"f\")\n        .build();\n    final PrecedenceClimbingParser.Token token = p.parse();\n    assertThat(p.print(token), is(\"((((a * b) + c) + d) + (e * f))\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/util/PrecedenceClimbingParserTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":92,"status":"B"},{"authorDate":"2016-02-19 03:14:52","commitOrder":1,"curCode":"  @Test public void testRightAssociative() {\n    final PrecedenceClimbingParser p = new PrecedenceClimbingParser.Builder()\n        .atom(\"a\")\n        .infix(\"^\", 3, false)\n        .atom(\"b\")\n        .infix(\"^\", 3, false)\n        .atom(\"c\")\n        .infix(\"^\", 3, false)\n        .atom(\"d\")\n        .infix(\"+\", 1, true)\n        .atom(\"e\")\n        .infix(\"*\", 2, true)\n        .atom(\"f\")\n        .build();\n    final PrecedenceClimbingParser.Token token = p.parse();\n    assertThat(p.print(token), is(\"((a ^ (b ^ (c ^ d))) + (e * f))\"));\n  }\n","date":"2016-09-16 08:02:42","endLine":126,"groupId":"13179","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testRightAssociative","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/3f/beac45d15700cc029152dff696c4b606a018f5.src","preCode":"  @Test public void testRightAssociative() {\n    final PrecedenceClimbingParser p = new PrecedenceClimbingParser.Builder()\n        .atom(\"a\")\n        .infix(\"^\", 3, false)\n        .atom(\"b\")\n        .infix(\"^\", 3, false)\n        .atom(\"c\")\n        .infix(\"^\", 3, false)\n        .atom(\"d\")\n        .infix(\"+\", 1, true)\n        .atom(\"e\")\n        .infix(\"*\", 2, true)\n        .atom(\"f\")\n        .build();\n    final PrecedenceClimbingParser.Token token = p.parse();\n    assertThat(p.print(token), is(\"((a ^ (b ^ (c ^ d))) + (e * f))\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/util/PrecedenceClimbingParserTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":110,"status":"B"}],"commitId":"339ac13eb23b5aac6cadc16c42e36deebbcd1e39","commitMessage":"@@@[CALCITE-1095] NOT precedence\n\nPreviously prefix operators such as NOT were not handled in the same\nway as infix and postfix operators. With a new precedence climbing\nparser.  we can handle all operators uniformly.\n\nDocument precedence of all operators.  adjusting some to match the SQL\nstandard; for example.  LIKE now has slightly higher precedence than =. \nand NOT has lower precedence than =.\n\nAdd a test to ensure that operators' real rankings match the documentation.\n","date":"2016-09-16 08:02:42","modifiedFileCount":"13","status":"B","submitter":"Julian Hyde"},{"authorTime":"2020-04-02 10:39:10","codes":[{"authorDate":"2020-04-02 10:39:10","commitOrder":2,"curCode":"  @Test void testLeftAssociative() {\n    final PrecedenceClimbingParser p = new PrecedenceClimbingParser.Builder()\n        .atom(\"a\")\n        .infix(\"*\", 2, true)\n        .atom(\"b\")\n        .infix(\"+\", 1, true)\n        .atom(\"c\")\n        .infix(\"+\", 1, true)\n        .atom(\"d\")\n        .infix(\"+\", 1, true)\n        .atom(\"e\")\n        .infix(\"*\", 2, true)\n        .atom(\"f\")\n        .build();\n    final PrecedenceClimbingParser.Token token = p.parse();\n    assertThat(p.print(token), is(\"((((a * b) + c) + d) + (e * f))\"));\n  }\n","date":"2020-04-06 04:57:49","endLine":108,"groupId":"101634","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"testLeftAssociative","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/7f/7821acbd34213f9cfa1bced8e7896ad8cc001d.src","preCode":"  @Test public void testLeftAssociative() {\n    final PrecedenceClimbingParser p = new PrecedenceClimbingParser.Builder()\n        .atom(\"a\")\n        .infix(\"*\", 2, true)\n        .atom(\"b\")\n        .infix(\"+\", 1, true)\n        .atom(\"c\")\n        .infix(\"+\", 1, true)\n        .atom(\"d\")\n        .infix(\"+\", 1, true)\n        .atom(\"e\")\n        .infix(\"*\", 2, true)\n        .atom(\"f\")\n        .build();\n    final PrecedenceClimbingParser.Token token = p.parse();\n    assertThat(p.print(token), is(\"((((a * b) + c) + d) + (e * f))\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/util/PrecedenceClimbingParserTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":92,"status":"M"},{"authorDate":"2020-04-02 10:39:10","commitOrder":2,"curCode":"  @Test void testRightAssociative() {\n    final PrecedenceClimbingParser p = new PrecedenceClimbingParser.Builder()\n        .atom(\"a\")\n        .infix(\"^\", 3, false)\n        .atom(\"b\")\n        .infix(\"^\", 3, false)\n        .atom(\"c\")\n        .infix(\"^\", 3, false)\n        .atom(\"d\")\n        .infix(\"+\", 1, true)\n        .atom(\"e\")\n        .infix(\"*\", 2, true)\n        .atom(\"f\")\n        .build();\n    final PrecedenceClimbingParser.Token token = p.parse();\n    assertThat(p.print(token), is(\"((a ^ (b ^ (c ^ d))) + (e * f))\"));\n  }\n","date":"2020-04-06 04:57:49","endLine":126,"groupId":"101634","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"testRightAssociative","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/7f/7821acbd34213f9cfa1bced8e7896ad8cc001d.src","preCode":"  @Test public void testRightAssociative() {\n    final PrecedenceClimbingParser p = new PrecedenceClimbingParser.Builder()\n        .atom(\"a\")\n        .infix(\"^\", 3, false)\n        .atom(\"b\")\n        .infix(\"^\", 3, false)\n        .atom(\"c\")\n        .infix(\"^\", 3, false)\n        .atom(\"d\")\n        .infix(\"+\", 1, true)\n        .atom(\"e\")\n        .infix(\"*\", 2, true)\n        .atom(\"f\")\n        .build();\n    final PrecedenceClimbingParser.Token token = p.parse();\n    assertThat(p.print(token), is(\"((a ^ (b ^ (c ^ d))) + (e * f))\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/util/PrecedenceClimbingParserTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":110,"status":"M"}],"commitId":"9492dd4146f63ddc028010d6c4e86f6a5cb29a8d","commitMessage":"@@@[CALCITE-3892] Make junit test classes and methods non-public where possible\n\nPrior to junit 5.  classes and methods had to be public. This is no\nlonger the case.\n\nSome classes need to remain public because they are referenced from\nelsewhere.  or if they use reflection somehow. The remaining 'public'\nkeyword will be informative to maintainers.\n","date":"2020-04-06 04:57:49","modifiedFileCount":"196","status":"M","submitter":"Julian Hyde"}]
