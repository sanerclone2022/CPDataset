[{"authorTime":"2020-09-10 07:48:24","codes":[{"authorDate":"2020-09-10 07:48:24","commitOrder":1,"curCode":"    @Override public void check(StringAndPos sap, SqlDialect dialect,\n        String expected, Consumer<SqlParser> parserChecker) {\n      final UnaryOperator<SqlParser.ConfigBuilder> transform =\n          getTransform(dialect);\n      SqlNode sqlNode = parseStmtAndHandleEx(sap.sql, transform, parserChecker);\n\n      \r\n      final SqlDialect dialect2 = Util.first(dialect, AnsiSqlDialect.DEFAULT);\n      final UnaryOperator<SqlWriterConfig> transform2 =\n          simpleWithParens().andThen(c -> c.withDialect(dialect2))::apply;\n      final String actual = sqlNode.toSqlString(transform2).getSql();\n      assertEquals(expected, linux(actual));\n\n      \r\n      \r\n      final String sql1 = sqlNode.toSqlString(simple()).getSql();\n\n      \r\n      SqlNode sqlNode2;\n      final Quoting q = quoting;\n      try {\n        quoting = Quoting.DOUBLE_QUOTE;\n        sqlNode2 = parseStmtAndHandleEx(sql1, b -> b, parser -> { });\n      } finally {\n        quoting = q;\n      }\n      final String sql2 = sqlNode2.toSqlString(simple()).getSql();\n\n      \r\n      assertEquals(sql1, sql2);\n\n      \r\n      \r\n      \r\n      final String actual2 = sqlNode.toSqlString(transform2).getSql();\n      assertEquals(expected, linux(actual2));\n\n      \r\n      \r\n      final Random random = new Random();\n      final String sql3 = sqlNode.toSqlString(randomize(random)).getSql();\n      assertThat(sql3, notNullValue());\n      SqlNode sqlNode4;\n      try {\n        quoting = Quoting.DOUBLE_QUOTE;\n        sqlNode4 = parseStmtAndHandleEx(sql1, b -> b, parser -> { });\n      } finally {\n        quoting = q;\n      }\n      final String sql4 = sqlNode4.toSqlString(simple()).getSql();\n      assertEquals(sql1, sql4);\n    }\n","date":"2020-09-18 10:35:30","endLine":9395,"groupId":"5640","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"check","params":"(StringAndPossap@SqlDialectdialect@Stringexpected@Consumer<SqlParser>parserChecker)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/6c/d1a9613e189238221e85788dafc7e38ba16391.src","preCode":"    @Override public void check(StringAndPos sap, SqlDialect dialect,\n        String expected, Consumer<SqlParser> parserChecker) {\n      final UnaryOperator<SqlParser.ConfigBuilder> transform =\n          getTransform(dialect);\n      SqlNode sqlNode = parseStmtAndHandleEx(sap.sql, transform, parserChecker);\n\n      \r\n      final SqlDialect dialect2 = Util.first(dialect, AnsiSqlDialect.DEFAULT);\n      final UnaryOperator<SqlWriterConfig> transform2 =\n          simpleWithParens().andThen(c -> c.withDialect(dialect2))::apply;\n      final String actual = sqlNode.toSqlString(transform2).getSql();\n      assertEquals(expected, linux(actual));\n\n      \r\n      \r\n      final String sql1 = sqlNode.toSqlString(simple()).getSql();\n\n      \r\n      SqlNode sqlNode2;\n      final Quoting q = quoting;\n      try {\n        quoting = Quoting.DOUBLE_QUOTE;\n        sqlNode2 = parseStmtAndHandleEx(sql1, b -> b, parser -> { });\n      } finally {\n        quoting = q;\n      }\n      final String sql2 = sqlNode2.toSqlString(simple()).getSql();\n\n      \r\n      assertEquals(sql1, sql2);\n\n      \r\n      \r\n      \r\n      final String actual2 = sqlNode.toSqlString(transform2).getSql();\n      assertEquals(expected, linux(actual2));\n\n      \r\n      \r\n      final Random random = new Random();\n      final String sql3 = sqlNode.toSqlString(randomize(random)).getSql();\n      assertThat(sql3, notNullValue());\n      SqlNode sqlNode4;\n      try {\n        quoting = Quoting.DOUBLE_QUOTE;\n        sqlNode4 = parseStmtAndHandleEx(sql1, b -> b, parser -> { });\n      } finally {\n        quoting = q;\n      }\n      final String sql4 = sqlNode4.toSqlString(simple()).getSql();\n      assertEquals(sql1, sql4);\n    }\n","realPath":"core/src/test/java/org/apache/calcite/sql/parser/SqlParserTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":9344,"status":"B"},{"authorDate":"2020-09-10 07:48:24","commitOrder":1,"curCode":"    @Override public void checkExp(StringAndPos sap, SqlDialect dialect,\n        String expected, Consumer<SqlParser> parserChecker) {\n      final UnaryOperator<SqlParser.ConfigBuilder> transform =\n          getTransform(dialect);\n      SqlNode sqlNode =\n          parseExpressionAndHandleEx(sap.sql, transform, parserChecker);\n\n      \r\n      final UnaryOperator<SqlWriterConfig> transform2 = c ->\n          simpleWithParens().apply(c).withDialect(AnsiSqlDialect.DEFAULT);\n      final String actual = sqlNode.toSqlString(transform2).getSql();\n      assertEquals(expected, linux(actual));\n\n      \r\n      \r\n      final String sql1 =\n          sqlNode.toSqlString(UnaryOperator.identity()).getSql();\n\n      \r\n      \r\n      SqlNode sqlNode2;\n      final Quoting q = quoting;\n      try {\n        quoting = Quoting.DOUBLE_QUOTE;\n        sqlNode2 = parseExpressionAndHandleEx(sql1, transform, parser -> { });\n      } finally {\n        quoting = q;\n      }\n      final String sql2 =\n          sqlNode2.toSqlString(UnaryOperator.identity()).getSql();\n\n      \r\n      assertEquals(sql1, sql2);\n\n      \r\n      \r\n      \r\n      final String actual2 = sqlNode2.toSqlString(null, true).getSql();\n      assertEquals(expected, linux(actual2));\n    }\n","date":"2020-09-18 10:35:30","endLine":9436,"groupId":"10378","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"checkExp","params":"(StringAndPossap@SqlDialectdialect@Stringexpected@Consumer<SqlParser>parserChecker)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/6c/d1a9613e189238221e85788dafc7e38ba16391.src","preCode":"    @Override public void checkExp(StringAndPos sap, SqlDialect dialect,\n        String expected, Consumer<SqlParser> parserChecker) {\n      final UnaryOperator<SqlParser.ConfigBuilder> transform =\n          getTransform(dialect);\n      SqlNode sqlNode =\n          parseExpressionAndHandleEx(sap.sql, transform, parserChecker);\n\n      \r\n      final UnaryOperator<SqlWriterConfig> transform2 = c ->\n          simpleWithParens().apply(c).withDialect(AnsiSqlDialect.DEFAULT);\n      final String actual = sqlNode.toSqlString(transform2).getSql();\n      assertEquals(expected, linux(actual));\n\n      \r\n      \r\n      final String sql1 =\n          sqlNode.toSqlString(UnaryOperator.identity()).getSql();\n\n      \r\n      \r\n      SqlNode sqlNode2;\n      final Quoting q = quoting;\n      try {\n        quoting = Quoting.DOUBLE_QUOTE;\n        sqlNode2 = parseExpressionAndHandleEx(sql1, transform, parser -> { });\n      } finally {\n        quoting = q;\n      }\n      final String sql2 =\n          sqlNode2.toSqlString(UnaryOperator.identity()).getSql();\n\n      \r\n      assertEquals(sql1, sql2);\n\n      \r\n      \r\n      \r\n      final String actual2 = sqlNode2.toSqlString(null, true).getSql();\n      assertEquals(expected, linux(actual2));\n    }\n","realPath":"core/src/test/java/org/apache/calcite/sql/parser/SqlParserTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":9397,"status":"B"}],"commitId":"0c5bb1a345f39cab3eaa3b95a77c1e8831e667e1","commitMessage":"@@@Refactor SqlParserTest\n\nStore StringAndPos rather than the SQL string in a test. This\nmakes it easier to write positive and negative tests on same\nSQL string.  because we don't have to keep the carets (that\nindicate the error position) in the SQL string. If you want\nreal carets in a SQL string.  you can now write \"^^\". Remove\nthe sansCarets() method.  as it is no longer necessary.\n\nPass SqlDialect into negative and expression tests.\n\nAdd constants in SqlParserTest for common dialects.\n","date":"2020-09-18 10:35:30","modifiedFileCount":"4","status":"B","submitter":"Julian Hyde"},{"authorTime":"2020-09-11 16:38:46","codes":[{"authorDate":"2020-09-11 16:38:46","commitOrder":2,"curCode":"    @Override public void check(StringAndPos sap, SqlDialect dialect,\n        String expected, Consumer<SqlParser> parserChecker) {\n      final UnaryOperator<SqlParser.Config> transform = getTransform(dialect);\n      SqlNode sqlNode = parseStmtAndHandleEx(sap.sql, transform, parserChecker);\n\n      \r\n      final SqlDialect dialect2 = Util.first(dialect, AnsiSqlDialect.DEFAULT);\n      final UnaryOperator<SqlWriterConfig> transform2 =\n          simpleWithParens().andThen(c -> c.withDialect(dialect2))::apply;\n      final String actual = sqlNode.toSqlString(transform2).getSql();\n      assertEquals(expected, linux(actual));\n\n      \r\n      \r\n      final String sql1 = sqlNode.toSqlString(simple()).getSql();\n\n      \r\n      SqlNode sqlNode2;\n      final Quoting q = quoting;\n      try {\n        quoting = Quoting.DOUBLE_QUOTE;\n        sqlNode2 = parseStmtAndHandleEx(sql1, b -> b, parser -> { });\n      } finally {\n        quoting = q;\n      }\n      final String sql2 = sqlNode2.toSqlString(simple()).getSql();\n\n      \r\n      assertEquals(sql1, sql2);\n\n      \r\n      \r\n      \r\n      final String actual2 = sqlNode.toSqlString(transform2).getSql();\n      assertEquals(expected, linux(actual2));\n\n      \r\n      \r\n      final Random random = new Random();\n      final String sql3 = sqlNode.toSqlString(randomize(random)).getSql();\n      assertThat(sql3, notNullValue());\n      SqlNode sqlNode4;\n      try {\n        quoting = Quoting.DOUBLE_QUOTE;\n        sqlNode4 = parseStmtAndHandleEx(sql1, b -> b, parser -> { });\n      } finally {\n        quoting = q;\n      }\n      final String sql4 = sqlNode4.toSqlString(simple()).getSql();\n      assertEquals(sql1, sql4);\n    }\n","date":"2020-09-18 10:35:31","endLine":9389,"groupId":"12932","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"check","params":"(StringAndPossap@SqlDialectdialect@Stringexpected@Consumer<SqlParser>parserChecker)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/33/552d6fe318702111ab3e1aa8126d5c28de6598.src","preCode":"    @Override public void check(StringAndPos sap, SqlDialect dialect,\n        String expected, Consumer<SqlParser> parserChecker) {\n      final UnaryOperator<SqlParser.ConfigBuilder> transform =\n          getTransform(dialect);\n      SqlNode sqlNode = parseStmtAndHandleEx(sap.sql, transform, parserChecker);\n\n      \r\n      final SqlDialect dialect2 = Util.first(dialect, AnsiSqlDialect.DEFAULT);\n      final UnaryOperator<SqlWriterConfig> transform2 =\n          simpleWithParens().andThen(c -> c.withDialect(dialect2))::apply;\n      final String actual = sqlNode.toSqlString(transform2).getSql();\n      assertEquals(expected, linux(actual));\n\n      \r\n      \r\n      final String sql1 = sqlNode.toSqlString(simple()).getSql();\n\n      \r\n      SqlNode sqlNode2;\n      final Quoting q = quoting;\n      try {\n        quoting = Quoting.DOUBLE_QUOTE;\n        sqlNode2 = parseStmtAndHandleEx(sql1, b -> b, parser -> { });\n      } finally {\n        quoting = q;\n      }\n      final String sql2 = sqlNode2.toSqlString(simple()).getSql();\n\n      \r\n      assertEquals(sql1, sql2);\n\n      \r\n      \r\n      \r\n      final String actual2 = sqlNode.toSqlString(transform2).getSql();\n      assertEquals(expected, linux(actual2));\n\n      \r\n      \r\n      final Random random = new Random();\n      final String sql3 = sqlNode.toSqlString(randomize(random)).getSql();\n      assertThat(sql3, notNullValue());\n      SqlNode sqlNode4;\n      try {\n        quoting = Quoting.DOUBLE_QUOTE;\n        sqlNode4 = parseStmtAndHandleEx(sql1, b -> b, parser -> { });\n      } finally {\n        quoting = q;\n      }\n      final String sql4 = sqlNode4.toSqlString(simple()).getSql();\n      assertEquals(sql1, sql4);\n    }\n","realPath":"core/src/test/java/org/apache/calcite/sql/parser/SqlParserTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":9339,"status":"M"},{"authorDate":"2020-09-11 16:38:46","commitOrder":2,"curCode":"    @Override public void checkExp(StringAndPos sap, SqlDialect dialect,\n        String expected, Consumer<SqlParser> parserChecker) {\n      final UnaryOperator<SqlParser.Config> transform = getTransform(dialect);\n      SqlNode sqlNode =\n          parseExpressionAndHandleEx(sap.sql, transform, parserChecker);\n\n      \r\n      final UnaryOperator<SqlWriterConfig> transform2 = c ->\n          simpleWithParens().apply(c).withDialect(AnsiSqlDialect.DEFAULT);\n      final String actual = sqlNode.toSqlString(transform2).getSql();\n      assertEquals(expected, linux(actual));\n\n      \r\n      \r\n      final String sql1 =\n          sqlNode.toSqlString(UnaryOperator.identity()).getSql();\n\n      \r\n      \r\n      SqlNode sqlNode2;\n      final Quoting q = quoting;\n      try {\n        quoting = Quoting.DOUBLE_QUOTE;\n        sqlNode2 = parseExpressionAndHandleEx(sql1, transform, parser -> { });\n      } finally {\n        quoting = q;\n      }\n      final String sql2 =\n          sqlNode2.toSqlString(UnaryOperator.identity()).getSql();\n\n      \r\n      assertEquals(sql1, sql2);\n\n      \r\n      \r\n      \r\n      final String actual2 = sqlNode2.toSqlString(null, true).getSql();\n      assertEquals(expected, linux(actual2));\n    }\n","date":"2020-09-18 10:35:31","endLine":9429,"groupId":"12932","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"checkExp","params":"(StringAndPossap@SqlDialectdialect@Stringexpected@Consumer<SqlParser>parserChecker)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/33/552d6fe318702111ab3e1aa8126d5c28de6598.src","preCode":"    @Override public void checkExp(StringAndPos sap, SqlDialect dialect,\n        String expected, Consumer<SqlParser> parserChecker) {\n      final UnaryOperator<SqlParser.ConfigBuilder> transform =\n          getTransform(dialect);\n      SqlNode sqlNode =\n          parseExpressionAndHandleEx(sap.sql, transform, parserChecker);\n\n      \r\n      final UnaryOperator<SqlWriterConfig> transform2 = c ->\n          simpleWithParens().apply(c).withDialect(AnsiSqlDialect.DEFAULT);\n      final String actual = sqlNode.toSqlString(transform2).getSql();\n      assertEquals(expected, linux(actual));\n\n      \r\n      \r\n      final String sql1 =\n          sqlNode.toSqlString(UnaryOperator.identity()).getSql();\n\n      \r\n      \r\n      SqlNode sqlNode2;\n      final Quoting q = quoting;\n      try {\n        quoting = Quoting.DOUBLE_QUOTE;\n        sqlNode2 = parseExpressionAndHandleEx(sql1, transform, parser -> { });\n      } finally {\n        quoting = q;\n      }\n      final String sql2 =\n          sqlNode2.toSqlString(UnaryOperator.identity()).getSql();\n\n      \r\n      assertEquals(sql1, sql2);\n\n      \r\n      \r\n      \r\n      final String actual2 = sqlNode2.toSqlString(null, true).getSql();\n      assertEquals(expected, linux(actual2));\n    }\n","realPath":"core/src/test/java/org/apache/calcite/sql/parser/SqlParserTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":9391,"status":"M"}],"commitId":"76ff19135f8bf9ee19b47d999d23bc1e2ab75e15","commitMessage":"@@@[CALCITE-4248] Deprecate SqlParser.ConfigBuilder\n","date":"2020-09-18 10:35:31","modifiedFileCount":"20","status":"M","submitter":"Julian Hyde"}]
