[{"authorTime":"2020-09-30 01:31:14","codes":[{"authorDate":"2020-09-30 01:31:14","commitOrder":14,"curCode":"  Expression translateCast(\n      RelDataType sourceType,\n      RelDataType targetType,\n      Expression operand) {\n    Expression convert = null;\n    switch (targetType.getSqlTypeName()) {\n    case ANY:\n      convert = operand;\n      break;\n    case DATE:\n      convert = translateCastToDate(sourceType, operand);\n      break;\n    case TIME:\n      convert = translateCastToTime(sourceType, operand);\n      break;\n    case TIME_WITH_LOCAL_TIME_ZONE:\n      switch (sourceType.getSqlTypeName()) {\n      case CHAR:\n      case VARCHAR:\n        convert =\n            Expressions.call(BuiltInMethod.STRING_TO_TIME_WITH_LOCAL_TIME_ZONE.method, operand);\n        break;\n      case TIME:\n        convert = Expressions.call(\n            BuiltInMethod.TIME_STRING_TO_TIME_WITH_LOCAL_TIME_ZONE.method,\n            RexImpTable.optimize2(\n                operand,\n                Expressions.call(\n                    BuiltInMethod.UNIX_TIME_TO_STRING.method,\n                    operand)),\n            Expressions.call(BuiltInMethod.TIME_ZONE.method, root));\n        break;\n      case TIMESTAMP:\n        convert = Expressions.call(\n            BuiltInMethod.TIMESTAMP_STRING_TO_TIMESTAMP_WITH_LOCAL_TIME_ZONE.method,\n            RexImpTable.optimize2(\n                operand,\n                Expressions.call(\n                    BuiltInMethod.UNIX_TIMESTAMP_TO_STRING.method,\n                    operand)),\n            Expressions.call(BuiltInMethod.TIME_ZONE.method, root));\n        break;\n      case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIME_WITH_LOCAL_TIME_ZONE.method,\n                operand));\n        break;\n      default:\n        break;\n      }\n      break;\n    case TIMESTAMP:\n      switch (sourceType.getSqlTypeName()) {\n      case CHAR:\n      case VARCHAR:\n        convert =\n            Expressions.call(BuiltInMethod.STRING_TO_TIMESTAMP.method, operand);\n        break;\n      case DATE:\n        convert = Expressions.multiply(\n            Expressions.convert_(operand, long.class),\n            Expressions.constant(DateTimeUtils.MILLIS_PER_DAY));\n        break;\n      case TIME:\n        convert =\n            Expressions.add(\n                Expressions.multiply(\n                    Expressions.convert_(\n                        Expressions.call(BuiltInMethod.CURRENT_DATE.method, root),\n                        long.class),\n                    Expressions.constant(DateTimeUtils.MILLIS_PER_DAY)),\n                Expressions.convert_(operand, long.class));\n        break;\n      case TIME_WITH_LOCAL_TIME_ZONE:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.TIME_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n                Expressions.call(\n                    BuiltInMethod.UNIX_DATE_TO_STRING.method,\n                    Expressions.call(BuiltInMethod.CURRENT_DATE.method, root)),\n                operand,\n                Expressions.call(BuiltInMethod.TIME_ZONE.method, root)));\n        break;\n      case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n                operand,\n                Expressions.call(BuiltInMethod.TIME_ZONE.method, root)));\n        break;\n      default:\n        break;\n      }\n      break;\n    case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n      switch (sourceType.getSqlTypeName()) {\n      case CHAR:\n      case VARCHAR:\n        convert =\n            Expressions.call(\n                BuiltInMethod.STRING_TO_TIMESTAMP_WITH_LOCAL_TIME_ZONE.method,\n                operand);\n        break;\n      case DATE:\n        convert = Expressions.call(\n            BuiltInMethod.TIMESTAMP_STRING_TO_TIMESTAMP_WITH_LOCAL_TIME_ZONE.method,\n            RexImpTable.optimize2(\n                operand,\n                Expressions.call(\n                    BuiltInMethod.UNIX_TIMESTAMP_TO_STRING.method,\n                    Expressions.multiply(\n                        Expressions.convert_(operand, long.class),\n                        Expressions.constant(DateTimeUtils.MILLIS_PER_DAY)))),\n            Expressions.call(BuiltInMethod.TIME_ZONE.method, root));\n        break;\n      case TIME:\n        convert = Expressions.call(\n            BuiltInMethod.TIMESTAMP_STRING_TO_TIMESTAMP_WITH_LOCAL_TIME_ZONE.method,\n            RexImpTable.optimize2(\n                operand,\n                Expressions.call(\n                    BuiltInMethod.UNIX_TIMESTAMP_TO_STRING.method,\n                    Expressions.add(\n                        Expressions.multiply(\n                            Expressions.convert_(\n                                Expressions.call(BuiltInMethod.CURRENT_DATE.method, root),\n                                long.class),\n                            Expressions.constant(DateTimeUtils.MILLIS_PER_DAY)),\n                        Expressions.convert_(operand, long.class)))),\n            Expressions.call(BuiltInMethod.TIME_ZONE.method, root));\n        break;\n      case TIME_WITH_LOCAL_TIME_ZONE:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.TIME_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP_WITH_LOCAL_TIME_ZONE.method,\n                Expressions.call(\n                    BuiltInMethod.UNIX_DATE_TO_STRING.method,\n                    Expressions.call(BuiltInMethod.CURRENT_DATE.method, root)),\n                operand));\n        break;\n      case TIMESTAMP:\n        convert = Expressions.call(\n            BuiltInMethod.TIMESTAMP_STRING_TO_TIMESTAMP_WITH_LOCAL_TIME_ZONE.method,\n            RexImpTable.optimize2(\n                operand,\n                Expressions.call(\n                    BuiltInMethod.UNIX_TIMESTAMP_TO_STRING.method,\n                    operand)),\n            Expressions.call(BuiltInMethod.TIME_ZONE.method, root));\n        break;\n      default:\n        break;\n      }\n      break;\n    case BOOLEAN:\n      switch (sourceType.getSqlTypeName()) {\n      case CHAR:\n      case VARCHAR:\n        convert = Expressions.call(\n            BuiltInMethod.STRING_TO_BOOLEAN.method,\n            operand);\n        break;\n      default:\n        break;\n      }\n      break;\n    case CHAR:\n    case VARCHAR:\n      final SqlIntervalQualifier interval =\n          sourceType.getIntervalQualifier();\n      switch (sourceType.getSqlTypeName()) {\n      case DATE:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.UNIX_DATE_TO_STRING.method,\n                operand));\n        break;\n      case TIME:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.UNIX_TIME_TO_STRING.method,\n                operand));\n        break;\n      case TIME_WITH_LOCAL_TIME_ZONE:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.TIME_WITH_LOCAL_TIME_ZONE_TO_STRING.method,\n                operand,\n                Expressions.call(BuiltInMethod.TIME_ZONE.method, root)));\n        break;\n      case TIMESTAMP:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.UNIX_TIMESTAMP_TO_STRING.method,\n                operand));\n        break;\n      case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_STRING.method,\n                operand,\n                Expressions.call(BuiltInMethod.TIME_ZONE.method, root)));\n        break;\n      case INTERVAL_YEAR:\n      case INTERVAL_YEAR_MONTH:\n      case INTERVAL_MONTH:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.INTERVAL_YEAR_MONTH_TO_STRING.method,\n                operand,\n                Expressions.constant(interval.timeUnitRange)));\n        break;\n      case INTERVAL_DAY:\n      case INTERVAL_DAY_HOUR:\n      case INTERVAL_DAY_MINUTE:\n      case INTERVAL_DAY_SECOND:\n      case INTERVAL_HOUR:\n      case INTERVAL_HOUR_MINUTE:\n      case INTERVAL_HOUR_SECOND:\n      case INTERVAL_MINUTE:\n      case INTERVAL_MINUTE_SECOND:\n      case INTERVAL_SECOND:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.INTERVAL_DAY_TIME_TO_STRING.method,\n                operand,\n                Expressions.constant(interval.timeUnitRange),\n                Expressions.constant(\n                    interval.getFractionalSecondPrecision(\n                        typeFactory.getTypeSystem()))));\n        break;\n      case BOOLEAN:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.BOOLEAN_TO_STRING.method,\n                operand));\n        break;\n      default:\n        break;\n      }\n      break;\n    default:\n      break;\n    }\n    if (convert == null) {\n      convert = EnumUtils.convert(operand, typeFactory.getJavaClass(targetType));\n    }\n    \r\n    \r\n    boolean pad = false;\n    boolean truncate = true;\n    switch (targetType.getSqlTypeName()) {\n    case CHAR:\n    case BINARY:\n      pad = true;\n      \r\n    case VARCHAR:\n    case VARBINARY:\n      final int targetPrecision = targetType.getPrecision();\n      if (targetPrecision >= 0) {\n        switch (sourceType.getSqlTypeName()) {\n        case CHAR:\n        case VARCHAR:\n        case BINARY:\n        case VARBINARY:\n          \r\n          final int sourcePrecision = sourceType.getPrecision();\n          if (SqlTypeUtil.comparePrecision(sourcePrecision, targetPrecision)\n              <= 0) {\n            truncate = false;\n          }\n          \r\n          if (SqlTypeUtil.comparePrecision(sourcePrecision, targetPrecision)\n              >= 0) {\n            pad = false;\n          }\n          \r\n        default:\n          if (truncate || pad) {\n            convert =\n                Expressions.call(\n                    pad\n                        ? BuiltInMethod.TRUNCATE_OR_PAD.method\n                        : BuiltInMethod.TRUNCATE.method,\n                    convert,\n                    Expressions.constant(targetPrecision));\n          }\n        }\n      }\n      break;\n    case TIMESTAMP:\n      int targetScale = targetType.getScale();\n      if (targetScale == RelDataType.SCALE_NOT_SPECIFIED) {\n        targetScale = 0;\n      }\n      if (targetScale < sourceType.getScale()) {\n        convert =\n            Expressions.call(\n                BuiltInMethod.ROUND_LONG.method,\n                convert,\n                Expressions.constant(\n                    (long) Math.pow(10, 3 - targetScale)));\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      switch (sourceType.getSqlTypeName().getFamily()) {\n      case NUMERIC:\n        final BigDecimal multiplier = targetType.getSqlTypeName().getEndUnit().multiplier;\n        final BigDecimal divider = BigDecimal.ONE;\n        convert = RexImpTable.multiplyDivide(convert, multiplier, divider);\n        break;\n      default:\n        break;\n      }\n      break;\n    default:\n      break;\n    }\n    return scaleIntervalToNumber(sourceType, targetType, convert);\n  }\n","date":"2020-10-07 05:43:06","endLine":593,"groupId":"15414","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"translateCast","params":"(RelDataTypesourceType@RelDataTypetargetType@Expressionoperand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/15/ace8f46811d117ab75418179ab96343ae5c789.src","preCode":"  Expression translateCast(\n      RelDataType sourceType,\n      RelDataType targetType,\n      Expression operand) {\n    Expression convert = null;\n    switch (targetType.getSqlTypeName()) {\n    case ANY:\n      convert = operand;\n      break;\n    case DATE:\n      convert = translateCastToDate(sourceType, operand);\n      break;\n    case TIME:\n      convert = translateCastToTime(sourceType, operand);\n      break;\n    case TIME_WITH_LOCAL_TIME_ZONE:\n      switch (sourceType.getSqlTypeName()) {\n      case CHAR:\n      case VARCHAR:\n        convert =\n            Expressions.call(BuiltInMethod.STRING_TO_TIME_WITH_LOCAL_TIME_ZONE.method, operand);\n        break;\n      case TIME:\n        convert = Expressions.call(\n            BuiltInMethod.TIME_STRING_TO_TIME_WITH_LOCAL_TIME_ZONE.method,\n            RexImpTable.optimize2(\n                operand,\n                Expressions.call(\n                    BuiltInMethod.UNIX_TIME_TO_STRING.method,\n                    operand)),\n            Expressions.call(BuiltInMethod.TIME_ZONE.method, root));\n        break;\n      case TIMESTAMP:\n        convert = Expressions.call(\n            BuiltInMethod.TIMESTAMP_STRING_TO_TIMESTAMP_WITH_LOCAL_TIME_ZONE.method,\n            RexImpTable.optimize2(\n                operand,\n                Expressions.call(\n                    BuiltInMethod.UNIX_TIMESTAMP_TO_STRING.method,\n                    operand)),\n            Expressions.call(BuiltInMethod.TIME_ZONE.method, root));\n        break;\n      case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIME_WITH_LOCAL_TIME_ZONE.method,\n                operand));\n        break;\n      default:\n        break;\n      }\n      break;\n    case TIMESTAMP:\n      switch (sourceType.getSqlTypeName()) {\n      case CHAR:\n      case VARCHAR:\n        convert =\n            Expressions.call(BuiltInMethod.STRING_TO_TIMESTAMP.method, operand);\n        break;\n      case DATE:\n        convert = Expressions.multiply(\n            Expressions.convert_(operand, long.class),\n            Expressions.constant(DateTimeUtils.MILLIS_PER_DAY));\n        break;\n      case TIME:\n        convert =\n            Expressions.add(\n                Expressions.multiply(\n                    Expressions.convert_(\n                        Expressions.call(BuiltInMethod.CURRENT_DATE.method, root),\n                        long.class),\n                    Expressions.constant(DateTimeUtils.MILLIS_PER_DAY)),\n                Expressions.convert_(operand, long.class));\n        break;\n      case TIME_WITH_LOCAL_TIME_ZONE:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.TIME_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n                Expressions.call(\n                    BuiltInMethod.UNIX_DATE_TO_STRING.method,\n                    Expressions.call(BuiltInMethod.CURRENT_DATE.method, root)),\n                operand,\n                Expressions.call(BuiltInMethod.TIME_ZONE.method, root)));\n        break;\n      case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n                operand,\n                Expressions.call(BuiltInMethod.TIME_ZONE.method, root)));\n        break;\n      default:\n        break;\n      }\n      break;\n    case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n      switch (sourceType.getSqlTypeName()) {\n      case CHAR:\n      case VARCHAR:\n        convert =\n            Expressions.call(\n                BuiltInMethod.STRING_TO_TIMESTAMP_WITH_LOCAL_TIME_ZONE.method,\n                operand);\n        break;\n      case DATE:\n        convert = Expressions.call(\n            BuiltInMethod.TIMESTAMP_STRING_TO_TIMESTAMP_WITH_LOCAL_TIME_ZONE.method,\n            RexImpTable.optimize2(\n                operand,\n                Expressions.call(\n                    BuiltInMethod.UNIX_TIMESTAMP_TO_STRING.method,\n                    Expressions.multiply(\n                        Expressions.convert_(operand, long.class),\n                        Expressions.constant(DateTimeUtils.MILLIS_PER_DAY)))),\n            Expressions.call(BuiltInMethod.TIME_ZONE.method, root));\n        break;\n      case TIME:\n        convert = Expressions.call(\n            BuiltInMethod.TIMESTAMP_STRING_TO_TIMESTAMP_WITH_LOCAL_TIME_ZONE.method,\n            RexImpTable.optimize2(\n                operand,\n                Expressions.call(\n                    BuiltInMethod.UNIX_TIMESTAMP_TO_STRING.method,\n                    Expressions.add(\n                        Expressions.multiply(\n                            Expressions.convert_(\n                                Expressions.call(BuiltInMethod.CURRENT_DATE.method, root),\n                                long.class),\n                            Expressions.constant(DateTimeUtils.MILLIS_PER_DAY)),\n                        Expressions.convert_(operand, long.class)))),\n            Expressions.call(BuiltInMethod.TIME_ZONE.method, root));\n        break;\n      case TIME_WITH_LOCAL_TIME_ZONE:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.TIME_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP_WITH_LOCAL_TIME_ZONE.method,\n                Expressions.call(\n                    BuiltInMethod.UNIX_DATE_TO_STRING.method,\n                    Expressions.call(BuiltInMethod.CURRENT_DATE.method, root)),\n                operand));\n        break;\n      case TIMESTAMP:\n        convert = Expressions.call(\n            BuiltInMethod.TIMESTAMP_STRING_TO_TIMESTAMP_WITH_LOCAL_TIME_ZONE.method,\n            RexImpTable.optimize2(\n                operand,\n                Expressions.call(\n                    BuiltInMethod.UNIX_TIMESTAMP_TO_STRING.method,\n                    operand)),\n            Expressions.call(BuiltInMethod.TIME_ZONE.method, root));\n        break;\n      default:\n        break;\n      }\n      break;\n    case BOOLEAN:\n      switch (sourceType.getSqlTypeName()) {\n      case CHAR:\n      case VARCHAR:\n        convert = Expressions.call(\n            BuiltInMethod.STRING_TO_BOOLEAN.method,\n            operand);\n        break;\n      default:\n        break;\n      }\n      break;\n    case CHAR:\n    case VARCHAR:\n      final SqlIntervalQualifier interval =\n          sourceType.getIntervalQualifier();\n      switch (sourceType.getSqlTypeName()) {\n      case DATE:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.UNIX_DATE_TO_STRING.method,\n                operand));\n        break;\n      case TIME:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.UNIX_TIME_TO_STRING.method,\n                operand));\n        break;\n      case TIME_WITH_LOCAL_TIME_ZONE:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.TIME_WITH_LOCAL_TIME_ZONE_TO_STRING.method,\n                operand,\n                Expressions.call(BuiltInMethod.TIME_ZONE.method, root)));\n        break;\n      case TIMESTAMP:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.UNIX_TIMESTAMP_TO_STRING.method,\n                operand));\n        break;\n      case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_STRING.method,\n                operand,\n                Expressions.call(BuiltInMethod.TIME_ZONE.method, root)));\n        break;\n      case INTERVAL_YEAR:\n      case INTERVAL_YEAR_MONTH:\n      case INTERVAL_MONTH:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.INTERVAL_YEAR_MONTH_TO_STRING.method,\n                operand,\n                Expressions.constant(interval.timeUnitRange)));\n        break;\n      case INTERVAL_DAY:\n      case INTERVAL_DAY_HOUR:\n      case INTERVAL_DAY_MINUTE:\n      case INTERVAL_DAY_SECOND:\n      case INTERVAL_HOUR:\n      case INTERVAL_HOUR_MINUTE:\n      case INTERVAL_HOUR_SECOND:\n      case INTERVAL_MINUTE:\n      case INTERVAL_MINUTE_SECOND:\n      case INTERVAL_SECOND:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.INTERVAL_DAY_TIME_TO_STRING.method,\n                operand,\n                Expressions.constant(interval.timeUnitRange),\n                Expressions.constant(\n                    interval.getFractionalSecondPrecision(\n                        typeFactory.getTypeSystem()))));\n        break;\n      case BOOLEAN:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.BOOLEAN_TO_STRING.method,\n                operand));\n        break;\n      default:\n        break;\n      }\n      break;\n    default:\n      break;\n    }\n    if (convert == null) {\n      convert = EnumUtils.convert(operand, typeFactory.getJavaClass(targetType));\n    }\n    \r\n    \r\n    boolean pad = false;\n    boolean truncate = true;\n    switch (targetType.getSqlTypeName()) {\n    case CHAR:\n    case BINARY:\n      pad = true;\n      \r\n    case VARCHAR:\n    case VARBINARY:\n      final int targetPrecision = targetType.getPrecision();\n      if (targetPrecision >= 0) {\n        switch (sourceType.getSqlTypeName()) {\n        case CHAR:\n        case VARCHAR:\n        case BINARY:\n        case VARBINARY:\n          \r\n          final int sourcePrecision = sourceType.getPrecision();\n          if (SqlTypeUtil.comparePrecision(sourcePrecision, targetPrecision)\n              <= 0) {\n            truncate = false;\n          }\n          \r\n          if (SqlTypeUtil.comparePrecision(sourcePrecision, targetPrecision)\n              >= 0) {\n            pad = false;\n          }\n          \r\n        default:\n          if (truncate || pad) {\n            convert =\n                Expressions.call(\n                    pad\n                        ? BuiltInMethod.TRUNCATE_OR_PAD.method\n                        : BuiltInMethod.TRUNCATE.method,\n                    convert,\n                    Expressions.constant(targetPrecision));\n          }\n        }\n      }\n      break;\n    case TIMESTAMP:\n      int targetScale = targetType.getScale();\n      if (targetScale == RelDataType.SCALE_NOT_SPECIFIED) {\n        targetScale = 0;\n      }\n      if (targetScale < sourceType.getScale()) {\n        convert =\n            Expressions.call(\n                BuiltInMethod.ROUND_LONG.method,\n                convert,\n                Expressions.constant(\n                    (long) Math.pow(10, 3 - targetScale)));\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      switch (sourceType.getSqlTypeName().getFamily()) {\n      case NUMERIC:\n        final BigDecimal multiplier = targetType.getSqlTypeName().getEndUnit().multiplier;\n        final BigDecimal divider = BigDecimal.ONE;\n        convert = RexImpTable.multiplyDivide(convert, multiplier, divider);\n        break;\n      default:\n        break;\n      }\n      break;\n    default:\n      break;\n    }\n    return scaleIntervalToNumber(sourceType, targetType, convert);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/RexToLixTranslator.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":249,"status":"MB"},{"authorDate":"2020-09-30 01:31:14","commitOrder":14,"curCode":"  private Expression translateCastToTime(RelDataType sourceType, Expression operand) {\n    Expression convert = null;\n    switch (sourceType.getSqlTypeName()) {\n    case CHAR:\n    case VARCHAR:\n      convert =\n          Expressions.call(BuiltInMethod.STRING_TO_TIME.method, operand);\n      break;\n    case TIME_WITH_LOCAL_TIME_ZONE:\n      convert = RexImpTable.optimize2(\n          operand,\n          Expressions.call(\n              BuiltInMethod.TIME_WITH_LOCAL_TIME_ZONE_TO_TIME.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, root)));\n      break;\n    case TIMESTAMP:\n      convert = Expressions.convert_(\n          Expressions.call(\n              BuiltInMethod.FLOOR_MOD.method,\n              operand,\n              Expressions.constant(DateTimeUtils.MILLIS_PER_DAY)),\n          int.class);\n      break;\n    case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n      convert = RexImpTable.optimize2(\n          operand,\n          Expressions.call(\n              BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIME.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, root)));\n      break;\n    default:\n      break;\n    }\n    return convert;\n  }\n","date":"2020-10-07 05:43:06","endLine":631,"groupId":"15414","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"translateCastToTime","params":"(RelDataTypesourceType@Expressionoperand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/15/ace8f46811d117ab75418179ab96343ae5c789.src","preCode":"  private Expression translateCastToTime(RelDataType sourceType, Expression operand) {\n    Expression convert = null;\n    switch (sourceType.getSqlTypeName()) {\n    case CHAR:\n    case VARCHAR:\n      convert =\n          Expressions.call(BuiltInMethod.STRING_TO_TIME.method, operand);\n      break;\n    case TIME_WITH_LOCAL_TIME_ZONE:\n      convert = RexImpTable.optimize2(\n          operand,\n          Expressions.call(\n              BuiltInMethod.TIME_WITH_LOCAL_TIME_ZONE_TO_TIME.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, root)));\n      break;\n    case TIMESTAMP:\n      convert = Expressions.convert_(\n          Expressions.call(\n              BuiltInMethod.FLOOR_MOD.method,\n              operand,\n              Expressions.constant(DateTimeUtils.MILLIS_PER_DAY)),\n          int.class);\n      break;\n    case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n      convert = RexImpTable.optimize2(\n          operand,\n          Expressions.call(\n              BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIME.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, root)));\n      break;\n    default:\n      break;\n    }\n    return convert;\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/RexToLixTranslator.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":595,"status":"B"}],"commitId":"1b94f37e888cf2d186362473529e6c147afe0f6e","commitMessage":"@@@[CALCITE-4314] Add missing default branches to switch statement\n\nNote: the changes are mechanical.\nThe intention is to keep the previous behavior and prevent adding new\nnon exchaustive switch statements in the future.\n\nSee https://errorprone.info/bugpattern/MissingCasesInEnumSwitch\n","date":"2020-10-07 05:43:06","modifiedFileCount":"98","status":"M","submitter":"Vladimir Sitnikov"},{"authorTime":"2020-05-29 00:04:40","codes":[{"authorDate":"2020-05-29 00:04:40","commitOrder":15,"curCode":"  Expression translateCast(\n      RelDataType sourceType,\n      RelDataType targetType,\n      Expression operand) {\n    Expression convert = null;\n    switch (targetType.getSqlTypeName()) {\n    case ANY:\n      convert = operand;\n      break;\n    case DATE:\n      convert = translateCastToDate(sourceType, operand);\n      break;\n    case TIME:\n      convert = translateCastToTime(sourceType, operand);\n      break;\n    case TIME_WITH_LOCAL_TIME_ZONE:\n      switch (sourceType.getSqlTypeName()) {\n      case CHAR:\n      case VARCHAR:\n        convert =\n            Expressions.call(BuiltInMethod.STRING_TO_TIME_WITH_LOCAL_TIME_ZONE.method, operand);\n        break;\n      case TIME:\n        convert = Expressions.call(\n            BuiltInMethod.TIME_STRING_TO_TIME_WITH_LOCAL_TIME_ZONE.method,\n            RexImpTable.optimize2(\n                operand,\n                Expressions.call(\n                    BuiltInMethod.UNIX_TIME_TO_STRING.method,\n                    operand)),\n            Expressions.call(BuiltInMethod.TIME_ZONE.method, root));\n        break;\n      case TIMESTAMP:\n        convert = Expressions.call(\n            BuiltInMethod.TIMESTAMP_STRING_TO_TIMESTAMP_WITH_LOCAL_TIME_ZONE.method,\n            RexImpTable.optimize2(\n                operand,\n                Expressions.call(\n                    BuiltInMethod.UNIX_TIMESTAMP_TO_STRING.method,\n                    operand)),\n            Expressions.call(BuiltInMethod.TIME_ZONE.method, root));\n        break;\n      case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIME_WITH_LOCAL_TIME_ZONE.method,\n                operand));\n        break;\n      default:\n        break;\n      }\n      break;\n    case TIMESTAMP:\n      switch (sourceType.getSqlTypeName()) {\n      case CHAR:\n      case VARCHAR:\n        convert =\n            Expressions.call(BuiltInMethod.STRING_TO_TIMESTAMP.method, operand);\n        break;\n      case DATE:\n        convert = Expressions.multiply(\n            Expressions.convert_(operand, long.class),\n            Expressions.constant(DateTimeUtils.MILLIS_PER_DAY));\n        break;\n      case TIME:\n        convert =\n            Expressions.add(\n                Expressions.multiply(\n                    Expressions.convert_(\n                        Expressions.call(BuiltInMethod.CURRENT_DATE.method, root),\n                        long.class),\n                    Expressions.constant(DateTimeUtils.MILLIS_PER_DAY)),\n                Expressions.convert_(operand, long.class));\n        break;\n      case TIME_WITH_LOCAL_TIME_ZONE:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.TIME_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n                Expressions.call(\n                    BuiltInMethod.UNIX_DATE_TO_STRING.method,\n                    Expressions.call(BuiltInMethod.CURRENT_DATE.method, root)),\n                operand,\n                Expressions.call(BuiltInMethod.TIME_ZONE.method, root)));\n        break;\n      case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n                operand,\n                Expressions.call(BuiltInMethod.TIME_ZONE.method, root)));\n        break;\n      default:\n        break;\n      }\n      break;\n    case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n      switch (sourceType.getSqlTypeName()) {\n      case CHAR:\n      case VARCHAR:\n        convert =\n            Expressions.call(\n                BuiltInMethod.STRING_TO_TIMESTAMP_WITH_LOCAL_TIME_ZONE.method,\n                operand);\n        break;\n      case DATE:\n        convert = Expressions.call(\n            BuiltInMethod.TIMESTAMP_STRING_TO_TIMESTAMP_WITH_LOCAL_TIME_ZONE.method,\n            RexImpTable.optimize2(\n                operand,\n                Expressions.call(\n                    BuiltInMethod.UNIX_TIMESTAMP_TO_STRING.method,\n                    Expressions.multiply(\n                        Expressions.convert_(operand, long.class),\n                        Expressions.constant(DateTimeUtils.MILLIS_PER_DAY)))),\n            Expressions.call(BuiltInMethod.TIME_ZONE.method, root));\n        break;\n      case TIME:\n        convert = Expressions.call(\n            BuiltInMethod.TIMESTAMP_STRING_TO_TIMESTAMP_WITH_LOCAL_TIME_ZONE.method,\n            RexImpTable.optimize2(\n                operand,\n                Expressions.call(\n                    BuiltInMethod.UNIX_TIMESTAMP_TO_STRING.method,\n                    Expressions.add(\n                        Expressions.multiply(\n                            Expressions.convert_(\n                                Expressions.call(BuiltInMethod.CURRENT_DATE.method, root),\n                                long.class),\n                            Expressions.constant(DateTimeUtils.MILLIS_PER_DAY)),\n                        Expressions.convert_(operand, long.class)))),\n            Expressions.call(BuiltInMethod.TIME_ZONE.method, root));\n        break;\n      case TIME_WITH_LOCAL_TIME_ZONE:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.TIME_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP_WITH_LOCAL_TIME_ZONE.method,\n                Expressions.call(\n                    BuiltInMethod.UNIX_DATE_TO_STRING.method,\n                    Expressions.call(BuiltInMethod.CURRENT_DATE.method, root)),\n                operand));\n        break;\n      case TIMESTAMP:\n        convert = Expressions.call(\n            BuiltInMethod.TIMESTAMP_STRING_TO_TIMESTAMP_WITH_LOCAL_TIME_ZONE.method,\n            RexImpTable.optimize2(\n                operand,\n                Expressions.call(\n                    BuiltInMethod.UNIX_TIMESTAMP_TO_STRING.method,\n                    operand)),\n            Expressions.call(BuiltInMethod.TIME_ZONE.method, root));\n        break;\n      default:\n        break;\n      }\n      break;\n    case BOOLEAN:\n      switch (sourceType.getSqlTypeName()) {\n      case CHAR:\n      case VARCHAR:\n        convert = Expressions.call(\n            BuiltInMethod.STRING_TO_BOOLEAN.method,\n            operand);\n        break;\n      default:\n        break;\n      }\n      break;\n    case CHAR:\n    case VARCHAR:\n      final SqlIntervalQualifier interval =\n          sourceType.getIntervalQualifier();\n      switch (sourceType.getSqlTypeName()) {\n      case DATE:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.UNIX_DATE_TO_STRING.method,\n                operand));\n        break;\n      case TIME:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.UNIX_TIME_TO_STRING.method,\n                operand));\n        break;\n      case TIME_WITH_LOCAL_TIME_ZONE:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.TIME_WITH_LOCAL_TIME_ZONE_TO_STRING.method,\n                operand,\n                Expressions.call(BuiltInMethod.TIME_ZONE.method, root)));\n        break;\n      case TIMESTAMP:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.UNIX_TIMESTAMP_TO_STRING.method,\n                operand));\n        break;\n      case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_STRING.method,\n                operand,\n                Expressions.call(BuiltInMethod.TIME_ZONE.method, root)));\n        break;\n      case INTERVAL_YEAR:\n      case INTERVAL_YEAR_MONTH:\n      case INTERVAL_MONTH:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.INTERVAL_YEAR_MONTH_TO_STRING.method,\n                operand,\n                Expressions.constant(requireNonNull(interval, \"interval\").timeUnitRange)));\n        break;\n      case INTERVAL_DAY:\n      case INTERVAL_DAY_HOUR:\n      case INTERVAL_DAY_MINUTE:\n      case INTERVAL_DAY_SECOND:\n      case INTERVAL_HOUR:\n      case INTERVAL_HOUR_MINUTE:\n      case INTERVAL_HOUR_SECOND:\n      case INTERVAL_MINUTE:\n      case INTERVAL_MINUTE_SECOND:\n      case INTERVAL_SECOND:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.INTERVAL_DAY_TIME_TO_STRING.method,\n                operand,\n                Expressions.constant(requireNonNull(interval, \"interval\").timeUnitRange),\n                Expressions.constant(\n                    interval.getFractionalSecondPrecision(\n                        typeFactory.getTypeSystem()))));\n        break;\n      case BOOLEAN:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.BOOLEAN_TO_STRING.method,\n                operand));\n        break;\n      default:\n        break;\n      }\n      break;\n    default:\n      break;\n    }\n    if (convert == null) {\n      convert = EnumUtils.convert(operand, typeFactory.getJavaClass(targetType));\n    }\n    \r\n    \r\n    boolean pad = false;\n    boolean truncate = true;\n    switch (targetType.getSqlTypeName()) {\n    case CHAR:\n    case BINARY:\n      pad = true;\n      \r\n    case VARCHAR:\n    case VARBINARY:\n      final int targetPrecision = targetType.getPrecision();\n      if (targetPrecision >= 0) {\n        switch (sourceType.getSqlTypeName()) {\n        case CHAR:\n        case VARCHAR:\n        case BINARY:\n        case VARBINARY:\n          \r\n          final int sourcePrecision = sourceType.getPrecision();\n          if (SqlTypeUtil.comparePrecision(sourcePrecision, targetPrecision)\n              <= 0) {\n            truncate = false;\n          }\n          \r\n          if (SqlTypeUtil.comparePrecision(sourcePrecision, targetPrecision)\n              >= 0) {\n            pad = false;\n          }\n          \r\n        default:\n          if (truncate || pad) {\n            convert =\n                Expressions.call(\n                    pad\n                        ? BuiltInMethod.TRUNCATE_OR_PAD.method\n                        : BuiltInMethod.TRUNCATE.method,\n                    convert,\n                    Expressions.constant(targetPrecision));\n          }\n        }\n      }\n      break;\n    case TIMESTAMP:\n      int targetScale = targetType.getScale();\n      if (targetScale == RelDataType.SCALE_NOT_SPECIFIED) {\n        targetScale = 0;\n      }\n      if (targetScale < sourceType.getScale()) {\n        convert =\n            Expressions.call(\n                BuiltInMethod.ROUND_LONG.method,\n                convert,\n                Expressions.constant(\n                    (long) Math.pow(10, 3 - targetScale)));\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      switch (requireNonNull(sourceType.getSqlTypeName().getFamily(),\n          () -> \"null SqlTypeFamily for \" + sourceType + \", SqlTypeName \"\n              + sourceType.getSqlTypeName())) {\n      case NUMERIC:\n        final BigDecimal multiplier = targetType.getSqlTypeName().getEndUnit().multiplier;\n        final BigDecimal divider = BigDecimal.ONE;\n        convert = RexImpTable.multiplyDivide(convert, multiplier, divider);\n        break;\n      default:\n        break;\n      }\n      break;\n    default:\n      break;\n    }\n    return scaleIntervalToNumber(sourceType, targetType, convert);\n  }\n","date":"2020-11-30 06:45:33","endLine":598,"groupId":"102152","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"translateCast","params":"(RelDataTypesourceType@RelDataTypetargetType@Expressionoperand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/ee/78362efd5815b5334cc4d1ed7a5d472c53f7e0.src","preCode":"  Expression translateCast(\n      RelDataType sourceType,\n      RelDataType targetType,\n      Expression operand) {\n    Expression convert = null;\n    switch (targetType.getSqlTypeName()) {\n    case ANY:\n      convert = operand;\n      break;\n    case DATE:\n      convert = translateCastToDate(sourceType, operand);\n      break;\n    case TIME:\n      convert = translateCastToTime(sourceType, operand);\n      break;\n    case TIME_WITH_LOCAL_TIME_ZONE:\n      switch (sourceType.getSqlTypeName()) {\n      case CHAR:\n      case VARCHAR:\n        convert =\n            Expressions.call(BuiltInMethod.STRING_TO_TIME_WITH_LOCAL_TIME_ZONE.method, operand);\n        break;\n      case TIME:\n        convert = Expressions.call(\n            BuiltInMethod.TIME_STRING_TO_TIME_WITH_LOCAL_TIME_ZONE.method,\n            RexImpTable.optimize2(\n                operand,\n                Expressions.call(\n                    BuiltInMethod.UNIX_TIME_TO_STRING.method,\n                    operand)),\n            Expressions.call(BuiltInMethod.TIME_ZONE.method, root));\n        break;\n      case TIMESTAMP:\n        convert = Expressions.call(\n            BuiltInMethod.TIMESTAMP_STRING_TO_TIMESTAMP_WITH_LOCAL_TIME_ZONE.method,\n            RexImpTable.optimize2(\n                operand,\n                Expressions.call(\n                    BuiltInMethod.UNIX_TIMESTAMP_TO_STRING.method,\n                    operand)),\n            Expressions.call(BuiltInMethod.TIME_ZONE.method, root));\n        break;\n      case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIME_WITH_LOCAL_TIME_ZONE.method,\n                operand));\n        break;\n      default:\n        break;\n      }\n      break;\n    case TIMESTAMP:\n      switch (sourceType.getSqlTypeName()) {\n      case CHAR:\n      case VARCHAR:\n        convert =\n            Expressions.call(BuiltInMethod.STRING_TO_TIMESTAMP.method, operand);\n        break;\n      case DATE:\n        convert = Expressions.multiply(\n            Expressions.convert_(operand, long.class),\n            Expressions.constant(DateTimeUtils.MILLIS_PER_DAY));\n        break;\n      case TIME:\n        convert =\n            Expressions.add(\n                Expressions.multiply(\n                    Expressions.convert_(\n                        Expressions.call(BuiltInMethod.CURRENT_DATE.method, root),\n                        long.class),\n                    Expressions.constant(DateTimeUtils.MILLIS_PER_DAY)),\n                Expressions.convert_(operand, long.class));\n        break;\n      case TIME_WITH_LOCAL_TIME_ZONE:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.TIME_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n                Expressions.call(\n                    BuiltInMethod.UNIX_DATE_TO_STRING.method,\n                    Expressions.call(BuiltInMethod.CURRENT_DATE.method, root)),\n                operand,\n                Expressions.call(BuiltInMethod.TIME_ZONE.method, root)));\n        break;\n      case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n                operand,\n                Expressions.call(BuiltInMethod.TIME_ZONE.method, root)));\n        break;\n      default:\n        break;\n      }\n      break;\n    case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n      switch (sourceType.getSqlTypeName()) {\n      case CHAR:\n      case VARCHAR:\n        convert =\n            Expressions.call(\n                BuiltInMethod.STRING_TO_TIMESTAMP_WITH_LOCAL_TIME_ZONE.method,\n                operand);\n        break;\n      case DATE:\n        convert = Expressions.call(\n            BuiltInMethod.TIMESTAMP_STRING_TO_TIMESTAMP_WITH_LOCAL_TIME_ZONE.method,\n            RexImpTable.optimize2(\n                operand,\n                Expressions.call(\n                    BuiltInMethod.UNIX_TIMESTAMP_TO_STRING.method,\n                    Expressions.multiply(\n                        Expressions.convert_(operand, long.class),\n                        Expressions.constant(DateTimeUtils.MILLIS_PER_DAY)))),\n            Expressions.call(BuiltInMethod.TIME_ZONE.method, root));\n        break;\n      case TIME:\n        convert = Expressions.call(\n            BuiltInMethod.TIMESTAMP_STRING_TO_TIMESTAMP_WITH_LOCAL_TIME_ZONE.method,\n            RexImpTable.optimize2(\n                operand,\n                Expressions.call(\n                    BuiltInMethod.UNIX_TIMESTAMP_TO_STRING.method,\n                    Expressions.add(\n                        Expressions.multiply(\n                            Expressions.convert_(\n                                Expressions.call(BuiltInMethod.CURRENT_DATE.method, root),\n                                long.class),\n                            Expressions.constant(DateTimeUtils.MILLIS_PER_DAY)),\n                        Expressions.convert_(operand, long.class)))),\n            Expressions.call(BuiltInMethod.TIME_ZONE.method, root));\n        break;\n      case TIME_WITH_LOCAL_TIME_ZONE:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.TIME_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP_WITH_LOCAL_TIME_ZONE.method,\n                Expressions.call(\n                    BuiltInMethod.UNIX_DATE_TO_STRING.method,\n                    Expressions.call(BuiltInMethod.CURRENT_DATE.method, root)),\n                operand));\n        break;\n      case TIMESTAMP:\n        convert = Expressions.call(\n            BuiltInMethod.TIMESTAMP_STRING_TO_TIMESTAMP_WITH_LOCAL_TIME_ZONE.method,\n            RexImpTable.optimize2(\n                operand,\n                Expressions.call(\n                    BuiltInMethod.UNIX_TIMESTAMP_TO_STRING.method,\n                    operand)),\n            Expressions.call(BuiltInMethod.TIME_ZONE.method, root));\n        break;\n      default:\n        break;\n      }\n      break;\n    case BOOLEAN:\n      switch (sourceType.getSqlTypeName()) {\n      case CHAR:\n      case VARCHAR:\n        convert = Expressions.call(\n            BuiltInMethod.STRING_TO_BOOLEAN.method,\n            operand);\n        break;\n      default:\n        break;\n      }\n      break;\n    case CHAR:\n    case VARCHAR:\n      final SqlIntervalQualifier interval =\n          sourceType.getIntervalQualifier();\n      switch (sourceType.getSqlTypeName()) {\n      case DATE:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.UNIX_DATE_TO_STRING.method,\n                operand));\n        break;\n      case TIME:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.UNIX_TIME_TO_STRING.method,\n                operand));\n        break;\n      case TIME_WITH_LOCAL_TIME_ZONE:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.TIME_WITH_LOCAL_TIME_ZONE_TO_STRING.method,\n                operand,\n                Expressions.call(BuiltInMethod.TIME_ZONE.method, root)));\n        break;\n      case TIMESTAMP:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.UNIX_TIMESTAMP_TO_STRING.method,\n                operand));\n        break;\n      case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_STRING.method,\n                operand,\n                Expressions.call(BuiltInMethod.TIME_ZONE.method, root)));\n        break;\n      case INTERVAL_YEAR:\n      case INTERVAL_YEAR_MONTH:\n      case INTERVAL_MONTH:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.INTERVAL_YEAR_MONTH_TO_STRING.method,\n                operand,\n                Expressions.constant(interval.timeUnitRange)));\n        break;\n      case INTERVAL_DAY:\n      case INTERVAL_DAY_HOUR:\n      case INTERVAL_DAY_MINUTE:\n      case INTERVAL_DAY_SECOND:\n      case INTERVAL_HOUR:\n      case INTERVAL_HOUR_MINUTE:\n      case INTERVAL_HOUR_SECOND:\n      case INTERVAL_MINUTE:\n      case INTERVAL_MINUTE_SECOND:\n      case INTERVAL_SECOND:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.INTERVAL_DAY_TIME_TO_STRING.method,\n                operand,\n                Expressions.constant(interval.timeUnitRange),\n                Expressions.constant(\n                    interval.getFractionalSecondPrecision(\n                        typeFactory.getTypeSystem()))));\n        break;\n      case BOOLEAN:\n        convert = RexImpTable.optimize2(\n            operand,\n            Expressions.call(\n                BuiltInMethod.BOOLEAN_TO_STRING.method,\n                operand));\n        break;\n      default:\n        break;\n      }\n      break;\n    default:\n      break;\n    }\n    if (convert == null) {\n      convert = EnumUtils.convert(operand, typeFactory.getJavaClass(targetType));\n    }\n    \r\n    \r\n    boolean pad = false;\n    boolean truncate = true;\n    switch (targetType.getSqlTypeName()) {\n    case CHAR:\n    case BINARY:\n      pad = true;\n      \r\n    case VARCHAR:\n    case VARBINARY:\n      final int targetPrecision = targetType.getPrecision();\n      if (targetPrecision >= 0) {\n        switch (sourceType.getSqlTypeName()) {\n        case CHAR:\n        case VARCHAR:\n        case BINARY:\n        case VARBINARY:\n          \r\n          final int sourcePrecision = sourceType.getPrecision();\n          if (SqlTypeUtil.comparePrecision(sourcePrecision, targetPrecision)\n              <= 0) {\n            truncate = false;\n          }\n          \r\n          if (SqlTypeUtil.comparePrecision(sourcePrecision, targetPrecision)\n              >= 0) {\n            pad = false;\n          }\n          \r\n        default:\n          if (truncate || pad) {\n            convert =\n                Expressions.call(\n                    pad\n                        ? BuiltInMethod.TRUNCATE_OR_PAD.method\n                        : BuiltInMethod.TRUNCATE.method,\n                    convert,\n                    Expressions.constant(targetPrecision));\n          }\n        }\n      }\n      break;\n    case TIMESTAMP:\n      int targetScale = targetType.getScale();\n      if (targetScale == RelDataType.SCALE_NOT_SPECIFIED) {\n        targetScale = 0;\n      }\n      if (targetScale < sourceType.getScale()) {\n        convert =\n            Expressions.call(\n                BuiltInMethod.ROUND_LONG.method,\n                convert,\n                Expressions.constant(\n                    (long) Math.pow(10, 3 - targetScale)));\n      }\n      break;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      switch (sourceType.getSqlTypeName().getFamily()) {\n      case NUMERIC:\n        final BigDecimal multiplier = targetType.getSqlTypeName().getEndUnit().multiplier;\n        final BigDecimal divider = BigDecimal.ONE;\n        convert = RexImpTable.multiplyDivide(convert, multiplier, divider);\n        break;\n      default:\n        break;\n      }\n      break;\n    default:\n      break;\n    }\n    return scaleIntervalToNumber(sourceType, targetType, convert);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/RexToLixTranslator.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":252,"status":"M"},{"authorDate":"2020-05-29 00:04:40","commitOrder":15,"curCode":"  private @Nullable Expression translateCastToTime(RelDataType sourceType, Expression operand) {\n    Expression convert = null;\n    switch (sourceType.getSqlTypeName()) {\n    case CHAR:\n    case VARCHAR:\n      convert =\n          Expressions.call(BuiltInMethod.STRING_TO_TIME.method, operand);\n      break;\n    case TIME_WITH_LOCAL_TIME_ZONE:\n      convert = RexImpTable.optimize2(\n          operand,\n          Expressions.call(\n              BuiltInMethod.TIME_WITH_LOCAL_TIME_ZONE_TO_TIME.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, root)));\n      break;\n    case TIMESTAMP:\n      convert = Expressions.convert_(\n          Expressions.call(\n              BuiltInMethod.FLOOR_MOD.method,\n              operand,\n              Expressions.constant(DateTimeUtils.MILLIS_PER_DAY)),\n          int.class);\n      break;\n    case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n      convert = RexImpTable.optimize2(\n          operand,\n          Expressions.call(\n              BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIME.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, root)));\n      break;\n    default:\n      break;\n    }\n    return convert;\n  }\n","date":"2020-11-30 06:45:33","endLine":636,"groupId":"102152","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"translateCastToTime","params":"(RelDataTypesourceType@Expressionoperand)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/ee/78362efd5815b5334cc4d1ed7a5d472c53f7e0.src","preCode":"  private Expression translateCastToTime(RelDataType sourceType, Expression operand) {\n    Expression convert = null;\n    switch (sourceType.getSqlTypeName()) {\n    case CHAR:\n    case VARCHAR:\n      convert =\n          Expressions.call(BuiltInMethod.STRING_TO_TIME.method, operand);\n      break;\n    case TIME_WITH_LOCAL_TIME_ZONE:\n      convert = RexImpTable.optimize2(\n          operand,\n          Expressions.call(\n              BuiltInMethod.TIME_WITH_LOCAL_TIME_ZONE_TO_TIME.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, root)));\n      break;\n    case TIMESTAMP:\n      convert = Expressions.convert_(\n          Expressions.call(\n              BuiltInMethod.FLOOR_MOD.method,\n              operand,\n              Expressions.constant(DateTimeUtils.MILLIS_PER_DAY)),\n          int.class);\n      break;\n    case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n      convert = RexImpTable.optimize2(\n          operand,\n          Expressions.call(\n              BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIME.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, root)));\n      break;\n    default:\n      break;\n    }\n    return convert;\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/RexToLixTranslator.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":600,"status":"M"}],"commitId":"d9a81b88ad561e7e4cedae93e805e0d7a53a7f1a","commitMessage":"@@@[CALCITE-4199] Add nullability annotations\n\nThe commit includes javadoc updates and refactorings made by Julian Hyde in https://github.com/apache/calcite/pull/2278\n","date":"2020-11-30 06:45:33","modifiedFileCount":"1012","status":"M","submitter":"Vladimir Sitnikov"}]
