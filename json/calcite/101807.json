[{"authorTime":"2016-06-28 14:57:41","codes":[{"authorDate":"2016-06-28 14:57:41","commitOrder":8,"curCode":"  public RexNode makeCast(\n      RelDataType type,\n      RexNode exp,\n      boolean matchNullability) {\n    final SqlTypeName sqlType = type.getSqlTypeName();\n    if (exp instanceof RexLiteral) {\n      RexLiteral literal = (RexLiteral) exp;\n      Comparable value = literal.getValue();\n      SqlTypeName typeName = literal.getTypeName();\n      if (canRemoveCastFromLiteral(type, value, typeName)) {\n        switch (typeName) {\n        case TIMESTAMP:\n        case TIME:\n          assert value instanceof Calendar;\n          final Calendar calendar = (Calendar) value;\n          int scale = type.getScale();\n          if (scale == RelDataType.SCALE_NOT_SPECIFIED) {\n            scale = 0;\n          }\n          calendar.setTimeInMillis(\n              SqlFunctions.round(\n                  calendar.getTimeInMillis(),\n                  DateTimeUtils.powerX(10, 3 - scale)));\n          break;\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          assert value instanceof BigDecimal;\n          typeName = type.getSqlTypeName();\n          switch (typeName) {\n          case BIGINT:\n          case INTEGER:\n          case SMALLINT:\n          case TINYINT:\n          case FLOAT:\n          case REAL:\n          case DECIMAL:\n            BigDecimal value2 = (BigDecimal) value;\n            final BigDecimal multiplier =\n                baseUnit(literal.getTypeName()).multiplier;\n            final BigDecimal divider =\n                literal.getTypeName().getEndUnit().multiplier;\n            value = value2.multiply(multiplier)\n                .divide(divider, 0, BigDecimal.ROUND_HALF_DOWN);\n          }\n\n          \r\n          switch (typeName) {\n          case INTEGER:\n            typeName = SqlTypeName.BIGINT;\n          }\n        }\n        final RexLiteral literal2 =\n            makeLiteral(value, type, typeName);\n        if (type.isNullable()\n            && !literal2.getType().isNullable()\n            && matchNullability) {\n          return makeAbstractCast(type, literal2);\n        }\n        return literal2;\n      }\n    } else if (SqlTypeUtil.isExactNumeric(type)\n        && SqlTypeUtil.isInterval(exp.getType())) {\n      return makeCastIntervalToExact(type, exp);\n    } else if (sqlType == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(exp.getType())) {\n      return makeCastExactToBoolean(type, exp);\n    } else if (exp.getType().getSqlTypeName() == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(type)) {\n      return makeCastBooleanToExact(type, exp);\n    }\n    return makeAbstractCast(type, exp);\n  }\n","date":"2016-07-02 02:11:10","endLine":567,"groupId":"5948","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"makeCast","params":"(RelDataTypetype@RexNodeexp@booleanmatchNullability)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/a0/62ba5d583a9a81fb63556a3bf78a529dcddddb.src","preCode":"  public RexNode makeCast(\n      RelDataType type,\n      RexNode exp,\n      boolean matchNullability) {\n    final SqlTypeName sqlType = type.getSqlTypeName();\n    if (exp instanceof RexLiteral) {\n      RexLiteral literal = (RexLiteral) exp;\n      Comparable value = literal.getValue();\n      SqlTypeName typeName = literal.getTypeName();\n      if (canRemoveCastFromLiteral(type, value, typeName)) {\n        switch (typeName) {\n        case TIMESTAMP:\n        case TIME:\n          assert value instanceof Calendar;\n          final Calendar calendar = (Calendar) value;\n          int scale = type.getScale();\n          if (scale == RelDataType.SCALE_NOT_SPECIFIED) {\n            scale = 0;\n          }\n          calendar.setTimeInMillis(\n              SqlFunctions.round(\n                  calendar.getTimeInMillis(),\n                  DateTimeUtils.powerX(10, 3 - scale)));\n          break;\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          assert value instanceof BigDecimal;\n          typeName = type.getSqlTypeName();\n          switch (typeName) {\n          case BIGINT:\n          case INTEGER:\n          case SMALLINT:\n          case TINYINT:\n          case FLOAT:\n          case REAL:\n          case DECIMAL:\n            BigDecimal value2 = (BigDecimal) value;\n            final BigDecimal multiplier =\n                baseUnit(literal.getTypeName()).multiplier;\n            final BigDecimal divider =\n                literal.getTypeName().getEndUnit().multiplier;\n            value = value2.multiply(multiplier)\n                .divide(divider, 0, BigDecimal.ROUND_HALF_DOWN);\n          }\n\n          \r\n          switch (typeName) {\n          case INTEGER:\n            typeName = SqlTypeName.BIGINT;\n          }\n        }\n        final RexLiteral literal2 =\n            makeLiteral(value, type, typeName);\n        if (type.isNullable()\n            && !literal2.getType().isNullable()\n            && matchNullability) {\n          return makeAbstractCast(type, literal2);\n        }\n        return literal2;\n      }\n    } else if (SqlTypeUtil.isExactNumeric(type)\n        && SqlTypeUtil.isInterval(exp.getType())) {\n      return makeCastIntervalToExact(type, exp);\n    } else if (sqlType == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(exp.getType())) {\n      return makeCastExactToBoolean(type, exp);\n    } else if (exp.getType().getSqlTypeName() == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(type)) {\n      return makeCastBooleanToExact(type, exp);\n    }\n    return makeAbstractCast(type, exp);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rex/RexBuilder.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":488,"status":"MB"},{"authorDate":"2016-06-28 14:57:41","commitOrder":8,"curCode":"  public int getMinPrecision() {\n    switch (this) {\n    case DECIMAL:\n    case VARCHAR:\n    case CHAR:\n    case VARBINARY:\n    case BINARY:\n    case TIME:\n    case TIMESTAMP:\n      return 1;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      return MIN_INTERVAL_START_PRECISION;\n    default:\n      return -1;\n    }\n  }\n","date":"2016-07-02 02:11:10","endLine":759,"groupId":"4949","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getMinPrecision","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/f5/5f9b929bd2862fb7fe2f15538b744383be5f0c.src","preCode":"  public int getMinPrecision() {\n    switch (this) {\n    case DECIMAL:\n    case VARCHAR:\n    case CHAR:\n    case VARBINARY:\n    case BINARY:\n    case TIME:\n    case TIMESTAMP:\n      return 1;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      return MIN_INTERVAL_START_PRECISION;\n    default:\n      return -1;\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/type/SqlTypeName.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":732,"status":"B"}],"commitId":"ac9c8c7af020a0532e3e7e31b4216f69d9f0b39f","commitMessage":"@@@[CALCITE-1302] Create SqlTypeName values for each interval range.  e.g. YEAR_MONTH\n\nAs a result.  we don't need to use SqlIntervalQualifier as often. Also. \nthe JDBC client gets more information from the type.\n\nChange the CalciteAssert.checkResultCount API.\n","date":"2016-07-02 02:11:10","modifiedFileCount":"26","status":"M","submitter":"Julian Hyde"},{"authorTime":"2016-06-28 14:57:41","codes":[{"authorDate":"2017-01-25 03:49:40","commitOrder":9,"curCode":"  public RexNode makeCast(\n      RelDataType type,\n      RexNode exp,\n      boolean matchNullability) {\n    final SqlTypeName sqlType = type.getSqlTypeName();\n    if (exp instanceof RexLiteral) {\n      RexLiteral literal = (RexLiteral) exp;\n      Comparable value = literal.getValue();\n      SqlTypeName typeName = literal.getTypeName();\n      if (canRemoveCastFromLiteral(type, value, typeName)) {\n        switch (typeName) {\n        case TIMESTAMP:\n        case TIME:\n          assert value instanceof Calendar;\n          final Calendar calendar = (Calendar) value;\n          int scale = type.getScale();\n          if (scale == RelDataType.SCALE_NOT_SPECIFIED) {\n            scale = 0;\n          }\n          calendar.setTimeInMillis(\n              SqlFunctions.round(\n                  calendar.getTimeInMillis(),\n                  DateTimeUtils.powerX(10, 3 - scale)));\n          break;\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          assert value instanceof BigDecimal;\n          typeName = type.getSqlTypeName();\n          switch (typeName) {\n          case BIGINT:\n          case INTEGER:\n          case SMALLINT:\n          case TINYINT:\n          case FLOAT:\n          case REAL:\n          case DECIMAL:\n            BigDecimal value2 = (BigDecimal) value;\n            final BigDecimal multiplier =\n                baseUnit(literal.getTypeName()).multiplier;\n            final BigDecimal divider =\n                literal.getTypeName().getEndUnit().multiplier;\n            value = value2.multiply(multiplier)\n                .divide(divider, 0, RoundingMode.HALF_DOWN);\n          }\n\n          \r\n          switch (typeName) {\n          case INTEGER:\n            typeName = SqlTypeName.BIGINT;\n          }\n        }\n        final RexLiteral literal2 =\n            makeLiteral(value, type, typeName);\n        if (type.isNullable()\n            && !literal2.getType().isNullable()\n            && matchNullability) {\n          return makeAbstractCast(type, literal2);\n        }\n        return literal2;\n      }\n    } else if (SqlTypeUtil.isExactNumeric(type)\n        && SqlTypeUtil.isInterval(exp.getType())) {\n      return makeCastIntervalToExact(type, exp);\n    } else if (sqlType == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(exp.getType())) {\n      return makeCastExactToBoolean(type, exp);\n    } else if (exp.getType().getSqlTypeName() == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(type)) {\n      return makeCastBooleanToExact(type, exp);\n    }\n    return makeAbstractCast(type, exp);\n  }\n","date":"2017-01-26 03:21:36","endLine":569,"groupId":"5948","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"makeCast","params":"(RelDataTypetype@RexNodeexp@booleanmatchNullability)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/b6/ef39624b86f99205aec2b69c1c54182f6642fd.src","preCode":"  public RexNode makeCast(\n      RelDataType type,\n      RexNode exp,\n      boolean matchNullability) {\n    final SqlTypeName sqlType = type.getSqlTypeName();\n    if (exp instanceof RexLiteral) {\n      RexLiteral literal = (RexLiteral) exp;\n      Comparable value = literal.getValue();\n      SqlTypeName typeName = literal.getTypeName();\n      if (canRemoveCastFromLiteral(type, value, typeName)) {\n        switch (typeName) {\n        case TIMESTAMP:\n        case TIME:\n          assert value instanceof Calendar;\n          final Calendar calendar = (Calendar) value;\n          int scale = type.getScale();\n          if (scale == RelDataType.SCALE_NOT_SPECIFIED) {\n            scale = 0;\n          }\n          calendar.setTimeInMillis(\n              SqlFunctions.round(\n                  calendar.getTimeInMillis(),\n                  DateTimeUtils.powerX(10, 3 - scale)));\n          break;\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          assert value instanceof BigDecimal;\n          typeName = type.getSqlTypeName();\n          switch (typeName) {\n          case BIGINT:\n          case INTEGER:\n          case SMALLINT:\n          case TINYINT:\n          case FLOAT:\n          case REAL:\n          case DECIMAL:\n            BigDecimal value2 = (BigDecimal) value;\n            final BigDecimal multiplier =\n                baseUnit(literal.getTypeName()).multiplier;\n            final BigDecimal divider =\n                literal.getTypeName().getEndUnit().multiplier;\n            value = value2.multiply(multiplier)\n                .divide(divider, 0, BigDecimal.ROUND_HALF_DOWN);\n          }\n\n          \r\n          switch (typeName) {\n          case INTEGER:\n            typeName = SqlTypeName.BIGINT;\n          }\n        }\n        final RexLiteral literal2 =\n            makeLiteral(value, type, typeName);\n        if (type.isNullable()\n            && !literal2.getType().isNullable()\n            && matchNullability) {\n          return makeAbstractCast(type, literal2);\n        }\n        return literal2;\n      }\n    } else if (SqlTypeUtil.isExactNumeric(type)\n        && SqlTypeUtil.isInterval(exp.getType())) {\n      return makeCastIntervalToExact(type, exp);\n    } else if (sqlType == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(exp.getType())) {\n      return makeCastExactToBoolean(type, exp);\n    } else if (exp.getType().getSqlTypeName() == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(type)) {\n      return makeCastBooleanToExact(type, exp);\n    }\n    return makeAbstractCast(type, exp);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rex/RexBuilder.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":490,"status":"M"},{"authorDate":"2016-06-28 14:57:41","commitOrder":9,"curCode":"  public int getMinPrecision() {\n    switch (this) {\n    case DECIMAL:\n    case VARCHAR:\n    case CHAR:\n    case VARBINARY:\n    case BINARY:\n    case TIME:\n    case TIMESTAMP:\n      return 1;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      return MIN_INTERVAL_START_PRECISION;\n    default:\n      return -1;\n    }\n  }\n","date":"2016-07-02 02:11:10","endLine":759,"groupId":"4949","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getMinPrecision","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/f5/5f9b929bd2862fb7fe2f15538b744383be5f0c.src","preCode":"  public int getMinPrecision() {\n    switch (this) {\n    case DECIMAL:\n    case VARCHAR:\n    case CHAR:\n    case VARBINARY:\n    case BINARY:\n    case TIME:\n    case TIMESTAMP:\n      return 1;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      return MIN_INTERVAL_START_PRECISION;\n    default:\n      return -1;\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/type/SqlTypeName.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":732,"status":"N"}],"commitId":"5181563f9f26d1533a7d98ecca8443077e7b7efa","commitMessage":"@@@[CALCITE-1602] Remove uses of deprecated APIs\n","date":"2017-01-26 03:21:36","modifiedFileCount":"69","status":"M","submitter":"Julian Hyde"},{"authorTime":"2016-06-28 14:57:41","codes":[{"authorDate":"2017-02-26 20:07:06","commitOrder":10,"curCode":"  public RexNode makeCast(\n      RelDataType type,\n      RexNode exp,\n      boolean matchNullability) {\n    final SqlTypeName sqlType = type.getSqlTypeName();\n    if (exp instanceof RexLiteral) {\n      RexLiteral literal = (RexLiteral) exp;\n      Comparable value = literal.getValue();\n      SqlTypeName typeName = literal.getTypeName();\n      if (canRemoveCastFromLiteral(type, value, typeName)) {\n        switch (typeName) {\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          assert value instanceof BigDecimal;\n          typeName = type.getSqlTypeName();\n          switch (typeName) {\n          case BIGINT:\n          case INTEGER:\n          case SMALLINT:\n          case TINYINT:\n          case FLOAT:\n          case REAL:\n          case DECIMAL:\n            BigDecimal value2 = (BigDecimal) value;\n            final BigDecimal multiplier =\n                baseUnit(literal.getTypeName()).multiplier;\n            final BigDecimal divider =\n                literal.getTypeName().getEndUnit().multiplier;\n            value = value2.multiply(multiplier)\n                .divide(divider, 0, RoundingMode.HALF_DOWN);\n          }\n\n          \r\n          switch (typeName) {\n          case INTEGER:\n            typeName = SqlTypeName.BIGINT;\n          }\n        }\n        final RexLiteral literal2 =\n            makeLiteral(value, type, typeName);\n        if (type.isNullable()\n            && !literal2.getType().isNullable()\n            && matchNullability) {\n          return makeAbstractCast(type, literal2);\n        }\n        return literal2;\n      }\n    } else if (SqlTypeUtil.isExactNumeric(type)\n        && SqlTypeUtil.isInterval(exp.getType())) {\n      return makeCastIntervalToExact(type, exp);\n    } else if (sqlType == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(exp.getType())) {\n      return makeCastExactToBoolean(type, exp);\n    } else if (exp.getType().getSqlTypeName() == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(type)) {\n      return makeCastBooleanToExact(type, exp);\n    }\n    return makeAbstractCast(type, exp);\n  }\n","date":"2017-02-28 03:36:36","endLine":571,"groupId":"5948","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"makeCast","params":"(RelDataTypetype@RexNodeexp@booleanmatchNullability)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/3e/34ec9dfa9c09623c00e2349af00e9a8e648dc0.src","preCode":"  public RexNode makeCast(\n      RelDataType type,\n      RexNode exp,\n      boolean matchNullability) {\n    final SqlTypeName sqlType = type.getSqlTypeName();\n    if (exp instanceof RexLiteral) {\n      RexLiteral literal = (RexLiteral) exp;\n      Comparable value = literal.getValue();\n      SqlTypeName typeName = literal.getTypeName();\n      if (canRemoveCastFromLiteral(type, value, typeName)) {\n        switch (typeName) {\n        case TIMESTAMP:\n        case TIME:\n          assert value instanceof Calendar;\n          final Calendar calendar = (Calendar) value;\n          int scale = type.getScale();\n          if (scale == RelDataType.SCALE_NOT_SPECIFIED) {\n            scale = 0;\n          }\n          calendar.setTimeInMillis(\n              SqlFunctions.round(\n                  calendar.getTimeInMillis(),\n                  DateTimeUtils.powerX(10, 3 - scale)));\n          break;\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          assert value instanceof BigDecimal;\n          typeName = type.getSqlTypeName();\n          switch (typeName) {\n          case BIGINT:\n          case INTEGER:\n          case SMALLINT:\n          case TINYINT:\n          case FLOAT:\n          case REAL:\n          case DECIMAL:\n            BigDecimal value2 = (BigDecimal) value;\n            final BigDecimal multiplier =\n                baseUnit(literal.getTypeName()).multiplier;\n            final BigDecimal divider =\n                literal.getTypeName().getEndUnit().multiplier;\n            value = value2.multiply(multiplier)\n                .divide(divider, 0, RoundingMode.HALF_DOWN);\n          }\n\n          \r\n          switch (typeName) {\n          case INTEGER:\n            typeName = SqlTypeName.BIGINT;\n          }\n        }\n        final RexLiteral literal2 =\n            makeLiteral(value, type, typeName);\n        if (type.isNullable()\n            && !literal2.getType().isNullable()\n            && matchNullability) {\n          return makeAbstractCast(type, literal2);\n        }\n        return literal2;\n      }\n    } else if (SqlTypeUtil.isExactNumeric(type)\n        && SqlTypeUtil.isInterval(exp.getType())) {\n      return makeCastIntervalToExact(type, exp);\n    } else if (sqlType == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(exp.getType())) {\n      return makeCastExactToBoolean(type, exp);\n    } else if (exp.getType().getSqlTypeName() == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(type)) {\n      return makeCastBooleanToExact(type, exp);\n    }\n    return makeAbstractCast(type, exp);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rex/RexBuilder.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":505,"status":"M"},{"authorDate":"2016-06-28 14:57:41","commitOrder":10,"curCode":"  public int getMinPrecision() {\n    switch (this) {\n    case DECIMAL:\n    case VARCHAR:\n    case CHAR:\n    case VARBINARY:\n    case BINARY:\n    case TIME:\n    case TIMESTAMP:\n      return 1;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      return MIN_INTERVAL_START_PRECISION;\n    default:\n      return -1;\n    }\n  }\n","date":"2016-07-02 02:11:10","endLine":759,"groupId":"4949","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"getMinPrecision","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/f5/5f9b929bd2862fb7fe2f15538b744383be5f0c.src","preCode":"  public int getMinPrecision() {\n    switch (this) {\n    case DECIMAL:\n    case VARCHAR:\n    case CHAR:\n    case VARBINARY:\n    case BINARY:\n    case TIME:\n    case TIMESTAMP:\n      return 1;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      return MIN_INTERVAL_START_PRECISION;\n    default:\n      return -1;\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/type/SqlTypeName.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":732,"status":"N"}],"commitId":"bb6ae0acf76d7890d545b64c29b0d0d60ed43190","commitMessage":"@@@[CALCITE-1659] Simplifying CAST('YYYY-MM-DD hh:mm:ss.SSS' as TIMESTAMP) should round the sub-second fraction (Remus Rusanu)\n\nPreviously the code incorrectly used the type's scale; now it uses the type's precision.\n\nMake ZonelessTimestamp digest contain relevant sub-second fraction.\n\nClose apache/calcite#384\n","date":"2017-02-28 03:36:36","modifiedFileCount":"2","status":"M","submitter":"Remus Rusanu"},{"authorTime":"2016-06-28 14:57:41","codes":[{"authorDate":"2017-05-02 12:53:12","commitOrder":11,"curCode":"  public RexNode makeCast(\n      RelDataType type,\n      RexNode exp,\n      boolean matchNullability) {\n    final SqlTypeName sqlType = type.getSqlTypeName();\n    if (exp instanceof RexLiteral) {\n      RexLiteral literal = (RexLiteral) exp;\n      Comparable value = literal.getValueAs(Comparable.class);\n      SqlTypeName typeName = literal.getTypeName();\n      if (canRemoveCastFromLiteral(type, value, typeName)) {\n        switch (typeName) {\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          assert value instanceof BigDecimal;\n          typeName = type.getSqlTypeName();\n          switch (typeName) {\n          case BIGINT:\n          case INTEGER:\n          case SMALLINT:\n          case TINYINT:\n          case FLOAT:\n          case REAL:\n          case DECIMAL:\n            BigDecimal value2 = (BigDecimal) value;\n            final BigDecimal multiplier =\n                baseUnit(literal.getTypeName()).multiplier;\n            final BigDecimal divider =\n                literal.getTypeName().getEndUnit().multiplier;\n            value = value2.multiply(multiplier)\n                .divide(divider, 0, RoundingMode.HALF_DOWN);\n          }\n\n          \r\n          switch (typeName) {\n          case INTEGER:\n            typeName = SqlTypeName.BIGINT;\n          }\n        }\n        final RexLiteral literal2 =\n            makeLiteral(value, type, typeName);\n        if (type.isNullable()\n            && !literal2.getType().isNullable()\n            && matchNullability) {\n          return makeAbstractCast(type, literal2);\n        }\n        return literal2;\n      }\n    } else if (SqlTypeUtil.isExactNumeric(type)\n        && SqlTypeUtil.isInterval(exp.getType())) {\n      return makeCastIntervalToExact(type, exp);\n    } else if (sqlType == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(exp.getType())) {\n      return makeCastExactToBoolean(type, exp);\n    } else if (exp.getType().getSqlTypeName() == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(type)) {\n      return makeCastBooleanToExact(type, exp);\n    }\n    return makeAbstractCast(type, exp);\n  }\n","date":"2017-05-31 23:17:28","endLine":561,"groupId":"5948","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"makeCast","params":"(RelDataTypetype@RexNodeexp@booleanmatchNullability)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/ad/f7fee5c709ebbc671fd0658ad74a14964d9163.src","preCode":"  public RexNode makeCast(\n      RelDataType type,\n      RexNode exp,\n      boolean matchNullability) {\n    final SqlTypeName sqlType = type.getSqlTypeName();\n    if (exp instanceof RexLiteral) {\n      RexLiteral literal = (RexLiteral) exp;\n      Comparable value = literal.getValue();\n      SqlTypeName typeName = literal.getTypeName();\n      if (canRemoveCastFromLiteral(type, value, typeName)) {\n        switch (typeName) {\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          assert value instanceof BigDecimal;\n          typeName = type.getSqlTypeName();\n          switch (typeName) {\n          case BIGINT:\n          case INTEGER:\n          case SMALLINT:\n          case TINYINT:\n          case FLOAT:\n          case REAL:\n          case DECIMAL:\n            BigDecimal value2 = (BigDecimal) value;\n            final BigDecimal multiplier =\n                baseUnit(literal.getTypeName()).multiplier;\n            final BigDecimal divider =\n                literal.getTypeName().getEndUnit().multiplier;\n            value = value2.multiply(multiplier)\n                .divide(divider, 0, RoundingMode.HALF_DOWN);\n          }\n\n          \r\n          switch (typeName) {\n          case INTEGER:\n            typeName = SqlTypeName.BIGINT;\n          }\n        }\n        final RexLiteral literal2 =\n            makeLiteral(value, type, typeName);\n        if (type.isNullable()\n            && !literal2.getType().isNullable()\n            && matchNullability) {\n          return makeAbstractCast(type, literal2);\n        }\n        return literal2;\n      }\n    } else if (SqlTypeUtil.isExactNumeric(type)\n        && SqlTypeUtil.isInterval(exp.getType())) {\n      return makeCastIntervalToExact(type, exp);\n    } else if (sqlType == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(exp.getType())) {\n      return makeCastExactToBoolean(type, exp);\n    } else if (exp.getType().getSqlTypeName() == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(type)) {\n      return makeCastBooleanToExact(type, exp);\n    }\n    return makeAbstractCast(type, exp);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rex/RexBuilder.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":495,"status":"M"},{"authorDate":"2016-06-28 14:57:41","commitOrder":11,"curCode":"  public int getMinPrecision() {\n    switch (this) {\n    case DECIMAL:\n    case VARCHAR:\n    case CHAR:\n    case VARBINARY:\n    case BINARY:\n    case TIME:\n    case TIMESTAMP:\n      return 1;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      return MIN_INTERVAL_START_PRECISION;\n    default:\n      return -1;\n    }\n  }\n","date":"2016-07-02 02:11:10","endLine":759,"groupId":"4949","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"getMinPrecision","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/f5/5f9b929bd2862fb7fe2f15538b744383be5f0c.src","preCode":"  public int getMinPrecision() {\n    switch (this) {\n    case DECIMAL:\n    case VARCHAR:\n    case CHAR:\n    case VARBINARY:\n    case BINARY:\n    case TIME:\n    case TIMESTAMP:\n      return 1;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      return MIN_INTERVAL_START_PRECISION;\n    default:\n      return -1;\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/type/SqlTypeName.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":732,"status":"N"}],"commitId":"205af8134857ba312415b9a5b4a48020fe0ce888","commitMessage":"@@@[CALCITE-1690] Calcite timestamp literals cannot express precision above millisecond.  TIMESTAMP(3)\n","date":"2017-05-31 23:17:28","modifiedFileCount":"34","status":"M","submitter":"Julian Hyde"},{"authorTime":"2017-08-15 08:46:42","codes":[{"authorDate":"2017-05-02 12:53:12","commitOrder":12,"curCode":"  public RexNode makeCast(\n      RelDataType type,\n      RexNode exp,\n      boolean matchNullability) {\n    final SqlTypeName sqlType = type.getSqlTypeName();\n    if (exp instanceof RexLiteral) {\n      RexLiteral literal = (RexLiteral) exp;\n      Comparable value = literal.getValueAs(Comparable.class);\n      SqlTypeName typeName = literal.getTypeName();\n      if (canRemoveCastFromLiteral(type, value, typeName)) {\n        switch (typeName) {\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          assert value instanceof BigDecimal;\n          typeName = type.getSqlTypeName();\n          switch (typeName) {\n          case BIGINT:\n          case INTEGER:\n          case SMALLINT:\n          case TINYINT:\n          case FLOAT:\n          case REAL:\n          case DECIMAL:\n            BigDecimal value2 = (BigDecimal) value;\n            final BigDecimal multiplier =\n                baseUnit(literal.getTypeName()).multiplier;\n            final BigDecimal divider =\n                literal.getTypeName().getEndUnit().multiplier;\n            value = value2.multiply(multiplier)\n                .divide(divider, 0, RoundingMode.HALF_DOWN);\n          }\n\n          \r\n          switch (typeName) {\n          case INTEGER:\n            typeName = SqlTypeName.BIGINT;\n          }\n        }\n        final RexLiteral literal2 =\n            makeLiteral(value, type, typeName);\n        if (type.isNullable()\n            && !literal2.getType().isNullable()\n            && matchNullability) {\n          return makeAbstractCast(type, literal2);\n        }\n        return literal2;\n      }\n    } else if (SqlTypeUtil.isExactNumeric(type)\n        && SqlTypeUtil.isInterval(exp.getType())) {\n      return makeCastIntervalToExact(type, exp);\n    } else if (sqlType == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(exp.getType())) {\n      return makeCastExactToBoolean(type, exp);\n    } else if (exp.getType().getSqlTypeName() == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(type)) {\n      return makeCastBooleanToExact(type, exp);\n    }\n    return makeAbstractCast(type, exp);\n  }\n","date":"2017-05-31 23:17:28","endLine":561,"groupId":"5948","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"makeCast","params":"(RelDataTypetype@RexNodeexp@booleanmatchNullability)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/ad/f7fee5c709ebbc671fd0658ad74a14964d9163.src","preCode":"  public RexNode makeCast(\n      RelDataType type,\n      RexNode exp,\n      boolean matchNullability) {\n    final SqlTypeName sqlType = type.getSqlTypeName();\n    if (exp instanceof RexLiteral) {\n      RexLiteral literal = (RexLiteral) exp;\n      Comparable value = literal.getValueAs(Comparable.class);\n      SqlTypeName typeName = literal.getTypeName();\n      if (canRemoveCastFromLiteral(type, value, typeName)) {\n        switch (typeName) {\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          assert value instanceof BigDecimal;\n          typeName = type.getSqlTypeName();\n          switch (typeName) {\n          case BIGINT:\n          case INTEGER:\n          case SMALLINT:\n          case TINYINT:\n          case FLOAT:\n          case REAL:\n          case DECIMAL:\n            BigDecimal value2 = (BigDecimal) value;\n            final BigDecimal multiplier =\n                baseUnit(literal.getTypeName()).multiplier;\n            final BigDecimal divider =\n                literal.getTypeName().getEndUnit().multiplier;\n            value = value2.multiply(multiplier)\n                .divide(divider, 0, RoundingMode.HALF_DOWN);\n          }\n\n          \r\n          switch (typeName) {\n          case INTEGER:\n            typeName = SqlTypeName.BIGINT;\n          }\n        }\n        final RexLiteral literal2 =\n            makeLiteral(value, type, typeName);\n        if (type.isNullable()\n            && !literal2.getType().isNullable()\n            && matchNullability) {\n          return makeAbstractCast(type, literal2);\n        }\n        return literal2;\n      }\n    } else if (SqlTypeUtil.isExactNumeric(type)\n        && SqlTypeUtil.isInterval(exp.getType())) {\n      return makeCastIntervalToExact(type, exp);\n    } else if (sqlType == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(exp.getType())) {\n      return makeCastExactToBoolean(type, exp);\n    } else if (exp.getType().getSqlTypeName() == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(type)) {\n      return makeCastBooleanToExact(type, exp);\n    }\n    return makeAbstractCast(type, exp);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rex/RexBuilder.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":495,"status":"N"},{"authorDate":"2017-08-15 08:46:42","commitOrder":12,"curCode":"  public int getMinPrecision() {\n    switch (this) {\n    case DECIMAL:\n    case VARCHAR:\n    case CHAR:\n    case VARBINARY:\n    case BINARY:\n    case TIME:\n    case TIME_WITH_LOCAL_TIME_ZONE:\n    case TIMESTAMP:\n    case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n      return 1;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      return MIN_INTERVAL_START_PRECISION;\n    default:\n      return -1;\n    }\n  }\n","date":"2017-09-06 06:00:36","endLine":769,"groupId":"9088","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"getMinPrecision","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e5/6b9cf1eb25f4fd3aa1d0dd9a6a18613499c17f.src","preCode":"  public int getMinPrecision() {\n    switch (this) {\n    case DECIMAL:\n    case VARCHAR:\n    case CHAR:\n    case VARBINARY:\n    case BINARY:\n    case TIME:\n    case TIMESTAMP:\n      return 1;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      return MIN_INTERVAL_START_PRECISION;\n    default:\n      return -1;\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/type/SqlTypeName.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":740,"status":"M"}],"commitId":"939c9a62b4905d2cfffcb4adaefd76a809aa3520","commitMessage":"@@@[CALCITE-1947] Add time/timestamp with local time zone types to optimizer\n\nClose apache/calcite#519\n","date":"2017-09-06 06:00:36","modifiedFileCount":"34","status":"M","submitter":"Jesus Camacho Rodriguez"},{"authorTime":"2017-08-15 08:46:42","codes":[{"authorDate":"2018-06-13 01:44:48","commitOrder":13,"curCode":"  public RexNode makeCast(\n      RelDataType type,\n      RexNode exp,\n      boolean matchNullability) {\n    final SqlTypeName sqlType = type.getSqlTypeName();\n    if (exp instanceof RexLiteral) {\n      RexLiteral literal = (RexLiteral) exp;\n      Comparable value = literal.getValueAs(Comparable.class);\n      SqlTypeName typeName = literal.getTypeName();\n      if (canRemoveCastFromLiteral(type, value, typeName)) {\n        switch (typeName) {\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          assert value instanceof BigDecimal;\n          typeName = type.getSqlTypeName();\n          switch (typeName) {\n          case BIGINT:\n          case INTEGER:\n          case SMALLINT:\n          case TINYINT:\n          case FLOAT:\n          case REAL:\n          case DECIMAL:\n            BigDecimal value2 = (BigDecimal) value;\n            final BigDecimal multiplier =\n                baseUnit(literal.getTypeName()).multiplier;\n            final BigDecimal divider =\n                literal.getTypeName().getEndUnit().multiplier;\n            value = value2.multiply(multiplier)\n                .divide(divider, 0, RoundingMode.HALF_DOWN);\n          }\n\n          \r\n          switch (typeName) {\n          case INTEGER:\n            typeName = SqlTypeName.BIGINT;\n          }\n        }\n        final RexLiteral literal2 =\n            makeLiteral(value, type, typeName);\n        if (type.isNullable()\n            && !literal2.getType().isNullable()\n            && matchNullability) {\n          return makeAbstractCast(type, literal2);\n        }\n        return literal2;\n      }\n    } else if (SqlTypeUtil.isExactNumeric(type)\n        && SqlTypeUtil.isInterval(exp.getType())) {\n      return makeCastIntervalToExact(type, exp);\n    } else if (sqlType == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(exp.getType())) {\n      return makeCastExactToBoolean(type, exp);\n    } else if (exp.getType().getSqlTypeName() == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(type)) {\n      return makeCastBooleanToExact(type, exp);\n    }\n    return makeAbstractCast(type, exp);\n  }\n","date":"2018-06-29 16:27:43","endLine":564,"groupId":"5948","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"makeCast","params":"(RelDataTypetype@RexNodeexp@booleanmatchNullability)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/5d/cc85b33b8707d14bf69945cfa9530fe1c8a2ec.src","preCode":"  public RexNode makeCast(\n      RelDataType type,\n      RexNode exp,\n      boolean matchNullability) {\n    final SqlTypeName sqlType = type.getSqlTypeName();\n    if (exp instanceof RexLiteral) {\n      RexLiteral literal = (RexLiteral) exp;\n      Comparable value = literal.getValueAs(Comparable.class);\n      SqlTypeName typeName = literal.getTypeName();\n      if (canRemoveCastFromLiteral(type, value, typeName)) {\n        switch (typeName) {\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          assert value instanceof BigDecimal;\n          typeName = type.getSqlTypeName();\n          switch (typeName) {\n          case BIGINT:\n          case INTEGER:\n          case SMALLINT:\n          case TINYINT:\n          case FLOAT:\n          case REAL:\n          case DECIMAL:\n            BigDecimal value2 = (BigDecimal) value;\n            final BigDecimal multiplier =\n                baseUnit(literal.getTypeName()).multiplier;\n            final BigDecimal divider =\n                literal.getTypeName().getEndUnit().multiplier;\n            value = value2.multiply(multiplier)\n                .divide(divider, 0, RoundingMode.HALF_DOWN);\n          }\n\n          \r\n          switch (typeName) {\n          case INTEGER:\n            typeName = SqlTypeName.BIGINT;\n          }\n        }\n        final RexLiteral literal2 =\n            makeLiteral(value, type, typeName);\n        if (type.isNullable()\n            && !literal2.getType().isNullable()\n            && matchNullability) {\n          return makeAbstractCast(type, literal2);\n        }\n        return literal2;\n      }\n    } else if (SqlTypeUtil.isExactNumeric(type)\n        && SqlTypeUtil.isInterval(exp.getType())) {\n      return makeCastIntervalToExact(type, exp);\n    } else if (sqlType == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(exp.getType())) {\n      return makeCastExactToBoolean(type, exp);\n    } else if (exp.getType().getSqlTypeName() == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(type)) {\n      return makeCastBooleanToExact(type, exp);\n    }\n    return makeAbstractCast(type, exp);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rex/RexBuilder.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":495,"status":"M"},{"authorDate":"2017-08-15 08:46:42","commitOrder":13,"curCode":"  public int getMinPrecision() {\n    switch (this) {\n    case DECIMAL:\n    case VARCHAR:\n    case CHAR:\n    case VARBINARY:\n    case BINARY:\n    case TIME:\n    case TIME_WITH_LOCAL_TIME_ZONE:\n    case TIMESTAMP:\n    case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n      return 1;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      return MIN_INTERVAL_START_PRECISION;\n    default:\n      return -1;\n    }\n  }\n","date":"2017-09-06 06:00:36","endLine":769,"groupId":"9088","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"getMinPrecision","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e5/6b9cf1eb25f4fd3aa1d0dd9a6a18613499c17f.src","preCode":"  public int getMinPrecision() {\n    switch (this) {\n    case DECIMAL:\n    case VARCHAR:\n    case CHAR:\n    case VARBINARY:\n    case BINARY:\n    case TIME:\n    case TIME_WITH_LOCAL_TIME_ZONE:\n    case TIMESTAMP:\n    case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n      return 1;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      return MIN_INTERVAL_START_PRECISION;\n    default:\n      return -1;\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/type/SqlTypeName.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":740,"status":"N"}],"commitId":"184bb1857fcb6df63b05410d25bc0078de0f71ab","commitMessage":"@@@[CALCITE-2359] Inconsistent results casting intervals to integers (James Duong)\n\nEnsure casting intervals to integers always returns the result in terms\nof the trailing unit.\n\nPreviously we had the following behavior:\n- Casting a standalone day interval literal returned results in terms of the trailing unit.\n- Casting a standalone year interval literal returned results in terms of months.\n- Casting a day interval expression returned results in terms of milliseconds.\n- Casting a year interval expression returned results in terms of months.\n\nClose apache/calcite#730\n","date":"2018-06-29 16:27:43","modifiedFileCount":"3","status":"M","submitter":"James Duong"},{"authorTime":"2017-08-15 08:46:42","codes":[{"authorDate":"2020-09-30 01:31:14","commitOrder":14,"curCode":"  public RexNode makeCast(\n      RelDataType type,\n      RexNode exp,\n      boolean matchNullability) {\n    final SqlTypeName sqlType = type.getSqlTypeName();\n    if (exp instanceof RexLiteral) {\n      RexLiteral literal = (RexLiteral) exp;\n      Comparable value = literal.getValueAs(Comparable.class);\n      SqlTypeName typeName = literal.getTypeName();\n      if (canRemoveCastFromLiteral(type, value, typeName)) {\n        switch (typeName) {\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          assert value instanceof BigDecimal;\n          typeName = type.getSqlTypeName();\n          switch (typeName) {\n          case BIGINT:\n          case INTEGER:\n          case SMALLINT:\n          case TINYINT:\n          case FLOAT:\n          case REAL:\n          case DECIMAL:\n            BigDecimal value2 = (BigDecimal) value;\n            final BigDecimal multiplier =\n                baseUnit(literal.getTypeName()).multiplier;\n            final BigDecimal divider =\n                literal.getTypeName().getEndUnit().multiplier;\n            value = value2.multiply(multiplier)\n                .divide(divider, 0, RoundingMode.HALF_DOWN);\n            break;\n          default:\n            break;\n          }\n\n          \r\n          switch (typeName) {\n          case INTEGER:\n            typeName = SqlTypeName.BIGINT;\n            break;\n          default:\n            break;\n          }\n          break;\n        default:\n          break;\n        }\n        final RexLiteral literal2 =\n            makeLiteral(value, type, typeName);\n        if (type.isNullable()\n            && !literal2.getType().isNullable()\n            && matchNullability) {\n          return makeAbstractCast(type, literal2);\n        }\n        return literal2;\n      }\n    } else if (SqlTypeUtil.isExactNumeric(type)\n        && SqlTypeUtil.isInterval(exp.getType())) {\n      return makeCastIntervalToExact(type, exp);\n    } else if (sqlType == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(exp.getType())) {\n      return makeCastExactToBoolean(type, exp);\n    } else if (exp.getType().getSqlTypeName() == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(type)) {\n      return makeCastBooleanToExact(type, exp);\n    }\n    return makeAbstractCast(type, exp);\n  }\n","date":"2020-10-07 05:43:06","endLine":620,"groupId":"101807","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"makeCast","params":"(RelDataTypetype@RexNodeexp@booleanmatchNullability)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/f6/ee5bda33c9546221063e3dbd586ce5f4d35247.src","preCode":"  public RexNode makeCast(\n      RelDataType type,\n      RexNode exp,\n      boolean matchNullability) {\n    final SqlTypeName sqlType = type.getSqlTypeName();\n    if (exp instanceof RexLiteral) {\n      RexLiteral literal = (RexLiteral) exp;\n      Comparable value = literal.getValueAs(Comparable.class);\n      SqlTypeName typeName = literal.getTypeName();\n      if (canRemoveCastFromLiteral(type, value, typeName)) {\n        switch (typeName) {\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          assert value instanceof BigDecimal;\n          typeName = type.getSqlTypeName();\n          switch (typeName) {\n          case BIGINT:\n          case INTEGER:\n          case SMALLINT:\n          case TINYINT:\n          case FLOAT:\n          case REAL:\n          case DECIMAL:\n            BigDecimal value2 = (BigDecimal) value;\n            final BigDecimal multiplier =\n                baseUnit(literal.getTypeName()).multiplier;\n            final BigDecimal divider =\n                literal.getTypeName().getEndUnit().multiplier;\n            value = value2.multiply(multiplier)\n                .divide(divider, 0, RoundingMode.HALF_DOWN);\n          }\n\n          \r\n          switch (typeName) {\n          case INTEGER:\n            typeName = SqlTypeName.BIGINT;\n          }\n        }\n        final RexLiteral literal2 =\n            makeLiteral(value, type, typeName);\n        if (type.isNullable()\n            && !literal2.getType().isNullable()\n            && matchNullability) {\n          return makeAbstractCast(type, literal2);\n        }\n        return literal2;\n      }\n    } else if (SqlTypeUtil.isExactNumeric(type)\n        && SqlTypeUtil.isInterval(exp.getType())) {\n      return makeCastIntervalToExact(type, exp);\n    } else if (sqlType == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(exp.getType())) {\n      return makeCastExactToBoolean(type, exp);\n    } else if (exp.getType().getSqlTypeName() == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(type)) {\n      return makeCastBooleanToExact(type, exp);\n    }\n    return makeAbstractCast(type, exp);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rex/RexBuilder.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":542,"status":"M"},{"authorDate":"2017-08-15 08:46:42","commitOrder":14,"curCode":"  public int getMinPrecision() {\n    switch (this) {\n    case DECIMAL:\n    case VARCHAR:\n    case CHAR:\n    case VARBINARY:\n    case BINARY:\n    case TIME:\n    case TIME_WITH_LOCAL_TIME_ZONE:\n    case TIMESTAMP:\n    case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n      return 1;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      return MIN_INTERVAL_START_PRECISION;\n    default:\n      return -1;\n    }\n  }\n","date":"2017-09-06 06:00:36","endLine":769,"groupId":"101807","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"getMinPrecision","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e5/6b9cf1eb25f4fd3aa1d0dd9a6a18613499c17f.src","preCode":"  public int getMinPrecision() {\n    switch (this) {\n    case DECIMAL:\n    case VARCHAR:\n    case CHAR:\n    case VARBINARY:\n    case BINARY:\n    case TIME:\n    case TIME_WITH_LOCAL_TIME_ZONE:\n    case TIMESTAMP:\n    case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n      return 1;\n    case INTERVAL_YEAR:\n    case INTERVAL_YEAR_MONTH:\n    case INTERVAL_MONTH:\n    case INTERVAL_DAY:\n    case INTERVAL_DAY_HOUR:\n    case INTERVAL_DAY_MINUTE:\n    case INTERVAL_DAY_SECOND:\n    case INTERVAL_HOUR:\n    case INTERVAL_HOUR_MINUTE:\n    case INTERVAL_HOUR_SECOND:\n    case INTERVAL_MINUTE:\n    case INTERVAL_MINUTE_SECOND:\n    case INTERVAL_SECOND:\n      return MIN_INTERVAL_START_PRECISION;\n    default:\n      return -1;\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/type/SqlTypeName.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":740,"status":"N"}],"commitId":"1b94f37e888cf2d186362473529e6c147afe0f6e","commitMessage":"@@@[CALCITE-4314] Add missing default branches to switch statement\n\nNote: the changes are mechanical.\nThe intention is to keep the previous behavior and prevent adding new\nnon exchaustive switch statements in the future.\n\nSee https://errorprone.info/bugpattern/MissingCasesInEnumSwitch\n","date":"2020-10-07 05:43:06","modifiedFileCount":"98","status":"M","submitter":"Vladimir Sitnikov"}]
