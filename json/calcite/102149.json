[{"authorTime":"2014-11-14 10:11:34","codes":[{"authorDate":"2014-11-14 10:11:34","commitOrder":1,"curCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression minusExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (minusExp == null) {\n        minusExp = childExp;\n      } else {\n        minusExp =\n            Expressions.call(\n                minusExp,\n                BuiltInMethod.EXCEPT.method,\n                childExp);\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(minusExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2014-11-14 10:22:06","endLine":78,"groupId":"12661","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/c7/83cab6a4a6eb193835278775713391ff1cfabb.src","preCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression minusExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (minusExp == null) {\n        minusExp = childExp;\n      } else {\n        minusExp =\n            Expressions.call(\n                minusExp,\n                BuiltInMethod.EXCEPT.method,\n                childExp);\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(minusExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMinus.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":45,"status":"B"},{"authorDate":"2014-11-14 10:11:34","commitOrder":1,"curCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression intersectExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (intersectExp == null) {\n        intersectExp = childExp;\n      } else {\n        intersectExp =\n            Expressions.call(\n                intersectExp,\n                all\n                    ? BuiltInMethod.CONCAT.method\n                    : BuiltInMethod.INTERSECT.method,\n                childExp);\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(intersectExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2014-11-14 10:22:06","endLine":80,"groupId":"14617","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/6c/74c17174c79ba43836be5fb824bf2e0de78301.src","preCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression intersectExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (intersectExp == null) {\n        intersectExp = childExp;\n      } else {\n        intersectExp =\n            Expressions.call(\n                intersectExp,\n                all\n                    ? BuiltInMethod.CONCAT.method\n                    : BuiltInMethod.INTERSECT.method,\n                childExp);\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(intersectExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableIntersect.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":45,"status":"B"}],"commitId":"a0ba73cd2de76696b96a1cd828d2aa4d3ef9eb55","commitMessage":"@@@[CALCITE-306] Standardize code style for \"import package.*;\"\n\nRename classes and packages and generally fix things up after [CALCITE-296] and [CALCITE-419].\n\nMake many inner classes of EnumerableRules (e.g. EnumerableFilter.  EnumerableFilterRule) top-level classes.\n\nApply a consistent formatting convention for string literals split over multiple lines.\n\nRename generated file org.eigenbase.resource.Resources to org.apache.calcite.runtime.Resources.\n\nChange occurrences of \"optiq\" and \"eigenbase\" in java code to \"calcite\".\n","date":"2014-11-14 10:22:06","modifiedFileCount":"1156","status":"B","submitter":"Julian Hyde"},{"authorTime":"2016-11-21 17:16:31","codes":[{"authorDate":"2016-11-21 17:16:31","commitOrder":2,"curCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression minusExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (minusExp == null) {\n        minusExp = childExp;\n      } else {\n        minusExp =\n            Expressions.call(minusExp,\n                BuiltInMethod.EXCEPT.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer()));\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(minusExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2016-11-23 13:26:46","endLine":78,"groupId":"0","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/7e/d4edbc737ce4926faecfb0a9d8e530198c385b.src","preCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression minusExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (minusExp == null) {\n        minusExp = childExp;\n      } else {\n        minusExp =\n            Expressions.call(\n                minusExp,\n                BuiltInMethod.EXCEPT.method,\n                childExp);\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(minusExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMinus.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":45,"status":"M"},{"authorDate":"2016-11-21 17:16:31","commitOrder":2,"curCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression intersectExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (intersectExp == null) {\n        intersectExp = childExp;\n      } else {\n        intersectExp =\n            Expressions.call(intersectExp,\n                BuiltInMethod.INTERSECT.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer()));\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(intersectExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2016-11-23 13:26:46","endLine":78,"groupId":"0","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/84/62f659c1ad3591c85ba0b6ae33533b08777424.src","preCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression intersectExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (intersectExp == null) {\n        intersectExp = childExp;\n      } else {\n        intersectExp =\n            Expressions.call(\n                intersectExp,\n                all\n                    ? BuiltInMethod.CONCAT.method\n                    : BuiltInMethod.INTERSECT.method,\n                childExp);\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(intersectExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableIntersect.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":45,"status":"M"}],"commitId":"ce2122ff2562340333bfa0ba371872fc9a9c6251","commitMessage":"@@@[CALCITE-1501] EnumerableUnion should use array comparator when row format is ARRAY (Dayue Gao)\n\nAlso implement EnumerableIntersect and EnumerableMinus.\n\nClose apache/calcite#326\n","date":"2016-11-23 13:26:46","modifiedFileCount":"9","status":"M","submitter":"gaodayue"},{"authorTime":"2019-10-14 15:32:10","codes":[{"authorDate":"2019-10-14 15:32:10","commitOrder":3,"curCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression minusExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (minusExp == null) {\n        minusExp = childExp;\n      } else {\n        minusExp =\n            Expressions.call(minusExp,\n                BuiltInMethod.EXCEPT.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer())\n                    .append(Expressions.constant(all)));\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(minusExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2019-11-08 02:11:07","endLine":78,"groupId":"5693","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/47/b563a7564a89fac89d7e9510c896a3760b5b74.src","preCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression minusExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (minusExp == null) {\n        minusExp = childExp;\n      } else {\n        minusExp =\n            Expressions.call(minusExp,\n                BuiltInMethod.EXCEPT.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer()));\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(minusExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMinus.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":44,"status":"M"},{"authorDate":"2019-10-14 15:32:10","commitOrder":3,"curCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression intersectExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (intersectExp == null) {\n        intersectExp = childExp;\n      } else {\n        intersectExp =\n            Expressions.call(intersectExp,\n                BuiltInMethod.INTERSECT.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer())\n                    .append(Expressions.constant(all)));\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(intersectExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2019-11-08 02:11:07","endLine":78,"groupId":"11878","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/1f/2b522540491e0dc53e5a0a9413a50ef4aa63d6.src","preCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression intersectExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (intersectExp == null) {\n        intersectExp = childExp;\n      } else {\n        intersectExp =\n            Expressions.call(intersectExp,\n                BuiltInMethod.INTERSECT.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer()));\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(intersectExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableIntersect.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":44,"status":"M"}],"commitId":"be5238492285ca061d4ddd82262448d3a6cedc5d","commitMessage":"@@@[CALCITE-3408] Add support for enumerable intersect/minus all (Wang Yanlin)\n\nClose #1503\n","date":"2019-11-08 02:11:07","modifiedFileCount":"15","status":"M","submitter":"yanlin-Lynn"},{"authorTime":"2020-09-29 22:09:05","codes":[{"authorDate":"2020-09-29 22:09:05","commitOrder":4,"curCode":"  @Override public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression minusExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (minusExp == null) {\n        minusExp = childExp;\n      } else {\n        minusExp =\n            Expressions.call(minusExp,\n                BuiltInMethod.EXCEPT.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer())\n                    .append(Expressions.constant(all)));\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(minusExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2020-10-07 05:42:47","endLine":78,"groupId":"5693","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/65/6c9a437154c27932f42ba59e6d33872d387d4c.src","preCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression minusExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (minusExp == null) {\n        minusExp = childExp;\n      } else {\n        minusExp =\n            Expressions.call(minusExp,\n                BuiltInMethod.EXCEPT.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer())\n                    .append(Expressions.constant(all)));\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(minusExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMinus.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":44,"status":"M"},{"authorDate":"2020-09-29 22:09:05","commitOrder":4,"curCode":"  @Override public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression intersectExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (intersectExp == null) {\n        intersectExp = childExp;\n      } else {\n        intersectExp =\n            Expressions.call(intersectExp,\n                BuiltInMethod.INTERSECT.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer())\n                    .append(Expressions.constant(all)));\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(intersectExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2020-10-07 05:42:47","endLine":78,"groupId":"11878","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/ab/95359709ec73c4073c42763c7c5ddd5d86c344.src","preCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression intersectExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (intersectExp == null) {\n        intersectExp = childExp;\n      } else {\n        intersectExp =\n            Expressions.call(intersectExp,\n                BuiltInMethod.INTERSECT.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer())\n                    .append(Expressions.constant(all)));\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(intersectExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableIntersect.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":44,"status":"M"}],"commitId":"66caa54c5e272f8287ca132ca012733898a38768","commitMessage":"@@@[CALCITE-4314] Add missing @Override annotations\n","date":"2020-10-07 05:42:47","modifiedFileCount":"745","status":"M","submitter":"Vladimir Sitnikov"},{"authorTime":"2020-05-29 00:04:40","codes":[{"authorDate":"2020-05-29 00:04:40","commitOrder":5,"curCode":"  @Override public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression minusExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n      assert childExp != null : \"childExp must not be null\";\n\n      if (minusExp == null) {\n        minusExp = childExp;\n      } else {\n        minusExp =\n            Expressions.call(minusExp,\n                BuiltInMethod.EXCEPT.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer())\n                    .append(Expressions.constant(all)));\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(\n        requireNonNull(minusExp, () -> \"minusExp is null, inputs=\" + inputs + \", rel=\" + this));\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2020-11-30 06:45:33","endLine":82,"groupId":"102149","id":9,"instanceNumber":1,"isCurCommit":1,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e9/c45c9641b0aab3edbacb366b6dec1fca3008c3.src","preCode":"  @Override public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression minusExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (minusExp == null) {\n        minusExp = childExp;\n      } else {\n        minusExp =\n            Expressions.call(minusExp,\n                BuiltInMethod.EXCEPT.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer())\n                    .append(Expressions.constant(all)));\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(minusExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMinus.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":46,"status":"M"},{"authorDate":"2020-05-29 00:04:40","commitOrder":5,"curCode":"  @Override public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression intersectExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (intersectExp == null) {\n        intersectExp = childExp;\n      } else {\n        intersectExp =\n            Expressions.call(intersectExp,\n                BuiltInMethod.INTERSECT.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer())\n                    .append(Expressions.constant(all)));\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(requireNonNull(intersectExp, \"intersectExp\"));\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2020-11-30 06:45:33","endLine":80,"groupId":"102149","id":10,"instanceNumber":2,"isCurCommit":1,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e2/0a8ad765eadde08981da8354f2fdb9b594cc5d.src","preCode":"  @Override public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final BlockBuilder builder = new BlockBuilder();\n    Expression intersectExp = null;\n    for (Ord<RelNode> ord : Ord.zip(inputs)) {\n      EnumerableRel input = (EnumerableRel) ord.e;\n      final Result result = implementor.visitChild(this, ord.i, input, pref);\n      Expression childExp =\n          builder.append(\n              \"child\" + ord.i,\n              result.block);\n\n      if (intersectExp == null) {\n        intersectExp = childExp;\n      } else {\n        intersectExp =\n            Expressions.call(intersectExp,\n                BuiltInMethod.INTERSECT.method,\n                Expressions.list(childExp)\n                    .appendIfNotNull(result.physType.comparer())\n                    .append(Expressions.constant(all)));\n      }\n\n      \r\n      \r\n      pref = pref.of(result.format);\n    }\n\n    builder.add(intersectExp);\n    final PhysType physType =\n        PhysTypeImpl.of(\n            implementor.getTypeFactory(),\n            getRowType(),\n            pref.prefer(JavaRowFormat.CUSTOM));\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableIntersect.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":46,"status":"M"}],"commitId":"d9a81b88ad561e7e4cedae93e805e0d7a53a7f1a","commitMessage":"@@@[CALCITE-4199] Add nullability annotations\n\nThe commit includes javadoc updates and refactorings made by Julian Hyde in https://github.com/apache/calcite/pull/2278\n","date":"2020-11-30 06:45:33","modifiedFileCount":"1012","status":"M","submitter":"Vladimir Sitnikov"}]
