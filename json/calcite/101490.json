[{"authorTime":"2016-07-31 03:56:19","codes":[{"authorDate":"2016-07-31 03:56:19","commitOrder":1,"curCode":"  @Test public void testExtractYearMonthDayFromDateColumn() {\n    final Fixture2 f = new Fixture2();\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    checkDateRange(f,\n        f.and(f.gt(f.exYear, f.literal(2010)), f.lt(f.exYear, f.literal(2020)),\n            f.eq(f.exMonth, f.literal(2)), f.eq(f.exDay, f.literal(29))),\n        is(\"AND(>=($8, 2011-01-01),\"\n            + \" AND(>=($8, 2011-01-01), <($8, 2020-01-01)),\"\n            + \" OR(AND(>=($8, 2011-02-01), <($8, 2011-03-01)),\"\n            + \" AND(>=($8, 2012-02-01), <($8, 2012-03-01)),\"\n            + \" AND(>=($8, 2013-02-01), <($8, 2013-03-01)),\"\n            + \" AND(>=($8, 2014-02-01), <($8, 2014-03-01)),\"\n            + \" AND(>=($8, 2015-02-01), <($8, 2015-03-01)),\"\n            + \" AND(>=($8, 2016-02-01), <($8, 2016-03-01)),\"\n            + \" AND(>=($8, 2017-02-01), <($8, 2017-03-01)),\"\n            + \" AND(>=($8, 2018-02-01), <($8, 2018-03-01)),\"\n            + \" AND(>=($8, 2019-02-01), <($8, 2019-03-01))),\"\n            + \" OR(AND(>=($8, 2012-02-29), <($8, 2012-03-01)),\"\n            + \" AND(>=($8, 2016-02-29), <($8, 2016-03-01))))\"));\n  }\n","date":"2016-09-07 02:39:10","endLine":137,"groupId":"2594","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testExtractYearMonthDayFromDateColumn","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/6e/f898e247dcdc9ad305bca9879d0c1c6568b673.src","preCode":"  @Test public void testExtractYearMonthDayFromDateColumn() {\n    final Fixture2 f = new Fixture2();\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    checkDateRange(f,\n        f.and(f.gt(f.exYear, f.literal(2010)), f.lt(f.exYear, f.literal(2020)),\n            f.eq(f.exMonth, f.literal(2)), f.eq(f.exDay, f.literal(29))),\n        is(\"AND(>=($8, 2011-01-01),\"\n            + \" AND(>=($8, 2011-01-01), <($8, 2020-01-01)),\"\n            + \" OR(AND(>=($8, 2011-02-01), <($8, 2011-03-01)),\"\n            + \" AND(>=($8, 2012-02-01), <($8, 2012-03-01)),\"\n            + \" AND(>=($8, 2013-02-01), <($8, 2013-03-01)),\"\n            + \" AND(>=($8, 2014-02-01), <($8, 2014-03-01)),\"\n            + \" AND(>=($8, 2015-02-01), <($8, 2015-03-01)),\"\n            + \" AND(>=($8, 2016-02-01), <($8, 2016-03-01)),\"\n            + \" AND(>=($8, 2017-02-01), <($8, 2017-03-01)),\"\n            + \" AND(>=($8, 2018-02-01), <($8, 2018-03-01)),\"\n            + \" AND(>=($8, 2019-02-01), <($8, 2019-03-01))),\"\n            + \" OR(AND(>=($8, 2012-02-29), <($8, 2012-03-01)),\"\n            + \" AND(>=($8, 2016-02-29), <($8, 2016-03-01))))\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rules/DateRangeRulesTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":113,"status":"B"},{"authorDate":"2016-07-31 03:56:19","commitOrder":1,"curCode":"  @Test public void testExtractYearMonthDayFromTimestampColumn() {\n    final Fixture2 f = new Fixture2();\n    checkDateRange(f,\n        f.and(f.gt(f.exYearTs, f.literal(2010)),\n            f.lt(f.exYearTs, f.literal(2020)),\n            f.eq(f.exMonthTs, f.literal(2)), f.eq(f.exDayTs, f.literal(29))),\n        is(\"AND(>=($9, 2011-01-01),\"\n            + \" AND(>=($9, 2011-01-01), <($9, 2020-01-01)),\"\n            + \" OR(AND(>=($9, 2011-02-01), <($9, 2011-03-01)),\"\n            + \" AND(>=($9, 2012-02-01), <($9, 2012-03-01)),\"\n            + \" AND(>=($9, 2013-02-01), <($9, 2013-03-01)),\"\n            + \" AND(>=($9, 2014-02-01), <($9, 2014-03-01)),\"\n            + \" AND(>=($9, 2015-02-01), <($9, 2015-03-01)),\"\n            + \" AND(>=($9, 2016-02-01), <($9, 2016-03-01)),\"\n            + \" AND(>=($9, 2017-02-01), <($9, 2017-03-01)),\"\n            + \" AND(>=($9, 2018-02-01), <($9, 2018-03-01)),\"\n            + \" AND(>=($9, 2019-02-01), <($9, 2019-03-01))),\"\n            + \" OR(AND(>=($9, 2012-02-29), <($9, 2012-03-01)),\"\n            + \" AND(>=($9, 2016-02-29), <($9, 2016-03-01))))\"));\n  }\n","date":"2016-09-07 02:39:10","endLine":158,"groupId":"5605","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testExtractYearMonthDayFromTimestampColumn","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/6e/f898e247dcdc9ad305bca9879d0c1c6568b673.src","preCode":"  @Test public void testExtractYearMonthDayFromTimestampColumn() {\n    final Fixture2 f = new Fixture2();\n    checkDateRange(f,\n        f.and(f.gt(f.exYearTs, f.literal(2010)),\n            f.lt(f.exYearTs, f.literal(2020)),\n            f.eq(f.exMonthTs, f.literal(2)), f.eq(f.exDayTs, f.literal(29))),\n        is(\"AND(>=($9, 2011-01-01),\"\n            + \" AND(>=($9, 2011-01-01), <($9, 2020-01-01)),\"\n            + \" OR(AND(>=($9, 2011-02-01), <($9, 2011-03-01)),\"\n            + \" AND(>=($9, 2012-02-01), <($9, 2012-03-01)),\"\n            + \" AND(>=($9, 2013-02-01), <($9, 2013-03-01)),\"\n            + \" AND(>=($9, 2014-02-01), <($9, 2014-03-01)),\"\n            + \" AND(>=($9, 2015-02-01), <($9, 2015-03-01)),\"\n            + \" AND(>=($9, 2016-02-01), <($9, 2016-03-01)),\"\n            + \" AND(>=($9, 2017-02-01), <($9, 2017-03-01)),\"\n            + \" AND(>=($9, 2018-02-01), <($9, 2018-03-01)),\"\n            + \" AND(>=($9, 2019-02-01), <($9, 2019-03-01))),\"\n            + \" OR(AND(>=($9, 2012-02-29), <($9, 2012-03-01)),\"\n            + \" AND(>=($9, 2016-02-29), <($9, 2016-03-01))))\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rules/DateRangeRulesTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":139,"status":"B"}],"commitId":"87435a9b86e0d44a6c9123c028e5c5180fe3da88","commitMessage":"@@@[CALCITE-1334] Convert predicates on EXTRACT function calls into date ranges\n\nTest the code on the 'timestamp' column of a Druid table.\n\nThis change requires RangeSet.  and therefore Guava 14 or higher.\n","date":"2016-09-07 02:39:10","modifiedFileCount":"14","status":"B","submitter":"Julian Hyde"},{"authorTime":"2017-09-14 20:53:41","codes":[{"authorDate":"2017-09-14 20:53:41","commitOrder":2,"curCode":"  @Test public void testExtractYearMonthDayFromDateColumn() {\n    final Fixture2 f = new Fixture2();\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    checkDateRange(f,\n        f.and(f.gt(f.exYear, f.literal(2010)), f.lt(f.exYear, f.literal(2020)),\n            f.eq(f.exMonth, f.literal(2)), f.eq(f.exDay, f.literal(29))),\n        is(\"AND(>=($9, 2011-01-01),\"\n            + \" AND(>=($9, 2011-01-01), <($9, 2020-01-01)),\"\n            + \" OR(AND(>=($9, 2011-02-01), <($9, 2011-03-01)),\"\n            + \" AND(>=($9, 2012-02-01), <($9, 2012-03-01)),\"\n            + \" AND(>=($9, 2013-02-01), <($9, 2013-03-01)),\"\n            + \" AND(>=($9, 2014-02-01), <($9, 2014-03-01)),\"\n            + \" AND(>=($9, 2015-02-01), <($9, 2015-03-01)),\"\n            + \" AND(>=($9, 2016-02-01), <($9, 2016-03-01)),\"\n            + \" AND(>=($9, 2017-02-01), <($9, 2017-03-01)),\"\n            + \" AND(>=($9, 2018-02-01), <($9, 2018-03-01)),\"\n            + \" AND(>=($9, 2019-02-01), <($9, 2019-03-01))),\"\n            + \" OR(AND(>=($9, 2012-02-29), <($9, 2012-03-01)),\"\n            + \" AND(>=($9, 2016-02-29), <($9, 2016-03-01))))\"));\n  }\n","date":"2017-10-03 02:13:43","endLine":160,"groupId":"2594","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testExtractYearMonthDayFromDateColumn","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/5f/d746d416c526637cb1a2c519f1260219e01d2f.src","preCode":"  @Test public void testExtractYearMonthDayFromDateColumn() {\n    final Fixture2 f = new Fixture2();\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    checkDateRange(f,\n        f.and(f.gt(f.exYear, f.literal(2010)), f.lt(f.exYear, f.literal(2020)),\n            f.eq(f.exMonth, f.literal(2)), f.eq(f.exDay, f.literal(29))),\n        is(\"AND(>=($8, 2011-01-01),\"\n            + \" AND(>=($8, 2011-01-01), <($8, 2020-01-01)),\"\n            + \" OR(AND(>=($8, 2011-02-01), <($8, 2011-03-01)),\"\n            + \" AND(>=($8, 2012-02-01), <($8, 2012-03-01)),\"\n            + \" AND(>=($8, 2013-02-01), <($8, 2013-03-01)),\"\n            + \" AND(>=($8, 2014-02-01), <($8, 2014-03-01)),\"\n            + \" AND(>=($8, 2015-02-01), <($8, 2015-03-01)),\"\n            + \" AND(>=($8, 2016-02-01), <($8, 2016-03-01)),\"\n            + \" AND(>=($8, 2017-02-01), <($8, 2017-03-01)),\"\n            + \" AND(>=($8, 2018-02-01), <($8, 2018-03-01)),\"\n            + \" AND(>=($8, 2019-02-01), <($8, 2019-03-01))),\"\n            + \" OR(AND(>=($8, 2012-02-29), <($8, 2012-03-01)),\"\n            + \" AND(>=($8, 2016-02-29), <($8, 2016-03-01))))\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rules/DateRangeRulesTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":136,"status":"M"},{"authorDate":"2017-09-14 20:53:41","commitOrder":2,"curCode":"  @Test public void testExtractYearMonthDayFromTimestampColumn() {\n    final Fixture2 f = new Fixture2();\n    checkDateRange(f,\n        f.and(f.gt(f.exYear, f.literal(2010)),\n            f.lt(f.exYear, f.literal(2020)),\n            f.eq(f.exMonth, f.literal(2)), f.eq(f.exDay, f.literal(29))),\n        is(\"AND(>=($9, 2011-01-01),\"\n            + \" AND(>=($9, 2011-01-01), <($9, 2020-01-01)),\"\n            + \" OR(AND(>=($9, 2011-02-01), <($9, 2011-03-01)),\"\n            + \" AND(>=($9, 2012-02-01), <($9, 2012-03-01)),\"\n            + \" AND(>=($9, 2013-02-01), <($9, 2013-03-01)),\"\n            + \" AND(>=($9, 2014-02-01), <($9, 2014-03-01)),\"\n            + \" AND(>=($9, 2015-02-01), <($9, 2015-03-01)),\"\n            + \" AND(>=($9, 2016-02-01), <($9, 2016-03-01)),\"\n            + \" AND(>=($9, 2017-02-01), <($9, 2017-03-01)),\"\n            + \" AND(>=($9, 2018-02-01), <($9, 2018-03-01)),\"\n            + \" AND(>=($9, 2019-02-01), <($9, 2019-03-01))),\"\n            + \" OR(AND(>=($9, 2012-02-29), <($9, 2012-03-01)),\"\n            + \" AND(>=($9, 2016-02-29), <($9, 2016-03-01))))\"));\n  }\n","date":"2017-10-03 02:13:43","endLine":181,"groupId":"2594","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testExtractYearMonthDayFromTimestampColumn","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/5f/d746d416c526637cb1a2c519f1260219e01d2f.src","preCode":"  @Test public void testExtractYearMonthDayFromTimestampColumn() {\n    final Fixture2 f = new Fixture2();\n    checkDateRange(f,\n        f.and(f.gt(f.exYearTs, f.literal(2010)),\n            f.lt(f.exYearTs, f.literal(2020)),\n            f.eq(f.exMonthTs, f.literal(2)), f.eq(f.exDayTs, f.literal(29))),\n        is(\"AND(>=($9, 2011-01-01),\"\n            + \" AND(>=($9, 2011-01-01), <($9, 2020-01-01)),\"\n            + \" OR(AND(>=($9, 2011-02-01), <($9, 2011-03-01)),\"\n            + \" AND(>=($9, 2012-02-01), <($9, 2012-03-01)),\"\n            + \" AND(>=($9, 2013-02-01), <($9, 2013-03-01)),\"\n            + \" AND(>=($9, 2014-02-01), <($9, 2014-03-01)),\"\n            + \" AND(>=($9, 2015-02-01), <($9, 2015-03-01)),\"\n            + \" AND(>=($9, 2016-02-01), <($9, 2016-03-01)),\"\n            + \" AND(>=($9, 2017-02-01), <($9, 2017-03-01)),\"\n            + \" AND(>=($9, 2018-02-01), <($9, 2018-03-01)),\"\n            + \" AND(>=($9, 2019-02-01), <($9, 2019-03-01))),\"\n            + \" OR(AND(>=($9, 2012-02-29), <($9, 2012-03-01)),\"\n            + \" AND(>=($9, 2016-02-29), <($9, 2016-03-01))))\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rules/DateRangeRulesTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":162,"status":"M"}],"commitId":"796a28f9a9d49a16971135074f315d536eb929cf","commitMessage":"@@@[CALCITE-1987] Implement EXTRACT for JDBC (Pavel Gubin)\n\nRemove EXTRACT_DATE function (it's all just EXTRACTi now). \nand revise Druid adapter.\n\nClose apache/calcite#539\n","date":"2017-10-03 02:13:43","modifiedFileCount":"8","status":"M","submitter":"pavelgubin"},{"authorTime":"2018-01-08 02:52:51","codes":[{"authorDate":"2018-01-08 02:52:51","commitOrder":3,"curCode":"  @Test public void testExtractYearMonthDayFromDateColumn() {\n    final Fixture2 f = new Fixture2();\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    checkDateRange(f,\n        f.and(f.gt(f.exYearD, f.literal(2010)),\n            f.lt(f.exYearD, f.literal(2020)),\n            f.eq(f.exMonthD, f.literal(2)), f.eq(f.exDayD, f.literal(29))),\n        is(\"AND(>=($8, 2011-01-01),\"\n            + \" AND(>=($8, 2011-01-01), <($8, 2020-01-01)),\"\n            + \" OR(AND(>=($8, 2011-02-01), <($8, 2011-03-01)),\"\n            + \" AND(>=($8, 2012-02-01), <($8, 2012-03-01)),\"\n            + \" AND(>=($8, 2013-02-01), <($8, 2013-03-01)),\"\n            + \" AND(>=($8, 2014-02-01), <($8, 2014-03-01)),\"\n            + \" AND(>=($8, 2015-02-01), <($8, 2015-03-01)),\"\n            + \" AND(>=($8, 2016-02-01), <($8, 2016-03-01)),\"\n            + \" AND(>=($8, 2017-02-01), <($8, 2017-03-01)),\"\n            + \" AND(>=($8, 2018-02-01), <($8, 2018-03-01)),\"\n            + \" AND(>=($8, 2019-02-01), <($8, 2019-03-01))),\"\n            + \" OR(AND(>=($8, 2012-02-29), <($8, 2012-03-01)),\"\n            + \" AND(>=($8, 2016-02-29), <($8, 2016-03-01))))\"));\n  }\n","date":"2018-01-09 05:34:48","endLine":159,"groupId":"9494","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testExtractYearMonthDayFromDateColumn","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/f2/47fbbf1251458ab4437e76a9619ba7d7828ce2.src","preCode":"  @Test public void testExtractYearMonthDayFromDateColumn() {\n    final Fixture2 f = new Fixture2();\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    checkDateRange(f,\n        f.and(f.gt(f.exYear, f.literal(2010)), f.lt(f.exYear, f.literal(2020)),\n            f.eq(f.exMonth, f.literal(2)), f.eq(f.exDay, f.literal(29))),\n        is(\"AND(>=($9, 2011-01-01),\"\n            + \" AND(>=($9, 2011-01-01), <($9, 2020-01-01)),\"\n            + \" OR(AND(>=($9, 2011-02-01), <($9, 2011-03-01)),\"\n            + \" AND(>=($9, 2012-02-01), <($9, 2012-03-01)),\"\n            + \" AND(>=($9, 2013-02-01), <($9, 2013-03-01)),\"\n            + \" AND(>=($9, 2014-02-01), <($9, 2014-03-01)),\"\n            + \" AND(>=($9, 2015-02-01), <($9, 2015-03-01)),\"\n            + \" AND(>=($9, 2016-02-01), <($9, 2016-03-01)),\"\n            + \" AND(>=($9, 2017-02-01), <($9, 2017-03-01)),\"\n            + \" AND(>=($9, 2018-02-01), <($9, 2018-03-01)),\"\n            + \" AND(>=($9, 2019-02-01), <($9, 2019-03-01))),\"\n            + \" OR(AND(>=($9, 2012-02-29), <($9, 2012-03-01)),\"\n            + \" AND(>=($9, 2016-02-29), <($9, 2016-03-01))))\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rules/DateRangeRulesTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":134,"status":"M"},{"authorDate":"2018-01-08 02:52:51","commitOrder":3,"curCode":"  @Test public void testExtractYearMonthDayFromTimestampColumn() {\n    final Fixture2 f = new Fixture2();\n    checkDateRange(f,\n        f.and(f.gt(f.exYearD, f.literal(2010)),\n            f.lt(f.exYearD, f.literal(2020)),\n            f.eq(f.exMonthD, f.literal(2)), f.eq(f.exDayD, f.literal(29))),\n        is(\"AND(>=($8, 2011-01-01),\"\n            + \" AND(>=($8, 2011-01-01), <($8, 2020-01-01)),\"\n            + \" OR(AND(>=($8, 2011-02-01), <($8, 2011-03-01)),\"\n            + \" AND(>=($8, 2012-02-01), <($8, 2012-03-01)),\"\n            + \" AND(>=($8, 2013-02-01), <($8, 2013-03-01)),\"\n            + \" AND(>=($8, 2014-02-01), <($8, 2014-03-01)),\"\n            + \" AND(>=($8, 2015-02-01), <($8, 2015-03-01)),\"\n            + \" AND(>=($8, 2016-02-01), <($8, 2016-03-01)),\"\n            + \" AND(>=($8, 2017-02-01), <($8, 2017-03-01)),\"\n            + \" AND(>=($8, 2018-02-01), <($8, 2018-03-01)),\"\n            + \" AND(>=($8, 2019-02-01), <($8, 2019-03-01))),\"\n            + \" OR(AND(>=($8, 2012-02-29), <($8, 2012-03-01)),\"\n            + \" AND(>=($8, 2016-02-29), <($8, 2016-03-01))))\"));\n  }\n","date":"2018-01-09 05:34:48","endLine":180,"groupId":"9494","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testExtractYearMonthDayFromTimestampColumn","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/f2/47fbbf1251458ab4437e76a9619ba7d7828ce2.src","preCode":"  @Test public void testExtractYearMonthDayFromTimestampColumn() {\n    final Fixture2 f = new Fixture2();\n    checkDateRange(f,\n        f.and(f.gt(f.exYear, f.literal(2010)),\n            f.lt(f.exYear, f.literal(2020)),\n            f.eq(f.exMonth, f.literal(2)), f.eq(f.exDay, f.literal(29))),\n        is(\"AND(>=($9, 2011-01-01),\"\n            + \" AND(>=($9, 2011-01-01), <($9, 2020-01-01)),\"\n            + \" OR(AND(>=($9, 2011-02-01), <($9, 2011-03-01)),\"\n            + \" AND(>=($9, 2012-02-01), <($9, 2012-03-01)),\"\n            + \" AND(>=($9, 2013-02-01), <($9, 2013-03-01)),\"\n            + \" AND(>=($9, 2014-02-01), <($9, 2014-03-01)),\"\n            + \" AND(>=($9, 2015-02-01), <($9, 2015-03-01)),\"\n            + \" AND(>=($9, 2016-02-01), <($9, 2016-03-01)),\"\n            + \" AND(>=($9, 2017-02-01), <($9, 2017-03-01)),\"\n            + \" AND(>=($9, 2018-02-01), <($9, 2018-03-01)),\"\n            + \" AND(>=($9, 2019-02-01), <($9, 2019-03-01))),\"\n            + \" OR(AND(>=($9, 2012-02-29), <($9, 2012-03-01)),\"\n            + \" AND(>=($9, 2016-02-29), <($9, 2016-03-01))))\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rules/DateRangeRulesTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":161,"status":"M"}],"commitId":"2918b8fe55c58e0bafd38accfface242f1847c54","commitMessage":"@@@[CALCITE-2122] In DateRangeRules.  make either TIMESTAMP or DATE literal.  according to target type (Nishant Bangarwa)\n\nClose apache/calcite#599\n","date":"2018-01-09 05:34:48","modifiedFileCount":"6","status":"M","submitter":"Nishant"},{"authorTime":"2020-04-02 10:39:10","codes":[{"authorDate":"2020-04-02 10:39:10","commitOrder":4,"curCode":"  @Test void testExtractYearMonthDayFromDateColumn() {\n    final Fixture2 f = new Fixture2();\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    checkDateRange(f,\n        f.and(f.gt(f.exYearD, f.literal(2010)),\n            f.lt(f.exYearD, f.literal(2020)),\n            f.eq(f.exMonthD, f.literal(2)), f.eq(f.exDayD, f.literal(29))),\n        is(\"AND(>=($8, 2011-01-01),\"\n            + \" AND(>=($8, 2011-01-01), <($8, 2020-01-01)),\"\n            + \" OR(AND(>=($8, 2011-02-01), <($8, 2011-03-01)),\"\n            + \" AND(>=($8, 2012-02-01), <($8, 2012-03-01)),\"\n            + \" AND(>=($8, 2013-02-01), <($8, 2013-03-01)),\"\n            + \" AND(>=($8, 2014-02-01), <($8, 2014-03-01)),\"\n            + \" AND(>=($8, 2015-02-01), <($8, 2015-03-01)),\"\n            + \" AND(>=($8, 2016-02-01), <($8, 2016-03-01)),\"\n            + \" AND(>=($8, 2017-02-01), <($8, 2017-03-01)),\"\n            + \" AND(>=($8, 2018-02-01), <($8, 2018-03-01)),\"\n            + \" AND(>=($8, 2019-02-01), <($8, 2019-03-01))),\"\n            + \" OR(AND(>=($8, 2012-02-29), <($8, 2012-03-01)),\"\n            + \" AND(>=($8, 2016-02-29), <($8, 2016-03-01))))\"));\n  }\n","date":"2020-04-06 04:57:49","endLine":159,"groupId":"101490","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testExtractYearMonthDayFromDateColumn","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e7/29288bd53b9dc06551209ba551f2b4be514394.src","preCode":"  @Test public void testExtractYearMonthDayFromDateColumn() {\n    final Fixture2 f = new Fixture2();\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    checkDateRange(f,\n        f.and(f.gt(f.exYearD, f.literal(2010)),\n            f.lt(f.exYearD, f.literal(2020)),\n            f.eq(f.exMonthD, f.literal(2)), f.eq(f.exDayD, f.literal(29))),\n        is(\"AND(>=($8, 2011-01-01),\"\n            + \" AND(>=($8, 2011-01-01), <($8, 2020-01-01)),\"\n            + \" OR(AND(>=($8, 2011-02-01), <($8, 2011-03-01)),\"\n            + \" AND(>=($8, 2012-02-01), <($8, 2012-03-01)),\"\n            + \" AND(>=($8, 2013-02-01), <($8, 2013-03-01)),\"\n            + \" AND(>=($8, 2014-02-01), <($8, 2014-03-01)),\"\n            + \" AND(>=($8, 2015-02-01), <($8, 2015-03-01)),\"\n            + \" AND(>=($8, 2016-02-01), <($8, 2016-03-01)),\"\n            + \" AND(>=($8, 2017-02-01), <($8, 2017-03-01)),\"\n            + \" AND(>=($8, 2018-02-01), <($8, 2018-03-01)),\"\n            + \" AND(>=($8, 2019-02-01), <($8, 2019-03-01))),\"\n            + \" OR(AND(>=($8, 2012-02-29), <($8, 2012-03-01)),\"\n            + \" AND(>=($8, 2016-02-29), <($8, 2016-03-01))))\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rules/DateRangeRulesTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":134,"status":"M"},{"authorDate":"2020-04-02 10:39:10","commitOrder":4,"curCode":"  @Test void testExtractYearMonthDayFromTimestampColumn() {\n    final Fixture2 f = new Fixture2();\n    checkDateRange(f,\n        f.and(f.gt(f.exYearD, f.literal(2010)),\n            f.lt(f.exYearD, f.literal(2020)),\n            f.eq(f.exMonthD, f.literal(2)), f.eq(f.exDayD, f.literal(29))),\n        is(\"AND(>=($8, 2011-01-01),\"\n            + \" AND(>=($8, 2011-01-01), <($8, 2020-01-01)),\"\n            + \" OR(AND(>=($8, 2011-02-01), <($8, 2011-03-01)),\"\n            + \" AND(>=($8, 2012-02-01), <($8, 2012-03-01)),\"\n            + \" AND(>=($8, 2013-02-01), <($8, 2013-03-01)),\"\n            + \" AND(>=($8, 2014-02-01), <($8, 2014-03-01)),\"\n            + \" AND(>=($8, 2015-02-01), <($8, 2015-03-01)),\"\n            + \" AND(>=($8, 2016-02-01), <($8, 2016-03-01)),\"\n            + \" AND(>=($8, 2017-02-01), <($8, 2017-03-01)),\"\n            + \" AND(>=($8, 2018-02-01), <($8, 2018-03-01)),\"\n            + \" AND(>=($8, 2019-02-01), <($8, 2019-03-01))),\"\n            + \" OR(AND(>=($8, 2012-02-29), <($8, 2012-03-01)),\"\n            + \" AND(>=($8, 2016-02-29), <($8, 2016-03-01))))\"));\n  }\n","date":"2020-04-06 04:57:49","endLine":180,"groupId":"101490","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testExtractYearMonthDayFromTimestampColumn","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e7/29288bd53b9dc06551209ba551f2b4be514394.src","preCode":"  @Test public void testExtractYearMonthDayFromTimestampColumn() {\n    final Fixture2 f = new Fixture2();\n    checkDateRange(f,\n        f.and(f.gt(f.exYearD, f.literal(2010)),\n            f.lt(f.exYearD, f.literal(2020)),\n            f.eq(f.exMonthD, f.literal(2)), f.eq(f.exDayD, f.literal(29))),\n        is(\"AND(>=($8, 2011-01-01),\"\n            + \" AND(>=($8, 2011-01-01), <($8, 2020-01-01)),\"\n            + \" OR(AND(>=($8, 2011-02-01), <($8, 2011-03-01)),\"\n            + \" AND(>=($8, 2012-02-01), <($8, 2012-03-01)),\"\n            + \" AND(>=($8, 2013-02-01), <($8, 2013-03-01)),\"\n            + \" AND(>=($8, 2014-02-01), <($8, 2014-03-01)),\"\n            + \" AND(>=($8, 2015-02-01), <($8, 2015-03-01)),\"\n            + \" AND(>=($8, 2016-02-01), <($8, 2016-03-01)),\"\n            + \" AND(>=($8, 2017-02-01), <($8, 2017-03-01)),\"\n            + \" AND(>=($8, 2018-02-01), <($8, 2018-03-01)),\"\n            + \" AND(>=($8, 2019-02-01), <($8, 2019-03-01))),\"\n            + \" OR(AND(>=($8, 2012-02-29), <($8, 2012-03-01)),\"\n            + \" AND(>=($8, 2016-02-29), <($8, 2016-03-01))))\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rules/DateRangeRulesTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":161,"status":"M"}],"commitId":"9492dd4146f63ddc028010d6c4e86f6a5cb29a8d","commitMessage":"@@@[CALCITE-3892] Make junit test classes and methods non-public where possible\n\nPrior to junit 5.  classes and methods had to be public. This is no\nlonger the case.\n\nSome classes need to remain public because they are referenced from\nelsewhere.  or if they use reflection somehow. The remaining 'public'\nkeyword will be informative to maintainers.\n","date":"2020-04-06 04:57:49","modifiedFileCount":"196","status":"M","submitter":"Julian Hyde"}]
