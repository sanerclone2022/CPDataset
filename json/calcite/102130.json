[{"authorTime":"2020-06-19 02:09:17","codes":[{"authorDate":"2020-06-19 02:09:17","commitOrder":16,"curCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    if (!Aggregate.isSimple(this)) {\n      throw Util.needToImplement(\"EnumerableSortedAggregate\");\n    }\n\n    final JavaTypeFactory typeFactory = implementor.getTypeFactory();\n    final BlockBuilder builder = new BlockBuilder();\n    final EnumerableRel child = (EnumerableRel) getInput();\n    final Result result = implementor.visitChild(this, 0, child, pref);\n    Expression childExp =\n        builder.append(\n            \"child\",\n            result.block);\n\n    final PhysType physType =\n        PhysTypeImpl.of(\n            typeFactory, getRowType(), pref.preferCustom());\n\n    final PhysType inputPhysType = result.physType;\n\n    ParameterExpression parameter =\n        Expressions.parameter(inputPhysType.getJavaRowType(), \"a0\");\n\n    final PhysType keyPhysType =\n        inputPhysType.project(groupSet.asList(), getGroupType() != Group.SIMPLE,\n            JavaRowFormat.LIST);\n    final int groupCount = getGroupCount();\n\n    final List<AggImpState> aggs = new ArrayList<>(aggCalls.size());\n    for (Ord<AggregateCall> call : Ord.zip(aggCalls)) {\n      aggs.add(new AggImpState(call.i, call.e, false));\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final List<Expression> initExpressions = new ArrayList<>();\n    final BlockBuilder initBlock = new BlockBuilder();\n\n    final List<Type> aggStateTypes = createAggStateTypes(\n        initExpressions, initBlock, aggs, typeFactory);\n\n    final PhysType accPhysType =\n        PhysTypeImpl.of(typeFactory,\n            typeFactory.createSyntheticType(aggStateTypes));\n\n    declareParentAccumulator(initExpressions, initBlock, accPhysType);\n\n    final Expression accumulatorInitializer =\n        builder.append(\"accumulatorInitializer\",\n            Expressions.lambda(\n                Function0.class,\n                initBlock.toBlock()));\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final ParameterExpression inParameter =\n        Expressions.parameter(inputPhysType.getJavaRowType(), \"in\");\n    final ParameterExpression acc_ =\n        Expressions.parameter(accPhysType.getJavaRowType(), \"acc\");\n\n    createAccumulatorAdders(\n        inParameter, aggs, accPhysType, acc_, inputPhysType, builder, implementor, typeFactory);\n\n    final ParameterExpression lambdaFactory =\n        Expressions.parameter(AggregateLambdaFactory.class,\n            builder.newName(\"lambdaFactory\"));\n\n    implementLambdaFactory(builder, inputPhysType, aggs, accumulatorInitializer,\n        false, lambdaFactory);\n\n    final BlockBuilder resultBlock = new BlockBuilder();\n    final List<Expression> results = Expressions.list();\n    final ParameterExpression key_;\n    final Type keyType = keyPhysType.getJavaRowType();\n    key_ = Expressions.parameter(keyType, \"key\");\n    for (int j = 0; j < groupCount; j++) {\n      final Expression ref = keyPhysType.fieldReference(key_, j);\n      results.add(ref);\n    }\n\n    for (final AggImpState agg : aggs) {\n      results.add(\n          agg.implementor.implementResult(agg.context,\n              new AggResultContextImpl(resultBlock, agg.call, agg.state, key_,\n                  keyPhysType)));\n    }\n    resultBlock.add(physType.record(results));\n\n    final Expression keySelector_ =\n        builder.append(\"keySelector\",\n            inputPhysType.generateSelector(parameter,\n                groupSet.asList(),\n                keyPhysType.getFormat()));\n    \r\n    \r\n    \r\n    final Expression comparator = keyPhysType.generateComparator(getTraitSet().getCollation());\n\n    final Expression resultSelector_ =\n        builder.append(\"resultSelector\",\n            Expressions.lambda(Function2.class,\n                resultBlock.toBlock(),\n                key_,\n                acc_));\n\n    builder.add(\n        Expressions.return_(null,\n            Expressions.call(childExp,\n                BuiltInMethod.SORTED_GROUP_BY.method,\n                Expressions.list(keySelector_,\n                    Expressions.call(lambdaFactory,\n                        BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_INITIALIZER.method),\n                    Expressions.call(lambdaFactory,\n                        BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_ADDER.method),\n                    Expressions.call(lambdaFactory,\n                        BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_RESULT_SELECTOR.method,\n                        resultSelector_), comparator)\n                    )));\n\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2020-06-29 16:36:00","endLine":233,"groupId":"2747","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/1b/b5fd31a288b5f19ab8ca2f2ce72e770e9a9d30.src","preCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    if (!Aggregate.isSimple(this)) {\n      throw Util.needToImplement(\"EnumerableSortedAggregate\");\n    }\n\n    final JavaTypeFactory typeFactory = implementor.getTypeFactory();\n    final BlockBuilder builder = new BlockBuilder();\n    final EnumerableRel child = (EnumerableRel) getInput();\n    final Result result = implementor.visitChild(this, 0, child, pref);\n    Expression childExp =\n        builder.append(\n            \"child\",\n            result.block);\n\n    final PhysType physType =\n        PhysTypeImpl.of(\n            typeFactory, getRowType(), pref.preferCustom());\n\n    final PhysType inputPhysType = result.physType;\n\n    ParameterExpression parameter =\n        Expressions.parameter(inputPhysType.getJavaRowType(), \"a0\");\n\n    final PhysType keyPhysType =\n        inputPhysType.project(groupSet.asList(), getGroupType() != Group.SIMPLE,\n            JavaRowFormat.LIST);\n    final int groupCount = getGroupCount();\n\n    final List<AggImpState> aggs = new ArrayList<>(aggCalls.size());\n    for (Ord<AggregateCall> call : Ord.zip(aggCalls)) {\n      aggs.add(new AggImpState(call.i, call.e, false));\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final List<Expression> initExpressions = new ArrayList<>();\n    final BlockBuilder initBlock = new BlockBuilder();\n\n    final List<Type> aggStateTypes = createAggStateTypes(\n        initExpressions, initBlock, aggs, typeFactory);\n\n    final PhysType accPhysType =\n        PhysTypeImpl.of(typeFactory,\n            typeFactory.createSyntheticType(aggStateTypes));\n\n    declareParentAccumulator(initExpressions, initBlock, accPhysType);\n\n    final Expression accumulatorInitializer =\n        builder.append(\"accumulatorInitializer\",\n            Expressions.lambda(\n                Function0.class,\n                initBlock.toBlock()));\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final ParameterExpression inParameter =\n        Expressions.parameter(inputPhysType.getJavaRowType(), \"in\");\n    final ParameterExpression acc_ =\n        Expressions.parameter(accPhysType.getJavaRowType(), \"acc\");\n\n    createAccumulatorAdders(\n        inParameter, aggs, accPhysType, acc_, inputPhysType, builder, implementor, typeFactory);\n\n    final ParameterExpression lambdaFactory =\n        Expressions.parameter(AggregateLambdaFactory.class,\n            builder.newName(\"lambdaFactory\"));\n\n    implementLambdaFactory(builder, inputPhysType, aggs, accumulatorInitializer,\n        false, lambdaFactory);\n\n    final BlockBuilder resultBlock = new BlockBuilder();\n    final List<Expression> results = Expressions.list();\n    final ParameterExpression key_;\n    final Type keyType = keyPhysType.getJavaRowType();\n    key_ = Expressions.parameter(keyType, \"key\");\n    for (int j = 0; j < groupCount; j++) {\n      final Expression ref = keyPhysType.fieldReference(key_, j);\n      results.add(ref);\n    }\n\n    for (final AggImpState agg : aggs) {\n      results.add(\n          agg.implementor.implementResult(agg.context,\n              new AggResultContextImpl(resultBlock, agg.call, agg.state, key_,\n                  keyPhysType)));\n    }\n    resultBlock.add(physType.record(results));\n\n    final Expression keySelector_ =\n        builder.append(\"keySelector\",\n            inputPhysType.generateSelector(parameter,\n                groupSet.asList(),\n                keyPhysType.getFormat()));\n    \r\n    \r\n    \r\n    final Expression comparator = keyPhysType.generateComparator(getTraitSet().getCollation());\n\n    final Expression resultSelector_ =\n        builder.append(\"resultSelector\",\n            Expressions.lambda(Function2.class,\n                resultBlock.toBlock(),\n                key_,\n                acc_));\n\n    builder.add(\n        Expressions.return_(null,\n            Expressions.call(childExp,\n                BuiltInMethod.SORTED_GROUP_BY.method,\n                Expressions.list(keySelector_,\n                    Expressions.call(lambdaFactory,\n                        BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_INITIALIZER.method),\n                    Expressions.call(lambdaFactory,\n                        BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_ADDER.method),\n                    Expressions.call(lambdaFactory,\n                        BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_RESULT_SELECTOR.method,\n                        resultSelector_), comparator)\n                    )));\n\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableSortedAggregate.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":103,"status":"B"},{"authorDate":"2020-06-19 02:09:17","commitOrder":16,"curCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final JavaTypeFactory typeFactory = implementor.getTypeFactory();\n    final BlockBuilder builder = new BlockBuilder();\n    final EnumerableRel child = (EnumerableRel) getInput();\n    final Result result = implementor.visitChild(this, 0, child, pref);\n    Expression childExp =\n        builder.append(\n            \"child\",\n            result.block);\n\n    final PhysType physType =\n        PhysTypeImpl.of(\n            typeFactory, getRowType(), pref.preferCustom());\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    final PhysType inputPhysType = result.physType;\n\n    ParameterExpression parameter =\n        Expressions.parameter(inputPhysType.getJavaRowType(), \"a0\");\n\n    final PhysType keyPhysType =\n        inputPhysType.project(groupSet.asList(), getGroupType() != Group.SIMPLE,\n            JavaRowFormat.LIST);\n    final int groupCount = getGroupCount();\n\n    final List<AggImpState> aggs = new ArrayList<>(aggCalls.size());\n    for (Ord<AggregateCall> call : Ord.zip(aggCalls)) {\n      aggs.add(new AggImpState(call.i, call.e, false));\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final List<Expression> initExpressions = new ArrayList<>();\n    final BlockBuilder initBlock = new BlockBuilder();\n\n    final List<Type> aggStateTypes = createAggStateTypes(\n        initExpressions, initBlock, aggs, typeFactory);\n\n    final PhysType accPhysType =\n        PhysTypeImpl.of(typeFactory,\n            typeFactory.createSyntheticType(aggStateTypes));\n\n    declareParentAccumulator(initExpressions, initBlock, accPhysType);\n\n    final Expression accumulatorInitializer =\n        builder.append(\"accumulatorInitializer\",\n            Expressions.lambda(\n                Function0.class,\n                initBlock.toBlock()));\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final ParameterExpression inParameter =\n        Expressions.parameter(inputPhysType.getJavaRowType(), \"in\");\n    final ParameterExpression acc_ =\n        Expressions.parameter(accPhysType.getJavaRowType(), \"acc\");\n\n    createAccumulatorAdders(\n        inParameter, aggs, accPhysType, acc_, inputPhysType, builder, implementor, typeFactory);\n\n    final ParameterExpression lambdaFactory =\n        Expressions.parameter(AggregateLambdaFactory.class,\n            builder.newName(\"lambdaFactory\"));\n\n    implementLambdaFactory(builder, inputPhysType, aggs, accumulatorInitializer,\n        hasOrderedCall(aggs), lambdaFactory);\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final BlockBuilder resultBlock = new BlockBuilder();\n    final List<Expression> results = Expressions.list();\n    final ParameterExpression key_;\n    if (groupCount == 0) {\n      key_ = null;\n    } else {\n      final Type keyType = keyPhysType.getJavaRowType();\n      key_ = Expressions.parameter(keyType, \"key\");\n      for (int j = 0; j < groupCount; j++) {\n        final Expression ref = keyPhysType.fieldReference(key_, j);\n        if (getGroupType() == Group.SIMPLE) {\n          results.add(ref);\n        } else {\n          results.add(\n              Expressions.condition(\n                  keyPhysType.fieldReference(key_, groupCount + j),\n                  Expressions.constant(null),\n                  Expressions.box(ref)));\n        }\n      }\n    }\n    for (final AggImpState agg : aggs) {\n      results.add(\n          agg.implementor.implementResult(agg.context,\n              new AggResultContextImpl(resultBlock, agg.call, agg.state, key_,\n                  keyPhysType)));\n    }\n    resultBlock.add(physType.record(results));\n    if (getGroupType() != Group.SIMPLE) {\n      final List<Expression> list = new ArrayList<>();\n      for (ImmutableBitSet set : groupSets) {\n        list.add(\n            inputPhysType.generateSelector(parameter, groupSet.asList(),\n                set.asList(), keyPhysType.getFormat()));\n      }\n      final Expression keySelectors_ =\n          builder.append(\"keySelectors\",\n              Expressions.call(BuiltInMethod.ARRAYS_AS_LIST.method,\n                  list));\n      final Expression resultSelector =\n          builder.append(\"resultSelector\",\n              Expressions.lambda(Function2.class,\n                  resultBlock.toBlock(),\n                  key_,\n                  acc_));\n      builder.add(\n          Expressions.return_(null,\n              Expressions.call(\n                  BuiltInMethod.GROUP_BY_MULTIPLE.method,\n                  Expressions.list(childExp,\n                      keySelectors_,\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_INITIALIZER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_ADDER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_RESULT_SELECTOR.method,\n                          resultSelector))\n                      .appendIfNotNull(keyPhysType.comparer()))));\n    } else if (groupCount == 0) {\n      final Expression resultSelector =\n          builder.append(\n              \"resultSelector\",\n              Expressions.lambda(\n                  Function1.class,\n                  resultBlock.toBlock(),\n                  acc_));\n      builder.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  BuiltInMethod.SINGLETON_ENUMERABLE.method,\n                  Expressions.call(\n                      childExp,\n                      BuiltInMethod.AGGREGATE.method,\n                      Expressions.call(\n                          Expressions.call(lambdaFactory,\n                              BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_INITIALIZER.method),\n                          BuiltInMethod.FUNCTION0_APPLY.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_ADDER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_SINGLE_GROUP_RESULT_SELECTOR.method,\n                          resultSelector)))));\n    } else if (aggCalls.isEmpty()\n        && groupSet.equals(\n            ImmutableBitSet.range(child.getRowType().getFieldCount()))) {\n      builder.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  inputPhysType.convertTo(childExp, physType.getFormat()),\n                  BuiltInMethod.DISTINCT.method,\n                  Expressions.<Expression>list()\n                      .appendIfNotNull(physType.comparer()))));\n    } else {\n      final Expression keySelector_ =\n          builder.append(\"keySelector\",\n              inputPhysType.generateSelector(parameter,\n                  groupSet.asList(),\n                  keyPhysType.getFormat()));\n      final Expression resultSelector_ =\n          builder.append(\"resultSelector\",\n              Expressions.lambda(Function2.class,\n                  resultBlock.toBlock(),\n                  key_,\n                  acc_));\n      builder.add(\n          Expressions.return_(null,\n              Expressions.call(childExp,\n                  BuiltInMethod.GROUP_BY2.method,\n                  Expressions.list(keySelector_,\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_INITIALIZER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_ADDER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_RESULT_SELECTOR.method,\n                          resultSelector_))\n                      .appendIfNotNull(keyPhysType.comparer()))));\n    }\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2020-06-29 16:36:00","endLine":355,"groupId":"1708","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/03/f3192b3c32f1e17093330b5a4d5b1746d7e8eb.src","preCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final JavaTypeFactory typeFactory = implementor.getTypeFactory();\n    final BlockBuilder builder = new BlockBuilder();\n    final EnumerableRel child = (EnumerableRel) getInput();\n    final Result result = implementor.visitChild(this, 0, child, pref);\n    Expression childExp =\n        builder.append(\n            \"child\",\n            result.block);\n\n    final PhysType physType =\n        PhysTypeImpl.of(\n            typeFactory, getRowType(), pref.preferCustom());\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    final PhysType inputPhysType = result.physType;\n\n    ParameterExpression parameter =\n        Expressions.parameter(inputPhysType.getJavaRowType(), \"a0\");\n\n    final PhysType keyPhysType =\n        inputPhysType.project(groupSet.asList(), getGroupType() != Group.SIMPLE,\n            JavaRowFormat.LIST);\n    final int groupCount = getGroupCount();\n\n    final List<AggImpState> aggs = new ArrayList<>(aggCalls.size());\n    for (Ord<AggregateCall> call : Ord.zip(aggCalls)) {\n      aggs.add(new AggImpState(call.i, call.e, false));\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final List<Expression> initExpressions = new ArrayList<>();\n    final BlockBuilder initBlock = new BlockBuilder();\n\n    final List<Type> aggStateTypes = createAggStateTypes(\n        initExpressions, initBlock, aggs, typeFactory);\n\n    final PhysType accPhysType =\n        PhysTypeImpl.of(typeFactory,\n            typeFactory.createSyntheticType(aggStateTypes));\n\n    declareParentAccumulator(initExpressions, initBlock, accPhysType);\n\n    final Expression accumulatorInitializer =\n        builder.append(\"accumulatorInitializer\",\n            Expressions.lambda(\n                Function0.class,\n                initBlock.toBlock()));\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final ParameterExpression inParameter =\n        Expressions.parameter(inputPhysType.getJavaRowType(), \"in\");\n    final ParameterExpression acc_ =\n        Expressions.parameter(accPhysType.getJavaRowType(), \"acc\");\n\n    createAccumulatorAdders(\n        inParameter, aggs, accPhysType, acc_, inputPhysType, builder, implementor, typeFactory);\n\n    final ParameterExpression lambdaFactory =\n        Expressions.parameter(AggregateLambdaFactory.class,\n            builder.newName(\"lambdaFactory\"));\n\n    implementLambdaFactory(builder, inputPhysType, aggs, accumulatorInitializer,\n        hasOrderedCall(aggs), lambdaFactory);\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final BlockBuilder resultBlock = new BlockBuilder();\n    final List<Expression> results = Expressions.list();\n    final ParameterExpression key_;\n    if (groupCount == 0) {\n      key_ = null;\n    } else {\n      final Type keyType = keyPhysType.getJavaRowType();\n      key_ = Expressions.parameter(keyType, \"key\");\n      for (int j = 0; j < groupCount; j++) {\n        final Expression ref = keyPhysType.fieldReference(key_, j);\n        if (getGroupType() == Group.SIMPLE) {\n          results.add(ref);\n        } else {\n          results.add(\n              Expressions.condition(\n                  keyPhysType.fieldReference(key_, groupCount + j),\n                  Expressions.constant(null),\n                  Expressions.box(ref)));\n        }\n      }\n    }\n    for (final AggImpState agg : aggs) {\n      results.add(\n          agg.implementor.implementResult(agg.context,\n              new AggResultContextImpl(resultBlock, agg.call, agg.state, key_,\n                  keyPhysType)));\n    }\n    resultBlock.add(physType.record(results));\n    if (getGroupType() != Group.SIMPLE) {\n      final List<Expression> list = new ArrayList<>();\n      for (ImmutableBitSet set : groupSets) {\n        list.add(\n            inputPhysType.generateSelector(parameter, groupSet.asList(),\n                set.asList(), keyPhysType.getFormat()));\n      }\n      final Expression keySelectors_ =\n          builder.append(\"keySelectors\",\n              Expressions.call(BuiltInMethod.ARRAYS_AS_LIST.method,\n                  list));\n      final Expression resultSelector =\n          builder.append(\"resultSelector\",\n              Expressions.lambda(Function2.class,\n                  resultBlock.toBlock(),\n                  key_,\n                  acc_));\n      builder.add(\n          Expressions.return_(null,\n              Expressions.call(\n                  BuiltInMethod.GROUP_BY_MULTIPLE.method,\n                  Expressions.list(childExp,\n                      keySelectors_,\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_INITIALIZER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_ADDER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_RESULT_SELECTOR.method,\n                          resultSelector))\n                      .appendIfNotNull(keyPhysType.comparer()))));\n    } else if (groupCount == 0) {\n      final Expression resultSelector =\n          builder.append(\n              \"resultSelector\",\n              Expressions.lambda(\n                  Function1.class,\n                  resultBlock.toBlock(),\n                  acc_));\n      builder.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  BuiltInMethod.SINGLETON_ENUMERABLE.method,\n                  Expressions.call(\n                      childExp,\n                      BuiltInMethod.AGGREGATE.method,\n                      Expressions.call(\n                          Expressions.call(lambdaFactory,\n                              BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_INITIALIZER.method),\n                          BuiltInMethod.FUNCTION0_APPLY.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_ADDER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_SINGLE_GROUP_RESULT_SELECTOR.method,\n                          resultSelector)))));\n    } else if (aggCalls.isEmpty()\n        && groupSet.equals(\n            ImmutableBitSet.range(child.getRowType().getFieldCount()))) {\n      builder.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  inputPhysType.convertTo(childExp, physType.getFormat()),\n                  BuiltInMethod.DISTINCT.method,\n                  Expressions.<Expression>list()\n                      .appendIfNotNull(physType.comparer()))));\n    } else {\n      final Expression keySelector_ =\n          builder.append(\"keySelector\",\n              inputPhysType.generateSelector(parameter,\n                  groupSet.asList(),\n                  keyPhysType.getFormat()));\n      final Expression resultSelector_ =\n          builder.append(\"resultSelector\",\n              Expressions.lambda(Function2.class,\n                  resultBlock.toBlock(),\n                  key_,\n                  acc_));\n      builder.add(\n          Expressions.return_(null,\n              Expressions.call(childExp,\n                  BuiltInMethod.GROUP_BY2.method,\n                  Expressions.list(keySelector_,\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_INITIALIZER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_ADDER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_RESULT_SELECTOR.method,\n                          resultSelector_))\n                      .appendIfNotNull(keyPhysType.comparer()))));\n    }\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableAggregate.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":93,"status":"MB"}],"commitId":"bf9ff001db743bcba35943daf7fec5fe8b8b207e","commitMessage":"@@@[CALCITE-4008] Implement Code generation for EnumerableSortedAggregate (Rui Wang).\n","date":"2020-06-29 16:36:00","modifiedFileCount":"6","status":"M","submitter":"amaliujia"},{"authorTime":"2020-09-29 22:09:05","codes":[{"authorDate":"2020-09-29 22:09:05","commitOrder":17,"curCode":"  @Override public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    if (!Aggregate.isSimple(this)) {\n      throw Util.needToImplement(\"EnumerableSortedAggregate\");\n    }\n\n    final JavaTypeFactory typeFactory = implementor.getTypeFactory();\n    final BlockBuilder builder = new BlockBuilder();\n    final EnumerableRel child = (EnumerableRel) getInput();\n    final Result result = implementor.visitChild(this, 0, child, pref);\n    Expression childExp =\n        builder.append(\n            \"child\",\n            result.block);\n\n    final PhysType physType =\n        PhysTypeImpl.of(\n            typeFactory, getRowType(), pref.preferCustom());\n\n    final PhysType inputPhysType = result.physType;\n\n    ParameterExpression parameter =\n        Expressions.parameter(inputPhysType.getJavaRowType(), \"a0\");\n\n    final PhysType keyPhysType =\n        inputPhysType.project(groupSet.asList(), getGroupType() != Group.SIMPLE,\n            JavaRowFormat.LIST);\n    final int groupCount = getGroupCount();\n\n    final List<AggImpState> aggs = new ArrayList<>(aggCalls.size());\n    for (Ord<AggregateCall> call : Ord.zip(aggCalls)) {\n      aggs.add(new AggImpState(call.i, call.e, false));\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final List<Expression> initExpressions = new ArrayList<>();\n    final BlockBuilder initBlock = new BlockBuilder();\n\n    final List<Type> aggStateTypes = createAggStateTypes(\n        initExpressions, initBlock, aggs, typeFactory);\n\n    final PhysType accPhysType =\n        PhysTypeImpl.of(typeFactory,\n            typeFactory.createSyntheticType(aggStateTypes));\n\n    declareParentAccumulator(initExpressions, initBlock, accPhysType);\n\n    final Expression accumulatorInitializer =\n        builder.append(\"accumulatorInitializer\",\n            Expressions.lambda(\n                Function0.class,\n                initBlock.toBlock()));\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final ParameterExpression inParameter =\n        Expressions.parameter(inputPhysType.getJavaRowType(), \"in\");\n    final ParameterExpression acc_ =\n        Expressions.parameter(accPhysType.getJavaRowType(), \"acc\");\n\n    createAccumulatorAdders(\n        inParameter, aggs, accPhysType, acc_, inputPhysType, builder, implementor, typeFactory);\n\n    final ParameterExpression lambdaFactory =\n        Expressions.parameter(AggregateLambdaFactory.class,\n            builder.newName(\"lambdaFactory\"));\n\n    implementLambdaFactory(builder, inputPhysType, aggs, accumulatorInitializer,\n        false, lambdaFactory);\n\n    final BlockBuilder resultBlock = new BlockBuilder();\n    final List<Expression> results = Expressions.list();\n    final ParameterExpression key_;\n    final Type keyType = keyPhysType.getJavaRowType();\n    key_ = Expressions.parameter(keyType, \"key\");\n    for (int j = 0; j < groupCount; j++) {\n      final Expression ref = keyPhysType.fieldReference(key_, j);\n      results.add(ref);\n    }\n\n    for (final AggImpState agg : aggs) {\n      results.add(\n          agg.implementor.implementResult(agg.context,\n              new AggResultContextImpl(resultBlock, agg.call, agg.state, key_,\n                  keyPhysType)));\n    }\n    resultBlock.add(physType.record(results));\n\n    final Expression keySelector_ =\n        builder.append(\"keySelector\",\n            inputPhysType.generateSelector(parameter,\n                groupSet.asList(),\n                keyPhysType.getFormat()));\n    \r\n    \r\n    \r\n    final Expression comparator = keyPhysType.generateComparator(getTraitSet().getCollation());\n\n    final Expression resultSelector_ =\n        builder.append(\"resultSelector\",\n            Expressions.lambda(Function2.class,\n                resultBlock.toBlock(),\n                key_,\n                acc_));\n\n    builder.add(\n        Expressions.return_(null,\n            Expressions.call(childExp,\n                BuiltInMethod.SORTED_GROUP_BY.method,\n                Expressions.list(keySelector_,\n                    Expressions.call(lambdaFactory,\n                        BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_INITIALIZER.method),\n                    Expressions.call(lambdaFactory,\n                        BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_ADDER.method),\n                    Expressions.call(lambdaFactory,\n                        BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_RESULT_SELECTOR.method,\n                        resultSelector_), comparator)\n                    )));\n\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2020-10-07 05:42:47","endLine":233,"groupId":"2747","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/77/041dfccbe656eee8d386f6751fde1dafb8d935.src","preCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    if (!Aggregate.isSimple(this)) {\n      throw Util.needToImplement(\"EnumerableSortedAggregate\");\n    }\n\n    final JavaTypeFactory typeFactory = implementor.getTypeFactory();\n    final BlockBuilder builder = new BlockBuilder();\n    final EnumerableRel child = (EnumerableRel) getInput();\n    final Result result = implementor.visitChild(this, 0, child, pref);\n    Expression childExp =\n        builder.append(\n            \"child\",\n            result.block);\n\n    final PhysType physType =\n        PhysTypeImpl.of(\n            typeFactory, getRowType(), pref.preferCustom());\n\n    final PhysType inputPhysType = result.physType;\n\n    ParameterExpression parameter =\n        Expressions.parameter(inputPhysType.getJavaRowType(), \"a0\");\n\n    final PhysType keyPhysType =\n        inputPhysType.project(groupSet.asList(), getGroupType() != Group.SIMPLE,\n            JavaRowFormat.LIST);\n    final int groupCount = getGroupCount();\n\n    final List<AggImpState> aggs = new ArrayList<>(aggCalls.size());\n    for (Ord<AggregateCall> call : Ord.zip(aggCalls)) {\n      aggs.add(new AggImpState(call.i, call.e, false));\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final List<Expression> initExpressions = new ArrayList<>();\n    final BlockBuilder initBlock = new BlockBuilder();\n\n    final List<Type> aggStateTypes = createAggStateTypes(\n        initExpressions, initBlock, aggs, typeFactory);\n\n    final PhysType accPhysType =\n        PhysTypeImpl.of(typeFactory,\n            typeFactory.createSyntheticType(aggStateTypes));\n\n    declareParentAccumulator(initExpressions, initBlock, accPhysType);\n\n    final Expression accumulatorInitializer =\n        builder.append(\"accumulatorInitializer\",\n            Expressions.lambda(\n                Function0.class,\n                initBlock.toBlock()));\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final ParameterExpression inParameter =\n        Expressions.parameter(inputPhysType.getJavaRowType(), \"in\");\n    final ParameterExpression acc_ =\n        Expressions.parameter(accPhysType.getJavaRowType(), \"acc\");\n\n    createAccumulatorAdders(\n        inParameter, aggs, accPhysType, acc_, inputPhysType, builder, implementor, typeFactory);\n\n    final ParameterExpression lambdaFactory =\n        Expressions.parameter(AggregateLambdaFactory.class,\n            builder.newName(\"lambdaFactory\"));\n\n    implementLambdaFactory(builder, inputPhysType, aggs, accumulatorInitializer,\n        false, lambdaFactory);\n\n    final BlockBuilder resultBlock = new BlockBuilder();\n    final List<Expression> results = Expressions.list();\n    final ParameterExpression key_;\n    final Type keyType = keyPhysType.getJavaRowType();\n    key_ = Expressions.parameter(keyType, \"key\");\n    for (int j = 0; j < groupCount; j++) {\n      final Expression ref = keyPhysType.fieldReference(key_, j);\n      results.add(ref);\n    }\n\n    for (final AggImpState agg : aggs) {\n      results.add(\n          agg.implementor.implementResult(agg.context,\n              new AggResultContextImpl(resultBlock, agg.call, agg.state, key_,\n                  keyPhysType)));\n    }\n    resultBlock.add(physType.record(results));\n\n    final Expression keySelector_ =\n        builder.append(\"keySelector\",\n            inputPhysType.generateSelector(parameter,\n                groupSet.asList(),\n                keyPhysType.getFormat()));\n    \r\n    \r\n    \r\n    final Expression comparator = keyPhysType.generateComparator(getTraitSet().getCollation());\n\n    final Expression resultSelector_ =\n        builder.append(\"resultSelector\",\n            Expressions.lambda(Function2.class,\n                resultBlock.toBlock(),\n                key_,\n                acc_));\n\n    builder.add(\n        Expressions.return_(null,\n            Expressions.call(childExp,\n                BuiltInMethod.SORTED_GROUP_BY.method,\n                Expressions.list(keySelector_,\n                    Expressions.call(lambdaFactory,\n                        BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_INITIALIZER.method),\n                    Expressions.call(lambdaFactory,\n                        BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_ADDER.method),\n                    Expressions.call(lambdaFactory,\n                        BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_RESULT_SELECTOR.method,\n                        resultSelector_), comparator)\n                    )));\n\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableSortedAggregate.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":103,"status":"M"},{"authorDate":"2020-09-29 22:09:05","commitOrder":17,"curCode":"  @Override public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final JavaTypeFactory typeFactory = implementor.getTypeFactory();\n    final BlockBuilder builder = new BlockBuilder();\n    final EnumerableRel child = (EnumerableRel) getInput();\n    final Result result = implementor.visitChild(this, 0, child, pref);\n    Expression childExp =\n        builder.append(\n            \"child\",\n            result.block);\n\n    final PhysType physType =\n        PhysTypeImpl.of(\n            typeFactory, getRowType(), pref.preferCustom());\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    final PhysType inputPhysType = result.physType;\n\n    ParameterExpression parameter =\n        Expressions.parameter(inputPhysType.getJavaRowType(), \"a0\");\n\n    final PhysType keyPhysType =\n        inputPhysType.project(groupSet.asList(), getGroupType() != Group.SIMPLE,\n            JavaRowFormat.LIST);\n    final int groupCount = getGroupCount();\n\n    final List<AggImpState> aggs = new ArrayList<>(aggCalls.size());\n    for (Ord<AggregateCall> call : Ord.zip(aggCalls)) {\n      aggs.add(new AggImpState(call.i, call.e, false));\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final List<Expression> initExpressions = new ArrayList<>();\n    final BlockBuilder initBlock = new BlockBuilder();\n\n    final List<Type> aggStateTypes = createAggStateTypes(\n        initExpressions, initBlock, aggs, typeFactory);\n\n    final PhysType accPhysType =\n        PhysTypeImpl.of(typeFactory,\n            typeFactory.createSyntheticType(aggStateTypes));\n\n    declareParentAccumulator(initExpressions, initBlock, accPhysType);\n\n    final Expression accumulatorInitializer =\n        builder.append(\"accumulatorInitializer\",\n            Expressions.lambda(\n                Function0.class,\n                initBlock.toBlock()));\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final ParameterExpression inParameter =\n        Expressions.parameter(inputPhysType.getJavaRowType(), \"in\");\n    final ParameterExpression acc_ =\n        Expressions.parameter(accPhysType.getJavaRowType(), \"acc\");\n\n    createAccumulatorAdders(\n        inParameter, aggs, accPhysType, acc_, inputPhysType, builder, implementor, typeFactory);\n\n    final ParameterExpression lambdaFactory =\n        Expressions.parameter(AggregateLambdaFactory.class,\n            builder.newName(\"lambdaFactory\"));\n\n    implementLambdaFactory(builder, inputPhysType, aggs, accumulatorInitializer,\n        hasOrderedCall(aggs), lambdaFactory);\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final BlockBuilder resultBlock = new BlockBuilder();\n    final List<Expression> results = Expressions.list();\n    final ParameterExpression key_;\n    if (groupCount == 0) {\n      key_ = null;\n    } else {\n      final Type keyType = keyPhysType.getJavaRowType();\n      key_ = Expressions.parameter(keyType, \"key\");\n      for (int j = 0; j < groupCount; j++) {\n        final Expression ref = keyPhysType.fieldReference(key_, j);\n        if (getGroupType() == Group.SIMPLE) {\n          results.add(ref);\n        } else {\n          results.add(\n              Expressions.condition(\n                  keyPhysType.fieldReference(key_, groupCount + j),\n                  Expressions.constant(null),\n                  Expressions.box(ref)));\n        }\n      }\n    }\n    for (final AggImpState agg : aggs) {\n      results.add(\n          agg.implementor.implementResult(agg.context,\n              new AggResultContextImpl(resultBlock, agg.call, agg.state, key_,\n                  keyPhysType)));\n    }\n    resultBlock.add(physType.record(results));\n    if (getGroupType() != Group.SIMPLE) {\n      final List<Expression> list = new ArrayList<>();\n      for (ImmutableBitSet set : groupSets) {\n        list.add(\n            inputPhysType.generateSelector(parameter, groupSet.asList(),\n                set.asList(), keyPhysType.getFormat()));\n      }\n      final Expression keySelectors_ =\n          builder.append(\"keySelectors\",\n              Expressions.call(BuiltInMethod.ARRAYS_AS_LIST.method,\n                  list));\n      final Expression resultSelector =\n          builder.append(\"resultSelector\",\n              Expressions.lambda(Function2.class,\n                  resultBlock.toBlock(),\n                  key_,\n                  acc_));\n      builder.add(\n          Expressions.return_(null,\n              Expressions.call(\n                  BuiltInMethod.GROUP_BY_MULTIPLE.method,\n                  Expressions.list(childExp,\n                      keySelectors_,\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_INITIALIZER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_ADDER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_RESULT_SELECTOR.method,\n                          resultSelector))\n                      .appendIfNotNull(keyPhysType.comparer()))));\n    } else if (groupCount == 0) {\n      final Expression resultSelector =\n          builder.append(\n              \"resultSelector\",\n              Expressions.lambda(\n                  Function1.class,\n                  resultBlock.toBlock(),\n                  acc_));\n      builder.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  BuiltInMethod.SINGLETON_ENUMERABLE.method,\n                  Expressions.call(\n                      childExp,\n                      BuiltInMethod.AGGREGATE.method,\n                      Expressions.call(\n                          Expressions.call(lambdaFactory,\n                              BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_INITIALIZER.method),\n                          BuiltInMethod.FUNCTION0_APPLY.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_ADDER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_SINGLE_GROUP_RESULT_SELECTOR.method,\n                          resultSelector)))));\n    } else if (aggCalls.isEmpty()\n        && groupSet.equals(\n            ImmutableBitSet.range(child.getRowType().getFieldCount()))) {\n      builder.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  inputPhysType.convertTo(childExp, physType.getFormat()),\n                  BuiltInMethod.DISTINCT.method,\n                  Expressions.<Expression>list()\n                      .appendIfNotNull(physType.comparer()))));\n    } else {\n      final Expression keySelector_ =\n          builder.append(\"keySelector\",\n              inputPhysType.generateSelector(parameter,\n                  groupSet.asList(),\n                  keyPhysType.getFormat()));\n      final Expression resultSelector_ =\n          builder.append(\"resultSelector\",\n              Expressions.lambda(Function2.class,\n                  resultBlock.toBlock(),\n                  key_,\n                  acc_));\n      builder.add(\n          Expressions.return_(null,\n              Expressions.call(childExp,\n                  BuiltInMethod.GROUP_BY2.method,\n                  Expressions.list(keySelector_,\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_INITIALIZER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_ADDER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_RESULT_SELECTOR.method,\n                          resultSelector_))\n                      .appendIfNotNull(keyPhysType.comparer()))));\n    }\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2020-10-07 05:42:47","endLine":355,"groupId":"1708","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/8a/4d49921063f521d865433891faae2542841a4f.src","preCode":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final JavaTypeFactory typeFactory = implementor.getTypeFactory();\n    final BlockBuilder builder = new BlockBuilder();\n    final EnumerableRel child = (EnumerableRel) getInput();\n    final Result result = implementor.visitChild(this, 0, child, pref);\n    Expression childExp =\n        builder.append(\n            \"child\",\n            result.block);\n\n    final PhysType physType =\n        PhysTypeImpl.of(\n            typeFactory, getRowType(), pref.preferCustom());\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    final PhysType inputPhysType = result.physType;\n\n    ParameterExpression parameter =\n        Expressions.parameter(inputPhysType.getJavaRowType(), \"a0\");\n\n    final PhysType keyPhysType =\n        inputPhysType.project(groupSet.asList(), getGroupType() != Group.SIMPLE,\n            JavaRowFormat.LIST);\n    final int groupCount = getGroupCount();\n\n    final List<AggImpState> aggs = new ArrayList<>(aggCalls.size());\n    for (Ord<AggregateCall> call : Ord.zip(aggCalls)) {\n      aggs.add(new AggImpState(call.i, call.e, false));\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final List<Expression> initExpressions = new ArrayList<>();\n    final BlockBuilder initBlock = new BlockBuilder();\n\n    final List<Type> aggStateTypes = createAggStateTypes(\n        initExpressions, initBlock, aggs, typeFactory);\n\n    final PhysType accPhysType =\n        PhysTypeImpl.of(typeFactory,\n            typeFactory.createSyntheticType(aggStateTypes));\n\n    declareParentAccumulator(initExpressions, initBlock, accPhysType);\n\n    final Expression accumulatorInitializer =\n        builder.append(\"accumulatorInitializer\",\n            Expressions.lambda(\n                Function0.class,\n                initBlock.toBlock()));\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final ParameterExpression inParameter =\n        Expressions.parameter(inputPhysType.getJavaRowType(), \"in\");\n    final ParameterExpression acc_ =\n        Expressions.parameter(accPhysType.getJavaRowType(), \"acc\");\n\n    createAccumulatorAdders(\n        inParameter, aggs, accPhysType, acc_, inputPhysType, builder, implementor, typeFactory);\n\n    final ParameterExpression lambdaFactory =\n        Expressions.parameter(AggregateLambdaFactory.class,\n            builder.newName(\"lambdaFactory\"));\n\n    implementLambdaFactory(builder, inputPhysType, aggs, accumulatorInitializer,\n        hasOrderedCall(aggs), lambdaFactory);\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final BlockBuilder resultBlock = new BlockBuilder();\n    final List<Expression> results = Expressions.list();\n    final ParameterExpression key_;\n    if (groupCount == 0) {\n      key_ = null;\n    } else {\n      final Type keyType = keyPhysType.getJavaRowType();\n      key_ = Expressions.parameter(keyType, \"key\");\n      for (int j = 0; j < groupCount; j++) {\n        final Expression ref = keyPhysType.fieldReference(key_, j);\n        if (getGroupType() == Group.SIMPLE) {\n          results.add(ref);\n        } else {\n          results.add(\n              Expressions.condition(\n                  keyPhysType.fieldReference(key_, groupCount + j),\n                  Expressions.constant(null),\n                  Expressions.box(ref)));\n        }\n      }\n    }\n    for (final AggImpState agg : aggs) {\n      results.add(\n          agg.implementor.implementResult(agg.context,\n              new AggResultContextImpl(resultBlock, agg.call, agg.state, key_,\n                  keyPhysType)));\n    }\n    resultBlock.add(physType.record(results));\n    if (getGroupType() != Group.SIMPLE) {\n      final List<Expression> list = new ArrayList<>();\n      for (ImmutableBitSet set : groupSets) {\n        list.add(\n            inputPhysType.generateSelector(parameter, groupSet.asList(),\n                set.asList(), keyPhysType.getFormat()));\n      }\n      final Expression keySelectors_ =\n          builder.append(\"keySelectors\",\n              Expressions.call(BuiltInMethod.ARRAYS_AS_LIST.method,\n                  list));\n      final Expression resultSelector =\n          builder.append(\"resultSelector\",\n              Expressions.lambda(Function2.class,\n                  resultBlock.toBlock(),\n                  key_,\n                  acc_));\n      builder.add(\n          Expressions.return_(null,\n              Expressions.call(\n                  BuiltInMethod.GROUP_BY_MULTIPLE.method,\n                  Expressions.list(childExp,\n                      keySelectors_,\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_INITIALIZER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_ADDER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_RESULT_SELECTOR.method,\n                          resultSelector))\n                      .appendIfNotNull(keyPhysType.comparer()))));\n    } else if (groupCount == 0) {\n      final Expression resultSelector =\n          builder.append(\n              \"resultSelector\",\n              Expressions.lambda(\n                  Function1.class,\n                  resultBlock.toBlock(),\n                  acc_));\n      builder.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  BuiltInMethod.SINGLETON_ENUMERABLE.method,\n                  Expressions.call(\n                      childExp,\n                      BuiltInMethod.AGGREGATE.method,\n                      Expressions.call(\n                          Expressions.call(lambdaFactory,\n                              BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_INITIALIZER.method),\n                          BuiltInMethod.FUNCTION0_APPLY.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_ADDER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_SINGLE_GROUP_RESULT_SELECTOR.method,\n                          resultSelector)))));\n    } else if (aggCalls.isEmpty()\n        && groupSet.equals(\n            ImmutableBitSet.range(child.getRowType().getFieldCount()))) {\n      builder.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  inputPhysType.convertTo(childExp, physType.getFormat()),\n                  BuiltInMethod.DISTINCT.method,\n                  Expressions.<Expression>list()\n                      .appendIfNotNull(physType.comparer()))));\n    } else {\n      final Expression keySelector_ =\n          builder.append(\"keySelector\",\n              inputPhysType.generateSelector(parameter,\n                  groupSet.asList(),\n                  keyPhysType.getFormat()));\n      final Expression resultSelector_ =\n          builder.append(\"resultSelector\",\n              Expressions.lambda(Function2.class,\n                  resultBlock.toBlock(),\n                  key_,\n                  acc_));\n      builder.add(\n          Expressions.return_(null,\n              Expressions.call(childExp,\n                  BuiltInMethod.GROUP_BY2.method,\n                  Expressions.list(keySelector_,\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_INITIALIZER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_ADDER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_RESULT_SELECTOR.method,\n                          resultSelector_))\n                      .appendIfNotNull(keyPhysType.comparer()))));\n    }\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableAggregate.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":93,"status":"M"}],"commitId":"66caa54c5e272f8287ca132ca012733898a38768","commitMessage":"@@@[CALCITE-4314] Add missing @Override annotations\n","date":"2020-10-07 05:42:47","modifiedFileCount":"745","status":"M","submitter":"Vladimir Sitnikov"},{"authorTime":"2020-05-29 00:04:40","codes":[{"authorDate":"2020-05-29 00:04:40","commitOrder":18,"curCode":"  @Override public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    if (!Aggregate.isSimple(this)) {\n      throw Util.needToImplement(\"EnumerableSortedAggregate\");\n    }\n\n    final JavaTypeFactory typeFactory = implementor.getTypeFactory();\n    final BlockBuilder builder = new BlockBuilder();\n    final EnumerableRel child = (EnumerableRel) getInput();\n    final Result result = implementor.visitChild(this, 0, child, pref);\n    Expression childExp =\n        builder.append(\n            \"child\",\n            result.block);\n\n    final PhysType physType =\n        PhysTypeImpl.of(\n            typeFactory, getRowType(), pref.preferCustom());\n\n    final PhysType inputPhysType = result.physType;\n\n    ParameterExpression parameter =\n        Expressions.parameter(inputPhysType.getJavaRowType(), \"a0\");\n\n    final PhysType keyPhysType =\n        inputPhysType.project(groupSet.asList(), getGroupType() != Group.SIMPLE,\n            JavaRowFormat.LIST);\n    final int groupCount = getGroupCount();\n\n    final List<AggImpState> aggs = new ArrayList<>(aggCalls.size());\n    for (Ord<AggregateCall> call : Ord.zip(aggCalls)) {\n      aggs.add(new AggImpState(call.i, call.e, false));\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final List<Expression> initExpressions = new ArrayList<>();\n    final BlockBuilder initBlock = new BlockBuilder();\n\n    final List<Type> aggStateTypes = createAggStateTypes(\n        initExpressions, initBlock, aggs, typeFactory);\n\n    final PhysType accPhysType =\n        PhysTypeImpl.of(typeFactory,\n            typeFactory.createSyntheticType(aggStateTypes));\n\n    declareParentAccumulator(initExpressions, initBlock, accPhysType);\n\n    final Expression accumulatorInitializer =\n        builder.append(\"accumulatorInitializer\",\n            Expressions.lambda(\n                Function0.class,\n                initBlock.toBlock()));\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final ParameterExpression inParameter =\n        Expressions.parameter(inputPhysType.getJavaRowType(), \"in\");\n    final ParameterExpression acc_ =\n        Expressions.parameter(accPhysType.getJavaRowType(), \"acc\");\n\n    createAccumulatorAdders(\n        inParameter, aggs, accPhysType, acc_, inputPhysType, builder, implementor, typeFactory);\n\n    final ParameterExpression lambdaFactory =\n        Expressions.parameter(AggregateLambdaFactory.class,\n            builder.newName(\"lambdaFactory\"));\n\n    implementLambdaFactory(builder, inputPhysType, aggs, accumulatorInitializer,\n        false, lambdaFactory);\n\n    final BlockBuilder resultBlock = new BlockBuilder();\n    final List<Expression> results = Expressions.list();\n    final ParameterExpression key_;\n    final Type keyType = keyPhysType.getJavaRowType();\n    key_ = Expressions.parameter(keyType, \"key\");\n    for (int j = 0; j < groupCount; j++) {\n      final Expression ref = keyPhysType.fieldReference(key_, j);\n      results.add(ref);\n    }\n\n    for (final AggImpState agg : aggs) {\n      results.add(\n          agg.implementor.implementResult(\n              requireNonNull(agg.context, () -> \"agg.context is null for \" + agg),\n              new AggResultContextImpl(resultBlock, agg.call,\n                  requireNonNull(agg.state, () -> \"agg.state is null for \" + agg),\n                  key_,\n                  keyPhysType)));\n    }\n    resultBlock.add(physType.record(results));\n\n    final Expression keySelector_ =\n        builder.append(\"keySelector\",\n            inputPhysType.generateSelector(parameter,\n                groupSet.asList(),\n                keyPhysType.getFormat()));\n    \r\n    \r\n    \r\n    final Expression comparator = keyPhysType.generateComparator(\n        requireNonNull(getTraitSet().getCollation(),\n            () -> \"getTraitSet().getCollation() is null, current traits are \" + getTraitSet()));\n\n    final Expression resultSelector_ =\n        builder.append(\"resultSelector\",\n            Expressions.lambda(Function2.class,\n                resultBlock.toBlock(),\n                key_,\n                acc_));\n\n    builder.add(\n        Expressions.return_(null,\n            Expressions.call(childExp,\n                BuiltInMethod.SORTED_GROUP_BY.method,\n                Expressions.list(keySelector_,\n                    Expressions.call(lambdaFactory,\n                        BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_INITIALIZER.method),\n                    Expressions.call(lambdaFactory,\n                        BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_ADDER.method),\n                    Expressions.call(lambdaFactory,\n                        BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_RESULT_SELECTOR.method,\n                        resultSelector_), comparator)\n                    )));\n\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2020-11-30 06:45:33","endLine":243,"groupId":"102130","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/2f/03b3552c4fef4f04f0f4ba84179e617bd7b6bd.src","preCode":"  @Override public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    if (!Aggregate.isSimple(this)) {\n      throw Util.needToImplement(\"EnumerableSortedAggregate\");\n    }\n\n    final JavaTypeFactory typeFactory = implementor.getTypeFactory();\n    final BlockBuilder builder = new BlockBuilder();\n    final EnumerableRel child = (EnumerableRel) getInput();\n    final Result result = implementor.visitChild(this, 0, child, pref);\n    Expression childExp =\n        builder.append(\n            \"child\",\n            result.block);\n\n    final PhysType physType =\n        PhysTypeImpl.of(\n            typeFactory, getRowType(), pref.preferCustom());\n\n    final PhysType inputPhysType = result.physType;\n\n    ParameterExpression parameter =\n        Expressions.parameter(inputPhysType.getJavaRowType(), \"a0\");\n\n    final PhysType keyPhysType =\n        inputPhysType.project(groupSet.asList(), getGroupType() != Group.SIMPLE,\n            JavaRowFormat.LIST);\n    final int groupCount = getGroupCount();\n\n    final List<AggImpState> aggs = new ArrayList<>(aggCalls.size());\n    for (Ord<AggregateCall> call : Ord.zip(aggCalls)) {\n      aggs.add(new AggImpState(call.i, call.e, false));\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final List<Expression> initExpressions = new ArrayList<>();\n    final BlockBuilder initBlock = new BlockBuilder();\n\n    final List<Type> aggStateTypes = createAggStateTypes(\n        initExpressions, initBlock, aggs, typeFactory);\n\n    final PhysType accPhysType =\n        PhysTypeImpl.of(typeFactory,\n            typeFactory.createSyntheticType(aggStateTypes));\n\n    declareParentAccumulator(initExpressions, initBlock, accPhysType);\n\n    final Expression accumulatorInitializer =\n        builder.append(\"accumulatorInitializer\",\n            Expressions.lambda(\n                Function0.class,\n                initBlock.toBlock()));\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final ParameterExpression inParameter =\n        Expressions.parameter(inputPhysType.getJavaRowType(), \"in\");\n    final ParameterExpression acc_ =\n        Expressions.parameter(accPhysType.getJavaRowType(), \"acc\");\n\n    createAccumulatorAdders(\n        inParameter, aggs, accPhysType, acc_, inputPhysType, builder, implementor, typeFactory);\n\n    final ParameterExpression lambdaFactory =\n        Expressions.parameter(AggregateLambdaFactory.class,\n            builder.newName(\"lambdaFactory\"));\n\n    implementLambdaFactory(builder, inputPhysType, aggs, accumulatorInitializer,\n        false, lambdaFactory);\n\n    final BlockBuilder resultBlock = new BlockBuilder();\n    final List<Expression> results = Expressions.list();\n    final ParameterExpression key_;\n    final Type keyType = keyPhysType.getJavaRowType();\n    key_ = Expressions.parameter(keyType, \"key\");\n    for (int j = 0; j < groupCount; j++) {\n      final Expression ref = keyPhysType.fieldReference(key_, j);\n      results.add(ref);\n    }\n\n    for (final AggImpState agg : aggs) {\n      results.add(\n          agg.implementor.implementResult(agg.context,\n              new AggResultContextImpl(resultBlock, agg.call, agg.state, key_,\n                  keyPhysType)));\n    }\n    resultBlock.add(physType.record(results));\n\n    final Expression keySelector_ =\n        builder.append(\"keySelector\",\n            inputPhysType.generateSelector(parameter,\n                groupSet.asList(),\n                keyPhysType.getFormat()));\n    \r\n    \r\n    \r\n    final Expression comparator = keyPhysType.generateComparator(getTraitSet().getCollation());\n\n    final Expression resultSelector_ =\n        builder.append(\"resultSelector\",\n            Expressions.lambda(Function2.class,\n                resultBlock.toBlock(),\n                key_,\n                acc_));\n\n    builder.add(\n        Expressions.return_(null,\n            Expressions.call(childExp,\n                BuiltInMethod.SORTED_GROUP_BY.method,\n                Expressions.list(keySelector_,\n                    Expressions.call(lambdaFactory,\n                        BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_INITIALIZER.method),\n                    Expressions.call(lambdaFactory,\n                        BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_ADDER.method),\n                    Expressions.call(lambdaFactory,\n                        BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_RESULT_SELECTOR.method,\n                        resultSelector_), comparator)\n                    )));\n\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableSortedAggregate.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":108,"status":"M"},{"authorDate":"2020-05-29 00:04:40","commitOrder":18,"curCode":"  @Override public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final JavaTypeFactory typeFactory = implementor.getTypeFactory();\n    final BlockBuilder builder = new BlockBuilder();\n    final EnumerableRel child = (EnumerableRel) getInput();\n    final Result result = implementor.visitChild(this, 0, child, pref);\n    Expression childExp =\n        builder.append(\n            \"child\",\n            result.block);\n\n    final PhysType physType =\n        PhysTypeImpl.of(\n            typeFactory, getRowType(), pref.preferCustom());\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    final PhysType inputPhysType = result.physType;\n\n    ParameterExpression parameter =\n        Expressions.parameter(inputPhysType.getJavaRowType(), \"a0\");\n\n    final PhysType keyPhysType =\n        inputPhysType.project(groupSet.asList(), getGroupType() != Group.SIMPLE,\n            JavaRowFormat.LIST);\n    final int groupCount = getGroupCount();\n\n    final List<AggImpState> aggs = new ArrayList<>(aggCalls.size());\n    for (Ord<AggregateCall> call : Ord.zip(aggCalls)) {\n      aggs.add(new AggImpState(call.i, call.e, false));\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final List<Expression> initExpressions = new ArrayList<>();\n    final BlockBuilder initBlock = new BlockBuilder();\n\n    final List<Type> aggStateTypes = createAggStateTypes(\n        initExpressions, initBlock, aggs, typeFactory);\n\n    final PhysType accPhysType =\n        PhysTypeImpl.of(typeFactory,\n            typeFactory.createSyntheticType(aggStateTypes));\n\n    declareParentAccumulator(initExpressions, initBlock, accPhysType);\n\n    final Expression accumulatorInitializer =\n        builder.append(\"accumulatorInitializer\",\n            Expressions.lambda(\n                Function0.class,\n                initBlock.toBlock()));\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final ParameterExpression inParameter =\n        Expressions.parameter(inputPhysType.getJavaRowType(), \"in\");\n    final ParameterExpression acc_ =\n        Expressions.parameter(accPhysType.getJavaRowType(), \"acc\");\n\n    createAccumulatorAdders(\n        inParameter, aggs, accPhysType, acc_, inputPhysType, builder, implementor, typeFactory);\n\n    final ParameterExpression lambdaFactory =\n        Expressions.parameter(AggregateLambdaFactory.class,\n            builder.newName(\"lambdaFactory\"));\n\n    implementLambdaFactory(builder, inputPhysType, aggs, accumulatorInitializer,\n        hasOrderedCall(aggs), lambdaFactory);\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final BlockBuilder resultBlock = new BlockBuilder();\n    final List<Expression> results = Expressions.list();\n    final ParameterExpression key_;\n    if (groupCount == 0) {\n      key_ = null;\n    } else {\n      final Type keyType = keyPhysType.getJavaRowType();\n      key_ = Expressions.parameter(keyType, \"key\");\n      for (int j = 0; j < groupCount; j++) {\n        final Expression ref = keyPhysType.fieldReference(key_, j);\n        if (getGroupType() == Group.SIMPLE) {\n          results.add(ref);\n        } else {\n          results.add(\n              Expressions.condition(\n                  keyPhysType.fieldReference(key_, groupCount + j),\n                  Expressions.constant(null),\n                  Expressions.box(ref)));\n        }\n      }\n    }\n    for (final AggImpState agg : aggs) {\n      results.add(\n          agg.implementor.implementResult(requireNonNull(agg.context, \"agg.context\"),\n              new AggResultContextImpl(resultBlock, agg.call,\n                  requireNonNull(agg.state, \"agg.state\"), key_,\n                  keyPhysType)));\n    }\n    resultBlock.add(physType.record(results));\n    if (getGroupType() != Group.SIMPLE) {\n      final List<Expression> list = new ArrayList<>();\n      for (ImmutableBitSet set : groupSets) {\n        list.add(\n            inputPhysType.generateSelector(parameter, groupSet.asList(),\n                set.asList(), keyPhysType.getFormat()));\n      }\n      final Expression keySelectors_ =\n          builder.append(\"keySelectors\",\n              Expressions.call(BuiltInMethod.ARRAYS_AS_LIST.method,\n                  list));\n      final Expression resultSelector =\n          builder.append(\"resultSelector\",\n              Expressions.lambda(Function2.class,\n                  resultBlock.toBlock(),\n                  requireNonNull(key_, \"key_\"),\n                  acc_));\n      builder.add(\n          Expressions.return_(null,\n              Expressions.call(\n                  BuiltInMethod.GROUP_BY_MULTIPLE.method,\n                  Expressions.list(childExp,\n                      keySelectors_,\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_INITIALIZER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_ADDER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_RESULT_SELECTOR.method,\n                          resultSelector))\n                      .appendIfNotNull(keyPhysType.comparer()))));\n    } else if (groupCount == 0) {\n      final Expression resultSelector =\n          builder.append(\n              \"resultSelector\",\n              Expressions.lambda(\n                  Function1.class,\n                  resultBlock.toBlock(),\n                  acc_));\n      builder.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  BuiltInMethod.SINGLETON_ENUMERABLE.method,\n                  Expressions.call(\n                      childExp,\n                      BuiltInMethod.AGGREGATE.method,\n                      Expressions.call(\n                          Expressions.call(lambdaFactory,\n                              BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_INITIALIZER.method),\n                          BuiltInMethod.FUNCTION0_APPLY.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_ADDER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_SINGLE_GROUP_RESULT_SELECTOR.method,\n                          resultSelector)))));\n    } else if (aggCalls.isEmpty()\n        && groupSet.equals(\n            ImmutableBitSet.range(child.getRowType().getFieldCount()))) {\n      builder.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  inputPhysType.convertTo(childExp, physType.getFormat()),\n                  BuiltInMethod.DISTINCT.method,\n                  Expressions.<Expression>list()\n                      .appendIfNotNull(physType.comparer()))));\n    } else {\n      final Expression keySelector_ =\n          builder.append(\"keySelector\",\n              inputPhysType.generateSelector(parameter,\n                  groupSet.asList(),\n                  keyPhysType.getFormat()));\n      final Expression resultSelector_ =\n          builder.append(\"resultSelector\",\n              Expressions.lambda(Function2.class,\n                  resultBlock.toBlock(),\n                  requireNonNull(key_, \"key_\"),\n                  acc_));\n      builder.add(\n          Expressions.return_(null,\n              Expressions.call(childExp,\n                  BuiltInMethod.GROUP_BY2.method,\n                  Expressions.list(keySelector_,\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_INITIALIZER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_ADDER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_RESULT_SELECTOR.method,\n                          resultSelector_))\n                      .appendIfNotNull(keyPhysType.comparer()))));\n    }\n    return implementor.result(physType, builder.toBlock());\n  }\n","date":"2020-11-30 06:45:33","endLine":360,"groupId":"102130","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"implement","params":"(EnumerableRelImplementorimplementor@Preferpref)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/14/a9c8e0df462840ebb2005304edaa62ff7a7ab0.src","preCode":"  @Override public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    final JavaTypeFactory typeFactory = implementor.getTypeFactory();\n    final BlockBuilder builder = new BlockBuilder();\n    final EnumerableRel child = (EnumerableRel) getInput();\n    final Result result = implementor.visitChild(this, 0, child, pref);\n    Expression childExp =\n        builder.append(\n            \"child\",\n            result.block);\n\n    final PhysType physType =\n        PhysTypeImpl.of(\n            typeFactory, getRowType(), pref.preferCustom());\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    final PhysType inputPhysType = result.physType;\n\n    ParameterExpression parameter =\n        Expressions.parameter(inputPhysType.getJavaRowType(), \"a0\");\n\n    final PhysType keyPhysType =\n        inputPhysType.project(groupSet.asList(), getGroupType() != Group.SIMPLE,\n            JavaRowFormat.LIST);\n    final int groupCount = getGroupCount();\n\n    final List<AggImpState> aggs = new ArrayList<>(aggCalls.size());\n    for (Ord<AggregateCall> call : Ord.zip(aggCalls)) {\n      aggs.add(new AggImpState(call.i, call.e, false));\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final List<Expression> initExpressions = new ArrayList<>();\n    final BlockBuilder initBlock = new BlockBuilder();\n\n    final List<Type> aggStateTypes = createAggStateTypes(\n        initExpressions, initBlock, aggs, typeFactory);\n\n    final PhysType accPhysType =\n        PhysTypeImpl.of(typeFactory,\n            typeFactory.createSyntheticType(aggStateTypes));\n\n    declareParentAccumulator(initExpressions, initBlock, accPhysType);\n\n    final Expression accumulatorInitializer =\n        builder.append(\"accumulatorInitializer\",\n            Expressions.lambda(\n                Function0.class,\n                initBlock.toBlock()));\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final ParameterExpression inParameter =\n        Expressions.parameter(inputPhysType.getJavaRowType(), \"in\");\n    final ParameterExpression acc_ =\n        Expressions.parameter(accPhysType.getJavaRowType(), \"acc\");\n\n    createAccumulatorAdders(\n        inParameter, aggs, accPhysType, acc_, inputPhysType, builder, implementor, typeFactory);\n\n    final ParameterExpression lambdaFactory =\n        Expressions.parameter(AggregateLambdaFactory.class,\n            builder.newName(\"lambdaFactory\"));\n\n    implementLambdaFactory(builder, inputPhysType, aggs, accumulatorInitializer,\n        hasOrderedCall(aggs), lambdaFactory);\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    final BlockBuilder resultBlock = new BlockBuilder();\n    final List<Expression> results = Expressions.list();\n    final ParameterExpression key_;\n    if (groupCount == 0) {\n      key_ = null;\n    } else {\n      final Type keyType = keyPhysType.getJavaRowType();\n      key_ = Expressions.parameter(keyType, \"key\");\n      for (int j = 0; j < groupCount; j++) {\n        final Expression ref = keyPhysType.fieldReference(key_, j);\n        if (getGroupType() == Group.SIMPLE) {\n          results.add(ref);\n        } else {\n          results.add(\n              Expressions.condition(\n                  keyPhysType.fieldReference(key_, groupCount + j),\n                  Expressions.constant(null),\n                  Expressions.box(ref)));\n        }\n      }\n    }\n    for (final AggImpState agg : aggs) {\n      results.add(\n          agg.implementor.implementResult(agg.context,\n              new AggResultContextImpl(resultBlock, agg.call, agg.state, key_,\n                  keyPhysType)));\n    }\n    resultBlock.add(physType.record(results));\n    if (getGroupType() != Group.SIMPLE) {\n      final List<Expression> list = new ArrayList<>();\n      for (ImmutableBitSet set : groupSets) {\n        list.add(\n            inputPhysType.generateSelector(parameter, groupSet.asList(),\n                set.asList(), keyPhysType.getFormat()));\n      }\n      final Expression keySelectors_ =\n          builder.append(\"keySelectors\",\n              Expressions.call(BuiltInMethod.ARRAYS_AS_LIST.method,\n                  list));\n      final Expression resultSelector =\n          builder.append(\"resultSelector\",\n              Expressions.lambda(Function2.class,\n                  resultBlock.toBlock(),\n                  key_,\n                  acc_));\n      builder.add(\n          Expressions.return_(null,\n              Expressions.call(\n                  BuiltInMethod.GROUP_BY_MULTIPLE.method,\n                  Expressions.list(childExp,\n                      keySelectors_,\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_INITIALIZER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_ADDER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_RESULT_SELECTOR.method,\n                          resultSelector))\n                      .appendIfNotNull(keyPhysType.comparer()))));\n    } else if (groupCount == 0) {\n      final Expression resultSelector =\n          builder.append(\n              \"resultSelector\",\n              Expressions.lambda(\n                  Function1.class,\n                  resultBlock.toBlock(),\n                  acc_));\n      builder.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  BuiltInMethod.SINGLETON_ENUMERABLE.method,\n                  Expressions.call(\n                      childExp,\n                      BuiltInMethod.AGGREGATE.method,\n                      Expressions.call(\n                          Expressions.call(lambdaFactory,\n                              BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_INITIALIZER.method),\n                          BuiltInMethod.FUNCTION0_APPLY.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_ADDER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_SINGLE_GROUP_RESULT_SELECTOR.method,\n                          resultSelector)))));\n    } else if (aggCalls.isEmpty()\n        && groupSet.equals(\n            ImmutableBitSet.range(child.getRowType().getFieldCount()))) {\n      builder.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  inputPhysType.convertTo(childExp, physType.getFormat()),\n                  BuiltInMethod.DISTINCT.method,\n                  Expressions.<Expression>list()\n                      .appendIfNotNull(physType.comparer()))));\n    } else {\n      final Expression keySelector_ =\n          builder.append(\"keySelector\",\n              inputPhysType.generateSelector(parameter,\n                  groupSet.asList(),\n                  keyPhysType.getFormat()));\n      final Expression resultSelector_ =\n          builder.append(\"resultSelector\",\n              Expressions.lambda(Function2.class,\n                  resultBlock.toBlock(),\n                  key_,\n                  acc_));\n      builder.add(\n          Expressions.return_(null,\n              Expressions.call(childExp,\n                  BuiltInMethod.GROUP_BY2.method,\n                  Expressions.list(keySelector_,\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_INITIALIZER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_ADDER.method),\n                      Expressions.call(lambdaFactory,\n                          BuiltInMethod.AGG_LAMBDA_FACTORY_ACC_RESULT_SELECTOR.method,\n                          resultSelector_))\n                      .appendIfNotNull(keyPhysType.comparer()))));\n    }\n    return implementor.result(physType, builder.toBlock());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableAggregate.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":97,"status":"M"}],"commitId":"d9a81b88ad561e7e4cedae93e805e0d7a53a7f1a","commitMessage":"@@@[CALCITE-4199] Add nullability annotations\n\nThe commit includes javadoc updates and refactorings made by Julian Hyde in https://github.com/apache/calcite/pull/2278\n","date":"2020-11-30 06:45:33","modifiedFileCount":"1012","status":"M","submitter":"Vladimir Sitnikov"}]
