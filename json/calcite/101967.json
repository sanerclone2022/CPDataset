[{"authorTime":"2014-11-14 09:39:29","codes":[{"authorDate":"2014-11-14 09:39:29","commitOrder":1,"curCode":"  private void onMatchRight(RelOptRuleCall call) {\n    final JoinRelBase topJoin = call.rel(0);\n    final JoinRelBase bottomJoin = call.rel(1);\n    final RelNode relC = call.rel(2);\n    final RelNode relA = bottomJoin.getLeft();\n    final RelNode relB = bottomJoin.getRight();\n    final RelOptCluster cluster = topJoin.getCluster();\n\n    \r\n    \r\n\r\n    \r\n\r\n\n    final int aCount = relA.getRowType().getFieldCount();\n    final int bCount = relB.getRowType().getFieldCount();\n    final int cCount = relC.getRowType().getFieldCount();\n    final BitSet bBitSet = BitSets.range(aCount, aCount + bCount);\n\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n\n    \r\n    \r\n    if (topJoin.getJoinType() != JoinRelType.INNER\n        || bottomJoin.getJoinType() != JoinRelType.INNER) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> intersecting = new ArrayList<RexNode>();\n    final List<RexNode> nonIntersecting = new ArrayList<RexNode>();\n    split(topJoin.getCondition(), bBitSet, intersecting, nonIntersecting);\n\n    \r\n    if (nonIntersecting.isEmpty()) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> bottomIntersecting = new ArrayList<RexNode>();\n    final List<RexNode> bottomNonIntersecting = new ArrayList<RexNode>();\n    split(\n        bottomJoin.getCondition(), bBitSet, bottomIntersecting,\n        bottomNonIntersecting);\n\n    \r\n    \r\n    final Mappings.TargetMapping bottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, 0, aCount,\n            aCount, aCount + bCount, cCount);\n    List<RexNode> newBottomList = new ArrayList<RexNode>();\n    new RexPermuteInputsShuttle(bottomMapping, relA, relC)\n        .visitList(nonIntersecting, newBottomList);\n    final Mappings.TargetMapping bottomBottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount,\n            0, 0, aCount);\n    new RexPermuteInputsShuttle(bottomBottomMapping, relA, relC)\n        .visitList(bottomNonIntersecting, newBottomList);\n    final RexBuilder rexBuilder = cluster.getRexBuilder();\n    RexNode newBottomCondition =\n        RexUtil.composeConjunction(rexBuilder, newBottomList, false);\n    final JoinRelBase newBottomJoin =\n        bottomJoin.copy(bottomJoin.getTraitSet(), newBottomCondition, relA,\n            relC, bottomJoin.getJoinType(), bottomJoin.isSemiJoinDone());\n\n    \r\n    \r\n    final Mappings.TargetMapping topMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, 0, aCount,\n            aCount + cCount, aCount, bCount,\n            aCount, aCount + bCount, cCount);\n    List<RexNode> newTopList = new ArrayList<RexNode>();\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relB)\n        .visitList(intersecting, newTopList);\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relB)\n        .visitList(bottomIntersecting, newTopList);\n    RexNode newTopCondition =\n        RexUtil.composeConjunction(rexBuilder, newTopList, false);\n    @SuppressWarnings(\"SuspiciousNameCombination\")\n    final JoinRelBase newTopJoin =\n        topJoin.copy(topJoin.getTraitSet(), newTopCondition, newBottomJoin,\n            relB, topJoin.getJoinType(), topJoin.isSemiJoinDone());\n\n    assert !Mappings.isIdentity(topMapping);\n    final RelNode newProject = RelOptUtil.createProject(projectFactory,\n        newTopJoin, Mappings.asList(topMapping));\n\n    call.transformTo(newProject);\n  }\n","date":"2014-11-14 09:39:34","endLine":196,"groupId":"10158","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"onMatchRight","params":"(RelOptRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/76/b7f2e37ea65ea0427fab349bcc6e844620e5b7.src","preCode":"  private void onMatchRight(RelOptRuleCall call) {\n    final JoinRelBase topJoin = call.rel(0);\n    final JoinRelBase bottomJoin = call.rel(1);\n    final RelNode relC = call.rel(2);\n    final RelNode relA = bottomJoin.getLeft();\n    final RelNode relB = bottomJoin.getRight();\n    final RelOptCluster cluster = topJoin.getCluster();\n\n    \r\n    \r\n\r\n    \r\n\r\n\n    final int aCount = relA.getRowType().getFieldCount();\n    final int bCount = relB.getRowType().getFieldCount();\n    final int cCount = relC.getRowType().getFieldCount();\n    final BitSet bBitSet = BitSets.range(aCount, aCount + bCount);\n\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n\n    \r\n    \r\n    if (topJoin.getJoinType() != JoinRelType.INNER\n        || bottomJoin.getJoinType() != JoinRelType.INNER) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> intersecting = new ArrayList<RexNode>();\n    final List<RexNode> nonIntersecting = new ArrayList<RexNode>();\n    split(topJoin.getCondition(), bBitSet, intersecting, nonIntersecting);\n\n    \r\n    if (nonIntersecting.isEmpty()) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> bottomIntersecting = new ArrayList<RexNode>();\n    final List<RexNode> bottomNonIntersecting = new ArrayList<RexNode>();\n    split(\n        bottomJoin.getCondition(), bBitSet, bottomIntersecting,\n        bottomNonIntersecting);\n\n    \r\n    \r\n    final Mappings.TargetMapping bottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, 0, aCount,\n            aCount, aCount + bCount, cCount);\n    List<RexNode> newBottomList = new ArrayList<RexNode>();\n    new RexPermuteInputsShuttle(bottomMapping, relA, relC)\n        .visitList(nonIntersecting, newBottomList);\n    final Mappings.TargetMapping bottomBottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount,\n            0, 0, aCount);\n    new RexPermuteInputsShuttle(bottomBottomMapping, relA, relC)\n        .visitList(bottomNonIntersecting, newBottomList);\n    final RexBuilder rexBuilder = cluster.getRexBuilder();\n    RexNode newBottomCondition =\n        RexUtil.composeConjunction(rexBuilder, newBottomList, false);\n    final JoinRelBase newBottomJoin =\n        bottomJoin.copy(bottomJoin.getTraitSet(), newBottomCondition, relA,\n            relC, bottomJoin.getJoinType(), bottomJoin.isSemiJoinDone());\n\n    \r\n    \r\n    final Mappings.TargetMapping topMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, 0, aCount,\n            aCount + cCount, aCount, bCount,\n            aCount, aCount + bCount, cCount);\n    List<RexNode> newTopList = new ArrayList<RexNode>();\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relB)\n        .visitList(intersecting, newTopList);\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relB)\n        .visitList(bottomIntersecting, newTopList);\n    RexNode newTopCondition =\n        RexUtil.composeConjunction(rexBuilder, newTopList, false);\n    @SuppressWarnings(\"SuspiciousNameCombination\")\n    final JoinRelBase newTopJoin =\n        topJoin.copy(topJoin.getTraitSet(), newTopCondition, newBottomJoin,\n            relB, topJoin.getJoinType(), topJoin.isSemiJoinDone());\n\n    assert !Mappings.isIdentity(topMapping);\n    final RelNode newProject = RelOptUtil.createProject(projectFactory,\n        newTopJoin, Mappings.asList(topMapping));\n\n    call.transformTo(newProject);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/JoinPushThroughJoinRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":95,"status":"B"},{"authorDate":"2014-11-14 09:39:29","commitOrder":1,"curCode":"  private void onMatchLeft(RelOptRuleCall call) {\n    final JoinRelBase topJoin = call.rel(0);\n    final JoinRelBase bottomJoin = call.rel(1);\n    final RelNode relC = call.rel(2);\n    final RelNode relA = bottomJoin.getLeft();\n    final RelNode relB = bottomJoin.getRight();\n    final RelOptCluster cluster = topJoin.getCluster();\n\n    \r\n    \r\n\r\n    \r\n\r\n\n    final int aCount = relA.getRowType().getFieldCount();\n    final int bCount = relB.getRowType().getFieldCount();\n    final int cCount = relC.getRowType().getFieldCount();\n    final BitSet aBitSet = BitSets.range(aCount);\n\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n\n    \r\n    \r\n    if (topJoin.getJoinType() != JoinRelType.INNER\n        || bottomJoin.getJoinType() != JoinRelType.INNER) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> intersecting = new ArrayList<RexNode>();\n    final List<RexNode> nonIntersecting = new ArrayList<RexNode>();\n    split(topJoin.getCondition(), aBitSet, intersecting, nonIntersecting);\n\n    \r\n    if (nonIntersecting.isEmpty()) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> bottomIntersecting = new ArrayList<RexNode>();\n    final List<RexNode> bottomNonIntersecting = new ArrayList<RexNode>();\n    split(\n        bottomJoin.getCondition(), aBitSet, bottomIntersecting,\n        bottomNonIntersecting);\n\n    \r\n    \r\n    final Mappings.TargetMapping bottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            cCount, aCount, bCount,\n            0, aCount + bCount, cCount);\n    List<RexNode> newBottomList = new ArrayList<RexNode>();\n    new RexPermuteInputsShuttle(bottomMapping, relC, relB)\n        .visitList(nonIntersecting, newBottomList);\n    final Mappings.TargetMapping bottomBottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, aCount + bCount, cCount,\n            cCount, aCount, bCount);\n    new RexPermuteInputsShuttle(bottomBottomMapping, relC, relB)\n        .visitList(bottomNonIntersecting, newBottomList);\n    final RexBuilder rexBuilder = cluster.getRexBuilder();\n    RexNode newBottomCondition =\n        RexUtil.composeConjunction(rexBuilder, newBottomList, false);\n    final JoinRelBase newBottomJoin =\n        bottomJoin.copy(bottomJoin.getTraitSet(), newBottomCondition, relC,\n            relB, bottomJoin.getJoinType(), bottomJoin.isSemiJoinDone());\n\n    \r\n    \r\n    final Mappings.TargetMapping topMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            cCount + bCount, 0, aCount,\n            cCount, aCount, bCount,\n            0, aCount + bCount, cCount);\n    List<RexNode> newTopList = new ArrayList<RexNode>();\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relA)\n        .visitList(intersecting, newTopList);\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relA)\n        .visitList(bottomIntersecting, newTopList);\n    RexNode newTopCondition =\n        RexUtil.composeConjunction(rexBuilder, newTopList, false);\n    @SuppressWarnings(\"SuspiciousNameCombination\")\n    final JoinRelBase newTopJoin =\n        topJoin.copy(topJoin.getTraitSet(), newTopCondition, newBottomJoin,\n            relA, topJoin.getJoinType(), topJoin.isSemiJoinDone());\n\n    final RelNode newProject = RelOptUtil.createProject(projectFactory,\n        newTopJoin, Mappings.asList(topMapping));\n\n    call.transformTo(newProject);\n  }\n","date":"2014-11-14 09:39:34","endLine":303,"groupId":"11050","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"onMatchLeft","params":"(RelOptRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/76/b7f2e37ea65ea0427fab349bcc6e844620e5b7.src","preCode":"  private void onMatchLeft(RelOptRuleCall call) {\n    final JoinRelBase topJoin = call.rel(0);\n    final JoinRelBase bottomJoin = call.rel(1);\n    final RelNode relC = call.rel(2);\n    final RelNode relA = bottomJoin.getLeft();\n    final RelNode relB = bottomJoin.getRight();\n    final RelOptCluster cluster = topJoin.getCluster();\n\n    \r\n    \r\n\r\n    \r\n\r\n\n    final int aCount = relA.getRowType().getFieldCount();\n    final int bCount = relB.getRowType().getFieldCount();\n    final int cCount = relC.getRowType().getFieldCount();\n    final BitSet aBitSet = BitSets.range(aCount);\n\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n\n    \r\n    \r\n    if (topJoin.getJoinType() != JoinRelType.INNER\n        || bottomJoin.getJoinType() != JoinRelType.INNER) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> intersecting = new ArrayList<RexNode>();\n    final List<RexNode> nonIntersecting = new ArrayList<RexNode>();\n    split(topJoin.getCondition(), aBitSet, intersecting, nonIntersecting);\n\n    \r\n    if (nonIntersecting.isEmpty()) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> bottomIntersecting = new ArrayList<RexNode>();\n    final List<RexNode> bottomNonIntersecting = new ArrayList<RexNode>();\n    split(\n        bottomJoin.getCondition(), aBitSet, bottomIntersecting,\n        bottomNonIntersecting);\n\n    \r\n    \r\n    final Mappings.TargetMapping bottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            cCount, aCount, bCount,\n            0, aCount + bCount, cCount);\n    List<RexNode> newBottomList = new ArrayList<RexNode>();\n    new RexPermuteInputsShuttle(bottomMapping, relC, relB)\n        .visitList(nonIntersecting, newBottomList);\n    final Mappings.TargetMapping bottomBottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, aCount + bCount, cCount,\n            cCount, aCount, bCount);\n    new RexPermuteInputsShuttle(bottomBottomMapping, relC, relB)\n        .visitList(bottomNonIntersecting, newBottomList);\n    final RexBuilder rexBuilder = cluster.getRexBuilder();\n    RexNode newBottomCondition =\n        RexUtil.composeConjunction(rexBuilder, newBottomList, false);\n    final JoinRelBase newBottomJoin =\n        bottomJoin.copy(bottomJoin.getTraitSet(), newBottomCondition, relC,\n            relB, bottomJoin.getJoinType(), bottomJoin.isSemiJoinDone());\n\n    \r\n    \r\n    final Mappings.TargetMapping topMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            cCount + bCount, 0, aCount,\n            cCount, aCount, bCount,\n            0, aCount + bCount, cCount);\n    List<RexNode> newTopList = new ArrayList<RexNode>();\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relA)\n        .visitList(intersecting, newTopList);\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relA)\n        .visitList(bottomIntersecting, newTopList);\n    RexNode newTopCondition =\n        RexUtil.composeConjunction(rexBuilder, newTopList, false);\n    @SuppressWarnings(\"SuspiciousNameCombination\")\n    final JoinRelBase newTopJoin =\n        topJoin.copy(topJoin.getTraitSet(), newTopCondition, newBottomJoin,\n            relA, topJoin.getJoinType(), topJoin.isSemiJoinDone());\n\n    final RelNode newProject = RelOptUtil.createProject(projectFactory,\n        newTopJoin, Mappings.asList(topMapping));\n\n    call.transformTo(newProject);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/JoinPushThroughJoinRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":202,"status":"B"}],"commitId":"a611d645ad754844a39f3d98f5f814f13dbd9404","commitMessage":"@@@[CALCITE-296] Re-organize package structure;\n[CALCITE-419] Naming convention for planner rules\n\nThis change only renames files (and deletes some obsolete files). There are no content changes.\n","date":"2014-11-14 09:39:34","modifiedFileCount":"0","status":"B","submitter":"Julian Hyde"},{"authorTime":"2014-11-14 10:11:34","codes":[{"authorDate":"2014-11-14 10:11:34","commitOrder":2,"curCode":"  private void onMatchRight(RelOptRuleCall call) {\n    final Join topJoin = call.rel(0);\n    final Join bottomJoin = call.rel(1);\n    final RelNode relC = call.rel(2);\n    final RelNode relA = bottomJoin.getLeft();\n    final RelNode relB = bottomJoin.getRight();\n    final RelOptCluster cluster = topJoin.getCluster();\n\n    \r\n    \r\n\r\n    \r\n\r\n\n    final int aCount = relA.getRowType().getFieldCount();\n    final int bCount = relB.getRowType().getFieldCount();\n    final int cCount = relC.getRowType().getFieldCount();\n    final BitSet bBitSet = BitSets.range(aCount, aCount + bCount);\n\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n\n    \r\n    \r\n    if (topJoin.getJoinType() != JoinRelType.INNER\n        || bottomJoin.getJoinType() != JoinRelType.INNER) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> intersecting = new ArrayList<RexNode>();\n    final List<RexNode> nonIntersecting = new ArrayList<RexNode>();\n    split(topJoin.getCondition(), bBitSet, intersecting, nonIntersecting);\n\n    \r\n    if (nonIntersecting.isEmpty()) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> bottomIntersecting = new ArrayList<RexNode>();\n    final List<RexNode> bottomNonIntersecting = new ArrayList<RexNode>();\n    split(\n        bottomJoin.getCondition(), bBitSet, bottomIntersecting,\n        bottomNonIntersecting);\n\n    \r\n    \r\n    final Mappings.TargetMapping bottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, 0, aCount,\n            aCount, aCount + bCount, cCount);\n    List<RexNode> newBottomList = new ArrayList<RexNode>();\n    new RexPermuteInputsShuttle(bottomMapping, relA, relC)\n        .visitList(nonIntersecting, newBottomList);\n    final Mappings.TargetMapping bottomBottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount,\n            0, 0, aCount);\n    new RexPermuteInputsShuttle(bottomBottomMapping, relA, relC)\n        .visitList(bottomNonIntersecting, newBottomList);\n    final RexBuilder rexBuilder = cluster.getRexBuilder();\n    RexNode newBottomCondition =\n        RexUtil.composeConjunction(rexBuilder, newBottomList, false);\n    final Join newBottomJoin =\n        bottomJoin.copy(bottomJoin.getTraitSet(), newBottomCondition, relA,\n            relC, bottomJoin.getJoinType(), bottomJoin.isSemiJoinDone());\n\n    \r\n    \r\n    final Mappings.TargetMapping topMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, 0, aCount,\n            aCount + cCount, aCount, bCount,\n            aCount, aCount + bCount, cCount);\n    List<RexNode> newTopList = new ArrayList<RexNode>();\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relB)\n        .visitList(intersecting, newTopList);\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relB)\n        .visitList(bottomIntersecting, newTopList);\n    RexNode newTopCondition =\n        RexUtil.composeConjunction(rexBuilder, newTopList, false);\n    @SuppressWarnings(\"SuspiciousNameCombination\")\n    final Join newTopJoin =\n        topJoin.copy(topJoin.getTraitSet(), newTopCondition, newBottomJoin,\n            relB, topJoin.getJoinType(), topJoin.isSemiJoinDone());\n\n    assert !Mappings.isIdentity(topMapping);\n    final RelNode newProject = RelOptUtil.createProject(projectFactory,\n        newTopJoin, Mappings.asList(topMapping));\n\n    call.transformTo(newProject);\n  }\n","date":"2014-11-14 10:22:06","endLine":205,"groupId":"10158","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"onMatchRight","params":"(RelOptRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/8e/024aa5e47964c44d5ddb6ff2caae323d3f93cd.src","preCode":"  private void onMatchRight(RelOptRuleCall call) {\n    final JoinRelBase topJoin = call.rel(0);\n    final JoinRelBase bottomJoin = call.rel(1);\n    final RelNode relC = call.rel(2);\n    final RelNode relA = bottomJoin.getLeft();\n    final RelNode relB = bottomJoin.getRight();\n    final RelOptCluster cluster = topJoin.getCluster();\n\n    \r\n    \r\n\r\n    \r\n\r\n\n    final int aCount = relA.getRowType().getFieldCount();\n    final int bCount = relB.getRowType().getFieldCount();\n    final int cCount = relC.getRowType().getFieldCount();\n    final BitSet bBitSet = BitSets.range(aCount, aCount + bCount);\n\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n\n    \r\n    \r\n    if (topJoin.getJoinType() != JoinRelType.INNER\n        || bottomJoin.getJoinType() != JoinRelType.INNER) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> intersecting = new ArrayList<RexNode>();\n    final List<RexNode> nonIntersecting = new ArrayList<RexNode>();\n    split(topJoin.getCondition(), bBitSet, intersecting, nonIntersecting);\n\n    \r\n    if (nonIntersecting.isEmpty()) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> bottomIntersecting = new ArrayList<RexNode>();\n    final List<RexNode> bottomNonIntersecting = new ArrayList<RexNode>();\n    split(\n        bottomJoin.getCondition(), bBitSet, bottomIntersecting,\n        bottomNonIntersecting);\n\n    \r\n    \r\n    final Mappings.TargetMapping bottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, 0, aCount,\n            aCount, aCount + bCount, cCount);\n    List<RexNode> newBottomList = new ArrayList<RexNode>();\n    new RexPermuteInputsShuttle(bottomMapping, relA, relC)\n        .visitList(nonIntersecting, newBottomList);\n    final Mappings.TargetMapping bottomBottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount,\n            0, 0, aCount);\n    new RexPermuteInputsShuttle(bottomBottomMapping, relA, relC)\n        .visitList(bottomNonIntersecting, newBottomList);\n    final RexBuilder rexBuilder = cluster.getRexBuilder();\n    RexNode newBottomCondition =\n        RexUtil.composeConjunction(rexBuilder, newBottomList, false);\n    final JoinRelBase newBottomJoin =\n        bottomJoin.copy(bottomJoin.getTraitSet(), newBottomCondition, relA,\n            relC, bottomJoin.getJoinType(), bottomJoin.isSemiJoinDone());\n\n    \r\n    \r\n    final Mappings.TargetMapping topMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, 0, aCount,\n            aCount + cCount, aCount, bCount,\n            aCount, aCount + bCount, cCount);\n    List<RexNode> newTopList = new ArrayList<RexNode>();\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relB)\n        .visitList(intersecting, newTopList);\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relB)\n        .visitList(bottomIntersecting, newTopList);\n    RexNode newTopCondition =\n        RexUtil.composeConjunction(rexBuilder, newTopList, false);\n    @SuppressWarnings(\"SuspiciousNameCombination\")\n    final JoinRelBase newTopJoin =\n        topJoin.copy(topJoin.getTraitSet(), newTopCondition, newBottomJoin,\n            relB, topJoin.getJoinType(), topJoin.isSemiJoinDone());\n\n    assert !Mappings.isIdentity(topMapping);\n    final RelNode newProject = RelOptUtil.createProject(projectFactory,\n        newTopJoin, Mappings.asList(topMapping));\n\n    call.transformTo(newProject);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/JoinPushThroughJoinRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":104,"status":"M"},{"authorDate":"2014-11-14 10:11:34","commitOrder":2,"curCode":"  private void onMatchLeft(RelOptRuleCall call) {\n    final Join topJoin = call.rel(0);\n    final Join bottomJoin = call.rel(1);\n    final RelNode relC = call.rel(2);\n    final RelNode relA = bottomJoin.getLeft();\n    final RelNode relB = bottomJoin.getRight();\n    final RelOptCluster cluster = topJoin.getCluster();\n\n    \r\n    \r\n\r\n    \r\n\r\n\n    final int aCount = relA.getRowType().getFieldCount();\n    final int bCount = relB.getRowType().getFieldCount();\n    final int cCount = relC.getRowType().getFieldCount();\n    final BitSet aBitSet = BitSets.range(aCount);\n\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n\n    \r\n    \r\n    if (topJoin.getJoinType() != JoinRelType.INNER\n        || bottomJoin.getJoinType() != JoinRelType.INNER) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> intersecting = new ArrayList<RexNode>();\n    final List<RexNode> nonIntersecting = new ArrayList<RexNode>();\n    split(topJoin.getCondition(), aBitSet, intersecting, nonIntersecting);\n\n    \r\n    if (nonIntersecting.isEmpty()) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> bottomIntersecting = new ArrayList<RexNode>();\n    final List<RexNode> bottomNonIntersecting = new ArrayList<RexNode>();\n    split(\n        bottomJoin.getCondition(), aBitSet, bottomIntersecting,\n        bottomNonIntersecting);\n\n    \r\n    \r\n    final Mappings.TargetMapping bottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            cCount, aCount, bCount,\n            0, aCount + bCount, cCount);\n    List<RexNode> newBottomList = new ArrayList<RexNode>();\n    new RexPermuteInputsShuttle(bottomMapping, relC, relB)\n        .visitList(nonIntersecting, newBottomList);\n    final Mappings.TargetMapping bottomBottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, aCount + bCount, cCount,\n            cCount, aCount, bCount);\n    new RexPermuteInputsShuttle(bottomBottomMapping, relC, relB)\n        .visitList(bottomNonIntersecting, newBottomList);\n    final RexBuilder rexBuilder = cluster.getRexBuilder();\n    RexNode newBottomCondition =\n        RexUtil.composeConjunction(rexBuilder, newBottomList, false);\n    final Join newBottomJoin =\n        bottomJoin.copy(bottomJoin.getTraitSet(), newBottomCondition, relC,\n            relB, bottomJoin.getJoinType(), bottomJoin.isSemiJoinDone());\n\n    \r\n    \r\n    final Mappings.TargetMapping topMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            cCount + bCount, 0, aCount,\n            cCount, aCount, bCount,\n            0, aCount + bCount, cCount);\n    List<RexNode> newTopList = new ArrayList<RexNode>();\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relA)\n        .visitList(intersecting, newTopList);\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relA)\n        .visitList(bottomIntersecting, newTopList);\n    RexNode newTopCondition =\n        RexUtil.composeConjunction(rexBuilder, newTopList, false);\n    @SuppressWarnings(\"SuspiciousNameCombination\")\n    final Join newTopJoin =\n        topJoin.copy(topJoin.getTraitSet(), newTopCondition, newBottomJoin,\n            relA, topJoin.getJoinType(), topJoin.isSemiJoinDone());\n\n    final RelNode newProject = RelOptUtil.createProject(projectFactory,\n        newTopJoin, Mappings.asList(topMapping));\n\n    call.transformTo(newProject);\n  }\n","date":"2014-11-14 10:22:06","endLine":312,"groupId":"11050","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"onMatchLeft","params":"(RelOptRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/8e/024aa5e47964c44d5ddb6ff2caae323d3f93cd.src","preCode":"  private void onMatchLeft(RelOptRuleCall call) {\n    final JoinRelBase topJoin = call.rel(0);\n    final JoinRelBase bottomJoin = call.rel(1);\n    final RelNode relC = call.rel(2);\n    final RelNode relA = bottomJoin.getLeft();\n    final RelNode relB = bottomJoin.getRight();\n    final RelOptCluster cluster = topJoin.getCluster();\n\n    \r\n    \r\n\r\n    \r\n\r\n\n    final int aCount = relA.getRowType().getFieldCount();\n    final int bCount = relB.getRowType().getFieldCount();\n    final int cCount = relC.getRowType().getFieldCount();\n    final BitSet aBitSet = BitSets.range(aCount);\n\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n\n    \r\n    \r\n    if (topJoin.getJoinType() != JoinRelType.INNER\n        || bottomJoin.getJoinType() != JoinRelType.INNER) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> intersecting = new ArrayList<RexNode>();\n    final List<RexNode> nonIntersecting = new ArrayList<RexNode>();\n    split(topJoin.getCondition(), aBitSet, intersecting, nonIntersecting);\n\n    \r\n    if (nonIntersecting.isEmpty()) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> bottomIntersecting = new ArrayList<RexNode>();\n    final List<RexNode> bottomNonIntersecting = new ArrayList<RexNode>();\n    split(\n        bottomJoin.getCondition(), aBitSet, bottomIntersecting,\n        bottomNonIntersecting);\n\n    \r\n    \r\n    final Mappings.TargetMapping bottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            cCount, aCount, bCount,\n            0, aCount + bCount, cCount);\n    List<RexNode> newBottomList = new ArrayList<RexNode>();\n    new RexPermuteInputsShuttle(bottomMapping, relC, relB)\n        .visitList(nonIntersecting, newBottomList);\n    final Mappings.TargetMapping bottomBottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, aCount + bCount, cCount,\n            cCount, aCount, bCount);\n    new RexPermuteInputsShuttle(bottomBottomMapping, relC, relB)\n        .visitList(bottomNonIntersecting, newBottomList);\n    final RexBuilder rexBuilder = cluster.getRexBuilder();\n    RexNode newBottomCondition =\n        RexUtil.composeConjunction(rexBuilder, newBottomList, false);\n    final JoinRelBase newBottomJoin =\n        bottomJoin.copy(bottomJoin.getTraitSet(), newBottomCondition, relC,\n            relB, bottomJoin.getJoinType(), bottomJoin.isSemiJoinDone());\n\n    \r\n    \r\n    final Mappings.TargetMapping topMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            cCount + bCount, 0, aCount,\n            cCount, aCount, bCount,\n            0, aCount + bCount, cCount);\n    List<RexNode> newTopList = new ArrayList<RexNode>();\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relA)\n        .visitList(intersecting, newTopList);\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relA)\n        .visitList(bottomIntersecting, newTopList);\n    RexNode newTopCondition =\n        RexUtil.composeConjunction(rexBuilder, newTopList, false);\n    @SuppressWarnings(\"SuspiciousNameCombination\")\n    final JoinRelBase newTopJoin =\n        topJoin.copy(topJoin.getTraitSet(), newTopCondition, newBottomJoin,\n            relA, topJoin.getJoinType(), topJoin.isSemiJoinDone());\n\n    final RelNode newProject = RelOptUtil.createProject(projectFactory,\n        newTopJoin, Mappings.asList(topMapping));\n\n    call.transformTo(newProject);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/JoinPushThroughJoinRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":211,"status":"M"}],"commitId":"a0ba73cd2de76696b96a1cd828d2aa4d3ef9eb55","commitMessage":"@@@[CALCITE-306] Standardize code style for \"import package.*;\"\n\nRename classes and packages and generally fix things up after [CALCITE-296] and [CALCITE-419].\n\nMake many inner classes of EnumerableRules (e.g. EnumerableFilter.  EnumerableFilterRule) top-level classes.\n\nApply a consistent formatting convention for string literals split over multiple lines.\n\nRename generated file org.eigenbase.resource.Resources to org.apache.calcite.runtime.Resources.\n\nChange occurrences of \"optiq\" and \"eigenbase\" in java code to \"calcite\".\n","date":"2014-11-14 10:22:06","modifiedFileCount":"1156","status":"M","submitter":"Julian Hyde"},{"authorTime":"2014-11-14 10:24:57","codes":[{"authorDate":"2014-11-14 10:24:57","commitOrder":3,"curCode":"  private void onMatchRight(RelOptRuleCall call) {\n    final Join topJoin = call.rel(0);\n    final Join bottomJoin = call.rel(1);\n    final RelNode relC = call.rel(2);\n    final RelNode relA = bottomJoin.getLeft();\n    final RelNode relB = bottomJoin.getRight();\n    final RelOptCluster cluster = topJoin.getCluster();\n\n    \r\n    \r\n\r\n    \r\n\r\n\n    final int aCount = relA.getRowType().getFieldCount();\n    final int bCount = relB.getRowType().getFieldCount();\n    final int cCount = relC.getRowType().getFieldCount();\n    final ImmutableBitSet bBitSet =\n        ImmutableBitSet.range(aCount, aCount + bCount);\n\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n\n    \r\n    \r\n    if (topJoin.getJoinType() != JoinRelType.INNER\n        || bottomJoin.getJoinType() != JoinRelType.INNER) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> intersecting = new ArrayList<RexNode>();\n    final List<RexNode> nonIntersecting = new ArrayList<RexNode>();\n    split(topJoin.getCondition(), bBitSet, intersecting, nonIntersecting);\n\n    \r\n    if (nonIntersecting.isEmpty()) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> bottomIntersecting = new ArrayList<RexNode>();\n    final List<RexNode> bottomNonIntersecting = new ArrayList<RexNode>();\n    split(\n        bottomJoin.getCondition(), bBitSet, bottomIntersecting,\n        bottomNonIntersecting);\n\n    \r\n    \r\n    final Mappings.TargetMapping bottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, 0, aCount,\n            aCount, aCount + bCount, cCount);\n    List<RexNode> newBottomList = new ArrayList<RexNode>();\n    new RexPermuteInputsShuttle(bottomMapping, relA, relC)\n        .visitList(nonIntersecting, newBottomList);\n    final Mappings.TargetMapping bottomBottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount,\n            0, 0, aCount);\n    new RexPermuteInputsShuttle(bottomBottomMapping, relA, relC)\n        .visitList(bottomNonIntersecting, newBottomList);\n    final RexBuilder rexBuilder = cluster.getRexBuilder();\n    RexNode newBottomCondition =\n        RexUtil.composeConjunction(rexBuilder, newBottomList, false);\n    final Join newBottomJoin =\n        bottomJoin.copy(bottomJoin.getTraitSet(), newBottomCondition, relA,\n            relC, bottomJoin.getJoinType(), bottomJoin.isSemiJoinDone());\n\n    \r\n    \r\n    final Mappings.TargetMapping topMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, 0, aCount,\n            aCount + cCount, aCount, bCount,\n            aCount, aCount + bCount, cCount);\n    List<RexNode> newTopList = new ArrayList<RexNode>();\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relB)\n        .visitList(intersecting, newTopList);\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relB)\n        .visitList(bottomIntersecting, newTopList);\n    RexNode newTopCondition =\n        RexUtil.composeConjunction(rexBuilder, newTopList, false);\n    @SuppressWarnings(\"SuspiciousNameCombination\")\n    final Join newTopJoin =\n        topJoin.copy(topJoin.getTraitSet(), newTopCondition, newBottomJoin,\n            relB, topJoin.getJoinType(), topJoin.isSemiJoinDone());\n\n    assert !Mappings.isIdentity(topMapping);\n    final RelNode newProject = RelOptUtil.createProject(projectFactory,\n        newTopJoin, Mappings.asList(topMapping));\n\n    call.transformTo(newProject);\n  }\n","date":"2014-11-14 11:00:43","endLine":205,"groupId":"10158","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"onMatchRight","params":"(RelOptRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/6a/292f6354907bd5ba60b1bb69167452359edeaf.src","preCode":"  private void onMatchRight(RelOptRuleCall call) {\n    final Join topJoin = call.rel(0);\n    final Join bottomJoin = call.rel(1);\n    final RelNode relC = call.rel(2);\n    final RelNode relA = bottomJoin.getLeft();\n    final RelNode relB = bottomJoin.getRight();\n    final RelOptCluster cluster = topJoin.getCluster();\n\n    \r\n    \r\n\r\n    \r\n\r\n\n    final int aCount = relA.getRowType().getFieldCount();\n    final int bCount = relB.getRowType().getFieldCount();\n    final int cCount = relC.getRowType().getFieldCount();\n    final BitSet bBitSet = BitSets.range(aCount, aCount + bCount);\n\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n\n    \r\n    \r\n    if (topJoin.getJoinType() != JoinRelType.INNER\n        || bottomJoin.getJoinType() != JoinRelType.INNER) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> intersecting = new ArrayList<RexNode>();\n    final List<RexNode> nonIntersecting = new ArrayList<RexNode>();\n    split(topJoin.getCondition(), bBitSet, intersecting, nonIntersecting);\n\n    \r\n    if (nonIntersecting.isEmpty()) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> bottomIntersecting = new ArrayList<RexNode>();\n    final List<RexNode> bottomNonIntersecting = new ArrayList<RexNode>();\n    split(\n        bottomJoin.getCondition(), bBitSet, bottomIntersecting,\n        bottomNonIntersecting);\n\n    \r\n    \r\n    final Mappings.TargetMapping bottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, 0, aCount,\n            aCount, aCount + bCount, cCount);\n    List<RexNode> newBottomList = new ArrayList<RexNode>();\n    new RexPermuteInputsShuttle(bottomMapping, relA, relC)\n        .visitList(nonIntersecting, newBottomList);\n    final Mappings.TargetMapping bottomBottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount,\n            0, 0, aCount);\n    new RexPermuteInputsShuttle(bottomBottomMapping, relA, relC)\n        .visitList(bottomNonIntersecting, newBottomList);\n    final RexBuilder rexBuilder = cluster.getRexBuilder();\n    RexNode newBottomCondition =\n        RexUtil.composeConjunction(rexBuilder, newBottomList, false);\n    final Join newBottomJoin =\n        bottomJoin.copy(bottomJoin.getTraitSet(), newBottomCondition, relA,\n            relC, bottomJoin.getJoinType(), bottomJoin.isSemiJoinDone());\n\n    \r\n    \r\n    final Mappings.TargetMapping topMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, 0, aCount,\n            aCount + cCount, aCount, bCount,\n            aCount, aCount + bCount, cCount);\n    List<RexNode> newTopList = new ArrayList<RexNode>();\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relB)\n        .visitList(intersecting, newTopList);\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relB)\n        .visitList(bottomIntersecting, newTopList);\n    RexNode newTopCondition =\n        RexUtil.composeConjunction(rexBuilder, newTopList, false);\n    @SuppressWarnings(\"SuspiciousNameCombination\")\n    final Join newTopJoin =\n        topJoin.copy(topJoin.getTraitSet(), newTopCondition, newBottomJoin,\n            relB, topJoin.getJoinType(), topJoin.isSemiJoinDone());\n\n    assert !Mappings.isIdentity(topMapping);\n    final RelNode newProject = RelOptUtil.createProject(projectFactory,\n        newTopJoin, Mappings.asList(topMapping));\n\n    call.transformTo(newProject);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/JoinPushThroughJoinRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":103,"status":"M"},{"authorDate":"2014-11-14 10:24:57","commitOrder":3,"curCode":"  private void onMatchLeft(RelOptRuleCall call) {\n    final Join topJoin = call.rel(0);\n    final Join bottomJoin = call.rel(1);\n    final RelNode relC = call.rel(2);\n    final RelNode relA = bottomJoin.getLeft();\n    final RelNode relB = bottomJoin.getRight();\n    final RelOptCluster cluster = topJoin.getCluster();\n\n    \r\n    \r\n\r\n    \r\n\r\n\n    final int aCount = relA.getRowType().getFieldCount();\n    final int bCount = relB.getRowType().getFieldCount();\n    final int cCount = relC.getRowType().getFieldCount();\n    final ImmutableBitSet aBitSet = ImmutableBitSet.range(aCount);\n\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n\n    \r\n    \r\n    if (topJoin.getJoinType() != JoinRelType.INNER\n        || bottomJoin.getJoinType() != JoinRelType.INNER) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> intersecting = new ArrayList<RexNode>();\n    final List<RexNode> nonIntersecting = new ArrayList<RexNode>();\n    split(topJoin.getCondition(), aBitSet, intersecting, nonIntersecting);\n\n    \r\n    if (nonIntersecting.isEmpty()) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> bottomIntersecting = new ArrayList<RexNode>();\n    final List<RexNode> bottomNonIntersecting = new ArrayList<RexNode>();\n    split(\n        bottomJoin.getCondition(), aBitSet, bottomIntersecting,\n        bottomNonIntersecting);\n\n    \r\n    \r\n    final Mappings.TargetMapping bottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            cCount, aCount, bCount,\n            0, aCount + bCount, cCount);\n    List<RexNode> newBottomList = new ArrayList<RexNode>();\n    new RexPermuteInputsShuttle(bottomMapping, relC, relB)\n        .visitList(nonIntersecting, newBottomList);\n    final Mappings.TargetMapping bottomBottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, aCount + bCount, cCount,\n            cCount, aCount, bCount);\n    new RexPermuteInputsShuttle(bottomBottomMapping, relC, relB)\n        .visitList(bottomNonIntersecting, newBottomList);\n    final RexBuilder rexBuilder = cluster.getRexBuilder();\n    RexNode newBottomCondition =\n        RexUtil.composeConjunction(rexBuilder, newBottomList, false);\n    final Join newBottomJoin =\n        bottomJoin.copy(bottomJoin.getTraitSet(), newBottomCondition, relC,\n            relB, bottomJoin.getJoinType(), bottomJoin.isSemiJoinDone());\n\n    \r\n    \r\n    final Mappings.TargetMapping topMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            cCount + bCount, 0, aCount,\n            cCount, aCount, bCount,\n            0, aCount + bCount, cCount);\n    List<RexNode> newTopList = new ArrayList<RexNode>();\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relA)\n        .visitList(intersecting, newTopList);\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relA)\n        .visitList(bottomIntersecting, newTopList);\n    RexNode newTopCondition =\n        RexUtil.composeConjunction(rexBuilder, newTopList, false);\n    @SuppressWarnings(\"SuspiciousNameCombination\")\n    final Join newTopJoin =\n        topJoin.copy(topJoin.getTraitSet(), newTopCondition, newBottomJoin,\n            relA, topJoin.getJoinType(), topJoin.isSemiJoinDone());\n\n    final RelNode newProject = RelOptUtil.createProject(projectFactory,\n        newTopJoin, Mappings.asList(topMapping));\n\n    call.transformTo(newProject);\n  }\n","date":"2014-11-14 11:00:43","endLine":312,"groupId":"11050","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"onMatchLeft","params":"(RelOptRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/6a/292f6354907bd5ba60b1bb69167452359edeaf.src","preCode":"  private void onMatchLeft(RelOptRuleCall call) {\n    final Join topJoin = call.rel(0);\n    final Join bottomJoin = call.rel(1);\n    final RelNode relC = call.rel(2);\n    final RelNode relA = bottomJoin.getLeft();\n    final RelNode relB = bottomJoin.getRight();\n    final RelOptCluster cluster = topJoin.getCluster();\n\n    \r\n    \r\n\r\n    \r\n\r\n\n    final int aCount = relA.getRowType().getFieldCount();\n    final int bCount = relB.getRowType().getFieldCount();\n    final int cCount = relC.getRowType().getFieldCount();\n    final BitSet aBitSet = BitSets.range(aCount);\n\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n\n    \r\n    \r\n    if (topJoin.getJoinType() != JoinRelType.INNER\n        || bottomJoin.getJoinType() != JoinRelType.INNER) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> intersecting = new ArrayList<RexNode>();\n    final List<RexNode> nonIntersecting = new ArrayList<RexNode>();\n    split(topJoin.getCondition(), aBitSet, intersecting, nonIntersecting);\n\n    \r\n    if (nonIntersecting.isEmpty()) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> bottomIntersecting = new ArrayList<RexNode>();\n    final List<RexNode> bottomNonIntersecting = new ArrayList<RexNode>();\n    split(\n        bottomJoin.getCondition(), aBitSet, bottomIntersecting,\n        bottomNonIntersecting);\n\n    \r\n    \r\n    final Mappings.TargetMapping bottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            cCount, aCount, bCount,\n            0, aCount + bCount, cCount);\n    List<RexNode> newBottomList = new ArrayList<RexNode>();\n    new RexPermuteInputsShuttle(bottomMapping, relC, relB)\n        .visitList(nonIntersecting, newBottomList);\n    final Mappings.TargetMapping bottomBottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, aCount + bCount, cCount,\n            cCount, aCount, bCount);\n    new RexPermuteInputsShuttle(bottomBottomMapping, relC, relB)\n        .visitList(bottomNonIntersecting, newBottomList);\n    final RexBuilder rexBuilder = cluster.getRexBuilder();\n    RexNode newBottomCondition =\n        RexUtil.composeConjunction(rexBuilder, newBottomList, false);\n    final Join newBottomJoin =\n        bottomJoin.copy(bottomJoin.getTraitSet(), newBottomCondition, relC,\n            relB, bottomJoin.getJoinType(), bottomJoin.isSemiJoinDone());\n\n    \r\n    \r\n    final Mappings.TargetMapping topMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            cCount + bCount, 0, aCount,\n            cCount, aCount, bCount,\n            0, aCount + bCount, cCount);\n    List<RexNode> newTopList = new ArrayList<RexNode>();\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relA)\n        .visitList(intersecting, newTopList);\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relA)\n        .visitList(bottomIntersecting, newTopList);\n    RexNode newTopCondition =\n        RexUtil.composeConjunction(rexBuilder, newTopList, false);\n    @SuppressWarnings(\"SuspiciousNameCombination\")\n    final Join newTopJoin =\n        topJoin.copy(topJoin.getTraitSet(), newTopCondition, newBottomJoin,\n            relA, topJoin.getJoinType(), topJoin.isSemiJoinDone());\n\n    final RelNode newProject = RelOptUtil.createProject(projectFactory,\n        newTopJoin, Mappings.asList(topMapping));\n\n    call.transformTo(newProject);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/JoinPushThroughJoinRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":211,"status":"M"}],"commitId":"b9d8de38d2aa4ee6791aec42ffe2adb58942060a","commitMessage":"@@@[CALCITE-460] Add ImmutableBitSet and replace uses of BitSet\n","date":"2014-11-14 11:00:43","modifiedFileCount":"74","status":"M","submitter":"Julian Hyde"},{"authorTime":"2015-09-22 16:20:38","codes":[{"authorDate":"2015-09-22 16:20:38","commitOrder":4,"curCode":"  private void onMatchRight(RelOptRuleCall call) {\n    final Join topJoin = call.rel(0);\n    final Join bottomJoin = call.rel(1);\n    final RelNode relC = call.rel(2);\n    final RelNode relA = bottomJoin.getLeft();\n    final RelNode relB = bottomJoin.getRight();\n    final RelOptCluster cluster = topJoin.getCluster();\n\n    \r\n    \r\n\r\n    \r\n\r\n\n    final int aCount = relA.getRowType().getFieldCount();\n    final int bCount = relB.getRowType().getFieldCount();\n    final int cCount = relC.getRowType().getFieldCount();\n    final ImmutableBitSet bBitSet =\n        ImmutableBitSet.range(aCount, aCount + bCount);\n\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n\n    \r\n    \r\n    if (topJoin.getJoinType() != JoinRelType.INNER\n        || bottomJoin.getJoinType() != JoinRelType.INNER) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> intersecting = new ArrayList<>();\n    final List<RexNode> nonIntersecting = new ArrayList<>();\n    split(topJoin.getCondition(), bBitSet, intersecting, nonIntersecting);\n\n    \r\n    if (nonIntersecting.isEmpty()) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> bottomIntersecting = new ArrayList<>();\n    final List<RexNode> bottomNonIntersecting = new ArrayList<>();\n    split(\n        bottomJoin.getCondition(), bBitSet, bottomIntersecting,\n        bottomNonIntersecting);\n\n    \r\n    \r\n    final Mappings.TargetMapping bottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, 0, aCount,\n            aCount, aCount + bCount, cCount);\n    final List<RexNode> newBottomList = new ArrayList<>();\n    new RexPermuteInputsShuttle(bottomMapping, relA, relC)\n        .visitList(nonIntersecting, newBottomList);\n    final Mappings.TargetMapping bottomBottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount,\n            0, 0, aCount);\n    new RexPermuteInputsShuttle(bottomBottomMapping, relA, relC)\n        .visitList(bottomNonIntersecting, newBottomList);\n    final RexBuilder rexBuilder = cluster.getRexBuilder();\n    RexNode newBottomCondition =\n        RexUtil.composeConjunction(rexBuilder, newBottomList, false);\n    final Join newBottomJoin =\n        bottomJoin.copy(bottomJoin.getTraitSet(), newBottomCondition, relA,\n            relC, bottomJoin.getJoinType(), bottomJoin.isSemiJoinDone());\n\n    \r\n    \r\n    final Mappings.TargetMapping topMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, 0, aCount,\n            aCount + cCount, aCount, bCount,\n            aCount, aCount + bCount, cCount);\n    final List<RexNode> newTopList = new ArrayList<>();\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relB)\n        .visitList(intersecting, newTopList);\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relB)\n        .visitList(bottomIntersecting, newTopList);\n    RexNode newTopCondition =\n        RexUtil.composeConjunction(rexBuilder, newTopList, false);\n    @SuppressWarnings(\"SuspiciousNameCombination\")\n    final Join newTopJoin =\n        topJoin.copy(topJoin.getTraitSet(), newTopCondition, newBottomJoin,\n            relB, topJoin.getJoinType(), topJoin.isSemiJoinDone());\n\n    assert !Mappings.isIdentity(topMapping);\n    final RelBuilder relBuilder = call.builder();\n    relBuilder.push(newTopJoin);\n    relBuilder.project(relBuilder.fields(topMapping));\n    call.transformTo(relBuilder.build());\n  }\n","date":"2015-09-28 11:22:49","endLine":210,"groupId":"16478","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"onMatchRight","params":"(RelOptRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/40/2557d2136194b1cdb48fc78c2cc930cd0233f8.src","preCode":"  private void onMatchRight(RelOptRuleCall call) {\n    final Join topJoin = call.rel(0);\n    final Join bottomJoin = call.rel(1);\n    final RelNode relC = call.rel(2);\n    final RelNode relA = bottomJoin.getLeft();\n    final RelNode relB = bottomJoin.getRight();\n    final RelOptCluster cluster = topJoin.getCluster();\n\n    \r\n    \r\n\r\n    \r\n\r\n\n    final int aCount = relA.getRowType().getFieldCount();\n    final int bCount = relB.getRowType().getFieldCount();\n    final int cCount = relC.getRowType().getFieldCount();\n    final ImmutableBitSet bBitSet =\n        ImmutableBitSet.range(aCount, aCount + bCount);\n\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n\n    \r\n    \r\n    if (topJoin.getJoinType() != JoinRelType.INNER\n        || bottomJoin.getJoinType() != JoinRelType.INNER) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> intersecting = new ArrayList<RexNode>();\n    final List<RexNode> nonIntersecting = new ArrayList<RexNode>();\n    split(topJoin.getCondition(), bBitSet, intersecting, nonIntersecting);\n\n    \r\n    if (nonIntersecting.isEmpty()) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> bottomIntersecting = new ArrayList<RexNode>();\n    final List<RexNode> bottomNonIntersecting = new ArrayList<RexNode>();\n    split(\n        bottomJoin.getCondition(), bBitSet, bottomIntersecting,\n        bottomNonIntersecting);\n\n    \r\n    \r\n    final Mappings.TargetMapping bottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, 0, aCount,\n            aCount, aCount + bCount, cCount);\n    List<RexNode> newBottomList = new ArrayList<RexNode>();\n    new RexPermuteInputsShuttle(bottomMapping, relA, relC)\n        .visitList(nonIntersecting, newBottomList);\n    final Mappings.TargetMapping bottomBottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount,\n            0, 0, aCount);\n    new RexPermuteInputsShuttle(bottomBottomMapping, relA, relC)\n        .visitList(bottomNonIntersecting, newBottomList);\n    final RexBuilder rexBuilder = cluster.getRexBuilder();\n    RexNode newBottomCondition =\n        RexUtil.composeConjunction(rexBuilder, newBottomList, false);\n    final Join newBottomJoin =\n        bottomJoin.copy(bottomJoin.getTraitSet(), newBottomCondition, relA,\n            relC, bottomJoin.getJoinType(), bottomJoin.isSemiJoinDone());\n\n    \r\n    \r\n    final Mappings.TargetMapping topMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, 0, aCount,\n            aCount + cCount, aCount, bCount,\n            aCount, aCount + bCount, cCount);\n    List<RexNode> newTopList = new ArrayList<RexNode>();\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relB)\n        .visitList(intersecting, newTopList);\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relB)\n        .visitList(bottomIntersecting, newTopList);\n    RexNode newTopCondition =\n        RexUtil.composeConjunction(rexBuilder, newTopList, false);\n    @SuppressWarnings(\"SuspiciousNameCombination\")\n    final Join newTopJoin =\n        topJoin.copy(topJoin.getTraitSet(), newTopCondition, newBottomJoin,\n            relB, topJoin.getJoinType(), topJoin.isSemiJoinDone());\n\n    assert !Mappings.isIdentity(topMapping);\n    final RelNode newProject = RelOptUtil.createProject(projectFactory,\n        newTopJoin, Mappings.asList(topMapping));\n\n    call.transformTo(newProject);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/JoinPushThroughJoinRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":108,"status":"M"},{"authorDate":"2015-09-22 16:20:38","commitOrder":4,"curCode":"  private void onMatchLeft(RelOptRuleCall call) {\n    final Join topJoin = call.rel(0);\n    final Join bottomJoin = call.rel(1);\n    final RelNode relC = call.rel(2);\n    final RelNode relA = bottomJoin.getLeft();\n    final RelNode relB = bottomJoin.getRight();\n    final RelOptCluster cluster = topJoin.getCluster();\n\n    \r\n    \r\n\r\n    \r\n\r\n\n    final int aCount = relA.getRowType().getFieldCount();\n    final int bCount = relB.getRowType().getFieldCount();\n    final int cCount = relC.getRowType().getFieldCount();\n    final ImmutableBitSet aBitSet = ImmutableBitSet.range(aCount);\n\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n\n    \r\n    \r\n    if (topJoin.getJoinType() != JoinRelType.INNER\n        || bottomJoin.getJoinType() != JoinRelType.INNER) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> intersecting = new ArrayList<>();\n    final List<RexNode> nonIntersecting = new ArrayList<>();\n    split(topJoin.getCondition(), aBitSet, intersecting, nonIntersecting);\n\n    \r\n    if (nonIntersecting.isEmpty()) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> bottomIntersecting = new ArrayList<>();\n    final List<RexNode> bottomNonIntersecting = new ArrayList<>();\n    split(\n        bottomJoin.getCondition(), aBitSet, bottomIntersecting,\n        bottomNonIntersecting);\n\n    \r\n    \r\n    final Mappings.TargetMapping bottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            cCount, aCount, bCount,\n            0, aCount + bCount, cCount);\n    final List<RexNode> newBottomList = new ArrayList<>();\n    new RexPermuteInputsShuttle(bottomMapping, relC, relB)\n        .visitList(nonIntersecting, newBottomList);\n    final Mappings.TargetMapping bottomBottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, aCount + bCount, cCount,\n            cCount, aCount, bCount);\n    new RexPermuteInputsShuttle(bottomBottomMapping, relC, relB)\n        .visitList(bottomNonIntersecting, newBottomList);\n    final RexBuilder rexBuilder = cluster.getRexBuilder();\n    RexNode newBottomCondition =\n        RexUtil.composeConjunction(rexBuilder, newBottomList, false);\n    final Join newBottomJoin =\n        bottomJoin.copy(bottomJoin.getTraitSet(), newBottomCondition, relC,\n            relB, bottomJoin.getJoinType(), bottomJoin.isSemiJoinDone());\n\n    \r\n    \r\n    final Mappings.TargetMapping topMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            cCount + bCount, 0, aCount,\n            cCount, aCount, bCount,\n            0, aCount + bCount, cCount);\n    final List<RexNode> newTopList = new ArrayList<>();\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relA)\n        .visitList(intersecting, newTopList);\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relA)\n        .visitList(bottomIntersecting, newTopList);\n    RexNode newTopCondition =\n        RexUtil.composeConjunction(rexBuilder, newTopList, false);\n    @SuppressWarnings(\"SuspiciousNameCombination\")\n    final Join newTopJoin =\n        topJoin.copy(topJoin.getTraitSet(), newTopCondition, newBottomJoin,\n            relA, topJoin.getJoinType(), topJoin.isSemiJoinDone());\n\n    final RelBuilder relBuilder = call.builder();\n    relBuilder.push(newTopJoin);\n    relBuilder.project(relBuilder.fields(topMapping));\n    call.transformTo(relBuilder.build());\n  }\n","date":"2015-09-28 11:22:49","endLine":317,"groupId":"16140","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"onMatchLeft","params":"(RelOptRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/40/2557d2136194b1cdb48fc78c2cc930cd0233f8.src","preCode":"  private void onMatchLeft(RelOptRuleCall call) {\n    final Join topJoin = call.rel(0);\n    final Join bottomJoin = call.rel(1);\n    final RelNode relC = call.rel(2);\n    final RelNode relA = bottomJoin.getLeft();\n    final RelNode relB = bottomJoin.getRight();\n    final RelOptCluster cluster = topJoin.getCluster();\n\n    \r\n    \r\n\r\n    \r\n\r\n\n    final int aCount = relA.getRowType().getFieldCount();\n    final int bCount = relB.getRowType().getFieldCount();\n    final int cCount = relC.getRowType().getFieldCount();\n    final ImmutableBitSet aBitSet = ImmutableBitSet.range(aCount);\n\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n\n    \r\n    \r\n    if (topJoin.getJoinType() != JoinRelType.INNER\n        || bottomJoin.getJoinType() != JoinRelType.INNER) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> intersecting = new ArrayList<RexNode>();\n    final List<RexNode> nonIntersecting = new ArrayList<RexNode>();\n    split(topJoin.getCondition(), aBitSet, intersecting, nonIntersecting);\n\n    \r\n    if (nonIntersecting.isEmpty()) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> bottomIntersecting = new ArrayList<RexNode>();\n    final List<RexNode> bottomNonIntersecting = new ArrayList<RexNode>();\n    split(\n        bottomJoin.getCondition(), aBitSet, bottomIntersecting,\n        bottomNonIntersecting);\n\n    \r\n    \r\n    final Mappings.TargetMapping bottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            cCount, aCount, bCount,\n            0, aCount + bCount, cCount);\n    List<RexNode> newBottomList = new ArrayList<RexNode>();\n    new RexPermuteInputsShuttle(bottomMapping, relC, relB)\n        .visitList(nonIntersecting, newBottomList);\n    final Mappings.TargetMapping bottomBottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, aCount + bCount, cCount,\n            cCount, aCount, bCount);\n    new RexPermuteInputsShuttle(bottomBottomMapping, relC, relB)\n        .visitList(bottomNonIntersecting, newBottomList);\n    final RexBuilder rexBuilder = cluster.getRexBuilder();\n    RexNode newBottomCondition =\n        RexUtil.composeConjunction(rexBuilder, newBottomList, false);\n    final Join newBottomJoin =\n        bottomJoin.copy(bottomJoin.getTraitSet(), newBottomCondition, relC,\n            relB, bottomJoin.getJoinType(), bottomJoin.isSemiJoinDone());\n\n    \r\n    \r\n    final Mappings.TargetMapping topMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            cCount + bCount, 0, aCount,\n            cCount, aCount, bCount,\n            0, aCount + bCount, cCount);\n    List<RexNode> newTopList = new ArrayList<RexNode>();\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relA)\n        .visitList(intersecting, newTopList);\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relA)\n        .visitList(bottomIntersecting, newTopList);\n    RexNode newTopCondition =\n        RexUtil.composeConjunction(rexBuilder, newTopList, false);\n    @SuppressWarnings(\"SuspiciousNameCombination\")\n    final Join newTopJoin =\n        topJoin.copy(topJoin.getTraitSet(), newTopCondition, newBottomJoin,\n            relA, topJoin.getJoinType(), topJoin.isSemiJoinDone());\n\n    final RelNode newProject = RelOptUtil.createProject(projectFactory,\n        newTopJoin, Mappings.asList(topMapping));\n\n    call.transformTo(newProject);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/JoinPushThroughJoinRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":216,"status":"M"}],"commitId":"815fa262b83d5a864b1eacdc3661df3b04704c20","commitMessage":"@@@[CALCITE-828] Use RelBuilder in rules rather than type-specific RelNode factories\n\nAll rules now have a RelBuilderFactory.  from which RelOptCall can\ncreate a RelBuilder. All built-in rules that took a relational\nexpression factory (for example ProjectFactory) now use the RelBuilder.\nWe have converted some.  but not all.  other implicit uses of a factory.\n\nWe now recommend that any rules that are generic have a\nRelBuilderFactory constructor parameter.  but we have not changed\nexisting rules to implement this policy. People will need to adapt\nrules and write tests to ensure the rules are generic.\n\nAdd various methods to RelBuilder.\n\nMostly we add new rule constructors and deprecate the old constructor.\nBut a few breaking changes:\n* Rename ProtoRelBuilder to RelBuilderFactory;\n* Rename DEFAULT_PROTO to LOGICAL_BUILDER;\n* Change signature of TableScan.project method;\n* Change signature of RelFieldTrimmer constructor;\n* Add filter argument to RelBuilder.aggregateCall method.\n\nAlso.  not an API change.  but a change in behavior: RelBuilder methods\nto create set operations (union.  except.  intersect) get their\nleft-to-right arguments by reading the oldest-to-newest stack elements.\n","date":"2015-09-28 11:22:49","modifiedFileCount":"49","status":"M","submitter":"Julian Hyde"},{"authorTime":"2016-05-19 21:07:18","codes":[{"authorDate":"2016-05-19 21:07:18","commitOrder":5,"curCode":"  private void onMatchRight(RelOptRuleCall call) {\n    final Join topJoin = call.rel(0);\n    final Join bottomJoin = call.rel(1);\n    final RelNode relC = call.rel(2);\n    final RelNode relA = bottomJoin.getLeft();\n    final RelNode relB = bottomJoin.getRight();\n    final RelOptCluster cluster = topJoin.getCluster();\n\n    \r\n    \r\n\r\n    \r\n\r\n\n    final int aCount = relA.getRowType().getFieldCount();\n    final int bCount = relB.getRowType().getFieldCount();\n    final int cCount = relC.getRowType().getFieldCount();\n    final ImmutableBitSet bBitSet =\n        ImmutableBitSet.range(aCount, aCount + bCount);\n\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n\n    \r\n    \r\n    if (topJoin.getJoinType() != JoinRelType.INNER\n        || bottomJoin.getJoinType() != JoinRelType.INNER) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> intersecting = new ArrayList<>();\n    final List<RexNode> nonIntersecting = new ArrayList<>();\n    split(topJoin.getCondition(), bBitSet, intersecting, nonIntersecting);\n\n    \r\n    if (nonIntersecting.isEmpty()) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> bottomIntersecting = new ArrayList<>();\n    final List<RexNode> bottomNonIntersecting = new ArrayList<>();\n    split(\n        bottomJoin.getCondition(), bBitSet, bottomIntersecting,\n        bottomNonIntersecting);\n\n    \r\n    \r\n    final Mappings.TargetMapping bottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, 0, aCount,\n            aCount, aCount + bCount, cCount);\n    final List<RexNode> newBottomList = new ArrayList<>();\n    new RexPermuteInputsShuttle(bottomMapping, relA, relC)\n        .visitList(nonIntersecting, newBottomList);\n    new RexPermuteInputsShuttle(bottomMapping, relA, relC)\n        .visitList(bottomNonIntersecting, newBottomList);\n    final RexBuilder rexBuilder = cluster.getRexBuilder();\n    RexNode newBottomCondition =\n        RexUtil.composeConjunction(rexBuilder, newBottomList, false);\n    final Join newBottomJoin =\n        bottomJoin.copy(bottomJoin.getTraitSet(), newBottomCondition, relA,\n            relC, bottomJoin.getJoinType(), bottomJoin.isSemiJoinDone());\n\n    \r\n    \r\n    final Mappings.TargetMapping topMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, 0, aCount,\n            aCount + cCount, aCount, bCount,\n            aCount, aCount + bCount, cCount);\n    final List<RexNode> newTopList = new ArrayList<>();\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relB)\n        .visitList(intersecting, newTopList);\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relB)\n        .visitList(bottomIntersecting, newTopList);\n    RexNode newTopCondition =\n        RexUtil.composeConjunction(rexBuilder, newTopList, false);\n    @SuppressWarnings(\"SuspiciousNameCombination\")\n    final Join newTopJoin =\n        topJoin.copy(topJoin.getTraitSet(), newTopCondition, newBottomJoin,\n            relB, topJoin.getJoinType(), topJoin.isSemiJoinDone());\n\n    assert !Mappings.isIdentity(topMapping);\n    final RelBuilder relBuilder = call.builder();\n    relBuilder.push(newTopJoin);\n    relBuilder.project(relBuilder.fields(topMapping));\n    call.transformTo(relBuilder.build());\n  }\n","date":"2016-05-23 03:46:46","endLine":206,"groupId":"16478","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"onMatchRight","params":"(RelOptRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/58/941305f33c3aec82d9f4416cc0320276b648ef.src","preCode":"  private void onMatchRight(RelOptRuleCall call) {\n    final Join topJoin = call.rel(0);\n    final Join bottomJoin = call.rel(1);\n    final RelNode relC = call.rel(2);\n    final RelNode relA = bottomJoin.getLeft();\n    final RelNode relB = bottomJoin.getRight();\n    final RelOptCluster cluster = topJoin.getCluster();\n\n    \r\n    \r\n\r\n    \r\n\r\n\n    final int aCount = relA.getRowType().getFieldCount();\n    final int bCount = relB.getRowType().getFieldCount();\n    final int cCount = relC.getRowType().getFieldCount();\n    final ImmutableBitSet bBitSet =\n        ImmutableBitSet.range(aCount, aCount + bCount);\n\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n\n    \r\n    \r\n    if (topJoin.getJoinType() != JoinRelType.INNER\n        || bottomJoin.getJoinType() != JoinRelType.INNER) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> intersecting = new ArrayList<>();\n    final List<RexNode> nonIntersecting = new ArrayList<>();\n    split(topJoin.getCondition(), bBitSet, intersecting, nonIntersecting);\n\n    \r\n    if (nonIntersecting.isEmpty()) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> bottomIntersecting = new ArrayList<>();\n    final List<RexNode> bottomNonIntersecting = new ArrayList<>();\n    split(\n        bottomJoin.getCondition(), bBitSet, bottomIntersecting,\n        bottomNonIntersecting);\n\n    \r\n    \r\n    final Mappings.TargetMapping bottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, 0, aCount,\n            aCount, aCount + bCount, cCount);\n    final List<RexNode> newBottomList = new ArrayList<>();\n    new RexPermuteInputsShuttle(bottomMapping, relA, relC)\n        .visitList(nonIntersecting, newBottomList);\n    final Mappings.TargetMapping bottomBottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount,\n            0, 0, aCount);\n    new RexPermuteInputsShuttle(bottomBottomMapping, relA, relC)\n        .visitList(bottomNonIntersecting, newBottomList);\n    final RexBuilder rexBuilder = cluster.getRexBuilder();\n    RexNode newBottomCondition =\n        RexUtil.composeConjunction(rexBuilder, newBottomList, false);\n    final Join newBottomJoin =\n        bottomJoin.copy(bottomJoin.getTraitSet(), newBottomCondition, relA,\n            relC, bottomJoin.getJoinType(), bottomJoin.isSemiJoinDone());\n\n    \r\n    \r\n    final Mappings.TargetMapping topMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, 0, aCount,\n            aCount + cCount, aCount, bCount,\n            aCount, aCount + bCount, cCount);\n    final List<RexNode> newTopList = new ArrayList<>();\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relB)\n        .visitList(intersecting, newTopList);\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relB)\n        .visitList(bottomIntersecting, newTopList);\n    RexNode newTopCondition =\n        RexUtil.composeConjunction(rexBuilder, newTopList, false);\n    @SuppressWarnings(\"SuspiciousNameCombination\")\n    final Join newTopJoin =\n        topJoin.copy(topJoin.getTraitSet(), newTopCondition, newBottomJoin,\n            relB, topJoin.getJoinType(), topJoin.isSemiJoinDone());\n\n    assert !Mappings.isIdentity(topMapping);\n    final RelBuilder relBuilder = call.builder();\n    relBuilder.push(newTopJoin);\n    relBuilder.project(relBuilder.fields(topMapping));\n    call.transformTo(relBuilder.build());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/JoinPushThroughJoinRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":108,"status":"M"},{"authorDate":"2016-05-19 21:07:18","commitOrder":5,"curCode":"  private void onMatchLeft(RelOptRuleCall call) {\n    final Join topJoin = call.rel(0);\n    final Join bottomJoin = call.rel(1);\n    final RelNode relC = call.rel(2);\n    final RelNode relA = bottomJoin.getLeft();\n    final RelNode relB = bottomJoin.getRight();\n    final RelOptCluster cluster = topJoin.getCluster();\n\n    \r\n    \r\n\r\n    \r\n\r\n\n    final int aCount = relA.getRowType().getFieldCount();\n    final int bCount = relB.getRowType().getFieldCount();\n    final int cCount = relC.getRowType().getFieldCount();\n    final ImmutableBitSet aBitSet = ImmutableBitSet.range(aCount);\n\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n\n    \r\n    \r\n    if (topJoin.getJoinType() != JoinRelType.INNER\n        || bottomJoin.getJoinType() != JoinRelType.INNER) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> intersecting = new ArrayList<>();\n    final List<RexNode> nonIntersecting = new ArrayList<>();\n    split(topJoin.getCondition(), aBitSet, intersecting, nonIntersecting);\n\n    \r\n    if (nonIntersecting.isEmpty()) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> bottomIntersecting = new ArrayList<>();\n    final List<RexNode> bottomNonIntersecting = new ArrayList<>();\n    split(\n        bottomJoin.getCondition(), aBitSet, bottomIntersecting,\n        bottomNonIntersecting);\n\n    \r\n    \r\n    final Mappings.TargetMapping bottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            cCount, aCount, bCount,\n            0, aCount + bCount, cCount);\n    final List<RexNode> newBottomList = new ArrayList<>();\n    new RexPermuteInputsShuttle(bottomMapping, relC, relB)\n        .visitList(nonIntersecting, newBottomList);\n    new RexPermuteInputsShuttle(bottomMapping, relC, relB)\n        .visitList(bottomNonIntersecting, newBottomList);\n    final RexBuilder rexBuilder = cluster.getRexBuilder();\n    RexNode newBottomCondition =\n        RexUtil.composeConjunction(rexBuilder, newBottomList, false);\n    final Join newBottomJoin =\n        bottomJoin.copy(bottomJoin.getTraitSet(), newBottomCondition, relC,\n            relB, bottomJoin.getJoinType(), bottomJoin.isSemiJoinDone());\n\n    \r\n    \r\n    final Mappings.TargetMapping topMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            cCount + bCount, 0, aCount,\n            cCount, aCount, bCount,\n            0, aCount + bCount, cCount);\n    final List<RexNode> newTopList = new ArrayList<>();\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relA)\n        .visitList(intersecting, newTopList);\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relA)\n        .visitList(bottomIntersecting, newTopList);\n    RexNode newTopCondition =\n        RexUtil.composeConjunction(rexBuilder, newTopList, false);\n    @SuppressWarnings(\"SuspiciousNameCombination\")\n    final Join newTopJoin =\n        topJoin.copy(topJoin.getTraitSet(), newTopCondition, newBottomJoin,\n            relA, topJoin.getJoinType(), topJoin.isSemiJoinDone());\n\n    final RelBuilder relBuilder = call.builder();\n    relBuilder.push(newTopJoin);\n    relBuilder.project(relBuilder.fields(topMapping));\n    call.transformTo(relBuilder.build());\n  }\n","date":"2016-05-23 03:46:46","endLine":308,"groupId":"16140","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"onMatchLeft","params":"(RelOptRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/58/941305f33c3aec82d9f4416cc0320276b648ef.src","preCode":"  private void onMatchLeft(RelOptRuleCall call) {\n    final Join topJoin = call.rel(0);\n    final Join bottomJoin = call.rel(1);\n    final RelNode relC = call.rel(2);\n    final RelNode relA = bottomJoin.getLeft();\n    final RelNode relB = bottomJoin.getRight();\n    final RelOptCluster cluster = topJoin.getCluster();\n\n    \r\n    \r\n\r\n    \r\n\r\n\n    final int aCount = relA.getRowType().getFieldCount();\n    final int bCount = relB.getRowType().getFieldCount();\n    final int cCount = relC.getRowType().getFieldCount();\n    final ImmutableBitSet aBitSet = ImmutableBitSet.range(aCount);\n\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n\n    \r\n    \r\n    if (topJoin.getJoinType() != JoinRelType.INNER\n        || bottomJoin.getJoinType() != JoinRelType.INNER) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> intersecting = new ArrayList<>();\n    final List<RexNode> nonIntersecting = new ArrayList<>();\n    split(topJoin.getCondition(), aBitSet, intersecting, nonIntersecting);\n\n    \r\n    if (nonIntersecting.isEmpty()) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> bottomIntersecting = new ArrayList<>();\n    final List<RexNode> bottomNonIntersecting = new ArrayList<>();\n    split(\n        bottomJoin.getCondition(), aBitSet, bottomIntersecting,\n        bottomNonIntersecting);\n\n    \r\n    \r\n    final Mappings.TargetMapping bottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            cCount, aCount, bCount,\n            0, aCount + bCount, cCount);\n    final List<RexNode> newBottomList = new ArrayList<>();\n    new RexPermuteInputsShuttle(bottomMapping, relC, relB)\n        .visitList(nonIntersecting, newBottomList);\n    final Mappings.TargetMapping bottomBottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, aCount + bCount, cCount,\n            cCount, aCount, bCount);\n    new RexPermuteInputsShuttle(bottomBottomMapping, relC, relB)\n        .visitList(bottomNonIntersecting, newBottomList);\n    final RexBuilder rexBuilder = cluster.getRexBuilder();\n    RexNode newBottomCondition =\n        RexUtil.composeConjunction(rexBuilder, newBottomList, false);\n    final Join newBottomJoin =\n        bottomJoin.copy(bottomJoin.getTraitSet(), newBottomCondition, relC,\n            relB, bottomJoin.getJoinType(), bottomJoin.isSemiJoinDone());\n\n    \r\n    \r\n    final Mappings.TargetMapping topMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            cCount + bCount, 0, aCount,\n            cCount, aCount, bCount,\n            0, aCount + bCount, cCount);\n    final List<RexNode> newTopList = new ArrayList<>();\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relA)\n        .visitList(intersecting, newTopList);\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relA)\n        .visitList(bottomIntersecting, newTopList);\n    RexNode newTopCondition =\n        RexUtil.composeConjunction(rexBuilder, newTopList, false);\n    @SuppressWarnings(\"SuspiciousNameCombination\")\n    final Join newTopJoin =\n        topJoin.copy(topJoin.getTraitSet(), newTopCondition, newBottomJoin,\n            relA, topJoin.getJoinType(), topJoin.isSemiJoinDone());\n\n    final RelBuilder relBuilder = call.builder();\n    relBuilder.push(newTopJoin);\n    relBuilder.project(relBuilder.fields(topMapping));\n    call.transformTo(relBuilder.build());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/JoinPushThroughJoinRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":212,"status":"M"}],"commitId":"b6f0e1021b8d8e0dc08e6da49391a76cdb6cfb14","commitMessage":"@@@[CALCITE-1246] Cleanup duplicate variables in JoinPushThroughJoinRule (Yi Xinglu)\n\nAlso.  fix typo in comment.\n\nClose apache/calcite#234\n","date":"2016-05-23 03:46:46","modifiedFileCount":"1","status":"M","submitter":"yixinglu"},{"authorTime":"2018-09-28 09:34:22","codes":[{"authorDate":"2018-09-28 09:34:22","commitOrder":6,"curCode":"  private void onMatchRight(RelOptRuleCall call) {\n    final Join topJoin = call.rel(0);\n    final Join bottomJoin = call.rel(1);\n    final RelNode relC = call.rel(2);\n    final RelNode relA = bottomJoin.getLeft();\n    final RelNode relB = bottomJoin.getRight();\n    final RelOptCluster cluster = topJoin.getCluster();\n\n    \r\n    \r\n\r\n    \r\n\r\n\n    final int aCount = relA.getRowType().getFieldCount();\n    final int bCount = relB.getRowType().getFieldCount();\n    final int cCount = relC.getRowType().getFieldCount();\n    final ImmutableBitSet bBitSet =\n        ImmutableBitSet.range(aCount, aCount + bCount);\n\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n\n    \r\n    \r\n    if (topJoin.getJoinType() != JoinRelType.INNER\n        || bottomJoin.getJoinType() != JoinRelType.INNER) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> intersecting = new ArrayList<>();\n    final List<RexNode> nonIntersecting = new ArrayList<>();\n    split(topJoin.getCondition(), bBitSet, intersecting, nonIntersecting);\n\n    \r\n    if (nonIntersecting.isEmpty()) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> bottomIntersecting = new ArrayList<>();\n    final List<RexNode> bottomNonIntersecting = new ArrayList<>();\n    split(\n        bottomJoin.getCondition(), bBitSet, bottomIntersecting,\n        bottomNonIntersecting);\n\n    \r\n    \r\n    final Mappings.TargetMapping bottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, 0, aCount,\n            aCount, aCount + bCount, cCount);\n    final List<RexNode> newBottomList = new ArrayList<>();\n    new RexPermuteInputsShuttle(bottomMapping, relA, relC)\n        .visitList(nonIntersecting, newBottomList);\n    new RexPermuteInputsShuttle(bottomMapping, relA, relC)\n        .visitList(bottomNonIntersecting, newBottomList);\n    final RexBuilder rexBuilder = cluster.getRexBuilder();\n    RexNode newBottomCondition =\n        RexUtil.composeConjunction(rexBuilder, newBottomList);\n    final Join newBottomJoin =\n        bottomJoin.copy(bottomJoin.getTraitSet(), newBottomCondition, relA,\n            relC, bottomJoin.getJoinType(), bottomJoin.isSemiJoinDone());\n\n    \r\n    \r\n    final Mappings.TargetMapping topMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, 0, aCount,\n            aCount + cCount, aCount, bCount,\n            aCount, aCount + bCount, cCount);\n    final List<RexNode> newTopList = new ArrayList<>();\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relB)\n        .visitList(intersecting, newTopList);\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relB)\n        .visitList(bottomIntersecting, newTopList);\n    RexNode newTopCondition =\n        RexUtil.composeConjunction(rexBuilder, newTopList);\n    @SuppressWarnings(\"SuspiciousNameCombination\")\n    final Join newTopJoin =\n        topJoin.copy(topJoin.getTraitSet(), newTopCondition, newBottomJoin,\n            relB, topJoin.getJoinType(), topJoin.isSemiJoinDone());\n\n    assert !Mappings.isIdentity(topMapping);\n    final RelBuilder relBuilder = call.builder();\n    relBuilder.push(newTopJoin);\n    relBuilder.project(relBuilder.fields(topMapping));\n    call.transformTo(relBuilder.build());\n  }\n","date":"2018-10-08 04:34:53","endLine":207,"groupId":"16478","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"onMatchRight","params":"(RelOptRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/76/606a815a2aafde533e0d3a67bf3808b4d4426d.src","preCode":"  private void onMatchRight(RelOptRuleCall call) {\n    final Join topJoin = call.rel(0);\n    final Join bottomJoin = call.rel(1);\n    final RelNode relC = call.rel(2);\n    final RelNode relA = bottomJoin.getLeft();\n    final RelNode relB = bottomJoin.getRight();\n    final RelOptCluster cluster = topJoin.getCluster();\n\n    \r\n    \r\n\r\n    \r\n\r\n\n    final int aCount = relA.getRowType().getFieldCount();\n    final int bCount = relB.getRowType().getFieldCount();\n    final int cCount = relC.getRowType().getFieldCount();\n    final ImmutableBitSet bBitSet =\n        ImmutableBitSet.range(aCount, aCount + bCount);\n\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n\n    \r\n    \r\n    if (topJoin.getJoinType() != JoinRelType.INNER\n        || bottomJoin.getJoinType() != JoinRelType.INNER) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> intersecting = new ArrayList<>();\n    final List<RexNode> nonIntersecting = new ArrayList<>();\n    split(topJoin.getCondition(), bBitSet, intersecting, nonIntersecting);\n\n    \r\n    if (nonIntersecting.isEmpty()) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> bottomIntersecting = new ArrayList<>();\n    final List<RexNode> bottomNonIntersecting = new ArrayList<>();\n    split(\n        bottomJoin.getCondition(), bBitSet, bottomIntersecting,\n        bottomNonIntersecting);\n\n    \r\n    \r\n    final Mappings.TargetMapping bottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, 0, aCount,\n            aCount, aCount + bCount, cCount);\n    final List<RexNode> newBottomList = new ArrayList<>();\n    new RexPermuteInputsShuttle(bottomMapping, relA, relC)\n        .visitList(nonIntersecting, newBottomList);\n    new RexPermuteInputsShuttle(bottomMapping, relA, relC)\n        .visitList(bottomNonIntersecting, newBottomList);\n    final RexBuilder rexBuilder = cluster.getRexBuilder();\n    RexNode newBottomCondition =\n        RexUtil.composeConjunction(rexBuilder, newBottomList, false);\n    final Join newBottomJoin =\n        bottomJoin.copy(bottomJoin.getTraitSet(), newBottomCondition, relA,\n            relC, bottomJoin.getJoinType(), bottomJoin.isSemiJoinDone());\n\n    \r\n    \r\n    final Mappings.TargetMapping topMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, 0, aCount,\n            aCount + cCount, aCount, bCount,\n            aCount, aCount + bCount, cCount);\n    final List<RexNode> newTopList = new ArrayList<>();\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relB)\n        .visitList(intersecting, newTopList);\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relB)\n        .visitList(bottomIntersecting, newTopList);\n    RexNode newTopCondition =\n        RexUtil.composeConjunction(rexBuilder, newTopList, false);\n    @SuppressWarnings(\"SuspiciousNameCombination\")\n    final Join newTopJoin =\n        topJoin.copy(topJoin.getTraitSet(), newTopCondition, newBottomJoin,\n            relB, topJoin.getJoinType(), topJoin.isSemiJoinDone());\n\n    assert !Mappings.isIdentity(topMapping);\n    final RelBuilder relBuilder = call.builder();\n    relBuilder.push(newTopJoin);\n    relBuilder.project(relBuilder.fields(topMapping));\n    call.transformTo(relBuilder.build());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/JoinPushThroughJoinRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":109,"status":"M"},{"authorDate":"2018-09-28 09:34:22","commitOrder":6,"curCode":"  private void onMatchLeft(RelOptRuleCall call) {\n    final Join topJoin = call.rel(0);\n    final Join bottomJoin = call.rel(1);\n    final RelNode relC = call.rel(2);\n    final RelNode relA = bottomJoin.getLeft();\n    final RelNode relB = bottomJoin.getRight();\n    final RelOptCluster cluster = topJoin.getCluster();\n\n    \r\n    \r\n\r\n    \r\n\r\n\n    final int aCount = relA.getRowType().getFieldCount();\n    final int bCount = relB.getRowType().getFieldCount();\n    final int cCount = relC.getRowType().getFieldCount();\n    final ImmutableBitSet aBitSet = ImmutableBitSet.range(aCount);\n\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n\n    \r\n    \r\n    if (topJoin.getJoinType() != JoinRelType.INNER\n        || bottomJoin.getJoinType() != JoinRelType.INNER) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> intersecting = new ArrayList<>();\n    final List<RexNode> nonIntersecting = new ArrayList<>();\n    split(topJoin.getCondition(), aBitSet, intersecting, nonIntersecting);\n\n    \r\n    if (nonIntersecting.isEmpty()) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> bottomIntersecting = new ArrayList<>();\n    final List<RexNode> bottomNonIntersecting = new ArrayList<>();\n    split(\n        bottomJoin.getCondition(), aBitSet, bottomIntersecting,\n        bottomNonIntersecting);\n\n    \r\n    \r\n    final Mappings.TargetMapping bottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            cCount, aCount, bCount,\n            0, aCount + bCount, cCount);\n    final List<RexNode> newBottomList = new ArrayList<>();\n    new RexPermuteInputsShuttle(bottomMapping, relC, relB)\n        .visitList(nonIntersecting, newBottomList);\n    new RexPermuteInputsShuttle(bottomMapping, relC, relB)\n        .visitList(bottomNonIntersecting, newBottomList);\n    final RexBuilder rexBuilder = cluster.getRexBuilder();\n    RexNode newBottomCondition =\n        RexUtil.composeConjunction(rexBuilder, newBottomList);\n    final Join newBottomJoin =\n        bottomJoin.copy(bottomJoin.getTraitSet(), newBottomCondition, relC,\n            relB, bottomJoin.getJoinType(), bottomJoin.isSemiJoinDone());\n\n    \r\n    \r\n    final Mappings.TargetMapping topMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            cCount + bCount, 0, aCount,\n            cCount, aCount, bCount,\n            0, aCount + bCount, cCount);\n    final List<RexNode> newTopList = new ArrayList<>();\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relA)\n        .visitList(intersecting, newTopList);\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relA)\n        .visitList(bottomIntersecting, newTopList);\n    RexNode newTopCondition =\n        RexUtil.composeConjunction(rexBuilder, newTopList);\n    @SuppressWarnings(\"SuspiciousNameCombination\")\n    final Join newTopJoin =\n        topJoin.copy(topJoin.getTraitSet(), newTopCondition, newBottomJoin,\n            relA, topJoin.getJoinType(), topJoin.isSemiJoinDone());\n\n    final RelBuilder relBuilder = call.builder();\n    relBuilder.push(newTopJoin);\n    relBuilder.project(relBuilder.fields(topMapping));\n    call.transformTo(relBuilder.build());\n  }\n","date":"2018-10-08 04:34:53","endLine":309,"groupId":"16140","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"onMatchLeft","params":"(RelOptRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/76/606a815a2aafde533e0d3a67bf3808b4d4426d.src","preCode":"  private void onMatchLeft(RelOptRuleCall call) {\n    final Join topJoin = call.rel(0);\n    final Join bottomJoin = call.rel(1);\n    final RelNode relC = call.rel(2);\n    final RelNode relA = bottomJoin.getLeft();\n    final RelNode relB = bottomJoin.getRight();\n    final RelOptCluster cluster = topJoin.getCluster();\n\n    \r\n    \r\n\r\n    \r\n\r\n\n    final int aCount = relA.getRowType().getFieldCount();\n    final int bCount = relB.getRowType().getFieldCount();\n    final int cCount = relC.getRowType().getFieldCount();\n    final ImmutableBitSet aBitSet = ImmutableBitSet.range(aCount);\n\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n\n    \r\n    \r\n    if (topJoin.getJoinType() != JoinRelType.INNER\n        || bottomJoin.getJoinType() != JoinRelType.INNER) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> intersecting = new ArrayList<>();\n    final List<RexNode> nonIntersecting = new ArrayList<>();\n    split(topJoin.getCondition(), aBitSet, intersecting, nonIntersecting);\n\n    \r\n    if (nonIntersecting.isEmpty()) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> bottomIntersecting = new ArrayList<>();\n    final List<RexNode> bottomNonIntersecting = new ArrayList<>();\n    split(\n        bottomJoin.getCondition(), aBitSet, bottomIntersecting,\n        bottomNonIntersecting);\n\n    \r\n    \r\n    final Mappings.TargetMapping bottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            cCount, aCount, bCount,\n            0, aCount + bCount, cCount);\n    final List<RexNode> newBottomList = new ArrayList<>();\n    new RexPermuteInputsShuttle(bottomMapping, relC, relB)\n        .visitList(nonIntersecting, newBottomList);\n    new RexPermuteInputsShuttle(bottomMapping, relC, relB)\n        .visitList(bottomNonIntersecting, newBottomList);\n    final RexBuilder rexBuilder = cluster.getRexBuilder();\n    RexNode newBottomCondition =\n        RexUtil.composeConjunction(rexBuilder, newBottomList, false);\n    final Join newBottomJoin =\n        bottomJoin.copy(bottomJoin.getTraitSet(), newBottomCondition, relC,\n            relB, bottomJoin.getJoinType(), bottomJoin.isSemiJoinDone());\n\n    \r\n    \r\n    final Mappings.TargetMapping topMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            cCount + bCount, 0, aCount,\n            cCount, aCount, bCount,\n            0, aCount + bCount, cCount);\n    final List<RexNode> newTopList = new ArrayList<>();\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relA)\n        .visitList(intersecting, newTopList);\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relA)\n        .visitList(bottomIntersecting, newTopList);\n    RexNode newTopCondition =\n        RexUtil.composeConjunction(rexBuilder, newTopList, false);\n    @SuppressWarnings(\"SuspiciousNameCombination\")\n    final Join newTopJoin =\n        topJoin.copy(topJoin.getTraitSet(), newTopCondition, newBottomJoin,\n            relA, topJoin.getJoinType(), topJoin.isSemiJoinDone());\n\n    final RelBuilder relBuilder = call.builder();\n    relBuilder.push(newTopJoin);\n    relBuilder.project(relBuilder.fields(topMapping));\n    call.transformTo(relBuilder.build());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/JoinPushThroughJoinRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":213,"status":"M"}],"commitId":"6b3844c0634792263a5073b8ea93565fb3415f41","commitMessage":"@@@[CALCITE-2604] When simplifying an expression.  say whether an UNKNOWN value will be interpreted as is.  or as TRUE or FALSE\n\nAdd class RexUnknownAs to describe policy.  and make it an argument to\ninternal methods; public methods such as RexSimplify.simplify(RexNode)\nand RexSimplify.simplifyAnds(Iterable) use UNKNOWN. (The RexSimplify\nconstructor that allows a different policy than UNKNOWN is deprecated. \nand even if you use the deprecated constructor.  that policy only\napplies to the top-level expression.  not arguments to it.)\n\nAdd RexSimplify.simplify(RexNode.  RexUnknownAs) (mainly for internal\nuse).  and RexSimplify.simplifyUnknownAsFalse(RexNode) (for public use).\n\nAdd variant of RexUtil.composeConjunction that never returns null. \nwith @Nonnull annotation.\n","date":"2018-10-08 04:34:53","modifiedFileCount":"28","status":"M","submitter":"Julian Hyde"},{"authorTime":"2020-12-02 05:40:39","codes":[{"authorDate":"2020-12-02 05:40:39","commitOrder":7,"curCode":"  private static void onMatchRight(RelOptRuleCall call) {\n    final Join topJoin = call.rel(0);\n    final Join bottomJoin = call.rel(1);\n    final RelNode relC = call.rel(2);\n    final RelNode relA = bottomJoin.getLeft();\n    final RelNode relB = bottomJoin.getRight();\n    final RelOptCluster cluster = topJoin.getCluster();\n\n    \r\n    \r\n\r\n    \r\n\r\n\n    final int aCount = relA.getRowType().getFieldCount();\n    final int bCount = relB.getRowType().getFieldCount();\n    final int cCount = relC.getRowType().getFieldCount();\n    final ImmutableBitSet bBitSet =\n        ImmutableBitSet.range(aCount, aCount + bCount);\n\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n\n    \r\n    \r\n    if (topJoin.getJoinType() != JoinRelType.INNER\n        || bottomJoin.getJoinType() != JoinRelType.INNER) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> intersecting = new ArrayList<>();\n    final List<RexNode> nonIntersecting = new ArrayList<>();\n    split(topJoin.getCondition(), bBitSet, intersecting, nonIntersecting);\n\n    \r\n    if (nonIntersecting.isEmpty()) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> bottomIntersecting = new ArrayList<>();\n    final List<RexNode> bottomNonIntersecting = new ArrayList<>();\n    split(\n        bottomJoin.getCondition(), bBitSet, bottomIntersecting,\n        bottomNonIntersecting);\n\n    \r\n    \r\n    final Mappings.TargetMapping bottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, 0, aCount,\n            aCount, aCount + bCount, cCount);\n    final List<RexNode> newBottomList = new ArrayList<>();\n    new RexPermuteInputsShuttle(bottomMapping, relA, relC)\n        .visitList(nonIntersecting, newBottomList);\n    new RexPermuteInputsShuttle(bottomMapping, relA, relC)\n        .visitList(bottomNonIntersecting, newBottomList);\n    final RexBuilder rexBuilder = cluster.getRexBuilder();\n    RexNode newBottomCondition =\n        RexUtil.composeConjunction(rexBuilder, newBottomList);\n    final Join newBottomJoin =\n        bottomJoin.copy(bottomJoin.getTraitSet(), newBottomCondition, relA,\n            relC, bottomJoin.getJoinType(), bottomJoin.isSemiJoinDone());\n\n    \r\n    \r\n    final Mappings.TargetMapping topMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, 0, aCount,\n            aCount + cCount, aCount, bCount,\n            aCount, aCount + bCount, cCount);\n    final List<RexNode> newTopList = new ArrayList<>();\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relB)\n        .visitList(intersecting, newTopList);\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relB)\n        .visitList(bottomIntersecting, newTopList);\n    RexNode newTopCondition =\n        RexUtil.composeConjunction(rexBuilder, newTopList);\n    @SuppressWarnings(\"SuspiciousNameCombination\")\n    final Join newTopJoin =\n        topJoin.copy(topJoin.getTraitSet(), newTopCondition, newBottomJoin,\n            relB, topJoin.getJoinType(), topJoin.isSemiJoinDone());\n\n    assert !Mappings.isIdentity(topMapping);\n    final RelBuilder relBuilder = call.builder();\n    relBuilder.push(newTopJoin);\n    relBuilder.project(relBuilder.fields(topMapping));\n    call.transformTo(relBuilder.build());\n  }\n","date":"2020-12-08 15:07:23","endLine":207,"groupId":"101967","id":13,"instanceNumber":1,"isCurCommit":1,"methodName":"onMatchRight","params":"(RelOptRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/18/63d3196a47e4e765cfc612581f453af8d31d02.src","preCode":"  private void onMatchRight(RelOptRuleCall call) {\n    final Join topJoin = call.rel(0);\n    final Join bottomJoin = call.rel(1);\n    final RelNode relC = call.rel(2);\n    final RelNode relA = bottomJoin.getLeft();\n    final RelNode relB = bottomJoin.getRight();\n    final RelOptCluster cluster = topJoin.getCluster();\n\n    \r\n    \r\n\r\n    \r\n\r\n\n    final int aCount = relA.getRowType().getFieldCount();\n    final int bCount = relB.getRowType().getFieldCount();\n    final int cCount = relC.getRowType().getFieldCount();\n    final ImmutableBitSet bBitSet =\n        ImmutableBitSet.range(aCount, aCount + bCount);\n\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n\n    \r\n    \r\n    if (topJoin.getJoinType() != JoinRelType.INNER\n        || bottomJoin.getJoinType() != JoinRelType.INNER) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> intersecting = new ArrayList<>();\n    final List<RexNode> nonIntersecting = new ArrayList<>();\n    split(topJoin.getCondition(), bBitSet, intersecting, nonIntersecting);\n\n    \r\n    if (nonIntersecting.isEmpty()) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> bottomIntersecting = new ArrayList<>();\n    final List<RexNode> bottomNonIntersecting = new ArrayList<>();\n    split(\n        bottomJoin.getCondition(), bBitSet, bottomIntersecting,\n        bottomNonIntersecting);\n\n    \r\n    \r\n    final Mappings.TargetMapping bottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, 0, aCount,\n            aCount, aCount + bCount, cCount);\n    final List<RexNode> newBottomList = new ArrayList<>();\n    new RexPermuteInputsShuttle(bottomMapping, relA, relC)\n        .visitList(nonIntersecting, newBottomList);\n    new RexPermuteInputsShuttle(bottomMapping, relA, relC)\n        .visitList(bottomNonIntersecting, newBottomList);\n    final RexBuilder rexBuilder = cluster.getRexBuilder();\n    RexNode newBottomCondition =\n        RexUtil.composeConjunction(rexBuilder, newBottomList);\n    final Join newBottomJoin =\n        bottomJoin.copy(bottomJoin.getTraitSet(), newBottomCondition, relA,\n            relC, bottomJoin.getJoinType(), bottomJoin.isSemiJoinDone());\n\n    \r\n    \r\n    final Mappings.TargetMapping topMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            0, 0, aCount,\n            aCount + cCount, aCount, bCount,\n            aCount, aCount + bCount, cCount);\n    final List<RexNode> newTopList = new ArrayList<>();\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relB)\n        .visitList(intersecting, newTopList);\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relB)\n        .visitList(bottomIntersecting, newTopList);\n    RexNode newTopCondition =\n        RexUtil.composeConjunction(rexBuilder, newTopList);\n    @SuppressWarnings(\"SuspiciousNameCombination\")\n    final Join newTopJoin =\n        topJoin.copy(topJoin.getTraitSet(), newTopCondition, newBottomJoin,\n            relB, topJoin.getJoinType(), topJoin.isSemiJoinDone());\n\n    assert !Mappings.isIdentity(topMapping);\n    final RelBuilder relBuilder = call.builder();\n    relBuilder.push(newTopJoin);\n    relBuilder.project(relBuilder.fields(topMapping));\n    call.transformTo(relBuilder.build());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/JoinPushThroughJoinRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":109,"status":"M"},{"authorDate":"2020-12-02 05:40:39","commitOrder":7,"curCode":"  private static void onMatchLeft(RelOptRuleCall call) {\n    final Join topJoin = call.rel(0);\n    final Join bottomJoin = call.rel(1);\n    final RelNode relC = call.rel(2);\n    final RelNode relA = bottomJoin.getLeft();\n    final RelNode relB = bottomJoin.getRight();\n    final RelOptCluster cluster = topJoin.getCluster();\n\n    \r\n    \r\n\r\n    \r\n\r\n\n    final int aCount = relA.getRowType().getFieldCount();\n    final int bCount = relB.getRowType().getFieldCount();\n    final int cCount = relC.getRowType().getFieldCount();\n    final ImmutableBitSet aBitSet = ImmutableBitSet.range(aCount);\n\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n\n    \r\n    \r\n    if (topJoin.getJoinType() != JoinRelType.INNER\n        || bottomJoin.getJoinType() != JoinRelType.INNER) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> intersecting = new ArrayList<>();\n    final List<RexNode> nonIntersecting = new ArrayList<>();\n    split(topJoin.getCondition(), aBitSet, intersecting, nonIntersecting);\n\n    \r\n    if (nonIntersecting.isEmpty()) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> bottomIntersecting = new ArrayList<>();\n    final List<RexNode> bottomNonIntersecting = new ArrayList<>();\n    split(\n        bottomJoin.getCondition(), aBitSet, bottomIntersecting,\n        bottomNonIntersecting);\n\n    \r\n    \r\n    final Mappings.TargetMapping bottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            cCount, aCount, bCount,\n            0, aCount + bCount, cCount);\n    final List<RexNode> newBottomList = new ArrayList<>();\n    new RexPermuteInputsShuttle(bottomMapping, relC, relB)\n        .visitList(nonIntersecting, newBottomList);\n    new RexPermuteInputsShuttle(bottomMapping, relC, relB)\n        .visitList(bottomNonIntersecting, newBottomList);\n    final RexBuilder rexBuilder = cluster.getRexBuilder();\n    RexNode newBottomCondition =\n        RexUtil.composeConjunction(rexBuilder, newBottomList);\n    final Join newBottomJoin =\n        bottomJoin.copy(bottomJoin.getTraitSet(), newBottomCondition, relC,\n            relB, bottomJoin.getJoinType(), bottomJoin.isSemiJoinDone());\n\n    \r\n    \r\n    final Mappings.TargetMapping topMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            cCount + bCount, 0, aCount,\n            cCount, aCount, bCount,\n            0, aCount + bCount, cCount);\n    final List<RexNode> newTopList = new ArrayList<>();\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relA)\n        .visitList(intersecting, newTopList);\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relA)\n        .visitList(bottomIntersecting, newTopList);\n    RexNode newTopCondition =\n        RexUtil.composeConjunction(rexBuilder, newTopList);\n    @SuppressWarnings(\"SuspiciousNameCombination\")\n    final Join newTopJoin =\n        topJoin.copy(topJoin.getTraitSet(), newTopCondition, newBottomJoin,\n            relA, topJoin.getJoinType(), topJoin.isSemiJoinDone());\n\n    final RelBuilder relBuilder = call.builder();\n    relBuilder.push(newTopJoin);\n    relBuilder.project(relBuilder.fields(topMapping));\n    call.transformTo(relBuilder.build());\n  }\n","date":"2020-12-08 15:07:23","endLine":309,"groupId":"101967","id":14,"instanceNumber":2,"isCurCommit":1,"methodName":"onMatchLeft","params":"(RelOptRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/18/63d3196a47e4e765cfc612581f453af8d31d02.src","preCode":"  private void onMatchLeft(RelOptRuleCall call) {\n    final Join topJoin = call.rel(0);\n    final Join bottomJoin = call.rel(1);\n    final RelNode relC = call.rel(2);\n    final RelNode relA = bottomJoin.getLeft();\n    final RelNode relB = bottomJoin.getRight();\n    final RelOptCluster cluster = topJoin.getCluster();\n\n    \r\n    \r\n\r\n    \r\n\r\n\n    final int aCount = relA.getRowType().getFieldCount();\n    final int bCount = relB.getRowType().getFieldCount();\n    final int cCount = relC.getRowType().getFieldCount();\n    final ImmutableBitSet aBitSet = ImmutableBitSet.range(aCount);\n\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n\n    \r\n    \r\n    if (topJoin.getJoinType() != JoinRelType.INNER\n        || bottomJoin.getJoinType() != JoinRelType.INNER) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> intersecting = new ArrayList<>();\n    final List<RexNode> nonIntersecting = new ArrayList<>();\n    split(topJoin.getCondition(), aBitSet, intersecting, nonIntersecting);\n\n    \r\n    if (nonIntersecting.isEmpty()) {\n      return;\n    }\n\n    \r\n    \r\n    final List<RexNode> bottomIntersecting = new ArrayList<>();\n    final List<RexNode> bottomNonIntersecting = new ArrayList<>();\n    split(\n        bottomJoin.getCondition(), aBitSet, bottomIntersecting,\n        bottomNonIntersecting);\n\n    \r\n    \r\n    final Mappings.TargetMapping bottomMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            cCount, aCount, bCount,\n            0, aCount + bCount, cCount);\n    final List<RexNode> newBottomList = new ArrayList<>();\n    new RexPermuteInputsShuttle(bottomMapping, relC, relB)\n        .visitList(nonIntersecting, newBottomList);\n    new RexPermuteInputsShuttle(bottomMapping, relC, relB)\n        .visitList(bottomNonIntersecting, newBottomList);\n    final RexBuilder rexBuilder = cluster.getRexBuilder();\n    RexNode newBottomCondition =\n        RexUtil.composeConjunction(rexBuilder, newBottomList);\n    final Join newBottomJoin =\n        bottomJoin.copy(bottomJoin.getTraitSet(), newBottomCondition, relC,\n            relB, bottomJoin.getJoinType(), bottomJoin.isSemiJoinDone());\n\n    \r\n    \r\n    final Mappings.TargetMapping topMapping =\n        Mappings.createShiftMapping(\n            aCount + bCount + cCount,\n            cCount + bCount, 0, aCount,\n            cCount, aCount, bCount,\n            0, aCount + bCount, cCount);\n    final List<RexNode> newTopList = new ArrayList<>();\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relA)\n        .visitList(intersecting, newTopList);\n    new RexPermuteInputsShuttle(topMapping, newBottomJoin, relA)\n        .visitList(bottomIntersecting, newTopList);\n    RexNode newTopCondition =\n        RexUtil.composeConjunction(rexBuilder, newTopList);\n    @SuppressWarnings(\"SuspiciousNameCombination\")\n    final Join newTopJoin =\n        topJoin.copy(topJoin.getTraitSet(), newTopCondition, newBottomJoin,\n            relA, topJoin.getJoinType(), topJoin.isSemiJoinDone());\n\n    final RelBuilder relBuilder = call.builder();\n    relBuilder.push(newTopJoin);\n    relBuilder.project(relBuilder.fields(topMapping));\n    call.transformTo(relBuilder.build());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/JoinPushThroughJoinRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":213,"status":"M"}],"commitId":"404f968f6079360621896e6ee20ec12488a40bc2","commitMessage":"@@@[CALCITE-4422] Add MethodCanBeStatic check via ErrorProne\n\nprivate and final methods can be made static.  so it is clear they do not access instance fields\n","date":"2020-12-08 15:07:23","modifiedFileCount":"169","status":"M","submitter":"Vladimir Sitnikov"}]
