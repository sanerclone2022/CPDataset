[{"authorTime":"2015-02-23 02:56:33","codes":[{"authorDate":"2015-02-23 02:56:33","commitOrder":1,"curCode":"  private static TableScanNode createFilterable(Interpreter interpreter,\n      TableScan rel, ImmutableList<RexNode> filters, ImmutableIntList projects,\n      FilterableTable filterableTable) {\n    final DataContext root = interpreter.getDataContext();\n    final List<RexNode> mutableFilters = Lists.newArrayList(filters);\n    final Enumerable<Object[]> enumerable =\n        filterableTable.scan(root, mutableFilters);\n    for (RexNode filter : mutableFilters) {\n      if (!filters.contains(filter)) {\n        throw RESOURCE.filterableTableInventedFilter(filter.toString()).ex();\n      }\n    }\n    final Enumerable<Row> rowEnumerable = Enumerables.toRow(enumerable);\n    return createEnumerable(interpreter, rel, rowEnumerable, null,\n        mutableFilters, projects);\n  }\n","date":"2015-02-24 06:33:59","endLine":196,"groupId":"1293","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"createFilterable","params":"(Interpreterinterpreter@TableScanrel@ImmutableList<RexNode>filters@ImmutableIntListprojects@FilterableTablefilterableTable)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/2b/1865fe8375bec86bdc696b5def01365480a098.src","preCode":"  private static TableScanNode createFilterable(Interpreter interpreter,\n      TableScan rel, ImmutableList<RexNode> filters, ImmutableIntList projects,\n      FilterableTable filterableTable) {\n    final DataContext root = interpreter.getDataContext();\n    final List<RexNode> mutableFilters = Lists.newArrayList(filters);\n    final Enumerable<Object[]> enumerable =\n        filterableTable.scan(root, mutableFilters);\n    for (RexNode filter : mutableFilters) {\n      if (!filters.contains(filter)) {\n        throw RESOURCE.filterableTableInventedFilter(filter.toString()).ex();\n      }\n    }\n    final Enumerable<Row> rowEnumerable = Enumerables.toRow(enumerable);\n    return createEnumerable(interpreter, rel, rowEnumerable, null,\n        mutableFilters, projects);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/interpreter/TableScanNode.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":181,"status":"B"},{"authorDate":"2015-02-23 02:56:33","commitOrder":1,"curCode":"  private static TableScanNode createProjectableFilterable(\n      Interpreter interpreter, TableScan rel, ImmutableList<RexNode> filters,\n      ImmutableIntList projects, ProjectableFilterableTable pfTable) {\n    final DataContext root = interpreter.getDataContext();\n    final ImmutableIntList originalProjects = projects;\n    for (;;) {\n      final List<RexNode> mutableFilters = Lists.newArrayList(filters);\n      final int[] projectInts;\n      if (projects == null\n          || projects.equals(TableScan.identity(rel.getTable()))) {\n        projectInts = null;\n      } else {\n        projectInts = projects.toIntArray();\n      }\n      final Enumerable<Object[]> enumerable1 =\n          pfTable.scan(root, mutableFilters, projectInts);\n      for (RexNode filter : mutableFilters) {\n        if (!filters.contains(filter)) {\n          throw RESOURCE.filterableTableInventedFilter(filter.toString())\n              .ex();\n        }\n      }\n      final ImmutableBitSet usedFields =\n          RelOptUtil.InputFinder.bits(mutableFilters, null);\n      if (projects != null) {\n        int changeCount = 0;\n        for (int usedField : usedFields) {\n          if (!projects.contains(usedField)) {\n            \r\n            \r\n            \r\n            projects =\n                ImmutableIntList.copyOf(\n                    Iterables.concat(projects, ImmutableList.of(usedField)));\n            ++changeCount;\n          }\n        }\n        if (changeCount > 0) {\n          continue;\n        }\n      }\n      final Enumerable<Row> rowEnumerable = Enumerables.toRow(enumerable1);\n      final ImmutableIntList rejectedProjects;\n      if (Objects.equal(projects, originalProjects)) {\n        rejectedProjects = null;\n      } else {\n        \r\n        \r\n        rejectedProjects = ImmutableIntList.identity(originalProjects.size());\n      }\n      return createEnumerable(interpreter, rel, rowEnumerable, projects,\n          mutableFilters, rejectedProjects);\n    }\n  }\n","date":"2015-02-24 06:33:59","endLine":251,"groupId":"1293","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"createProjectableFilterable","params":"(Interpreterinterpreter@TableScanrel@ImmutableList<RexNode>filters@ImmutableIntListprojects@ProjectableFilterableTablepfTable)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/2b/1865fe8375bec86bdc696b5def01365480a098.src","preCode":"  private static TableScanNode createProjectableFilterable(\n      Interpreter interpreter, TableScan rel, ImmutableList<RexNode> filters,\n      ImmutableIntList projects, ProjectableFilterableTable pfTable) {\n    final DataContext root = interpreter.getDataContext();\n    final ImmutableIntList originalProjects = projects;\n    for (;;) {\n      final List<RexNode> mutableFilters = Lists.newArrayList(filters);\n      final int[] projectInts;\n      if (projects == null\n          || projects.equals(TableScan.identity(rel.getTable()))) {\n        projectInts = null;\n      } else {\n        projectInts = projects.toIntArray();\n      }\n      final Enumerable<Object[]> enumerable1 =\n          pfTable.scan(root, mutableFilters, projectInts);\n      for (RexNode filter : mutableFilters) {\n        if (!filters.contains(filter)) {\n          throw RESOURCE.filterableTableInventedFilter(filter.toString())\n              .ex();\n        }\n      }\n      final ImmutableBitSet usedFields =\n          RelOptUtil.InputFinder.bits(mutableFilters, null);\n      if (projects != null) {\n        int changeCount = 0;\n        for (int usedField : usedFields) {\n          if (!projects.contains(usedField)) {\n            \r\n            \r\n            \r\n            projects =\n                ImmutableIntList.copyOf(\n                    Iterables.concat(projects, ImmutableList.of(usedField)));\n            ++changeCount;\n          }\n        }\n        if (changeCount > 0) {\n          continue;\n        }\n      }\n      final Enumerable<Row> rowEnumerable = Enumerables.toRow(enumerable1);\n      final ImmutableIntList rejectedProjects;\n      if (Objects.equal(projects, originalProjects)) {\n        rejectedProjects = null;\n      } else {\n        \r\n        \r\n        rejectedProjects = ImmutableIntList.identity(originalProjects.size());\n      }\n      return createEnumerable(interpreter, rel, rowEnumerable, projects,\n          mutableFilters, rejectedProjects);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/interpreter/TableScanNode.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":198,"status":"B"}],"commitId":"96cac479615421628dfca3461d2b36e461c2bb16","commitMessage":"@@@Refactor TableScanNode.create method\n","date":"2015-02-24 06:33:59","modifiedFileCount":"1","status":"B","submitter":"Julian Hyde"},{"authorTime":"2016-02-03 07:01:17","codes":[{"authorDate":"2015-02-23 02:56:33","commitOrder":2,"curCode":"  private static TableScanNode createFilterable(Interpreter interpreter,\n      TableScan rel, ImmutableList<RexNode> filters, ImmutableIntList projects,\n      FilterableTable filterableTable) {\n    final DataContext root = interpreter.getDataContext();\n    final List<RexNode> mutableFilters = Lists.newArrayList(filters);\n    final Enumerable<Object[]> enumerable =\n        filterableTable.scan(root, mutableFilters);\n    for (RexNode filter : mutableFilters) {\n      if (!filters.contains(filter)) {\n        throw RESOURCE.filterableTableInventedFilter(filter.toString()).ex();\n      }\n    }\n    final Enumerable<Row> rowEnumerable = Enumerables.toRow(enumerable);\n    return createEnumerable(interpreter, rel, rowEnumerable, null,\n        mutableFilters, projects);\n  }\n","date":"2015-02-24 06:33:59","endLine":196,"groupId":"1293","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"createFilterable","params":"(Interpreterinterpreter@TableScanrel@ImmutableList<RexNode>filters@ImmutableIntListprojects@FilterableTablefilterableTable)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/2b/1865fe8375bec86bdc696b5def01365480a098.src","preCode":"  private static TableScanNode createFilterable(Interpreter interpreter,\n      TableScan rel, ImmutableList<RexNode> filters, ImmutableIntList projects,\n      FilterableTable filterableTable) {\n    final DataContext root = interpreter.getDataContext();\n    final List<RexNode> mutableFilters = Lists.newArrayList(filters);\n    final Enumerable<Object[]> enumerable =\n        filterableTable.scan(root, mutableFilters);\n    for (RexNode filter : mutableFilters) {\n      if (!filters.contains(filter)) {\n        throw RESOURCE.filterableTableInventedFilter(filter.toString()).ex();\n      }\n    }\n    final Enumerable<Row> rowEnumerable = Enumerables.toRow(enumerable);\n    return createEnumerable(interpreter, rel, rowEnumerable, null,\n        mutableFilters, projects);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/interpreter/TableScanNode.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":181,"status":"N"},{"authorDate":"2016-02-03 07:01:17","commitOrder":2,"curCode":"  private static TableScanNode createProjectableFilterable(\n      Interpreter interpreter, TableScan rel, ImmutableList<RexNode> filters,\n      ImmutableIntList projects, ProjectableFilterableTable pfTable) {\n    final DataContext root = interpreter.getDataContext();\n    final ImmutableIntList originalProjects = projects;\n    for (;;) {\n      final List<RexNode> mutableFilters = Lists.newArrayList(filters);\n      final int[] projectInts;\n      if (projects == null\n          || projects.equals(TableScan.identity(rel.getTable()))) {\n        projectInts = null;\n      } else {\n        projectInts = projects.toIntArray();\n      }\n      final Enumerable<Object[]> enumerable1 =\n          pfTable.scan(root, mutableFilters, projectInts);\n      for (RexNode filter : mutableFilters) {\n        if (!filters.contains(filter)) {\n          throw RESOURCE.filterableTableInventedFilter(filter.toString())\n              .ex();\n        }\n      }\n      final ImmutableBitSet usedFields =\n          RelOptUtil.InputFinder.bits(mutableFilters, null);\n      if (projects != null) {\n        int changeCount = 0;\n        for (int usedField : usedFields) {\n          if (!projects.contains(usedField)) {\n            \r\n            \r\n            \r\n            projects =\n                ImmutableIntList.copyOf(\n                    Iterables.concat(projects, ImmutableList.of(usedField)));\n            ++changeCount;\n          }\n        }\n        if (changeCount > 0) {\n          continue;\n        }\n      }\n      final Enumerable<Row> rowEnumerable = Enumerables.toRow(enumerable1);\n      final ImmutableIntList rejectedProjects;\n      if (Objects.equals(projects, originalProjects)) {\n        rejectedProjects = null;\n      } else {\n        \r\n        \r\n        rejectedProjects = ImmutableIntList.identity(originalProjects.size());\n      }\n      return createEnumerable(interpreter, rel, rowEnumerable, projects,\n          mutableFilters, rejectedProjects);\n    }\n  }\n","date":"2016-02-03 07:36:00","endLine":240,"groupId":"1293","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"createProjectableFilterable","params":"(Interpreterinterpreter@TableScanrel@ImmutableList<RexNode>filters@ImmutableIntListprojects@ProjectableFilterableTablepfTable)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/dd/75d572fa3b4b6b51e2a230529cabff14d61349.src","preCode":"  private static TableScanNode createProjectableFilterable(\n      Interpreter interpreter, TableScan rel, ImmutableList<RexNode> filters,\n      ImmutableIntList projects, ProjectableFilterableTable pfTable) {\n    final DataContext root = interpreter.getDataContext();\n    final ImmutableIntList originalProjects = projects;\n    for (;;) {\n      final List<RexNode> mutableFilters = Lists.newArrayList(filters);\n      final int[] projectInts;\n      if (projects == null\n          || projects.equals(TableScan.identity(rel.getTable()))) {\n        projectInts = null;\n      } else {\n        projectInts = projects.toIntArray();\n      }\n      final Enumerable<Object[]> enumerable1 =\n          pfTable.scan(root, mutableFilters, projectInts);\n      for (RexNode filter : mutableFilters) {\n        if (!filters.contains(filter)) {\n          throw RESOURCE.filterableTableInventedFilter(filter.toString())\n              .ex();\n        }\n      }\n      final ImmutableBitSet usedFields =\n          RelOptUtil.InputFinder.bits(mutableFilters, null);\n      if (projects != null) {\n        int changeCount = 0;\n        for (int usedField : usedFields) {\n          if (!projects.contains(usedField)) {\n            \r\n            \r\n            \r\n            projects =\n                ImmutableIntList.copyOf(\n                    Iterables.concat(projects, ImmutableList.of(usedField)));\n            ++changeCount;\n          }\n        }\n        if (changeCount > 0) {\n          continue;\n        }\n      }\n      final Enumerable<Row> rowEnumerable = Enumerables.toRow(enumerable1);\n      final ImmutableIntList rejectedProjects;\n      if (Objects.equal(projects, originalProjects)) {\n        rejectedProjects = null;\n      } else {\n        \r\n        \r\n        rejectedProjects = ImmutableIntList.identity(originalProjects.size());\n      }\n      return createEnumerable(interpreter, rel, rowEnumerable, projects,\n          mutableFilters, rejectedProjects);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/interpreter/TableScanNode.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":187,"status":"M"}],"commitId":"ecf4d6dcb4b6fdc40828d0c853ae10abc0550a76","commitMessage":"@@@[CALCITE-1071] Improve hash functions\n","date":"2016-02-03 07:36:00","modifiedFileCount":"67","status":"M","submitter":"Julian Hyde"},{"authorTime":"2018-01-09 15:21:54","codes":[{"authorDate":"2018-01-09 15:21:54","commitOrder":3,"curCode":"  private static TableScanNode createFilterable(Compiler compiler,\n      TableScan rel, ImmutableList<RexNode> filters, ImmutableIntList projects,\n      FilterableTable filterableTable) {\n    final DataContext root = compiler.getDataContext();\n    final List<RexNode> mutableFilters = Lists.newArrayList(filters);\n    final Enumerable<Object[]> enumerable =\n        filterableTable.scan(root, mutableFilters);\n    for (RexNode filter : mutableFilters) {\n      if (!filters.contains(filter)) {\n        throw RESOURCE.filterableTableInventedFilter(filter.toString()).ex();\n      }\n    }\n    final Enumerable<Row> rowEnumerable = Enumerables.toRow(enumerable);\n    return createEnumerable(compiler, rel, rowEnumerable, null,\n        mutableFilters, projects);\n  }\n","date":"2018-01-10 15:01:18","endLine":185,"groupId":"1293","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"createFilterable","params":"(Compilercompiler@TableScanrel@ImmutableList<RexNode>filters@ImmutableIntListprojects@FilterableTablefilterableTable)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/9c/8124e9cf23ad23c30046005a34a3056de497c1.src","preCode":"  private static TableScanNode createFilterable(Interpreter interpreter,\n      TableScan rel, ImmutableList<RexNode> filters, ImmutableIntList projects,\n      FilterableTable filterableTable) {\n    final DataContext root = interpreter.getDataContext();\n    final List<RexNode> mutableFilters = Lists.newArrayList(filters);\n    final Enumerable<Object[]> enumerable =\n        filterableTable.scan(root, mutableFilters);\n    for (RexNode filter : mutableFilters) {\n      if (!filters.contains(filter)) {\n        throw RESOURCE.filterableTableInventedFilter(filter.toString()).ex();\n      }\n    }\n    final Enumerable<Row> rowEnumerable = Enumerables.toRow(enumerable);\n    return createEnumerable(interpreter, rel, rowEnumerable, null,\n        mutableFilters, projects);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/interpreter/TableScanNode.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":170,"status":"M"},{"authorDate":"2018-01-09 15:21:54","commitOrder":3,"curCode":"  private static TableScanNode createProjectableFilterable(Compiler compiler,\n      TableScan rel, ImmutableList<RexNode> filters, ImmutableIntList projects,\n      ProjectableFilterableTable pfTable) {\n    final DataContext root = compiler.getDataContext();\n    final ImmutableIntList originalProjects = projects;\n    for (;;) {\n      final List<RexNode> mutableFilters = Lists.newArrayList(filters);\n      final int[] projectInts;\n      if (projects == null\n          || projects.equals(TableScan.identity(rel.getTable()))) {\n        projectInts = null;\n      } else {\n        projectInts = projects.toIntArray();\n      }\n      final Enumerable<Object[]> enumerable1 =\n          pfTable.scan(root, mutableFilters, projectInts);\n      for (RexNode filter : mutableFilters) {\n        if (!filters.contains(filter)) {\n          throw RESOURCE.filterableTableInventedFilter(filter.toString())\n              .ex();\n        }\n      }\n      final ImmutableBitSet usedFields =\n          RelOptUtil.InputFinder.bits(mutableFilters, null);\n      if (projects != null) {\n        int changeCount = 0;\n        for (int usedField : usedFields) {\n          if (!projects.contains(usedField)) {\n            \r\n            \r\n            \r\n            projects =\n                ImmutableIntList.copyOf(\n                    Iterables.concat(projects, ImmutableList.of(usedField)));\n            ++changeCount;\n          }\n        }\n        if (changeCount > 0) {\n          continue;\n        }\n      }\n      final Enumerable<Row> rowEnumerable = Enumerables.toRow(enumerable1);\n      final ImmutableIntList rejectedProjects;\n      if (Objects.equals(projects, originalProjects)) {\n        rejectedProjects = null;\n      } else {\n        \r\n        \r\n        rejectedProjects = ImmutableIntList.identity(originalProjects.size());\n      }\n      return createEnumerable(compiler, rel, rowEnumerable, projects,\n          mutableFilters, rejectedProjects);\n    }\n  }\n","date":"2018-01-10 15:01:18","endLine":240,"groupId":"1293","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"createProjectableFilterable","params":"(Compilercompiler@TableScanrel@ImmutableList<RexNode>filters@ImmutableIntListprojects@ProjectableFilterableTablepfTable)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/9c/8124e9cf23ad23c30046005a34a3056de497c1.src","preCode":"  private static TableScanNode createProjectableFilterable(\n      Interpreter interpreter, TableScan rel, ImmutableList<RexNode> filters,\n      ImmutableIntList projects, ProjectableFilterableTable pfTable) {\n    final DataContext root = interpreter.getDataContext();\n    final ImmutableIntList originalProjects = projects;\n    for (;;) {\n      final List<RexNode> mutableFilters = Lists.newArrayList(filters);\n      final int[] projectInts;\n      if (projects == null\n          || projects.equals(TableScan.identity(rel.getTable()))) {\n        projectInts = null;\n      } else {\n        projectInts = projects.toIntArray();\n      }\n      final Enumerable<Object[]> enumerable1 =\n          pfTable.scan(root, mutableFilters, projectInts);\n      for (RexNode filter : mutableFilters) {\n        if (!filters.contains(filter)) {\n          throw RESOURCE.filterableTableInventedFilter(filter.toString())\n              .ex();\n        }\n      }\n      final ImmutableBitSet usedFields =\n          RelOptUtil.InputFinder.bits(mutableFilters, null);\n      if (projects != null) {\n        int changeCount = 0;\n        for (int usedField : usedFields) {\n          if (!projects.contains(usedField)) {\n            \r\n            \r\n            \r\n            projects =\n                ImmutableIntList.copyOf(\n                    Iterables.concat(projects, ImmutableList.of(usedField)));\n            ++changeCount;\n          }\n        }\n        if (changeCount > 0) {\n          continue;\n        }\n      }\n      final Enumerable<Row> rowEnumerable = Enumerables.toRow(enumerable1);\n      final ImmutableIntList rejectedProjects;\n      if (Objects.equals(projects, originalProjects)) {\n        rejectedProjects = null;\n      } else {\n        \r\n        \r\n        rejectedProjects = ImmutableIntList.identity(originalProjects.size());\n      }\n      return createEnumerable(interpreter, rel, rowEnumerable, projects,\n          mutableFilters, rejectedProjects);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/interpreter/TableScanNode.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":187,"status":"M"}],"commitId":"7b85d445462799926474945c6ab33b1cb8ce33cc","commitMessage":"@@@[CALCITE-2127] In Interpreter.  allow a node to have more than one consumer\n","date":"2018-01-10 15:01:18","modifiedFileCount":"16","status":"M","submitter":"Julian Hyde"},{"authorTime":"2020-05-29 00:04:40","codes":[{"authorDate":"2020-05-29 00:04:40","commitOrder":4,"curCode":"  private static TableScanNode createFilterable(Compiler compiler,\n      TableScan rel, ImmutableList<RexNode> filters, @Nullable ImmutableIntList projects,\n      FilterableTable filterableTable) {\n    final DataContext root = compiler.getDataContext();\n    final List<RexNode> mutableFilters = Lists.newArrayList(filters);\n    final Enumerable<@Nullable Object[]> enumerable =\n        filterableTable.scan(root, mutableFilters);\n    for (RexNode filter : mutableFilters) {\n      if (!filters.contains(filter)) {\n        throw RESOURCE.filterableTableInventedFilter(filter.toString()).ex();\n      }\n    }\n    final Enumerable<Row> rowEnumerable = Enumerables.toRow(enumerable);\n    return createEnumerable(compiler, rel, rowEnumerable, null,\n        mutableFilters, projects);\n  }\n","date":"2020-11-30 06:45:33","endLine":186,"groupId":"102174","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"createFilterable","params":"(Compilercompiler@TableScanrel@ImmutableList<RexNode>filters@@NullableImmutableIntListprojects@FilterableTablefilterableTable)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/75/a5a930d51a0c59e23ef2d928517884952dcaa0.src","preCode":"  private static TableScanNode createFilterable(Compiler compiler,\n      TableScan rel, ImmutableList<RexNode> filters, ImmutableIntList projects,\n      FilterableTable filterableTable) {\n    final DataContext root = compiler.getDataContext();\n    final List<RexNode> mutableFilters = Lists.newArrayList(filters);\n    final Enumerable<Object[]> enumerable =\n        filterableTable.scan(root, mutableFilters);\n    for (RexNode filter : mutableFilters) {\n      if (!filters.contains(filter)) {\n        throw RESOURCE.filterableTableInventedFilter(filter.toString()).ex();\n      }\n    }\n    final Enumerable<Row> rowEnumerable = Enumerables.toRow(enumerable);\n    return createEnumerable(compiler, rel, rowEnumerable, null,\n        mutableFilters, projects);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/interpreter/TableScanNode.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":171,"status":"M"},{"authorDate":"2020-05-29 00:04:40","commitOrder":4,"curCode":"  private static TableScanNode createProjectableFilterable(Compiler compiler,\n      TableScan rel, ImmutableList<RexNode> filters, @Nullable ImmutableIntList projects,\n      ProjectableFilterableTable pfTable) {\n    final DataContext root = compiler.getDataContext();\n    final ImmutableIntList originalProjects = projects;\n    for (;;) {\n      final List<RexNode> mutableFilters = Lists.newArrayList(filters);\n      final int[] projectInts;\n      if (projects == null\n          || projects.equals(TableScan.identity(rel.getTable()))) {\n        projectInts = null;\n      } else {\n        projectInts = projects.toIntArray();\n      }\n      final Enumerable<@Nullable Object[]> enumerable1 =\n          pfTable.scan(root, mutableFilters, projectInts);\n      for (RexNode filter : mutableFilters) {\n        if (!filters.contains(filter)) {\n          throw RESOURCE.filterableTableInventedFilter(filter.toString())\n              .ex();\n        }\n      }\n      final ImmutableBitSet usedFields =\n          RelOptUtil.InputFinder.bits(mutableFilters, null);\n      if (projects != null) {\n        int changeCount = 0;\n        for (int usedField : usedFields) {\n          if (!projects.contains(usedField)) {\n            \r\n            \r\n            \r\n            projects =\n                ImmutableIntList.copyOf(\n                    Iterables.concat(projects, ImmutableList.of(usedField)));\n            ++changeCount;\n          }\n        }\n        if (changeCount > 0) {\n          continue;\n        }\n      }\n      final Enumerable<Row> rowEnumerable = Enumerables.toRow(enumerable1);\n      final ImmutableIntList rejectedProjects;\n      if (originalProjects == null || originalProjects.equals(projects)) {\n        rejectedProjects = null;\n      } else {\n        \r\n        \r\n        rejectedProjects = ImmutableIntList.identity(originalProjects.size());\n      }\n      return createEnumerable(compiler, rel, rowEnumerable, projects,\n          mutableFilters, rejectedProjects);\n    }\n  }\n","date":"2020-11-30 06:45:33","endLine":241,"groupId":"102174","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"createProjectableFilterable","params":"(Compilercompiler@TableScanrel@ImmutableList<RexNode>filters@@NullableImmutableIntListprojects@ProjectableFilterableTablepfTable)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/75/a5a930d51a0c59e23ef2d928517884952dcaa0.src","preCode":"  private static TableScanNode createProjectableFilterable(Compiler compiler,\n      TableScan rel, ImmutableList<RexNode> filters, ImmutableIntList projects,\n      ProjectableFilterableTable pfTable) {\n    final DataContext root = compiler.getDataContext();\n    final ImmutableIntList originalProjects = projects;\n    for (;;) {\n      final List<RexNode> mutableFilters = Lists.newArrayList(filters);\n      final int[] projectInts;\n      if (projects == null\n          || projects.equals(TableScan.identity(rel.getTable()))) {\n        projectInts = null;\n      } else {\n        projectInts = projects.toIntArray();\n      }\n      final Enumerable<Object[]> enumerable1 =\n          pfTable.scan(root, mutableFilters, projectInts);\n      for (RexNode filter : mutableFilters) {\n        if (!filters.contains(filter)) {\n          throw RESOURCE.filterableTableInventedFilter(filter.toString())\n              .ex();\n        }\n      }\n      final ImmutableBitSet usedFields =\n          RelOptUtil.InputFinder.bits(mutableFilters, null);\n      if (projects != null) {\n        int changeCount = 0;\n        for (int usedField : usedFields) {\n          if (!projects.contains(usedField)) {\n            \r\n            \r\n            \r\n            projects =\n                ImmutableIntList.copyOf(\n                    Iterables.concat(projects, ImmutableList.of(usedField)));\n            ++changeCount;\n          }\n        }\n        if (changeCount > 0) {\n          continue;\n        }\n      }\n      final Enumerable<Row> rowEnumerable = Enumerables.toRow(enumerable1);\n      final ImmutableIntList rejectedProjects;\n      if (Objects.equals(projects, originalProjects)) {\n        rejectedProjects = null;\n      } else {\n        \r\n        \r\n        rejectedProjects = ImmutableIntList.identity(originalProjects.size());\n      }\n      return createEnumerable(compiler, rel, rowEnumerable, projects,\n          mutableFilters, rejectedProjects);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/interpreter/TableScanNode.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":188,"status":"M"}],"commitId":"d9a81b88ad561e7e4cedae93e805e0d7a53a7f1a","commitMessage":"@@@[CALCITE-4199] Add nullability annotations\n\nThe commit includes javadoc updates and refactorings made by Julian Hyde in https://github.com/apache/calcite/pull/2278\n","date":"2020-11-30 06:45:33","modifiedFileCount":"1012","status":"M","submitter":"Vladimir Sitnikov"}]
