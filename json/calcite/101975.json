[{"authorTime":"2018-05-22 01:38:03","codes":[{"authorDate":"2018-05-22 01:38:03","commitOrder":1,"curCode":"  private RexNode rewriteExists(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder) {\n    builder.push(e.rel);\n\n    builder.project(builder.alias(builder.literal(true), \"i\"));\n    switch (logic) {\n    case TRUE:\n      \r\n      \r\n      \r\n      builder.aggregate(builder.groupKey(0));\n      builder.as(\"dt\");\n      builder.join(JoinRelType.INNER, builder.literal(true), variablesSet);\n      return builder.literal(true);\n    default:\n      builder.distinct();\n    }\n\n    builder.as(\"dt\");\n\n    builder.join(JoinRelType.LEFT, builder.literal(true), variablesSet);\n\n    return builder.isNotNull(Util.last(builder.fields()));\n  }\n","date":"2018-06-13 08:01:21","endLine":223,"groupId":"7228","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"rewriteExists","params":"(RexSubQuerye@Set<CorrelationId>variablesSet@RelOptUtil.Logiclogic@RelBuilderbuilder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/62/8219f40b842f9a42287a082895cb2c0ee0b13b.src","preCode":"  private RexNode rewriteExists(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder) {\n    builder.push(e.rel);\n\n    builder.project(builder.alias(builder.literal(true), \"i\"));\n    switch (logic) {\n    case TRUE:\n      \r\n      \r\n      \r\n      builder.aggregate(builder.groupKey(0));\n      builder.as(\"dt\");\n      builder.join(JoinRelType.INNER, builder.literal(true), variablesSet);\n      return builder.literal(true);\n    default:\n      builder.distinct();\n    }\n\n    builder.as(\"dt\");\n\n    builder.join(JoinRelType.LEFT, builder.literal(true), variablesSet);\n\n    return builder.isNotNull(Util.last(builder.fields()));\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":200,"status":"B"},{"authorDate":"2018-05-22 01:38:03","commitOrder":1,"curCode":"  private RexNode rewriteIn(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder, int offset) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    builder.push(e.rel);\n    final List<RexNode> fields = new ArrayList<>(builder.fields());\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    boolean allLiterals = RexUtil.allLiterals(e.getOperands());\n    final List<RexNode> expressionOperands = new ArrayList<>(e.getOperands());\n\n    final List<RexNode> keyIsNulls = e.getOperands().stream()\n        .filter(operand -> operand.getType().isNullable())\n        .map(builder::isNull)\n        .collect(Collectors.toList());\n\n    if (allLiterals) {\n      final List<RexNode> conditions =\n          Pair.zip(expressionOperands, fields).stream()\n              .map(pair -> builder.equals(pair.left, pair.right))\n              .collect(Collectors.toList());\n      switch (logic) {\n      case TRUE:\n      case TRUE_FALSE:\n        builder.filter(conditions);\n        builder.project(builder.alias(builder.literal(true), \"cs\"));\n        builder.distinct();\n        break;\n      default:\n        List<RexNode> isNullOpperands = fields.stream()\n            .map(builder::isNull)\n            .collect(Collectors.toList());\n        \r\n        isNullOpperands.addAll(keyIsNulls);\n        builder.filter(\n            builder.or(\n                builder.and(conditions),\n                builder.or(\n                    isNullOpperands\n                )));\n        RexNode project = builder.and(\n            fields.stream()\n                .map(builder::isNotNull)\n                .collect(Collectors.toList()));\n        builder.project(builder.alias(project, \"cs\"));\n\n        if (variablesSet.isEmpty()) {\n          builder.aggregate(builder.groupKey(builder.field(\"cs\")),\n              builder.count(false, \"c\"));\n\n          \r\n          \r\n          \r\n          \r\n          builder.sortLimit(0, 1,\n              ImmutableList.of(\n                  builder.call(SqlStdOperatorTable.DESC,\n                      builder.field(\"cs\"))));\n        } else {\n          builder.distinct();\n        }\n      }\n      \r\n      \r\n      expressionOperands.clear();\n      fields.clear();\n    } else {\n      switch (logic) {\n      case TRUE:\n        builder.aggregate(builder.groupKey(fields));\n        break;\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        \r\n        builder.aggregate(builder.groupKey(),\n            builder.count(false, \"c\"),\n            builder.aggregateCall(SqlStdOperatorTable.COUNT, false, false, null,\n                \"ck\", builder.fields()));\n        builder.as(\"ct\");\n        if (!variablesSet.isEmpty()) {\n          builder.join(JoinRelType.LEFT, builder.literal(true), variablesSet);\n        } else {\n          builder.join(JoinRelType.INNER, builder.literal(true), variablesSet);\n        }\n        offset += 2;\n        builder.push(e.rel);\n        \r\n      default:\n        fields.add(builder.alias(builder.literal(true), \"i\"));\n        builder.project(fields);\n        builder.distinct();\n      }\n    }\n\n    builder.as(\"dt\");\n    int refOffset = offset;\n    final List<RexNode> conditions =\n        Pair.zip(expressionOperands, builder.fields()).stream()\n            .map(pair -> builder.equals(pair.left, RexUtil.shift(pair.right, refOffset)))\n            .collect(Collectors.toList());\n    switch (logic) {\n    case TRUE:\n      builder.join(JoinRelType.INNER, builder.and(conditions), variablesSet);\n      return builder.literal(true);\n    }\n    \r\n    builder.join(JoinRelType.LEFT, builder.and(conditions), variablesSet);\n\n    final ImmutableList.Builder<RexNode> operands = ImmutableList.builder();\n    Boolean b = true;\n    switch (logic) {\n    case TRUE_FALSE_UNKNOWN:\n      b = null;\n      \r\n    case UNKNOWN_AS_TRUE:\n      if (allLiterals) {\n        \r\n        \r\n        if (variablesSet.isEmpty()) {\n          operands.add(\n              builder.isNull(builder.field(\"c\")),\n              builder.literal(false));\n        }\n        operands.add(\n            builder.equals(builder.field(\"cs\"), builder.literal(false)),\n            builder.literal(b));\n      } else {\n        operands.add(\n            builder.equals(builder.field(\"ct\", \"c\"), builder.literal(0)),\n            builder.literal(false));\n      }\n      break;\n    }\n\n    if (!keyIsNulls.isEmpty()) {\n      operands.add(builder.or(keyIsNulls), builder.literal(null));\n    }\n\n    if (allLiterals) {\n      operands.add(builder.isNotNull(builder.field(\"cs\")),\n          builder.literal(true));\n    } else {\n      operands.add(builder.isNotNull(Util.last(builder.fields())),\n          builder.literal(true));\n    }\n\n    if (!allLiterals) {\n      switch (logic) {\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        operands.add(\n            builder.call(SqlStdOperatorTable.LESS_THAN,\n                builder.field(\"ct\", \"ck\"), builder.field(\"ct\", \"c\")),\n            builder.literal(b));\n      }\n    }\n    operands.add(builder.literal(false));\n    return builder.call(SqlStdOperatorTable.CASE, operands.build());\n  }\n","date":"2018-06-13 08:01:21","endLine":470,"groupId":"14540","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"rewriteIn","params":"(RexSubQuerye@Set<CorrelationId>variablesSet@RelOptUtil.Logiclogic@RelBuilderbuilder@intoffset)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/62/8219f40b842f9a42287a082895cb2c0ee0b13b.src","preCode":"  private RexNode rewriteIn(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder, int offset) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    builder.push(e.rel);\n    final List<RexNode> fields = new ArrayList<>(builder.fields());\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    boolean allLiterals = RexUtil.allLiterals(e.getOperands());\n    final List<RexNode> expressionOperands = new ArrayList<>(e.getOperands());\n\n    final List<RexNode> keyIsNulls = e.getOperands().stream()\n        .filter(operand -> operand.getType().isNullable())\n        .map(builder::isNull)\n        .collect(Collectors.toList());\n\n    if (allLiterals) {\n      final List<RexNode> conditions =\n          Pair.zip(expressionOperands, fields).stream()\n              .map(pair -> builder.equals(pair.left, pair.right))\n              .collect(Collectors.toList());\n      switch (logic) {\n      case TRUE:\n      case TRUE_FALSE:\n        builder.filter(conditions);\n        builder.project(builder.alias(builder.literal(true), \"cs\"));\n        builder.distinct();\n        break;\n      default:\n        List<RexNode> isNullOpperands = fields.stream()\n            .map(builder::isNull)\n            .collect(Collectors.toList());\n        \r\n        isNullOpperands.addAll(keyIsNulls);\n        builder.filter(\n            builder.or(\n                builder.and(conditions),\n                builder.or(\n                    isNullOpperands\n                )));\n        RexNode project = builder.and(\n            fields.stream()\n                .map(builder::isNotNull)\n                .collect(Collectors.toList()));\n        builder.project(builder.alias(project, \"cs\"));\n\n        if (variablesSet.isEmpty()) {\n          builder.aggregate(builder.groupKey(builder.field(\"cs\")),\n              builder.count(false, \"c\"));\n\n          \r\n          \r\n          \r\n          \r\n          builder.sortLimit(0, 1,\n              ImmutableList.of(\n                  builder.call(SqlStdOperatorTable.DESC,\n                      builder.field(\"cs\"))));\n        } else {\n          builder.distinct();\n        }\n      }\n      \r\n      \r\n      expressionOperands.clear();\n      fields.clear();\n    } else {\n      switch (logic) {\n      case TRUE:\n        builder.aggregate(builder.groupKey(fields));\n        break;\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        \r\n        builder.aggregate(builder.groupKey(),\n            builder.count(false, \"c\"),\n            builder.aggregateCall(SqlStdOperatorTable.COUNT, false, false, null,\n                \"ck\", builder.fields()));\n        builder.as(\"ct\");\n        if (!variablesSet.isEmpty()) {\n          builder.join(JoinRelType.LEFT, builder.literal(true), variablesSet);\n        } else {\n          builder.join(JoinRelType.INNER, builder.literal(true), variablesSet);\n        }\n        offset += 2;\n        builder.push(e.rel);\n        \r\n      default:\n        fields.add(builder.alias(builder.literal(true), \"i\"));\n        builder.project(fields);\n        builder.distinct();\n      }\n    }\n\n    builder.as(\"dt\");\n    int refOffset = offset;\n    final List<RexNode> conditions =\n        Pair.zip(expressionOperands, builder.fields()).stream()\n            .map(pair -> builder.equals(pair.left, RexUtil.shift(pair.right, refOffset)))\n            .collect(Collectors.toList());\n    switch (logic) {\n    case TRUE:\n      builder.join(JoinRelType.INNER, builder.and(conditions), variablesSet);\n      return builder.literal(true);\n    }\n    \r\n    builder.join(JoinRelType.LEFT, builder.and(conditions), variablesSet);\n\n    final ImmutableList.Builder<RexNode> operands = ImmutableList.builder();\n    Boolean b = true;\n    switch (logic) {\n    case TRUE_FALSE_UNKNOWN:\n      b = null;\n      \r\n    case UNKNOWN_AS_TRUE:\n      if (allLiterals) {\n        \r\n        \r\n        if (variablesSet.isEmpty()) {\n          operands.add(\n              builder.isNull(builder.field(\"c\")),\n              builder.literal(false));\n        }\n        operands.add(\n            builder.equals(builder.field(\"cs\"), builder.literal(false)),\n            builder.literal(b));\n      } else {\n        operands.add(\n            builder.equals(builder.field(\"ct\", \"c\"), builder.literal(0)),\n            builder.literal(false));\n      }\n      break;\n    }\n\n    if (!keyIsNulls.isEmpty()) {\n      operands.add(builder.or(keyIsNulls), builder.literal(null));\n    }\n\n    if (allLiterals) {\n      operands.add(builder.isNotNull(builder.field(\"cs\")),\n          builder.literal(true));\n    } else {\n      operands.add(builder.isNotNull(Util.last(builder.fields())),\n          builder.literal(true));\n    }\n\n    if (!allLiterals) {\n      switch (logic) {\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        operands.add(\n            builder.call(SqlStdOperatorTable.LESS_THAN,\n                builder.field(\"ct\", \"ck\"), builder.field(\"ct\", \"c\")),\n            builder.literal(b));\n      }\n    }\n    operands.add(builder.literal(false));\n    return builder.call(SqlStdOperatorTable.CASE, operands.build());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":237,"status":"B"}],"commitId":"1ae6a52603006741a4cb6bf558c58d9ac08e866a","commitMessage":"@@@[CALCITE-2329] Improve rewrite for \"constant IN (sub-query)\"\n\nImprove and refactor SubQueryRemoveRule.\n\nAdd tests for partially-null right-hand side. (Julian Hyde)\n\nClose apache/calcite#700\n","date":"2018-06-13 08:01:21","modifiedFileCount":"2","status":"B","submitter":"Volodymyr Vysotskyi"},{"authorTime":"2018-11-04 10:59:11","codes":[{"authorDate":"2018-05-22 01:38:03","commitOrder":2,"curCode":"  private RexNode rewriteExists(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder) {\n    builder.push(e.rel);\n\n    builder.project(builder.alias(builder.literal(true), \"i\"));\n    switch (logic) {\n    case TRUE:\n      \r\n      \r\n      \r\n      builder.aggregate(builder.groupKey(0));\n      builder.as(\"dt\");\n      builder.join(JoinRelType.INNER, builder.literal(true), variablesSet);\n      return builder.literal(true);\n    default:\n      builder.distinct();\n    }\n\n    builder.as(\"dt\");\n\n    builder.join(JoinRelType.LEFT, builder.literal(true), variablesSet);\n\n    return builder.isNotNull(Util.last(builder.fields()));\n  }\n","date":"2018-06-13 08:01:21","endLine":223,"groupId":"7228","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"rewriteExists","params":"(RexSubQuerye@Set<CorrelationId>variablesSet@RelOptUtil.Logiclogic@RelBuilderbuilder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/62/8219f40b842f9a42287a082895cb2c0ee0b13b.src","preCode":"  private RexNode rewriteExists(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder) {\n    builder.push(e.rel);\n\n    builder.project(builder.alias(builder.literal(true), \"i\"));\n    switch (logic) {\n    case TRUE:\n      \r\n      \r\n      \r\n      builder.aggregate(builder.groupKey(0));\n      builder.as(\"dt\");\n      builder.join(JoinRelType.INNER, builder.literal(true), variablesSet);\n      return builder.literal(true);\n    default:\n      builder.distinct();\n    }\n\n    builder.as(\"dt\");\n\n    builder.join(JoinRelType.LEFT, builder.literal(true), variablesSet);\n\n    return builder.isNotNull(Util.last(builder.fields()));\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":200,"status":"N"},{"authorDate":"2018-11-04 10:59:11","commitOrder":2,"curCode":"  private RexNode rewriteIn(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder, int offset) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    builder.push(e.rel);\n    final List<RexNode> fields = new ArrayList<>(builder.fields());\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    boolean allLiterals = RexUtil.allLiterals(e.getOperands());\n    final List<RexNode> expressionOperands = new ArrayList<>(e.getOperands());\n\n    final List<RexNode> keyIsNulls = e.getOperands().stream()\n        .filter(operand -> operand.getType().isNullable())\n        .map(builder::isNull)\n        .collect(Collectors.toList());\n\n    if (allLiterals) {\n      final List<RexNode> conditions =\n          Pair.zip(expressionOperands, fields).stream()\n              .map(pair -> builder.equals(pair.left, pair.right))\n              .collect(Collectors.toList());\n      switch (logic) {\n      case TRUE:\n      case TRUE_FALSE:\n        builder.filter(conditions);\n        builder.project(builder.alias(builder.literal(true), \"cs\"));\n        builder.distinct();\n        break;\n      default:\n        List<RexNode> isNullOpperands = fields.stream()\n            .map(builder::isNull)\n            .collect(Collectors.toList());\n        \r\n        isNullOpperands.addAll(keyIsNulls);\n        builder.filter(\n            builder.or(\n                builder.and(conditions),\n                builder.or(\n                    isNullOpperands\n                )));\n        RexNode project = builder.and(\n            fields.stream()\n                .map(builder::isNotNull)\n                .collect(Collectors.toList()));\n        builder.project(builder.alias(project, \"cs\"));\n\n        if (variablesSet.isEmpty()) {\n          builder.aggregate(builder.groupKey(builder.field(\"cs\")),\n              builder.count(false, \"c\"));\n\n          \r\n          \r\n          \r\n          \r\n          builder.sortLimit(0, 1,\n              ImmutableList.of(\n                  builder.call(SqlStdOperatorTable.DESC,\n                      builder.field(\"cs\"))));\n        } else {\n          builder.distinct();\n        }\n      }\n      \r\n      \r\n      expressionOperands.clear();\n      fields.clear();\n    } else {\n      switch (logic) {\n      case TRUE:\n        builder.aggregate(builder.groupKey(fields));\n        break;\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        \r\n        builder.aggregate(builder.groupKey(),\n            builder.count(false, \"c\"),\n            builder.aggregateCall(SqlStdOperatorTable.COUNT, builder.fields())\n                .as(\"ck\"));\n        builder.as(\"ct\");\n        if (!variablesSet.isEmpty()) {\n          builder.join(JoinRelType.LEFT, builder.literal(true), variablesSet);\n        } else {\n          builder.join(JoinRelType.INNER, builder.literal(true), variablesSet);\n        }\n        offset += 2;\n        builder.push(e.rel);\n        \r\n      default:\n        fields.add(builder.alias(builder.literal(true), \"i\"));\n        builder.project(fields);\n        builder.distinct();\n      }\n    }\n\n    builder.as(\"dt\");\n    int refOffset = offset;\n    final List<RexNode> conditions =\n        Pair.zip(expressionOperands, builder.fields()).stream()\n            .map(pair -> builder.equals(pair.left, RexUtil.shift(pair.right, refOffset)))\n            .collect(Collectors.toList());\n    switch (logic) {\n    case TRUE:\n      builder.join(JoinRelType.INNER, builder.and(conditions), variablesSet);\n      return builder.literal(true);\n    }\n    \r\n    builder.join(JoinRelType.LEFT, builder.and(conditions), variablesSet);\n\n    final ImmutableList.Builder<RexNode> operands = ImmutableList.builder();\n    Boolean b = true;\n    switch (logic) {\n    case TRUE_FALSE_UNKNOWN:\n      b = null;\n      \r\n    case UNKNOWN_AS_TRUE:\n      if (allLiterals) {\n        \r\n        \r\n        if (variablesSet.isEmpty()) {\n          operands.add(\n              builder.isNull(builder.field(\"c\")),\n              builder.literal(false));\n        }\n        operands.add(\n            builder.equals(builder.field(\"cs\"), builder.literal(false)),\n            builder.literal(b));\n      } else {\n        operands.add(\n            builder.equals(builder.field(\"ct\", \"c\"), builder.literal(0)),\n            builder.literal(false));\n      }\n      break;\n    }\n\n    if (!keyIsNulls.isEmpty()) {\n      operands.add(builder.or(keyIsNulls), builder.literal(null));\n    }\n\n    if (allLiterals) {\n      operands.add(builder.isNotNull(builder.field(\"cs\")),\n          builder.literal(true));\n    } else {\n      operands.add(builder.isNotNull(Util.last(builder.fields())),\n          builder.literal(true));\n    }\n\n    if (!allLiterals) {\n      switch (logic) {\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        operands.add(\n            builder.call(SqlStdOperatorTable.LESS_THAN,\n                builder.field(\"ct\", \"ck\"), builder.field(\"ct\", \"c\")),\n            builder.literal(b));\n      }\n    }\n    operands.add(builder.literal(false));\n    return builder.call(SqlStdOperatorTable.CASE, operands.build());\n  }\n","date":"2018-11-08 08:33:06","endLine":470,"groupId":"7236","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"rewriteIn","params":"(RexSubQuerye@Set<CorrelationId>variablesSet@RelOptUtil.Logiclogic@RelBuilderbuilder@intoffset)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/39/bccbfb6ee23c5a67449f7e36fe754e94404d6b.src","preCode":"  private RexNode rewriteIn(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder, int offset) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    builder.push(e.rel);\n    final List<RexNode> fields = new ArrayList<>(builder.fields());\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    boolean allLiterals = RexUtil.allLiterals(e.getOperands());\n    final List<RexNode> expressionOperands = new ArrayList<>(e.getOperands());\n\n    final List<RexNode> keyIsNulls = e.getOperands().stream()\n        .filter(operand -> operand.getType().isNullable())\n        .map(builder::isNull)\n        .collect(Collectors.toList());\n\n    if (allLiterals) {\n      final List<RexNode> conditions =\n          Pair.zip(expressionOperands, fields).stream()\n              .map(pair -> builder.equals(pair.left, pair.right))\n              .collect(Collectors.toList());\n      switch (logic) {\n      case TRUE:\n      case TRUE_FALSE:\n        builder.filter(conditions);\n        builder.project(builder.alias(builder.literal(true), \"cs\"));\n        builder.distinct();\n        break;\n      default:\n        List<RexNode> isNullOpperands = fields.stream()\n            .map(builder::isNull)\n            .collect(Collectors.toList());\n        \r\n        isNullOpperands.addAll(keyIsNulls);\n        builder.filter(\n            builder.or(\n                builder.and(conditions),\n                builder.or(\n                    isNullOpperands\n                )));\n        RexNode project = builder.and(\n            fields.stream()\n                .map(builder::isNotNull)\n                .collect(Collectors.toList()));\n        builder.project(builder.alias(project, \"cs\"));\n\n        if (variablesSet.isEmpty()) {\n          builder.aggregate(builder.groupKey(builder.field(\"cs\")),\n              builder.count(false, \"c\"));\n\n          \r\n          \r\n          \r\n          \r\n          builder.sortLimit(0, 1,\n              ImmutableList.of(\n                  builder.call(SqlStdOperatorTable.DESC,\n                      builder.field(\"cs\"))));\n        } else {\n          builder.distinct();\n        }\n      }\n      \r\n      \r\n      expressionOperands.clear();\n      fields.clear();\n    } else {\n      switch (logic) {\n      case TRUE:\n        builder.aggregate(builder.groupKey(fields));\n        break;\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        \r\n        builder.aggregate(builder.groupKey(),\n            builder.count(false, \"c\"),\n            builder.aggregateCall(SqlStdOperatorTable.COUNT, false, false, null,\n                \"ck\", builder.fields()));\n        builder.as(\"ct\");\n        if (!variablesSet.isEmpty()) {\n          builder.join(JoinRelType.LEFT, builder.literal(true), variablesSet);\n        } else {\n          builder.join(JoinRelType.INNER, builder.literal(true), variablesSet);\n        }\n        offset += 2;\n        builder.push(e.rel);\n        \r\n      default:\n        fields.add(builder.alias(builder.literal(true), \"i\"));\n        builder.project(fields);\n        builder.distinct();\n      }\n    }\n\n    builder.as(\"dt\");\n    int refOffset = offset;\n    final List<RexNode> conditions =\n        Pair.zip(expressionOperands, builder.fields()).stream()\n            .map(pair -> builder.equals(pair.left, RexUtil.shift(pair.right, refOffset)))\n            .collect(Collectors.toList());\n    switch (logic) {\n    case TRUE:\n      builder.join(JoinRelType.INNER, builder.and(conditions), variablesSet);\n      return builder.literal(true);\n    }\n    \r\n    builder.join(JoinRelType.LEFT, builder.and(conditions), variablesSet);\n\n    final ImmutableList.Builder<RexNode> operands = ImmutableList.builder();\n    Boolean b = true;\n    switch (logic) {\n    case TRUE_FALSE_UNKNOWN:\n      b = null;\n      \r\n    case UNKNOWN_AS_TRUE:\n      if (allLiterals) {\n        \r\n        \r\n        if (variablesSet.isEmpty()) {\n          operands.add(\n              builder.isNull(builder.field(\"c\")),\n              builder.literal(false));\n        }\n        operands.add(\n            builder.equals(builder.field(\"cs\"), builder.literal(false)),\n            builder.literal(b));\n      } else {\n        operands.add(\n            builder.equals(builder.field(\"ct\", \"c\"), builder.literal(0)),\n            builder.literal(false));\n      }\n      break;\n    }\n\n    if (!keyIsNulls.isEmpty()) {\n      operands.add(builder.or(keyIsNulls), builder.literal(null));\n    }\n\n    if (allLiterals) {\n      operands.add(builder.isNotNull(builder.field(\"cs\")),\n          builder.literal(true));\n    } else {\n      operands.add(builder.isNotNull(Util.last(builder.fields())),\n          builder.literal(true));\n    }\n\n    if (!allLiterals) {\n      switch (logic) {\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        operands.add(\n            builder.call(SqlStdOperatorTable.LESS_THAN,\n                builder.field(\"ct\", \"ck\"), builder.field(\"ct\", \"c\")),\n            builder.literal(b));\n      }\n    }\n    operands.add(builder.literal(false));\n    return builder.call(SqlStdOperatorTable.CASE, operands.build());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":237,"status":"M"}],"commitId":"4cc46130f71d21e4f5b76f6e645380cd83d2c921","commitMessage":"@@@[CALCITE-2654] In RelBuilder.  add a fluent API for building complex aggregate calls\n\nTo interface AggCall in RelBuilder.  add methods distinct(boolean). \nfilter(RexNode).  approximate(boolean).  alias(String). And simplify the\nRelBuilder.aggregateCall method to just two arguments:\naggregateCall(op.  operands). Thus you only specify the arguments that\nare of interest. Similar changes to count.  countStar.  min.  max.  sum. \navg.\n","date":"2018-11-08 08:33:06","modifiedFileCount":"9","status":"M","submitter":"Julian Hyde"},{"authorTime":"2018-09-27 17:55:02","codes":[{"authorDate":"2018-05-22 01:38:03","commitOrder":3,"curCode":"  private RexNode rewriteExists(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder) {\n    builder.push(e.rel);\n\n    builder.project(builder.alias(builder.literal(true), \"i\"));\n    switch (logic) {\n    case TRUE:\n      \r\n      \r\n      \r\n      builder.aggregate(builder.groupKey(0));\n      builder.as(\"dt\");\n      builder.join(JoinRelType.INNER, builder.literal(true), variablesSet);\n      return builder.literal(true);\n    default:\n      builder.distinct();\n    }\n\n    builder.as(\"dt\");\n\n    builder.join(JoinRelType.LEFT, builder.literal(true), variablesSet);\n\n    return builder.isNotNull(Util.last(builder.fields()));\n  }\n","date":"2018-06-13 08:01:21","endLine":223,"groupId":"7228","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"rewriteExists","params":"(RexSubQuerye@Set<CorrelationId>variablesSet@RelOptUtil.Logiclogic@RelBuilderbuilder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/62/8219f40b842f9a42287a082895cb2c0ee0b13b.src","preCode":"  private RexNode rewriteExists(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder) {\n    builder.push(e.rel);\n\n    builder.project(builder.alias(builder.literal(true), \"i\"));\n    switch (logic) {\n    case TRUE:\n      \r\n      \r\n      \r\n      builder.aggregate(builder.groupKey(0));\n      builder.as(\"dt\");\n      builder.join(JoinRelType.INNER, builder.literal(true), variablesSet);\n      return builder.literal(true);\n    default:\n      builder.distinct();\n    }\n\n    builder.as(\"dt\");\n\n    builder.join(JoinRelType.LEFT, builder.literal(true), variablesSet);\n\n    return builder.isNotNull(Util.last(builder.fields()));\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":200,"status":"N"},{"authorDate":"2018-09-27 17:55:02","commitOrder":3,"curCode":"  private RexNode rewriteIn(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder, int offset) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    builder.push(e.rel);\n    final List<RexNode> fields = new ArrayList<>(builder.fields());\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    boolean allLiterals = RexUtil.allLiterals(e.getOperands());\n    final List<RexNode> expressionOperands = new ArrayList<>(e.getOperands());\n\n    final List<RexNode> keyIsNulls = e.getOperands().stream()\n        .filter(operand -> operand.getType().isNullable())\n        .map(builder::isNull)\n        .collect(Collectors.toList());\n\n    if (allLiterals) {\n      final List<RexNode> conditions =\n          Pair.zip(expressionOperands, fields).stream()\n              .map(pair -> builder.equals(pair.left, pair.right))\n              .collect(Collectors.toList());\n      switch (logic) {\n      case TRUE:\n      case TRUE_FALSE:\n        builder.filter(conditions);\n        builder.project(builder.alias(builder.literal(true), \"cs\"));\n        builder.distinct();\n        break;\n      default:\n        List<RexNode> isNullOpperands = fields.stream()\n            .map(builder::isNull)\n            .collect(Collectors.toList());\n        \r\n        isNullOpperands.addAll(keyIsNulls);\n        builder.filter(\n            builder.or(\n                builder.and(conditions),\n                builder.or(\n                    isNullOpperands\n                )));\n        RexNode project = builder.and(\n            fields.stream()\n                .map(builder::isNotNull)\n                .collect(Collectors.toList()));\n        builder.project(builder.alias(project, \"cs\"));\n\n        if (variablesSet.isEmpty()) {\n          builder.aggregate(builder.groupKey(builder.field(\"cs\")),\n              builder.count(false, \"c\"));\n\n          \r\n          \r\n          \r\n          \r\n          builder.sortLimit(0, 1,\n              ImmutableList.of(\n                  builder.call(SqlStdOperatorTable.DESC,\n                      builder.field(\"cs\"))));\n        } else {\n          builder.distinct();\n        }\n      }\n      \r\n      \r\n      expressionOperands.clear();\n      fields.clear();\n    } else {\n      switch (logic) {\n      case TRUE:\n        builder.aggregate(builder.groupKey(fields));\n        break;\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        \r\n        builder.aggregate(builder.groupKey(),\n            builder.count(false, \"c\"),\n            builder.count(builder.fields()).as(\"ck\"));\n        builder.as(\"ct\");\n        if (!variablesSet.isEmpty()) {\n          builder.join(JoinRelType.LEFT, builder.literal(true), variablesSet);\n        } else {\n          builder.join(JoinRelType.INNER, builder.literal(true), variablesSet);\n        }\n        offset += 2;\n        builder.push(e.rel);\n        \r\n      default:\n        fields.add(builder.alias(builder.literal(true), \"i\"));\n        builder.project(fields);\n        builder.distinct();\n      }\n    }\n\n    builder.as(\"dt\");\n    int refOffset = offset;\n    final List<RexNode> conditions =\n        Pair.zip(expressionOperands, builder.fields()).stream()\n            .map(pair -> builder.equals(pair.left, RexUtil.shift(pair.right, refOffset)))\n            .collect(Collectors.toList());\n    switch (logic) {\n    case TRUE:\n      builder.join(JoinRelType.INNER, builder.and(conditions), variablesSet);\n      return builder.literal(true);\n    }\n    \r\n    builder.join(JoinRelType.LEFT, builder.and(conditions), variablesSet);\n\n    final ImmutableList.Builder<RexNode> operands = ImmutableList.builder();\n    Boolean b = true;\n    switch (logic) {\n    case TRUE_FALSE_UNKNOWN:\n      b = null;\n      \r\n    case UNKNOWN_AS_TRUE:\n      if (allLiterals) {\n        \r\n        \r\n        if (variablesSet.isEmpty()) {\n          operands.add(\n              builder.isNull(builder.field(\"c\")),\n              builder.literal(false));\n        }\n        operands.add(\n            builder.equals(builder.field(\"cs\"), builder.literal(false)),\n            builder.literal(b));\n      } else {\n        operands.add(\n            builder.equals(builder.field(\"ct\", \"c\"), builder.literal(0)),\n            builder.literal(false));\n      }\n      break;\n    }\n\n    if (!keyIsNulls.isEmpty()) {\n      operands.add(builder.or(keyIsNulls), builder.literal(null));\n    }\n\n    if (allLiterals) {\n      operands.add(builder.isNotNull(builder.field(\"cs\")),\n          builder.literal(true));\n    } else {\n      operands.add(builder.isNotNull(Util.last(builder.fields())),\n          builder.literal(true));\n    }\n\n    if (!allLiterals) {\n      switch (logic) {\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        operands.add(\n            builder.call(SqlStdOperatorTable.LESS_THAN,\n                builder.field(\"ct\", \"ck\"), builder.field(\"ct\", \"c\")),\n            builder.literal(b));\n      }\n    }\n    operands.add(builder.literal(false));\n    return builder.call(SqlStdOperatorTable.CASE, operands.build());\n  }\n","date":"2018-11-09 02:00:28","endLine":469,"groupId":"7236","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"rewriteIn","params":"(RexSubQuerye@Set<CorrelationId>variablesSet@RelOptUtil.Logiclogic@RelBuilderbuilder@intoffset)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/33/83f979792ab0fde4973835bc9f2178546e0fcf.src","preCode":"  private RexNode rewriteIn(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder, int offset) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    builder.push(e.rel);\n    final List<RexNode> fields = new ArrayList<>(builder.fields());\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    boolean allLiterals = RexUtil.allLiterals(e.getOperands());\n    final List<RexNode> expressionOperands = new ArrayList<>(e.getOperands());\n\n    final List<RexNode> keyIsNulls = e.getOperands().stream()\n        .filter(operand -> operand.getType().isNullable())\n        .map(builder::isNull)\n        .collect(Collectors.toList());\n\n    if (allLiterals) {\n      final List<RexNode> conditions =\n          Pair.zip(expressionOperands, fields).stream()\n              .map(pair -> builder.equals(pair.left, pair.right))\n              .collect(Collectors.toList());\n      switch (logic) {\n      case TRUE:\n      case TRUE_FALSE:\n        builder.filter(conditions);\n        builder.project(builder.alias(builder.literal(true), \"cs\"));\n        builder.distinct();\n        break;\n      default:\n        List<RexNode> isNullOpperands = fields.stream()\n            .map(builder::isNull)\n            .collect(Collectors.toList());\n        \r\n        isNullOpperands.addAll(keyIsNulls);\n        builder.filter(\n            builder.or(\n                builder.and(conditions),\n                builder.or(\n                    isNullOpperands\n                )));\n        RexNode project = builder.and(\n            fields.stream()\n                .map(builder::isNotNull)\n                .collect(Collectors.toList()));\n        builder.project(builder.alias(project, \"cs\"));\n\n        if (variablesSet.isEmpty()) {\n          builder.aggregate(builder.groupKey(builder.field(\"cs\")),\n              builder.count(false, \"c\"));\n\n          \r\n          \r\n          \r\n          \r\n          builder.sortLimit(0, 1,\n              ImmutableList.of(\n                  builder.call(SqlStdOperatorTable.DESC,\n                      builder.field(\"cs\"))));\n        } else {\n          builder.distinct();\n        }\n      }\n      \r\n      \r\n      expressionOperands.clear();\n      fields.clear();\n    } else {\n      switch (logic) {\n      case TRUE:\n        builder.aggregate(builder.groupKey(fields));\n        break;\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        \r\n        builder.aggregate(builder.groupKey(),\n            builder.count(false, \"c\"),\n            builder.aggregateCall(SqlStdOperatorTable.COUNT, builder.fields())\n                .as(\"ck\"));\n        builder.as(\"ct\");\n        if (!variablesSet.isEmpty()) {\n          builder.join(JoinRelType.LEFT, builder.literal(true), variablesSet);\n        } else {\n          builder.join(JoinRelType.INNER, builder.literal(true), variablesSet);\n        }\n        offset += 2;\n        builder.push(e.rel);\n        \r\n      default:\n        fields.add(builder.alias(builder.literal(true), \"i\"));\n        builder.project(fields);\n        builder.distinct();\n      }\n    }\n\n    builder.as(\"dt\");\n    int refOffset = offset;\n    final List<RexNode> conditions =\n        Pair.zip(expressionOperands, builder.fields()).stream()\n            .map(pair -> builder.equals(pair.left, RexUtil.shift(pair.right, refOffset)))\n            .collect(Collectors.toList());\n    switch (logic) {\n    case TRUE:\n      builder.join(JoinRelType.INNER, builder.and(conditions), variablesSet);\n      return builder.literal(true);\n    }\n    \r\n    builder.join(JoinRelType.LEFT, builder.and(conditions), variablesSet);\n\n    final ImmutableList.Builder<RexNode> operands = ImmutableList.builder();\n    Boolean b = true;\n    switch (logic) {\n    case TRUE_FALSE_UNKNOWN:\n      b = null;\n      \r\n    case UNKNOWN_AS_TRUE:\n      if (allLiterals) {\n        \r\n        \r\n        if (variablesSet.isEmpty()) {\n          operands.add(\n              builder.isNull(builder.field(\"c\")),\n              builder.literal(false));\n        }\n        operands.add(\n            builder.equals(builder.field(\"cs\"), builder.literal(false)),\n            builder.literal(b));\n      } else {\n        operands.add(\n            builder.equals(builder.field(\"ct\", \"c\"), builder.literal(0)),\n            builder.literal(false));\n      }\n      break;\n    }\n\n    if (!keyIsNulls.isEmpty()) {\n      operands.add(builder.or(keyIsNulls), builder.literal(null));\n    }\n\n    if (allLiterals) {\n      operands.add(builder.isNotNull(builder.field(\"cs\")),\n          builder.literal(true));\n    } else {\n      operands.add(builder.isNotNull(Util.last(builder.fields())),\n          builder.literal(true));\n    }\n\n    if (!allLiterals) {\n      switch (logic) {\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        operands.add(\n            builder.call(SqlStdOperatorTable.LESS_THAN,\n                builder.field(\"ct\", \"ck\"), builder.field(\"ct\", \"c\")),\n            builder.literal(b));\n      }\n    }\n    operands.add(builder.literal(false));\n    return builder.call(SqlStdOperatorTable.CASE, operands.build());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":237,"status":"M"}],"commitId":"7bc9f14032b7cf0761c0b2eefdb6bb588047ec8e","commitMessage":"@@@[CALCITE-2224] Support WITHIN GROUP clause for aggregate functions (Hongze Zhang)\n\nClose apache/calcite#871\n","date":"2018-11-09 02:00:28","modifiedFileCount":"60","status":"M","submitter":"hongzezhang"},{"authorTime":"2019-08-03 08:59:01","codes":[{"authorDate":"2018-05-22 01:38:03","commitOrder":4,"curCode":"  private RexNode rewriteExists(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder) {\n    builder.push(e.rel);\n\n    builder.project(builder.alias(builder.literal(true), \"i\"));\n    switch (logic) {\n    case TRUE:\n      \r\n      \r\n      \r\n      builder.aggregate(builder.groupKey(0));\n      builder.as(\"dt\");\n      builder.join(JoinRelType.INNER, builder.literal(true), variablesSet);\n      return builder.literal(true);\n    default:\n      builder.distinct();\n    }\n\n    builder.as(\"dt\");\n\n    builder.join(JoinRelType.LEFT, builder.literal(true), variablesSet);\n\n    return builder.isNotNull(Util.last(builder.fields()));\n  }\n","date":"2018-06-13 08:01:21","endLine":223,"groupId":"7228","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"rewriteExists","params":"(RexSubQuerye@Set<CorrelationId>variablesSet@RelOptUtil.Logiclogic@RelBuilderbuilder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/62/8219f40b842f9a42287a082895cb2c0ee0b13b.src","preCode":"  private RexNode rewriteExists(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder) {\n    builder.push(e.rel);\n\n    builder.project(builder.alias(builder.literal(true), \"i\"));\n    switch (logic) {\n    case TRUE:\n      \r\n      \r\n      \r\n      builder.aggregate(builder.groupKey(0));\n      builder.as(\"dt\");\n      builder.join(JoinRelType.INNER, builder.literal(true), variablesSet);\n      return builder.literal(true);\n    default:\n      builder.distinct();\n    }\n\n    builder.as(\"dt\");\n\n    builder.join(JoinRelType.LEFT, builder.literal(true), variablesSet);\n\n    return builder.isNotNull(Util.last(builder.fields()));\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":200,"status":"N"},{"authorDate":"2019-08-03 08:59:01","commitOrder":4,"curCode":"  private RexNode rewriteIn(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder, int offset) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    builder.push(e.rel);\n    final List<RexNode> fields = new ArrayList<>(builder.fields());\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    boolean allLiterals = RexUtil.allLiterals(e.getOperands());\n    final List<RexNode> expressionOperands = new ArrayList<>(e.getOperands());\n\n    final List<RexNode> keyIsNulls = e.getOperands().stream()\n        .filter(operand -> operand.getType().isNullable())\n        .map(builder::isNull)\n        .collect(Collectors.toList());\n\n    final RexLiteral trueLiteral = (RexLiteral) builder.literal(true);\n    final RexLiteral falseLiteral = (RexLiteral) builder.literal(false);\n    final RexLiteral unknownLiteral =\n        builder.getRexBuilder().makeNullLiteral(trueLiteral.getType());\n    if (allLiterals) {\n      final List<RexNode> conditions =\n          Pair.zip(expressionOperands, fields).stream()\n              .map(pair -> builder.equals(pair.left, pair.right))\n              .collect(Collectors.toList());\n      switch (logic) {\n      case TRUE:\n      case TRUE_FALSE:\n        builder.filter(conditions);\n        builder.project(builder.alias(trueLiteral, \"cs\"));\n        builder.distinct();\n        break;\n      default:\n        List<RexNode> isNullOpperands = fields.stream()\n            .map(builder::isNull)\n            .collect(Collectors.toList());\n        \r\n        isNullOpperands.addAll(keyIsNulls);\n        builder.filter(\n            builder.or(\n                builder.and(conditions),\n                builder.or(isNullOpperands)));\n        RexNode project = builder.and(\n            fields.stream()\n                .map(builder::isNotNull)\n                .collect(Collectors.toList()));\n        builder.project(builder.alias(project, \"cs\"));\n\n        if (variablesSet.isEmpty()) {\n          builder.aggregate(builder.groupKey(builder.field(\"cs\")),\n              builder.count(false, \"c\"));\n\n          \r\n          \r\n          \r\n          \r\n          builder.sortLimit(0, 1,\n              ImmutableList.of(\n                  builder.call(SqlStdOperatorTable.DESC,\n                      builder.field(\"cs\"))));\n        } else {\n          builder.distinct();\n        }\n      }\n      \r\n      \r\n      expressionOperands.clear();\n      fields.clear();\n    } else {\n      switch (logic) {\n      case TRUE:\n        builder.aggregate(builder.groupKey(fields));\n        break;\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        \r\n        builder.aggregate(builder.groupKey(),\n            builder.count(false, \"c\"),\n            builder.count(builder.fields()).as(\"ck\"));\n        builder.as(\"ct\");\n        if (!variablesSet.isEmpty()) {\n          builder.join(JoinRelType.LEFT, trueLiteral, variablesSet);\n        } else {\n          builder.join(JoinRelType.INNER, trueLiteral, variablesSet);\n        }\n        offset += 2;\n        builder.push(e.rel);\n        \r\n      default:\n        fields.add(builder.alias(trueLiteral, \"i\"));\n        builder.project(fields);\n        builder.distinct();\n      }\n    }\n\n    builder.as(\"dt\");\n    int refOffset = offset;\n    final List<RexNode> conditions =\n        Pair.zip(expressionOperands, builder.fields()).stream()\n            .map(pair -> builder.equals(pair.left, RexUtil.shift(pair.right, refOffset)))\n            .collect(Collectors.toList());\n    switch (logic) {\n    case TRUE:\n      builder.join(JoinRelType.INNER, builder.and(conditions), variablesSet);\n      return trueLiteral;\n    }\n    \r\n    builder.join(JoinRelType.LEFT, builder.and(conditions), variablesSet);\n\n    final ImmutableList.Builder<RexNode> operands = ImmutableList.builder();\n    RexLiteral b = trueLiteral;\n    switch (logic) {\n    case TRUE_FALSE_UNKNOWN:\n      b = unknownLiteral;\n      \r\n    case UNKNOWN_AS_TRUE:\n      if (allLiterals) {\n        \r\n        \r\n        if (variablesSet.isEmpty()) {\n          operands.add(\n              builder.isNull(builder.field(\"c\")),\n              falseLiteral);\n        }\n        operands.add(\n            builder.equals(builder.field(\"cs\"), falseLiteral),\n            b);\n      } else {\n        operands.add(\n            builder.equals(builder.field(\"ct\", \"c\"), builder.literal(0)),\n            falseLiteral);\n      }\n      break;\n    }\n\n    if (!keyIsNulls.isEmpty()) {\n      operands.add(builder.or(keyIsNulls), unknownLiteral);\n    }\n\n    if (allLiterals) {\n      operands.add(builder.isNotNull(builder.field(\"cs\")),\n          trueLiteral);\n    } else {\n      operands.add(builder.isNotNull(Util.last(builder.fields())),\n          trueLiteral);\n    }\n\n    if (!allLiterals) {\n      switch (logic) {\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        operands.add(\n            builder.call(SqlStdOperatorTable.LESS_THAN,\n                builder.field(\"ct\", \"ck\"), builder.field(\"ct\", \"c\")),\n            b);\n      }\n    }\n    operands.add(falseLiteral);\n    return builder.call(SqlStdOperatorTable.CASE, operands.build());\n  }\n","date":"2019-08-04 04:36:34","endLine":564,"groupId":"2948","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"rewriteIn","params":"(RexSubQuerye@Set<CorrelationId>variablesSet@RelOptUtil.Logiclogic@RelBuilderbuilder@intoffset)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/39/b257a394a634513ff049da72dbeb819640d090.src","preCode":"  private RexNode rewriteIn(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder, int offset) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    builder.push(e.rel);\n    final List<RexNode> fields = new ArrayList<>(builder.fields());\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    boolean allLiterals = RexUtil.allLiterals(e.getOperands());\n    final List<RexNode> expressionOperands = new ArrayList<>(e.getOperands());\n\n    final List<RexNode> keyIsNulls = e.getOperands().stream()\n        .filter(operand -> operand.getType().isNullable())\n        .map(builder::isNull)\n        .collect(Collectors.toList());\n\n    if (allLiterals) {\n      final List<RexNode> conditions =\n          Pair.zip(expressionOperands, fields).stream()\n              .map(pair -> builder.equals(pair.left, pair.right))\n              .collect(Collectors.toList());\n      switch (logic) {\n      case TRUE:\n      case TRUE_FALSE:\n        builder.filter(conditions);\n        builder.project(builder.alias(builder.literal(true), \"cs\"));\n        builder.distinct();\n        break;\n      default:\n        List<RexNode> isNullOpperands = fields.stream()\n            .map(builder::isNull)\n            .collect(Collectors.toList());\n        \r\n        isNullOpperands.addAll(keyIsNulls);\n        builder.filter(\n            builder.or(\n                builder.and(conditions),\n                builder.or(isNullOpperands)));\n        RexNode project = builder.and(\n            fields.stream()\n                .map(builder::isNotNull)\n                .collect(Collectors.toList()));\n        builder.project(builder.alias(project, \"cs\"));\n\n        if (variablesSet.isEmpty()) {\n          builder.aggregate(builder.groupKey(builder.field(\"cs\")),\n              builder.count(false, \"c\"));\n\n          \r\n          \r\n          \r\n          \r\n          builder.sortLimit(0, 1,\n              ImmutableList.of(\n                  builder.call(SqlStdOperatorTable.DESC,\n                      builder.field(\"cs\"))));\n        } else {\n          builder.distinct();\n        }\n      }\n      \r\n      \r\n      expressionOperands.clear();\n      fields.clear();\n    } else {\n      switch (logic) {\n      case TRUE:\n        builder.aggregate(builder.groupKey(fields));\n        break;\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        \r\n        builder.aggregate(builder.groupKey(),\n            builder.count(false, \"c\"),\n            builder.count(builder.fields()).as(\"ck\"));\n        builder.as(\"ct\");\n        if (!variablesSet.isEmpty()) {\n          builder.join(JoinRelType.LEFT, builder.literal(true), variablesSet);\n        } else {\n          builder.join(JoinRelType.INNER, builder.literal(true), variablesSet);\n        }\n        offset += 2;\n        builder.push(e.rel);\n        \r\n      default:\n        fields.add(builder.alias(builder.literal(true), \"i\"));\n        builder.project(fields);\n        builder.distinct();\n      }\n    }\n\n    builder.as(\"dt\");\n    int refOffset = offset;\n    final List<RexNode> conditions =\n        Pair.zip(expressionOperands, builder.fields()).stream()\n            .map(pair -> builder.equals(pair.left, RexUtil.shift(pair.right, refOffset)))\n            .collect(Collectors.toList());\n    switch (logic) {\n    case TRUE:\n      builder.join(JoinRelType.INNER, builder.and(conditions), variablesSet);\n      return builder.literal(true);\n    }\n    \r\n    builder.join(JoinRelType.LEFT, builder.and(conditions), variablesSet);\n\n    final ImmutableList.Builder<RexNode> operands = ImmutableList.builder();\n    Boolean b = true;\n    switch (logic) {\n    case TRUE_FALSE_UNKNOWN:\n      b = null;\n      \r\n    case UNKNOWN_AS_TRUE:\n      if (allLiterals) {\n        \r\n        \r\n        if (variablesSet.isEmpty()) {\n          operands.add(\n              builder.isNull(builder.field(\"c\")),\n              builder.literal(false));\n        }\n        operands.add(\n            builder.equals(builder.field(\"cs\"), builder.literal(false)),\n            builder.literal(b));\n      } else {\n        operands.add(\n            builder.equals(builder.field(\"ct\", \"c\"), builder.literal(0)),\n            builder.literal(false));\n      }\n      break;\n    }\n\n    if (!keyIsNulls.isEmpty()) {\n      operands.add(builder.or(keyIsNulls), builder.literal(null));\n    }\n\n    if (allLiterals) {\n      operands.add(builder.isNotNull(builder.field(\"cs\")),\n          builder.literal(true));\n    } else {\n      operands.add(builder.isNotNull(Util.last(builder.fields())),\n          builder.literal(true));\n    }\n\n    if (!allLiterals) {\n      switch (logic) {\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        operands.add(\n            builder.call(SqlStdOperatorTable.LESS_THAN,\n                builder.field(\"ct\", \"ck\"), builder.field(\"ct\", \"c\")),\n            builder.literal(b));\n      }\n    }\n    operands.add(builder.literal(false));\n    return builder.call(SqlStdOperatorTable.CASE, operands.build());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":330,"status":"M"}],"commitId":"b432756e2be9ad0557a56254550eb4438dd0efcf","commitMessage":"@@@Deprecate RexBuilder.constantNull().  because it produces untyped NULL literals that make planning difficult\n\nWe cannot deprecate RelBuilder.literal(null).  but remove all uses of\nin internal code.  for similar reasons.\n","date":"2019-08-04 04:36:34","modifiedFileCount":"16","status":"M","submitter":"Julian Hyde"},{"authorTime":"2020-08-13 15:59:15","codes":[{"authorDate":"2018-05-22 01:38:03","commitOrder":5,"curCode":"  private RexNode rewriteExists(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder) {\n    builder.push(e.rel);\n\n    builder.project(builder.alias(builder.literal(true), \"i\"));\n    switch (logic) {\n    case TRUE:\n      \r\n      \r\n      \r\n      builder.aggregate(builder.groupKey(0));\n      builder.as(\"dt\");\n      builder.join(JoinRelType.INNER, builder.literal(true), variablesSet);\n      return builder.literal(true);\n    default:\n      builder.distinct();\n    }\n\n    builder.as(\"dt\");\n\n    builder.join(JoinRelType.LEFT, builder.literal(true), variablesSet);\n\n    return builder.isNotNull(Util.last(builder.fields()));\n  }\n","date":"2018-06-13 08:01:21","endLine":223,"groupId":"7228","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"rewriteExists","params":"(RexSubQuerye@Set<CorrelationId>variablesSet@RelOptUtil.Logiclogic@RelBuilderbuilder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/62/8219f40b842f9a42287a082895cb2c0ee0b13b.src","preCode":"  private RexNode rewriteExists(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder) {\n    builder.push(e.rel);\n\n    builder.project(builder.alias(builder.literal(true), \"i\"));\n    switch (logic) {\n    case TRUE:\n      \r\n      \r\n      \r\n      builder.aggregate(builder.groupKey(0));\n      builder.as(\"dt\");\n      builder.join(JoinRelType.INNER, builder.literal(true), variablesSet);\n      return builder.literal(true);\n    default:\n      builder.distinct();\n    }\n\n    builder.as(\"dt\");\n\n    builder.join(JoinRelType.LEFT, builder.literal(true), variablesSet);\n\n    return builder.isNotNull(Util.last(builder.fields()));\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":200,"status":"N"},{"authorDate":"2020-08-13 15:59:15","commitOrder":5,"curCode":"  private RexNode rewriteIn(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder, int offset) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    builder.push(e.rel);\n    final List<RexNode> fields = new ArrayList<>(builder.fields());\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    boolean allLiterals = RexUtil.allLiterals(e.getOperands());\n    final List<RexNode> expressionOperands = new ArrayList<>(e.getOperands());\n\n    final List<RexNode> keyIsNulls = e.getOperands().stream()\n        .filter(operand -> operand.getType().isNullable())\n        .map(builder::isNull)\n        .collect(Collectors.toList());\n\n    final RexLiteral trueLiteral = (RexLiteral) builder.literal(true);\n    final RexLiteral falseLiteral = (RexLiteral) builder.literal(false);\n    final RexLiteral unknownLiteral =\n        builder.getRexBuilder().makeNullLiteral(trueLiteral.getType());\n    if (allLiterals) {\n      final List<RexNode> conditions =\n          Pair.zip(expressionOperands, fields).stream()\n              .map(pair -> builder.equals(pair.left, pair.right))\n              .collect(Collectors.toList());\n      switch (logic) {\n      case TRUE:\n      case TRUE_FALSE:\n        builder.filter(conditions);\n        builder.project(builder.alias(trueLiteral, \"cs\"));\n        builder.distinct();\n        break;\n      default:\n        List<RexNode> isNullOperands = fields.stream()\n            .map(builder::isNull)\n            .collect(Collectors.toList());\n        \r\n        isNullOperands.addAll(keyIsNulls);\n        builder.filter(\n            builder.or(\n                builder.and(conditions),\n                builder.or(isNullOperands)));\n        RexNode project = builder.and(\n            fields.stream()\n                .map(builder::isNotNull)\n                .collect(Collectors.toList()));\n        builder.project(builder.alias(project, \"cs\"));\n\n        if (variablesSet.isEmpty()) {\n          builder.aggregate(builder.groupKey(builder.field(\"cs\")),\n              builder.count(false, \"c\"));\n\n          \r\n          \r\n          \r\n          \r\n          builder.sortLimit(0, 1,\n              ImmutableList.of(\n                  builder.call(SqlStdOperatorTable.DESC,\n                      builder.field(\"cs\"))));\n        } else {\n          builder.distinct();\n        }\n      }\n      \r\n      \r\n      expressionOperands.clear();\n      fields.clear();\n    } else {\n      switch (logic) {\n      case TRUE:\n        builder.aggregate(builder.groupKey(fields));\n        break;\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        \r\n        builder.aggregate(builder.groupKey(),\n            builder.count(false, \"c\"),\n            builder.count(builder.fields()).as(\"ck\"));\n        builder.as(\"ct\");\n        if (!variablesSet.isEmpty()) {\n          builder.join(JoinRelType.LEFT, trueLiteral, variablesSet);\n        } else {\n          builder.join(JoinRelType.INNER, trueLiteral, variablesSet);\n        }\n        offset += 2;\n        builder.push(e.rel);\n        \r\n      default:\n        fields.add(builder.alias(trueLiteral, \"i\"));\n        builder.project(fields);\n        builder.distinct();\n      }\n    }\n\n    builder.as(\"dt\");\n    int refOffset = offset;\n    final List<RexNode> conditions =\n        Pair.zip(expressionOperands, builder.fields()).stream()\n            .map(pair -> builder.equals(pair.left, RexUtil.shift(pair.right, refOffset)))\n            .collect(Collectors.toList());\n    switch (logic) {\n    case TRUE:\n      builder.join(JoinRelType.INNER, builder.and(conditions), variablesSet);\n      return trueLiteral;\n    }\n    \r\n    builder.join(JoinRelType.LEFT, builder.and(conditions), variablesSet);\n\n    final ImmutableList.Builder<RexNode> operands = ImmutableList.builder();\n    RexLiteral b = trueLiteral;\n    switch (logic) {\n    case TRUE_FALSE_UNKNOWN:\n      b = unknownLiteral;\n      \r\n    case UNKNOWN_AS_TRUE:\n      if (allLiterals) {\n        \r\n        \r\n        if (variablesSet.isEmpty()) {\n          operands.add(\n              builder.isNull(builder.field(\"c\")),\n              falseLiteral);\n        }\n        operands.add(\n            builder.equals(builder.field(\"cs\"), falseLiteral),\n            b);\n      } else {\n        operands.add(\n            builder.equals(builder.field(\"ct\", \"c\"), builder.literal(0)),\n            falseLiteral);\n      }\n      break;\n    }\n\n    if (!keyIsNulls.isEmpty()) {\n      operands.add(builder.or(keyIsNulls), unknownLiteral);\n    }\n\n    if (allLiterals) {\n      operands.add(builder.isNotNull(builder.field(\"cs\")),\n          trueLiteral);\n    } else {\n      operands.add(builder.isNotNull(Util.last(builder.fields())),\n          trueLiteral);\n    }\n\n    if (!allLiterals) {\n      switch (logic) {\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        operands.add(\n            builder.call(SqlStdOperatorTable.LESS_THAN,\n                builder.field(\"ct\", \"ck\"), builder.field(\"ct\", \"c\")),\n            b);\n      }\n    }\n    operands.add(falseLiteral);\n    return builder.call(SqlStdOperatorTable.CASE, operands.build());\n  }\n","date":"2020-09-05 00:58:49","endLine":557,"groupId":"2948","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"rewriteIn","params":"(RexSubQuerye@Set<CorrelationId>variablesSet@RelOptUtil.Logiclogic@RelBuilderbuilder@intoffset)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/28/d1bb2de26a8bcc80a8b14b832a8e293d69a364.src","preCode":"  private RexNode rewriteIn(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder, int offset) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    builder.push(e.rel);\n    final List<RexNode> fields = new ArrayList<>(builder.fields());\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    boolean allLiterals = RexUtil.allLiterals(e.getOperands());\n    final List<RexNode> expressionOperands = new ArrayList<>(e.getOperands());\n\n    final List<RexNode> keyIsNulls = e.getOperands().stream()\n        .filter(operand -> operand.getType().isNullable())\n        .map(builder::isNull)\n        .collect(Collectors.toList());\n\n    final RexLiteral trueLiteral = (RexLiteral) builder.literal(true);\n    final RexLiteral falseLiteral = (RexLiteral) builder.literal(false);\n    final RexLiteral unknownLiteral =\n        builder.getRexBuilder().makeNullLiteral(trueLiteral.getType());\n    if (allLiterals) {\n      final List<RexNode> conditions =\n          Pair.zip(expressionOperands, fields).stream()\n              .map(pair -> builder.equals(pair.left, pair.right))\n              .collect(Collectors.toList());\n      switch (logic) {\n      case TRUE:\n      case TRUE_FALSE:\n        builder.filter(conditions);\n        builder.project(builder.alias(trueLiteral, \"cs\"));\n        builder.distinct();\n        break;\n      default:\n        List<RexNode> isNullOpperands = fields.stream()\n            .map(builder::isNull)\n            .collect(Collectors.toList());\n        \r\n        isNullOpperands.addAll(keyIsNulls);\n        builder.filter(\n            builder.or(\n                builder.and(conditions),\n                builder.or(isNullOpperands)));\n        RexNode project = builder.and(\n            fields.stream()\n                .map(builder::isNotNull)\n                .collect(Collectors.toList()));\n        builder.project(builder.alias(project, \"cs\"));\n\n        if (variablesSet.isEmpty()) {\n          builder.aggregate(builder.groupKey(builder.field(\"cs\")),\n              builder.count(false, \"c\"));\n\n          \r\n          \r\n          \r\n          \r\n          builder.sortLimit(0, 1,\n              ImmutableList.of(\n                  builder.call(SqlStdOperatorTable.DESC,\n                      builder.field(\"cs\"))));\n        } else {\n          builder.distinct();\n        }\n      }\n      \r\n      \r\n      expressionOperands.clear();\n      fields.clear();\n    } else {\n      switch (logic) {\n      case TRUE:\n        builder.aggregate(builder.groupKey(fields));\n        break;\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        \r\n        builder.aggregate(builder.groupKey(),\n            builder.count(false, \"c\"),\n            builder.count(builder.fields()).as(\"ck\"));\n        builder.as(\"ct\");\n        if (!variablesSet.isEmpty()) {\n          builder.join(JoinRelType.LEFT, trueLiteral, variablesSet);\n        } else {\n          builder.join(JoinRelType.INNER, trueLiteral, variablesSet);\n        }\n        offset += 2;\n        builder.push(e.rel);\n        \r\n      default:\n        fields.add(builder.alias(trueLiteral, \"i\"));\n        builder.project(fields);\n        builder.distinct();\n      }\n    }\n\n    builder.as(\"dt\");\n    int refOffset = offset;\n    final List<RexNode> conditions =\n        Pair.zip(expressionOperands, builder.fields()).stream()\n            .map(pair -> builder.equals(pair.left, RexUtil.shift(pair.right, refOffset)))\n            .collect(Collectors.toList());\n    switch (logic) {\n    case TRUE:\n      builder.join(JoinRelType.INNER, builder.and(conditions), variablesSet);\n      return trueLiteral;\n    }\n    \r\n    builder.join(JoinRelType.LEFT, builder.and(conditions), variablesSet);\n\n    final ImmutableList.Builder<RexNode> operands = ImmutableList.builder();\n    RexLiteral b = trueLiteral;\n    switch (logic) {\n    case TRUE_FALSE_UNKNOWN:\n      b = unknownLiteral;\n      \r\n    case UNKNOWN_AS_TRUE:\n      if (allLiterals) {\n        \r\n        \r\n        if (variablesSet.isEmpty()) {\n          operands.add(\n              builder.isNull(builder.field(\"c\")),\n              falseLiteral);\n        }\n        operands.add(\n            builder.equals(builder.field(\"cs\"), falseLiteral),\n            b);\n      } else {\n        operands.add(\n            builder.equals(builder.field(\"ct\", \"c\"), builder.literal(0)),\n            falseLiteral);\n      }\n      break;\n    }\n\n    if (!keyIsNulls.isEmpty()) {\n      operands.add(builder.or(keyIsNulls), unknownLiteral);\n    }\n\n    if (allLiterals) {\n      operands.add(builder.isNotNull(builder.field(\"cs\")),\n          trueLiteral);\n    } else {\n      operands.add(builder.isNotNull(Util.last(builder.fields())),\n          trueLiteral);\n    }\n\n    if (!allLiterals) {\n      switch (logic) {\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        operands.add(\n            builder.call(SqlStdOperatorTable.LESS_THAN,\n                builder.field(\"ct\", \"ck\"), builder.field(\"ct\", \"c\")),\n            b);\n      }\n    }\n    operands.add(falseLiteral);\n    return builder.call(SqlStdOperatorTable.CASE, operands.build());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":323,"status":"M"}],"commitId":"850f0f4a04fc2399b8fd1c1fed532cd8e1e39514","commitMessage":"@@@[CALCITE-4173] Add internal SEARCH operator and Sarg literal that represents a set of values or ranges\n\nObsolete use of IN in RexCall; in Druid.  replace some uses\nwith DRUID_IN operator.\n\nCreate Sarg instances during RexSimplify of AND.  OR. Also\nduring simplify.  strengthen Sarg.containsNull from true to\nfalse if predicates prove that NULL values are impossible.\n\nIn JDBC adapter we handle SEARCH natively.  but in Geode. \nMongoDB and Spark adapters.  expand SEARCH before translating\nto target query language. Later.  it may be better to handle\nSEARCH explicitly. For instance.  it will be easier to recognize\nexpressions that can be translated to Geode's 'IN SET'\nconstruct.\n\nClose apache/calcite#2124\n","date":"2020-09-05 00:58:49","modifiedFileCount":"44","status":"M","submitter":"Julian Hyde"},{"authorTime":"2020-09-30 01:31:14","codes":[{"authorDate":"2018-05-22 01:38:03","commitOrder":6,"curCode":"  private RexNode rewriteExists(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder) {\n    builder.push(e.rel);\n\n    builder.project(builder.alias(builder.literal(true), \"i\"));\n    switch (logic) {\n    case TRUE:\n      \r\n      \r\n      \r\n      builder.aggregate(builder.groupKey(0));\n      builder.as(\"dt\");\n      builder.join(JoinRelType.INNER, builder.literal(true), variablesSet);\n      return builder.literal(true);\n    default:\n      builder.distinct();\n    }\n\n    builder.as(\"dt\");\n\n    builder.join(JoinRelType.LEFT, builder.literal(true), variablesSet);\n\n    return builder.isNotNull(Util.last(builder.fields()));\n  }\n","date":"2018-06-13 08:01:21","endLine":223,"groupId":"7228","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"rewriteExists","params":"(RexSubQuerye@Set<CorrelationId>variablesSet@RelOptUtil.Logiclogic@RelBuilderbuilder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/62/8219f40b842f9a42287a082895cb2c0ee0b13b.src","preCode":"  private RexNode rewriteExists(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder) {\n    builder.push(e.rel);\n\n    builder.project(builder.alias(builder.literal(true), \"i\"));\n    switch (logic) {\n    case TRUE:\n      \r\n      \r\n      \r\n      builder.aggregate(builder.groupKey(0));\n      builder.as(\"dt\");\n      builder.join(JoinRelType.INNER, builder.literal(true), variablesSet);\n      return builder.literal(true);\n    default:\n      builder.distinct();\n    }\n\n    builder.as(\"dt\");\n\n    builder.join(JoinRelType.LEFT, builder.literal(true), variablesSet);\n\n    return builder.isNotNull(Util.last(builder.fields()));\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":200,"status":"N"},{"authorDate":"2020-09-30 01:31:14","commitOrder":6,"curCode":"  private RexNode rewriteIn(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder, int offset) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    builder.push(e.rel);\n    final List<RexNode> fields = new ArrayList<>(builder.fields());\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    boolean allLiterals = RexUtil.allLiterals(e.getOperands());\n    final List<RexNode> expressionOperands = new ArrayList<>(e.getOperands());\n\n    final List<RexNode> keyIsNulls = e.getOperands().stream()\n        .filter(operand -> operand.getType().isNullable())\n        .map(builder::isNull)\n        .collect(Collectors.toList());\n\n    final RexLiteral trueLiteral = (RexLiteral) builder.literal(true);\n    final RexLiteral falseLiteral = (RexLiteral) builder.literal(false);\n    final RexLiteral unknownLiteral =\n        builder.getRexBuilder().makeNullLiteral(trueLiteral.getType());\n    if (allLiterals) {\n      final List<RexNode> conditions =\n          Pair.zip(expressionOperands, fields).stream()\n              .map(pair -> builder.equals(pair.left, pair.right))\n              .collect(Collectors.toList());\n      switch (logic) {\n      case TRUE:\n      case TRUE_FALSE:\n        builder.filter(conditions);\n        builder.project(builder.alias(trueLiteral, \"cs\"));\n        builder.distinct();\n        break;\n      default:\n        List<RexNode> isNullOperands = fields.stream()\n            .map(builder::isNull)\n            .collect(Collectors.toList());\n        \r\n        isNullOperands.addAll(keyIsNulls);\n        builder.filter(\n            builder.or(\n                builder.and(conditions),\n                builder.or(isNullOperands)));\n        RexNode project = builder.and(\n            fields.stream()\n                .map(builder::isNotNull)\n                .collect(Collectors.toList()));\n        builder.project(builder.alias(project, \"cs\"));\n\n        if (variablesSet.isEmpty()) {\n          builder.aggregate(builder.groupKey(builder.field(\"cs\")),\n              builder.count(false, \"c\"));\n\n          \r\n          \r\n          \r\n          \r\n          builder.sortLimit(0, 1,\n              ImmutableList.of(\n                  builder.call(SqlStdOperatorTable.DESC,\n                      builder.field(\"cs\"))));\n        } else {\n          builder.distinct();\n        }\n      }\n      \r\n      \r\n      expressionOperands.clear();\n      fields.clear();\n    } else {\n      switch (logic) {\n      case TRUE:\n        builder.aggregate(builder.groupKey(fields));\n        break;\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        \r\n        builder.aggregate(builder.groupKey(),\n            builder.count(false, \"c\"),\n            builder.count(builder.fields()).as(\"ck\"));\n        builder.as(\"ct\");\n        if (!variablesSet.isEmpty()) {\n          builder.join(JoinRelType.LEFT, trueLiteral, variablesSet);\n        } else {\n          builder.join(JoinRelType.INNER, trueLiteral, variablesSet);\n        }\n        offset += 2;\n        builder.push(e.rel);\n        \r\n      default:\n        fields.add(builder.alias(trueLiteral, \"i\"));\n        builder.project(fields);\n        builder.distinct();\n      }\n    }\n\n    builder.as(\"dt\");\n    int refOffset = offset;\n    final List<RexNode> conditions =\n        Pair.zip(expressionOperands, builder.fields()).stream()\n            .map(pair -> builder.equals(pair.left, RexUtil.shift(pair.right, refOffset)))\n            .collect(Collectors.toList());\n    switch (logic) {\n    case TRUE:\n      builder.join(JoinRelType.INNER, builder.and(conditions), variablesSet);\n      return trueLiteral;\n    default:\n      break;\n    }\n    \r\n    builder.join(JoinRelType.LEFT, builder.and(conditions), variablesSet);\n\n    final ImmutableList.Builder<RexNode> operands = ImmutableList.builder();\n    RexLiteral b = trueLiteral;\n    switch (logic) {\n    case TRUE_FALSE_UNKNOWN:\n      b = unknownLiteral;\n      \r\n    case UNKNOWN_AS_TRUE:\n      if (allLiterals) {\n        \r\n        \r\n        if (variablesSet.isEmpty()) {\n          operands.add(\n              builder.isNull(builder.field(\"c\")),\n              falseLiteral);\n        }\n        operands.add(\n            builder.equals(builder.field(\"cs\"), falseLiteral),\n            b);\n      } else {\n        operands.add(\n            builder.equals(builder.field(\"ct\", \"c\"), builder.literal(0)),\n            falseLiteral);\n      }\n      break;\n    default:\n      break;\n    }\n\n    if (!keyIsNulls.isEmpty()) {\n      operands.add(builder.or(keyIsNulls), unknownLiteral);\n    }\n\n    if (allLiterals) {\n      operands.add(builder.isNotNull(builder.field(\"cs\")),\n          trueLiteral);\n    } else {\n      operands.add(builder.isNotNull(Util.last(builder.fields())),\n          trueLiteral);\n    }\n\n    if (!allLiterals) {\n      switch (logic) {\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        operands.add(\n            builder.call(SqlStdOperatorTable.LESS_THAN,\n                builder.field(\"ct\", \"ck\"), builder.field(\"ct\", \"c\")),\n            b);\n        break;\n      default:\n        break;\n      }\n    }\n    operands.add(falseLiteral);\n    return builder.call(SqlStdOperatorTable.CASE, operands.build());\n  }\n","date":"2020-10-07 05:43:06","endLine":564,"groupId":"2948","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"rewriteIn","params":"(RexSubQuerye@Set<CorrelationId>variablesSet@RelOptUtil.Logiclogic@RelBuilderbuilder@intoffset)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/c0/7890e2b2c9cd162f6cdd438d2df63c91114e44.src","preCode":"  private RexNode rewriteIn(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder, int offset) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    builder.push(e.rel);\n    final List<RexNode> fields = new ArrayList<>(builder.fields());\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    boolean allLiterals = RexUtil.allLiterals(e.getOperands());\n    final List<RexNode> expressionOperands = new ArrayList<>(e.getOperands());\n\n    final List<RexNode> keyIsNulls = e.getOperands().stream()\n        .filter(operand -> operand.getType().isNullable())\n        .map(builder::isNull)\n        .collect(Collectors.toList());\n\n    final RexLiteral trueLiteral = (RexLiteral) builder.literal(true);\n    final RexLiteral falseLiteral = (RexLiteral) builder.literal(false);\n    final RexLiteral unknownLiteral =\n        builder.getRexBuilder().makeNullLiteral(trueLiteral.getType());\n    if (allLiterals) {\n      final List<RexNode> conditions =\n          Pair.zip(expressionOperands, fields).stream()\n              .map(pair -> builder.equals(pair.left, pair.right))\n              .collect(Collectors.toList());\n      switch (logic) {\n      case TRUE:\n      case TRUE_FALSE:\n        builder.filter(conditions);\n        builder.project(builder.alias(trueLiteral, \"cs\"));\n        builder.distinct();\n        break;\n      default:\n        List<RexNode> isNullOperands = fields.stream()\n            .map(builder::isNull)\n            .collect(Collectors.toList());\n        \r\n        isNullOperands.addAll(keyIsNulls);\n        builder.filter(\n            builder.or(\n                builder.and(conditions),\n                builder.or(isNullOperands)));\n        RexNode project = builder.and(\n            fields.stream()\n                .map(builder::isNotNull)\n                .collect(Collectors.toList()));\n        builder.project(builder.alias(project, \"cs\"));\n\n        if (variablesSet.isEmpty()) {\n          builder.aggregate(builder.groupKey(builder.field(\"cs\")),\n              builder.count(false, \"c\"));\n\n          \r\n          \r\n          \r\n          \r\n          builder.sortLimit(0, 1,\n              ImmutableList.of(\n                  builder.call(SqlStdOperatorTable.DESC,\n                      builder.field(\"cs\"))));\n        } else {\n          builder.distinct();\n        }\n      }\n      \r\n      \r\n      expressionOperands.clear();\n      fields.clear();\n    } else {\n      switch (logic) {\n      case TRUE:\n        builder.aggregate(builder.groupKey(fields));\n        break;\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        \r\n        builder.aggregate(builder.groupKey(),\n            builder.count(false, \"c\"),\n            builder.count(builder.fields()).as(\"ck\"));\n        builder.as(\"ct\");\n        if (!variablesSet.isEmpty()) {\n          builder.join(JoinRelType.LEFT, trueLiteral, variablesSet);\n        } else {\n          builder.join(JoinRelType.INNER, trueLiteral, variablesSet);\n        }\n        offset += 2;\n        builder.push(e.rel);\n        \r\n      default:\n        fields.add(builder.alias(trueLiteral, \"i\"));\n        builder.project(fields);\n        builder.distinct();\n      }\n    }\n\n    builder.as(\"dt\");\n    int refOffset = offset;\n    final List<RexNode> conditions =\n        Pair.zip(expressionOperands, builder.fields()).stream()\n            .map(pair -> builder.equals(pair.left, RexUtil.shift(pair.right, refOffset)))\n            .collect(Collectors.toList());\n    switch (logic) {\n    case TRUE:\n      builder.join(JoinRelType.INNER, builder.and(conditions), variablesSet);\n      return trueLiteral;\n    }\n    \r\n    builder.join(JoinRelType.LEFT, builder.and(conditions), variablesSet);\n\n    final ImmutableList.Builder<RexNode> operands = ImmutableList.builder();\n    RexLiteral b = trueLiteral;\n    switch (logic) {\n    case TRUE_FALSE_UNKNOWN:\n      b = unknownLiteral;\n      \r\n    case UNKNOWN_AS_TRUE:\n      if (allLiterals) {\n        \r\n        \r\n        if (variablesSet.isEmpty()) {\n          operands.add(\n              builder.isNull(builder.field(\"c\")),\n              falseLiteral);\n        }\n        operands.add(\n            builder.equals(builder.field(\"cs\"), falseLiteral),\n            b);\n      } else {\n        operands.add(\n            builder.equals(builder.field(\"ct\", \"c\"), builder.literal(0)),\n            falseLiteral);\n      }\n      break;\n    }\n\n    if (!keyIsNulls.isEmpty()) {\n      operands.add(builder.or(keyIsNulls), unknownLiteral);\n    }\n\n    if (allLiterals) {\n      operands.add(builder.isNotNull(builder.field(\"cs\")),\n          trueLiteral);\n    } else {\n      operands.add(builder.isNotNull(Util.last(builder.fields())),\n          trueLiteral);\n    }\n\n    if (!allLiterals) {\n      switch (logic) {\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        operands.add(\n            builder.call(SqlStdOperatorTable.LESS_THAN,\n                builder.field(\"ct\", \"ck\"), builder.field(\"ct\", \"c\")),\n            b);\n      }\n    }\n    operands.add(falseLiteral);\n    return builder.call(SqlStdOperatorTable.CASE, operands.build());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":323,"status":"M"}],"commitId":"1b94f37e888cf2d186362473529e6c147afe0f6e","commitMessage":"@@@[CALCITE-4314] Add missing default branches to switch statement\n\nNote: the changes are mechanical.\nThe intention is to keep the previous behavior and prevent adding new\nnon exchaustive switch statements in the future.\n\nSee https://errorprone.info/bugpattern/MissingCasesInEnumSwitch\n","date":"2020-10-07 05:43:06","modifiedFileCount":"98","status":"M","submitter":"Vladimir Sitnikov"},{"authorTime":"2020-12-02 05:40:39","codes":[{"authorDate":"2020-12-02 05:40:39","commitOrder":7,"curCode":"  private static RexNode rewriteExists(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder) {\n    builder.push(e.rel);\n\n    builder.project(builder.alias(builder.literal(true), \"i\"));\n    switch (logic) {\n    case TRUE:\n      \r\n      \r\n      \r\n      builder.aggregate(builder.groupKey(0));\n      builder.as(\"dt\");\n      builder.join(JoinRelType.INNER, builder.literal(true), variablesSet);\n      return builder.literal(true);\n    default:\n      builder.distinct();\n    }\n\n    builder.as(\"dt\");\n\n    builder.join(JoinRelType.LEFT, builder.literal(true), variablesSet);\n\n    return builder.isNotNull(Util.last(builder.fields()));\n  }\n","date":"2020-12-08 15:07:23","endLine":309,"groupId":"7228","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"rewriteExists","params":"(RexSubQuerye@Set<CorrelationId>variablesSet@RelOptUtil.Logiclogic@RelBuilderbuilder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/cb/356d6123610c0c5287a55998bbb91763c33cf9.src","preCode":"  private RexNode rewriteExists(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder) {\n    builder.push(e.rel);\n\n    builder.project(builder.alias(builder.literal(true), \"i\"));\n    switch (logic) {\n    case TRUE:\n      \r\n      \r\n      \r\n      builder.aggregate(builder.groupKey(0));\n      builder.as(\"dt\");\n      builder.join(JoinRelType.INNER, builder.literal(true), variablesSet);\n      return builder.literal(true);\n    default:\n      builder.distinct();\n    }\n\n    builder.as(\"dt\");\n\n    builder.join(JoinRelType.LEFT, builder.literal(true), variablesSet);\n\n    return builder.isNotNull(Util.last(builder.fields()));\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":286,"status":"M"},{"authorDate":"2020-12-02 05:40:39","commitOrder":7,"curCode":"  private static RexNode rewriteIn(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder, int offset) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    builder.push(e.rel);\n    final List<RexNode> fields = new ArrayList<>(builder.fields());\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    boolean allLiterals = RexUtil.allLiterals(e.getOperands());\n    final List<RexNode> expressionOperands = new ArrayList<>(e.getOperands());\n\n    final List<RexNode> keyIsNulls = e.getOperands().stream()\n        .filter(operand -> operand.getType().isNullable())\n        .map(builder::isNull)\n        .collect(Collectors.toList());\n\n    final RexLiteral trueLiteral = (RexLiteral) builder.literal(true);\n    final RexLiteral falseLiteral = (RexLiteral) builder.literal(false);\n    final RexLiteral unknownLiteral =\n        builder.getRexBuilder().makeNullLiteral(trueLiteral.getType());\n    if (allLiterals) {\n      final List<RexNode> conditions =\n          Pair.zip(expressionOperands, fields).stream()\n              .map(pair -> builder.equals(pair.left, pair.right))\n              .collect(Collectors.toList());\n      switch (logic) {\n      case TRUE:\n      case TRUE_FALSE:\n        builder.filter(conditions);\n        builder.project(builder.alias(trueLiteral, \"cs\"));\n        builder.distinct();\n        break;\n      default:\n        List<RexNode> isNullOperands = fields.stream()\n            .map(builder::isNull)\n            .collect(Collectors.toList());\n        \r\n        isNullOperands.addAll(keyIsNulls);\n        builder.filter(\n            builder.or(\n                builder.and(conditions),\n                builder.or(isNullOperands)));\n        RexNode project = builder.and(\n            fields.stream()\n                .map(builder::isNotNull)\n                .collect(Collectors.toList()));\n        builder.project(builder.alias(project, \"cs\"));\n\n        if (variablesSet.isEmpty()) {\n          builder.aggregate(builder.groupKey(builder.field(\"cs\")),\n              builder.count(false, \"c\"));\n\n          \r\n          \r\n          \r\n          \r\n          builder.sortLimit(0, 1,\n              ImmutableList.of(\n                  builder.call(SqlStdOperatorTable.DESC,\n                      builder.field(\"cs\"))));\n        } else {\n          builder.distinct();\n        }\n      }\n      \r\n      \r\n      expressionOperands.clear();\n      fields.clear();\n    } else {\n      switch (logic) {\n      case TRUE:\n        builder.aggregate(builder.groupKey(fields));\n        break;\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        \r\n        builder.aggregate(builder.groupKey(),\n            builder.count(false, \"c\"),\n            builder.count(builder.fields()).as(\"ck\"));\n        builder.as(\"ct\");\n        if (!variablesSet.isEmpty()) {\n          builder.join(JoinRelType.LEFT, trueLiteral, variablesSet);\n        } else {\n          builder.join(JoinRelType.INNER, trueLiteral, variablesSet);\n        }\n        offset += 2;\n        builder.push(e.rel);\n        \r\n      default:\n        fields.add(builder.alias(trueLiteral, \"i\"));\n        builder.project(fields);\n        builder.distinct();\n      }\n    }\n\n    builder.as(\"dt\");\n    int refOffset = offset;\n    final List<RexNode> conditions =\n        Pair.zip(expressionOperands, builder.fields()).stream()\n            .map(pair -> builder.equals(pair.left, RexUtil.shift(pair.right, refOffset)))\n            .collect(Collectors.toList());\n    switch (logic) {\n    case TRUE:\n      builder.join(JoinRelType.INNER, builder.and(conditions), variablesSet);\n      return trueLiteral;\n    default:\n      break;\n    }\n    \r\n    builder.join(JoinRelType.LEFT, builder.and(conditions), variablesSet);\n\n    final ImmutableList.Builder<RexNode> operands = ImmutableList.builder();\n    RexLiteral b = trueLiteral;\n    switch (logic) {\n    case TRUE_FALSE_UNKNOWN:\n      b = unknownLiteral;\n      \r\n    case UNKNOWN_AS_TRUE:\n      if (allLiterals) {\n        \r\n        \r\n        if (variablesSet.isEmpty()) {\n          operands.add(\n              builder.isNull(builder.field(\"c\")),\n              falseLiteral);\n        }\n        operands.add(\n            builder.equals(builder.field(\"cs\"), falseLiteral),\n            b);\n      } else {\n        operands.add(\n            builder.equals(builder.field(\"ct\", \"c\"), builder.literal(0)),\n            falseLiteral);\n      }\n      break;\n    default:\n      break;\n    }\n\n    if (!keyIsNulls.isEmpty()) {\n      operands.add(builder.or(keyIsNulls), unknownLiteral);\n    }\n\n    if (allLiterals) {\n      operands.add(builder.isNotNull(builder.field(\"cs\")),\n          trueLiteral);\n    } else {\n      operands.add(builder.isNotNull(Util.last(builder.fields())),\n          trueLiteral);\n    }\n\n    if (!allLiterals) {\n      switch (logic) {\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        operands.add(\n            builder.call(SqlStdOperatorTable.LESS_THAN,\n                builder.field(\"ct\", \"ck\"), builder.field(\"ct\", \"c\")),\n            b);\n        break;\n      default:\n        break;\n      }\n    }\n    operands.add(falseLiteral);\n    return builder.call(SqlStdOperatorTable.CASE, operands.build());\n  }\n","date":"2020-12-08 15:07:23","endLine":564,"groupId":"2948","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"rewriteIn","params":"(RexSubQuerye@Set<CorrelationId>variablesSet@RelOptUtil.Logiclogic@RelBuilderbuilder@intoffset)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/cb/356d6123610c0c5287a55998bbb91763c33cf9.src","preCode":"  private RexNode rewriteIn(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder, int offset) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    builder.push(e.rel);\n    final List<RexNode> fields = new ArrayList<>(builder.fields());\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    boolean allLiterals = RexUtil.allLiterals(e.getOperands());\n    final List<RexNode> expressionOperands = new ArrayList<>(e.getOperands());\n\n    final List<RexNode> keyIsNulls = e.getOperands().stream()\n        .filter(operand -> operand.getType().isNullable())\n        .map(builder::isNull)\n        .collect(Collectors.toList());\n\n    final RexLiteral trueLiteral = (RexLiteral) builder.literal(true);\n    final RexLiteral falseLiteral = (RexLiteral) builder.literal(false);\n    final RexLiteral unknownLiteral =\n        builder.getRexBuilder().makeNullLiteral(trueLiteral.getType());\n    if (allLiterals) {\n      final List<RexNode> conditions =\n          Pair.zip(expressionOperands, fields).stream()\n              .map(pair -> builder.equals(pair.left, pair.right))\n              .collect(Collectors.toList());\n      switch (logic) {\n      case TRUE:\n      case TRUE_FALSE:\n        builder.filter(conditions);\n        builder.project(builder.alias(trueLiteral, \"cs\"));\n        builder.distinct();\n        break;\n      default:\n        List<RexNode> isNullOperands = fields.stream()\n            .map(builder::isNull)\n            .collect(Collectors.toList());\n        \r\n        isNullOperands.addAll(keyIsNulls);\n        builder.filter(\n            builder.or(\n                builder.and(conditions),\n                builder.or(isNullOperands)));\n        RexNode project = builder.and(\n            fields.stream()\n                .map(builder::isNotNull)\n                .collect(Collectors.toList()));\n        builder.project(builder.alias(project, \"cs\"));\n\n        if (variablesSet.isEmpty()) {\n          builder.aggregate(builder.groupKey(builder.field(\"cs\")),\n              builder.count(false, \"c\"));\n\n          \r\n          \r\n          \r\n          \r\n          builder.sortLimit(0, 1,\n              ImmutableList.of(\n                  builder.call(SqlStdOperatorTable.DESC,\n                      builder.field(\"cs\"))));\n        } else {\n          builder.distinct();\n        }\n      }\n      \r\n      \r\n      expressionOperands.clear();\n      fields.clear();\n    } else {\n      switch (logic) {\n      case TRUE:\n        builder.aggregate(builder.groupKey(fields));\n        break;\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        \r\n        builder.aggregate(builder.groupKey(),\n            builder.count(false, \"c\"),\n            builder.count(builder.fields()).as(\"ck\"));\n        builder.as(\"ct\");\n        if (!variablesSet.isEmpty()) {\n          builder.join(JoinRelType.LEFT, trueLiteral, variablesSet);\n        } else {\n          builder.join(JoinRelType.INNER, trueLiteral, variablesSet);\n        }\n        offset += 2;\n        builder.push(e.rel);\n        \r\n      default:\n        fields.add(builder.alias(trueLiteral, \"i\"));\n        builder.project(fields);\n        builder.distinct();\n      }\n    }\n\n    builder.as(\"dt\");\n    int refOffset = offset;\n    final List<RexNode> conditions =\n        Pair.zip(expressionOperands, builder.fields()).stream()\n            .map(pair -> builder.equals(pair.left, RexUtil.shift(pair.right, refOffset)))\n            .collect(Collectors.toList());\n    switch (logic) {\n    case TRUE:\n      builder.join(JoinRelType.INNER, builder.and(conditions), variablesSet);\n      return trueLiteral;\n    default:\n      break;\n    }\n    \r\n    builder.join(JoinRelType.LEFT, builder.and(conditions), variablesSet);\n\n    final ImmutableList.Builder<RexNode> operands = ImmutableList.builder();\n    RexLiteral b = trueLiteral;\n    switch (logic) {\n    case TRUE_FALSE_UNKNOWN:\n      b = unknownLiteral;\n      \r\n    case UNKNOWN_AS_TRUE:\n      if (allLiterals) {\n        \r\n        \r\n        if (variablesSet.isEmpty()) {\n          operands.add(\n              builder.isNull(builder.field(\"c\")),\n              falseLiteral);\n        }\n        operands.add(\n            builder.equals(builder.field(\"cs\"), falseLiteral),\n            b);\n      } else {\n        operands.add(\n            builder.equals(builder.field(\"ct\", \"c\"), builder.literal(0)),\n            falseLiteral);\n      }\n      break;\n    default:\n      break;\n    }\n\n    if (!keyIsNulls.isEmpty()) {\n      operands.add(builder.or(keyIsNulls), unknownLiteral);\n    }\n\n    if (allLiterals) {\n      operands.add(builder.isNotNull(builder.field(\"cs\")),\n          trueLiteral);\n    } else {\n      operands.add(builder.isNotNull(Util.last(builder.fields())),\n          trueLiteral);\n    }\n\n    if (!allLiterals) {\n      switch (logic) {\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        operands.add(\n            builder.call(SqlStdOperatorTable.LESS_THAN,\n                builder.field(\"ct\", \"ck\"), builder.field(\"ct\", \"c\")),\n            b);\n        break;\n      default:\n        break;\n      }\n    }\n    operands.add(falseLiteral);\n    return builder.call(SqlStdOperatorTable.CASE, operands.build());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":323,"status":"M"}],"commitId":"404f968f6079360621896e6ee20ec12488a40bc2","commitMessage":"@@@[CALCITE-4422] Add MethodCanBeStatic check via ErrorProne\n\nprivate and final methods can be made static.  so it is clear they do not access instance fields\n","date":"2020-12-08 15:07:23","modifiedFileCount":"169","status":"M","submitter":"Vladimir Sitnikov"},{"authorTime":"2020-12-14 16:40:32","codes":[{"authorDate":"2020-12-02 05:40:39","commitOrder":8,"curCode":"  private static RexNode rewriteExists(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder) {\n    builder.push(e.rel);\n\n    builder.project(builder.alias(builder.literal(true), \"i\"));\n    switch (logic) {\n    case TRUE:\n      \r\n      \r\n      \r\n      builder.aggregate(builder.groupKey(0));\n      builder.as(\"dt\");\n      builder.join(JoinRelType.INNER, builder.literal(true), variablesSet);\n      return builder.literal(true);\n    default:\n      builder.distinct();\n    }\n\n    builder.as(\"dt\");\n\n    builder.join(JoinRelType.LEFT, builder.literal(true), variablesSet);\n\n    return builder.isNotNull(Util.last(builder.fields()));\n  }\n","date":"2020-12-08 15:07:23","endLine":309,"groupId":"7228","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"rewriteExists","params":"(RexSubQuerye@Set<CorrelationId>variablesSet@RelOptUtil.Logiclogic@RelBuilderbuilder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/cb/356d6123610c0c5287a55998bbb91763c33cf9.src","preCode":"  private static RexNode rewriteExists(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder) {\n    builder.push(e.rel);\n\n    builder.project(builder.alias(builder.literal(true), \"i\"));\n    switch (logic) {\n    case TRUE:\n      \r\n      \r\n      \r\n      builder.aggregate(builder.groupKey(0));\n      builder.as(\"dt\");\n      builder.join(JoinRelType.INNER, builder.literal(true), variablesSet);\n      return builder.literal(true);\n    default:\n      builder.distinct();\n    }\n\n    builder.as(\"dt\");\n\n    builder.join(JoinRelType.LEFT, builder.literal(true), variablesSet);\n\n    return builder.isNotNull(Util.last(builder.fields()));\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":286,"status":"N"},{"authorDate":"2020-12-14 16:40:32","commitOrder":8,"curCode":"  private static RexNode rewriteIn(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder, int offset) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    builder.push(e.rel);\n    final List<RexNode> fields = new ArrayList<>(builder.fields());\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    boolean allLiterals = RexUtil.allLiterals(e.getOperands());\n    final List<RexNode> expressionOperands = new ArrayList<>(e.getOperands());\n\n    final List<RexNode> keyIsNulls = e.getOperands().stream()\n        .filter(operand -> operand.getType().isNullable())\n        .map(builder::isNull)\n        .collect(Collectors.toList());\n\n    final RexLiteral trueLiteral = builder.literal(true);\n    final RexLiteral falseLiteral = builder.literal(false);\n    final RexLiteral unknownLiteral =\n        builder.getRexBuilder().makeNullLiteral(trueLiteral.getType());\n    if (allLiterals) {\n      final List<RexNode> conditions =\n          Pair.zip(expressionOperands, fields).stream()\n              .map(pair -> builder.equals(pair.left, pair.right))\n              .collect(Collectors.toList());\n      switch (logic) {\n      case TRUE:\n      case TRUE_FALSE:\n        builder.filter(conditions);\n        builder.project(builder.alias(trueLiteral, \"cs\"));\n        builder.distinct();\n        break;\n      default:\n        List<RexNode> isNullOperands = fields.stream()\n            .map(builder::isNull)\n            .collect(Collectors.toList());\n        \r\n        isNullOperands.addAll(keyIsNulls);\n        builder.filter(\n            builder.or(\n                builder.and(conditions),\n                builder.or(isNullOperands)));\n        RexNode project = builder.and(\n            fields.stream()\n                .map(builder::isNotNull)\n                .collect(Collectors.toList()));\n        builder.project(builder.alias(project, \"cs\"));\n\n        if (variablesSet.isEmpty()) {\n          builder.aggregate(builder.groupKey(builder.field(\"cs\")),\n              builder.count(false, \"c\"));\n\n          \r\n          \r\n          \r\n          \r\n          builder.sortLimit(0, 1,\n              ImmutableList.of(\n                  builder.call(SqlStdOperatorTable.DESC,\n                      builder.field(\"cs\"))));\n        } else {\n          builder.distinct();\n        }\n      }\n      \r\n      \r\n      expressionOperands.clear();\n      fields.clear();\n    } else {\n      switch (logic) {\n      case TRUE:\n        builder.aggregate(builder.groupKey(fields));\n        break;\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        \r\n        builder.aggregate(builder.groupKey(),\n            builder.count(false, \"c\"),\n            builder.count(builder.fields()).as(\"ck\"));\n        builder.as(\"ct\");\n        if (!variablesSet.isEmpty()) {\n          builder.join(JoinRelType.LEFT, trueLiteral, variablesSet);\n        } else {\n          builder.join(JoinRelType.INNER, trueLiteral, variablesSet);\n        }\n        offset += 2;\n        builder.push(e.rel);\n        \r\n      default:\n        fields.add(builder.alias(trueLiteral, \"i\"));\n        builder.project(fields);\n        builder.distinct();\n      }\n    }\n\n    builder.as(\"dt\");\n    int refOffset = offset;\n    final List<RexNode> conditions =\n        Pair.zip(expressionOperands, builder.fields()).stream()\n            .map(pair -> builder.equals(pair.left, RexUtil.shift(pair.right, refOffset)))\n            .collect(Collectors.toList());\n    switch (logic) {\n    case TRUE:\n      builder.join(JoinRelType.INNER, builder.and(conditions), variablesSet);\n      return trueLiteral;\n    default:\n      break;\n    }\n    \r\n    builder.join(JoinRelType.LEFT, builder.and(conditions), variablesSet);\n\n    final ImmutableList.Builder<RexNode> operands = ImmutableList.builder();\n    RexLiteral b = trueLiteral;\n    switch (logic) {\n    case TRUE_FALSE_UNKNOWN:\n      b = unknownLiteral;\n      \r\n    case UNKNOWN_AS_TRUE:\n      if (allLiterals) {\n        \r\n        \r\n        if (variablesSet.isEmpty()) {\n          operands.add(\n              builder.isNull(builder.field(\"c\")),\n              falseLiteral);\n        }\n        operands.add(\n            builder.equals(builder.field(\"cs\"), falseLiteral),\n            b);\n      } else {\n        operands.add(\n            builder.equals(builder.field(\"ct\", \"c\"), builder.literal(0)),\n            falseLiteral);\n      }\n      break;\n    default:\n      break;\n    }\n\n    if (!keyIsNulls.isEmpty()) {\n      operands.add(builder.or(keyIsNulls), unknownLiteral);\n    }\n\n    if (allLiterals) {\n      operands.add(builder.isNotNull(builder.field(\"cs\")),\n          trueLiteral);\n    } else {\n      operands.add(builder.isNotNull(Util.last(builder.fields())),\n          trueLiteral);\n    }\n\n    if (!allLiterals) {\n      switch (logic) {\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        operands.add(\n            builder.call(SqlStdOperatorTable.LESS_THAN,\n                builder.field(\"ct\", \"ck\"), builder.field(\"ct\", \"c\")),\n            b);\n        break;\n      default:\n        break;\n      }\n    }\n    operands.add(falseLiteral);\n    return builder.call(SqlStdOperatorTable.CASE, operands.build());\n  }\n","date":"2020-12-19 05:09:44","endLine":564,"groupId":"2948","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"rewriteIn","params":"(RexSubQuerye@Set<CorrelationId>variablesSet@RelOptUtil.Logiclogic@RelBuilderbuilder@intoffset)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/5b/fbcca65c93b244c0e1f06bc45dcd40594ffcf9.src","preCode":"  private static RexNode rewriteIn(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder, int offset) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    builder.push(e.rel);\n    final List<RexNode> fields = new ArrayList<>(builder.fields());\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    boolean allLiterals = RexUtil.allLiterals(e.getOperands());\n    final List<RexNode> expressionOperands = new ArrayList<>(e.getOperands());\n\n    final List<RexNode> keyIsNulls = e.getOperands().stream()\n        .filter(operand -> operand.getType().isNullable())\n        .map(builder::isNull)\n        .collect(Collectors.toList());\n\n    final RexLiteral trueLiteral = (RexLiteral) builder.literal(true);\n    final RexLiteral falseLiteral = (RexLiteral) builder.literal(false);\n    final RexLiteral unknownLiteral =\n        builder.getRexBuilder().makeNullLiteral(trueLiteral.getType());\n    if (allLiterals) {\n      final List<RexNode> conditions =\n          Pair.zip(expressionOperands, fields).stream()\n              .map(pair -> builder.equals(pair.left, pair.right))\n              .collect(Collectors.toList());\n      switch (logic) {\n      case TRUE:\n      case TRUE_FALSE:\n        builder.filter(conditions);\n        builder.project(builder.alias(trueLiteral, \"cs\"));\n        builder.distinct();\n        break;\n      default:\n        List<RexNode> isNullOperands = fields.stream()\n            .map(builder::isNull)\n            .collect(Collectors.toList());\n        \r\n        isNullOperands.addAll(keyIsNulls);\n        builder.filter(\n            builder.or(\n                builder.and(conditions),\n                builder.or(isNullOperands)));\n        RexNode project = builder.and(\n            fields.stream()\n                .map(builder::isNotNull)\n                .collect(Collectors.toList()));\n        builder.project(builder.alias(project, \"cs\"));\n\n        if (variablesSet.isEmpty()) {\n          builder.aggregate(builder.groupKey(builder.field(\"cs\")),\n              builder.count(false, \"c\"));\n\n          \r\n          \r\n          \r\n          \r\n          builder.sortLimit(0, 1,\n              ImmutableList.of(\n                  builder.call(SqlStdOperatorTable.DESC,\n                      builder.field(\"cs\"))));\n        } else {\n          builder.distinct();\n        }\n      }\n      \r\n      \r\n      expressionOperands.clear();\n      fields.clear();\n    } else {\n      switch (logic) {\n      case TRUE:\n        builder.aggregate(builder.groupKey(fields));\n        break;\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        \r\n        builder.aggregate(builder.groupKey(),\n            builder.count(false, \"c\"),\n            builder.count(builder.fields()).as(\"ck\"));\n        builder.as(\"ct\");\n        if (!variablesSet.isEmpty()) {\n          builder.join(JoinRelType.LEFT, trueLiteral, variablesSet);\n        } else {\n          builder.join(JoinRelType.INNER, trueLiteral, variablesSet);\n        }\n        offset += 2;\n        builder.push(e.rel);\n        \r\n      default:\n        fields.add(builder.alias(trueLiteral, \"i\"));\n        builder.project(fields);\n        builder.distinct();\n      }\n    }\n\n    builder.as(\"dt\");\n    int refOffset = offset;\n    final List<RexNode> conditions =\n        Pair.zip(expressionOperands, builder.fields()).stream()\n            .map(pair -> builder.equals(pair.left, RexUtil.shift(pair.right, refOffset)))\n            .collect(Collectors.toList());\n    switch (logic) {\n    case TRUE:\n      builder.join(JoinRelType.INNER, builder.and(conditions), variablesSet);\n      return trueLiteral;\n    default:\n      break;\n    }\n    \r\n    builder.join(JoinRelType.LEFT, builder.and(conditions), variablesSet);\n\n    final ImmutableList.Builder<RexNode> operands = ImmutableList.builder();\n    RexLiteral b = trueLiteral;\n    switch (logic) {\n    case TRUE_FALSE_UNKNOWN:\n      b = unknownLiteral;\n      \r\n    case UNKNOWN_AS_TRUE:\n      if (allLiterals) {\n        \r\n        \r\n        if (variablesSet.isEmpty()) {\n          operands.add(\n              builder.isNull(builder.field(\"c\")),\n              falseLiteral);\n        }\n        operands.add(\n            builder.equals(builder.field(\"cs\"), falseLiteral),\n            b);\n      } else {\n        operands.add(\n            builder.equals(builder.field(\"ct\", \"c\"), builder.literal(0)),\n            falseLiteral);\n      }\n      break;\n    default:\n      break;\n    }\n\n    if (!keyIsNulls.isEmpty()) {\n      operands.add(builder.or(keyIsNulls), unknownLiteral);\n    }\n\n    if (allLiterals) {\n      operands.add(builder.isNotNull(builder.field(\"cs\")),\n          trueLiteral);\n    } else {\n      operands.add(builder.isNotNull(Util.last(builder.fields())),\n          trueLiteral);\n    }\n\n    if (!allLiterals) {\n      switch (logic) {\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        operands.add(\n            builder.call(SqlStdOperatorTable.LESS_THAN,\n                builder.field(\"ct\", \"ck\"), builder.field(\"ct\", \"c\")),\n            b);\n        break;\n      default:\n        break;\n      }\n    }\n    operands.add(falseLiteral);\n    return builder.call(SqlStdOperatorTable.CASE, operands.build());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":323,"status":"M"}],"commitId":"56a86a032ac05ed522846910eea6f884b31820e3","commitMessage":"@@@Refactor: Change return type of RelBuilder.literal from RexNode to RexLiteral\n","date":"2020-12-19 05:09:44","modifiedFileCount":"15","status":"M","submitter":"Julian Hyde"},{"authorTime":"2021-09-17 17:38:52","codes":[{"authorDate":"2020-12-02 05:40:39","commitOrder":9,"curCode":"  private static RexNode rewriteExists(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder) {\n    builder.push(e.rel);\n\n    builder.project(builder.alias(builder.literal(true), \"i\"));\n    switch (logic) {\n    case TRUE:\n      \r\n      \r\n      \r\n      builder.aggregate(builder.groupKey(0));\n      builder.as(\"dt\");\n      builder.join(JoinRelType.INNER, builder.literal(true), variablesSet);\n      return builder.literal(true);\n    default:\n      builder.distinct();\n    }\n\n    builder.as(\"dt\");\n\n    builder.join(JoinRelType.LEFT, builder.literal(true), variablesSet);\n\n    return builder.isNotNull(Util.last(builder.fields()));\n  }\n","date":"2020-12-08 15:07:23","endLine":309,"groupId":"7228","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"rewriteExists","params":"(RexSubQuerye@Set<CorrelationId>variablesSet@RelOptUtil.Logiclogic@RelBuilderbuilder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/cb/356d6123610c0c5287a55998bbb91763c33cf9.src","preCode":"  private static RexNode rewriteExists(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder) {\n    builder.push(e.rel);\n\n    builder.project(builder.alias(builder.literal(true), \"i\"));\n    switch (logic) {\n    case TRUE:\n      \r\n      \r\n      \r\n      builder.aggregate(builder.groupKey(0));\n      builder.as(\"dt\");\n      builder.join(JoinRelType.INNER, builder.literal(true), variablesSet);\n      return builder.literal(true);\n    default:\n      builder.distinct();\n    }\n\n    builder.as(\"dt\");\n\n    builder.join(JoinRelType.LEFT, builder.literal(true), variablesSet);\n\n    return builder.isNotNull(Util.last(builder.fields()));\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":286,"status":"N"},{"authorDate":"2021-09-17 17:38:52","commitOrder":9,"curCode":"  private static RexNode rewriteIn(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder, int offset) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    builder.push(e.rel);\n    final List<RexNode> fields = new ArrayList<>(builder.fields());\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    boolean allLiterals = RexUtil.allLiterals(e.getOperands());\n    final List<RexNode> expressionOperands = new ArrayList<>(e.getOperands());\n\n    final List<RexNode> keyIsNulls = e.getOperands().stream()\n        .filter(operand -> operand.getType().isNullable())\n        .map(builder::isNull)\n        .collect(Collectors.toList());\n\n    final RexLiteral trueLiteral = builder.literal(true);\n    final RexLiteral falseLiteral = builder.literal(false);\n    final RexLiteral unknownLiteral =\n        builder.getRexBuilder().makeNullLiteral(trueLiteral.getType());\n    if (allLiterals) {\n      final List<RexNode> conditions =\n          Pair.zip(expressionOperands, fields).stream()\n              .map(pair -> builder.equals(pair.left, pair.right))\n              .collect(Collectors.toList());\n      switch (logic) {\n      case TRUE:\n      case TRUE_FALSE:\n        builder.filter(conditions);\n        builder.project(builder.alias(trueLiteral, \"cs\"));\n        builder.distinct();\n        break;\n      default:\n        List<RexNode> isNullOperands = fields.stream()\n            .map(builder::isNull)\n            .collect(Collectors.toList());\n        \r\n        isNullOperands.addAll(keyIsNulls);\n        builder.filter(\n            builder.or(\n                builder.and(conditions),\n                builder.or(isNullOperands)));\n        RexNode project = builder.and(\n            fields.stream()\n                .map(builder::isNotNull)\n                .collect(Collectors.toList()));\n        builder.project(builder.alias(project, \"cs\"));\n\n        if (variablesSet.isEmpty()) {\n          builder.aggregate(builder.groupKey(builder.field(\"cs\")),\n              builder.count(false, \"c\"));\n\n          \r\n          \r\n          \r\n          \r\n          builder.sortLimit(0, 1,\n              ImmutableList.of(builder.desc(builder.field(\"cs\"))));\n        } else {\n          builder.distinct();\n        }\n      }\n      \r\n      \r\n      expressionOperands.clear();\n      fields.clear();\n    } else {\n      switch (logic) {\n      case TRUE:\n        builder.aggregate(builder.groupKey(fields));\n        break;\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        \r\n        builder.aggregate(builder.groupKey(),\n            builder.count(false, \"c\"),\n            builder.count(builder.fields()).as(\"ck\"));\n        builder.as(\"ct\");\n        if (!variablesSet.isEmpty()) {\n          builder.join(JoinRelType.LEFT, trueLiteral, variablesSet);\n        } else {\n          builder.join(JoinRelType.INNER, trueLiteral, variablesSet);\n        }\n        offset += 2;\n        builder.push(e.rel);\n        \r\n      default:\n        fields.add(builder.alias(trueLiteral, \"i\"));\n        builder.project(fields);\n        builder.distinct();\n      }\n    }\n\n    builder.as(\"dt\");\n    int refOffset = offset;\n    final List<RexNode> conditions =\n        Pair.zip(expressionOperands, builder.fields()).stream()\n            .map(pair -> builder.equals(pair.left, RexUtil.shift(pair.right, refOffset)))\n            .collect(Collectors.toList());\n    switch (logic) {\n    case TRUE:\n      builder.join(JoinRelType.INNER, builder.and(conditions), variablesSet);\n      return trueLiteral;\n    default:\n      break;\n    }\n    \r\n    builder.join(JoinRelType.LEFT, builder.and(conditions), variablesSet);\n\n    final ImmutableList.Builder<RexNode> operands = ImmutableList.builder();\n    RexLiteral b = trueLiteral;\n    switch (logic) {\n    case TRUE_FALSE_UNKNOWN:\n      b = unknownLiteral;\n      \r\n    case UNKNOWN_AS_TRUE:\n      if (allLiterals) {\n        \r\n        \r\n        if (variablesSet.isEmpty()) {\n          operands.add(\n              builder.isNull(builder.field(\"c\")),\n              falseLiteral);\n        }\n        operands.add(\n            builder.equals(builder.field(\"cs\"), falseLiteral),\n            b);\n      } else {\n        operands.add(\n            builder.equals(builder.field(\"ct\", \"c\"), builder.literal(0)),\n            falseLiteral);\n      }\n      break;\n    default:\n      break;\n    }\n\n    if (!keyIsNulls.isEmpty()) {\n      operands.add(builder.or(keyIsNulls), unknownLiteral);\n    }\n\n    if (allLiterals) {\n      operands.add(builder.isNotNull(builder.field(\"cs\")),\n          trueLiteral);\n    } else {\n      operands.add(builder.isNotNull(Util.last(builder.fields())),\n          trueLiteral);\n    }\n\n    if (!allLiterals) {\n      switch (logic) {\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        operands.add(\n            builder.lessThan(builder.field(\"ct\", \"ck\"),\n                builder.field(\"ct\", \"c\")),\n            b);\n        break;\n      default:\n        break;\n      }\n    }\n    operands.add(falseLiteral);\n    return builder.call(SqlStdOperatorTable.CASE, operands.build());\n  }\n","date":"2021-09-18 03:08:56","endLine":559,"groupId":"1837","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"rewriteIn","params":"(RexSubQuerye@Set<CorrelationId>variablesSet@RelOptUtil.Logiclogic@RelBuilderbuilder@intoffset)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/1a/8add9dc6bc95a325b9c94e8f65b87684ee4b3b.src","preCode":"  private static RexNode rewriteIn(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder, int offset) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    builder.push(e.rel);\n    final List<RexNode> fields = new ArrayList<>(builder.fields());\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    boolean allLiterals = RexUtil.allLiterals(e.getOperands());\n    final List<RexNode> expressionOperands = new ArrayList<>(e.getOperands());\n\n    final List<RexNode> keyIsNulls = e.getOperands().stream()\n        .filter(operand -> operand.getType().isNullable())\n        .map(builder::isNull)\n        .collect(Collectors.toList());\n\n    final RexLiteral trueLiteral = builder.literal(true);\n    final RexLiteral falseLiteral = builder.literal(false);\n    final RexLiteral unknownLiteral =\n        builder.getRexBuilder().makeNullLiteral(trueLiteral.getType());\n    if (allLiterals) {\n      final List<RexNode> conditions =\n          Pair.zip(expressionOperands, fields).stream()\n              .map(pair -> builder.equals(pair.left, pair.right))\n              .collect(Collectors.toList());\n      switch (logic) {\n      case TRUE:\n      case TRUE_FALSE:\n        builder.filter(conditions);\n        builder.project(builder.alias(trueLiteral, \"cs\"));\n        builder.distinct();\n        break;\n      default:\n        List<RexNode> isNullOperands = fields.stream()\n            .map(builder::isNull)\n            .collect(Collectors.toList());\n        \r\n        isNullOperands.addAll(keyIsNulls);\n        builder.filter(\n            builder.or(\n                builder.and(conditions),\n                builder.or(isNullOperands)));\n        RexNode project = builder.and(\n            fields.stream()\n                .map(builder::isNotNull)\n                .collect(Collectors.toList()));\n        builder.project(builder.alias(project, \"cs\"));\n\n        if (variablesSet.isEmpty()) {\n          builder.aggregate(builder.groupKey(builder.field(\"cs\")),\n              builder.count(false, \"c\"));\n\n          \r\n          \r\n          \r\n          \r\n          builder.sortLimit(0, 1,\n              ImmutableList.of(\n                  builder.call(SqlStdOperatorTable.DESC,\n                      builder.field(\"cs\"))));\n        } else {\n          builder.distinct();\n        }\n      }\n      \r\n      \r\n      expressionOperands.clear();\n      fields.clear();\n    } else {\n      switch (logic) {\n      case TRUE:\n        builder.aggregate(builder.groupKey(fields));\n        break;\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        \r\n        builder.aggregate(builder.groupKey(),\n            builder.count(false, \"c\"),\n            builder.count(builder.fields()).as(\"ck\"));\n        builder.as(\"ct\");\n        if (!variablesSet.isEmpty()) {\n          builder.join(JoinRelType.LEFT, trueLiteral, variablesSet);\n        } else {\n          builder.join(JoinRelType.INNER, trueLiteral, variablesSet);\n        }\n        offset += 2;\n        builder.push(e.rel);\n        \r\n      default:\n        fields.add(builder.alias(trueLiteral, \"i\"));\n        builder.project(fields);\n        builder.distinct();\n      }\n    }\n\n    builder.as(\"dt\");\n    int refOffset = offset;\n    final List<RexNode> conditions =\n        Pair.zip(expressionOperands, builder.fields()).stream()\n            .map(pair -> builder.equals(pair.left, RexUtil.shift(pair.right, refOffset)))\n            .collect(Collectors.toList());\n    switch (logic) {\n    case TRUE:\n      builder.join(JoinRelType.INNER, builder.and(conditions), variablesSet);\n      return trueLiteral;\n    default:\n      break;\n    }\n    \r\n    builder.join(JoinRelType.LEFT, builder.and(conditions), variablesSet);\n\n    final ImmutableList.Builder<RexNode> operands = ImmutableList.builder();\n    RexLiteral b = trueLiteral;\n    switch (logic) {\n    case TRUE_FALSE_UNKNOWN:\n      b = unknownLiteral;\n      \r\n    case UNKNOWN_AS_TRUE:\n      if (allLiterals) {\n        \r\n        \r\n        if (variablesSet.isEmpty()) {\n          operands.add(\n              builder.isNull(builder.field(\"c\")),\n              falseLiteral);\n        }\n        operands.add(\n            builder.equals(builder.field(\"cs\"), falseLiteral),\n            b);\n      } else {\n        operands.add(\n            builder.equals(builder.field(\"ct\", \"c\"), builder.literal(0)),\n            falseLiteral);\n      }\n      break;\n    default:\n      break;\n    }\n\n    if (!keyIsNulls.isEmpty()) {\n      operands.add(builder.or(keyIsNulls), unknownLiteral);\n    }\n\n    if (allLiterals) {\n      operands.add(builder.isNotNull(builder.field(\"cs\")),\n          trueLiteral);\n    } else {\n      operands.add(builder.isNotNull(Util.last(builder.fields())),\n          trueLiteral);\n    }\n\n    if (!allLiterals) {\n      switch (logic) {\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        operands.add(\n            builder.call(SqlStdOperatorTable.LESS_THAN,\n                builder.field(\"ct\", \"ck\"), builder.field(\"ct\", \"c\")),\n            b);\n        break;\n      default:\n        break;\n      }\n    }\n    operands.add(falseLiteral);\n    return builder.call(SqlStdOperatorTable.CASE, operands.build());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":320,"status":"M"}],"commitId":"4d82c5346292b32a1301214376366c2e8c5a892e","commitMessage":"@@@Add RelBuilder.lessThan.  and use RelBuilder shorthands\n","date":"2021-09-18 03:08:56","modifiedFileCount":"9","status":"M","submitter":"Julian Hyde"},{"authorTime":"2021-07-19 14:46:42","codes":[{"authorDate":"2021-07-19 14:46:42","commitOrder":10,"curCode":"  private static RexNode rewriteExists(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder) {\n    builder.push(e.rel);\n\n    builder.project(builder.alias(builder.literal(true), \"i\"));\n    switch (logic) {\n    case TRUE:\n      \r\n      \r\n      \r\n      builder.aggregate(builder.groupKey(0));\n      builder.as(\"dt\");\n      builder.join(JoinRelType.INNER, builder.literal(true), variablesSet);\n      return builder.literal(true);\n    default:\n      builder.distinct();\n    }\n\n    builder.as(\"dt\");\n\n    builder.join(JoinRelType.LEFT, builder.literal(true), variablesSet);\n\n    return builder.isNotNull(last(builder.fields()));\n  }\n","date":"2021-09-23 00:34:28","endLine":439,"groupId":"101975","id":19,"instanceNumber":1,"isCurCommit":1,"methodName":"rewriteExists","params":"(RexSubQuerye@Set<CorrelationId>variablesSet@RelOptUtil.Logiclogic@RelBuilderbuilder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e2/49a3348551e2bf42b2040388485cf4a9179eab.src","preCode":"  private static RexNode rewriteExists(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder) {\n    builder.push(e.rel);\n\n    builder.project(builder.alias(builder.literal(true), \"i\"));\n    switch (logic) {\n    case TRUE:\n      \r\n      \r\n      \r\n      builder.aggregate(builder.groupKey(0));\n      builder.as(\"dt\");\n      builder.join(JoinRelType.INNER, builder.literal(true), variablesSet);\n      return builder.literal(true);\n    default:\n      builder.distinct();\n    }\n\n    builder.as(\"dt\");\n\n    builder.join(JoinRelType.LEFT, builder.literal(true), variablesSet);\n\n    return builder.isNotNull(Util.last(builder.fields()));\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":416,"status":"M"},{"authorDate":"2021-07-19 14:46:42","commitOrder":10,"curCode":"  private static RexNode rewriteIn(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder, int offset) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    builder.push(e.rel);\n    final List<RexNode> fields = new ArrayList<>(builder.fields());\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    boolean allLiterals = RexUtil.allLiterals(e.getOperands());\n    final List<RexNode> expressionOperands = new ArrayList<>(e.getOperands());\n\n    final List<RexNode> keyIsNulls = e.getOperands().stream()\n        .filter(operand -> operand.getType().isNullable())\n        .map(builder::isNull)\n        .collect(Collectors.toList());\n\n    final RexLiteral trueLiteral = builder.literal(true);\n    final RexLiteral falseLiteral = builder.literal(false);\n    final RexLiteral unknownLiteral =\n        builder.getRexBuilder().makeNullLiteral(trueLiteral.getType());\n    if (allLiterals) {\n      final List<RexNode> conditions =\n          Pair.zip(expressionOperands, fields).stream()\n              .map(pair -> builder.equals(pair.left, pair.right))\n              .collect(Collectors.toList());\n      switch (logic) {\n      case TRUE:\n      case TRUE_FALSE:\n        builder.filter(conditions);\n        builder.project(builder.alias(trueLiteral, \"cs\"));\n        builder.distinct();\n        break;\n      default:\n        List<RexNode> isNullOperands = fields.stream()\n            .map(builder::isNull)\n            .collect(Collectors.toList());\n        \r\n        isNullOperands.addAll(keyIsNulls);\n        builder.filter(\n            builder.or(\n                builder.and(conditions),\n                builder.or(isNullOperands)));\n        RexNode project = builder.and(\n            fields.stream()\n                .map(builder::isNotNull)\n                .collect(Collectors.toList()));\n        builder.project(builder.alias(project, \"cs\"));\n\n        if (variablesSet.isEmpty()) {\n          builder.aggregate(builder.groupKey(builder.field(\"cs\")),\n              builder.count(false, \"c\"));\n\n          \r\n          \r\n          \r\n          \r\n          builder.sortLimit(0, 1,\n              ImmutableList.of(builder.desc(builder.field(\"cs\"))));\n        } else {\n          builder.distinct();\n        }\n      }\n      \r\n      \r\n      expressionOperands.clear();\n      fields.clear();\n    } else {\n      switch (logic) {\n      case TRUE:\n        builder.aggregate(builder.groupKey(fields));\n        break;\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        \r\n        builder.aggregate(builder.groupKey(),\n            builder.count(false, \"c\"),\n            builder.count(builder.fields()).as(\"ck\"));\n        builder.as(\"ct\");\n        if (!variablesSet.isEmpty()) {\n          builder.join(JoinRelType.LEFT, trueLiteral, variablesSet);\n        } else {\n          builder.join(JoinRelType.INNER, trueLiteral, variablesSet);\n        }\n        offset += 2;\n        builder.push(e.rel);\n        \r\n      default:\n        fields.add(builder.alias(trueLiteral, \"i\"));\n        builder.project(fields);\n        builder.distinct();\n      }\n    }\n\n    builder.as(\"dt\");\n    int refOffset = offset;\n    final List<RexNode> conditions =\n        Pair.zip(expressionOperands, builder.fields()).stream()\n            .map(pair -> builder.equals(pair.left, RexUtil.shift(pair.right, refOffset)))\n            .collect(Collectors.toList());\n    switch (logic) {\n    case TRUE:\n      builder.join(JoinRelType.INNER, builder.and(conditions), variablesSet);\n      return trueLiteral;\n    default:\n      break;\n    }\n    \r\n    builder.join(JoinRelType.LEFT, builder.and(conditions), variablesSet);\n\n    final ImmutableList.Builder<RexNode> operands = ImmutableList.builder();\n    RexLiteral b = trueLiteral;\n    switch (logic) {\n    case TRUE_FALSE_UNKNOWN:\n      b = unknownLiteral;\n      \r\n    case UNKNOWN_AS_TRUE:\n      if (allLiterals) {\n        \r\n        \r\n        if (variablesSet.isEmpty()) {\n          operands.add(\n              builder.isNull(builder.field(\"c\")),\n              falseLiteral);\n        }\n        operands.add(\n            builder.equals(builder.field(\"cs\"), falseLiteral),\n            b);\n      } else {\n        operands.add(\n            builder.equals(builder.field(\"ct\", \"c\"), builder.literal(0)),\n            falseLiteral);\n      }\n      break;\n    default:\n      break;\n    }\n\n    if (!keyIsNulls.isEmpty()) {\n      operands.add(builder.or(keyIsNulls), unknownLiteral);\n    }\n\n    if (allLiterals) {\n      operands.add(builder.isNotNull(builder.field(\"cs\")),\n          trueLiteral);\n    } else {\n      operands.add(builder.isNotNull(last(builder.fields())),\n          trueLiteral);\n    }\n\n    if (!allLiterals) {\n      switch (logic) {\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        operands.add(\n            builder.lessThan(builder.field(\"ct\", \"ck\"),\n                builder.field(\"ct\", \"c\")),\n            b);\n        break;\n      default:\n        break;\n      }\n    }\n    operands.add(falseLiteral);\n    return builder.call(SqlStdOperatorTable.CASE, operands.build());\n  }\n","date":"2021-09-23 00:34:28","endLine":744,"groupId":"101975","id":20,"instanceNumber":2,"isCurCommit":1,"methodName":"rewriteIn","params":"(RexSubQuerye@Set<CorrelationId>variablesSet@RelOptUtil.Logiclogic@RelBuilderbuilder@intoffset)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e2/49a3348551e2bf42b2040388485cf4a9179eab.src","preCode":"  private static RexNode rewriteIn(RexSubQuery e, Set<CorrelationId> variablesSet,\n      RelOptUtil.Logic logic, RelBuilder builder, int offset) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    builder.push(e.rel);\n    final List<RexNode> fields = new ArrayList<>(builder.fields());\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\n    boolean allLiterals = RexUtil.allLiterals(e.getOperands());\n    final List<RexNode> expressionOperands = new ArrayList<>(e.getOperands());\n\n    final List<RexNode> keyIsNulls = e.getOperands().stream()\n        .filter(operand -> operand.getType().isNullable())\n        .map(builder::isNull)\n        .collect(Collectors.toList());\n\n    final RexLiteral trueLiteral = builder.literal(true);\n    final RexLiteral falseLiteral = builder.literal(false);\n    final RexLiteral unknownLiteral =\n        builder.getRexBuilder().makeNullLiteral(trueLiteral.getType());\n    if (allLiterals) {\n      final List<RexNode> conditions =\n          Pair.zip(expressionOperands, fields).stream()\n              .map(pair -> builder.equals(pair.left, pair.right))\n              .collect(Collectors.toList());\n      switch (logic) {\n      case TRUE:\n      case TRUE_FALSE:\n        builder.filter(conditions);\n        builder.project(builder.alias(trueLiteral, \"cs\"));\n        builder.distinct();\n        break;\n      default:\n        List<RexNode> isNullOperands = fields.stream()\n            .map(builder::isNull)\n            .collect(Collectors.toList());\n        \r\n        isNullOperands.addAll(keyIsNulls);\n        builder.filter(\n            builder.or(\n                builder.and(conditions),\n                builder.or(isNullOperands)));\n        RexNode project = builder.and(\n            fields.stream()\n                .map(builder::isNotNull)\n                .collect(Collectors.toList()));\n        builder.project(builder.alias(project, \"cs\"));\n\n        if (variablesSet.isEmpty()) {\n          builder.aggregate(builder.groupKey(builder.field(\"cs\")),\n              builder.count(false, \"c\"));\n\n          \r\n          \r\n          \r\n          \r\n          builder.sortLimit(0, 1,\n              ImmutableList.of(builder.desc(builder.field(\"cs\"))));\n        } else {\n          builder.distinct();\n        }\n      }\n      \r\n      \r\n      expressionOperands.clear();\n      fields.clear();\n    } else {\n      switch (logic) {\n      case TRUE:\n        builder.aggregate(builder.groupKey(fields));\n        break;\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        \r\n        builder.aggregate(builder.groupKey(),\n            builder.count(false, \"c\"),\n            builder.count(builder.fields()).as(\"ck\"));\n        builder.as(\"ct\");\n        if (!variablesSet.isEmpty()) {\n          builder.join(JoinRelType.LEFT, trueLiteral, variablesSet);\n        } else {\n          builder.join(JoinRelType.INNER, trueLiteral, variablesSet);\n        }\n        offset += 2;\n        builder.push(e.rel);\n        \r\n      default:\n        fields.add(builder.alias(trueLiteral, \"i\"));\n        builder.project(fields);\n        builder.distinct();\n      }\n    }\n\n    builder.as(\"dt\");\n    int refOffset = offset;\n    final List<RexNode> conditions =\n        Pair.zip(expressionOperands, builder.fields()).stream()\n            .map(pair -> builder.equals(pair.left, RexUtil.shift(pair.right, refOffset)))\n            .collect(Collectors.toList());\n    switch (logic) {\n    case TRUE:\n      builder.join(JoinRelType.INNER, builder.and(conditions), variablesSet);\n      return trueLiteral;\n    default:\n      break;\n    }\n    \r\n    builder.join(JoinRelType.LEFT, builder.and(conditions), variablesSet);\n\n    final ImmutableList.Builder<RexNode> operands = ImmutableList.builder();\n    RexLiteral b = trueLiteral;\n    switch (logic) {\n    case TRUE_FALSE_UNKNOWN:\n      b = unknownLiteral;\n      \r\n    case UNKNOWN_AS_TRUE:\n      if (allLiterals) {\n        \r\n        \r\n        if (variablesSet.isEmpty()) {\n          operands.add(\n              builder.isNull(builder.field(\"c\")),\n              falseLiteral);\n        }\n        operands.add(\n            builder.equals(builder.field(\"cs\"), falseLiteral),\n            b);\n      } else {\n        operands.add(\n            builder.equals(builder.field(\"ct\", \"c\"), builder.literal(0)),\n            falseLiteral);\n      }\n      break;\n    default:\n      break;\n    }\n\n    if (!keyIsNulls.isEmpty()) {\n      operands.add(builder.or(keyIsNulls), unknownLiteral);\n    }\n\n    if (allLiterals) {\n      operands.add(builder.isNotNull(builder.field(\"cs\")),\n          trueLiteral);\n    } else {\n      operands.add(builder.isNotNull(Util.last(builder.fields())),\n          trueLiteral);\n    }\n\n    if (!allLiterals) {\n      switch (logic) {\n      case TRUE_FALSE_UNKNOWN:\n      case UNKNOWN_AS_TRUE:\n        operands.add(\n            builder.lessThan(builder.field(\"ct\", \"ck\"),\n                builder.field(\"ct\", \"c\")),\n            b);\n        break;\n      default:\n        break;\n      }\n    }\n    operands.add(falseLiteral);\n    return builder.call(SqlStdOperatorTable.CASE, operands.build());\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":505,"status":"M"}],"commitId":"d66f4c50737ad3a95a89f49712fc3ff69a1413ee","commitMessage":"@@@[CALCITE-4486] UNIQUE sub-query (NobiGo)\n\nRewrite UNIQUE to EXISTS.\n\nClose apache/calcite#2495\n","date":"2021-09-23 00:34:28","modifiedFileCount":"11","status":"M","submitter":"NobiGo"}]
