[{"authorTime":"2019-08-21 20:49:48","codes":[{"authorDate":"2019-08-21 20:49:48","commitOrder":1,"curCode":"  private static <TSource, TInner, TKey, TResult> Enumerable<TResult> hashEquiJoin_(\n      final Enumerable<TSource> outer, final Enumerable<TInner> inner,\n      final Function1<TSource, TKey> outerKeySelector,\n      final Function1<TInner, TKey> innerKeySelector,\n      final Function2<TSource, TInner, TResult> resultSelector,\n      final EqualityComparer<TKey> comparer, final boolean generateNullsOnLeft,\n      final boolean generateNullsOnRight) {\n    return new AbstractEnumerable<TResult>() {\n      public Enumerator<TResult> enumerator() {\n        final Lookup<TKey, TInner> innerLookup =\n            comparer == null\n                ? inner.toLookup(innerKeySelector)\n                : inner.toLookup(innerKeySelector, comparer);\n\n        return new Enumerator<TResult>() {\n          Enumerator<TSource> outers = outer.enumerator();\n          Enumerator<TInner> inners = Linq4j.emptyEnumerator();\n          Set<TKey> unmatchedKeys =\n              generateNullsOnLeft\n                  ? new HashSet<>(innerLookup.keySet())\n                  : null;\n\n          public TResult current() {\n            return resultSelector.apply(outers.current(), inners.current());\n          }\n\n          public boolean moveNext() {\n            for (;;) {\n              if (inners.moveNext()) {\n                return true;\n              }\n              if (!outers.moveNext()) {\n                if (unmatchedKeys != null) {\n                  \r\n                  \r\n                  \r\n                  List<TInner> list = new ArrayList<>();\n                  for (TKey key : unmatchedKeys) {\n                    for (TInner tInner : innerLookup.get(key)) {\n                      list.add(tInner);\n                    }\n                  }\n                  inners = Linq4j.enumerator(list);\n                  outers.close();\n                  outers = Linq4j.singletonNullEnumerator();\n                  outers.moveNext();\n                  unmatchedKeys = null; \r\n                  continue;\n                }\n                return false;\n              }\n              final TSource outer = outers.current();\n              final Enumerable<TInner> innerEnumerable;\n              if (outer == null) {\n                innerEnumerable = null;\n              } else {\n                final TKey outerKey = outerKeySelector.apply(outer);\n                if (outerKey == null) {\n                  innerEnumerable = null;\n                } else {\n                  if (unmatchedKeys != null) {\n                    unmatchedKeys.remove(outerKey);\n                  }\n                  innerEnumerable = innerLookup.get(outerKey);\n                }\n              }\n              if (innerEnumerable == null\n                  || !innerEnumerable.any()) {\n                if (generateNullsOnRight) {\n                  inners = Linq4j.singletonNullEnumerator();\n                } else {\n                  inners = Linq4j.emptyEnumerator();\n                }\n              } else {\n                inners = innerEnumerable.enumerator();\n              }\n            }\n          }\n\n          public void reset() {\n            outers.reset();\n          }\n\n          public void close() {\n            outers.close();\n          }\n        };\n      }\n    };\n  }\n","date":"2019-08-30 14:54:12","endLine":1187,"groupId":"16536","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"hashEquiJoin_","params":"(finalEnumerable<TSource>outer@finalEnumerable<TInner>inner@finalFunction1<TSource@TKey>outerKeySelector@finalFunction1<TInner@TKey>innerKeySelector@finalFunction2<TSource@TInner@TResult>resultSelector@finalEqualityComparer<TKey>comparer@finalbooleangenerateNullsOnLeft@finalbooleangenerateNullsOnRight)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/f8/2fe9e58b6d4f1dc8fbb796aab0fba7057d7a3b.src","preCode":"  private static <TSource, TInner, TKey, TResult> Enumerable<TResult> hashEquiJoin_(\n      final Enumerable<TSource> outer, final Enumerable<TInner> inner,\n      final Function1<TSource, TKey> outerKeySelector,\n      final Function1<TInner, TKey> innerKeySelector,\n      final Function2<TSource, TInner, TResult> resultSelector,\n      final EqualityComparer<TKey> comparer, final boolean generateNullsOnLeft,\n      final boolean generateNullsOnRight) {\n    return new AbstractEnumerable<TResult>() {\n      public Enumerator<TResult> enumerator() {\n        final Lookup<TKey, TInner> innerLookup =\n            comparer == null\n                ? inner.toLookup(innerKeySelector)\n                : inner.toLookup(innerKeySelector, comparer);\n\n        return new Enumerator<TResult>() {\n          Enumerator<TSource> outers = outer.enumerator();\n          Enumerator<TInner> inners = Linq4j.emptyEnumerator();\n          Set<TKey> unmatchedKeys =\n              generateNullsOnLeft\n                  ? new HashSet<>(innerLookup.keySet())\n                  : null;\n\n          public TResult current() {\n            return resultSelector.apply(outers.current(), inners.current());\n          }\n\n          public boolean moveNext() {\n            for (;;) {\n              if (inners.moveNext()) {\n                return true;\n              }\n              if (!outers.moveNext()) {\n                if (unmatchedKeys != null) {\n                  \r\n                  \r\n                  \r\n                  List<TInner> list = new ArrayList<>();\n                  for (TKey key : unmatchedKeys) {\n                    for (TInner tInner : innerLookup.get(key)) {\n                      list.add(tInner);\n                    }\n                  }\n                  inners = Linq4j.enumerator(list);\n                  outers.close();\n                  outers = Linq4j.singletonNullEnumerator();\n                  outers.moveNext();\n                  unmatchedKeys = null; \r\n                  continue;\n                }\n                return false;\n              }\n              final TSource outer = outers.current();\n              final Enumerable<TInner> innerEnumerable;\n              if (outer == null) {\n                innerEnumerable = null;\n              } else {\n                final TKey outerKey = outerKeySelector.apply(outer);\n                if (outerKey == null) {\n                  innerEnumerable = null;\n                } else {\n                  if (unmatchedKeys != null) {\n                    unmatchedKeys.remove(outerKey);\n                  }\n                  innerEnumerable = innerLookup.get(outerKey);\n                }\n              }\n              if (innerEnumerable == null\n                  || !innerEnumerable.any()) {\n                if (generateNullsOnRight) {\n                  inners = Linq4j.singletonNullEnumerator();\n                } else {\n                  inners = Linq4j.emptyEnumerator();\n                }\n              } else {\n                inners = innerEnumerable.enumerator();\n              }\n            }\n          }\n\n          public void reset() {\n            outers.reset();\n          }\n\n          public void close() {\n            outers.close();\n          }\n        };\n      }\n    };\n  }\n","realPath":"linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1098,"status":"B"},{"authorDate":"2019-08-21 20:49:48","commitOrder":1,"curCode":"  private static <TSource, TInner, TKey, TResult> Enumerable<TResult> hashJoinWithPredicate_(\n      final Enumerable<TSource> outer, final Enumerable<TInner> inner,\n      final Function1<TSource, TKey> outerKeySelector,\n      final Function1<TInner, TKey> innerKeySelector,\n      final Function2<TSource, TInner, TResult> resultSelector,\n      final EqualityComparer<TKey> comparer, final boolean generateNullsOnLeft,\n      final boolean generateNullsOnRight, final Predicate2<TSource, TInner> predicate) {\n\n    return new AbstractEnumerable<TResult>() {\n      public Enumerator<TResult> enumerator() {\n        \r\n\r\n\r\n\n        final Enumerable<TInner> innerToLookUp = generateNullsOnLeft\n            ? Linq4j.asEnumerable(inner.toList())\n            : inner;\n\n        final Lookup<TKey, TInner> innerLookup =\n            comparer == null\n                ? innerToLookUp.toLookup(innerKeySelector)\n                : innerToLookUp\n                    .toLookup(innerKeySelector, comparer);\n\n        return new Enumerator<TResult>() {\n          Enumerator<TSource> outers = outer.enumerator();\n          Enumerator<TInner> inners = Linq4j.emptyEnumerator();\n          List<TInner> innersUnmatched =\n              generateNullsOnLeft\n                  ? new ArrayList<>(innerToLookUp.toList())\n                  : null;\n\n          public TResult current() {\n            return resultSelector.apply(outers.current(), inners.current());\n          }\n\n          public boolean moveNext() {\n            for (;;) {\n              if (inners.moveNext()) {\n                return true;\n              }\n              if (!outers.moveNext()) {\n                if (innersUnmatched != null) {\n                  inners = Linq4j.enumerator(innersUnmatched);\n                  outers.close();\n                  outers = Linq4j.singletonNullEnumerator();\n                  outers.moveNext();\n                  innersUnmatched = null; \r\n                  continue;\n                }\n                return false;\n              }\n              final TSource outer = outers.current();\n              Enumerable<TInner> innerEnumerable;\n              if (outer == null) {\n                innerEnumerable = null;\n              } else {\n                final TKey outerKey = outerKeySelector.apply(outer);\n                if (outerKey == null) {\n                  innerEnumerable = null;\n                } else {\n                  innerEnumerable = innerLookup.get(outerKey);\n                  \r\n                  if (innerEnumerable != null) {\n                    final List<TInner> matchedInners = new ArrayList<>();\n                    try (Enumerator<TInner> innerEnumerator =\n                        innerEnumerable.enumerator()) {\n                      while (innerEnumerator.moveNext()) {\n                        final TInner inner = innerEnumerator.current();\n                        if (predicate.apply(outer, inner)) {\n                          matchedInners.add(inner);\n                        }\n                      }\n                    }\n                    innerEnumerable = Linq4j.asEnumerable(matchedInners);\n                    if (innersUnmatched != null) {\n                      innersUnmatched.removeAll(matchedInners);\n                    }\n                  }\n                }\n              }\n              if (innerEnumerable == null\n                  || !innerEnumerable.any()) {\n                if (generateNullsOnRight) {\n                  inners = Linq4j.singletonNullEnumerator();\n                } else {\n                  inners = Linq4j.emptyEnumerator();\n                }\n              } else {\n                inners = innerEnumerable.enumerator();\n              }\n            }\n          }\n\n          public void reset() {\n            outers.reset();\n          }\n\n          public void close() {\n            outers.close();\n          }\n        };\n      }\n    };\n  }\n","date":"2019-08-30 14:54:12","endLine":1296,"groupId":"3353","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"hashJoinWithPredicate_","params":"(finalEnumerable<TSource>outer@finalEnumerable<TInner>inner@finalFunction1<TSource@TKey>outerKeySelector@finalFunction1<TInner@TKey>innerKeySelector@finalFunction2<TSource@TInner@TResult>resultSelector@finalEqualityComparer<TKey>comparer@finalbooleangenerateNullsOnLeft@finalbooleangenerateNullsOnRight@finalPredicate2<TSource@TInner>predicate)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/f8/2fe9e58b6d4f1dc8fbb796aab0fba7057d7a3b.src","preCode":"  private static <TSource, TInner, TKey, TResult> Enumerable<TResult> hashJoinWithPredicate_(\n      final Enumerable<TSource> outer, final Enumerable<TInner> inner,\n      final Function1<TSource, TKey> outerKeySelector,\n      final Function1<TInner, TKey> innerKeySelector,\n      final Function2<TSource, TInner, TResult> resultSelector,\n      final EqualityComparer<TKey> comparer, final boolean generateNullsOnLeft,\n      final boolean generateNullsOnRight, final Predicate2<TSource, TInner> predicate) {\n\n    return new AbstractEnumerable<TResult>() {\n      public Enumerator<TResult> enumerator() {\n        \r\n\r\n\r\n\n        final Enumerable<TInner> innerToLookUp = generateNullsOnLeft\n            ? Linq4j.asEnumerable(inner.toList())\n            : inner;\n\n        final Lookup<TKey, TInner> innerLookup =\n            comparer == null\n                ? innerToLookUp.toLookup(innerKeySelector)\n                : innerToLookUp\n                    .toLookup(innerKeySelector, comparer);\n\n        return new Enumerator<TResult>() {\n          Enumerator<TSource> outers = outer.enumerator();\n          Enumerator<TInner> inners = Linq4j.emptyEnumerator();\n          List<TInner> innersUnmatched =\n              generateNullsOnLeft\n                  ? new ArrayList<>(innerToLookUp.toList())\n                  : null;\n\n          public TResult current() {\n            return resultSelector.apply(outers.current(), inners.current());\n          }\n\n          public boolean moveNext() {\n            for (;;) {\n              if (inners.moveNext()) {\n                return true;\n              }\n              if (!outers.moveNext()) {\n                if (innersUnmatched != null) {\n                  inners = Linq4j.enumerator(innersUnmatched);\n                  outers.close();\n                  outers = Linq4j.singletonNullEnumerator();\n                  outers.moveNext();\n                  innersUnmatched = null; \r\n                  continue;\n                }\n                return false;\n              }\n              final TSource outer = outers.current();\n              Enumerable<TInner> innerEnumerable;\n              if (outer == null) {\n                innerEnumerable = null;\n              } else {\n                final TKey outerKey = outerKeySelector.apply(outer);\n                if (outerKey == null) {\n                  innerEnumerable = null;\n                } else {\n                  innerEnumerable = innerLookup.get(outerKey);\n                  \r\n                  if (innerEnumerable != null) {\n                    final List<TInner> matchedInners = new ArrayList<>();\n                    try (Enumerator<TInner> innerEnumerator =\n                        innerEnumerable.enumerator()) {\n                      while (innerEnumerator.moveNext()) {\n                        final TInner inner = innerEnumerator.current();\n                        if (predicate.apply(outer, inner)) {\n                          matchedInners.add(inner);\n                        }\n                      }\n                    }\n                    innerEnumerable = Linq4j.asEnumerable(matchedInners);\n                    if (innersUnmatched != null) {\n                      innersUnmatched.removeAll(matchedInners);\n                    }\n                  }\n                }\n              }\n              if (innerEnumerable == null\n                  || !innerEnumerable.any()) {\n                if (generateNullsOnRight) {\n                  inners = Linq4j.singletonNullEnumerator();\n                } else {\n                  inners = Linq4j.emptyEnumerator();\n                }\n              } else {\n                inners = innerEnumerable.enumerator();\n              }\n            }\n          }\n\n          public void reset() {\n            outers.reset();\n          }\n\n          public void close() {\n            outers.close();\n          }\n        };\n      }\n    };\n  }\n","realPath":"linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1191,"status":"B"}],"commitId":"6cec81178e6739d9b1f3474dc5dbd7488dda2464","commitMessage":"@@@[CALCITE-2973]. [CALCITE-3284] Allow joins(hash. semi. anti) that have equi conditions to be executed using a hash join algorithm\n","date":"2019-08-30 14:54:12","modifiedFileCount":"7","status":"B","submitter":"Lai Zhou"},{"authorTime":"2020-09-29 22:09:05","codes":[{"authorDate":"2020-09-29 22:09:05","commitOrder":2,"curCode":"  private static <TSource, TInner, TKey, TResult> Enumerable<TResult> hashEquiJoin_(\n      final Enumerable<TSource> outer, final Enumerable<TInner> inner,\n      final Function1<TSource, TKey> outerKeySelector,\n      final Function1<TInner, TKey> innerKeySelector,\n      final Function2<TSource, TInner, TResult> resultSelector,\n      final EqualityComparer<TKey> comparer, final boolean generateNullsOnLeft,\n      final boolean generateNullsOnRight) {\n    return new AbstractEnumerable<TResult>() {\n      @Override public Enumerator<TResult> enumerator() {\n        final Lookup<TKey, TInner> innerLookup =\n            comparer == null\n                ? inner.toLookup(innerKeySelector)\n                : inner.toLookup(innerKeySelector, comparer);\n\n        return new Enumerator<TResult>() {\n          Enumerator<TSource> outers = outer.enumerator();\n          Enumerator<TInner> inners = Linq4j.emptyEnumerator();\n          Set<TKey> unmatchedKeys =\n              generateNullsOnLeft\n                  ? new HashSet<>(innerLookup.keySet())\n                  : null;\n\n          @Override public TResult current() {\n            return resultSelector.apply(outers.current(), inners.current());\n          }\n\n          @Override public boolean moveNext() {\n            for (;;) {\n              if (inners.moveNext()) {\n                return true;\n              }\n              if (!outers.moveNext()) {\n                if (unmatchedKeys != null) {\n                  \r\n                  \r\n                  \r\n                  List<TInner> list = new ArrayList<>();\n                  for (TKey key : unmatchedKeys) {\n                    for (TInner tInner : innerLookup.get(key)) {\n                      list.add(tInner);\n                    }\n                  }\n                  inners = Linq4j.enumerator(list);\n                  outers.close();\n                  outers = Linq4j.singletonNullEnumerator();\n                  outers.moveNext();\n                  unmatchedKeys = null; \r\n                  continue;\n                }\n                return false;\n              }\n              final TSource outer = outers.current();\n              final Enumerable<TInner> innerEnumerable;\n              if (outer == null) {\n                innerEnumerable = null;\n              } else {\n                final TKey outerKey = outerKeySelector.apply(outer);\n                if (outerKey == null) {\n                  innerEnumerable = null;\n                } else {\n                  if (unmatchedKeys != null) {\n                    unmatchedKeys.remove(outerKey);\n                  }\n                  innerEnumerable = innerLookup.get(outerKey);\n                }\n              }\n              if (innerEnumerable == null\n                  || !innerEnumerable.any()) {\n                if (generateNullsOnRight) {\n                  inners = Linq4j.singletonNullEnumerator();\n                } else {\n                  inners = Linq4j.emptyEnumerator();\n                }\n              } else {\n                inners = innerEnumerable.enumerator();\n              }\n            }\n          }\n\n          @Override public void reset() {\n            outers.reset();\n          }\n\n          @Override public void close() {\n            outers.close();\n          }\n        };\n      }\n    };\n  }\n","date":"2020-10-07 05:42:47","endLine":1368,"groupId":"16536","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"hashEquiJoin_","params":"(finalEnumerable<TSource>outer@finalEnumerable<TInner>inner@finalFunction1<TSource@TKey>outerKeySelector@finalFunction1<TInner@TKey>innerKeySelector@finalFunction2<TSource@TInner@TResult>resultSelector@finalEqualityComparer<TKey>comparer@finalbooleangenerateNullsOnLeft@finalbooleangenerateNullsOnRight)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/5f/4d484dbd63f86d5449292ce78f1f05dc972925.src","preCode":"  private static <TSource, TInner, TKey, TResult> Enumerable<TResult> hashEquiJoin_(\n      final Enumerable<TSource> outer, final Enumerable<TInner> inner,\n      final Function1<TSource, TKey> outerKeySelector,\n      final Function1<TInner, TKey> innerKeySelector,\n      final Function2<TSource, TInner, TResult> resultSelector,\n      final EqualityComparer<TKey> comparer, final boolean generateNullsOnLeft,\n      final boolean generateNullsOnRight) {\n    return new AbstractEnumerable<TResult>() {\n      public Enumerator<TResult> enumerator() {\n        final Lookup<TKey, TInner> innerLookup =\n            comparer == null\n                ? inner.toLookup(innerKeySelector)\n                : inner.toLookup(innerKeySelector, comparer);\n\n        return new Enumerator<TResult>() {\n          Enumerator<TSource> outers = outer.enumerator();\n          Enumerator<TInner> inners = Linq4j.emptyEnumerator();\n          Set<TKey> unmatchedKeys =\n              generateNullsOnLeft\n                  ? new HashSet<>(innerLookup.keySet())\n                  : null;\n\n          public TResult current() {\n            return resultSelector.apply(outers.current(), inners.current());\n          }\n\n          public boolean moveNext() {\n            for (;;) {\n              if (inners.moveNext()) {\n                return true;\n              }\n              if (!outers.moveNext()) {\n                if (unmatchedKeys != null) {\n                  \r\n                  \r\n                  \r\n                  List<TInner> list = new ArrayList<>();\n                  for (TKey key : unmatchedKeys) {\n                    for (TInner tInner : innerLookup.get(key)) {\n                      list.add(tInner);\n                    }\n                  }\n                  inners = Linq4j.enumerator(list);\n                  outers.close();\n                  outers = Linq4j.singletonNullEnumerator();\n                  outers.moveNext();\n                  unmatchedKeys = null; \r\n                  continue;\n                }\n                return false;\n              }\n              final TSource outer = outers.current();\n              final Enumerable<TInner> innerEnumerable;\n              if (outer == null) {\n                innerEnumerable = null;\n              } else {\n                final TKey outerKey = outerKeySelector.apply(outer);\n                if (outerKey == null) {\n                  innerEnumerable = null;\n                } else {\n                  if (unmatchedKeys != null) {\n                    unmatchedKeys.remove(outerKey);\n                  }\n                  innerEnumerable = innerLookup.get(outerKey);\n                }\n              }\n              if (innerEnumerable == null\n                  || !innerEnumerable.any()) {\n                if (generateNullsOnRight) {\n                  inners = Linq4j.singletonNullEnumerator();\n                } else {\n                  inners = Linq4j.emptyEnumerator();\n                }\n              } else {\n                inners = innerEnumerable.enumerator();\n              }\n            }\n          }\n\n          public void reset() {\n            outers.reset();\n          }\n\n          public void close() {\n            outers.close();\n          }\n        };\n      }\n    };\n  }\n","realPath":"linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1279,"status":"M"},{"authorDate":"2020-09-29 22:09:05","commitOrder":2,"curCode":"  private static <TSource, TInner, TKey, TResult> Enumerable<TResult> hashJoinWithPredicate_(\n      final Enumerable<TSource> outer, final Enumerable<TInner> inner,\n      final Function1<TSource, TKey> outerKeySelector,\n      final Function1<TInner, TKey> innerKeySelector,\n      final Function2<TSource, TInner, TResult> resultSelector,\n      final EqualityComparer<TKey> comparer, final boolean generateNullsOnLeft,\n      final boolean generateNullsOnRight, final Predicate2<TSource, TInner> predicate) {\n\n    return new AbstractEnumerable<TResult>() {\n      @Override public Enumerator<TResult> enumerator() {\n        \r\n\r\n\r\n\n        final Enumerable<TInner> innerToLookUp = generateNullsOnLeft\n            ? Linq4j.asEnumerable(inner.toList())\n            : inner;\n\n        final Lookup<TKey, TInner> innerLookup =\n            comparer == null\n                ? innerToLookUp.toLookup(innerKeySelector)\n                : innerToLookUp\n                    .toLookup(innerKeySelector, comparer);\n\n        return new Enumerator<TResult>() {\n          Enumerator<TSource> outers = outer.enumerator();\n          Enumerator<TInner> inners = Linq4j.emptyEnumerator();\n          List<TInner> innersUnmatched =\n              generateNullsOnLeft\n                  ? new ArrayList<>(innerToLookUp.toList())\n                  : null;\n\n          @Override public TResult current() {\n            return resultSelector.apply(outers.current(), inners.current());\n          }\n\n          @Override public boolean moveNext() {\n            for (;;) {\n              if (inners.moveNext()) {\n                return true;\n              }\n              if (!outers.moveNext()) {\n                if (innersUnmatched != null) {\n                  inners = Linq4j.enumerator(innersUnmatched);\n                  outers.close();\n                  outers = Linq4j.singletonNullEnumerator();\n                  outers.moveNext();\n                  innersUnmatched = null; \r\n                  continue;\n                }\n                return false;\n              }\n              final TSource outer = outers.current();\n              Enumerable<TInner> innerEnumerable;\n              if (outer == null) {\n                innerEnumerable = null;\n              } else {\n                final TKey outerKey = outerKeySelector.apply(outer);\n                if (outerKey == null) {\n                  innerEnumerable = null;\n                } else {\n                  innerEnumerable = innerLookup.get(outerKey);\n                  \r\n                  if (innerEnumerable != null) {\n                    final List<TInner> matchedInners = new ArrayList<>();\n                    try (Enumerator<TInner> innerEnumerator =\n                        innerEnumerable.enumerator()) {\n                      while (innerEnumerator.moveNext()) {\n                        final TInner inner = innerEnumerator.current();\n                        if (predicate.apply(outer, inner)) {\n                          matchedInners.add(inner);\n                        }\n                      }\n                    }\n                    innerEnumerable = Linq4j.asEnumerable(matchedInners);\n                    if (innersUnmatched != null) {\n                      innersUnmatched.removeAll(matchedInners);\n                    }\n                  }\n                }\n              }\n              if (innerEnumerable == null\n                  || !innerEnumerable.any()) {\n                if (generateNullsOnRight) {\n                  inners = Linq4j.singletonNullEnumerator();\n                } else {\n                  inners = Linq4j.emptyEnumerator();\n                }\n              } else {\n                inners = innerEnumerable.enumerator();\n              }\n            }\n          }\n\n          @Override public void reset() {\n            outers.reset();\n          }\n\n          @Override public void close() {\n            outers.close();\n          }\n        };\n      }\n    };\n  }\n","date":"2020-10-07 05:42:47","endLine":1477,"groupId":"3353","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"hashJoinWithPredicate_","params":"(finalEnumerable<TSource>outer@finalEnumerable<TInner>inner@finalFunction1<TSource@TKey>outerKeySelector@finalFunction1<TInner@TKey>innerKeySelector@finalFunction2<TSource@TInner@TResult>resultSelector@finalEqualityComparer<TKey>comparer@finalbooleangenerateNullsOnLeft@finalbooleangenerateNullsOnRight@finalPredicate2<TSource@TInner>predicate)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/5f/4d484dbd63f86d5449292ce78f1f05dc972925.src","preCode":"  private static <TSource, TInner, TKey, TResult> Enumerable<TResult> hashJoinWithPredicate_(\n      final Enumerable<TSource> outer, final Enumerable<TInner> inner,\n      final Function1<TSource, TKey> outerKeySelector,\n      final Function1<TInner, TKey> innerKeySelector,\n      final Function2<TSource, TInner, TResult> resultSelector,\n      final EqualityComparer<TKey> comparer, final boolean generateNullsOnLeft,\n      final boolean generateNullsOnRight, final Predicate2<TSource, TInner> predicate) {\n\n    return new AbstractEnumerable<TResult>() {\n      public Enumerator<TResult> enumerator() {\n        \r\n\r\n\r\n\n        final Enumerable<TInner> innerToLookUp = generateNullsOnLeft\n            ? Linq4j.asEnumerable(inner.toList())\n            : inner;\n\n        final Lookup<TKey, TInner> innerLookup =\n            comparer == null\n                ? innerToLookUp.toLookup(innerKeySelector)\n                : innerToLookUp\n                    .toLookup(innerKeySelector, comparer);\n\n        return new Enumerator<TResult>() {\n          Enumerator<TSource> outers = outer.enumerator();\n          Enumerator<TInner> inners = Linq4j.emptyEnumerator();\n          List<TInner> innersUnmatched =\n              generateNullsOnLeft\n                  ? new ArrayList<>(innerToLookUp.toList())\n                  : null;\n\n          public TResult current() {\n            return resultSelector.apply(outers.current(), inners.current());\n          }\n\n          public boolean moveNext() {\n            for (;;) {\n              if (inners.moveNext()) {\n                return true;\n              }\n              if (!outers.moveNext()) {\n                if (innersUnmatched != null) {\n                  inners = Linq4j.enumerator(innersUnmatched);\n                  outers.close();\n                  outers = Linq4j.singletonNullEnumerator();\n                  outers.moveNext();\n                  innersUnmatched = null; \r\n                  continue;\n                }\n                return false;\n              }\n              final TSource outer = outers.current();\n              Enumerable<TInner> innerEnumerable;\n              if (outer == null) {\n                innerEnumerable = null;\n              } else {\n                final TKey outerKey = outerKeySelector.apply(outer);\n                if (outerKey == null) {\n                  innerEnumerable = null;\n                } else {\n                  innerEnumerable = innerLookup.get(outerKey);\n                  \r\n                  if (innerEnumerable != null) {\n                    final List<TInner> matchedInners = new ArrayList<>();\n                    try (Enumerator<TInner> innerEnumerator =\n                        innerEnumerable.enumerator()) {\n                      while (innerEnumerator.moveNext()) {\n                        final TInner inner = innerEnumerator.current();\n                        if (predicate.apply(outer, inner)) {\n                          matchedInners.add(inner);\n                        }\n                      }\n                    }\n                    innerEnumerable = Linq4j.asEnumerable(matchedInners);\n                    if (innersUnmatched != null) {\n                      innersUnmatched.removeAll(matchedInners);\n                    }\n                  }\n                }\n              }\n              if (innerEnumerable == null\n                  || !innerEnumerable.any()) {\n                if (generateNullsOnRight) {\n                  inners = Linq4j.singletonNullEnumerator();\n                } else {\n                  inners = Linq4j.emptyEnumerator();\n                }\n              } else {\n                inners = innerEnumerable.enumerator();\n              }\n            }\n          }\n\n          public void reset() {\n            outers.reset();\n          }\n\n          public void close() {\n            outers.close();\n          }\n        };\n      }\n    };\n  }\n","realPath":"linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1372,"status":"M"}],"commitId":"66caa54c5e272f8287ca132ca012733898a38768","commitMessage":"@@@[CALCITE-4314] Add missing @Override annotations\n","date":"2020-10-07 05:42:47","modifiedFileCount":"745","status":"M","submitter":"Vladimir Sitnikov"},{"authorTime":"2020-05-29 00:04:40","codes":[{"authorDate":"2020-05-29 00:04:40","commitOrder":3,"curCode":"  private static <TSource, TInner, TKey, TResult> Enumerable<TResult> hashEquiJoin_(\n      final Enumerable<TSource> outer, final Enumerable<TInner> inner,\n      final Function1<TSource, TKey> outerKeySelector,\n      final Function1<TInner, TKey> innerKeySelector,\n      final Function2<TSource, TInner, TResult> resultSelector,\n      final @Nullable EqualityComparer<TKey> comparer,\n      final boolean generateNullsOnLeft,\n      final boolean generateNullsOnRight) {\n    return new AbstractEnumerable<TResult>() {\n      @Override public Enumerator<TResult> enumerator() {\n        final Lookup<TKey, TInner> innerLookup =\n            comparer == null\n                ? inner.toLookup(innerKeySelector)\n                : inner.toLookup(innerKeySelector, comparer);\n\n        return new Enumerator<TResult>() {\n          Enumerator<TSource> outers = outer.enumerator();\n          Enumerator<TInner> inners = Linq4j.emptyEnumerator();\n          @Nullable Set<TKey> unmatchedKeys =\n              generateNullsOnLeft\n                  ? new HashSet<>(innerLookup.keySet())\n                  : null;\n\n          @Override public TResult current() {\n            return resultSelector.apply(outers.current(), inners.current());\n          }\n\n          @Override public boolean moveNext() {\n            for (;;) {\n              if (inners.moveNext()) {\n                return true;\n              }\n              if (!outers.moveNext()) {\n                if (unmatchedKeys != null) {\n                  \r\n                  \r\n                  \r\n                  List<TInner> list = new ArrayList<>();\n                  for (TKey key : unmatchedKeys) {\n                    @SuppressWarnings(\"argument.type.incompatible\")\n                    Enumerable<TInner> innerValues = requireNonNull(innerLookup.get(key));\n                    for (TInner tInner : innerValues) {\n                      list.add(tInner);\n                    }\n                  }\n                  inners = Linq4j.enumerator(list);\n                  outers.close();\n                  outers = Linq4j.singletonNullEnumerator();\n                  outers.moveNext();\n                  unmatchedKeys = null; \r\n                  continue;\n                }\n                return false;\n              }\n              final TSource outer = outers.current();\n              final Enumerable<TInner> innerEnumerable;\n              if (outer == null) {\n                innerEnumerable = null;\n              } else {\n                final TKey outerKey = outerKeySelector.apply(outer);\n                if (outerKey == null) {\n                  innerEnumerable = null;\n                } else {\n                  if (unmatchedKeys != null) {\n                    unmatchedKeys.remove(outerKey);\n                  }\n                  innerEnumerable = innerLookup.get(outerKey);\n                }\n              }\n              if (innerEnumerable == null\n                  || !innerEnumerable.any()) {\n                if (generateNullsOnRight) {\n                  inners = Linq4j.singletonNullEnumerator();\n                } else {\n                  inners = Linq4j.emptyEnumerator();\n                }\n              } else {\n                inners = innerEnumerable.enumerator();\n              }\n            }\n          }\n\n          @Override public void reset() {\n            outers.reset();\n          }\n\n          @Override public void close() {\n            outers.close();\n          }\n        };\n      }\n    };\n  }\n","date":"2020-11-30 06:45:33","endLine":1396,"groupId":"10122","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"hashEquiJoin_","params":"(finalEnumerable<TSource>outer@finalEnumerable<TInner>inner@finalFunction1<TSource@TKey>outerKeySelector@finalFunction1<TInner@TKey>innerKeySelector@finalFunction2<TSource@TInner@TResult>resultSelector@final@NullableEqualityComparer<TKey>comparer@finalbooleangenerateNullsOnLeft@finalbooleangenerateNullsOnRight)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/b6/5681a61d625c97b1c82a2d555f8635b1edf6cb.src","preCode":"  private static <TSource, TInner, TKey, TResult> Enumerable<TResult> hashEquiJoin_(\n      final Enumerable<TSource> outer, final Enumerable<TInner> inner,\n      final Function1<TSource, TKey> outerKeySelector,\n      final Function1<TInner, TKey> innerKeySelector,\n      final Function2<TSource, TInner, TResult> resultSelector,\n      final EqualityComparer<TKey> comparer, final boolean generateNullsOnLeft,\n      final boolean generateNullsOnRight) {\n    return new AbstractEnumerable<TResult>() {\n      @Override public Enumerator<TResult> enumerator() {\n        final Lookup<TKey, TInner> innerLookup =\n            comparer == null\n                ? inner.toLookup(innerKeySelector)\n                : inner.toLookup(innerKeySelector, comparer);\n\n        return new Enumerator<TResult>() {\n          Enumerator<TSource> outers = outer.enumerator();\n          Enumerator<TInner> inners = Linq4j.emptyEnumerator();\n          Set<TKey> unmatchedKeys =\n              generateNullsOnLeft\n                  ? new HashSet<>(innerLookup.keySet())\n                  : null;\n\n          @Override public TResult current() {\n            return resultSelector.apply(outers.current(), inners.current());\n          }\n\n          @Override public boolean moveNext() {\n            for (;;) {\n              if (inners.moveNext()) {\n                return true;\n              }\n              if (!outers.moveNext()) {\n                if (unmatchedKeys != null) {\n                  \r\n                  \r\n                  \r\n                  List<TInner> list = new ArrayList<>();\n                  for (TKey key : unmatchedKeys) {\n                    for (TInner tInner : innerLookup.get(key)) {\n                      list.add(tInner);\n                    }\n                  }\n                  inners = Linq4j.enumerator(list);\n                  outers.close();\n                  outers = Linq4j.singletonNullEnumerator();\n                  outers.moveNext();\n                  unmatchedKeys = null; \r\n                  continue;\n                }\n                return false;\n              }\n              final TSource outer = outers.current();\n              final Enumerable<TInner> innerEnumerable;\n              if (outer == null) {\n                innerEnumerable = null;\n              } else {\n                final TKey outerKey = outerKeySelector.apply(outer);\n                if (outerKey == null) {\n                  innerEnumerable = null;\n                } else {\n                  if (unmatchedKeys != null) {\n                    unmatchedKeys.remove(outerKey);\n                  }\n                  innerEnumerable = innerLookup.get(outerKey);\n                }\n              }\n              if (innerEnumerable == null\n                  || !innerEnumerable.any()) {\n                if (generateNullsOnRight) {\n                  inners = Linq4j.singletonNullEnumerator();\n                } else {\n                  inners = Linq4j.emptyEnumerator();\n                }\n              } else {\n                inners = innerEnumerable.enumerator();\n              }\n            }\n          }\n\n          @Override public void reset() {\n            outers.reset();\n          }\n\n          @Override public void close() {\n            outers.close();\n          }\n        };\n      }\n    };\n  }\n","realPath":"linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1304,"status":"M"},{"authorDate":"2020-05-29 00:04:40","commitOrder":3,"curCode":"  private static <TSource, TInner, TKey, TResult> Enumerable<TResult> hashJoinWithPredicate_(\n      final Enumerable<TSource> outer, final Enumerable<TInner> inner,\n      final Function1<TSource, TKey> outerKeySelector,\n      final Function1<TInner, TKey> innerKeySelector,\n      final Function2<TSource, TInner, TResult> resultSelector,\n      final @Nullable EqualityComparer<TKey> comparer,\n      final boolean generateNullsOnLeft,\n      final boolean generateNullsOnRight, final Predicate2<TSource, TInner> predicate) {\n\n    return new AbstractEnumerable<TResult>() {\n      @Override public Enumerator<TResult> enumerator() {\n        \r\n\r\n\r\n\n        final Enumerable<TInner> innerToLookUp = generateNullsOnLeft\n            ? Linq4j.asEnumerable(inner.toList())\n            : inner;\n\n        final Lookup<TKey, TInner> innerLookup =\n            comparer == null\n                ? innerToLookUp.toLookup(innerKeySelector)\n                : innerToLookUp\n                    .toLookup(innerKeySelector, comparer);\n\n        return new Enumerator<TResult>() {\n          Enumerator<TSource> outers = outer.enumerator();\n          Enumerator<TInner> inners = Linq4j.emptyEnumerator();\n          @Nullable List<TInner> innersUnmatched =\n              generateNullsOnLeft\n                  ? new ArrayList<>(innerToLookUp.toList())\n                  : null;\n\n          @Override public TResult current() {\n            return resultSelector.apply(outers.current(), inners.current());\n          }\n\n          @Override public boolean moveNext() {\n            for (;;) {\n              if (inners.moveNext()) {\n                return true;\n              }\n              if (!outers.moveNext()) {\n                if (innersUnmatched != null) {\n                  inners = Linq4j.enumerator(innersUnmatched);\n                  outers.close();\n                  outers = Linq4j.singletonNullEnumerator();\n                  outers.moveNext();\n                  innersUnmatched = null; \r\n                  continue;\n                }\n                return false;\n              }\n              final TSource outer = outers.current();\n              Enumerable<TInner> innerEnumerable;\n              if (outer == null) {\n                innerEnumerable = null;\n              } else {\n                final TKey outerKey = outerKeySelector.apply(outer);\n                if (outerKey == null) {\n                  innerEnumerable = null;\n                } else {\n                  innerEnumerable = innerLookup.get(outerKey);\n                  \r\n                  if (innerEnumerable != null) {\n                    final List<TInner> matchedInners = new ArrayList<>();\n                    try (Enumerator<TInner> innerEnumerator =\n                        innerEnumerable.enumerator()) {\n                      while (innerEnumerator.moveNext()) {\n                        final TInner inner = innerEnumerator.current();\n                        if (predicate.apply(outer, inner)) {\n                          matchedInners.add(inner);\n                        }\n                      }\n                    }\n                    innerEnumerable = Linq4j.asEnumerable(matchedInners);\n                    if (innersUnmatched != null) {\n                      innersUnmatched.removeAll(matchedInners);\n                    }\n                  }\n                }\n              }\n              if (innerEnumerable == null\n                  || !innerEnumerable.any()) {\n                if (generateNullsOnRight) {\n                  inners = Linq4j.singletonNullEnumerator();\n                } else {\n                  inners = Linq4j.emptyEnumerator();\n                }\n              } else {\n                inners = innerEnumerable.enumerator();\n              }\n            }\n          }\n\n          @Override public void reset() {\n            outers.reset();\n          }\n\n          @Override public void close() {\n            outers.close();\n          }\n        };\n      }\n    };\n  }\n","date":"2020-11-30 06:45:33","endLine":1506,"groupId":"10122","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"hashJoinWithPredicate_","params":"(finalEnumerable<TSource>outer@finalEnumerable<TInner>inner@finalFunction1<TSource@TKey>outerKeySelector@finalFunction1<TInner@TKey>innerKeySelector@finalFunction2<TSource@TInner@TResult>resultSelector@final@NullableEqualityComparer<TKey>comparer@finalbooleangenerateNullsOnLeft@finalbooleangenerateNullsOnRight@finalPredicate2<TSource@TInner>predicate)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/b6/5681a61d625c97b1c82a2d555f8635b1edf6cb.src","preCode":"  private static <TSource, TInner, TKey, TResult> Enumerable<TResult> hashJoinWithPredicate_(\n      final Enumerable<TSource> outer, final Enumerable<TInner> inner,\n      final Function1<TSource, TKey> outerKeySelector,\n      final Function1<TInner, TKey> innerKeySelector,\n      final Function2<TSource, TInner, TResult> resultSelector,\n      final EqualityComparer<TKey> comparer, final boolean generateNullsOnLeft,\n      final boolean generateNullsOnRight, final Predicate2<TSource, TInner> predicate) {\n\n    return new AbstractEnumerable<TResult>() {\n      @Override public Enumerator<TResult> enumerator() {\n        \r\n\r\n\r\n\n        final Enumerable<TInner> innerToLookUp = generateNullsOnLeft\n            ? Linq4j.asEnumerable(inner.toList())\n            : inner;\n\n        final Lookup<TKey, TInner> innerLookup =\n            comparer == null\n                ? innerToLookUp.toLookup(innerKeySelector)\n                : innerToLookUp\n                    .toLookup(innerKeySelector, comparer);\n\n        return new Enumerator<TResult>() {\n          Enumerator<TSource> outers = outer.enumerator();\n          Enumerator<TInner> inners = Linq4j.emptyEnumerator();\n          List<TInner> innersUnmatched =\n              generateNullsOnLeft\n                  ? new ArrayList<>(innerToLookUp.toList())\n                  : null;\n\n          @Override public TResult current() {\n            return resultSelector.apply(outers.current(), inners.current());\n          }\n\n          @Override public boolean moveNext() {\n            for (;;) {\n              if (inners.moveNext()) {\n                return true;\n              }\n              if (!outers.moveNext()) {\n                if (innersUnmatched != null) {\n                  inners = Linq4j.enumerator(innersUnmatched);\n                  outers.close();\n                  outers = Linq4j.singletonNullEnumerator();\n                  outers.moveNext();\n                  innersUnmatched = null; \r\n                  continue;\n                }\n                return false;\n              }\n              final TSource outer = outers.current();\n              Enumerable<TInner> innerEnumerable;\n              if (outer == null) {\n                innerEnumerable = null;\n              } else {\n                final TKey outerKey = outerKeySelector.apply(outer);\n                if (outerKey == null) {\n                  innerEnumerable = null;\n                } else {\n                  innerEnumerable = innerLookup.get(outerKey);\n                  \r\n                  if (innerEnumerable != null) {\n                    final List<TInner> matchedInners = new ArrayList<>();\n                    try (Enumerator<TInner> innerEnumerator =\n                        innerEnumerable.enumerator()) {\n                      while (innerEnumerator.moveNext()) {\n                        final TInner inner = innerEnumerator.current();\n                        if (predicate.apply(outer, inner)) {\n                          matchedInners.add(inner);\n                        }\n                      }\n                    }\n                    innerEnumerable = Linq4j.asEnumerable(matchedInners);\n                    if (innersUnmatched != null) {\n                      innersUnmatched.removeAll(matchedInners);\n                    }\n                  }\n                }\n              }\n              if (innerEnumerable == null\n                  || !innerEnumerable.any()) {\n                if (generateNullsOnRight) {\n                  inners = Linq4j.singletonNullEnumerator();\n                } else {\n                  inners = Linq4j.emptyEnumerator();\n                }\n              } else {\n                inners = innerEnumerable.enumerator();\n              }\n            }\n          }\n\n          @Override public void reset() {\n            outers.reset();\n          }\n\n          @Override public void close() {\n            outers.close();\n          }\n        };\n      }\n    };\n  }\n","realPath":"linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1400,"status":"M"}],"commitId":"d9a81b88ad561e7e4cedae93e805e0d7a53a7f1a","commitMessage":"@@@[CALCITE-4199] Add nullability annotations\n\nThe commit includes javadoc updates and refactorings made by Julian Hyde in https://github.com/apache/calcite/pull/2278\n","date":"2020-11-30 06:45:33","modifiedFileCount":"1012","status":"M","submitter":"Vladimir Sitnikov"}]
