[{"authorTime":"2014-11-14 09:39:29","codes":[{"authorDate":"2014-11-14 09:39:29","commitOrder":1,"curCode":"  public static long intervalToMillis(\n      String literal,\n      SqlIntervalQualifier intervalQualifier) {\n    Util.permAssert(\n        !intervalQualifier.isYearMonth(),\n        \"interval must be day time\");\n    int[] ret;\n    try {\n      ret = intervalQualifier.evaluateIntervalLiteral(literal,\n          intervalQualifier.getParserPosition(), RelDataTypeSystem.DEFAULT);\n      assert ret != null;\n    } catch (EigenbaseContextException e) {\n      throw Util.newInternal(\n          e, \"while parsing day-to-second interval \" + literal);\n    }\n    long l = 0;\n    long[] conv = new long[5];\n    conv[4] = 1; \r\n    conv[3] = conv[4] * 1000; \r\n    conv[2] = conv[3] * 60; \r\n    conv[1] = conv[2] * 60; \r\n    conv[0] = conv[1] * 24; \r\n    for (int i = 1; i < ret.length; i++) {\n      l += conv[i - 1] * ret[i];\n    }\n    return ret[0] * l;\n  }\n","date":"2014-11-14 09:39:34","endLine":156,"groupId":"14251","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"intervalToMillis","params":"(Stringliteral@SqlIntervalQualifierintervalQualifier)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/12/97f35f8dc7ba3c7164088c516bd245a09a90d4.src","preCode":"  public static long intervalToMillis(\n      String literal,\n      SqlIntervalQualifier intervalQualifier) {\n    Util.permAssert(\n        !intervalQualifier.isYearMonth(),\n        \"interval must be day time\");\n    int[] ret;\n    try {\n      ret = intervalQualifier.evaluateIntervalLiteral(literal,\n          intervalQualifier.getParserPosition(), RelDataTypeSystem.DEFAULT);\n      assert ret != null;\n    } catch (EigenbaseContextException e) {\n      throw Util.newInternal(\n          e, \"while parsing day-to-second interval \" + literal);\n    }\n    long l = 0;\n    long[] conv = new long[5];\n    conv[4] = 1; \r\n    conv[3] = conv[4] * 1000; \r\n    conv[2] = conv[3] * 60; \r\n    conv[1] = conv[2] * 60; \r\n    conv[0] = conv[1] * 24; \r\n    for (int i = 1; i < ret.length; i++) {\n      l += conv[i - 1] * ret[i];\n    }\n    return ret[0] * l;\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/parser/SqlParserUtil.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":130,"status":"B"},{"authorDate":"2014-11-14 09:39:29","commitOrder":1,"curCode":"  public static long intervalToMonths(\n      String literal,\n      SqlIntervalQualifier intervalQualifier) {\n    Util.permAssert(\n        intervalQualifier.isYearMonth(),\n        \"interval must be year month\");\n    int[] ret;\n    try {\n      ret = intervalQualifier.evaluateIntervalLiteral(literal,\n          intervalQualifier.getParserPosition(), RelDataTypeSystem.DEFAULT);\n      assert ret != null;\n    } catch (EigenbaseContextException e) {\n      throw Util.newInternal(\n          e, \"error parsing year-to-month interval \" + literal);\n    }\n\n    long l = 0;\n    long[] conv = new long[2];\n    conv[1] = 1; \r\n    conv[0] = conv[1] * 12; \r\n    for (int i = 1; i < ret.length; i++) {\n      l += conv[i - 1] * ret[i];\n    }\n    return ret[0] * l;\n  }\n","date":"2014-11-14 09:39:34","endLine":196,"groupId":"14257","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"intervalToMonths","params":"(Stringliteral@SqlIntervalQualifierintervalQualifier)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/12/97f35f8dc7ba3c7164088c516bd245a09a90d4.src","preCode":"  public static long intervalToMonths(\n      String literal,\n      SqlIntervalQualifier intervalQualifier) {\n    Util.permAssert(\n        intervalQualifier.isYearMonth(),\n        \"interval must be year month\");\n    int[] ret;\n    try {\n      ret = intervalQualifier.evaluateIntervalLiteral(literal,\n          intervalQualifier.getParserPosition(), RelDataTypeSystem.DEFAULT);\n      assert ret != null;\n    } catch (EigenbaseContextException e) {\n      throw Util.newInternal(\n          e, \"error parsing year-to-month interval \" + literal);\n    }\n\n    long l = 0;\n    long[] conv = new long[2];\n    conv[1] = 1; \r\n    conv[0] = conv[1] * 12; \r\n    for (int i = 1; i < ret.length; i++) {\n      l += conv[i - 1] * ret[i];\n    }\n    return ret[0] * l;\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/parser/SqlParserUtil.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":172,"status":"B"}],"commitId":"a611d645ad754844a39f3d98f5f814f13dbd9404","commitMessage":"@@@[CALCITE-296] Re-organize package structure;\n[CALCITE-419] Naming convention for planner rules\n\nThis change only renames files (and deletes some obsolete files). There are no content changes.\n","date":"2014-11-14 09:39:34","modifiedFileCount":"0","status":"B","submitter":"Julian Hyde"},{"authorTime":"2014-11-14 10:11:34","codes":[{"authorDate":"2014-11-14 10:11:34","commitOrder":2,"curCode":"  public static long intervalToMillis(\n      String literal,\n      SqlIntervalQualifier intervalQualifier) {\n    Util.permAssert(\n        !intervalQualifier.isYearMonth(),\n        \"interval must be day time\");\n    int[] ret;\n    try {\n      ret = intervalQualifier.evaluateIntervalLiteral(literal,\n          intervalQualifier.getParserPosition(), RelDataTypeSystem.DEFAULT);\n      assert ret != null;\n    } catch (CalciteContextException e) {\n      throw Util.newInternal(\n          e, \"while parsing day-to-second interval \" + literal);\n    }\n    long l = 0;\n    long[] conv = new long[5];\n    conv[4] = 1; \r\n    conv[3] = conv[4] * 1000; \r\n    conv[2] = conv[3] * 60; \r\n    conv[1] = conv[2] * 60; \r\n    conv[0] = conv[1] * 24; \r\n    for (int i = 1; i < ret.length; i++) {\n      l += conv[i - 1] * ret[i];\n    }\n    return ret[0] * l;\n  }\n","date":"2014-11-14 10:22:06","endLine":170,"groupId":"14251","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"intervalToMillis","params":"(Stringliteral@SqlIntervalQualifierintervalQualifier)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/b1/84a867af17e734f62003a50a8052b441de3c8b.src","preCode":"  public static long intervalToMillis(\n      String literal,\n      SqlIntervalQualifier intervalQualifier) {\n    Util.permAssert(\n        !intervalQualifier.isYearMonth(),\n        \"interval must be day time\");\n    int[] ret;\n    try {\n      ret = intervalQualifier.evaluateIntervalLiteral(literal,\n          intervalQualifier.getParserPosition(), RelDataTypeSystem.DEFAULT);\n      assert ret != null;\n    } catch (EigenbaseContextException e) {\n      throw Util.newInternal(\n          e, \"while parsing day-to-second interval \" + literal);\n    }\n    long l = 0;\n    long[] conv = new long[5];\n    conv[4] = 1; \r\n    conv[3] = conv[4] * 1000; \r\n    conv[2] = conv[3] * 60; \r\n    conv[1] = conv[2] * 60; \r\n    conv[0] = conv[1] * 24; \r\n    for (int i = 1; i < ret.length; i++) {\n      l += conv[i - 1] * ret[i];\n    }\n    return ret[0] * l;\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/parser/SqlParserUtil.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":144,"status":"M"},{"authorDate":"2014-11-14 10:11:34","commitOrder":2,"curCode":"  public static long intervalToMonths(\n      String literal,\n      SqlIntervalQualifier intervalQualifier) {\n    Util.permAssert(\n        intervalQualifier.isYearMonth(),\n        \"interval must be year month\");\n    int[] ret;\n    try {\n      ret = intervalQualifier.evaluateIntervalLiteral(literal,\n          intervalQualifier.getParserPosition(), RelDataTypeSystem.DEFAULT);\n      assert ret != null;\n    } catch (CalciteContextException e) {\n      throw Util.newInternal(\n          e, \"error parsing year-to-month interval \" + literal);\n    }\n\n    long l = 0;\n    long[] conv = new long[2];\n    conv[1] = 1; \r\n    conv[0] = conv[1] * 12; \r\n    for (int i = 1; i < ret.length; i++) {\n      l += conv[i - 1] * ret[i];\n    }\n    return ret[0] * l;\n  }\n","date":"2014-11-14 10:22:06","endLine":210,"groupId":"14257","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"intervalToMonths","params":"(Stringliteral@SqlIntervalQualifierintervalQualifier)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/b1/84a867af17e734f62003a50a8052b441de3c8b.src","preCode":"  public static long intervalToMonths(\n      String literal,\n      SqlIntervalQualifier intervalQualifier) {\n    Util.permAssert(\n        intervalQualifier.isYearMonth(),\n        \"interval must be year month\");\n    int[] ret;\n    try {\n      ret = intervalQualifier.evaluateIntervalLiteral(literal,\n          intervalQualifier.getParserPosition(), RelDataTypeSystem.DEFAULT);\n      assert ret != null;\n    } catch (EigenbaseContextException e) {\n      throw Util.newInternal(\n          e, \"error parsing year-to-month interval \" + literal);\n    }\n\n    long l = 0;\n    long[] conv = new long[2];\n    conv[1] = 1; \r\n    conv[0] = conv[1] * 12; \r\n    for (int i = 1; i < ret.length; i++) {\n      l += conv[i - 1] * ret[i];\n    }\n    return ret[0] * l;\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/parser/SqlParserUtil.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":186,"status":"M"}],"commitId":"a0ba73cd2de76696b96a1cd828d2aa4d3ef9eb55","commitMessage":"@@@[CALCITE-306] Standardize code style for \"import package.*;\"\n\nRename classes and packages and generally fix things up after [CALCITE-296] and [CALCITE-419].\n\nMake many inner classes of EnumerableRules (e.g. EnumerableFilter.  EnumerableFilterRule) top-level classes.\n\nApply a consistent formatting convention for string literals split over multiple lines.\n\nRename generated file org.eigenbase.resource.Resources to org.apache.calcite.runtime.Resources.\n\nChange occurrences of \"optiq\" and \"eigenbase\" in java code to \"calcite\".\n","date":"2014-11-14 10:22:06","modifiedFileCount":"1156","status":"M","submitter":"Julian Hyde"},{"authorTime":"2017-01-23 17:38:12","codes":[{"authorDate":"2017-01-23 17:38:12","commitOrder":3,"curCode":"  public static long intervalToMillis(\n      String literal,\n      SqlIntervalQualifier intervalQualifier) {\n    Preconditions.checkArgument(!intervalQualifier.isYearMonth(),\n        \"interval must be day time\");\n    int[] ret;\n    try {\n      ret = intervalQualifier.evaluateIntervalLiteral(literal,\n          intervalQualifier.getParserPosition(), RelDataTypeSystem.DEFAULT);\n      assert ret != null;\n    } catch (CalciteContextException e) {\n      throw new RuntimeException(\"while parsing day-to-second interval \"\n          + literal, e);\n    }\n    long l = 0;\n    long[] conv = new long[5];\n    conv[4] = 1; \r\n    conv[3] = conv[4] * 1000; \r\n    conv[2] = conv[3] * 60; \r\n    conv[1] = conv[2] * 60; \r\n    conv[0] = conv[1] * 24; \r\n    for (int i = 1; i < ret.length; i++) {\n      l += conv[i - 1] * ret[i];\n    }\n    return ret[0] * l;\n  }\n","date":"2017-01-26 03:00:12","endLine":181,"groupId":"101871","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"intervalToMillis","params":"(Stringliteral@SqlIntervalQualifierintervalQualifier)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/22/8b5f74bc5cc0bfcecaeb83d58dc183dd028563.src","preCode":"  public static long intervalToMillis(\n      String literal,\n      SqlIntervalQualifier intervalQualifier) {\n    Util.permAssert(\n        !intervalQualifier.isYearMonth(),\n        \"interval must be day time\");\n    int[] ret;\n    try {\n      ret = intervalQualifier.evaluateIntervalLiteral(literal,\n          intervalQualifier.getParserPosition(), RelDataTypeSystem.DEFAULT);\n      assert ret != null;\n    } catch (CalciteContextException e) {\n      throw Util.newInternal(\n          e, \"while parsing day-to-second interval \" + literal);\n    }\n    long l = 0;\n    long[] conv = new long[5];\n    conv[4] = 1; \r\n    conv[3] = conv[4] * 1000; \r\n    conv[2] = conv[3] * 60; \r\n    conv[1] = conv[2] * 60; \r\n    conv[0] = conv[1] * 24; \r\n    for (int i = 1; i < ret.length; i++) {\n      l += conv[i - 1] * ret[i];\n    }\n    return ret[0] * l;\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/parser/SqlParserUtil.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":156,"status":"M"},{"authorDate":"2017-01-23 17:38:12","commitOrder":3,"curCode":"  public static long intervalToMonths(\n      String literal,\n      SqlIntervalQualifier intervalQualifier) {\n    Preconditions.checkArgument(intervalQualifier.isYearMonth(),\n        \"interval must be year month\");\n    int[] ret;\n    try {\n      ret = intervalQualifier.evaluateIntervalLiteral(literal,\n          intervalQualifier.getParserPosition(), RelDataTypeSystem.DEFAULT);\n      assert ret != null;\n    } catch (CalciteContextException e) {\n      throw new RuntimeException(\"Error while parsing year-to-month interval \"\n          + literal, e);\n    }\n\n    long l = 0;\n    long[] conv = new long[2];\n    conv[1] = 1; \r\n    conv[0] = conv[1] * 12; \r\n    for (int i = 1; i < ret.length; i++) {\n      l += conv[i - 1] * ret[i];\n    }\n    return ret[0] * l;\n  }\n","date":"2017-01-26 03:00:12","endLine":220,"groupId":"101871","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"intervalToMonths","params":"(Stringliteral@SqlIntervalQualifierintervalQualifier)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/22/8b5f74bc5cc0bfcecaeb83d58dc183dd028563.src","preCode":"  public static long intervalToMonths(\n      String literal,\n      SqlIntervalQualifier intervalQualifier) {\n    Util.permAssert(\n        intervalQualifier.isYearMonth(),\n        \"interval must be year month\");\n    int[] ret;\n    try {\n      ret = intervalQualifier.evaluateIntervalLiteral(literal,\n          intervalQualifier.getParserPosition(), RelDataTypeSystem.DEFAULT);\n      assert ret != null;\n    } catch (CalciteContextException e) {\n      throw Util.newInternal(\n          e, \"error parsing year-to-month interval \" + literal);\n    }\n\n    long l = 0;\n    long[] conv = new long[2];\n    conv[1] = 1; \r\n    conv[0] = conv[1] * 12; \r\n    for (int i = 1; i < ret.length; i++) {\n      l += conv[i - 1] * ret[i];\n    }\n    return ret[0] * l;\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/parser/SqlParserUtil.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":197,"status":"M"}],"commitId":"603648bc2466ab699fa6646ffc1ad717b8c11880","commitMessage":"@@@[CALCITE-1597] Obsolete Util.newInternal.  .pre.  .post.  .permAssert and Throwables.propagate\n\nReplace Util.newInternal with new AssertionError in some contexts. \nnew RuntimeException in others. Replace methods pre.  pos.  permAssert\nin Util with methods in Preconditions.\n\nRemove uses of Throwables.propagate and .propagateIfPossible because\nthey are deprecated as of Guava 20. Create method\nUtil.throwIfUnchecked because we can't use Guava's\nThrowables.throwIfUnchecked yet.\n","date":"2017-01-26 03:00:12","modifiedFileCount":"82","status":"M","submitter":"Julian Hyde"}]
