[{"authorTime":"2020-09-01 11:57:35","codes":[{"authorDate":"2020-09-01 11:57:35","commitOrder":1,"curCode":"  public Set<ImmutableBitSet> getUniqueKeys(Intersect rel,\n      RelMetadataQuery mq, boolean ignoreNulls) {\n    Set<ImmutableBitSet> keys = new LinkedHashSet<>();\n    for (RelNode input : rel.getInputs()) {\n      Set<ImmutableBitSet> uniqueKeys = mq.getUniqueKeys(input, ignoreNulls);\n      if (uniqueKeys != null) {\n        keys.addAll(uniqueKeys);\n      }\n    }\n    if (!keys.isEmpty()) {\n      return keys;\n    }\n\n    if (!rel.all) {\n      return ImmutableSet.of(\n          ImmutableBitSet.range(rel.getRowType().getFieldCount()));\n    }\n    return ImmutableSet.of();\n  }\n","date":"2020-09-03 14:26:50","endLine":283,"groupId":"1499","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"getUniqueKeys","params":"(Intersectrel@RelMetadataQuerymq@booleanignoreNulls)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/19/69d311dbf57b12babdc8ec244ed18191592dbd.src","preCode":"  public Set<ImmutableBitSet> getUniqueKeys(Intersect rel,\n      RelMetadataQuery mq, boolean ignoreNulls) {\n    Set<ImmutableBitSet> keys = new LinkedHashSet<>();\n    for (RelNode input : rel.getInputs()) {\n      Set<ImmutableBitSet> uniqueKeys = mq.getUniqueKeys(input, ignoreNulls);\n      if (uniqueKeys != null) {\n        keys.addAll(uniqueKeys);\n      }\n    }\n    if (!keys.isEmpty()) {\n      return keys;\n    }\n\n    if (!rel.all) {\n      return ImmutableSet.of(\n          ImmutableBitSet.range(rel.getRowType().getFieldCount()));\n    }\n    return ImmutableSet.of();\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/metadata/RelMdUniqueKeys.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":265,"status":"B"},{"authorDate":"2020-09-01 11:57:35","commitOrder":1,"curCode":"  public Set<ImmutableBitSet> getUniqueKeys(Minus rel,\n      RelMetadataQuery mq, boolean ignoreNulls) {\n    Set<ImmutableBitSet> uniqueKeys = mq.getUniqueKeys(rel.getInput(0), ignoreNulls);\n    if (uniqueKeys != null) {\n      return uniqueKeys;\n    }\n\n    if (!rel.all) {\n      return ImmutableSet.of(\n          ImmutableBitSet.range(rel.getRowType().getFieldCount()));\n    }\n    return ImmutableSet.of();\n  }\n","date":"2020-09-03 14:26:50","endLine":300,"groupId":"1497","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getUniqueKeys","params":"(Minusrel@RelMetadataQuerymq@booleanignoreNulls)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/19/69d311dbf57b12babdc8ec244ed18191592dbd.src","preCode":"  public Set<ImmutableBitSet> getUniqueKeys(Minus rel,\n      RelMetadataQuery mq, boolean ignoreNulls) {\n    Set<ImmutableBitSet> uniqueKeys = mq.getUniqueKeys(rel.getInput(0), ignoreNulls);\n    if (uniqueKeys != null) {\n      return uniqueKeys;\n    }\n\n    if (!rel.all) {\n      return ImmutableSet.of(\n          ImmutableBitSet.range(rel.getRowType().getFieldCount()));\n    }\n    return ImmutableSet.of();\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/metadata/RelMdUniqueKeys.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":288,"status":"B"}],"commitId":"103430bcc76ed1a7cbab6861ecdd39814cf4ef83","commitMessage":"@@@[CALCITE-4203] RelMdUniqueKeys should not return empty when meeting Intersect and Minus if its input has unique keys\n","date":"2020-09-03 14:26:50","modifiedFileCount":"2","status":"B","submitter":"Chunwei Lei"},{"authorTime":"2020-09-01 11:57:35","codes":[{"authorDate":"2020-09-30 02:49:29","commitOrder":2,"curCode":"  public Set<ImmutableBitSet> getUniqueKeys(Intersect rel,\n      RelMetadataQuery mq, boolean ignoreNulls) {\n    ImmutableSet.Builder<ImmutableBitSet> keys = new ImmutableSet.Builder<>();\n    for (RelNode input : rel.getInputs()) {\n      Set<ImmutableBitSet> uniqueKeys = mq.getUniqueKeys(input, ignoreNulls);\n      if (uniqueKeys != null) {\n        keys.addAll(uniqueKeys);\n      }\n    }\n    ImmutableSet<ImmutableBitSet> uniqueKeys = keys.build();\n    if (!uniqueKeys.isEmpty()) {\n      return uniqueKeys;\n    }\n\n    if (!rel.all) {\n      return ImmutableSet.of(\n          ImmutableBitSet.range(rel.getRowType().getFieldCount()));\n    }\n    return ImmutableSet.of();\n  }\n","date":"2020-10-07 05:43:20","endLine":286,"groupId":"111941","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"getUniqueKeys","params":"(Intersectrel@RelMetadataQuerymq@booleanignoreNulls)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/7f/25a5b77ed1acbaa47859a2acab02713cbf7bec.src","preCode":"  public Set<ImmutableBitSet> getUniqueKeys(Intersect rel,\n      RelMetadataQuery mq, boolean ignoreNulls) {\n    Set<ImmutableBitSet> keys = new LinkedHashSet<>();\n    for (RelNode input : rel.getInputs()) {\n      Set<ImmutableBitSet> uniqueKeys = mq.getUniqueKeys(input, ignoreNulls);\n      if (uniqueKeys != null) {\n        keys.addAll(uniqueKeys);\n      }\n    }\n    if (!keys.isEmpty()) {\n      return keys;\n    }\n\n    if (!rel.all) {\n      return ImmutableSet.of(\n          ImmutableBitSet.range(rel.getRowType().getFieldCount()));\n    }\n    return ImmutableSet.of();\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/metadata/RelMdUniqueKeys.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":267,"status":"M"},{"authorDate":"2020-09-01 11:57:35","commitOrder":2,"curCode":"  public Set<ImmutableBitSet> getUniqueKeys(Minus rel,\n      RelMetadataQuery mq, boolean ignoreNulls) {\n    Set<ImmutableBitSet> uniqueKeys = mq.getUniqueKeys(rel.getInput(0), ignoreNulls);\n    if (uniqueKeys != null) {\n      return uniqueKeys;\n    }\n\n    if (!rel.all) {\n      return ImmutableSet.of(\n          ImmutableBitSet.range(rel.getRowType().getFieldCount()));\n    }\n    return ImmutableSet.of();\n  }\n","date":"2020-09-03 14:26:50","endLine":300,"groupId":"111941","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getUniqueKeys","params":"(Minusrel@RelMetadataQuerymq@booleanignoreNulls)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/19/69d311dbf57b12babdc8ec244ed18191592dbd.src","preCode":"  public Set<ImmutableBitSet> getUniqueKeys(Minus rel,\n      RelMetadataQuery mq, boolean ignoreNulls) {\n    Set<ImmutableBitSet> uniqueKeys = mq.getUniqueKeys(rel.getInput(0), ignoreNulls);\n    if (uniqueKeys != null) {\n      return uniqueKeys;\n    }\n\n    if (!rel.all) {\n      return ImmutableSet.of(\n          ImmutableBitSet.range(rel.getRowType().getFieldCount()));\n    }\n    return ImmutableSet.of();\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/metadata/RelMdUniqueKeys.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":288,"status":"N"}],"commitId":"1435ed51c6764708b6c9952dca0af9374bf1f329","commitMessage":"@@@[CALCITE-4314] Avoid returning mutable and non-mutable lists from the same method\n\nSee https://errorprone.info/bugpattern/MixedMutabilityReturnType\n","date":"2020-10-07 05:43:20","modifiedFileCount":"9","status":"M","submitter":"Vladimir Sitnikov"}]
