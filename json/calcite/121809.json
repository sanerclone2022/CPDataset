[{"authorTime":"2019-08-05 21:28:29","codes":[{"authorDate":"2018-06-13 01:44:48","commitOrder":13,"curCode":"  public RexNode makeCast(\n      RelDataType type,\n      RexNode exp,\n      boolean matchNullability) {\n    final SqlTypeName sqlType = type.getSqlTypeName();\n    if (exp instanceof RexLiteral) {\n      RexLiteral literal = (RexLiteral) exp;\n      Comparable value = literal.getValueAs(Comparable.class);\n      SqlTypeName typeName = literal.getTypeName();\n      if (canRemoveCastFromLiteral(type, value, typeName)) {\n        switch (typeName) {\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          assert value instanceof BigDecimal;\n          typeName = type.getSqlTypeName();\n          switch (typeName) {\n          case BIGINT:\n          case INTEGER:\n          case SMALLINT:\n          case TINYINT:\n          case FLOAT:\n          case REAL:\n          case DECIMAL:\n            BigDecimal value2 = (BigDecimal) value;\n            final BigDecimal multiplier =\n                baseUnit(literal.getTypeName()).multiplier;\n            final BigDecimal divider =\n                literal.getTypeName().getEndUnit().multiplier;\n            value = value2.multiply(multiplier)\n                .divide(divider, 0, RoundingMode.HALF_DOWN);\n          }\n\n          \r\n          switch (typeName) {\n          case INTEGER:\n            typeName = SqlTypeName.BIGINT;\n          }\n        }\n        final RexLiteral literal2 =\n            makeLiteral(value, type, typeName);\n        if (type.isNullable()\n            && !literal2.getType().isNullable()\n            && matchNullability) {\n          return makeAbstractCast(type, literal2);\n        }\n        return literal2;\n      }\n    } else if (SqlTypeUtil.isExactNumeric(type)\n        && SqlTypeUtil.isInterval(exp.getType())) {\n      return makeCastIntervalToExact(type, exp);\n    } else if (sqlType == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(exp.getType())) {\n      return makeCastExactToBoolean(type, exp);\n    } else if (exp.getType().getSqlTypeName() == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(type)) {\n      return makeCastBooleanToExact(type, exp);\n    }\n    return makeAbstractCast(type, exp);\n  }\n","date":"2018-06-29 16:27:43","endLine":564,"groupId":"5948","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"makeCast","params":"(RelDataTypetype@RexNodeexp@booleanmatchNullability)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/5d/cc85b33b8707d14bf69945cfa9530fe1c8a2ec.src","preCode":"  public RexNode makeCast(\n      RelDataType type,\n      RexNode exp,\n      boolean matchNullability) {\n    final SqlTypeName sqlType = type.getSqlTypeName();\n    if (exp instanceof RexLiteral) {\n      RexLiteral literal = (RexLiteral) exp;\n      Comparable value = literal.getValueAs(Comparable.class);\n      SqlTypeName typeName = literal.getTypeName();\n      if (canRemoveCastFromLiteral(type, value, typeName)) {\n        switch (typeName) {\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          assert value instanceof BigDecimal;\n          typeName = type.getSqlTypeName();\n          switch (typeName) {\n          case BIGINT:\n          case INTEGER:\n          case SMALLINT:\n          case TINYINT:\n          case FLOAT:\n          case REAL:\n          case DECIMAL:\n            BigDecimal value2 = (BigDecimal) value;\n            final BigDecimal multiplier =\n                baseUnit(literal.getTypeName()).multiplier;\n            final BigDecimal divider =\n                literal.getTypeName().getEndUnit().multiplier;\n            value = value2.multiply(multiplier)\n                .divide(divider, 0, RoundingMode.HALF_DOWN);\n          }\n\n          \r\n          switch (typeName) {\n          case INTEGER:\n            typeName = SqlTypeName.BIGINT;\n          }\n        }\n        final RexLiteral literal2 =\n            makeLiteral(value, type, typeName);\n        if (type.isNullable()\n            && !literal2.getType().isNullable()\n            && matchNullability) {\n          return makeAbstractCast(type, literal2);\n        }\n        return literal2;\n      }\n    } else if (SqlTypeUtil.isExactNumeric(type)\n        && SqlTypeUtil.isInterval(exp.getType())) {\n      return makeCastIntervalToExact(type, exp);\n    } else if (sqlType == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(exp.getType())) {\n      return makeCastExactToBoolean(type, exp);\n    } else if (exp.getType().getSqlTypeName() == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(type)) {\n      return makeCastBooleanToExact(type, exp);\n    }\n    return makeAbstractCast(type, exp);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rex/RexBuilder.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":495,"status":"NB"},{"authorDate":"2019-08-05 21:28:29","commitOrder":13,"curCode":"    @Override Expression implementSafe(final RexToLixTranslator translator,\n        final RexCall call, final List<Expression> argValueList) {\n      final TimeUnitRange timeUnitRange =\n          (TimeUnitRange) translator.getLiteralValue(argValueList.get(0));\n      final TimeUnit unit = timeUnitRange.startUnit;\n      Expression operand = argValueList.get(1);\n      final SqlTypeName sqlTypeName =\n          call.operands.get(1).getType().getSqlTypeName();\n      switch (unit) {\n      case MILLENNIUM:\n      case CENTURY:\n      case YEAR:\n      case QUARTER:\n      case MONTH:\n      case DAY:\n      case DOW:\n      case DECADE:\n      case DOY:\n      case ISODOW:\n      case ISOYEAR:\n      case WEEK:\n        switch (sqlTypeName) {\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          break;\n        case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n          operand = Expressions.call(\n              BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, translator.getRoot()));\n          \r\n        case TIMESTAMP:\n          operand = Expressions.call(BuiltInMethod.FLOOR_DIV.method,\n              operand, Expressions.constant(TimeUnit.DAY.multiplier.longValue()));\n          \r\n        case DATE:\n          return Expressions.call(BuiltInMethod.UNIX_DATE_EXTRACT.method,\n              argValueList.get(0), operand);\n        default:\n          throw new AssertionError(\"unexpected \" + sqlTypeName);\n        }\n        break;\n      case MILLISECOND:\n      case MICROSECOND:\n      case NANOSECOND:\n        if (sqlTypeName == SqlTypeName.DATE) {\n          return Expressions.constant(0L);\n        }\n        operand = mod(operand, TimeUnit.MINUTE.multiplier.longValue());\n        return Expressions.multiply(\n            operand, Expressions.constant((long) (1 / unit.multiplier.doubleValue())));\n      case EPOCH:\n        switch (sqlTypeName) {\n        case DATE:\n          \r\n          operand = Expressions.multiply(operand,\n              Expressions.constant(TimeUnit.DAY.multiplier.longValue()));\n          \r\n        case TIMESTAMP:\n          \r\n          return Expressions.divide(operand,\n              Expressions.constant(TimeUnit.SECOND.multiplier.longValue()));\n        case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n          operand = Expressions.call(\n              BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, translator.getRoot()));\n          return Expressions.divide(operand,\n              Expressions.constant(TimeUnit.SECOND.multiplier.longValue()));\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          \r\n          throw new AssertionError(\"unexpected \" + sqlTypeName);\n        }\n        break;\n      case HOUR:\n      case MINUTE:\n      case SECOND:\n        switch (sqlTypeName) {\n        case DATE:\n          return Expressions.multiply(operand, Expressions.constant(0L));\n        }\n        break;\n      }\n\n      operand = mod(operand, getFactor(unit));\n      if (unit == TimeUnit.QUARTER) {\n        operand = Expressions.subtract(operand, Expressions.constant(1L));\n      }\n      operand = Expressions.divide(operand,\n          Expressions.constant(unit.multiplier.longValue()));\n      if (unit == TimeUnit.QUARTER) {\n        operand = Expressions.add(operand, Expressions.constant(1L));\n      }\n      return operand;\n    }\n","date":"2020-06-26 14:19:13","endLine":2316,"groupId":"8140","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"implementSafe","params":"(finalRexToLixTranslatortranslator@finalRexCallcall@finalList<Expression>argValueList)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e0/457e95186624c2bd9540162a894a9efe4588a6.src","preCode":"    @Override Expression implementSafe(final RexToLixTranslator translator,\n        final RexCall call, final List<Expression> argValueList) {\n      final TimeUnitRange timeUnitRange =\n          (TimeUnitRange) translator.getLiteralValue(argValueList.get(0));\n      final TimeUnit unit = timeUnitRange.startUnit;\n      Expression operand = argValueList.get(1);\n      final SqlTypeName sqlTypeName =\n          call.operands.get(1).getType().getSqlTypeName();\n      switch (unit) {\n      case MILLENNIUM:\n      case CENTURY:\n      case YEAR:\n      case QUARTER:\n      case MONTH:\n      case DAY:\n      case DOW:\n      case DECADE:\n      case DOY:\n      case ISODOW:\n      case ISOYEAR:\n      case WEEK:\n        switch (sqlTypeName) {\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          break;\n        case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n          operand = Expressions.call(\n              BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, translator.getRoot()));\n          \r\n        case TIMESTAMP:\n          operand = Expressions.call(BuiltInMethod.FLOOR_DIV.method,\n              operand, Expressions.constant(TimeUnit.DAY.multiplier.longValue()));\n          \r\n        case DATE:\n          return Expressions.call(BuiltInMethod.UNIX_DATE_EXTRACT.method,\n              argValueList.get(0), operand);\n        default:\n          throw new AssertionError(\"unexpected \" + sqlTypeName);\n        }\n        break;\n      case MILLISECOND:\n      case MICROSECOND:\n      case NANOSECOND:\n        if (sqlTypeName == SqlTypeName.DATE) {\n          return Expressions.constant(0L);\n        }\n        operand = mod(operand, TimeUnit.MINUTE.multiplier.longValue());\n        return Expressions.multiply(\n            operand, Expressions.constant((long) (1 / unit.multiplier.doubleValue())));\n      case EPOCH:\n        switch (sqlTypeName) {\n        case DATE:\n          \r\n          operand = Expressions.multiply(operand,\n              Expressions.constant(TimeUnit.DAY.multiplier.longValue()));\n          \r\n        case TIMESTAMP:\n          \r\n          return Expressions.divide(operand,\n              Expressions.constant(TimeUnit.SECOND.multiplier.longValue()));\n        case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n          operand = Expressions.call(\n              BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, translator.getRoot()));\n          return Expressions.divide(operand,\n              Expressions.constant(TimeUnit.SECOND.multiplier.longValue()));\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          \r\n          throw new AssertionError(\"unexpected \" + sqlTypeName);\n        }\n        break;\n      case HOUR:\n      case MINUTE:\n      case SECOND:\n        switch (sqlTypeName) {\n        case DATE:\n          return Expressions.multiply(operand, Expressions.constant(0L));\n        }\n        break;\n      }\n\n      operand = mod(operand, getFactor(unit));\n      if (unit == TimeUnit.QUARTER) {\n        operand = Expressions.subtract(operand, Expressions.constant(1L));\n      }\n      operand = Expressions.divide(operand,\n          Expressions.constant(unit.multiplier.longValue()));\n      if (unit == TimeUnit.QUARTER) {\n        operand = Expressions.add(operand, Expressions.constant(1L));\n      }\n      return operand;\n    }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":2199,"status":"B"}],"commitId":"dae53ef7917c46f6d5593477b2ef81b16427c541","commitMessage":"@@@[CALCITE-3224] New implementation of RexNode-to-Expression code generation\n\nFixes various issues where.  due to common sub-expression\nelimination.  a guarded value would be accessed before the\ncondition had been evaluated. For example.  division-by-zero\noccurs if the quotient is computed before the zero check.\n\nIssues fixed:\n * [CALCITE-3142] NullPointerException when rounding a\n   nullable numeric\n * [CALCITE-3143] Dividing by NULLIF may cause\n   \"ArithmeticException: Division by zero\"\n * [CALCITE-3150] NullPointerException when UPPER is repeated\n   and combined with LIKE\n * [CALCITE-3717] Dividing by nullable numeric throws\n   \"ArithmeticException: Division by zero\"\n\nRestore type to RexCall.equals.  necessary to distinguish CAST calls (a\nbug introduced by [CALCITE-3786]).\n\nClose apache/calcite#1347\n","date":"2020-06-26 14:19:13","modifiedFileCount":"10","status":"M","submitter":"wellfengzhu"},{"authorTime":"2020-09-30 01:31:14","codes":[{"authorDate":"2020-09-30 01:31:14","commitOrder":14,"curCode":"  public RexNode makeCast(\n      RelDataType type,\n      RexNode exp,\n      boolean matchNullability) {\n    final SqlTypeName sqlType = type.getSqlTypeName();\n    if (exp instanceof RexLiteral) {\n      RexLiteral literal = (RexLiteral) exp;\n      Comparable value = literal.getValueAs(Comparable.class);\n      SqlTypeName typeName = literal.getTypeName();\n      if (canRemoveCastFromLiteral(type, value, typeName)) {\n        switch (typeName) {\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          assert value instanceof BigDecimal;\n          typeName = type.getSqlTypeName();\n          switch (typeName) {\n          case BIGINT:\n          case INTEGER:\n          case SMALLINT:\n          case TINYINT:\n          case FLOAT:\n          case REAL:\n          case DECIMAL:\n            BigDecimal value2 = (BigDecimal) value;\n            final BigDecimal multiplier =\n                baseUnit(literal.getTypeName()).multiplier;\n            final BigDecimal divider =\n                literal.getTypeName().getEndUnit().multiplier;\n            value = value2.multiply(multiplier)\n                .divide(divider, 0, RoundingMode.HALF_DOWN);\n            break;\n          default:\n            break;\n          }\n\n          \r\n          switch (typeName) {\n          case INTEGER:\n            typeName = SqlTypeName.BIGINT;\n            break;\n          default:\n            break;\n          }\n          break;\n        default:\n          break;\n        }\n        final RexLiteral literal2 =\n            makeLiteral(value, type, typeName);\n        if (type.isNullable()\n            && !literal2.getType().isNullable()\n            && matchNullability) {\n          return makeAbstractCast(type, literal2);\n        }\n        return literal2;\n      }\n    } else if (SqlTypeUtil.isExactNumeric(type)\n        && SqlTypeUtil.isInterval(exp.getType())) {\n      return makeCastIntervalToExact(type, exp);\n    } else if (sqlType == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(exp.getType())) {\n      return makeCastExactToBoolean(type, exp);\n    } else if (exp.getType().getSqlTypeName() == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(type)) {\n      return makeCastBooleanToExact(type, exp);\n    }\n    return makeAbstractCast(type, exp);\n  }\n","date":"2020-10-07 05:43:06","endLine":620,"groupId":"9088","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"makeCast","params":"(RelDataTypetype@RexNodeexp@booleanmatchNullability)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/f6/ee5bda33c9546221063e3dbd586ce5f4d35247.src","preCode":"  public RexNode makeCast(\n      RelDataType type,\n      RexNode exp,\n      boolean matchNullability) {\n    final SqlTypeName sqlType = type.getSqlTypeName();\n    if (exp instanceof RexLiteral) {\n      RexLiteral literal = (RexLiteral) exp;\n      Comparable value = literal.getValueAs(Comparable.class);\n      SqlTypeName typeName = literal.getTypeName();\n      if (canRemoveCastFromLiteral(type, value, typeName)) {\n        switch (typeName) {\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          assert value instanceof BigDecimal;\n          typeName = type.getSqlTypeName();\n          switch (typeName) {\n          case BIGINT:\n          case INTEGER:\n          case SMALLINT:\n          case TINYINT:\n          case FLOAT:\n          case REAL:\n          case DECIMAL:\n            BigDecimal value2 = (BigDecimal) value;\n            final BigDecimal multiplier =\n                baseUnit(literal.getTypeName()).multiplier;\n            final BigDecimal divider =\n                literal.getTypeName().getEndUnit().multiplier;\n            value = value2.multiply(multiplier)\n                .divide(divider, 0, RoundingMode.HALF_DOWN);\n          }\n\n          \r\n          switch (typeName) {\n          case INTEGER:\n            typeName = SqlTypeName.BIGINT;\n          }\n        }\n        final RexLiteral literal2 =\n            makeLiteral(value, type, typeName);\n        if (type.isNullable()\n            && !literal2.getType().isNullable()\n            && matchNullability) {\n          return makeAbstractCast(type, literal2);\n        }\n        return literal2;\n      }\n    } else if (SqlTypeUtil.isExactNumeric(type)\n        && SqlTypeUtil.isInterval(exp.getType())) {\n      return makeCastIntervalToExact(type, exp);\n    } else if (sqlType == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(exp.getType())) {\n      return makeCastExactToBoolean(type, exp);\n    } else if (exp.getType().getSqlTypeName() == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(type)) {\n      return makeCastBooleanToExact(type, exp);\n    }\n    return makeAbstractCast(type, exp);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rex/RexBuilder.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":542,"status":"M"},{"authorDate":"2020-09-30 01:31:14","commitOrder":14,"curCode":"    @Override Expression implementSafe(final RexToLixTranslator translator,\n        final RexCall call, final List<Expression> argValueList) {\n      final TimeUnitRange timeUnitRange =\n          (TimeUnitRange) translator.getLiteralValue(argValueList.get(0));\n      final TimeUnit unit = timeUnitRange.startUnit;\n      Expression operand = argValueList.get(1);\n      final SqlTypeName sqlTypeName =\n          call.operands.get(1).getType().getSqlTypeName();\n      switch (unit) {\n      case MILLENNIUM:\n      case CENTURY:\n      case YEAR:\n      case QUARTER:\n      case MONTH:\n      case DAY:\n      case DOW:\n      case DECADE:\n      case DOY:\n      case ISODOW:\n      case ISOYEAR:\n      case WEEK:\n        switch (sqlTypeName) {\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          break;\n        case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n          operand = Expressions.call(\n              BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, translator.getRoot()));\n          \r\n        case TIMESTAMP:\n          operand = Expressions.call(BuiltInMethod.FLOOR_DIV.method,\n              operand, Expressions.constant(TimeUnit.DAY.multiplier.longValue()));\n          \r\n        case DATE:\n          return Expressions.call(BuiltInMethod.UNIX_DATE_EXTRACT.method,\n              argValueList.get(0), operand);\n        default:\n          throw new AssertionError(\"unexpected \" + sqlTypeName);\n        }\n        break;\n      case MILLISECOND:\n      case MICROSECOND:\n      case NANOSECOND:\n        if (sqlTypeName == SqlTypeName.DATE) {\n          return Expressions.constant(0L);\n        }\n        operand = mod(operand, TimeUnit.MINUTE.multiplier.longValue());\n        return Expressions.multiply(\n            operand, Expressions.constant((long) (1 / unit.multiplier.doubleValue())));\n      case EPOCH:\n        switch (sqlTypeName) {\n        case DATE:\n          \r\n          operand = Expressions.multiply(operand,\n              Expressions.constant(TimeUnit.DAY.multiplier.longValue()));\n          \r\n        case TIMESTAMP:\n          \r\n          return Expressions.divide(operand,\n              Expressions.constant(TimeUnit.SECOND.multiplier.longValue()));\n        case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n          operand = Expressions.call(\n              BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, translator.getRoot()));\n          return Expressions.divide(operand,\n              Expressions.constant(TimeUnit.SECOND.multiplier.longValue()));\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          \r\n          throw new AssertionError(\"unexpected \" + sqlTypeName);\n        default:\n          break;\n        }\n        break;\n      case HOUR:\n      case MINUTE:\n      case SECOND:\n        switch (sqlTypeName) {\n        case DATE:\n          return Expressions.multiply(operand, Expressions.constant(0L));\n        default:\n          break;\n        }\n        break;\n      }\n\n      operand = mod(operand, getFactor(unit));\n      if (unit == TimeUnit.QUARTER) {\n        operand = Expressions.subtract(operand, Expressions.constant(1L));\n      }\n      operand = Expressions.divide(operand,\n          Expressions.constant(unit.multiplier.longValue()));\n      if (unit == TimeUnit.QUARTER) {\n        operand = Expressions.add(operand, Expressions.constant(1L));\n      }\n      return operand;\n    }\n","date":"2020-10-07 05:43:06","endLine":2362,"groupId":"8140","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"implementSafe","params":"(finalRexToLixTranslatortranslator@finalRexCallcall@finalList<Expression>argValueList)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/82/8ed066eedec77069d14d918310e957cc8c39f2.src","preCode":"    @Override Expression implementSafe(final RexToLixTranslator translator,\n        final RexCall call, final List<Expression> argValueList) {\n      final TimeUnitRange timeUnitRange =\n          (TimeUnitRange) translator.getLiteralValue(argValueList.get(0));\n      final TimeUnit unit = timeUnitRange.startUnit;\n      Expression operand = argValueList.get(1);\n      final SqlTypeName sqlTypeName =\n          call.operands.get(1).getType().getSqlTypeName();\n      switch (unit) {\n      case MILLENNIUM:\n      case CENTURY:\n      case YEAR:\n      case QUARTER:\n      case MONTH:\n      case DAY:\n      case DOW:\n      case DECADE:\n      case DOY:\n      case ISODOW:\n      case ISOYEAR:\n      case WEEK:\n        switch (sqlTypeName) {\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          break;\n        case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n          operand = Expressions.call(\n              BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, translator.getRoot()));\n          \r\n        case TIMESTAMP:\n          operand = Expressions.call(BuiltInMethod.FLOOR_DIV.method,\n              operand, Expressions.constant(TimeUnit.DAY.multiplier.longValue()));\n          \r\n        case DATE:\n          return Expressions.call(BuiltInMethod.UNIX_DATE_EXTRACT.method,\n              argValueList.get(0), operand);\n        default:\n          throw new AssertionError(\"unexpected \" + sqlTypeName);\n        }\n        break;\n      case MILLISECOND:\n      case MICROSECOND:\n      case NANOSECOND:\n        if (sqlTypeName == SqlTypeName.DATE) {\n          return Expressions.constant(0L);\n        }\n        operand = mod(operand, TimeUnit.MINUTE.multiplier.longValue());\n        return Expressions.multiply(\n            operand, Expressions.constant((long) (1 / unit.multiplier.doubleValue())));\n      case EPOCH:\n        switch (sqlTypeName) {\n        case DATE:\n          \r\n          operand = Expressions.multiply(operand,\n              Expressions.constant(TimeUnit.DAY.multiplier.longValue()));\n          \r\n        case TIMESTAMP:\n          \r\n          return Expressions.divide(operand,\n              Expressions.constant(TimeUnit.SECOND.multiplier.longValue()));\n        case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n          operand = Expressions.call(\n              BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, translator.getRoot()));\n          return Expressions.divide(operand,\n              Expressions.constant(TimeUnit.SECOND.multiplier.longValue()));\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          \r\n          throw new AssertionError(\"unexpected \" + sqlTypeName);\n        }\n        break;\n      case HOUR:\n      case MINUTE:\n      case SECOND:\n        switch (sqlTypeName) {\n        case DATE:\n          return Expressions.multiply(operand, Expressions.constant(0L));\n        }\n        break;\n      }\n\n      operand = mod(operand, getFactor(unit));\n      if (unit == TimeUnit.QUARTER) {\n        operand = Expressions.subtract(operand, Expressions.constant(1L));\n      }\n      operand = Expressions.divide(operand,\n          Expressions.constant(unit.multiplier.longValue()));\n      if (unit == TimeUnit.QUARTER) {\n        operand = Expressions.add(operand, Expressions.constant(1L));\n      }\n      return operand;\n    }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":2241,"status":"M"}],"commitId":"1b94f37e888cf2d186362473529e6c147afe0f6e","commitMessage":"@@@[CALCITE-4314] Add missing default branches to switch statement\n\nNote: the changes are mechanical.\nThe intention is to keep the previous behavior and prevent adding new\nnon exchaustive switch statements in the future.\n\nSee https://errorprone.info/bugpattern/MissingCasesInEnumSwitch\n","date":"2020-10-07 05:43:06","modifiedFileCount":"98","status":"M","submitter":"Vladimir Sitnikov"},{"authorTime":"2020-05-29 00:04:40","codes":[{"authorDate":"2020-09-30 01:31:14","commitOrder":15,"curCode":"  public RexNode makeCast(\n      RelDataType type,\n      RexNode exp,\n      boolean matchNullability) {\n    final SqlTypeName sqlType = type.getSqlTypeName();\n    if (exp instanceof RexLiteral) {\n      RexLiteral literal = (RexLiteral) exp;\n      Comparable value = literal.getValueAs(Comparable.class);\n      SqlTypeName typeName = literal.getTypeName();\n      if (canRemoveCastFromLiteral(type, value, typeName)) {\n        switch (typeName) {\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          assert value instanceof BigDecimal;\n          typeName = type.getSqlTypeName();\n          switch (typeName) {\n          case BIGINT:\n          case INTEGER:\n          case SMALLINT:\n          case TINYINT:\n          case FLOAT:\n          case REAL:\n          case DECIMAL:\n            BigDecimal value2 = (BigDecimal) value;\n            final BigDecimal multiplier =\n                baseUnit(literal.getTypeName()).multiplier;\n            final BigDecimal divider =\n                literal.getTypeName().getEndUnit().multiplier;\n            value = value2.multiply(multiplier)\n                .divide(divider, 0, RoundingMode.HALF_DOWN);\n            break;\n          default:\n            break;\n          }\n\n          \r\n          switch (typeName) {\n          case INTEGER:\n            typeName = SqlTypeName.BIGINT;\n            break;\n          default:\n            break;\n          }\n          break;\n        default:\n          break;\n        }\n        final RexLiteral literal2 =\n            makeLiteral(value, type, typeName);\n        if (type.isNullable()\n            && !literal2.getType().isNullable()\n            && matchNullability) {\n          return makeAbstractCast(type, literal2);\n        }\n        return literal2;\n      }\n    } else if (SqlTypeUtil.isExactNumeric(type)\n        && SqlTypeUtil.isInterval(exp.getType())) {\n      return makeCastIntervalToExact(type, exp);\n    } else if (sqlType == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(exp.getType())) {\n      return makeCastExactToBoolean(type, exp);\n    } else if (exp.getType().getSqlTypeName() == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(type)) {\n      return makeCastBooleanToExact(type, exp);\n    }\n    return makeAbstractCast(type, exp);\n  }\n","date":"2020-10-07 05:43:06","endLine":620,"groupId":"121809","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"makeCast","params":"(RelDataTypetype@RexNodeexp@booleanmatchNullability)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/f6/ee5bda33c9546221063e3dbd586ce5f4d35247.src","preCode":"  public RexNode makeCast(\n      RelDataType type,\n      RexNode exp,\n      boolean matchNullability) {\n    final SqlTypeName sqlType = type.getSqlTypeName();\n    if (exp instanceof RexLiteral) {\n      RexLiteral literal = (RexLiteral) exp;\n      Comparable value = literal.getValueAs(Comparable.class);\n      SqlTypeName typeName = literal.getTypeName();\n      if (canRemoveCastFromLiteral(type, value, typeName)) {\n        switch (typeName) {\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          assert value instanceof BigDecimal;\n          typeName = type.getSqlTypeName();\n          switch (typeName) {\n          case BIGINT:\n          case INTEGER:\n          case SMALLINT:\n          case TINYINT:\n          case FLOAT:\n          case REAL:\n          case DECIMAL:\n            BigDecimal value2 = (BigDecimal) value;\n            final BigDecimal multiplier =\n                baseUnit(literal.getTypeName()).multiplier;\n            final BigDecimal divider =\n                literal.getTypeName().getEndUnit().multiplier;\n            value = value2.multiply(multiplier)\n                .divide(divider, 0, RoundingMode.HALF_DOWN);\n            break;\n          default:\n            break;\n          }\n\n          \r\n          switch (typeName) {\n          case INTEGER:\n            typeName = SqlTypeName.BIGINT;\n            break;\n          default:\n            break;\n          }\n          break;\n        default:\n          break;\n        }\n        final RexLiteral literal2 =\n            makeLiteral(value, type, typeName);\n        if (type.isNullable()\n            && !literal2.getType().isNullable()\n            && matchNullability) {\n          return makeAbstractCast(type, literal2);\n        }\n        return literal2;\n      }\n    } else if (SqlTypeUtil.isExactNumeric(type)\n        && SqlTypeUtil.isInterval(exp.getType())) {\n      return makeCastIntervalToExact(type, exp);\n    } else if (sqlType == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(exp.getType())) {\n      return makeCastExactToBoolean(type, exp);\n    } else if (exp.getType().getSqlTypeName() == SqlTypeName.BOOLEAN\n        && SqlTypeUtil.isExactNumeric(type)) {\n      return makeCastBooleanToExact(type, exp);\n    }\n    return makeAbstractCast(type, exp);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rex/RexBuilder.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":542,"status":"N"},{"authorDate":"2020-05-29 00:04:40","commitOrder":15,"curCode":"    @Override Expression implementSafe(final RexToLixTranslator translator,\n        final RexCall call, final List<Expression> argValueList) {\n      final TimeUnitRange timeUnitRange =\n          (TimeUnitRange) translator.getLiteralValue(argValueList.get(0));\n      final TimeUnit unit = requireNonNull(timeUnitRange, \"timeUnitRange\").startUnit;\n      Expression operand = argValueList.get(1);\n      final SqlTypeName sqlTypeName =\n          call.operands.get(1).getType().getSqlTypeName();\n      switch (unit) {\n      case MILLENNIUM:\n      case CENTURY:\n      case YEAR:\n      case QUARTER:\n      case MONTH:\n      case DAY:\n      case DOW:\n      case DECADE:\n      case DOY:\n      case ISODOW:\n      case ISOYEAR:\n      case WEEK:\n        switch (sqlTypeName) {\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          break;\n        case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n          operand = Expressions.call(\n              BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, translator.getRoot()));\n          \r\n        case TIMESTAMP:\n          operand = Expressions.call(BuiltInMethod.FLOOR_DIV.method,\n              operand, Expressions.constant(TimeUnit.DAY.multiplier.longValue()));\n          \r\n        case DATE:\n          return Expressions.call(BuiltInMethod.UNIX_DATE_EXTRACT.method,\n              argValueList.get(0), operand);\n        default:\n          throw new AssertionError(\"unexpected \" + sqlTypeName);\n        }\n        break;\n      case MILLISECOND:\n      case MICROSECOND:\n      case NANOSECOND:\n        if (sqlTypeName == SqlTypeName.DATE) {\n          return Expressions.constant(0L);\n        }\n        operand = mod(operand, TimeUnit.MINUTE.multiplier.longValue());\n        return Expressions.multiply(\n            operand, Expressions.constant((long) (1 / unit.multiplier.doubleValue())));\n      case EPOCH:\n        switch (sqlTypeName) {\n        case DATE:\n          \r\n          operand = Expressions.multiply(operand,\n              Expressions.constant(TimeUnit.DAY.multiplier.longValue()));\n          \r\n        case TIMESTAMP:\n          \r\n          return Expressions.divide(operand,\n              Expressions.constant(TimeUnit.SECOND.multiplier.longValue()));\n        case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n          operand = Expressions.call(\n              BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, translator.getRoot()));\n          return Expressions.divide(operand,\n              Expressions.constant(TimeUnit.SECOND.multiplier.longValue()));\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          \r\n          throw new AssertionError(\"unexpected \" + sqlTypeName);\n        default:\n          break;\n        }\n        break;\n      case HOUR:\n      case MINUTE:\n      case SECOND:\n        switch (sqlTypeName) {\n        case DATE:\n          return Expressions.multiply(operand, Expressions.constant(0L));\n        default:\n          break;\n        }\n        break;\n      }\n\n      operand = mod(operand, getFactor(unit));\n      if (unit == TimeUnit.QUARTER) {\n        operand = Expressions.subtract(operand, Expressions.constant(1L));\n      }\n      operand = Expressions.divide(operand,\n          Expressions.constant(unit.multiplier.longValue()));\n      if (unit == TimeUnit.QUARTER) {\n        operand = Expressions.add(operand, Expressions.constant(1L));\n      }\n      return operand;\n    }\n","date":"2020-11-30 06:45:33","endLine":2391,"groupId":"121809","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"implementSafe","params":"(finalRexToLixTranslatortranslator@finalRexCallcall@finalList<Expression>argValueList)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/42/aae7e106e89f2be0ba56c3bb8a2c1cd31ed0e0.src","preCode":"    @Override Expression implementSafe(final RexToLixTranslator translator,\n        final RexCall call, final List<Expression> argValueList) {\n      final TimeUnitRange timeUnitRange =\n          (TimeUnitRange) translator.getLiteralValue(argValueList.get(0));\n      final TimeUnit unit = timeUnitRange.startUnit;\n      Expression operand = argValueList.get(1);\n      final SqlTypeName sqlTypeName =\n          call.operands.get(1).getType().getSqlTypeName();\n      switch (unit) {\n      case MILLENNIUM:\n      case CENTURY:\n      case YEAR:\n      case QUARTER:\n      case MONTH:\n      case DAY:\n      case DOW:\n      case DECADE:\n      case DOY:\n      case ISODOW:\n      case ISOYEAR:\n      case WEEK:\n        switch (sqlTypeName) {\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          break;\n        case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n          operand = Expressions.call(\n              BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, translator.getRoot()));\n          \r\n        case TIMESTAMP:\n          operand = Expressions.call(BuiltInMethod.FLOOR_DIV.method,\n              operand, Expressions.constant(TimeUnit.DAY.multiplier.longValue()));\n          \r\n        case DATE:\n          return Expressions.call(BuiltInMethod.UNIX_DATE_EXTRACT.method,\n              argValueList.get(0), operand);\n        default:\n          throw new AssertionError(\"unexpected \" + sqlTypeName);\n        }\n        break;\n      case MILLISECOND:\n      case MICROSECOND:\n      case NANOSECOND:\n        if (sqlTypeName == SqlTypeName.DATE) {\n          return Expressions.constant(0L);\n        }\n        operand = mod(operand, TimeUnit.MINUTE.multiplier.longValue());\n        return Expressions.multiply(\n            operand, Expressions.constant((long) (1 / unit.multiplier.doubleValue())));\n      case EPOCH:\n        switch (sqlTypeName) {\n        case DATE:\n          \r\n          operand = Expressions.multiply(operand,\n              Expressions.constant(TimeUnit.DAY.multiplier.longValue()));\n          \r\n        case TIMESTAMP:\n          \r\n          return Expressions.divide(operand,\n              Expressions.constant(TimeUnit.SECOND.multiplier.longValue()));\n        case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n          operand = Expressions.call(\n              BuiltInMethod.TIMESTAMP_WITH_LOCAL_TIME_ZONE_TO_TIMESTAMP.method,\n              operand,\n              Expressions.call(BuiltInMethod.TIME_ZONE.method, translator.getRoot()));\n          return Expressions.divide(operand,\n              Expressions.constant(TimeUnit.SECOND.multiplier.longValue()));\n        case INTERVAL_YEAR:\n        case INTERVAL_YEAR_MONTH:\n        case INTERVAL_MONTH:\n        case INTERVAL_DAY:\n        case INTERVAL_DAY_HOUR:\n        case INTERVAL_DAY_MINUTE:\n        case INTERVAL_DAY_SECOND:\n        case INTERVAL_HOUR:\n        case INTERVAL_HOUR_MINUTE:\n        case INTERVAL_HOUR_SECOND:\n        case INTERVAL_MINUTE:\n        case INTERVAL_MINUTE_SECOND:\n        case INTERVAL_SECOND:\n          \r\n          throw new AssertionError(\"unexpected \" + sqlTypeName);\n        default:\n          break;\n        }\n        break;\n      case HOUR:\n      case MINUTE:\n      case SECOND:\n        switch (sqlTypeName) {\n        case DATE:\n          return Expressions.multiply(operand, Expressions.constant(0L));\n        default:\n          break;\n        }\n        break;\n      }\n\n      operand = mod(operand, getFactor(unit));\n      if (unit == TimeUnit.QUARTER) {\n        operand = Expressions.subtract(operand, Expressions.constant(1L));\n      }\n      operand = Expressions.divide(operand,\n          Expressions.constant(unit.multiplier.longValue()));\n      if (unit == TimeUnit.QUARTER) {\n        operand = Expressions.add(operand, Expressions.constant(1L));\n      }\n      return operand;\n    }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":2270,"status":"M"}],"commitId":"d9a81b88ad561e7e4cedae93e805e0d7a53a7f1a","commitMessage":"@@@[CALCITE-4199] Add nullability annotations\n\nThe commit includes javadoc updates and refactorings made by Julian Hyde in https://github.com/apache/calcite/pull/2278\n","date":"2020-11-30 06:45:33","modifiedFileCount":"1012","status":"M","submitter":"Vladimir Sitnikov"}]
