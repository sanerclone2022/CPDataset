[{"authorTime":"2020-06-09 21:11:34","codes":[{"authorDate":"2020-05-22 08:26:43","commitOrder":11,"curCode":"  public TrimResult trimFields(\n      Calc calc,\n      ImmutableBitSet fieldsUsed,\n      Set<RelDataTypeField> extraFields) {\n    final RexProgram rexProgram = calc.getProgram();\n    final List<RexNode> projs = Lists.transform(rexProgram.getProjectList(),\n        rexProgram::expandLocalRef);\n\n    final RelDataType rowType = calc.getRowType();\n    final int fieldCount = rowType.getFieldCount();\n    final RelNode input = calc.getInput();\n\n    final Set<RelDataTypeField> inputExtraFields =\n        new HashSet<>(extraFields);\n    RelOptUtil.InputFinder inputFinder =\n        new RelOptUtil.InputFinder(inputExtraFields);\n    for (Ord<RexNode> ord : Ord.zip(projs)) {\n      if (fieldsUsed.get(ord.i)) {\n        ord.e.accept(inputFinder);\n      }\n    }\n    ImmutableBitSet inputFieldsUsed = inputFinder.build();\n\n    \r\n    TrimResult trimResult =\n        trimChild(calc, input, inputFieldsUsed, inputExtraFields);\n    RelNode newInput = trimResult.left;\n    final Mapping inputMapping = trimResult.right;\n\n    \r\n    \r\n    if (newInput == input\n        && fieldsUsed.cardinality() == fieldCount) {\n      return result(calc, Mappings.createIdentity(fieldCount));\n    }\n\n    \r\n    \r\n    if (fieldsUsed.cardinality() == 0) {\n      return dummyProject(fieldCount, newInput);\n    }\n\n    \r\n    final List<RexNode> newProjects = new ArrayList<>();\n    final RexVisitor<RexNode> shuttle =\n        new RexPermuteInputsShuttle(\n            inputMapping, newInput);\n    final Mapping mapping =\n        Mappings.create(\n            MappingType.INVERSE_SURJECTION,\n            fieldCount,\n            fieldsUsed.cardinality());\n    for (Ord<RexNode> ord : Ord.zip(projs)) {\n      if (fieldsUsed.get(ord.i)) {\n        mapping.set(ord.i, newProjects.size());\n        RexNode newProjectExpr = ord.e.accept(shuttle);\n        newProjects.add(newProjectExpr);\n      }\n    }\n\n    final RelDataType newRowType =\n        RelOptUtil.permute(calc.getCluster().getTypeFactory(), rowType,\n            mapping);\n\n    final RelNode newInputRelNode = relBuilder.push(newInput).build();\n    RexNode newConditionExpr = null;\n    if (rexProgram.getCondition() != null) {\n      final List<RexNode> filter = Lists.transform(\n          ImmutableList.of(\n              rexProgram.getCondition()), rexProgram::expandLocalRef);\n      assert filter.size() == 1;\n      final RexNode conditionExpr = filter.get(0);\n      newConditionExpr = conditionExpr.accept(shuttle);\n    }\n    final RexProgram newRexProgram = RexProgram.create(newInputRelNode.getRowType(),\n        newProjects, newConditionExpr, newRowType.getFieldNames(),\n        newInputRelNode.getCluster().getRexBuilder());\n    final Calc newCalc = calc.copy(calc.getTraitSet(), newInputRelNode, newRexProgram);\n    return result(newCalc, mapping);\n  }\n","date":"2020-06-18 16:18:48","endLine":440,"groupId":"3526","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"trimFields","params":"(Calccalc@ImmutableBitSetfieldsUsed@Set<RelDataTypeField>extraFields)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/34/a201e3f0343dfa0394677dc0b4b53463e71ff7.src","preCode":"  public TrimResult trimFields(\n      Calc calc,\n      ImmutableBitSet fieldsUsed,\n      Set<RelDataTypeField> extraFields) {\n    final RexProgram rexProgram = calc.getProgram();\n    final List<RexNode> projs = Lists.transform(rexProgram.getProjectList(),\n        rexProgram::expandLocalRef);\n\n    final RelDataType rowType = calc.getRowType();\n    final int fieldCount = rowType.getFieldCount();\n    final RelNode input = calc.getInput();\n\n    final Set<RelDataTypeField> inputExtraFields =\n        new HashSet<>(extraFields);\n    RelOptUtil.InputFinder inputFinder =\n        new RelOptUtil.InputFinder(inputExtraFields);\n    for (Ord<RexNode> ord : Ord.zip(projs)) {\n      if (fieldsUsed.get(ord.i)) {\n        ord.e.accept(inputFinder);\n      }\n    }\n    ImmutableBitSet inputFieldsUsed = inputFinder.build();\n\n    \r\n    TrimResult trimResult =\n        trimChild(calc, input, inputFieldsUsed, inputExtraFields);\n    RelNode newInput = trimResult.left;\n    final Mapping inputMapping = trimResult.right;\n\n    \r\n    \r\n    if (newInput == input\n        && fieldsUsed.cardinality() == fieldCount) {\n      return result(calc, Mappings.createIdentity(fieldCount));\n    }\n\n    \r\n    \r\n    if (fieldsUsed.cardinality() == 0) {\n      return dummyProject(fieldCount, newInput);\n    }\n\n    \r\n    final List<RexNode> newProjects = new ArrayList<>();\n    final RexVisitor<RexNode> shuttle =\n        new RexPermuteInputsShuttle(\n            inputMapping, newInput);\n    final Mapping mapping =\n        Mappings.create(\n            MappingType.INVERSE_SURJECTION,\n            fieldCount,\n            fieldsUsed.cardinality());\n    for (Ord<RexNode> ord : Ord.zip(projs)) {\n      if (fieldsUsed.get(ord.i)) {\n        mapping.set(ord.i, newProjects.size());\n        RexNode newProjectExpr = ord.e.accept(shuttle);\n        newProjects.add(newProjectExpr);\n      }\n    }\n\n    final RelDataType newRowType =\n        RelOptUtil.permute(calc.getCluster().getTypeFactory(), rowType,\n            mapping);\n\n    final RelNode newInputRelNode = relBuilder.push(newInput).build();\n    RexNode newConditionExpr = null;\n    if (rexProgram.getCondition() != null) {\n      final List<RexNode> filter = Lists.transform(\n          ImmutableList.of(\n              rexProgram.getCondition()), rexProgram::expandLocalRef);\n      assert filter.size() == 1;\n      final RexNode conditionExpr = filter.get(0);\n      newConditionExpr = conditionExpr.accept(shuttle);\n    }\n    final RexProgram newRexProgram = RexProgram.create(newInputRelNode.getRowType(),\n        newProjects, newConditionExpr, newRowType.getFieldNames(),\n        newInputRelNode.getCluster().getRexBuilder());\n    final Calc newCalc = calc.copy(calc.getTraitSet(), newInputRelNode, newRexProgram);\n    return result(newCalc, mapping);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":361,"status":"B"},{"authorDate":"2020-06-09 21:11:34","commitOrder":11,"curCode":"  public TrimResult trimFields(\n      Project project,\n      ImmutableBitSet fieldsUsed,\n      Set<RelDataTypeField> extraFields) {\n    final RelDataType rowType = project.getRowType();\n    final int fieldCount = rowType.getFieldCount();\n    final RelNode input = project.getInput();\n\n    \r\n    final Set<RelDataTypeField> inputExtraFields =\n        new LinkedHashSet<>(extraFields);\n    RelOptUtil.InputFinder inputFinder =\n        new RelOptUtil.InputFinder(inputExtraFields);\n    for (Ord<RexNode> ord : Ord.zip(project.getProjects())) {\n      if (fieldsUsed.get(ord.i)) {\n        ord.e.accept(inputFinder);\n      }\n    }\n    ImmutableBitSet inputFieldsUsed = inputFinder.build();\n\n    \r\n    TrimResult trimResult =\n        trimChild(project, input, inputFieldsUsed, inputExtraFields);\n    RelNode newInput = trimResult.left;\n    final Mapping inputMapping = trimResult.right;\n\n    \r\n    \r\n    if (newInput == input\n        && fieldsUsed.cardinality() == fieldCount) {\n      return result(project, Mappings.createIdentity(fieldCount));\n    }\n\n    \r\n    \r\n    if (fieldsUsed.cardinality() == 0) {\n      return dummyProject(fieldCount, newInput, project);\n    }\n\n    \r\n    final List<RexNode> newProjects = new ArrayList<>();\n    final RexVisitor<RexNode> shuttle =\n        new RexPermuteInputsShuttle(\n            inputMapping, newInput);\n    final Mapping mapping =\n        Mappings.create(\n            MappingType.INVERSE_SURJECTION,\n            fieldCount,\n            fieldsUsed.cardinality());\n    for (Ord<RexNode> ord : Ord.zip(project.getProjects())) {\n      if (fieldsUsed.get(ord.i)) {\n        mapping.set(ord.i, newProjects.size());\n        RexNode newProjectExpr = ord.e.accept(shuttle);\n        newProjects.add(newProjectExpr);\n      }\n    }\n\n    final RelDataType newRowType =\n        RelOptUtil.permute(project.getCluster().getTypeFactory(), rowType,\n            mapping);\n\n    relBuilder.push(newInput);\n    relBuilder.project(newProjects, newRowType.getFieldNames());\n    final RelNode newProject = RelOptUtil.propagateRelHints(project, relBuilder.build());\n    return result(newProject, mapping);\n  }\n","date":"2020-06-12 15:19:41","endLine":422,"groupId":"2875","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"trimFields","params":"(Projectproject@ImmutableBitSetfieldsUsed@Set<RelDataTypeField>extraFields)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/0a/4ec01a92e69375dcc2d859e6a35c46dbaf52bf.src","preCode":"  public TrimResult trimFields(\n      Project project,\n      ImmutableBitSet fieldsUsed,\n      Set<RelDataTypeField> extraFields) {\n    final RelDataType rowType = project.getRowType();\n    final int fieldCount = rowType.getFieldCount();\n    final RelNode input = project.getInput();\n\n    \r\n    final Set<RelDataTypeField> inputExtraFields =\n        new LinkedHashSet<>(extraFields);\n    RelOptUtil.InputFinder inputFinder =\n        new RelOptUtil.InputFinder(inputExtraFields);\n    for (Ord<RexNode> ord : Ord.zip(project.getProjects())) {\n      if (fieldsUsed.get(ord.i)) {\n        ord.e.accept(inputFinder);\n      }\n    }\n    ImmutableBitSet inputFieldsUsed = inputFinder.build();\n\n    \r\n    TrimResult trimResult =\n        trimChild(project, input, inputFieldsUsed, inputExtraFields);\n    RelNode newInput = trimResult.left;\n    final Mapping inputMapping = trimResult.right;\n\n    \r\n    \r\n    if (newInput == input\n        && fieldsUsed.cardinality() == fieldCount) {\n      return result(project, Mappings.createIdentity(fieldCount));\n    }\n\n    \r\n    \r\n    if (fieldsUsed.cardinality() == 0) {\n      return dummyProject(fieldCount, newInput, project);\n    }\n\n    \r\n    final List<RexNode> newProjects = new ArrayList<>();\n    final RexVisitor<RexNode> shuttle =\n        new RexPermuteInputsShuttle(\n            inputMapping, newInput);\n    final Mapping mapping =\n        Mappings.create(\n            MappingType.INVERSE_SURJECTION,\n            fieldCount,\n            fieldsUsed.cardinality());\n    for (Ord<RexNode> ord : Ord.zip(project.getProjects())) {\n      if (fieldsUsed.get(ord.i)) {\n        mapping.set(ord.i, newProjects.size());\n        RexNode newProjectExpr = ord.e.accept(shuttle);\n        newProjects.add(newProjectExpr);\n      }\n    }\n\n    final RelDataType newRowType =\n        RelOptUtil.permute(project.getCluster().getTypeFactory(), rowType,\n            mapping);\n\n    relBuilder.push(newInput);\n    relBuilder.project(newProjects, newRowType.getFieldNames());\n    final RelNode newProject = RelOptUtil.propagateRelHints(project, relBuilder.build());\n    return result(newProject, mapping);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":357,"status":"NB"}],"commitId":"d7eb31b91560e34269a097dc720cbe926983bb0c","commitMessage":"@@@[CALCITE-4020] Support Calc operator in RelFieldTrimmer (Xu Zhaohui)\n","date":"2020-06-18 16:18:48","modifiedFileCount":"2","status":"M","submitter":"xzh"},{"authorTime":"2020-06-09 21:11:34","codes":[{"authorDate":"2020-09-26 22:54:58","commitOrder":12,"curCode":"  public TrimResult trimFields(\n      Calc calc,\n      ImmutableBitSet fieldsUsed,\n      Set<RelDataTypeField> extraFields) {\n    final RexProgram rexProgram = calc.getProgram();\n    final List<RexNode> projs = Util.transform(rexProgram.getProjectList(),\n        rexProgram::expandLocalRef);\n\n    final RelDataType rowType = calc.getRowType();\n    final int fieldCount = rowType.getFieldCount();\n    final RelNode input = calc.getInput();\n\n    final Set<RelDataTypeField> inputExtraFields =\n        new HashSet<>(extraFields);\n    RelOptUtil.InputFinder inputFinder =\n        new RelOptUtil.InputFinder(inputExtraFields);\n    for (Ord<RexNode> ord : Ord.zip(projs)) {\n      if (fieldsUsed.get(ord.i)) {\n        ord.e.accept(inputFinder);\n      }\n    }\n    ImmutableBitSet inputFieldsUsed = inputFinder.build();\n\n    \r\n    TrimResult trimResult =\n        trimChild(calc, input, inputFieldsUsed, inputExtraFields);\n    RelNode newInput = trimResult.left;\n    final Mapping inputMapping = trimResult.right;\n\n    \r\n    \r\n    if (newInput == input\n        && fieldsUsed.cardinality() == fieldCount) {\n      return result(calc, Mappings.createIdentity(fieldCount));\n    }\n\n    \r\n    \r\n    if (fieldsUsed.cardinality() == 0) {\n      return dummyProject(fieldCount, newInput);\n    }\n\n    \r\n    final List<RexNode> newProjects = new ArrayList<>();\n    final RexVisitor<RexNode> shuttle =\n        new RexPermuteInputsShuttle(\n            inputMapping, newInput);\n    final Mapping mapping =\n        Mappings.create(\n            MappingType.INVERSE_SURJECTION,\n            fieldCount,\n            fieldsUsed.cardinality());\n    for (Ord<RexNode> ord : Ord.zip(projs)) {\n      if (fieldsUsed.get(ord.i)) {\n        mapping.set(ord.i, newProjects.size());\n        RexNode newProjectExpr = ord.e.accept(shuttle);\n        newProjects.add(newProjectExpr);\n      }\n    }\n\n    final RelDataType newRowType =\n        RelOptUtil.permute(calc.getCluster().getTypeFactory(), rowType,\n            mapping);\n\n    final RelNode newInputRelNode = relBuilder.push(newInput).build();\n    RexNode newConditionExpr = null;\n    if (rexProgram.getCondition() != null) {\n      final List<RexNode> filter = Util.transform(\n          ImmutableList.of(\n              rexProgram.getCondition()), rexProgram::expandLocalRef);\n      assert filter.size() == 1;\n      final RexNode conditionExpr = filter.get(0);\n      newConditionExpr = conditionExpr.accept(shuttle);\n    }\n    final RexProgram newRexProgram = RexProgram.create(newInputRelNode.getRowType(),\n        newProjects, newConditionExpr, newRowType.getFieldNames(),\n        newInputRelNode.getCluster().getRexBuilder());\n    final Calc newCalc = calc.copy(calc.getTraitSet(), newInputRelNode, newRexProgram);\n    return result(newCalc, mapping);\n  }\n","date":"2020-09-30 16:54:11","endLine":439,"groupId":"112172","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"trimFields","params":"(Calccalc@ImmutableBitSetfieldsUsed@Set<RelDataTypeField>extraFields)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/96/e949e3a79f8a591ed62b9f0196ea6c206634f8.src","preCode":"  public TrimResult trimFields(\n      Calc calc,\n      ImmutableBitSet fieldsUsed,\n      Set<RelDataTypeField> extraFields) {\n    final RexProgram rexProgram = calc.getProgram();\n    final List<RexNode> projs = Lists.transform(rexProgram.getProjectList(),\n        rexProgram::expandLocalRef);\n\n    final RelDataType rowType = calc.getRowType();\n    final int fieldCount = rowType.getFieldCount();\n    final RelNode input = calc.getInput();\n\n    final Set<RelDataTypeField> inputExtraFields =\n        new HashSet<>(extraFields);\n    RelOptUtil.InputFinder inputFinder =\n        new RelOptUtil.InputFinder(inputExtraFields);\n    for (Ord<RexNode> ord : Ord.zip(projs)) {\n      if (fieldsUsed.get(ord.i)) {\n        ord.e.accept(inputFinder);\n      }\n    }\n    ImmutableBitSet inputFieldsUsed = inputFinder.build();\n\n    \r\n    TrimResult trimResult =\n        trimChild(calc, input, inputFieldsUsed, inputExtraFields);\n    RelNode newInput = trimResult.left;\n    final Mapping inputMapping = trimResult.right;\n\n    \r\n    \r\n    if (newInput == input\n        && fieldsUsed.cardinality() == fieldCount) {\n      return result(calc, Mappings.createIdentity(fieldCount));\n    }\n\n    \r\n    \r\n    if (fieldsUsed.cardinality() == 0) {\n      return dummyProject(fieldCount, newInput);\n    }\n\n    \r\n    final List<RexNode> newProjects = new ArrayList<>();\n    final RexVisitor<RexNode> shuttle =\n        new RexPermuteInputsShuttle(\n            inputMapping, newInput);\n    final Mapping mapping =\n        Mappings.create(\n            MappingType.INVERSE_SURJECTION,\n            fieldCount,\n            fieldsUsed.cardinality());\n    for (Ord<RexNode> ord : Ord.zip(projs)) {\n      if (fieldsUsed.get(ord.i)) {\n        mapping.set(ord.i, newProjects.size());\n        RexNode newProjectExpr = ord.e.accept(shuttle);\n        newProjects.add(newProjectExpr);\n      }\n    }\n\n    final RelDataType newRowType =\n        RelOptUtil.permute(calc.getCluster().getTypeFactory(), rowType,\n            mapping);\n\n    final RelNode newInputRelNode = relBuilder.push(newInput).build();\n    RexNode newConditionExpr = null;\n    if (rexProgram.getCondition() != null) {\n      final List<RexNode> filter = Lists.transform(\n          ImmutableList.of(\n              rexProgram.getCondition()), rexProgram::expandLocalRef);\n      assert filter.size() == 1;\n      final RexNode conditionExpr = filter.get(0);\n      newConditionExpr = conditionExpr.accept(shuttle);\n    }\n    final RexProgram newRexProgram = RexProgram.create(newInputRelNode.getRowType(),\n        newProjects, newConditionExpr, newRowType.getFieldNames(),\n        newInputRelNode.getCluster().getRexBuilder());\n    final Calc newCalc = calc.copy(calc.getTraitSet(), newInputRelNode, newRexProgram);\n    return result(newCalc, mapping);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":360,"status":"M"},{"authorDate":"2020-06-09 21:11:34","commitOrder":12,"curCode":"  public TrimResult trimFields(\n      Project project,\n      ImmutableBitSet fieldsUsed,\n      Set<RelDataTypeField> extraFields) {\n    final RelDataType rowType = project.getRowType();\n    final int fieldCount = rowType.getFieldCount();\n    final RelNode input = project.getInput();\n\n    \r\n    final Set<RelDataTypeField> inputExtraFields =\n        new LinkedHashSet<>(extraFields);\n    RelOptUtil.InputFinder inputFinder =\n        new RelOptUtil.InputFinder(inputExtraFields);\n    for (Ord<RexNode> ord : Ord.zip(project.getProjects())) {\n      if (fieldsUsed.get(ord.i)) {\n        ord.e.accept(inputFinder);\n      }\n    }\n    ImmutableBitSet inputFieldsUsed = inputFinder.build();\n\n    \r\n    TrimResult trimResult =\n        trimChild(project, input, inputFieldsUsed, inputExtraFields);\n    RelNode newInput = trimResult.left;\n    final Mapping inputMapping = trimResult.right;\n\n    \r\n    \r\n    if (newInput == input\n        && fieldsUsed.cardinality() == fieldCount) {\n      return result(project, Mappings.createIdentity(fieldCount));\n    }\n\n    \r\n    \r\n    if (fieldsUsed.cardinality() == 0) {\n      return dummyProject(fieldCount, newInput, project);\n    }\n\n    \r\n    final List<RexNode> newProjects = new ArrayList<>();\n    final RexVisitor<RexNode> shuttle =\n        new RexPermuteInputsShuttle(\n            inputMapping, newInput);\n    final Mapping mapping =\n        Mappings.create(\n            MappingType.INVERSE_SURJECTION,\n            fieldCount,\n            fieldsUsed.cardinality());\n    for (Ord<RexNode> ord : Ord.zip(project.getProjects())) {\n      if (fieldsUsed.get(ord.i)) {\n        mapping.set(ord.i, newProjects.size());\n        RexNode newProjectExpr = ord.e.accept(shuttle);\n        newProjects.add(newProjectExpr);\n      }\n    }\n\n    final RelDataType newRowType =\n        RelOptUtil.permute(project.getCluster().getTypeFactory(), rowType,\n            mapping);\n\n    relBuilder.push(newInput);\n    relBuilder.project(newProjects, newRowType.getFieldNames());\n    final RelNode newProject = RelOptUtil.propagateRelHints(project, relBuilder.build());\n    return result(newProject, mapping);\n  }\n","date":"2020-06-12 15:19:41","endLine":422,"groupId":"112172","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"trimFields","params":"(Projectproject@ImmutableBitSetfieldsUsed@Set<RelDataTypeField>extraFields)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/0a/4ec01a92e69375dcc2d859e6a35c46dbaf52bf.src","preCode":"  public TrimResult trimFields(\n      Project project,\n      ImmutableBitSet fieldsUsed,\n      Set<RelDataTypeField> extraFields) {\n    final RelDataType rowType = project.getRowType();\n    final int fieldCount = rowType.getFieldCount();\n    final RelNode input = project.getInput();\n\n    \r\n    final Set<RelDataTypeField> inputExtraFields =\n        new LinkedHashSet<>(extraFields);\n    RelOptUtil.InputFinder inputFinder =\n        new RelOptUtil.InputFinder(inputExtraFields);\n    for (Ord<RexNode> ord : Ord.zip(project.getProjects())) {\n      if (fieldsUsed.get(ord.i)) {\n        ord.e.accept(inputFinder);\n      }\n    }\n    ImmutableBitSet inputFieldsUsed = inputFinder.build();\n\n    \r\n    TrimResult trimResult =\n        trimChild(project, input, inputFieldsUsed, inputExtraFields);\n    RelNode newInput = trimResult.left;\n    final Mapping inputMapping = trimResult.right;\n\n    \r\n    \r\n    if (newInput == input\n        && fieldsUsed.cardinality() == fieldCount) {\n      return result(project, Mappings.createIdentity(fieldCount));\n    }\n\n    \r\n    \r\n    if (fieldsUsed.cardinality() == 0) {\n      return dummyProject(fieldCount, newInput, project);\n    }\n\n    \r\n    final List<RexNode> newProjects = new ArrayList<>();\n    final RexVisitor<RexNode> shuttle =\n        new RexPermuteInputsShuttle(\n            inputMapping, newInput);\n    final Mapping mapping =\n        Mappings.create(\n            MappingType.INVERSE_SURJECTION,\n            fieldCount,\n            fieldsUsed.cardinality());\n    for (Ord<RexNode> ord : Ord.zip(project.getProjects())) {\n      if (fieldsUsed.get(ord.i)) {\n        mapping.set(ord.i, newProjects.size());\n        RexNode newProjectExpr = ord.e.accept(shuttle);\n        newProjects.add(newProjectExpr);\n      }\n    }\n\n    final RelDataType newRowType =\n        RelOptUtil.permute(project.getCluster().getTypeFactory(), rowType,\n            mapping);\n\n    relBuilder.push(newInput);\n    relBuilder.project(newProjects, newRowType.getFieldNames());\n    final RelNode newProject = RelOptUtil.propagateRelHints(project, relBuilder.build());\n    return result(newProject, mapping);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":357,"status":"N"}],"commitId":"a79dde6383325bc34bc3d92ee32176c59579221a","commitMessage":"@@@[CALCITE-4280] Replace Guava's Lists.transform and Iterables.transform with Util.transform\n","date":"2020-09-30 16:54:11","modifiedFileCount":"57","status":"M","submitter":"Vladimir Sitnikov"}]
