[{"authorTime":"2017-03-10 20:53:51","codes":[{"authorDate":"2017-03-10 20:53:51","commitOrder":1,"curCode":"  public Set<RexNode> getExpressionLineage(Aggregate rel,\n      RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = rel.getInput();\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n\n    \r\n    final Set<RelDataTypeField> inputExtraFields = new LinkedHashSet<>();\n    final RelOptUtil.InputFinder inputFinder = new RelOptUtil.InputFinder(inputExtraFields);\n    outputExpression.accept(inputFinder);\n    final ImmutableBitSet inputFieldsUsed = inputFinder.inputBitSet.build();\n\n    for (int idx : inputFieldsUsed) {\n      if (idx >= rel.getGroupCount()) {\n        \r\n        return null;\n      }\n    }\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexInputRef inputRef = RexInputRef.of(rel.getGroupSet().nth(idx),\n          input.getRowType().getFieldList());\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputRef);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","date":"2017-04-27 02:56:37","endLine":176,"groupId":"15828","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"getExpressionLineage","params":"(Aggregaterel@RelMetadataQuerymq@RexNodeoutputExpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/5f/9e5ba66b294c64ad4c872ea03c58104987c5ea.src","preCode":"  public Set<RexNode> getExpressionLineage(Aggregate rel,\n      RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = rel.getInput();\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n\n    \r\n    final Set<RelDataTypeField> inputExtraFields = new LinkedHashSet<>();\n    final RelOptUtil.InputFinder inputFinder = new RelOptUtil.InputFinder(inputExtraFields);\n    outputExpression.accept(inputFinder);\n    final ImmutableBitSet inputFieldsUsed = inputFinder.inputBitSet.build();\n\n    for (int idx : inputFieldsUsed) {\n      if (idx >= rel.getGroupCount()) {\n        \r\n        return null;\n      }\n    }\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexInputRef inputRef = RexInputRef.of(rel.getGroupSet().nth(idx),\n          input.getRowType().getFieldList());\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputRef);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/metadata/RelMdExpressionLineage.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":142,"status":"B"},{"authorDate":"2017-03-10 20:53:51","commitOrder":1,"curCode":"  public Set<RexNode> getExpressionLineage(Project rel,\n      final RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = rel.getInput();\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n\n    \r\n    final Set<RelDataTypeField> inputExtraFields = new LinkedHashSet<>();\n    final RelOptUtil.InputFinder inputFinder = new RelOptUtil.InputFinder(inputExtraFields);\n    outputExpression.accept(inputFinder);\n    final ImmutableBitSet inputFieldsUsed = inputFinder.inputBitSet.build();\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexNode inputExpr = rel.getChildExps().get(idx);\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputExpr);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","date":"2017-04-27 02:56:37","endLine":347,"groupId":"8569","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getExpressionLineage","params":"(Projectrel@finalRelMetadataQuerymq@RexNodeoutputExpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/5f/9e5ba66b294c64ad4c872ea03c58104987c5ea.src","preCode":"  public Set<RexNode> getExpressionLineage(Project rel,\n      final RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = rel.getInput();\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n\n    \r\n    final Set<RelDataTypeField> inputExtraFields = new LinkedHashSet<>();\n    final RelOptUtil.InputFinder inputFinder = new RelOptUtil.InputFinder(inputExtraFields);\n    outputExpression.accept(inputFinder);\n    final ImmutableBitSet inputFieldsUsed = inputFinder.inputBitSet.build();\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexNode inputExpr = rel.getChildExps().get(idx);\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputExpr);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/metadata/RelMdExpressionLineage.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":321,"status":"B"}],"commitId":"41b05d784fd2e0ae81b09d013ef8a746036ca446","commitMessage":"@@@[CALCITE-1682] New metadata providers for expression column origin and all predicates in plan\n\nIncludes:\n* RelNode type metadata provider\n* Ranges containment-based simplification in conjunctive predicates\n","date":"2017-04-27 02:56:37","modifiedFileCount":"16","status":"B","submitter":"Jesus Camacho Rodriguez"},{"authorTime":"2018-11-14 00:42:35","codes":[{"authorDate":"2018-11-14 00:42:35","commitOrder":2,"curCode":"  public Set<RexNode> getExpressionLineage(Aggregate rel,\n      RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = rel.getInput();\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n\n    \r\n    final ImmutableBitSet inputFieldsUsed = extractInputRefs(outputExpression);\n\n    for (int idx : inputFieldsUsed) {\n      if (idx >= rel.getGroupCount()) {\n        \r\n        return null;\n      }\n    }\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexInputRef inputRef = RexInputRef.of(rel.getGroupSet().nth(idx),\n          input.getRowType().getFieldList());\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputRef);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","date":"2018-11-14 00:42:52","endLine":171,"groupId":"15828","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"getExpressionLineage","params":"(Aggregaterel@RelMetadataQuerymq@RexNodeoutputExpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/fc/bf571a68b552ff661d1670a32a16809cf4c59a.src","preCode":"  public Set<RexNode> getExpressionLineage(Aggregate rel,\n      RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = rel.getInput();\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n\n    \r\n    final Set<RelDataTypeField> inputExtraFields = new LinkedHashSet<>();\n    final RelOptUtil.InputFinder inputFinder = new RelOptUtil.InputFinder(inputExtraFields);\n    outputExpression.accept(inputFinder);\n    final ImmutableBitSet inputFieldsUsed = inputFinder.inputBitSet.build();\n\n    for (int idx : inputFieldsUsed) {\n      if (idx >= rel.getGroupCount()) {\n        \r\n        return null;\n      }\n    }\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexInputRef inputRef = RexInputRef.of(rel.getGroupSet().nth(idx),\n          input.getRowType().getFieldList());\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputRef);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/metadata/RelMdExpressionLineage.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":140,"status":"M"},{"authorDate":"2018-11-14 00:42:35","commitOrder":2,"curCode":"  public Set<RexNode> getExpressionLineage(Project rel,\n      final RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = rel.getInput();\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n\n    \r\n    final ImmutableBitSet inputFieldsUsed = extractInputRefs(outputExpression);\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexNode inputExpr = rel.getChildExps().get(idx);\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputExpr);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","date":"2018-11-14 00:42:52","endLine":365,"groupId":"8569","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getExpressionLineage","params":"(Projectrel@finalRelMetadataQuerymq@RexNodeoutputExpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/fc/bf571a68b552ff661d1670a32a16809cf4c59a.src","preCode":"  public Set<RexNode> getExpressionLineage(Project rel,\n      final RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = rel.getInput();\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n\n    \r\n    final Set<RelDataTypeField> inputExtraFields = new LinkedHashSet<>();\n    final RelOptUtil.InputFinder inputFinder = new RelOptUtil.InputFinder(inputExtraFields);\n    outputExpression.accept(inputFinder);\n    final ImmutableBitSet inputFieldsUsed = inputFinder.inputBitSet.build();\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexNode inputExpr = rel.getChildExps().get(idx);\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputExpr);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/metadata/RelMdExpressionLineage.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":342,"status":"M"}],"commitId":"81a9bd783e2cc8a34e7a175b09cfd0b77dbf334a","commitMessage":"@@@[CALCITE-2668] Support for left/right outer join in RelMdExpressionLineage\n","date":"2018-11-14 00:42:52","modifiedFileCount":"4","status":"M","submitter":"Jesus Camacho Rodriguez"},{"authorTime":"2020-06-09 21:16:22","codes":[{"authorDate":"2018-11-14 00:42:35","commitOrder":3,"curCode":"  public Set<RexNode> getExpressionLineage(Aggregate rel,\n      RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = rel.getInput();\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n\n    \r\n    final ImmutableBitSet inputFieldsUsed = extractInputRefs(outputExpression);\n\n    for (int idx : inputFieldsUsed) {\n      if (idx >= rel.getGroupCount()) {\n        \r\n        return null;\n      }\n    }\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexInputRef inputRef = RexInputRef.of(rel.getGroupSet().nth(idx),\n          input.getRowType().getFieldList());\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputRef);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","date":"2018-11-14 00:42:52","endLine":171,"groupId":"15828","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"getExpressionLineage","params":"(Aggregaterel@RelMetadataQuerymq@RexNodeoutputExpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/fc/bf571a68b552ff661d1670a32a16809cf4c59a.src","preCode":"  public Set<RexNode> getExpressionLineage(Aggregate rel,\n      RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = rel.getInput();\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n\n    \r\n    final ImmutableBitSet inputFieldsUsed = extractInputRefs(outputExpression);\n\n    for (int idx : inputFieldsUsed) {\n      if (idx >= rel.getGroupCount()) {\n        \r\n        return null;\n      }\n    }\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexInputRef inputRef = RexInputRef.of(rel.getGroupSet().nth(idx),\n          input.getRowType().getFieldList());\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputRef);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/metadata/RelMdExpressionLineage.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":140,"status":"N"},{"authorDate":"2020-06-09 21:16:22","commitOrder":3,"curCode":"  public Set<RexNode> getExpressionLineage(Project rel,\n      final RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = rel.getInput();\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n\n    \r\n    final ImmutableBitSet inputFieldsUsed = extractInputRefs(outputExpression);\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexNode inputExpr = rel.getProjects().get(idx);\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputExpr);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","date":"2020-06-16 11:11:13","endLine":376,"groupId":"7627","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"getExpressionLineage","params":"(Projectrel@finalRelMetadataQuerymq@RexNodeoutputExpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/6a/ba8b3879d97c0ce10a4681da4ac44fdd0e9d8f.src","preCode":"  public Set<RexNode> getExpressionLineage(Project rel,\n      final RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = rel.getInput();\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n\n    \r\n    final ImmutableBitSet inputFieldsUsed = extractInputRefs(outputExpression);\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexNode inputExpr = rel.getChildExps().get(idx);\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputExpr);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/metadata/RelMdExpressionLineage.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":353,"status":"M"}],"commitId":"69f25863f5f4197c17927a39a82cbf1cffd12b80","commitMessage":"@@@[CALCITE-3786] Add Digest interface to enable efficient hashCode(equals) for RexNode and RelNode\n\n* Add class Digest used to identify the node;\n* There is a pre-computed hashcode to speedup #hashCode and #equals;\n* Change RexCall to use object#equals instead of pure string digest\ncomparison;\n* We only support RexInputRef normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing complicated. \nRexNode can always be normalized(default true).\n","date":"2020-06-16 11:11:13","modifiedFileCount":"51","status":"M","submitter":"yuzhao.cyz"},{"authorTime":"2020-05-29 00:04:40","codes":[{"authorDate":"2020-05-29 00:04:40","commitOrder":4,"curCode":"  public @Nullable Set<RexNode> getExpressionLineage(Aggregate rel,\n      RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = rel.getInput();\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n\n    \r\n    final ImmutableBitSet inputFieldsUsed = extractInputRefs(outputExpression);\n\n    for (int idx : inputFieldsUsed) {\n      if (idx >= rel.getGroupCount()) {\n        \r\n        return null;\n      }\n    }\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexInputRef inputRef = RexInputRef.of(rel.getGroupSet().nth(idx),\n          input.getRowType().getFieldList());\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputRef);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","date":"2020-11-30 06:45:33","endLine":185,"groupId":"111954","id":7,"instanceNumber":1,"isCurCommit":1,"methodName":"getExpressionLineage","params":"(Aggregaterel@RelMetadataQuerymq@RexNodeoutputExpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/43/be0ac23a8334ce5ec957a1175aa4f314a52b8b.src","preCode":"  public Set<RexNode> getExpressionLineage(Aggregate rel,\n      RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = rel.getInput();\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n\n    \r\n    final ImmutableBitSet inputFieldsUsed = extractInputRefs(outputExpression);\n\n    for (int idx : inputFieldsUsed) {\n      if (idx >= rel.getGroupCount()) {\n        \r\n        return null;\n      }\n    }\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexInputRef inputRef = RexInputRef.of(rel.getGroupSet().nth(idx),\n          input.getRowType().getFieldList());\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputRef);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/metadata/RelMdExpressionLineage.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":154,"status":"M"},{"authorDate":"2020-05-29 00:04:40","commitOrder":4,"curCode":"  public @Nullable Set<RexNode> getExpressionLineage(Project rel,\n      final RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = rel.getInput();\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n\n    \r\n    final ImmutableBitSet inputFieldsUsed = extractInputRefs(outputExpression);\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexNode inputExpr = rel.getProjects().get(idx);\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputExpr);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","date":"2020-11-30 06:45:33","endLine":385,"groupId":"111954","id":8,"instanceNumber":2,"isCurCommit":1,"methodName":"getExpressionLineage","params":"(Projectrel@finalRelMetadataQuerymq@RexNodeoutputExpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/43/be0ac23a8334ce5ec957a1175aa4f314a52b8b.src","preCode":"  public Set<RexNode> getExpressionLineage(Project rel,\n      final RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = rel.getInput();\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n\n    \r\n    final ImmutableBitSet inputFieldsUsed = extractInputRefs(outputExpression);\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexNode inputExpr = rel.getProjects().get(idx);\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputExpr);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/metadata/RelMdExpressionLineage.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":362,"status":"M"}],"commitId":"d9a81b88ad561e7e4cedae93e805e0d7a53a7f1a","commitMessage":"@@@[CALCITE-4199] Add nullability annotations\n\nThe commit includes javadoc updates and refactorings made by Julian Hyde in https://github.com/apache/calcite/pull/2278\n","date":"2020-11-30 06:45:33","modifiedFileCount":"1012","status":"M","submitter":"Vladimir Sitnikov"}]
