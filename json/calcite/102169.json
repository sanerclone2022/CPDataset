[{"authorTime":"2019-07-12 00:48:24","codes":[{"authorDate":"2019-07-12 00:48:24","commitOrder":7,"curCode":"  private void flattenProjection(RewriteRexShuttle shuttle,\n      RexNode exp,\n      String fieldName,\n      List<Pair<RexNode, String>> flattenedExps) {\n    if (exp.getType().isStruct()) {\n      if (exp instanceof RexInputRef) {\n        final int oldOrdinal = ((RexInputRef) exp).getIndex();\n        final int flattenFieldsCount = postFlattenSize(exp.getType());\n        for (int innerOrdinal = 0; innerOrdinal < flattenFieldsCount; innerOrdinal++) {\n          Ord<RelDataType> newField = getNewFieldForOldInput(oldOrdinal, innerOrdinal);\n          RexInputRef newRef = new RexInputRef(newField.i, newField.e);\n          flattenedExps.add(Pair.of(newRef, fieldName));\n        }\n      } else if (isConstructor(exp) || exp.isA(SqlKind.CAST)) {\n        \r\n        \r\n        RexCall call = (RexCall) exp;\n        if (exp.isA(SqlKind.CAST)\n            && RexLiteral.isNullLiteral(call.operands.get(0))) {\n          \r\n          \r\n          flattenNullLiteral(exp.getType(), flattenedExps);\n          return;\n        }\n        flattenProjections(shuttle,\n            call.getOperands(),\n            Collections.nCopies(call.getOperands().size(), null),\n            fieldName,\n            flattenedExps);\n      } else if (exp instanceof RexCall) {\n        \r\n        \r\n        RexNode newExp = exp;\n        List<RexNode> operands = ((RexCall) exp).getOperands();\n        SqlOperator operator = ((RexCall) exp).getOperator();\n\n        if (operator == SqlStdOperatorTable.ITEM\n            && operands.get(0).getType().isStruct()\n            && operands.get(1).isA(SqlKind.LITERAL)\n            && SqlTypeUtil.inCharFamily(operands.get(1).getType())) {\n          String literalString = ((RexLiteral) operands.get(1)).getValueAs(String.class);\n          RexNode firstOp = operands.get(0);\n\n          if (firstOp instanceof RexInputRef) {\n            \r\n            \r\n            \r\n            \r\n            int from = 0;\n            for (RelDataTypeField field : firstOp.getType().getFieldList()) {\n              if (literalString.equalsIgnoreCase(field.getName())) {\n                int oldOrdinal = ((RexInputRef) firstOp).getIndex();\n                int to = from + postFlattenSize(field.getType());\n                for (int newInnerOrdinal = from; newInnerOrdinal < to; newInnerOrdinal++) {\n                  Ord<RelDataType> newField = getNewFieldForOldInput(oldOrdinal, newInnerOrdinal);\n                  RexInputRef newRef = rexBuilder.makeInputRef(newField.e, newField.i);\n                  flattenedExps.add(Pair.of(newRef, fieldName));\n                }\n                break;\n              } else {\n                from += postFlattenSize(field.getType());\n              }\n            }\n          } else if (firstOp instanceof RexCall) {\n            \r\n            \r\n            \r\n            List<Pair<RexNode, String>> firstOpFlattenedExps = new ArrayList<>();\n            flattenProjection(shuttle, firstOp, fieldName + \"$0\", firstOpFlattenedExps);\n            int newInnerOrdinal = getNewInnerOrdinal(firstOp, literalString);\n            int endOfRange = newInnerOrdinal + postFlattenSize(newExp.getType());\n            for (int i = newInnerOrdinal; i < endOfRange; i++) {\n              flattenedExps.add(firstOpFlattenedExps.get(i));\n            }\n          }\n        } else {\n          List<RexNode> newOperands = operands.stream()\n              .map(op -> op.accept(shuttle))\n              .collect(Collectors.toList());\n          newExp = rexBuilder.makeCall(exp.getType(), operator, newOperands);\n          \r\n          flattenResultTypeOfRexCall(newExp, fieldName, flattenedExps);\n        }\n      } else {\n        throw Util.needToImplement(exp);\n      }\n    } else {\n      flattenedExps.add(\n          Pair.of(exp.accept(shuttle), fieldName));\n    }\n  }\n","date":"2019-08-22 02:13:24","endLine":669,"groupId":"1244","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"flattenProjection","params":"(RewriteRexShuttleshuttle@RexNodeexp@StringfieldName@List<Pair<RexNode@String>>flattenedExps)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/fc/fe6ab0f0d948abf732e50f8f7d27713b030f1d.src","preCode":"  private void flattenProjection(RewriteRexShuttle shuttle,\n      RexNode exp,\n      String fieldName,\n      List<Pair<RexNode, String>> flattenedExps) {\n    if (exp.getType().isStruct()) {\n      if (exp instanceof RexInputRef) {\n        final int oldOrdinal = ((RexInputRef) exp).getIndex();\n        final int flattenFieldsCount = postFlattenSize(exp.getType());\n        for (int innerOrdinal = 0; innerOrdinal < flattenFieldsCount; innerOrdinal++) {\n          Ord<RelDataType> newField = getNewFieldForOldInput(oldOrdinal, innerOrdinal);\n          RexInputRef newRef = new RexInputRef(newField.i, newField.e);\n          flattenedExps.add(Pair.of(newRef, fieldName));\n        }\n      } else if (isConstructor(exp) || exp.isA(SqlKind.CAST)) {\n        \r\n        \r\n        RexCall call = (RexCall) exp;\n        if (exp.isA(SqlKind.CAST)\n            && RexLiteral.isNullLiteral(call.operands.get(0))) {\n          \r\n          \r\n          flattenNullLiteral(exp.getType(), flattenedExps);\n          return;\n        }\n        flattenProjections(shuttle,\n            call.getOperands(),\n            Collections.nCopies(call.getOperands().size(), null),\n            fieldName,\n            flattenedExps);\n      } else if (exp instanceof RexCall) {\n        \r\n        \r\n        RexNode newExp = exp;\n        List<RexNode> operands = ((RexCall) exp).getOperands();\n        SqlOperator operator = ((RexCall) exp).getOperator();\n\n        if (operator == SqlStdOperatorTable.ITEM\n            && operands.get(0).getType().isStruct()\n            && operands.get(1).isA(SqlKind.LITERAL)\n            && SqlTypeUtil.inCharFamily(operands.get(1).getType())) {\n          String literalString = ((RexLiteral) operands.get(1)).getValueAs(String.class);\n          RexNode firstOp = operands.get(0);\n\n          if (firstOp instanceof RexInputRef) {\n            \r\n            \r\n            \r\n            \r\n            int from = 0;\n            for (RelDataTypeField field : firstOp.getType().getFieldList()) {\n              if (literalString.equalsIgnoreCase(field.getName())) {\n                int oldOrdinal = ((RexInputRef) firstOp).getIndex();\n                int to = from + postFlattenSize(field.getType());\n                for (int newInnerOrdinal = from; newInnerOrdinal < to; newInnerOrdinal++) {\n                  Ord<RelDataType> newField = getNewFieldForOldInput(oldOrdinal, newInnerOrdinal);\n                  RexInputRef newRef = rexBuilder.makeInputRef(newField.e, newField.i);\n                  flattenedExps.add(Pair.of(newRef, fieldName));\n                }\n                break;\n              } else {\n                from += postFlattenSize(field.getType());\n              }\n            }\n          } else if (firstOp instanceof RexCall) {\n            \r\n            \r\n            \r\n            List<Pair<RexNode, String>> firstOpFlattenedExps = new ArrayList<>();\n            flattenProjection(shuttle, firstOp, fieldName + \"$0\", firstOpFlattenedExps);\n            int newInnerOrdinal = getNewInnerOrdinal(firstOp, literalString);\n            int endOfRange = newInnerOrdinal + postFlattenSize(newExp.getType());\n            for (int i = newInnerOrdinal; i < endOfRange; i++) {\n              flattenedExps.add(firstOpFlattenedExps.get(i));\n            }\n          }\n        } else {\n          List<RexNode> newOperands = operands.stream()\n              .map(op -> op.accept(shuttle))\n              .collect(Collectors.toList());\n          newExp = rexBuilder.makeCall(exp.getType(), operator, newOperands);\n          \r\n          flattenResultTypeOfRexCall(newExp, fieldName, flattenedExps);\n        }\n      } else {\n        throw Util.needToImplement(exp);\n      }\n    } else {\n      flattenedExps.add(\n          Pair.of(exp.accept(shuttle), fieldName));\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql2rel/RelStructuredTypeFlattener.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":579,"status":"MB"},{"authorDate":"2019-07-12 00:48:24","commitOrder":7,"curCode":"  private int getNewInnerOrdinal(RexNode firstOp, String literalString) {\n    int newInnerOrdinal = 0;\n    for (RelDataTypeField field : firstOp.getType().getFieldList()) {\n      if (literalString.equalsIgnoreCase(field.getName())) {\n        break;\n      } else {\n        newInnerOrdinal += postFlattenSize(field.getType());\n      }\n    }\n    return newInnerOrdinal;\n  }\n","date":"2019-08-22 02:13:24","endLine":984,"groupId":"23","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getNewInnerOrdinal","params":"(RexNodefirstOp@StringliteralString)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/fc/fe6ab0f0d948abf732e50f8f7d27713b030f1d.src","preCode":"  private int getNewInnerOrdinal(RexNode firstOp, String literalString) {\n    int newInnerOrdinal = 0;\n    for (RelDataTypeField field : firstOp.getType().getFieldList()) {\n      if (literalString.equalsIgnoreCase(field.getName())) {\n        break;\n      } else {\n        newInnerOrdinal += postFlattenSize(field.getType());\n      }\n    }\n    return newInnerOrdinal;\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql2rel/RelStructuredTypeFlattener.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":974,"status":"B"}],"commitId":"1e62d3d64fc217d14016702237b4f8d56b3683f2","commitMessage":"@@@[CALCITE-3138] RelStructuredTypeFlattener doesn't restructure ROW type fields (Igor Guzenko)\n\nClose #1374\n","date":"2019-08-22 02:13:24","modifiedFileCount":"7","status":"M","submitter":"Igor Guzenko"},{"authorTime":"2019-07-12 00:48:24","codes":[{"authorDate":"2020-05-30 01:18:58","commitOrder":8,"curCode":"  private void flattenProjection(RewriteRexShuttle shuttle,\n      RexNode exp,\n      String fieldName,\n      List<Pair<RexNode, String>> flattenedExps) {\n    if (exp.getType().isStruct()) {\n      if (exp instanceof RexInputRef) {\n        final int oldOrdinal = ((RexInputRef) exp).getIndex();\n        final int flattenFieldsCount = postFlattenSize(exp.getType());\n        for (int innerOrdinal = 0; innerOrdinal < flattenFieldsCount; innerOrdinal++) {\n          Ord<RelDataType> newField = getNewFieldForOldInput(oldOrdinal, innerOrdinal);\n          RexInputRef newRef = new RexInputRef(newField.i, newField.e);\n          flattenedExps.add(Pair.of(newRef, fieldName));\n        }\n      } else if (isConstructor(exp) || exp.isA(SqlKind.CAST)) {\n        \r\n        \r\n        RexCall call = (RexCall) exp;\n        if (exp.isA(SqlKind.CAST)\n            && RexLiteral.isNullLiteral(call.operands.get(0))) {\n          \r\n          \r\n          flattenNullLiteral(exp.getType(), flattenedExps);\n          return;\n        }\n        flattenProjections(shuttle,\n            call.getOperands(),\n            Collections.nCopies(call.getOperands().size(), null),\n            fieldName,\n            flattenedExps);\n      } else if (exp instanceof RexCall) {\n        \r\n        \r\n        RexNode newExp = exp;\n        List<RexNode> operands = ((RexCall) exp).getOperands();\n        SqlOperator operator = ((RexCall) exp).getOperator();\n\n        if (operator == SqlStdOperatorTable.ITEM\n            && operands.get(0).getType().isStruct()\n            && operands.get(1).isA(SqlKind.LITERAL)\n            && SqlTypeUtil.inCharFamily(operands.get(1).getType())) {\n          String literalString = ((RexLiteral) operands.get(1)).getValueAs(String.class);\n          RexNode firstOp = operands.get(0);\n\n          if (firstOp instanceof RexInputRef) {\n            \r\n            \r\n            \r\n            \r\n            int from = 0;\n            for (RelDataTypeField field : firstOp.getType().getFieldList()) {\n              if (literalString.equalsIgnoreCase(field.getName())) {\n                int oldOrdinal = ((RexInputRef) firstOp).getIndex();\n                int to = from + postFlattenSize(field.getType());\n                for (int newInnerOrdinal = from; newInnerOrdinal < to; newInnerOrdinal++) {\n                  Ord<RelDataType> newField = getNewFieldForOldInput(oldOrdinal, newInnerOrdinal);\n                  RexInputRef newRef = rexBuilder.makeInputRef(newField.e, newField.i);\n                  flattenedExps.add(Pair.of(newRef, fieldName));\n                }\n                break;\n              } else {\n                from += postFlattenSize(field.getType());\n              }\n            }\n          } else if (firstOp instanceof RexCall) {\n            \r\n            \r\n            \r\n            List<Pair<RexNode, String>> firstOpFlattenedExps = new ArrayList<>();\n            flattenProjection(shuttle, firstOp, fieldName + \"$0\", firstOpFlattenedExps);\n            int newInnerOrdinal = getNewInnerOrdinal(firstOp, literalString);\n            int endOfRange = newInnerOrdinal + postFlattenSize(newExp.getType());\n            for (int i = newInnerOrdinal; i < endOfRange; i++) {\n              flattenedExps.add(firstOpFlattenedExps.get(i));\n            }\n          }\n        } else {\n          newExp = rexBuilder.makeCall(exp.getType(), operator,\n              shuttle.visitList(operands));\n          \r\n          flattenResultTypeOfRexCall(newExp, fieldName, flattenedExps);\n        }\n      } else {\n        throw Util.needToImplement(exp);\n      }\n    } else {\n      flattenedExps.add(\n          Pair.of(exp.accept(shuttle), fieldName));\n    }\n  }\n","date":"2020-06-12 02:23:07","endLine":702,"groupId":"1244","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"flattenProjection","params":"(RewriteRexShuttleshuttle@RexNodeexp@StringfieldName@List<Pair<RexNode@String>>flattenedExps)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/1e/9ba3d6d13fa3d02dd4d1ce48091c7e6953f7ee.src","preCode":"  private void flattenProjection(RewriteRexShuttle shuttle,\n      RexNode exp,\n      String fieldName,\n      List<Pair<RexNode, String>> flattenedExps) {\n    if (exp.getType().isStruct()) {\n      if (exp instanceof RexInputRef) {\n        final int oldOrdinal = ((RexInputRef) exp).getIndex();\n        final int flattenFieldsCount = postFlattenSize(exp.getType());\n        for (int innerOrdinal = 0; innerOrdinal < flattenFieldsCount; innerOrdinal++) {\n          Ord<RelDataType> newField = getNewFieldForOldInput(oldOrdinal, innerOrdinal);\n          RexInputRef newRef = new RexInputRef(newField.i, newField.e);\n          flattenedExps.add(Pair.of(newRef, fieldName));\n        }\n      } else if (isConstructor(exp) || exp.isA(SqlKind.CAST)) {\n        \r\n        \r\n        RexCall call = (RexCall) exp;\n        if (exp.isA(SqlKind.CAST)\n            && RexLiteral.isNullLiteral(call.operands.get(0))) {\n          \r\n          \r\n          flattenNullLiteral(exp.getType(), flattenedExps);\n          return;\n        }\n        flattenProjections(shuttle,\n            call.getOperands(),\n            Collections.nCopies(call.getOperands().size(), null),\n            fieldName,\n            flattenedExps);\n      } else if (exp instanceof RexCall) {\n        \r\n        \r\n        RexNode newExp = exp;\n        List<RexNode> operands = ((RexCall) exp).getOperands();\n        SqlOperator operator = ((RexCall) exp).getOperator();\n\n        if (operator == SqlStdOperatorTable.ITEM\n            && operands.get(0).getType().isStruct()\n            && operands.get(1).isA(SqlKind.LITERAL)\n            && SqlTypeUtil.inCharFamily(operands.get(1).getType())) {\n          String literalString = ((RexLiteral) operands.get(1)).getValueAs(String.class);\n          RexNode firstOp = operands.get(0);\n\n          if (firstOp instanceof RexInputRef) {\n            \r\n            \r\n            \r\n            \r\n            int from = 0;\n            for (RelDataTypeField field : firstOp.getType().getFieldList()) {\n              if (literalString.equalsIgnoreCase(field.getName())) {\n                int oldOrdinal = ((RexInputRef) firstOp).getIndex();\n                int to = from + postFlattenSize(field.getType());\n                for (int newInnerOrdinal = from; newInnerOrdinal < to; newInnerOrdinal++) {\n                  Ord<RelDataType> newField = getNewFieldForOldInput(oldOrdinal, newInnerOrdinal);\n                  RexInputRef newRef = rexBuilder.makeInputRef(newField.e, newField.i);\n                  flattenedExps.add(Pair.of(newRef, fieldName));\n                }\n                break;\n              } else {\n                from += postFlattenSize(field.getType());\n              }\n            }\n          } else if (firstOp instanceof RexCall) {\n            \r\n            \r\n            \r\n            List<Pair<RexNode, String>> firstOpFlattenedExps = new ArrayList<>();\n            flattenProjection(shuttle, firstOp, fieldName + \"$0\", firstOpFlattenedExps);\n            int newInnerOrdinal = getNewInnerOrdinal(firstOp, literalString);\n            int endOfRange = newInnerOrdinal + postFlattenSize(newExp.getType());\n            for (int i = newInnerOrdinal; i < endOfRange; i++) {\n              flattenedExps.add(firstOpFlattenedExps.get(i));\n            }\n          }\n        } else {\n          List<RexNode> newOperands = operands.stream()\n              .map(op -> op.accept(shuttle))\n              .collect(Collectors.toList());\n          newExp = rexBuilder.makeCall(exp.getType(), operator, newOperands);\n          \r\n          flattenResultTypeOfRexCall(newExp, fieldName, flattenedExps);\n        }\n      } else {\n        throw Util.needToImplement(exp);\n      }\n    } else {\n      flattenedExps.add(\n          Pair.of(exp.accept(shuttle), fieldName));\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql2rel/RelStructuredTypeFlattener.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":614,"status":"M"},{"authorDate":"2019-07-12 00:48:24","commitOrder":8,"curCode":"  private int getNewInnerOrdinal(RexNode firstOp, String literalString) {\n    int newInnerOrdinal = 0;\n    for (RelDataTypeField field : firstOp.getType().getFieldList()) {\n      if (literalString.equalsIgnoreCase(field.getName())) {\n        break;\n      } else {\n        newInnerOrdinal += postFlattenSize(field.getType());\n      }\n    }\n    return newInnerOrdinal;\n  }\n","date":"2019-08-22 02:13:24","endLine":984,"groupId":"23","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getNewInnerOrdinal","params":"(RexNodefirstOp@StringliteralString)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/fc/fe6ab0f0d948abf732e50f8f7d27713b030f1d.src","preCode":"  private int getNewInnerOrdinal(RexNode firstOp, String literalString) {\n    int newInnerOrdinal = 0;\n    for (RelDataTypeField field : firstOp.getType().getFieldList()) {\n      if (literalString.equalsIgnoreCase(field.getName())) {\n        break;\n      } else {\n        newInnerOrdinal += postFlattenSize(field.getType());\n      }\n    }\n    return newInnerOrdinal;\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql2rel/RelStructuredTypeFlattener.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":974,"status":"N"}],"commitId":"59d6eb852676ab5d77eccd63f488c9f121804d5d","commitMessage":"@@@[CALCITE-4038] Refactor RexVisitor.  RexBiVisitor.  RelOptUtil.InputFinder\n\nMake mutable field RelOptUtil.InputFinder.inputBitSet private.\nThe field still exists.  public and deprecated.  but it shadows\na new private field. Rather than calling InputFinder.inputBitSet.build()\nyou should now call InputFinder.build().\n\nIn RexVisitor and RexBiVisitor add methods visitList and\nvisitEach (the former returns a list.  and the latter returns\nvoid).\n\nDeprecate RexShuttle.apply in favor of visitList.\n\nAdd RexWindowBound.accept(RexBiVisitor).\n\nFor RexBiVisitor<X.  Integer> add a method visitEachIndexed. \nthe index passed as the 'payload' argument.\n\nAdd abstract implementations of RexBiVisitor:\nRexUnaryBiVisitor and RexBiVisitorImpl.\n","date":"2020-06-12 02:23:07","modifiedFileCount":"38","status":"M","submitter":"Julian Hyde"},{"authorTime":"2020-05-29 00:04:40","codes":[{"authorDate":"2020-05-29 00:04:40","commitOrder":9,"curCode":"  private void flattenProjection(RewriteRexShuttle shuttle,\n      RexNode exp,\n      String fieldName,\n      List<Pair<RexNode, String>> flattenedExps) {\n    if (exp.getType().isStruct()) {\n      if (exp instanceof RexInputRef) {\n        final int oldOrdinal = ((RexInputRef) exp).getIndex();\n        final int flattenFieldsCount = postFlattenSize(exp.getType());\n        for (int innerOrdinal = 0; innerOrdinal < flattenFieldsCount; innerOrdinal++) {\n          Ord<RelDataType> newField = getNewFieldForOldInput(oldOrdinal, innerOrdinal);\n          RexInputRef newRef = new RexInputRef(newField.i, newField.e);\n          flattenedExps.add(Pair.of(newRef, fieldName));\n        }\n      } else if (isConstructor(exp) || exp.isA(SqlKind.CAST)) {\n        \r\n        \r\n        RexCall call = (RexCall) exp;\n        if (exp.isA(SqlKind.CAST)\n            && RexLiteral.isNullLiteral(call.operands.get(0))) {\n          \r\n          \r\n          flattenNullLiteral(exp.getType(), flattenedExps);\n          return;\n        }\n        flattenProjections(shuttle,\n            call.getOperands(),\n            Collections.nCopies(call.getOperands().size(), null),\n            fieldName,\n            flattenedExps);\n      } else if (exp instanceof RexCall) {\n        \r\n        \r\n        RexNode newExp = exp;\n        List<RexNode> operands = ((RexCall) exp).getOperands();\n        SqlOperator operator = ((RexCall) exp).getOperator();\n\n        if (operator == SqlStdOperatorTable.ITEM\n            && operands.get(0).getType().isStruct()\n            && operands.get(1).isA(SqlKind.LITERAL)\n            && SqlTypeUtil.inCharFamily(operands.get(1).getType())) {\n          String literalString = ((RexLiteral) operands.get(1)).getValueAs(String.class);\n          RexNode firstOp = operands.get(0);\n\n          if (firstOp instanceof RexInputRef) {\n            \r\n            \r\n            \r\n            \r\n            int from = 0;\n            for (RelDataTypeField field : firstOp.getType().getFieldList()) {\n              if (field.getName().equalsIgnoreCase(literalString)) {\n                int oldOrdinal = ((RexInputRef) firstOp).getIndex();\n                int to = from + postFlattenSize(field.getType());\n                for (int newInnerOrdinal = from; newInnerOrdinal < to; newInnerOrdinal++) {\n                  Ord<RelDataType> newField = getNewFieldForOldInput(oldOrdinal, newInnerOrdinal);\n                  RexInputRef newRef = rexBuilder.makeInputRef(newField.e, newField.i);\n                  flattenedExps.add(Pair.of(newRef, fieldName));\n                }\n                break;\n              } else {\n                from += postFlattenSize(field.getType());\n              }\n            }\n          } else if (firstOp instanceof RexCall) {\n            \r\n            \r\n            \r\n            List<Pair<RexNode, String>> firstOpFlattenedExps = new ArrayList<>();\n            flattenProjection(shuttle, firstOp, fieldName + \"$0\", firstOpFlattenedExps);\n            int newInnerOrdinal = getNewInnerOrdinal(firstOp, literalString);\n            int endOfRange = newInnerOrdinal + postFlattenSize(newExp.getType());\n            for (int i = newInnerOrdinal; i < endOfRange; i++) {\n              flattenedExps.add(firstOpFlattenedExps.get(i));\n            }\n          }\n        } else {\n          newExp = rexBuilder.makeCall(exp.getType(), operator,\n              shuttle.visitList(operands));\n          \r\n          flattenResultTypeOfRexCall(newExp, fieldName, flattenedExps);\n        }\n      } else {\n        throw Util.needToImplement(exp);\n      }\n    } else {\n      flattenedExps.add(\n          Pair.of(exp.accept(shuttle), fieldName));\n    }\n  }\n","date":"2020-11-30 06:45:33","endLine":715,"groupId":"102169","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"flattenProjection","params":"(RewriteRexShuttleshuttle@RexNodeexp@StringfieldName@List<Pair<RexNode@String>>flattenedExps)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/5a/0f9765c27d4e204c755de41a30526c8b2ba632.src","preCode":"  private void flattenProjection(RewriteRexShuttle shuttle,\n      RexNode exp,\n      String fieldName,\n      List<Pair<RexNode, String>> flattenedExps) {\n    if (exp.getType().isStruct()) {\n      if (exp instanceof RexInputRef) {\n        final int oldOrdinal = ((RexInputRef) exp).getIndex();\n        final int flattenFieldsCount = postFlattenSize(exp.getType());\n        for (int innerOrdinal = 0; innerOrdinal < flattenFieldsCount; innerOrdinal++) {\n          Ord<RelDataType> newField = getNewFieldForOldInput(oldOrdinal, innerOrdinal);\n          RexInputRef newRef = new RexInputRef(newField.i, newField.e);\n          flattenedExps.add(Pair.of(newRef, fieldName));\n        }\n      } else if (isConstructor(exp) || exp.isA(SqlKind.CAST)) {\n        \r\n        \r\n        RexCall call = (RexCall) exp;\n        if (exp.isA(SqlKind.CAST)\n            && RexLiteral.isNullLiteral(call.operands.get(0))) {\n          \r\n          \r\n          flattenNullLiteral(exp.getType(), flattenedExps);\n          return;\n        }\n        flattenProjections(shuttle,\n            call.getOperands(),\n            Collections.nCopies(call.getOperands().size(), null),\n            fieldName,\n            flattenedExps);\n      } else if (exp instanceof RexCall) {\n        \r\n        \r\n        RexNode newExp = exp;\n        List<RexNode> operands = ((RexCall) exp).getOperands();\n        SqlOperator operator = ((RexCall) exp).getOperator();\n\n        if (operator == SqlStdOperatorTable.ITEM\n            && operands.get(0).getType().isStruct()\n            && operands.get(1).isA(SqlKind.LITERAL)\n            && SqlTypeUtil.inCharFamily(operands.get(1).getType())) {\n          String literalString = ((RexLiteral) operands.get(1)).getValueAs(String.class);\n          RexNode firstOp = operands.get(0);\n\n          if (firstOp instanceof RexInputRef) {\n            \r\n            \r\n            \r\n            \r\n            int from = 0;\n            for (RelDataTypeField field : firstOp.getType().getFieldList()) {\n              if (literalString.equalsIgnoreCase(field.getName())) {\n                int oldOrdinal = ((RexInputRef) firstOp).getIndex();\n                int to = from + postFlattenSize(field.getType());\n                for (int newInnerOrdinal = from; newInnerOrdinal < to; newInnerOrdinal++) {\n                  Ord<RelDataType> newField = getNewFieldForOldInput(oldOrdinal, newInnerOrdinal);\n                  RexInputRef newRef = rexBuilder.makeInputRef(newField.e, newField.i);\n                  flattenedExps.add(Pair.of(newRef, fieldName));\n                }\n                break;\n              } else {\n                from += postFlattenSize(field.getType());\n              }\n            }\n          } else if (firstOp instanceof RexCall) {\n            \r\n            \r\n            \r\n            List<Pair<RexNode, String>> firstOpFlattenedExps = new ArrayList<>();\n            flattenProjection(shuttle, firstOp, fieldName + \"$0\", firstOpFlattenedExps);\n            int newInnerOrdinal = getNewInnerOrdinal(firstOp, literalString);\n            int endOfRange = newInnerOrdinal + postFlattenSize(newExp.getType());\n            for (int i = newInnerOrdinal; i < endOfRange; i++) {\n              flattenedExps.add(firstOpFlattenedExps.get(i));\n            }\n          }\n        } else {\n          newExp = rexBuilder.makeCall(exp.getType(), operator,\n              shuttle.visitList(operands));\n          \r\n          flattenResultTypeOfRexCall(newExp, fieldName, flattenedExps);\n        }\n      } else {\n        throw Util.needToImplement(exp);\n      }\n    } else {\n      flattenedExps.add(\n          Pair.of(exp.accept(shuttle), fieldName));\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql2rel/RelStructuredTypeFlattener.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":627,"status":"M"},{"authorDate":"2020-05-29 00:04:40","commitOrder":9,"curCode":"  private int getNewInnerOrdinal(RexNode firstOp, @Nullable String literalString) {\n    int newInnerOrdinal = 0;\n    for (RelDataTypeField field : firstOp.getType().getFieldList()) {\n      if (field.getName().equalsIgnoreCase(literalString)) {\n        break;\n      } else {\n        newInnerOrdinal += postFlattenSize(field.getType());\n      }\n    }\n    return newInnerOrdinal;\n  }\n","date":"2020-11-30 06:45:33","endLine":1062,"groupId":"102169","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"getNewInnerOrdinal","params":"(RexNodefirstOp@@NullableStringliteralString)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/5a/0f9765c27d4e204c755de41a30526c8b2ba632.src","preCode":"  private int getNewInnerOrdinal(RexNode firstOp, String literalString) {\n    int newInnerOrdinal = 0;\n    for (RelDataTypeField field : firstOp.getType().getFieldList()) {\n      if (literalString.equalsIgnoreCase(field.getName())) {\n        break;\n      } else {\n        newInnerOrdinal += postFlattenSize(field.getType());\n      }\n    }\n    return newInnerOrdinal;\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql2rel/RelStructuredTypeFlattener.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1052,"status":"M"}],"commitId":"d9a81b88ad561e7e4cedae93e805e0d7a53a7f1a","commitMessage":"@@@[CALCITE-4199] Add nullability annotations\n\nThe commit includes javadoc updates and refactorings made by Julian Hyde in https://github.com/apache/calcite/pull/2278\n","date":"2020-11-30 06:45:33","modifiedFileCount":"1012","status":"M","submitter":"Vladimir Sitnikov"}]
