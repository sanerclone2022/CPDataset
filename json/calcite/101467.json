[{"authorTime":"2019-01-25 07:35:43","codes":[{"authorDate":"2019-01-25 07:35:43","commitOrder":2,"curCode":"  @Test public void testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2() {\n    int leftJoinIndex = EMP_SCAN.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = DEPT_ROW.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(EMP_ROW.getFieldCount() + rightJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.CASE,\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.EQUALS, leftKeyInputRef, rightKeyInputRef));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        relBuilder.literal(true));\n  }\n","date":"2019-05-23 01:23:56","endLine":258,"groupId":"622","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/a7/2df310ff3d69fa9b24ccfe79a88ceb35fbf4cd.src","preCode":"  @Test public void testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2() {\n    int leftJoinIndex = EMP_SCAN.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = DEPT_ROW.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(EMP_ROW.getFieldCount() + rightJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.CASE,\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.EQUALS, leftKeyInputRef, rightKeyInputRef));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        relBuilder.literal(true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/RelOptUtilTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":238,"status":"MB"},{"authorDate":"2019-01-25 07:35:43","commitOrder":2,"curCode":"  @Test public void testPushDownJoinConditionsWithExpandedIsNotDistinctUsingCase() {\n    int leftJoinIndex = EMP_SCAN.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = DEPT_ROW.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(EMP_ROW.getFieldCount() + rightJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.CASE,\n        relBuilder.call(SqlStdOperatorTable.IS_NULL,\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1))),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL,\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1))),\n        relBuilder.call(SqlStdOperatorTable.EQUALS,\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1)),\n            rightKeyInputRef));\n\n\n    \r\n    relBuilder.push(EMP_SCAN);\n    relBuilder.push(DEPT_SCAN);\n    relBuilder.join(JoinRelType.INNER, joinCond);\n    Join join = (Join) relBuilder.build();\n    RelNode transformed = RelOptUtil.pushDownJoinConditions(join, relBuilder);\n\n    \r\n    assertThat(transformed.getRowType(), is(join.getRowType()));\n    assertThat(transformed, is(instanceOf(Project.class)));\n    RelNode transformedInput = transformed.getInput(0);\n    assertThat(transformedInput, is(instanceOf(Join.class)));\n    Join newJoin = (Join) transformedInput;\n    assertThat(newJoin.getCondition().toString(),\n        is(\n            relBuilder.call(\n                SqlStdOperatorTable.IS_NOT_DISTINCT_FROM,\n                \r\n                RexInputRef.of(EMP_ROW.getFieldCount(), join.getRowType()),\n                \r\n                RexInputRef.of(EMP_ROW.getFieldCount() + 1 + rightJoinIndex, join.getRowType()))\n              .toString()));\n    assertThat(newJoin.getLeft(), is(instanceOf(Project.class)));\n    Project leftInput = (Project) newJoin.getLeft();\n    assertThat(leftInput.getChildExps().get(EMP_ROW.getFieldCount()).toString(),\n        is(relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1))\n            .toString()));\n  }\n","date":"2019-05-23 01:23:56","endLine":467,"groupId":"16492","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testPushDownJoinConditionsWithExpandedIsNotDistinctUsingCase","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/a7/2df310ff3d69fa9b24ccfe79a88ceb35fbf4cd.src","preCode":"  @Test public void testPushDownJoinConditionsWithExpandedIsNotDistinctUsingCase() {\n    int leftJoinIndex = EMP_SCAN.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = DEPT_ROW.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(EMP_ROW.getFieldCount() + rightJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.CASE,\n        relBuilder.call(SqlStdOperatorTable.IS_NULL,\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1))),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL,\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1))),\n        relBuilder.call(SqlStdOperatorTable.EQUALS,\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1)),\n            rightKeyInputRef));\n\n\n    \r\n    relBuilder.push(EMP_SCAN);\n    relBuilder.push(DEPT_SCAN);\n    relBuilder.join(JoinRelType.INNER, joinCond);\n    Join join = (Join) relBuilder.build();\n    RelNode transformed = RelOptUtil.pushDownJoinConditions(join, relBuilder);\n\n    \r\n    assertThat(transformed.getRowType(), is(join.getRowType()));\n    assertThat(transformed, is(instanceOf(Project.class)));\n    RelNode transformedInput = transformed.getInput(0);\n    assertThat(transformedInput, is(instanceOf(Join.class)));\n    Join newJoin = (Join) transformedInput;\n    assertThat(newJoin.getCondition().toString(),\n        is(\n            relBuilder.call(\n                SqlStdOperatorTable.IS_NOT_DISTINCT_FROM,\n                \r\n                RexInputRef.of(EMP_ROW.getFieldCount(), join.getRowType()),\n                \r\n                RexInputRef.of(EMP_ROW.getFieldCount() + 1 + rightJoinIndex, join.getRowType()))\n              .toString()));\n    assertThat(newJoin.getLeft(), is(instanceOf(Project.class)));\n    Project leftInput = (Project) newJoin.getLeft();\n    assertThat(leftInput.getChildExps().get(EMP_ROW.getFieldCount()).toString(),\n        is(relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1))\n            .toString()));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/RelOptUtilTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":421,"status":"B"}],"commitId":"82e7d4e760cb203d31956c55e38e0fdd56119d58","commitMessage":"@@@[CALCITE-2807] Fix `IS NOT DISTINCT FROM` expression identification in RelOptUtil#pushDownJoinConditions()\n\nRelOptUtil#pushDownJoinConditions do not identify and preserve\nexpanded versions of `IS NOT DISTINCT FROM` expressions.  causing\nequi-joins to be miscategorized as inequality joins.\n\nModify the function to try to collapse the expression back to a\ncanonical `IS NOT DISTINCT FROM` expression if possible before\nvisiting the expression and pushing it below the join.\n","date":"2019-05-23 01:23:56","modifiedFileCount":"4","status":"M","submitter":"Laurent Goujon"},{"authorTime":"2019-05-30 05:04:46","codes":[{"authorDate":"2019-05-30 05:04:46","commitOrder":3,"curCode":"  @Test public void testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2() {\n    int leftJoinIndex = empScan.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = deptRow.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, empDeptJoinRelFields);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(empRow.getFieldCount() + rightJoinIndex, empDeptJoinRelFields);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.CASE,\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.EQUALS, leftKeyInputRef, rightKeyInputRef));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        relBuilder.literal(true));\n  }\n","date":"2019-05-30 08:16:45","endLine":261,"groupId":"622","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/a2/84e101e07e1d680143f9cedfa4521cf69fa6c2.src","preCode":"  @Test public void testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2() {\n    int leftJoinIndex = EMP_SCAN.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = DEPT_ROW.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(EMP_ROW.getFieldCount() + rightJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.CASE,\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.EQUALS, leftKeyInputRef, rightKeyInputRef));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        relBuilder.literal(true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/RelOptUtilTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":241,"status":"M"},{"authorDate":"2019-05-30 05:04:46","commitOrder":3,"curCode":"  @Test public void testPushDownJoinConditionsWithExpandedIsNotDistinctUsingCase() {\n    int leftJoinIndex = empScan.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = deptRow.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, empDeptJoinRelFields);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(empRow.getFieldCount() + rightJoinIndex, empDeptJoinRelFields);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.CASE,\n        relBuilder.call(SqlStdOperatorTable.IS_NULL,\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1))),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL,\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1))),\n        relBuilder.call(SqlStdOperatorTable.EQUALS,\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1)),\n            rightKeyInputRef));\n\n\n    \r\n    relBuilder.push(empScan);\n    relBuilder.push(deptScan);\n    relBuilder.join(JoinRelType.INNER, joinCond);\n    Join join = (Join) relBuilder.build();\n    RelNode transformed = RelOptUtil.pushDownJoinConditions(join, relBuilder);\n\n    \r\n    assertThat(transformed.getRowType(), is(join.getRowType()));\n    assertThat(transformed, is(instanceOf(Project.class)));\n    RelNode transformedInput = transformed.getInput(0);\n    assertThat(transformedInput, is(instanceOf(Join.class)));\n    Join newJoin = (Join) transformedInput;\n    assertThat(newJoin.getCondition().toString(),\n        is(\n            relBuilder.call(\n                SqlStdOperatorTable.IS_NOT_DISTINCT_FROM,\n                \r\n                RexInputRef.of(empRow.getFieldCount(), join.getRowType()),\n                \r\n                RexInputRef.of(empRow.getFieldCount() + 1 + rightJoinIndex, join.getRowType()))\n              .toString()));\n    assertThat(newJoin.getLeft(), is(instanceOf(Project.class)));\n    Project leftInput = (Project) newJoin.getLeft();\n    assertThat(leftInput.getChildExps().get(empRow.getFieldCount()).toString(),\n        is(relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1))\n            .toString()));\n  }\n","date":"2019-05-30 08:16:45","endLine":470,"groupId":"16492","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testPushDownJoinConditionsWithExpandedIsNotDistinctUsingCase","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/a2/84e101e07e1d680143f9cedfa4521cf69fa6c2.src","preCode":"  @Test public void testPushDownJoinConditionsWithExpandedIsNotDistinctUsingCase() {\n    int leftJoinIndex = EMP_SCAN.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = DEPT_ROW.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(EMP_ROW.getFieldCount() + rightJoinIndex, EMP_DEPT_JOIN_REL_FIELDS);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.CASE,\n        relBuilder.call(SqlStdOperatorTable.IS_NULL,\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1))),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL,\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1))),\n        relBuilder.call(SqlStdOperatorTable.EQUALS,\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1)),\n            rightKeyInputRef));\n\n\n    \r\n    relBuilder.push(EMP_SCAN);\n    relBuilder.push(DEPT_SCAN);\n    relBuilder.join(JoinRelType.INNER, joinCond);\n    Join join = (Join) relBuilder.build();\n    RelNode transformed = RelOptUtil.pushDownJoinConditions(join, relBuilder);\n\n    \r\n    assertThat(transformed.getRowType(), is(join.getRowType()));\n    assertThat(transformed, is(instanceOf(Project.class)));\n    RelNode transformedInput = transformed.getInput(0);\n    assertThat(transformedInput, is(instanceOf(Join.class)));\n    Join newJoin = (Join) transformedInput;\n    assertThat(newJoin.getCondition().toString(),\n        is(\n            relBuilder.call(\n                SqlStdOperatorTable.IS_NOT_DISTINCT_FROM,\n                \r\n                RexInputRef.of(EMP_ROW.getFieldCount(), join.getRowType()),\n                \r\n                RexInputRef.of(EMP_ROW.getFieldCount() + 1 + rightJoinIndex, join.getRowType()))\n              .toString()));\n    assertThat(newJoin.getLeft(), is(instanceOf(Project.class)));\n    Project leftInput = (Project) newJoin.getLeft();\n    assertThat(leftInput.getChildExps().get(EMP_ROW.getFieldCount()).toString(),\n        is(relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1))\n            .toString()));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/RelOptUtilTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":424,"status":"M"}],"commitId":"00f8b5f5ca1d45ce5029a474c42e674bec31634f","commitMessage":"@@@RelOptUtilTest concurrency fixup\n\nRelOptUtilTest was creating a static RelOptCluster which could be used\nduring tests running in parallel to acces the associated RelMetadataQuery\ninstance.  Alas the object is not safe to access from multiple threads\nand in some occasions tests would fail with CyclicMetadataException.\n\nFixing the test class by creating a new RelOptCluster/RelBuilder\ninstance for each test.  and removing the static instances.\n","date":"2019-05-30 08:16:45","modifiedFileCount":"1","status":"M","submitter":"Laurent Goujon"},{"authorTime":"2020-04-02 10:39:10","codes":[{"authorDate":"2020-04-02 10:39:10","commitOrder":4,"curCode":"  @Test void testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2() {\n    int leftJoinIndex = empScan.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = deptRow.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, empDeptJoinRelFields);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(empRow.getFieldCount() + rightJoinIndex, empDeptJoinRelFields);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.CASE,\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.EQUALS, leftKeyInputRef, rightKeyInputRef));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        relBuilder.literal(true));\n  }\n","date":"2020-04-06 04:57:49","endLine":335,"groupId":"622","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/d5/67ce1b0e03643d2f43cda079b7e52f3be701d2.src","preCode":"  @Test public void testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2() {\n    int leftJoinIndex = empScan.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = deptRow.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, empDeptJoinRelFields);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(empRow.getFieldCount() + rightJoinIndex, empDeptJoinRelFields);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.CASE,\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.EQUALS, leftKeyInputRef, rightKeyInputRef));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        relBuilder.literal(true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/RelOptUtilTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":315,"status":"M"},{"authorDate":"2020-04-02 10:39:10","commitOrder":4,"curCode":"  @Test void testPushDownJoinConditionsWithExpandedIsNotDistinctUsingCase() {\n    int leftJoinIndex = empScan.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = deptRow.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, empDeptJoinRelFields);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(empRow.getFieldCount() + rightJoinIndex, empDeptJoinRelFields);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.CASE,\n        relBuilder.call(SqlStdOperatorTable.IS_NULL,\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1))),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL,\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1))),\n        relBuilder.call(SqlStdOperatorTable.EQUALS,\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1)),\n            rightKeyInputRef));\n\n\n    \r\n    relBuilder.push(empScan);\n    relBuilder.push(deptScan);\n    relBuilder.join(JoinRelType.INNER, joinCond);\n    Join join = (Join) relBuilder.build();\n    RelNode transformed = RelOptUtil.pushDownJoinConditions(join, relBuilder);\n\n    \r\n    assertThat(transformed.getRowType(), is(join.getRowType()));\n    assertThat(transformed, is(instanceOf(Project.class)));\n    RelNode transformedInput = transformed.getInput(0);\n    assertThat(transformedInput, is(instanceOf(Join.class)));\n    Join newJoin = (Join) transformedInput;\n    assertThat(newJoin.getCondition().toString(),\n        is(\n            relBuilder.call(\n                SqlStdOperatorTable.IS_NOT_DISTINCT_FROM,\n                \r\n                RexInputRef.of(empRow.getFieldCount(), join.getRowType()),\n                \r\n                RexInputRef.of(empRow.getFieldCount() + 1 + rightJoinIndex, join.getRowType()))\n              .toString()));\n    assertThat(newJoin.getLeft(), is(instanceOf(Project.class)));\n    Project leftInput = (Project) newJoin.getLeft();\n    assertThat(leftInput.getChildExps().get(empRow.getFieldCount()).toString(),\n        is(relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1))\n            .toString()));\n  }\n","date":"2020-04-06 04:57:49","endLine":544,"groupId":"16492","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testPushDownJoinConditionsWithExpandedIsNotDistinctUsingCase","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/d5/67ce1b0e03643d2f43cda079b7e52f3be701d2.src","preCode":"  @Test public void testPushDownJoinConditionsWithExpandedIsNotDistinctUsingCase() {\n    int leftJoinIndex = empScan.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = deptRow.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, empDeptJoinRelFields);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(empRow.getFieldCount() + rightJoinIndex, empDeptJoinRelFields);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.CASE,\n        relBuilder.call(SqlStdOperatorTable.IS_NULL,\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1))),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL,\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1))),\n        relBuilder.call(SqlStdOperatorTable.EQUALS,\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1)),\n            rightKeyInputRef));\n\n\n    \r\n    relBuilder.push(empScan);\n    relBuilder.push(deptScan);\n    relBuilder.join(JoinRelType.INNER, joinCond);\n    Join join = (Join) relBuilder.build();\n    RelNode transformed = RelOptUtil.pushDownJoinConditions(join, relBuilder);\n\n    \r\n    assertThat(transformed.getRowType(), is(join.getRowType()));\n    assertThat(transformed, is(instanceOf(Project.class)));\n    RelNode transformedInput = transformed.getInput(0);\n    assertThat(transformedInput, is(instanceOf(Join.class)));\n    Join newJoin = (Join) transformedInput;\n    assertThat(newJoin.getCondition().toString(),\n        is(\n            relBuilder.call(\n                SqlStdOperatorTable.IS_NOT_DISTINCT_FROM,\n                \r\n                RexInputRef.of(empRow.getFieldCount(), join.getRowType()),\n                \r\n                RexInputRef.of(empRow.getFieldCount() + 1 + rightJoinIndex, join.getRowType()))\n              .toString()));\n    assertThat(newJoin.getLeft(), is(instanceOf(Project.class)));\n    Project leftInput = (Project) newJoin.getLeft();\n    assertThat(leftInput.getChildExps().get(empRow.getFieldCount()).toString(),\n        is(relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1))\n            .toString()));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/RelOptUtilTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":498,"status":"M"}],"commitId":"9492dd4146f63ddc028010d6c4e86f6a5cb29a8d","commitMessage":"@@@[CALCITE-3892] Make junit test classes and methods non-public where possible\n\nPrior to junit 5.  classes and methods had to be public. This is no\nlonger the case.\n\nSome classes need to remain public because they are referenced from\nelsewhere.  or if they use reflection somehow. The remaining 'public'\nkeyword will be informative to maintainers.\n","date":"2020-04-06 04:57:49","modifiedFileCount":"196","status":"M","submitter":"Julian Hyde"},{"authorTime":"2020-06-09 21:16:22","codes":[{"authorDate":"2020-04-02 10:39:10","commitOrder":5,"curCode":"  @Test void testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2() {\n    int leftJoinIndex = empScan.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = deptRow.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, empDeptJoinRelFields);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(empRow.getFieldCount() + rightJoinIndex, empDeptJoinRelFields);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.CASE,\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.EQUALS, leftKeyInputRef, rightKeyInputRef));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        relBuilder.literal(true));\n  }\n","date":"2020-04-06 04:57:49","endLine":335,"groupId":"622","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/d5/67ce1b0e03643d2f43cda079b7e52f3be701d2.src","preCode":"  @Test void testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2() {\n    int leftJoinIndex = empScan.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = deptRow.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, empDeptJoinRelFields);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(empRow.getFieldCount() + rightJoinIndex, empDeptJoinRelFields);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.CASE,\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.EQUALS, leftKeyInputRef, rightKeyInputRef));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        relBuilder.literal(true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/RelOptUtilTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":315,"status":"N"},{"authorDate":"2020-06-09 21:16:22","commitOrder":5,"curCode":"  @Test void testPushDownJoinConditionsWithExpandedIsNotDistinctUsingCase() {\n    int leftJoinIndex = empScan.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = deptRow.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, empDeptJoinRelFields);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(empRow.getFieldCount() + rightJoinIndex, empDeptJoinRelFields);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.CASE,\n        relBuilder.call(SqlStdOperatorTable.IS_NULL,\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1))),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL,\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1))),\n        relBuilder.call(SqlStdOperatorTable.EQUALS,\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1)),\n            rightKeyInputRef));\n\n\n    \r\n    relBuilder.push(empScan);\n    relBuilder.push(deptScan);\n    relBuilder.join(JoinRelType.INNER, joinCond);\n    Join join = (Join) relBuilder.build();\n    RelNode transformed = RelOptUtil.pushDownJoinConditions(join, relBuilder);\n\n    \r\n    assertThat(transformed.getRowType(), is(join.getRowType()));\n    assertThat(transformed, is(instanceOf(Project.class)));\n    RelNode transformedInput = transformed.getInput(0);\n    assertThat(transformedInput, is(instanceOf(Join.class)));\n    Join newJoin = (Join) transformedInput;\n    assertThat(newJoin.getCondition().toString(),\n        is(\n            relBuilder.call(\n                SqlStdOperatorTable.IS_NOT_DISTINCT_FROM,\n                \r\n                RexInputRef.of(empRow.getFieldCount(), join.getRowType()),\n                \r\n                RexInputRef.of(empRow.getFieldCount() + 1 + rightJoinIndex, join.getRowType()))\n              .toString()));\n    assertThat(newJoin.getLeft(), is(instanceOf(Project.class)));\n    Project leftInput = (Project) newJoin.getLeft();\n    assertThat(leftInput.getProjects().get(empRow.getFieldCount()).toString(),\n        is(relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1))\n            .toString()));\n  }\n","date":"2020-06-16 11:11:13","endLine":544,"groupId":"16492","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testPushDownJoinConditionsWithExpandedIsNotDistinctUsingCase","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/5a/f0d2768128deed4b1f15541f2aa53e31642550.src","preCode":"  @Test void testPushDownJoinConditionsWithExpandedIsNotDistinctUsingCase() {\n    int leftJoinIndex = empScan.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = deptRow.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, empDeptJoinRelFields);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(empRow.getFieldCount() + rightJoinIndex, empDeptJoinRelFields);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.CASE,\n        relBuilder.call(SqlStdOperatorTable.IS_NULL,\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1))),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL,\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1))),\n        relBuilder.call(SqlStdOperatorTable.EQUALS,\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1)),\n            rightKeyInputRef));\n\n\n    \r\n    relBuilder.push(empScan);\n    relBuilder.push(deptScan);\n    relBuilder.join(JoinRelType.INNER, joinCond);\n    Join join = (Join) relBuilder.build();\n    RelNode transformed = RelOptUtil.pushDownJoinConditions(join, relBuilder);\n\n    \r\n    assertThat(transformed.getRowType(), is(join.getRowType()));\n    assertThat(transformed, is(instanceOf(Project.class)));\n    RelNode transformedInput = transformed.getInput(0);\n    assertThat(transformedInput, is(instanceOf(Join.class)));\n    Join newJoin = (Join) transformedInput;\n    assertThat(newJoin.getCondition().toString(),\n        is(\n            relBuilder.call(\n                SqlStdOperatorTable.IS_NOT_DISTINCT_FROM,\n                \r\n                RexInputRef.of(empRow.getFieldCount(), join.getRowType()),\n                \r\n                RexInputRef.of(empRow.getFieldCount() + 1 + rightJoinIndex, join.getRowType()))\n              .toString()));\n    assertThat(newJoin.getLeft(), is(instanceOf(Project.class)));\n    Project leftInput = (Project) newJoin.getLeft();\n    assertThat(leftInput.getChildExps().get(empRow.getFieldCount()).toString(),\n        is(relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1))\n            .toString()));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/RelOptUtilTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":498,"status":"M"}],"commitId":"69f25863f5f4197c17927a39a82cbf1cffd12b80","commitMessage":"@@@[CALCITE-3786] Add Digest interface to enable efficient hashCode(equals) for RexNode and RelNode\n\n* Add class Digest used to identify the node;\n* There is a pre-computed hashcode to speedup #hashCode and #equals;\n* Change RexCall to use object#equals instead of pure string digest\ncomparison;\n* We only support RexInputRef normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing complicated. \nRexNode can always be normalized(default true).\n","date":"2020-06-16 11:11:13","modifiedFileCount":"51","status":"M","submitter":"yuzhao.cyz"},{"authorTime":"2021-09-17 17:38:52","codes":[{"authorDate":"2021-09-17 17:38:52","commitOrder":6,"curCode":"  @Test void testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2() {\n    int leftJoinIndex = empScan.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = deptRow.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, empDeptJoinRelFields);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(empRow.getFieldCount() + rightJoinIndex, empDeptJoinRelFields);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.CASE,\n        relBuilder.isNull(leftKeyInputRef),\n        relBuilder.isNull(rightKeyInputRef),\n        relBuilder.isNull(rightKeyInputRef),\n        relBuilder.isNull(leftKeyInputRef),\n        relBuilder.equals(leftKeyInputRef, rightKeyInputRef));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        relBuilder.literal(true));\n  }\n","date":"2021-09-18 03:08:56","endLine":385,"groupId":"101467","id":9,"instanceNumber":1,"isCurCommit":1,"methodName":"testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/ce/571c33cf435d0922678e9dbf8e75006b71d838.src","preCode":"  @Test void testSplitJoinConditionExpandedIsNotDistinctFromUsingCase2() {\n    int leftJoinIndex = empScan.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = deptRow.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, empDeptJoinRelFields);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(empRow.getFieldCount() + rightJoinIndex, empDeptJoinRelFields);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.CASE,\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, leftKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.EQUALS, leftKeyInputRef, rightKeyInputRef));\n\n    splitJoinConditionHelper(\n        joinCond,\n        Collections.singletonList(leftJoinIndex),\n        Collections.singletonList(rightJoinIndex),\n        Collections.singletonList(false),\n        relBuilder.literal(true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/RelOptUtilTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":365,"status":"M"},{"authorDate":"2021-09-17 17:38:52","commitOrder":6,"curCode":"  @Test void testPushDownJoinConditionsWithExpandedIsNotDistinctUsingCase() {\n    int leftJoinIndex = empScan.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = deptRow.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, empDeptJoinRelFields);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(empRow.getFieldCount() + rightJoinIndex, empDeptJoinRelFields);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.CASE,\n        relBuilder.isNull(\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef,\n                relBuilder.literal(1))),\n        relBuilder.isNull(rightKeyInputRef),\n        relBuilder.isNull(rightKeyInputRef),\n        relBuilder.isNull(\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef,\n                relBuilder.literal(1))),\n        relBuilder.equals(\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef,\n                relBuilder.literal(1)),\n            rightKeyInputRef));\n\n\n    \r\n    relBuilder.push(empScan);\n    relBuilder.push(deptScan);\n    relBuilder.join(JoinRelType.INNER, joinCond);\n    Join join = (Join) relBuilder.build();\n    RelNode transformed = RelOptUtil.pushDownJoinConditions(join, relBuilder);\n\n    \r\n    assertThat(transformed.getRowType(), is(join.getRowType()));\n    assertThat(transformed, is(instanceOf(Project.class)));\n    RelNode transformedInput = transformed.getInput(0);\n    assertThat(transformedInput, is(instanceOf(Join.class)));\n    Join newJoin = (Join) transformedInput;\n    assertThat(newJoin.getCondition().toString(),\n        is(\n            relBuilder.call(\n                SqlStdOperatorTable.IS_NOT_DISTINCT_FROM,\n                \r\n                RexInputRef.of(empRow.getFieldCount(), join.getRowType()),\n                \r\n                RexInputRef.of(empRow.getFieldCount() + 1 + rightJoinIndex, join.getRowType()))\n              .toString()));\n    assertThat(newJoin.getLeft(), is(instanceOf(Project.class)));\n    Project leftInput = (Project) newJoin.getLeft();\n    assertThat(leftInput.getProjects().get(empRow.getFieldCount()).toString(),\n        is(relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1))\n            .toString()));\n  }\n","date":"2021-09-18 03:08:56","endLine":597,"groupId":"101467","id":10,"instanceNumber":2,"isCurCommit":1,"methodName":"testPushDownJoinConditionsWithExpandedIsNotDistinctUsingCase","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/ce/571c33cf435d0922678e9dbf8e75006b71d838.src","preCode":"  @Test void testPushDownJoinConditionsWithExpandedIsNotDistinctUsingCase() {\n    int leftJoinIndex = empScan.getRowType().getFieldNames().indexOf(\"DEPTNO\");\n    int rightJoinIndex = deptRow.getFieldNames().indexOf(\"DEPTNO\");\n\n    RexInputRef leftKeyInputRef = RexInputRef.of(leftJoinIndex, empDeptJoinRelFields);\n    RexInputRef rightKeyInputRef =\n        RexInputRef.of(empRow.getFieldCount() + rightJoinIndex, empDeptJoinRelFields);\n    RexNode joinCond = relBuilder.call(SqlStdOperatorTable.CASE,\n        relBuilder.call(SqlStdOperatorTable.IS_NULL,\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1))),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL, rightKeyInputRef),\n        relBuilder.call(SqlStdOperatorTable.IS_NULL,\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1))),\n        relBuilder.call(SqlStdOperatorTable.EQUALS,\n            relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1)),\n            rightKeyInputRef));\n\n\n    \r\n    relBuilder.push(empScan);\n    relBuilder.push(deptScan);\n    relBuilder.join(JoinRelType.INNER, joinCond);\n    Join join = (Join) relBuilder.build();\n    RelNode transformed = RelOptUtil.pushDownJoinConditions(join, relBuilder);\n\n    \r\n    assertThat(transformed.getRowType(), is(join.getRowType()));\n    assertThat(transformed, is(instanceOf(Project.class)));\n    RelNode transformedInput = transformed.getInput(0);\n    assertThat(transformedInput, is(instanceOf(Join.class)));\n    Join newJoin = (Join) transformedInput;\n    assertThat(newJoin.getCondition().toString(),\n        is(\n            relBuilder.call(\n                SqlStdOperatorTable.IS_NOT_DISTINCT_FROM,\n                \r\n                RexInputRef.of(empRow.getFieldCount(), join.getRowType()),\n                \r\n                RexInputRef.of(empRow.getFieldCount() + 1 + rightJoinIndex, join.getRowType()))\n              .toString()));\n    assertThat(newJoin.getLeft(), is(instanceOf(Project.class)));\n    Project leftInput = (Project) newJoin.getLeft();\n    assertThat(leftInput.getProjects().get(empRow.getFieldCount()).toString(),\n        is(relBuilder.call(SqlStdOperatorTable.PLUS, leftKeyInputRef, relBuilder.literal(1))\n            .toString()));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/plan/RelOptUtilTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":548,"status":"M"}],"commitId":"4d82c5346292b32a1301214376366c2e8c5a892e","commitMessage":"@@@Add RelBuilder.lessThan.  and use RelBuilder shorthands\n","date":"2021-09-18 03:08:56","modifiedFileCount":"9","status":"M","submitter":"Julian Hyde"}]
