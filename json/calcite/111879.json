[{"authorTime":"2019-09-03 12:07:18","codes":[{"authorDate":"2019-09-03 12:07:18","commitOrder":1,"curCode":"    @Override protected UnifyResult apply(UnifyRuleCall call) {\n      final MutableJoin query = (MutableJoin) call.query;\n      final MutableCalc qInput0 = (MutableCalc) query.getLeft();\n      final MutableRel qInput1 = query.getRight();\n      final Pair<RexNode, List<RexNode>> qInput0Explained = explainCalc(qInput0);\n      final RexNode qInput0Cond = qInput0Explained.left;\n      final List<RexNode> qInput0Projs = qInput0Explained.right;\n\n      final MutableJoin target = (MutableJoin) call.target;\n\n      final RexBuilder rexBuilder = call.getCluster().getRexBuilder();\n\n      \r\n      \r\n      \r\n      final JoinRelType joinRelType = sameJoinType(query.joinType, target.joinType);\n      if (joinRelType == null) {\n        return null;\n      }\n      if (joinRelType != JoinRelType.INNER\n          && !(joinRelType.isOuterJoin() && qInput0Cond.isAlwaysTrue())) {\n        return null;\n      }\n      \r\n      final List<RexNode> identityProjects =\n          (List<RexNode>) rexBuilder.identityProjects(qInput1.rowType);\n      if (!referenceByMapping(query.condition, qInput0Projs, identityProjects)) {\n        return null;\n      }\n\n      final RexNode newQueryJoinCond = new RexShuttle() {\n        @Override public RexNode visitInputRef(RexInputRef inputRef) {\n          final int idx = inputRef.getIndex();\n          if (idx < fieldCnt(qInput0)) {\n            final int newIdx = ((RexInputRef) qInput0Projs.get(idx)).getIndex();\n            return new RexInputRef(newIdx, inputRef.getType());\n          } else {\n            int newIdx = idx - fieldCnt(qInput0) + fieldCnt(qInput0.getInput());\n            return new RexInputRef(newIdx, inputRef.getType());\n          }\n        }\n      }.apply(query.condition);\n\n      final RexNode splitted =\n          splitFilter(call.getSimplify(), newQueryJoinCond, target.condition);\n      \r\n      if (splitted != null && splitted.isAlwaysTrue()) {\n        final RexNode compenCond = qInput0Cond;\n        final List<RexNode> compenProjs = new ArrayList<>();\n        for (int i = 0; i < fieldCnt(query); i++) {\n          if (i < fieldCnt(qInput0)) {\n            compenProjs.add(qInput0Projs.get(i));\n          } else {\n            final int newIdx = i - fieldCnt(qInput0) + fieldCnt(qInput0.getInput());\n            compenProjs.add(\n                new RexInputRef(newIdx, query.rowType.getFieldList().get(i).getType()));\n          }\n        }\n        final RexProgram compenRexProgram = RexProgram.create(\n            target.rowType, compenProjs, compenCond,\n            query.rowType, rexBuilder);\n        final MutableCalc compenCalc = MutableCalc.of(target, compenRexProgram);\n        return tryMergeParentCalcAndGenResult(call, compenCalc);\n      }\n\n      return null;\n    }\n","date":"2019-10-28 13:09:26","endLine":1225,"groupId":"16750","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"apply","params":"(UnifyRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/0c/4e22f8417cd0d0b4bcef07e9e92a2493708b2b.src","preCode":"    @Override protected UnifyResult apply(UnifyRuleCall call) {\n      final MutableJoin query = (MutableJoin) call.query;\n      final MutableCalc qInput0 = (MutableCalc) query.getLeft();\n      final MutableRel qInput1 = query.getRight();\n      final Pair<RexNode, List<RexNode>> qInput0Explained = explainCalc(qInput0);\n      final RexNode qInput0Cond = qInput0Explained.left;\n      final List<RexNode> qInput0Projs = qInput0Explained.right;\n\n      final MutableJoin target = (MutableJoin) call.target;\n\n      final RexBuilder rexBuilder = call.getCluster().getRexBuilder();\n\n      \r\n      \r\n      \r\n      final JoinRelType joinRelType = sameJoinType(query.joinType, target.joinType);\n      if (joinRelType == null) {\n        return null;\n      }\n      if (joinRelType != JoinRelType.INNER\n          && !(joinRelType.isOuterJoin() && qInput0Cond.isAlwaysTrue())) {\n        return null;\n      }\n      \r\n      final List<RexNode> identityProjects =\n          (List<RexNode>) rexBuilder.identityProjects(qInput1.rowType);\n      if (!referenceByMapping(query.condition, qInput0Projs, identityProjects)) {\n        return null;\n      }\n\n      final RexNode newQueryJoinCond = new RexShuttle() {\n        @Override public RexNode visitInputRef(RexInputRef inputRef) {\n          final int idx = inputRef.getIndex();\n          if (idx < fieldCnt(qInput0)) {\n            final int newIdx = ((RexInputRef) qInput0Projs.get(idx)).getIndex();\n            return new RexInputRef(newIdx, inputRef.getType());\n          } else {\n            int newIdx = idx - fieldCnt(qInput0) + fieldCnt(qInput0.getInput());\n            return new RexInputRef(newIdx, inputRef.getType());\n          }\n        }\n      }.apply(query.condition);\n\n      final RexNode splitted =\n          splitFilter(call.getSimplify(), newQueryJoinCond, target.condition);\n      \r\n      if (splitted != null && splitted.isAlwaysTrue()) {\n        final RexNode compenCond = qInput0Cond;\n        final List<RexNode> compenProjs = new ArrayList<>();\n        for (int i = 0; i < fieldCnt(query); i++) {\n          if (i < fieldCnt(qInput0)) {\n            compenProjs.add(qInput0Projs.get(i));\n          } else {\n            final int newIdx = i - fieldCnt(qInput0) + fieldCnt(qInput0.getInput());\n            compenProjs.add(\n                new RexInputRef(newIdx, query.rowType.getFieldList().get(i).getType()));\n          }\n        }\n        final RexProgram compenRexProgram = RexProgram.create(\n            target.rowType, compenProjs, compenCond,\n            query.rowType, rexBuilder);\n        final MutableCalc compenCalc = MutableCalc.of(target, compenRexProgram);\n        return tryMergeParentCalcAndGenResult(call, compenCalc);\n      }\n\n      return null;\n    }\n","realPath":"core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1159,"status":"B"},{"authorDate":"2019-09-03 12:07:18","commitOrder":1,"curCode":"    @Override protected UnifyResult apply(UnifyRuleCall call) {\n      final MutableJoin query = (MutableJoin) call.query;\n      final MutableCalc qInput0 = (MutableCalc) query.getLeft();\n      final MutableCalc qInput1 = (MutableCalc) query.getRight();\n      final Pair<RexNode, List<RexNode>> qInput0Explained = explainCalc(qInput0);\n      final RexNode qInput0Cond = qInput0Explained.left;\n      final List<RexNode> qInput0Projs = qInput0Explained.right;\n      final Pair<RexNode, List<RexNode>> qInput1Explained = explainCalc(qInput1);\n      final RexNode qInput1Cond = qInput1Explained.left;\n      final List<RexNode> qInput1Projs = qInput1Explained.right;\n\n      final MutableJoin target = (MutableJoin) call.target;\n\n      final RexBuilder rexBuilder = call.getCluster().getRexBuilder();\n\n      \r\n      \r\n      \r\n      final JoinRelType joinRelType = sameJoinType(query.joinType, target.joinType);\n      if (joinRelType == null) {\n        return null;\n      }\n      if (joinRelType != JoinRelType.INNER\n          && !(joinRelType.isOuterJoin()\n              && qInput0Cond.isAlwaysTrue()\n              && qInput1Cond.isAlwaysTrue())) {\n        return null;\n      }\n      if (!referenceByMapping(query.condition, qInput0Projs, qInput1Projs)) {\n        return null;\n      }\n\n      RexNode newQueryJoinCond = new RexShuttle() {\n        @Override public RexNode visitInputRef(RexInputRef inputRef) {\n          final int idx = inputRef.getIndex();\n          if (idx < fieldCnt(qInput0)) {\n            final int newIdx = ((RexInputRef) qInput0Projs.get(idx)).getIndex();\n            return new RexInputRef(newIdx, inputRef.getType());\n          } else {\n            final int newIdx = ((RexInputRef) qInput1Projs.get(idx - fieldCnt(qInput0)))\n                .getIndex() + fieldCnt(qInput0.getInput());\n            return new RexInputRef(newIdx, inputRef.getType());\n          }\n        }\n      }.apply(query.condition);\n      final RexNode splitted =\n          splitFilter(call.getSimplify(), newQueryJoinCond, target.condition);\n      \r\n      if (splitted != null && splitted.isAlwaysTrue()) {\n        final RexNode qInput1CondShifted =\n            RexUtil.shift(qInput1Cond, fieldCnt(qInput0.getInput()));\n        final RexNode compenCond = RexUtil.composeConjunction(rexBuilder,\n            ImmutableList.of(qInput0Cond, qInput1CondShifted));\n\n        final List<RexNode> compenProjs = new ArrayList<>();\n        for (int i = 0; i < query.rowType.getFieldCount(); i++) {\n          if (i < fieldCnt(qInput0)) {\n            compenProjs.add(qInput0Projs.get(i));\n          } else {\n            RexNode shifted = RexUtil.shift(qInput1Projs.get(i - fieldCnt(qInput0)),\n                fieldCnt(qInput0.getInput()));\n            compenProjs.add(shifted);\n          }\n        }\n        final RexProgram compensatingRexProgram = RexProgram.create(\n            target.rowType, compenProjs, compenCond,\n            query.rowType, rexBuilder);\n        final MutableCalc compensatingCalc =\n            MutableCalc.of(target, compensatingRexProgram);\n        return tryMergeParentCalcAndGenResult(call, compensatingCalc);\n      }\n      return null;\n    }\n","date":"2019-10-28 13:09:26","endLine":1405,"groupId":"13013","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"apply","params":"(UnifyRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/0c/4e22f8417cd0d0b4bcef07e9e92a2493708b2b.src","preCode":"    @Override protected UnifyResult apply(UnifyRuleCall call) {\n      final MutableJoin query = (MutableJoin) call.query;\n      final MutableCalc qInput0 = (MutableCalc) query.getLeft();\n      final MutableCalc qInput1 = (MutableCalc) query.getRight();\n      final Pair<RexNode, List<RexNode>> qInput0Explained = explainCalc(qInput0);\n      final RexNode qInput0Cond = qInput0Explained.left;\n      final List<RexNode> qInput0Projs = qInput0Explained.right;\n      final Pair<RexNode, List<RexNode>> qInput1Explained = explainCalc(qInput1);\n      final RexNode qInput1Cond = qInput1Explained.left;\n      final List<RexNode> qInput1Projs = qInput1Explained.right;\n\n      final MutableJoin target = (MutableJoin) call.target;\n\n      final RexBuilder rexBuilder = call.getCluster().getRexBuilder();\n\n      \r\n      \r\n      \r\n      final JoinRelType joinRelType = sameJoinType(query.joinType, target.joinType);\n      if (joinRelType == null) {\n        return null;\n      }\n      if (joinRelType != JoinRelType.INNER\n          && !(joinRelType.isOuterJoin()\n              && qInput0Cond.isAlwaysTrue()\n              && qInput1Cond.isAlwaysTrue())) {\n        return null;\n      }\n      if (!referenceByMapping(query.condition, qInput0Projs, qInput1Projs)) {\n        return null;\n      }\n\n      RexNode newQueryJoinCond = new RexShuttle() {\n        @Override public RexNode visitInputRef(RexInputRef inputRef) {\n          final int idx = inputRef.getIndex();\n          if (idx < fieldCnt(qInput0)) {\n            final int newIdx = ((RexInputRef) qInput0Projs.get(idx)).getIndex();\n            return new RexInputRef(newIdx, inputRef.getType());\n          } else {\n            final int newIdx = ((RexInputRef) qInput1Projs.get(idx - fieldCnt(qInput0)))\n                .getIndex() + fieldCnt(qInput0.getInput());\n            return new RexInputRef(newIdx, inputRef.getType());\n          }\n        }\n      }.apply(query.condition);\n      final RexNode splitted =\n          splitFilter(call.getSimplify(), newQueryJoinCond, target.condition);\n      \r\n      if (splitted != null && splitted.isAlwaysTrue()) {\n        final RexNode qInput1CondShifted =\n            RexUtil.shift(qInput1Cond, fieldCnt(qInput0.getInput()));\n        final RexNode compenCond = RexUtil.composeConjunction(rexBuilder,\n            ImmutableList.of(qInput0Cond, qInput1CondShifted));\n\n        final List<RexNode> compenProjs = new ArrayList<>();\n        for (int i = 0; i < query.rowType.getFieldCount(); i++) {\n          if (i < fieldCnt(qInput0)) {\n            compenProjs.add(qInput0Projs.get(i));\n          } else {\n            RexNode shifted = RexUtil.shift(qInput1Projs.get(i - fieldCnt(qInput0)),\n                fieldCnt(qInput0.getInput()));\n            compenProjs.add(shifted);\n          }\n        }\n        final RexProgram compensatingRexProgram = RexProgram.create(\n            target.rowType, compenProjs, compenCond,\n            query.rowType, rexBuilder);\n        final MutableCalc compensatingCalc =\n            MutableCalc.of(target, compensatingRexProgram);\n        return tryMergeParentCalcAndGenResult(call, compensatingCalc);\n      }\n      return null;\n    }\n","realPath":"core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1333,"status":"B"}],"commitId":"93da00b7537527c1457d2f1cdcd3530b61fea207","commitMessage":"@@@[CALCITE-3334] Refinement for Substitution-Based MV Matching (Jin Xing)\n\nThis patch proposes to refine existing implementation by:\n- Canonicalize before MV matching.  through which we can significantly simplify\n  the algebra tree and lower the difficulty for materialization matching.\n- Separate matching rules into two categories and enumerate common matching\n  patterns which needs to be covered by rules.\n\nDesign doc:\nhttps://docs.google.com/document/d/1JpwGNFE3hw3yXb7W3-95-jXKClZC5UFPKbuhgYDuEu4/edit#heading=h.bmvjxz1h5evc\n\nClose #1451\n","date":"2019-10-28 13:09:26","modifiedFileCount":"8","status":"B","submitter":"jinxing"},{"authorTime":"2020-05-29 00:04:40","codes":[{"authorDate":"2020-05-29 00:04:40","commitOrder":2,"curCode":"    @Override protected @Nullable UnifyResult apply(UnifyRuleCall call) {\n      final MutableJoin query = (MutableJoin) call.query;\n      final MutableCalc qInput0 = (MutableCalc) query.getLeft();\n      final MutableRel qInput1 = query.getRight();\n      final Pair<RexNode, List<RexNode>> qInput0Explained = explainCalc(qInput0);\n      final RexNode qInput0Cond = qInput0Explained.left;\n      final List<RexNode> qInput0Projs = qInput0Explained.right;\n\n      final MutableJoin target = (MutableJoin) call.target;\n\n      final RexBuilder rexBuilder = call.getCluster().getRexBuilder();\n\n      \r\n      \r\n      \r\n      final JoinRelType joinRelType = sameJoinType(query.joinType, target.joinType);\n      if (joinRelType == null) {\n        return null;\n      }\n      if (joinRelType != JoinRelType.INNER\n          && !(joinRelType.isOuterJoin() && qInput0Cond.isAlwaysTrue())) {\n        return null;\n      }\n      \r\n      final List<RexNode> identityProjects =\n          rexBuilder.identityProjects(qInput1.rowType);\n      if (!referenceByMapping(query.condition, qInput0Projs, identityProjects)) {\n        return null;\n      }\n\n      final RexNode newQueryJoinCond = new RexShuttle() {\n        @Override public RexNode visitInputRef(RexInputRef inputRef) {\n          final int idx = inputRef.getIndex();\n          if (idx < fieldCnt(qInput0)) {\n            final int newIdx = ((RexInputRef) qInput0Projs.get(idx)).getIndex();\n            return new RexInputRef(newIdx, inputRef.getType());\n          } else {\n            int newIdx = idx - fieldCnt(qInput0) + fieldCnt(qInput0.getInput());\n            return new RexInputRef(newIdx, inputRef.getType());\n          }\n        }\n      }.apply(query.condition);\n\n      final RexNode splitted =\n          splitFilter(call.getSimplify(), newQueryJoinCond, target.condition);\n      \r\n      if (splitted != null && splitted.isAlwaysTrue()) {\n        final RexNode compenCond = qInput0Cond;\n        final List<RexNode> compenProjs = new ArrayList<>();\n        for (int i = 0; i < fieldCnt(query); i++) {\n          if (i < fieldCnt(qInput0)) {\n            compenProjs.add(qInput0Projs.get(i));\n          } else {\n            final int newIdx = i - fieldCnt(qInput0) + fieldCnt(qInput0.getInput());\n            compenProjs.add(\n                new RexInputRef(newIdx, query.rowType.getFieldList().get(i).getType()));\n          }\n        }\n        final RexProgram compenRexProgram = RexProgram.create(\n            target.rowType, compenProjs, compenCond,\n            query.rowType, rexBuilder);\n        final MutableCalc compenCalc = MutableCalc.of(target, compenRexProgram);\n        return tryMergeParentCalcAndGenResult(call, compenCalc);\n      }\n\n      return null;\n    }\n","date":"2020-11-30 06:45:33","endLine":1267,"groupId":"16750","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"apply","params":"(UnifyRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/cf/987d23d57d4619eae578c60232ea52836bdf5c.src","preCode":"    @Override protected UnifyResult apply(UnifyRuleCall call) {\n      final MutableJoin query = (MutableJoin) call.query;\n      final MutableCalc qInput0 = (MutableCalc) query.getLeft();\n      final MutableRel qInput1 = query.getRight();\n      final Pair<RexNode, List<RexNode>> qInput0Explained = explainCalc(qInput0);\n      final RexNode qInput0Cond = qInput0Explained.left;\n      final List<RexNode> qInput0Projs = qInput0Explained.right;\n\n      final MutableJoin target = (MutableJoin) call.target;\n\n      final RexBuilder rexBuilder = call.getCluster().getRexBuilder();\n\n      \r\n      \r\n      \r\n      final JoinRelType joinRelType = sameJoinType(query.joinType, target.joinType);\n      if (joinRelType == null) {\n        return null;\n      }\n      if (joinRelType != JoinRelType.INNER\n          && !(joinRelType.isOuterJoin() && qInput0Cond.isAlwaysTrue())) {\n        return null;\n      }\n      \r\n      final List<RexNode> identityProjects =\n          (List<RexNode>) rexBuilder.identityProjects(qInput1.rowType);\n      if (!referenceByMapping(query.condition, qInput0Projs, identityProjects)) {\n        return null;\n      }\n\n      final RexNode newQueryJoinCond = new RexShuttle() {\n        @Override public RexNode visitInputRef(RexInputRef inputRef) {\n          final int idx = inputRef.getIndex();\n          if (idx < fieldCnt(qInput0)) {\n            final int newIdx = ((RexInputRef) qInput0Projs.get(idx)).getIndex();\n            return new RexInputRef(newIdx, inputRef.getType());\n          } else {\n            int newIdx = idx - fieldCnt(qInput0) + fieldCnt(qInput0.getInput());\n            return new RexInputRef(newIdx, inputRef.getType());\n          }\n        }\n      }.apply(query.condition);\n\n      final RexNode splitted =\n          splitFilter(call.getSimplify(), newQueryJoinCond, target.condition);\n      \r\n      if (splitted != null && splitted.isAlwaysTrue()) {\n        final RexNode compenCond = qInput0Cond;\n        final List<RexNode> compenProjs = new ArrayList<>();\n        for (int i = 0; i < fieldCnt(query); i++) {\n          if (i < fieldCnt(qInput0)) {\n            compenProjs.add(qInput0Projs.get(i));\n          } else {\n            final int newIdx = i - fieldCnt(qInput0) + fieldCnt(qInput0.getInput());\n            compenProjs.add(\n                new RexInputRef(newIdx, query.rowType.getFieldList().get(i).getType()));\n          }\n        }\n        final RexProgram compenRexProgram = RexProgram.create(\n            target.rowType, compenProjs, compenCond,\n            query.rowType, rexBuilder);\n        final MutableCalc compenCalc = MutableCalc.of(target, compenRexProgram);\n        return tryMergeParentCalcAndGenResult(call, compenCalc);\n      }\n\n      return null;\n    }\n","realPath":"core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1201,"status":"M"},{"authorDate":"2020-05-29 00:04:40","commitOrder":2,"curCode":"    @Override protected @Nullable UnifyResult apply(UnifyRuleCall call) {\n      final MutableJoin query = (MutableJoin) call.query;\n      final MutableCalc qInput0 = (MutableCalc) query.getLeft();\n      final MutableCalc qInput1 = (MutableCalc) query.getRight();\n      final Pair<RexNode, List<RexNode>> qInput0Explained = explainCalc(qInput0);\n      final RexNode qInput0Cond = qInput0Explained.left;\n      final List<RexNode> qInput0Projs = qInput0Explained.right;\n      final Pair<RexNode, List<RexNode>> qInput1Explained = explainCalc(qInput1);\n      final RexNode qInput1Cond = qInput1Explained.left;\n      final List<RexNode> qInput1Projs = qInput1Explained.right;\n\n      final MutableJoin target = (MutableJoin) call.target;\n\n      final RexBuilder rexBuilder = call.getCluster().getRexBuilder();\n\n      \r\n      \r\n      \r\n      final JoinRelType joinRelType = sameJoinType(query.joinType, target.joinType);\n      if (joinRelType == null) {\n        return null;\n      }\n      if (joinRelType != JoinRelType.INNER\n          && !(joinRelType.isOuterJoin()\n              && qInput0Cond.isAlwaysTrue()\n              && qInput1Cond.isAlwaysTrue())) {\n        return null;\n      }\n      if (!referenceByMapping(query.condition, qInput0Projs, qInput1Projs)) {\n        return null;\n      }\n\n      RexNode newQueryJoinCond = new RexShuttle() {\n        @Override public RexNode visitInputRef(RexInputRef inputRef) {\n          final int idx = inputRef.getIndex();\n          if (idx < fieldCnt(qInput0)) {\n            final int newIdx = ((RexInputRef) qInput0Projs.get(idx)).getIndex();\n            return new RexInputRef(newIdx, inputRef.getType());\n          } else {\n            final int newIdx = ((RexInputRef) qInput1Projs.get(idx - fieldCnt(qInput0)))\n                .getIndex() + fieldCnt(qInput0.getInput());\n            return new RexInputRef(newIdx, inputRef.getType());\n          }\n        }\n      }.apply(query.condition);\n      final RexNode splitted =\n          splitFilter(call.getSimplify(), newQueryJoinCond, target.condition);\n      \r\n      if (splitted != null && splitted.isAlwaysTrue()) {\n        final RexNode qInput1CondShifted =\n            RexUtil.shift(qInput1Cond, fieldCnt(qInput0.getInput()));\n        final RexNode compenCond = RexUtil.composeConjunction(rexBuilder,\n            ImmutableList.of(qInput0Cond, qInput1CondShifted));\n\n        final List<RexNode> compenProjs = new ArrayList<>();\n        for (int i = 0; i < query.rowType.getFieldCount(); i++) {\n          if (i < fieldCnt(qInput0)) {\n            compenProjs.add(qInput0Projs.get(i));\n          } else {\n            RexNode shifted = RexUtil.shift(qInput1Projs.get(i - fieldCnt(qInput0)),\n                fieldCnt(qInput0.getInput()));\n            compenProjs.add(shifted);\n          }\n        }\n        final RexProgram compensatingRexProgram = RexProgram.create(\n            target.rowType, compenProjs, compenCond,\n            query.rowType, rexBuilder);\n        final MutableCalc compensatingCalc =\n            MutableCalc.of(target, compensatingRexProgram);\n        return tryMergeParentCalcAndGenResult(call, compensatingCalc);\n      }\n      return null;\n    }\n","date":"2020-11-30 06:45:33","endLine":1447,"groupId":"13013","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"apply","params":"(UnifyRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/cf/987d23d57d4619eae578c60232ea52836bdf5c.src","preCode":"    @Override protected UnifyResult apply(UnifyRuleCall call) {\n      final MutableJoin query = (MutableJoin) call.query;\n      final MutableCalc qInput0 = (MutableCalc) query.getLeft();\n      final MutableCalc qInput1 = (MutableCalc) query.getRight();\n      final Pair<RexNode, List<RexNode>> qInput0Explained = explainCalc(qInput0);\n      final RexNode qInput0Cond = qInput0Explained.left;\n      final List<RexNode> qInput0Projs = qInput0Explained.right;\n      final Pair<RexNode, List<RexNode>> qInput1Explained = explainCalc(qInput1);\n      final RexNode qInput1Cond = qInput1Explained.left;\n      final List<RexNode> qInput1Projs = qInput1Explained.right;\n\n      final MutableJoin target = (MutableJoin) call.target;\n\n      final RexBuilder rexBuilder = call.getCluster().getRexBuilder();\n\n      \r\n      \r\n      \r\n      final JoinRelType joinRelType = sameJoinType(query.joinType, target.joinType);\n      if (joinRelType == null) {\n        return null;\n      }\n      if (joinRelType != JoinRelType.INNER\n          && !(joinRelType.isOuterJoin()\n              && qInput0Cond.isAlwaysTrue()\n              && qInput1Cond.isAlwaysTrue())) {\n        return null;\n      }\n      if (!referenceByMapping(query.condition, qInput0Projs, qInput1Projs)) {\n        return null;\n      }\n\n      RexNode newQueryJoinCond = new RexShuttle() {\n        @Override public RexNode visitInputRef(RexInputRef inputRef) {\n          final int idx = inputRef.getIndex();\n          if (idx < fieldCnt(qInput0)) {\n            final int newIdx = ((RexInputRef) qInput0Projs.get(idx)).getIndex();\n            return new RexInputRef(newIdx, inputRef.getType());\n          } else {\n            final int newIdx = ((RexInputRef) qInput1Projs.get(idx - fieldCnt(qInput0)))\n                .getIndex() + fieldCnt(qInput0.getInput());\n            return new RexInputRef(newIdx, inputRef.getType());\n          }\n        }\n      }.apply(query.condition);\n      final RexNode splitted =\n          splitFilter(call.getSimplify(), newQueryJoinCond, target.condition);\n      \r\n      if (splitted != null && splitted.isAlwaysTrue()) {\n        final RexNode qInput1CondShifted =\n            RexUtil.shift(qInput1Cond, fieldCnt(qInput0.getInput()));\n        final RexNode compenCond = RexUtil.composeConjunction(rexBuilder,\n            ImmutableList.of(qInput0Cond, qInput1CondShifted));\n\n        final List<RexNode> compenProjs = new ArrayList<>();\n        for (int i = 0; i < query.rowType.getFieldCount(); i++) {\n          if (i < fieldCnt(qInput0)) {\n            compenProjs.add(qInput0Projs.get(i));\n          } else {\n            RexNode shifted = RexUtil.shift(qInput1Projs.get(i - fieldCnt(qInput0)),\n                fieldCnt(qInput0.getInput()));\n            compenProjs.add(shifted);\n          }\n        }\n        final RexProgram compensatingRexProgram = RexProgram.create(\n            target.rowType, compenProjs, compenCond,\n            query.rowType, rexBuilder);\n        final MutableCalc compensatingCalc =\n            MutableCalc.of(target, compensatingRexProgram);\n        return tryMergeParentCalcAndGenResult(call, compensatingCalc);\n      }\n      return null;\n    }\n","realPath":"core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1375,"status":"M"}],"commitId":"d9a81b88ad561e7e4cedae93e805e0d7a53a7f1a","commitMessage":"@@@[CALCITE-4199] Add nullability annotations\n\nThe commit includes javadoc updates and refactorings made by Julian Hyde in https://github.com/apache/calcite/pull/2278\n","date":"2020-11-30 06:45:33","modifiedFileCount":"1012","status":"M","submitter":"Vladimir Sitnikov"},{"authorTime":"2021-09-16 16:53:31","codes":[{"authorDate":"2021-09-16 16:53:31","commitOrder":3,"curCode":"    @Override protected @Nullable UnifyResult apply(UnifyRuleCall call) {\n      final MutableJoin query = (MutableJoin) call.query;\n      final MutableCalc qInput0 = (MutableCalc) query.getLeft();\n      final MutableRel qInput1 = query.getRight();\n      final Pair<RexNode, List<RexNode>> qInput0Explained = explainCalc(qInput0);\n      final RexNode qInput0Cond = qInput0Explained.left;\n      final List<RexNode> qInput0Projs = qInput0Explained.right;\n\n      final MutableJoin target = (MutableJoin) call.target;\n\n      final RexBuilder rexBuilder = call.getCluster().getRexBuilder();\n\n      \r\n      final JoinRelType joinRelType = sameJoinType(query.joinType, target.joinType);\n      if (joinRelType == null) {\n        return null;\n      }\n      \r\n      if (!canPullUpFilterUnderJoin(joinRelType, qInput0Cond, null)) {\n        return null;\n      }\n      \r\n      final List<RexNode> identityProjects =\n          rexBuilder.identityProjects(qInput1.rowType);\n      if (!referenceByMapping(query.condition, qInput0Projs, identityProjects)) {\n        return null;\n      }\n\n      final RexNode newQueryJoinCond = new RexShuttle() {\n        @Override public RexNode visitInputRef(RexInputRef inputRef) {\n          final int idx = inputRef.getIndex();\n          if (idx < fieldCnt(qInput0)) {\n            final int newIdx = ((RexInputRef) qInput0Projs.get(idx)).getIndex();\n            return new RexInputRef(newIdx, inputRef.getType());\n          } else {\n            int newIdx = idx - fieldCnt(qInput0) + fieldCnt(qInput0.getInput());\n            return new RexInputRef(newIdx, inputRef.getType());\n          }\n        }\n      }.apply(query.condition);\n\n      final RexNode splitted =\n          splitFilter(call.getSimplify(), newQueryJoinCond, target.condition);\n      \r\n      if (splitted != null && splitted.isAlwaysTrue()) {\n        final RexNode compenCond = qInput0Cond;\n        final List<RexNode> compenProjs = new ArrayList<>();\n        for (int i = 0; i < fieldCnt(query); i++) {\n          if (i < fieldCnt(qInput0)) {\n            compenProjs.add(qInput0Projs.get(i));\n          } else {\n            final int newIdx = i - fieldCnt(qInput0) + fieldCnt(qInput0.getInput());\n            compenProjs.add(\n                new RexInputRef(newIdx, query.rowType.getFieldList().get(i).getType()));\n          }\n        }\n        final RexProgram compenRexProgram = RexProgram.create(\n            target.rowType, compenProjs, compenCond,\n            query.rowType, rexBuilder);\n        final MutableCalc compenCalc = MutableCalc.of(target, compenRexProgram);\n        return tryMergeParentCalcAndGenResult(call, compenCalc);\n      }\n\n      return null;\n    }\n","date":"2021-09-20 16:28:23","endLine":1267,"groupId":"111879","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"apply","params":"(UnifyRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/60/a97138b46c85dd274984f899ec245c30078b64.src","preCode":"    @Override protected @Nullable UnifyResult apply(UnifyRuleCall call) {\n      final MutableJoin query = (MutableJoin) call.query;\n      final MutableCalc qInput0 = (MutableCalc) query.getLeft();\n      final MutableRel qInput1 = query.getRight();\n      final Pair<RexNode, List<RexNode>> qInput0Explained = explainCalc(qInput0);\n      final RexNode qInput0Cond = qInput0Explained.left;\n      final List<RexNode> qInput0Projs = qInput0Explained.right;\n\n      final MutableJoin target = (MutableJoin) call.target;\n\n      final RexBuilder rexBuilder = call.getCluster().getRexBuilder();\n\n      \r\n      \r\n      \r\n      final JoinRelType joinRelType = sameJoinType(query.joinType, target.joinType);\n      if (joinRelType == null) {\n        return null;\n      }\n      if (joinRelType != JoinRelType.INNER\n          && !(joinRelType.isOuterJoin() && qInput0Cond.isAlwaysTrue())) {\n        return null;\n      }\n      \r\n      final List<RexNode> identityProjects =\n          rexBuilder.identityProjects(qInput1.rowType);\n      if (!referenceByMapping(query.condition, qInput0Projs, identityProjects)) {\n        return null;\n      }\n\n      final RexNode newQueryJoinCond = new RexShuttle() {\n        @Override public RexNode visitInputRef(RexInputRef inputRef) {\n          final int idx = inputRef.getIndex();\n          if (idx < fieldCnt(qInput0)) {\n            final int newIdx = ((RexInputRef) qInput0Projs.get(idx)).getIndex();\n            return new RexInputRef(newIdx, inputRef.getType());\n          } else {\n            int newIdx = idx - fieldCnt(qInput0) + fieldCnt(qInput0.getInput());\n            return new RexInputRef(newIdx, inputRef.getType());\n          }\n        }\n      }.apply(query.condition);\n\n      final RexNode splitted =\n          splitFilter(call.getSimplify(), newQueryJoinCond, target.condition);\n      \r\n      if (splitted != null && splitted.isAlwaysTrue()) {\n        final RexNode compenCond = qInput0Cond;\n        final List<RexNode> compenProjs = new ArrayList<>();\n        for (int i = 0; i < fieldCnt(query); i++) {\n          if (i < fieldCnt(qInput0)) {\n            compenProjs.add(qInput0Projs.get(i));\n          } else {\n            final int newIdx = i - fieldCnt(qInput0) + fieldCnt(qInput0.getInput());\n            compenProjs.add(\n                new RexInputRef(newIdx, query.rowType.getFieldList().get(i).getType()));\n          }\n        }\n        final RexProgram compenRexProgram = RexProgram.create(\n            target.rowType, compenProjs, compenCond,\n            query.rowType, rexBuilder);\n        final MutableCalc compenCalc = MutableCalc.of(target, compenRexProgram);\n        return tryMergeParentCalcAndGenResult(call, compenCalc);\n      }\n\n      return null;\n    }\n","realPath":"core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1203,"status":"M"},{"authorDate":"2021-09-16 16:53:31","commitOrder":3,"curCode":"    @Override protected @Nullable UnifyResult apply(UnifyRuleCall call) {\n      final MutableJoin query = (MutableJoin) call.query;\n      final MutableCalc qInput0 = (MutableCalc) query.getLeft();\n      final MutableCalc qInput1 = (MutableCalc) query.getRight();\n      final Pair<RexNode, List<RexNode>> qInput0Explained = explainCalc(qInput0);\n      final RexNode qInput0Cond = qInput0Explained.left;\n      final List<RexNode> qInput0Projs = qInput0Explained.right;\n      final Pair<RexNode, List<RexNode>> qInput1Explained = explainCalc(qInput1);\n      final RexNode qInput1Cond = qInput1Explained.left;\n      final List<RexNode> qInput1Projs = qInput1Explained.right;\n\n      final MutableJoin target = (MutableJoin) call.target;\n\n      final RexBuilder rexBuilder = call.getCluster().getRexBuilder();\n\n      \r\n      final JoinRelType joinRelType = sameJoinType(query.joinType, target.joinType);\n      if (joinRelType == null) {\n        return null;\n      }\n      \r\n      if (!canPullUpFilterUnderJoin(joinRelType, qInput0Cond, qInput1Cond)) {\n        return null;\n      }\n      if (!referenceByMapping(query.condition, qInput0Projs, qInput1Projs)) {\n        return null;\n      }\n\n      RexNode newQueryJoinCond = new RexShuttle() {\n        @Override public RexNode visitInputRef(RexInputRef inputRef) {\n          final int idx = inputRef.getIndex();\n          if (idx < fieldCnt(qInput0)) {\n            final int newIdx = ((RexInputRef) qInput0Projs.get(idx)).getIndex();\n            return new RexInputRef(newIdx, inputRef.getType());\n          } else {\n            final int newIdx = ((RexInputRef) qInput1Projs.get(idx - fieldCnt(qInput0)))\n                .getIndex() + fieldCnt(qInput0.getInput());\n            return new RexInputRef(newIdx, inputRef.getType());\n          }\n        }\n      }.apply(query.condition);\n      final RexNode splitted =\n          splitFilter(call.getSimplify(), newQueryJoinCond, target.condition);\n      \r\n      if (splitted != null && splitted.isAlwaysTrue()) {\n        final RexNode qInput1CondShifted =\n            RexUtil.shift(qInput1Cond, fieldCnt(qInput0.getInput()));\n        final RexNode compenCond = RexUtil.composeConjunction(rexBuilder,\n            ImmutableList.of(qInput0Cond, qInput1CondShifted));\n\n        final List<RexNode> compenProjs = new ArrayList<>();\n        for (int i = 0; i < query.rowType.getFieldCount(); i++) {\n          if (i < fieldCnt(qInput0)) {\n            compenProjs.add(qInput0Projs.get(i));\n          } else {\n            RexNode shifted = RexUtil.shift(qInput1Projs.get(i - fieldCnt(qInput0)),\n                fieldCnt(qInput0.getInput()));\n            compenProjs.add(shifted);\n          }\n        }\n        final RexProgram compensatingRexProgram = RexProgram.create(\n            target.rowType, compenProjs, compenCond,\n            query.rowType, rexBuilder);\n        final MutableCalc compensatingCalc =\n            MutableCalc.of(target, compensatingRexProgram);\n        return tryMergeParentCalcAndGenResult(call, compensatingCalc);\n      }\n      return null;\n    }\n","date":"2021-09-20 16:28:23","endLine":1441,"groupId":"111879","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"apply","params":"(UnifyRuleCallcall)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/60/a97138b46c85dd274984f899ec245c30078b64.src","preCode":"    @Override protected @Nullable UnifyResult apply(UnifyRuleCall call) {\n      final MutableJoin query = (MutableJoin) call.query;\n      final MutableCalc qInput0 = (MutableCalc) query.getLeft();\n      final MutableCalc qInput1 = (MutableCalc) query.getRight();\n      final Pair<RexNode, List<RexNode>> qInput0Explained = explainCalc(qInput0);\n      final RexNode qInput0Cond = qInput0Explained.left;\n      final List<RexNode> qInput0Projs = qInput0Explained.right;\n      final Pair<RexNode, List<RexNode>> qInput1Explained = explainCalc(qInput1);\n      final RexNode qInput1Cond = qInput1Explained.left;\n      final List<RexNode> qInput1Projs = qInput1Explained.right;\n\n      final MutableJoin target = (MutableJoin) call.target;\n\n      final RexBuilder rexBuilder = call.getCluster().getRexBuilder();\n\n      \r\n      \r\n      \r\n      final JoinRelType joinRelType = sameJoinType(query.joinType, target.joinType);\n      if (joinRelType == null) {\n        return null;\n      }\n      if (joinRelType != JoinRelType.INNER\n          && !(joinRelType.isOuterJoin()\n              && qInput0Cond.isAlwaysTrue()\n              && qInput1Cond.isAlwaysTrue())) {\n        return null;\n      }\n      if (!referenceByMapping(query.condition, qInput0Projs, qInput1Projs)) {\n        return null;\n      }\n\n      RexNode newQueryJoinCond = new RexShuttle() {\n        @Override public RexNode visitInputRef(RexInputRef inputRef) {\n          final int idx = inputRef.getIndex();\n          if (idx < fieldCnt(qInput0)) {\n            final int newIdx = ((RexInputRef) qInput0Projs.get(idx)).getIndex();\n            return new RexInputRef(newIdx, inputRef.getType());\n          } else {\n            final int newIdx = ((RexInputRef) qInput1Projs.get(idx - fieldCnt(qInput0)))\n                .getIndex() + fieldCnt(qInput0.getInput());\n            return new RexInputRef(newIdx, inputRef.getType());\n          }\n        }\n      }.apply(query.condition);\n      final RexNode splitted =\n          splitFilter(call.getSimplify(), newQueryJoinCond, target.condition);\n      \r\n      if (splitted != null && splitted.isAlwaysTrue()) {\n        final RexNode qInput1CondShifted =\n            RexUtil.shift(qInput1Cond, fieldCnt(qInput0.getInput()));\n        final RexNode compenCond = RexUtil.composeConjunction(rexBuilder,\n            ImmutableList.of(qInput0Cond, qInput1CondShifted));\n\n        final List<RexNode> compenProjs = new ArrayList<>();\n        for (int i = 0; i < query.rowType.getFieldCount(); i++) {\n          if (i < fieldCnt(qInput0)) {\n            compenProjs.add(qInput0Projs.get(i));\n          } else {\n            RexNode shifted = RexUtil.shift(qInput1Projs.get(i - fieldCnt(qInput0)),\n                fieldCnt(qInput0.getInput()));\n            compenProjs.add(shifted);\n          }\n        }\n        final RexProgram compensatingRexProgram = RexProgram.create(\n            target.rowType, compenProjs, compenCond,\n            query.rowType, rexBuilder);\n        final MutableCalc compensatingCalc =\n            MutableCalc.of(target, compensatingRexProgram);\n        return tryMergeParentCalcAndGenResult(call, compensatingCalc);\n      }\n      return null;\n    }\n","realPath":"core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1373,"status":"M"}],"commitId":"a36f5a21f006ee717e7949269a99fa48a65f6abe","commitMessage":"@@@[CALCITE-3935] Enhance Join-Materialization.  support to pull-up filters under join of left or right (xurenhe)\n","date":"2021-09-20 16:28:23","modifiedFileCount":"2","status":"M","submitter":"xurenhe"}]
