[{"authorTime":"2017-09-14 13:27:57","codes":[{"authorDate":"2017-09-14 13:27:57","commitOrder":1,"curCode":"  @Override public void unparseCall(SqlWriter writer, SqlCall call,\n      int leftPrec, int rightPrec) {\n    if (call.getOperator() == SqlStdOperatorTable.SUBSTRING) {\n      SqlUtil.unparseFunctionSyntax(OracleSqlOperatorTable.SUBSTR, writer, call);\n    } else {\n      switch (call.getKind()) {\n      case FLOOR:\n        if (call.operandCount() != 2) {\n          super.unparseCall(writer, call, leftPrec, rightPrec);\n          return;\n        }\n\n        final SqlLiteral timeUnitNode = call.operand(1);\n        final TimeUnitRange timeUnit = timeUnitNode.getValueAs(TimeUnitRange.class);\n\n        SqlCall call2 = SqlFloorFunction.replaceTimeUnitOperand(call, timeUnit.name(),\n            timeUnitNode.getParserPosition());\n        SqlFloorFunction.unparseDatetimeFunction(writer, call2, \"TRUNC\", true);\n        break;\n\n      default:\n        super.unparseCall(writer, call, leftPrec, rightPrec);\n      }\n    }\n  }\n","date":"2017-10-03 03:28:20","endLine":75,"groupId":"1257","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"unparseCall","params":"(SqlWriterwriter@SqlCallcall@intleftPrec@intrightPrec)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/cd/ac9d7c96ec1a918a1086f4ffa5c8cc14f6f10c.src","preCode":"  @Override public void unparseCall(SqlWriter writer, SqlCall call,\n      int leftPrec, int rightPrec) {\n    if (call.getOperator() == SqlStdOperatorTable.SUBSTRING) {\n      SqlUtil.unparseFunctionSyntax(OracleSqlOperatorTable.SUBSTR, writer, call);\n    } else {\n      switch (call.getKind()) {\n      case FLOOR:\n        if (call.operandCount() != 2) {\n          super.unparseCall(writer, call, leftPrec, rightPrec);\n          return;\n        }\n\n        final SqlLiteral timeUnitNode = call.operand(1);\n        final TimeUnitRange timeUnit = timeUnitNode.getValueAs(TimeUnitRange.class);\n\n        SqlCall call2 = SqlFloorFunction.replaceTimeUnitOperand(call, timeUnit.name(),\n            timeUnitNode.getParserPosition());\n        SqlFloorFunction.unparseDatetimeFunction(writer, call2, \"TRUNC\", true);\n        break;\n\n      default:\n        super.unparseCall(writer, call, leftPrec, rightPrec);\n      }\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/dialect/OracleSqlDialect.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":51,"status":"B"},{"authorDate":"2017-09-14 13:27:57","commitOrder":1,"curCode":"  @Override public void unparseCall(SqlWriter writer, SqlCall call,\n      int leftPrec, int rightPrec) {\n    switch (call.getKind()) {\n    case FLOOR:\n      if (call.operandCount() != 2) {\n        super.unparseCall(writer, call, leftPrec, rightPrec);\n        return;\n      }\n\n      final SqlLiteral timeUnitNode = call.operand(1);\n      final TimeUnitRange timeUnit = timeUnitNode.getValueAs(TimeUnitRange.class);\n\n      SqlCall call2 = SqlFloorFunction.replaceTimeUnitOperand(call, timeUnit.name(),\n          timeUnitNode.getParserPosition());\n      SqlFloorFunction.unparseDatetimeFunction(writer, call2, \"DATE_TRUNC\", false);\n      break;\n\n    default:\n      super.unparseCall(writer, call, leftPrec, rightPrec);\n    }\n  }\n","date":"2017-10-03 03:28:20","endLine":72,"groupId":"1257","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"unparseCall","params":"(SqlWriterwriter@SqlCallcall@intleftPrec@intrightPrec)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/6a/6014ec04def9ff14397d9585ef6938c06c6e3f.src","preCode":"  @Override public void unparseCall(SqlWriter writer, SqlCall call,\n      int leftPrec, int rightPrec) {\n    switch (call.getKind()) {\n    case FLOOR:\n      if (call.operandCount() != 2) {\n        super.unparseCall(writer, call, leftPrec, rightPrec);\n        return;\n      }\n\n      final SqlLiteral timeUnitNode = call.operand(1);\n      final TimeUnitRange timeUnit = timeUnitNode.getValueAs(TimeUnitRange.class);\n\n      SqlCall call2 = SqlFloorFunction.replaceTimeUnitOperand(call, timeUnit.name(),\n          timeUnitNode.getParserPosition());\n      SqlFloorFunction.unparseDatetimeFunction(writer, call2, \"DATE_TRUNC\", false);\n      break;\n\n    default:\n      super.unparseCall(writer, call, leftPrec, rightPrec);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/dialect/PostgresqlSqlDialect.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":52,"status":"B"}],"commitId":"914b5cfbf978e796afeaff7b780e268ed39d8ec5","commitMessage":"@@@[CALCITE-1913] Replace usages of DatabaseProduct with dialect methods.  and introduce a configurable SqlDialectFactory (Christian Beikov)\n\nCreate class SqlDialect.Context to hold all arguments to the\nconstructor of a SqlDialect.  including allowing future expansion.\n(Julian Hyde)\n\nBack out Christian's deprecation of DatabaseProduct. In my opinion. \ndeprecation is a step too far. People can use it if they like.  but\nthere are usually better alternatives. (Julian Hyde)\n\nClose apache/calcite#540\n","date":"2017-10-03 03:28:20","modifiedFileCount":"30","status":"B","submitter":"Christian Beikov"},{"authorTime":"2017-09-14 13:27:57","codes":[{"authorDate":"2019-04-25 12:00:28","commitOrder":2,"curCode":"  @Override public void unparseCall(SqlWriter writer, SqlCall call,\n      int leftPrec, int rightPrec) {\n    if (call.getOperator() == SqlStdOperatorTable.SUBSTRING) {\n      SqlUtil.unparseFunctionSyntax(SqlLibraryOperators.SUBSTR, writer, call);\n    } else {\n      switch (call.getKind()) {\n      case FLOOR:\n        if (call.operandCount() != 2) {\n          super.unparseCall(writer, call, leftPrec, rightPrec);\n          return;\n        }\n\n        final SqlLiteral timeUnitNode = call.operand(1);\n        final TimeUnitRange timeUnit = timeUnitNode.getValueAs(TimeUnitRange.class);\n\n        SqlCall call2 = SqlFloorFunction.replaceTimeUnitOperand(call, timeUnit.name(),\n            timeUnitNode.getParserPosition());\n        SqlFloorFunction.unparseDatetimeFunction(writer, call2, \"TRUNC\", true);\n        break;\n\n      default:\n        super.unparseCall(writer, call, leftPrec, rightPrec);\n      }\n    }\n  }\n","date":"2019-05-12 14:03:15","endLine":79,"groupId":"1257","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"unparseCall","params":"(SqlWriterwriter@SqlCallcall@intleftPrec@intrightPrec)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/ad/583196ce63190ef2a817cdc9c819f247eb7846.src","preCode":"  @Override public void unparseCall(SqlWriter writer, SqlCall call,\n      int leftPrec, int rightPrec) {\n    if (call.getOperator() == SqlStdOperatorTable.SUBSTRING) {\n      SqlUtil.unparseFunctionSyntax(OracleSqlOperatorTable.SUBSTR, writer, call);\n    } else {\n      switch (call.getKind()) {\n      case FLOOR:\n        if (call.operandCount() != 2) {\n          super.unparseCall(writer, call, leftPrec, rightPrec);\n          return;\n        }\n\n        final SqlLiteral timeUnitNode = call.operand(1);\n        final TimeUnitRange timeUnit = timeUnitNode.getValueAs(TimeUnitRange.class);\n\n        SqlCall call2 = SqlFloorFunction.replaceTimeUnitOperand(call, timeUnit.name(),\n            timeUnitNode.getParserPosition());\n        SqlFloorFunction.unparseDatetimeFunction(writer, call2, \"TRUNC\", true);\n        break;\n\n      default:\n        super.unparseCall(writer, call, leftPrec, rightPrec);\n      }\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/dialect/OracleSqlDialect.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"M"},{"authorDate":"2017-09-14 13:27:57","commitOrder":2,"curCode":"  @Override public void unparseCall(SqlWriter writer, SqlCall call,\n      int leftPrec, int rightPrec) {\n    switch (call.getKind()) {\n    case FLOOR:\n      if (call.operandCount() != 2) {\n        super.unparseCall(writer, call, leftPrec, rightPrec);\n        return;\n      }\n\n      final SqlLiteral timeUnitNode = call.operand(1);\n      final TimeUnitRange timeUnit = timeUnitNode.getValueAs(TimeUnitRange.class);\n\n      SqlCall call2 = SqlFloorFunction.replaceTimeUnitOperand(call, timeUnit.name(),\n          timeUnitNode.getParserPosition());\n      SqlFloorFunction.unparseDatetimeFunction(writer, call2, \"DATE_TRUNC\", false);\n      break;\n\n    default:\n      super.unparseCall(writer, call, leftPrec, rightPrec);\n    }\n  }\n","date":"2017-10-03 03:28:20","endLine":72,"groupId":"1257","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"unparseCall","params":"(SqlWriterwriter@SqlCallcall@intleftPrec@intrightPrec)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/6a/6014ec04def9ff14397d9585ef6938c06c6e3f.src","preCode":"  @Override public void unparseCall(SqlWriter writer, SqlCall call,\n      int leftPrec, int rightPrec) {\n    switch (call.getKind()) {\n    case FLOOR:\n      if (call.operandCount() != 2) {\n        super.unparseCall(writer, call, leftPrec, rightPrec);\n        return;\n      }\n\n      final SqlLiteral timeUnitNode = call.operand(1);\n      final TimeUnitRange timeUnit = timeUnitNode.getValueAs(TimeUnitRange.class);\n\n      SqlCall call2 = SqlFloorFunction.replaceTimeUnitOperand(call, timeUnit.name(),\n          timeUnitNode.getParserPosition());\n      SqlFloorFunction.unparseDatetimeFunction(writer, call2, \"DATE_TRUNC\", false);\n      break;\n\n    default:\n      super.unparseCall(writer, call, leftPrec, rightPrec);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/dialect/PostgresqlSqlDialect.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":52,"status":"N"}],"commitId":"9a4eab5240d96379431d14a1ac33bfebaf6fbb28","commitMessage":"@@@[CALCITE-3017] Re-organize how we represent built-in operators that are not in the standard operator table\n\nAdd enum SqlLibrary.  with values STANDARD.  SPATIAL.  ORACLE.  MYSQL etc.. \nand SqlLibraryOperatorTableFactory.  that can create operator tables for\nany combination of libraries.\n\nFurther changes by Julian Hyde:\n * Adopt the term \"library\" (earlier revisions had \"dialect\" and \"flavor\");\n * Change SqlDialectOperatorTableFactory into a cache (previously it\n   pre-built one table per library);\n * Make it responsible for standard and spatial libraries in addition to\n   database-specific ones;\n * Move operators from SqlLibraryOperatorTableFactory into a dedicated\n   holder class.  SqlLibraryOperators;\n * Deprecate OracleSqlOperatorTable.  and move its operator definitions.\n\nClose apache/calcite#1203\n","date":"2019-05-12 14:03:15","modifiedFileCount":"12","status":"M","submitter":"yuzhao.cyz"},{"authorTime":"2017-09-14 13:27:57","codes":[{"authorDate":"2020-10-20 13:55:40","commitOrder":3,"curCode":"  @Override public void unparseCall(SqlWriter writer, SqlCall call,\n      int leftPrec, int rightPrec) {\n    if (call.getOperator() == SqlStdOperatorTable.SUBSTRING) {\n      SqlUtil.unparseFunctionSyntax(SqlLibraryOperators.SUBSTR, writer, call, false);\n    } else {\n      switch (call.getKind()) {\n      case FLOOR:\n        if (call.operandCount() != 2) {\n          super.unparseCall(writer, call, leftPrec, rightPrec);\n          return;\n        }\n\n        final SqlLiteral timeUnitNode = call.operand(1);\n        final TimeUnitRange timeUnit = timeUnitNode.getValueAs(TimeUnitRange.class);\n\n        SqlCall call2 = SqlFloorFunction.replaceTimeUnitOperand(call, timeUnit.name(),\n            timeUnitNode.getParserPosition());\n        SqlFloorFunction.unparseDatetimeFunction(writer, call2, \"TRUNC\", true);\n        break;\n\n      default:\n        super.unparseCall(writer, call, leftPrec, rightPrec);\n      }\n    }\n  }\n","date":"2020-10-23 05:29:41","endLine":164,"groupId":"1257","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"unparseCall","params":"(SqlWriterwriter@SqlCallcall@intleftPrec@intrightPrec)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/de/eb8a50fe775bf757987927ccd5297c4fff60af.src","preCode":"  @Override public void unparseCall(SqlWriter writer, SqlCall call,\n      int leftPrec, int rightPrec) {\n    if (call.getOperator() == SqlStdOperatorTable.SUBSTRING) {\n      SqlUtil.unparseFunctionSyntax(SqlLibraryOperators.SUBSTR, writer, call);\n    } else {\n      switch (call.getKind()) {\n      case FLOOR:\n        if (call.operandCount() != 2) {\n          super.unparseCall(writer, call, leftPrec, rightPrec);\n          return;\n        }\n\n        final SqlLiteral timeUnitNode = call.operand(1);\n        final TimeUnitRange timeUnit = timeUnitNode.getValueAs(TimeUnitRange.class);\n\n        SqlCall call2 = SqlFloorFunction.replaceTimeUnitOperand(call, timeUnit.name(),\n            timeUnitNode.getParserPosition());\n        SqlFloorFunction.unparseDatetimeFunction(writer, call2, \"TRUNC\", true);\n        break;\n\n      default:\n        super.unparseCall(writer, call, leftPrec, rightPrec);\n      }\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/dialect/OracleSqlDialect.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":140,"status":"M"},{"authorDate":"2017-09-14 13:27:57","commitOrder":3,"curCode":"  @Override public void unparseCall(SqlWriter writer, SqlCall call,\n      int leftPrec, int rightPrec) {\n    switch (call.getKind()) {\n    case FLOOR:\n      if (call.operandCount() != 2) {\n        super.unparseCall(writer, call, leftPrec, rightPrec);\n        return;\n      }\n\n      final SqlLiteral timeUnitNode = call.operand(1);\n      final TimeUnitRange timeUnit = timeUnitNode.getValueAs(TimeUnitRange.class);\n\n      SqlCall call2 = SqlFloorFunction.replaceTimeUnitOperand(call, timeUnit.name(),\n          timeUnitNode.getParserPosition());\n      SqlFloorFunction.unparseDatetimeFunction(writer, call2, \"DATE_TRUNC\", false);\n      break;\n\n    default:\n      super.unparseCall(writer, call, leftPrec, rightPrec);\n    }\n  }\n","date":"2017-10-03 03:28:20","endLine":72,"groupId":"1257","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"unparseCall","params":"(SqlWriterwriter@SqlCallcall@intleftPrec@intrightPrec)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/6a/6014ec04def9ff14397d9585ef6938c06c6e3f.src","preCode":"  @Override public void unparseCall(SqlWriter writer, SqlCall call,\n      int leftPrec, int rightPrec) {\n    switch (call.getKind()) {\n    case FLOOR:\n      if (call.operandCount() != 2) {\n        super.unparseCall(writer, call, leftPrec, rightPrec);\n        return;\n      }\n\n      final SqlLiteral timeUnitNode = call.operand(1);\n      final TimeUnitRange timeUnit = timeUnitNode.getValueAs(TimeUnitRange.class);\n\n      SqlCall call2 = SqlFloorFunction.replaceTimeUnitOperand(call, timeUnit.name(),\n          timeUnitNode.getParserPosition());\n      SqlFloorFunction.unparseDatetimeFunction(writer, call2, \"DATE_TRUNC\", false);\n      break;\n\n    default:\n      super.unparseCall(writer, call, leftPrec, rightPrec);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/dialect/PostgresqlSqlDialect.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":52,"status":"N"}],"commitId":"3038fb7e87c51740ef733fd4f9bde41b0c25e5b0","commitMessage":"@@@[CALCITE-4335] ARRAY_AGG.  ARRAY_CONCAT_AGG.  STRING_AGG aggregate functions for BigQuery\n","date":"2020-10-23 05:29:41","modifiedFileCount":"24","status":"M","submitter":"Julian Hyde"},{"authorTime":"2017-09-14 13:27:57","codes":[{"authorDate":"2020-11-19 06:16:27","commitOrder":4,"curCode":"  @Override public void unparseCall(SqlWriter writer, SqlCall call,\n      int leftPrec, int rightPrec) {\n    if (call.getOperator() == SqlStdOperatorTable.SUBSTRING) {\n      SqlUtil.unparseFunctionSyntax(SqlLibraryOperators.ORACLE_SUBSTR, writer,\n          call, false);\n    } else {\n      switch (call.getKind()) {\n      case FLOOR:\n        if (call.operandCount() != 2) {\n          super.unparseCall(writer, call, leftPrec, rightPrec);\n          return;\n        }\n\n        final SqlLiteral timeUnitNode = call.operand(1);\n        final TimeUnitRange timeUnit = timeUnitNode.getValueAs(TimeUnitRange.class);\n\n        SqlCall call2 = SqlFloorFunction.replaceTimeUnitOperand(call, timeUnit.name(),\n            timeUnitNode.getParserPosition());\n        SqlFloorFunction.unparseDatetimeFunction(writer, call2, \"TRUNC\", true);\n        break;\n\n      default:\n        super.unparseCall(writer, call, leftPrec, rightPrec);\n      }\n    }\n  }\n","date":"2020-12-04 11:53:16","endLine":167,"groupId":"1257","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"unparseCall","params":"(SqlWriterwriter@SqlCallcall@intleftPrec@intrightPrec)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/9b/1f4e494576fdb707f2964c323ce5f44f3109bc.src","preCode":"  @Override public void unparseCall(SqlWriter writer, SqlCall call,\n      int leftPrec, int rightPrec) {\n    if (call.getOperator() == SqlStdOperatorTable.SUBSTRING) {\n      SqlUtil.unparseFunctionSyntax(SqlLibraryOperators.SUBSTR, writer, call, false);\n    } else {\n      switch (call.getKind()) {\n      case FLOOR:\n        if (call.operandCount() != 2) {\n          super.unparseCall(writer, call, leftPrec, rightPrec);\n          return;\n        }\n\n        final SqlLiteral timeUnitNode = call.operand(1);\n        final TimeUnitRange timeUnit = timeUnitNode.getValueAs(TimeUnitRange.class);\n\n        SqlCall call2 = SqlFloorFunction.replaceTimeUnitOperand(call, timeUnit.name(),\n            timeUnitNode.getParserPosition());\n        SqlFloorFunction.unparseDatetimeFunction(writer, call2, \"TRUNC\", true);\n        break;\n\n      default:\n        super.unparseCall(writer, call, leftPrec, rightPrec);\n      }\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/dialect/OracleSqlDialect.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":142,"status":"M"},{"authorDate":"2017-09-14 13:27:57","commitOrder":4,"curCode":"  @Override public void unparseCall(SqlWriter writer, SqlCall call,\n      int leftPrec, int rightPrec) {\n    switch (call.getKind()) {\n    case FLOOR:\n      if (call.operandCount() != 2) {\n        super.unparseCall(writer, call, leftPrec, rightPrec);\n        return;\n      }\n\n      final SqlLiteral timeUnitNode = call.operand(1);\n      final TimeUnitRange timeUnit = timeUnitNode.getValueAs(TimeUnitRange.class);\n\n      SqlCall call2 = SqlFloorFunction.replaceTimeUnitOperand(call, timeUnit.name(),\n          timeUnitNode.getParserPosition());\n      SqlFloorFunction.unparseDatetimeFunction(writer, call2, \"DATE_TRUNC\", false);\n      break;\n\n    default:\n      super.unparseCall(writer, call, leftPrec, rightPrec);\n    }\n  }\n","date":"2017-10-03 03:28:20","endLine":72,"groupId":"1257","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"unparseCall","params":"(SqlWriterwriter@SqlCallcall@intleftPrec@intrightPrec)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/6a/6014ec04def9ff14397d9585ef6938c06c6e3f.src","preCode":"  @Override public void unparseCall(SqlWriter writer, SqlCall call,\n      int leftPrec, int rightPrec) {\n    switch (call.getKind()) {\n    case FLOOR:\n      if (call.operandCount() != 2) {\n        super.unparseCall(writer, call, leftPrec, rightPrec);\n        return;\n      }\n\n      final SqlLiteral timeUnitNode = call.operand(1);\n      final TimeUnitRange timeUnit = timeUnitNode.getValueAs(TimeUnitRange.class);\n\n      SqlCall call2 = SqlFloorFunction.replaceTimeUnitOperand(call, timeUnit.name(),\n          timeUnitNode.getParserPosition());\n      SqlFloorFunction.unparseDatetimeFunction(writer, call2, \"DATE_TRUNC\", false);\n      break;\n\n    default:\n      super.unparseCall(writer, call, leftPrec, rightPrec);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/dialect/PostgresqlSqlDialect.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":52,"status":"N"}],"commitId":"0327135376246eb58e1703fc13d555efaf389ada","commitMessage":"@@@[CALCITE-4408] Implement Oracle SUBSTR function (James Starr)\n\nAdd an operand type checker for the Oracle SUBSTR. Becauses\nsemantics are different to standard SUBSTRING.  implement by\ntranslating to SUBSTRING with a CASE expression to handle the\ndifferences.\n\nThe implementation assumes that SUBSTRING is consistent with\nBigQuery.  not ISO Standard SQL.  and may need rework when\n  [CALCITE-4427] Make SUBSTRING operator comply with ISO\n  standard SQL\nis fixed.\n\nRework so that it gives the right result for very negative\nstart; add tests for MySQL and PostgreSQL variants of SUBSTR\n(Julian Hyde).\n\nClose apache/calcite#2271\n","date":"2020-12-04 11:53:16","modifiedFileCount":"6","status":"M","submitter":"James Starr"},{"authorTime":"2017-09-14 13:27:57","codes":[{"authorDate":"2020-12-09 05:01:39","commitOrder":5,"curCode":"  @Override public void unparseCall(SqlWriter writer, SqlCall call,\n      int leftPrec, int rightPrec) {\n    if (call.getOperator() == SqlStdOperatorTable.SUBSTRING) {\n      SqlUtil.unparseFunctionSyntax(SqlLibraryOperators.SUBSTR_ORACLE, writer,\n          call, false);\n    } else {\n      switch (call.getKind()) {\n      case FLOOR:\n        if (call.operandCount() != 2) {\n          super.unparseCall(writer, call, leftPrec, rightPrec);\n          return;\n        }\n\n        final SqlLiteral timeUnitNode = call.operand(1);\n        final TimeUnitRange timeUnit = timeUnitNode.getValueAs(TimeUnitRange.class);\n\n        SqlCall call2 = SqlFloorFunction.replaceTimeUnitOperand(call, timeUnit.name(),\n            timeUnitNode.getParserPosition());\n        SqlFloorFunction.unparseDatetimeFunction(writer, call2, \"TRUNC\", true);\n        break;\n\n      default:\n        super.unparseCall(writer, call, leftPrec, rightPrec);\n      }\n    }\n  }\n","date":"2020-12-10 07:05:35","endLine":167,"groupId":"101831","id":9,"instanceNumber":1,"isCurCommit":1,"methodName":"unparseCall","params":"(SqlWriterwriter@SqlCallcall@intleftPrec@intrightPrec)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/b9/8b284d855891c3d59705eb87bb7224c711a5b4.src","preCode":"  @Override public void unparseCall(SqlWriter writer, SqlCall call,\n      int leftPrec, int rightPrec) {\n    if (call.getOperator() == SqlStdOperatorTable.SUBSTRING) {\n      SqlUtil.unparseFunctionSyntax(SqlLibraryOperators.ORACLE_SUBSTR, writer,\n          call, false);\n    } else {\n      switch (call.getKind()) {\n      case FLOOR:\n        if (call.operandCount() != 2) {\n          super.unparseCall(writer, call, leftPrec, rightPrec);\n          return;\n        }\n\n        final SqlLiteral timeUnitNode = call.operand(1);\n        final TimeUnitRange timeUnit = timeUnitNode.getValueAs(TimeUnitRange.class);\n\n        SqlCall call2 = SqlFloorFunction.replaceTimeUnitOperand(call, timeUnit.name(),\n            timeUnitNode.getParserPosition());\n        SqlFloorFunction.unparseDatetimeFunction(writer, call2, \"TRUNC\", true);\n        break;\n\n      default:\n        super.unparseCall(writer, call, leftPrec, rightPrec);\n      }\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/dialect/OracleSqlDialect.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":142,"status":"M"},{"authorDate":"2017-09-14 13:27:57","commitOrder":5,"curCode":"  @Override public void unparseCall(SqlWriter writer, SqlCall call,\n      int leftPrec, int rightPrec) {\n    switch (call.getKind()) {\n    case FLOOR:\n      if (call.operandCount() != 2) {\n        super.unparseCall(writer, call, leftPrec, rightPrec);\n        return;\n      }\n\n      final SqlLiteral timeUnitNode = call.operand(1);\n      final TimeUnitRange timeUnit = timeUnitNode.getValueAs(TimeUnitRange.class);\n\n      SqlCall call2 = SqlFloorFunction.replaceTimeUnitOperand(call, timeUnit.name(),\n          timeUnitNode.getParserPosition());\n      SqlFloorFunction.unparseDatetimeFunction(writer, call2, \"DATE_TRUNC\", false);\n      break;\n\n    default:\n      super.unparseCall(writer, call, leftPrec, rightPrec);\n    }\n  }\n","date":"2017-10-03 03:28:20","endLine":72,"groupId":"101831","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"unparseCall","params":"(SqlWriterwriter@SqlCallcall@intleftPrec@intrightPrec)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/6a/6014ec04def9ff14397d9585ef6938c06c6e3f.src","preCode":"  @Override public void unparseCall(SqlWriter writer, SqlCall call,\n      int leftPrec, int rightPrec) {\n    switch (call.getKind()) {\n    case FLOOR:\n      if (call.operandCount() != 2) {\n        super.unparseCall(writer, call, leftPrec, rightPrec);\n        return;\n      }\n\n      final SqlLiteral timeUnitNode = call.operand(1);\n      final TimeUnitRange timeUnit = timeUnitNode.getValueAs(TimeUnitRange.class);\n\n      SqlCall call2 = SqlFloorFunction.replaceTimeUnitOperand(call, timeUnit.name(),\n          timeUnitNode.getParserPosition());\n      SqlFloorFunction.unparseDatetimeFunction(writer, call2, \"DATE_TRUNC\", false);\n      break;\n\n    default:\n      super.unparseCall(writer, call, leftPrec, rightPrec);\n    }\n  }\n","realPath":"core/src/main/java/org/apache/calcite/sql/dialect/PostgresqlSqlDialect.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":52,"status":"N"}],"commitId":"0ab1fe3118cc5adb8750a5c785e24fa4381afda1","commitMessage":"@@@[CALCITE-4427] Make SUBSTRING operator comply with ISO standard SQL\n\nIf you want the old behavior (which was consistent with\nBigQuery but not with ISO standard SQL).  set\nconformance=BIG_QUERY in your connection properties.\n\nIn SqlConformance.  add method semantics() that controls the\nsemantics of standard functions. The default is STANDARD. In\nBIG_QUERY semantics.  the SUBSTRING function treats negative\nstart values differently.\n\nAdd implementations of SUBSTR for BigQuery.  MySQL.  PostgreSQL\n(we already have Oracle). Each have slightly different\nbehavior.  consistent with their DBs of origin. PostgreSQL's\nSUBSTR is consistent with ISO standard SQL's SUBSTRING.\n\nUnlike SUBSTRING.  the behavior of your SUBSTR function\ndepends on which operator table you got it from. For example. \nif you specify fun=bigquery in your connection properties. \nyour SUBSTR function will be consistent with BigQuery.\n\nAdd function OCTET_LENGTH.  the BINARY equivalent of CHAR_LENGTH.\n","date":"2020-12-10 07:05:35","modifiedFileCount":"18","status":"M","submitter":"Julian Hyde"}]
