[{"authorTime":"2018-01-01 18:45:32","codes":[{"authorDate":"2018-01-01 18:45:32","commitOrder":1,"curCode":"  @Test public void testExtractWithOrCondition1() {\n    \r\n    \r\n    \r\n    \r\n    final Fixture2 f = new Fixture2();\n    checkDateRange(f,\n        f.or(\n            f.and(f.eq(f.exYear, f.literal(2000)),\n                f.or(f.eq(f.exMonth, f.literal(2)),\n                    f.eq(f.exMonth, f.literal(3)),\n                    f.eq(f.exMonth, f.literal(5)))),\n            f.and(f.eq(f.exYear, f.literal(2001)),\n                f.eq(f.exMonth, f.literal(1)))),\n        is(\"OR(AND(AND(>=($9, 2000-01-01), <($9, 2001-01-01)),\"\n            + \" OR(AND(>=($9, 2000-02-01), <($9, 2000-03-01)),\"\n            + \" AND(>=($9, 2000-03-01), <($9, 2000-04-01)),\"\n            + \" AND(>=($9, 2000-05-01), <($9, 2000-06-01)))),\"\n            + \" AND(AND(>=($9, 2001-01-01), <($9, 2002-01-01)),\"\n            + \" AND(>=($9, 2001-01-01), <($9, 2001-02-01))))\"));\n  }\n","date":"2018-01-03 06:24:51","endLine":204,"groupId":"5607","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testExtractWithOrCondition1","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/ae/c4d20bc2ffe1feb384c8bc0cdfe2d267657b01.src","preCode":"  @Test public void testExtractWithOrCondition1() {\n    \r\n    \r\n    \r\n    \r\n    final Fixture2 f = new Fixture2();\n    checkDateRange(f,\n        f.or(\n            f.and(f.eq(f.exYear, f.literal(2000)),\n                f.or(f.eq(f.exMonth, f.literal(2)),\n                    f.eq(f.exMonth, f.literal(3)),\n                    f.eq(f.exMonth, f.literal(5)))),\n            f.and(f.eq(f.exYear, f.literal(2001)),\n                f.eq(f.exMonth, f.literal(1)))),\n        is(\"OR(AND(AND(>=($9, 2000-01-01), <($9, 2001-01-01)),\"\n            + \" OR(AND(>=($9, 2000-02-01), <($9, 2000-03-01)),\"\n            + \" AND(>=($9, 2000-03-01), <($9, 2000-04-01)),\"\n            + \" AND(>=($9, 2000-05-01), <($9, 2000-06-01)))),\"\n            + \" AND(AND(>=($9, 2001-01-01), <($9, 2002-01-01)),\"\n            + \" AND(>=($9, 2001-01-01), <($9, 2001-02-01))))\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rules/DateRangeRulesTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":184,"status":"B"},{"authorDate":"2018-01-01 18:45:32","commitOrder":1,"curCode":"  @Test public void testExtractPartialRewriteForNotEqualsYear() {\n    \r\n    \r\n    \r\n    \r\n    \r\n    final Fixture2 f = new Fixture2();\n    checkDateRange(f,\n        f.and(\n            f.ne(f.exYear, f.literal(2000)),\n            f.or(\n                f.and(f.eq(f.exYear, f.literal(2000)),\n                    f.or(f.eq(f.exMonth, f.literal(2)),\n                        f.eq(f.exMonth, f.literal(3)),\n                        f.eq(f.exMonth, f.literal(5)))),\n                f.and(f.eq(f.exYear, f.literal(2001)),\n                    f.eq(f.exMonth, f.literal(1))))),\n        is(\"AND(<>(EXTRACT(FLAG(YEAR), $9), 2000),\"\n            + \" OR(AND(AND(>=($9, 2000-01-01), <($9, 2001-01-01)),\"\n            + \" OR(AND(>=($9, 2000-02-01), <($9, 2000-03-01)),\"\n            + \" AND(>=($9, 2000-03-01), <($9, 2000-04-01)),\"\n            + \" AND(>=($9, 2000-05-01), <($9, 2000-06-01)))),\"\n            + \" AND(AND(>=($9, 2001-01-01), <($9, 2002-01-01)),\"\n            + \" AND(>=($9, 2001-01-01), <($9, 2001-02-01)))))\"));\n  }\n","date":"2018-01-03 06:24:51","endLine":264,"groupId":"5607","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testExtractPartialRewriteForNotEqualsYear","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/ae/c4d20bc2ffe1feb384c8bc0cdfe2d267657b01.src","preCode":"  @Test public void testExtractPartialRewriteForNotEqualsYear() {\n    \r\n    \r\n    \r\n    \r\n    \r\n    final Fixture2 f = new Fixture2();\n    checkDateRange(f,\n        f.and(\n            f.ne(f.exYear, f.literal(2000)),\n            f.or(\n                f.and(f.eq(f.exYear, f.literal(2000)),\n                    f.or(f.eq(f.exMonth, f.literal(2)),\n                        f.eq(f.exMonth, f.literal(3)),\n                        f.eq(f.exMonth, f.literal(5)))),\n                f.and(f.eq(f.exYear, f.literal(2001)),\n                    f.eq(f.exMonth, f.literal(1))))),\n        is(\"AND(<>(EXTRACT(FLAG(YEAR), $9), 2000),\"\n            + \" OR(AND(AND(>=($9, 2000-01-01), <($9, 2001-01-01)),\"\n            + \" OR(AND(>=($9, 2000-02-01), <($9, 2000-03-01)),\"\n            + \" AND(>=($9, 2000-03-01), <($9, 2000-04-01)),\"\n            + \" AND(>=($9, 2000-05-01), <($9, 2000-06-01)))),\"\n            + \" AND(AND(>=($9, 2001-01-01), <($9, 2002-01-01)),\"\n            + \" AND(>=($9, 2001-01-01), <($9, 2001-02-01)))))\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rules/DateRangeRulesTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":240,"status":"B"}],"commitId":"1e9fd38ba7b702675a066f6bd712d03b7b07410e","commitMessage":"@@@[CALCITE-1658] DateRangeRules incorrectly rewrites EXTRACT calls (Nishant Bangarwa)\n\nFix several issues where DateRangeRules incorrectly rewrites EXTRACT\ncalls.  causing wrong results.\n\nClose apache/calcite#596\n\nClose apache/calcite#587 (unrelated.  but forgot to close it in [CALCITE-2102])\n","date":"2018-01-03 06:24:51","modifiedFileCount":"3","status":"B","submitter":"Nishant"},{"authorTime":"2018-01-08 02:52:51","codes":[{"authorDate":"2018-01-08 02:52:51","commitOrder":2,"curCode":"  @Test public void testExtractWithOrCondition1() {\n    \r\n    \r\n    \r\n    \r\n    final Fixture2 f = new Fixture2();\n    checkDateRange(f,\n        f.or(\n            f.and(f.eq(f.exYearD, f.literal(2000)),\n                f.or(f.eq(f.exMonthD, f.literal(2)),\n                    f.eq(f.exMonthD, f.literal(3)),\n                    f.eq(f.exMonthD, f.literal(5)))),\n            f.and(f.eq(f.exYearD, f.literal(2001)),\n                f.eq(f.exMonthD, f.literal(1)))),\n        is(\"OR(AND(AND(>=($8, 2000-01-01), <($8, 2001-01-01)),\"\n            + \" OR(AND(>=($8, 2000-02-01), <($8, 2000-03-01)),\"\n            + \" AND(>=($8, 2000-03-01), <($8, 2000-04-01)),\"\n            + \" AND(>=($8, 2000-05-01), <($8, 2000-06-01)))),\"\n            + \" AND(AND(>=($8, 2001-01-01), <($8, 2002-01-01)),\"\n            + \" AND(>=($8, 2001-01-01), <($8, 2001-02-01))))\"));\n  }\n","date":"2018-01-09 05:34:48","endLine":205,"groupId":"13153","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testExtractWithOrCondition1","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/f2/47fbbf1251458ab4437e76a9619ba7d7828ce2.src","preCode":"  @Test public void testExtractWithOrCondition1() {\n    \r\n    \r\n    \r\n    \r\n    final Fixture2 f = new Fixture2();\n    checkDateRange(f,\n        f.or(\n            f.and(f.eq(f.exYear, f.literal(2000)),\n                f.or(f.eq(f.exMonth, f.literal(2)),\n                    f.eq(f.exMonth, f.literal(3)),\n                    f.eq(f.exMonth, f.literal(5)))),\n            f.and(f.eq(f.exYear, f.literal(2001)),\n                f.eq(f.exMonth, f.literal(1)))),\n        is(\"OR(AND(AND(>=($9, 2000-01-01), <($9, 2001-01-01)),\"\n            + \" OR(AND(>=($9, 2000-02-01), <($9, 2000-03-01)),\"\n            + \" AND(>=($9, 2000-03-01), <($9, 2000-04-01)),\"\n            + \" AND(>=($9, 2000-05-01), <($9, 2000-06-01)))),\"\n            + \" AND(AND(>=($9, 2001-01-01), <($9, 2002-01-01)),\"\n            + \" AND(>=($9, 2001-01-01), <($9, 2001-02-01))))\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rules/DateRangeRulesTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":185,"status":"M"},{"authorDate":"2018-01-08 02:52:51","commitOrder":2,"curCode":"  @Test public void testExtractPartialRewriteForNotEqualsYear() {\n    \r\n    \r\n    \r\n    \r\n    \r\n    final Fixture2 f = new Fixture2();\n    checkDateRange(f,\n        f.and(\n            f.ne(f.exYearD, f.literal(2000)),\n            f.or(\n                f.and(f.eq(f.exYearD, f.literal(2000)),\n                    f.or(f.eq(f.exMonthD, f.literal(2)),\n                        f.eq(f.exMonthD, f.literal(3)),\n                        f.eq(f.exMonthD, f.literal(5)))),\n                f.and(f.eq(f.exYearD, f.literal(2001)),\n                    f.eq(f.exMonthD, f.literal(1))))),\n        is(\"AND(<>(EXTRACT(FLAG(YEAR), $8), 2000),\"\n            + \" OR(AND(AND(>=($8, 2000-01-01), <($8, 2001-01-01)),\"\n            + \" OR(AND(>=($8, 2000-02-01), <($8, 2000-03-01)),\"\n            + \" AND(>=($8, 2000-03-01), <($8, 2000-04-01)),\"\n            + \" AND(>=($8, 2000-05-01), <($8, 2000-06-01)))),\"\n            + \" AND(AND(>=($8, 2001-01-01), <($8, 2002-01-01)),\"\n            + \" AND(>=($8, 2001-01-01), <($8, 2001-02-01)))))\"));\n  }\n","date":"2018-01-09 05:34:48","endLine":265,"groupId":"13153","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testExtractPartialRewriteForNotEqualsYear","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/f2/47fbbf1251458ab4437e76a9619ba7d7828ce2.src","preCode":"  @Test public void testExtractPartialRewriteForNotEqualsYear() {\n    \r\n    \r\n    \r\n    \r\n    \r\n    final Fixture2 f = new Fixture2();\n    checkDateRange(f,\n        f.and(\n            f.ne(f.exYear, f.literal(2000)),\n            f.or(\n                f.and(f.eq(f.exYear, f.literal(2000)),\n                    f.or(f.eq(f.exMonth, f.literal(2)),\n                        f.eq(f.exMonth, f.literal(3)),\n                        f.eq(f.exMonth, f.literal(5)))),\n                f.and(f.eq(f.exYear, f.literal(2001)),\n                    f.eq(f.exMonth, f.literal(1))))),\n        is(\"AND(<>(EXTRACT(FLAG(YEAR), $9), 2000),\"\n            + \" OR(AND(AND(>=($9, 2000-01-01), <($9, 2001-01-01)),\"\n            + \" OR(AND(>=($9, 2000-02-01), <($9, 2000-03-01)),\"\n            + \" AND(>=($9, 2000-03-01), <($9, 2000-04-01)),\"\n            + \" AND(>=($9, 2000-05-01), <($9, 2000-06-01)))),\"\n            + \" AND(AND(>=($9, 2001-01-01), <($9, 2002-01-01)),\"\n            + \" AND(>=($9, 2001-01-01), <($9, 2001-02-01)))))\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rules/DateRangeRulesTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":241,"status":"M"}],"commitId":"2918b8fe55c58e0bafd38accfface242f1847c54","commitMessage":"@@@[CALCITE-2122] In DateRangeRules.  make either TIMESTAMP or DATE literal.  according to target type (Nishant Bangarwa)\n\nClose apache/calcite#599\n","date":"2018-01-09 05:34:48","modifiedFileCount":"6","status":"M","submitter":"Nishant"},{"authorTime":"2020-04-02 10:39:10","codes":[{"authorDate":"2020-04-02 10:39:10","commitOrder":3,"curCode":"  @Test void testExtractWithOrCondition1() {\n    \r\n    \r\n    \r\n    \r\n    final Fixture2 f = new Fixture2();\n    checkDateRange(f,\n        f.or(\n            f.and(f.eq(f.exYearD, f.literal(2000)),\n                f.or(f.eq(f.exMonthD, f.literal(2)),\n                    f.eq(f.exMonthD, f.literal(3)),\n                    f.eq(f.exMonthD, f.literal(5)))),\n            f.and(f.eq(f.exYearD, f.literal(2001)),\n                f.eq(f.exMonthD, f.literal(1)))),\n        is(\"OR(AND(AND(>=($8, 2000-01-01), <($8, 2001-01-01)),\"\n            + \" OR(AND(>=($8, 2000-02-01), <($8, 2000-03-01)),\"\n            + \" AND(>=($8, 2000-03-01), <($8, 2000-04-01)),\"\n            + \" AND(>=($8, 2000-05-01), <($8, 2000-06-01)))),\"\n            + \" AND(AND(>=($8, 2001-01-01), <($8, 2002-01-01)),\"\n            + \" AND(>=($8, 2001-01-01), <($8, 2001-02-01))))\"));\n  }\n","date":"2020-04-06 04:57:49","endLine":205,"groupId":"101492","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testExtractWithOrCondition1","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e7/29288bd53b9dc06551209ba551f2b4be514394.src","preCode":"  @Test public void testExtractWithOrCondition1() {\n    \r\n    \r\n    \r\n    \r\n    final Fixture2 f = new Fixture2();\n    checkDateRange(f,\n        f.or(\n            f.and(f.eq(f.exYearD, f.literal(2000)),\n                f.or(f.eq(f.exMonthD, f.literal(2)),\n                    f.eq(f.exMonthD, f.literal(3)),\n                    f.eq(f.exMonthD, f.literal(5)))),\n            f.and(f.eq(f.exYearD, f.literal(2001)),\n                f.eq(f.exMonthD, f.literal(1)))),\n        is(\"OR(AND(AND(>=($8, 2000-01-01), <($8, 2001-01-01)),\"\n            + \" OR(AND(>=($8, 2000-02-01), <($8, 2000-03-01)),\"\n            + \" AND(>=($8, 2000-03-01), <($8, 2000-04-01)),\"\n            + \" AND(>=($8, 2000-05-01), <($8, 2000-06-01)))),\"\n            + \" AND(AND(>=($8, 2001-01-01), <($8, 2002-01-01)),\"\n            + \" AND(>=($8, 2001-01-01), <($8, 2001-02-01))))\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rules/DateRangeRulesTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":185,"status":"M"},{"authorDate":"2020-04-02 10:39:10","commitOrder":3,"curCode":"  @Test void testExtractPartialRewriteForNotEqualsYear() {\n    \r\n    \r\n    \r\n    \r\n    \r\n    final Fixture2 f = new Fixture2();\n    checkDateRange(f,\n        f.and(\n            f.ne(f.exYearD, f.literal(2000)),\n            f.or(\n                f.and(f.eq(f.exYearD, f.literal(2000)),\n                    f.or(f.eq(f.exMonthD, f.literal(2)),\n                        f.eq(f.exMonthD, f.literal(3)),\n                        f.eq(f.exMonthD, f.literal(5)))),\n                f.and(f.eq(f.exYearD, f.literal(2001)),\n                    f.eq(f.exMonthD, f.literal(1))))),\n        is(\"AND(<>(EXTRACT(FLAG(YEAR), $8), 2000),\"\n            + \" OR(AND(AND(>=($8, 2000-01-01), <($8, 2001-01-01)),\"\n            + \" OR(AND(>=($8, 2000-02-01), <($8, 2000-03-01)),\"\n            + \" AND(>=($8, 2000-03-01), <($8, 2000-04-01)),\"\n            + \" AND(>=($8, 2000-05-01), <($8, 2000-06-01)))),\"\n            + \" AND(AND(>=($8, 2001-01-01), <($8, 2002-01-01)),\"\n            + \" AND(>=($8, 2001-01-01), <($8, 2001-02-01)))))\"));\n  }\n","date":"2020-04-06 04:57:49","endLine":265,"groupId":"101492","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testExtractPartialRewriteForNotEqualsYear","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e7/29288bd53b9dc06551209ba551f2b4be514394.src","preCode":"  @Test public void testExtractPartialRewriteForNotEqualsYear() {\n    \r\n    \r\n    \r\n    \r\n    \r\n    final Fixture2 f = new Fixture2();\n    checkDateRange(f,\n        f.and(\n            f.ne(f.exYearD, f.literal(2000)),\n            f.or(\n                f.and(f.eq(f.exYearD, f.literal(2000)),\n                    f.or(f.eq(f.exMonthD, f.literal(2)),\n                        f.eq(f.exMonthD, f.literal(3)),\n                        f.eq(f.exMonthD, f.literal(5)))),\n                f.and(f.eq(f.exYearD, f.literal(2001)),\n                    f.eq(f.exMonthD, f.literal(1))))),\n        is(\"AND(<>(EXTRACT(FLAG(YEAR), $8), 2000),\"\n            + \" OR(AND(AND(>=($8, 2000-01-01), <($8, 2001-01-01)),\"\n            + \" OR(AND(>=($8, 2000-02-01), <($8, 2000-03-01)),\"\n            + \" AND(>=($8, 2000-03-01), <($8, 2000-04-01)),\"\n            + \" AND(>=($8, 2000-05-01), <($8, 2000-06-01)))),\"\n            + \" AND(AND(>=($8, 2001-01-01), <($8, 2002-01-01)),\"\n            + \" AND(>=($8, 2001-01-01), <($8, 2001-02-01)))))\"));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rules/DateRangeRulesTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":241,"status":"M"}],"commitId":"9492dd4146f63ddc028010d6c4e86f6a5cb29a8d","commitMessage":"@@@[CALCITE-3892] Make junit test classes and methods non-public where possible\n\nPrior to junit 5.  classes and methods had to be public. This is no\nlonger the case.\n\nSome classes need to remain public because they are referenced from\nelsewhere.  or if they use reflection somehow. The remaining 'public'\nkeyword will be informative to maintainers.\n","date":"2020-04-06 04:57:49","modifiedFileCount":"196","status":"M","submitter":"Julian Hyde"}]
