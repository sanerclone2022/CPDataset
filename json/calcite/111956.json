[{"authorTime":"2020-09-22 18:02:11","codes":[{"authorDate":"2020-06-09 21:16:22","commitOrder":4,"curCode":"  public Set<RexNode> getExpressionLineage(Project rel,\n      final RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = rel.getInput();\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n\n    \r\n    final ImmutableBitSet inputFieldsUsed = extractInputRefs(outputExpression);\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexNode inputExpr = rel.getProjects().get(idx);\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputExpr);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","date":"2020-06-16 11:11:13","endLine":376,"groupId":"7627","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"getExpressionLineage","params":"(Projectrel@finalRelMetadataQuerymq@RexNodeoutputExpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/6a/ba8b3879d97c0ce10a4681da4ac44fdd0e9d8f.src","preCode":"  public Set<RexNode> getExpressionLineage(Project rel,\n      final RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = rel.getInput();\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n\n    \r\n    final ImmutableBitSet inputFieldsUsed = extractInputRefs(outputExpression);\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexNode inputExpr = rel.getProjects().get(idx);\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputExpr);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/metadata/RelMdExpressionLineage.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":353,"status":"NB"},{"authorDate":"2020-09-22 18:02:11","commitOrder":4,"curCode":"  public Set<RexNode> getExpressionLineage(Calc calc,\n      RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = calc.getInput();\n    final RexBuilder rexBuilder = calc.getCluster().getRexBuilder();\n    \r\n    final ImmutableBitSet inputFieldsUsed = extractInputRefs(outputExpression);\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    Pair<ImmutableList<RexNode>, ImmutableList<RexNode>> calcProjectsAndFilter =\n        calc.getProgram().split();\n    for (int idx : inputFieldsUsed) {\n      final RexNode inputExpr = calcProjectsAndFilter.getKey().get(idx);\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputExpr);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, calc.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","date":"2020-11-04 08:19:22","endLine":438,"groupId":"5085","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getExpressionLineage","params":"(Calccalc@RelMetadataQuerymq@RexNodeoutputExpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/f1/c97cb7a7706f1a38d3109322ca3843ce618f98.src","preCode":"  public Set<RexNode> getExpressionLineage(Calc calc,\n      RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = calc.getInput();\n    final RexBuilder rexBuilder = calc.getCluster().getRexBuilder();\n    \r\n    final ImmutableBitSet inputFieldsUsed = extractInputRefs(outputExpression);\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    Pair<ImmutableList<RexNode>, ImmutableList<RexNode>> calcProjectsAndFilter =\n        calc.getProgram().split();\n    for (int idx : inputFieldsUsed) {\n      final RexNode inputExpr = calcProjectsAndFilter.getKey().get(idx);\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputExpr);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, calc.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/metadata/RelMdExpressionLineage.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":414,"status":"B"}],"commitId":"2e9edae7fc57ab9c9c7c097008724ac99a1791a3","commitMessage":"@@@[CALCITE-4273] Support get expression lineage for Calc\n","date":"2020-11-04 08:19:22","modifiedFileCount":"2","status":"M","submitter":"yanlin-Lynn"},{"authorTime":"2020-05-29 00:04:40","codes":[{"authorDate":"2020-05-29 00:04:40","commitOrder":5,"curCode":"  public @Nullable Set<RexNode> getExpressionLineage(Project rel,\n      final RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = rel.getInput();\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n\n    \r\n    final ImmutableBitSet inputFieldsUsed = extractInputRefs(outputExpression);\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexNode inputExpr = rel.getProjects().get(idx);\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputExpr);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","date":"2020-11-30 06:45:33","endLine":385,"groupId":"111956","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"getExpressionLineage","params":"(Projectrel@finalRelMetadataQuerymq@RexNodeoutputExpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/43/be0ac23a8334ce5ec957a1175aa4f314a52b8b.src","preCode":"  public Set<RexNode> getExpressionLineage(Project rel,\n      final RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = rel.getInput();\n    final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();\n\n    \r\n    final ImmutableBitSet inputFieldsUsed = extractInputRefs(outputExpression);\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    for (int idx : inputFieldsUsed) {\n      final RexNode inputExpr = rel.getProjects().get(idx);\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputExpr);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, rel.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/metadata/RelMdExpressionLineage.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":362,"status":"M"},{"authorDate":"2020-05-29 00:04:40","commitOrder":5,"curCode":"  public @Nullable Set<RexNode> getExpressionLineage(Calc calc,\n      RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = calc.getInput();\n    final RexBuilder rexBuilder = calc.getCluster().getRexBuilder();\n    \r\n    final ImmutableBitSet inputFieldsUsed = extractInputRefs(outputExpression);\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    Pair<ImmutableList<RexNode>, ImmutableList<RexNode>> calcProjectsAndFilter =\n        calc.getProgram().split();\n    for (int idx : inputFieldsUsed) {\n      final RexNode inputExpr = calcProjectsAndFilter.getKey().get(idx);\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputExpr);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, calc.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","date":"2020-11-30 06:45:33","endLine":446,"groupId":"111956","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"getExpressionLineage","params":"(Calccalc@RelMetadataQuerymq@RexNodeoutputExpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/43/be0ac23a8334ce5ec957a1175aa4f314a52b8b.src","preCode":"  public Set<RexNode> getExpressionLineage(Calc calc,\n      RelMetadataQuery mq, RexNode outputExpression) {\n    final RelNode input = calc.getInput();\n    final RexBuilder rexBuilder = calc.getCluster().getRexBuilder();\n    \r\n    final ImmutableBitSet inputFieldsUsed = extractInputRefs(outputExpression);\n\n    \r\n    final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();\n    Pair<ImmutableList<RexNode>, ImmutableList<RexNode>> calcProjectsAndFilter =\n        calc.getProgram().split();\n    for (int idx : inputFieldsUsed) {\n      final RexNode inputExpr = calcProjectsAndFilter.getKey().get(idx);\n      final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputExpr);\n      if (originalExprs == null) {\n        \r\n        return null;\n      }\n      final RexInputRef ref = RexInputRef.of(idx, calc.getRowType().getFieldList());\n      mapping.put(ref, originalExprs);\n    }\n\n    \r\n    return createAllPossibleExpressions(rexBuilder, outputExpression, mapping);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/rel/metadata/RelMdExpressionLineage.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":422,"status":"M"}],"commitId":"d9a81b88ad561e7e4cedae93e805e0d7a53a7f1a","commitMessage":"@@@[CALCITE-4199] Add nullability annotations\n\nThe commit includes javadoc updates and refactorings made by Julian Hyde in https://github.com/apache/calcite/pull/2278\n","date":"2020-11-30 06:45:33","modifiedFileCount":"1012","status":"M","submitter":"Vladimir Sitnikov"}]
