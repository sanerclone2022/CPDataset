[{"authorTime":"2014-11-14 09:39:29","codes":[{"authorDate":"2014-11-14 09:39:29","commitOrder":1,"curCode":"  public Pair<Expression, Expression> generateCollationKey(\n      final List<RelFieldCollation> collations) {\n    final Expression selector;\n    if (collations.size() == 1) {\n      RelFieldCollation collation = collations.get(0);\n      ParameterExpression parameter =\n          Expressions.parameter(javaRowClass, \"v\");\n      selector =\n          Expressions.lambda(\n              Function1.class,\n              fieldReference(parameter, collation.getFieldIndex()),\n              parameter);\n      return Pair.<Expression, Expression>of(\n          selector,\n          Expressions.call(\n              BuiltinMethod.NULLS_COMPARATOR.method,\n              Expressions.constant(\n                  collation.nullDirection\n                      == RelFieldCollation.NullDirection.FIRST),\n              Expressions.constant(\n                  collation.getDirection()\n                      == RelFieldCollation.Direction.DESCENDING)));\n    }\n    selector =\n        Expressions.call(BuiltinMethod.IDENTITY_SELECTOR.method);\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod = collations.size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation collation : collations) {\n      final int index = collation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = Types.castIfNecessary(Comparable.class, arg0);\n        arg1 = Types.castIfNecessary(Comparable.class, arg1);\n      }\n      final boolean nullsFirst =\n          collation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          collation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.<MemberDeclaration>list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(\n                    parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (JavaRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltinMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          JavaRules.EnumUtil.overridingMethodDecl(\n              BuiltinMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Pair.<Expression, Expression>of(\n        selector,\n        Expressions.new_(\n            Comparator.class,\n            Collections.<Expression>emptyList(),\n            memberDeclarations));\n  }\n","date":"2014-11-14 09:39:34","endLine":315,"groupId":"1134","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"generateCollationKey","params":"(finalList<RelFieldCollation>collations)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e3/0ce216684f64178a5ba723204b1e53cbee268c.src","preCode":"  public Pair<Expression, Expression> generateCollationKey(\n      final List<RelFieldCollation> collations) {\n    final Expression selector;\n    if (collations.size() == 1) {\n      RelFieldCollation collation = collations.get(0);\n      ParameterExpression parameter =\n          Expressions.parameter(javaRowClass, \"v\");\n      selector =\n          Expressions.lambda(\n              Function1.class,\n              fieldReference(parameter, collation.getFieldIndex()),\n              parameter);\n      return Pair.<Expression, Expression>of(\n          selector,\n          Expressions.call(\n              BuiltinMethod.NULLS_COMPARATOR.method,\n              Expressions.constant(\n                  collation.nullDirection\n                      == RelFieldCollation.NullDirection.FIRST),\n              Expressions.constant(\n                  collation.getDirection()\n                      == RelFieldCollation.Direction.DESCENDING)));\n    }\n    selector =\n        Expressions.call(BuiltinMethod.IDENTITY_SELECTOR.method);\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod = collations.size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation collation : collations) {\n      final int index = collation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = Types.castIfNecessary(Comparable.class, arg0);\n        arg1 = Types.castIfNecessary(Comparable.class, arg1);\n      }\n      final boolean nullsFirst =\n          collation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          collation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.<MemberDeclaration>list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(\n                    parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (JavaRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltinMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          JavaRules.EnumUtil.overridingMethodDecl(\n              BuiltinMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Pair.<Expression, Expression>of(\n        selector,\n        Expressions.new_(\n            Comparator.class,\n            Collections.<Expression>emptyList(),\n            memberDeclarations));\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":193,"status":"B"},{"authorDate":"2014-11-14 09:39:29","commitOrder":1,"curCode":"  public Expression generateComparator(RelCollation collation) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final Type javaRowClass = Primitive.box(this.javaRowClass);\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod =\n        collation.getFieldCollations().size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation fieldCollation : collation.getFieldCollations()) {\n      final int index = fieldCollation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = Types.castIfNecessary(Comparable.class, arg0);\n        arg1 = Types.castIfNecessary(Comparable.class, arg1);\n      }\n      final boolean nullsFirst =\n          fieldCollation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          fieldCollation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst != descending\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.<MemberDeclaration>list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (JavaRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltinMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          JavaRules.EnumUtil.overridingMethodDecl(\n              BuiltinMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Expressions.new_(\n        Comparator.class,\n        Collections.<Expression>emptyList(),\n        memberDeclarations);\n  }\n","date":"2014-11-14 09:39:34","endLine":413,"groupId":"3802","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"generateComparator","params":"(RelCollationcollation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e3/0ce216684f64178a5ba723204b1e53cbee268c.src","preCode":"  public Expression generateComparator(RelCollation collation) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final Type javaRowClass = Primitive.box(this.javaRowClass);\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod =\n        collation.getFieldCollations().size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation fieldCollation : collation.getFieldCollations()) {\n      final int index = fieldCollation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = Types.castIfNecessary(Comparable.class, arg0);\n        arg1 = Types.castIfNecessary(Comparable.class, arg1);\n      }\n      final boolean nullsFirst =\n          fieldCollation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          fieldCollation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst != descending\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.<MemberDeclaration>list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (JavaRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltinMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          JavaRules.EnumUtil.overridingMethodDecl(\n              BuiltinMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Expressions.new_(\n        Comparator.class,\n        Collections.<Expression>emptyList(),\n        memberDeclarations);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":317,"status":"B"}],"commitId":"a611d645ad754844a39f3d98f5f814f13dbd9404","commitMessage":"@@@[CALCITE-296] Re-organize package structure;\n[CALCITE-419] Naming convention for planner rules\n\nThis change only renames files (and deletes some obsolete files). There are no content changes.\n","date":"2014-11-14 09:39:34","modifiedFileCount":"0","status":"B","submitter":"Julian Hyde"},{"authorTime":"2014-11-14 10:11:34","codes":[{"authorDate":"2014-11-14 10:11:34","commitOrder":2,"curCode":"  public Pair<Expression, Expression> generateCollationKey(\n      final List<RelFieldCollation> collations) {\n    final Expression selector;\n    if (collations.size() == 1) {\n      RelFieldCollation collation = collations.get(0);\n      ParameterExpression parameter =\n          Expressions.parameter(javaRowClass, \"v\");\n      selector =\n          Expressions.lambda(\n              Function1.class,\n              fieldReference(parameter, collation.getFieldIndex()),\n              parameter);\n      return Pair.<Expression, Expression>of(\n          selector,\n          Expressions.call(\n              BuiltInMethod.NULLS_COMPARATOR.method,\n              Expressions.constant(\n                  collation.nullDirection\n                      == RelFieldCollation.NullDirection.FIRST),\n              Expressions.constant(\n                  collation.getDirection()\n                      == RelFieldCollation.Direction.DESCENDING)));\n    }\n    selector =\n        Expressions.call(BuiltInMethod.IDENTITY_SELECTOR.method);\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod = collations.size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation collation : collations) {\n      final int index = collation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = Types.castIfNecessary(Comparable.class, arg0);\n        arg1 = Types.castIfNecessary(Comparable.class, arg1);\n      }\n      final boolean nullsFirst =\n          collation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          collation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.<MemberDeclaration>list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(\n                    parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Pair.<Expression, Expression>of(\n        selector,\n        Expressions.new_(\n            Comparator.class,\n            Collections.<Expression>emptyList(),\n            memberDeclarations));\n  }\n","date":"2014-11-14 10:22:06","endLine":325,"groupId":"1134","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"generateCollationKey","params":"(finalList<RelFieldCollation>collations)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/56/2e4bad2be22b2ef22ff6aa5b449a8bf88c3bf1.src","preCode":"  public Pair<Expression, Expression> generateCollationKey(\n      final List<RelFieldCollation> collations) {\n    final Expression selector;\n    if (collations.size() == 1) {\n      RelFieldCollation collation = collations.get(0);\n      ParameterExpression parameter =\n          Expressions.parameter(javaRowClass, \"v\");\n      selector =\n          Expressions.lambda(\n              Function1.class,\n              fieldReference(parameter, collation.getFieldIndex()),\n              parameter);\n      return Pair.<Expression, Expression>of(\n          selector,\n          Expressions.call(\n              BuiltinMethod.NULLS_COMPARATOR.method,\n              Expressions.constant(\n                  collation.nullDirection\n                      == RelFieldCollation.NullDirection.FIRST),\n              Expressions.constant(\n                  collation.getDirection()\n                      == RelFieldCollation.Direction.DESCENDING)));\n    }\n    selector =\n        Expressions.call(BuiltinMethod.IDENTITY_SELECTOR.method);\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod = collations.size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation collation : collations) {\n      final int index = collation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = Types.castIfNecessary(Comparable.class, arg0);\n        arg1 = Types.castIfNecessary(Comparable.class, arg1);\n      }\n      final boolean nullsFirst =\n          collation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          collation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.<MemberDeclaration>list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(\n                    parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (JavaRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltinMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          JavaRules.EnumUtil.overridingMethodDecl(\n              BuiltinMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Pair.<Expression, Expression>of(\n        selector,\n        Expressions.new_(\n            Comparator.class,\n            Collections.<Expression>emptyList(),\n            memberDeclarations));\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":203,"status":"M"},{"authorDate":"2014-11-14 10:11:34","commitOrder":2,"curCode":"  public Expression generateComparator(RelCollation collation) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final Type javaRowClass = Primitive.box(this.javaRowClass);\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod =\n        collation.getFieldCollations().size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation fieldCollation : collation.getFieldCollations()) {\n      final int index = fieldCollation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = Types.castIfNecessary(Comparable.class, arg0);\n        arg1 = Types.castIfNecessary(Comparable.class, arg1);\n      }\n      final boolean nullsFirst =\n          fieldCollation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          fieldCollation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst != descending\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.<MemberDeclaration>list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Expressions.new_(\n        Comparator.class,\n        Collections.<Expression>emptyList(),\n        memberDeclarations);\n  }\n","date":"2014-11-14 10:22:06","endLine":423,"groupId":"3802","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"generateComparator","params":"(RelCollationcollation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/56/2e4bad2be22b2ef22ff6aa5b449a8bf88c3bf1.src","preCode":"  public Expression generateComparator(RelCollation collation) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final Type javaRowClass = Primitive.box(this.javaRowClass);\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod =\n        collation.getFieldCollations().size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation fieldCollation : collation.getFieldCollations()) {\n      final int index = fieldCollation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = Types.castIfNecessary(Comparable.class, arg0);\n        arg1 = Types.castIfNecessary(Comparable.class, arg1);\n      }\n      final boolean nullsFirst =\n          fieldCollation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          fieldCollation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst != descending\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.<MemberDeclaration>list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (JavaRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltinMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          JavaRules.EnumUtil.overridingMethodDecl(\n              BuiltinMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Expressions.new_(\n        Comparator.class,\n        Collections.<Expression>emptyList(),\n        memberDeclarations);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":327,"status":"M"}],"commitId":"a0ba73cd2de76696b96a1cd828d2aa4d3ef9eb55","commitMessage":"@@@[CALCITE-306] Standardize code style for \"import package.*;\"\n\nRename classes and packages and generally fix things up after [CALCITE-296] and [CALCITE-419].\n\nMake many inner classes of EnumerableRules (e.g. EnumerableFilter.  EnumerableFilterRule) top-level classes.\n\nApply a consistent formatting convention for string literals split over multiple lines.\n\nRename generated file org.eigenbase.resource.Resources to org.apache.calcite.runtime.Resources.\n\nChange occurrences of \"optiq\" and \"eigenbase\" in java code to \"calcite\".\n","date":"2014-11-14 10:22:06","modifiedFileCount":"1156","status":"M","submitter":"Julian Hyde"},{"authorTime":"2014-11-14 10:11:34","codes":[{"authorDate":"2015-11-17 03:05:49","commitOrder":3,"curCode":"  public Pair<Expression, Expression> generateCollationKey(\n      final List<RelFieldCollation> collations) {\n    final Expression selector;\n    if (collations.size() == 1) {\n      RelFieldCollation collation = collations.get(0);\n      ParameterExpression parameter =\n          Expressions.parameter(javaRowClass, \"v\");\n      selector =\n          Expressions.lambda(\n              Function1.class,\n              fieldReference(parameter, collation.getFieldIndex()),\n              parameter);\n      return Pair.<Expression, Expression>of(\n          selector,\n          Expressions.call(\n              BuiltInMethod.NULLS_COMPARATOR.method,\n              Expressions.constant(\n                  collation.nullDirection\n                      == RelFieldCollation.NullDirection.FIRST),\n              Expressions.constant(\n                  collation.getDirection()\n                      == RelFieldCollation.Direction.DESCENDING)));\n    }\n    selector =\n        Expressions.call(BuiltInMethod.IDENTITY_SELECTOR.method);\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod = collations.size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation collation : collations) {\n      final int index = collation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = Types.castIfNecessary(Comparable.class, arg0);\n        arg1 = Types.castIfNecessary(Comparable.class, arg1);\n      }\n      final boolean nullsFirst =\n          collation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          collation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst ^ descending\n                              ? \"compareNullsFirst\"\n                              : \"compareNullsLast\")\n                          : \"compare\",\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.<MemberDeclaration>list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(\n                    parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Pair.<Expression, Expression>of(\n        selector,\n        Expressions.new_(\n            Comparator.class,\n            Collections.<Expression>emptyList(),\n            memberDeclarations));\n  }\n","date":"2015-11-17 03:12:19","endLine":371,"groupId":"0","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"generateCollationKey","params":"(finalList<RelFieldCollation>collations)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/af/42c16ab15c16cc3d101611691aeeb3ef3776b2.src","preCode":"  public Pair<Expression, Expression> generateCollationKey(\n      final List<RelFieldCollation> collations) {\n    final Expression selector;\n    if (collations.size() == 1) {\n      RelFieldCollation collation = collations.get(0);\n      ParameterExpression parameter =\n          Expressions.parameter(javaRowClass, \"v\");\n      selector =\n          Expressions.lambda(\n              Function1.class,\n              fieldReference(parameter, collation.getFieldIndex()),\n              parameter);\n      return Pair.<Expression, Expression>of(\n          selector,\n          Expressions.call(\n              BuiltInMethod.NULLS_COMPARATOR.method,\n              Expressions.constant(\n                  collation.nullDirection\n                      == RelFieldCollation.NullDirection.FIRST),\n              Expressions.constant(\n                  collation.getDirection()\n                      == RelFieldCollation.Direction.DESCENDING)));\n    }\n    selector =\n        Expressions.call(BuiltInMethod.IDENTITY_SELECTOR.method);\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod = collations.size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation collation : collations) {\n      final int index = collation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = Types.castIfNecessary(Comparable.class, arg0);\n        arg1 = Types.castIfNecessary(Comparable.class, arg1);\n      }\n      final boolean nullsFirst =\n          collation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          collation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.<MemberDeclaration>list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(\n                    parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Pair.<Expression, Expression>of(\n        selector,\n        Expressions.new_(\n            Comparator.class,\n            Collections.<Expression>emptyList(),\n            memberDeclarations));\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":249,"status":"M"},{"authorDate":"2014-11-14 10:11:34","commitOrder":3,"curCode":"  public Expression generateComparator(RelCollation collation) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final Type javaRowClass = Primitive.box(this.javaRowClass);\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod =\n        collation.getFieldCollations().size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation fieldCollation : collation.getFieldCollations()) {\n      final int index = fieldCollation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = Types.castIfNecessary(Comparable.class, arg0);\n        arg1 = Types.castIfNecessary(Comparable.class, arg1);\n      }\n      final boolean nullsFirst =\n          fieldCollation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          fieldCollation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst != descending\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.<MemberDeclaration>list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Expressions.new_(\n        Comparator.class,\n        Collections.<Expression>emptyList(),\n        memberDeclarations);\n  }\n","date":"2014-11-14 10:22:06","endLine":423,"groupId":"3802","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"generateComparator","params":"(RelCollationcollation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/56/2e4bad2be22b2ef22ff6aa5b449a8bf88c3bf1.src","preCode":"  public Expression generateComparator(RelCollation collation) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final Type javaRowClass = Primitive.box(this.javaRowClass);\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod =\n        collation.getFieldCollations().size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation fieldCollation : collation.getFieldCollations()) {\n      final int index = fieldCollation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = Types.castIfNecessary(Comparable.class, arg0);\n        arg1 = Types.castIfNecessary(Comparable.class, arg1);\n      }\n      final boolean nullsFirst =\n          fieldCollation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          fieldCollation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst != descending\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.<MemberDeclaration>list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Expressions.new_(\n        Comparator.class,\n        Collections.<Expression>emptyList(),\n        memberDeclarations);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":327,"status":"N"}],"commitId":"80bbb5bf2a53612be6bf2e6f086141e84c5e9a61","commitMessage":"@@@[CALCITE-969] Composite EnumerableSort with DESC wrongly sorts NULL values low\n","date":"2015-11-17 03:12:19","modifiedFileCount":"1","status":"M","submitter":"Julian Hyde"},{"authorTime":"2014-11-14 10:11:34","codes":[{"authorDate":"2016-01-06 07:15:51","commitOrder":4,"curCode":"  public Pair<Expression, Expression> generateCollationKey(\n      final List<RelFieldCollation> collations) {\n    final Expression selector;\n    if (collations.size() == 1) {\n      RelFieldCollation collation = collations.get(0);\n      ParameterExpression parameter =\n          Expressions.parameter(javaRowClass, \"v\");\n      selector =\n          Expressions.lambda(\n              Function1.class,\n              fieldReference(parameter, collation.getFieldIndex()),\n              parameter);\n      return Pair.<Expression, Expression>of(\n          selector,\n          Expressions.call(\n              BuiltInMethod.NULLS_COMPARATOR.method,\n              Expressions.constant(\n                  collation.nullDirection\n                      == RelFieldCollation.NullDirection.FIRST),\n              Expressions.constant(\n                  collation.getDirection()\n                      == RelFieldCollation.Direction.DESCENDING)));\n    }\n    selector =\n        Expressions.call(BuiltInMethod.IDENTITY_SELECTOR.method);\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod = collations.size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation collation : collations) {\n      final int index = collation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = Types.castIfNecessary(Comparable.class, arg0);\n        arg1 = Types.castIfNecessary(Comparable.class, arg1);\n      }\n      final boolean nullsFirst =\n          collation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          collation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      final Method method = (fieldNullable(index)\n          ? (nullsFirst ^ descending\n              ? BuiltInMethod.COMPARE_NULLS_FIRST\n              : BuiltInMethod.COMPARE_NULLS_LAST)\n          : BuiltInMethod.COMPARE).method;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(method.getDeclaringClass(),\n                      method.getName(),\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.<MemberDeclaration>list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(\n                    parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Pair.<Expression, Expression>of(\n        selector,\n        Expressions.new_(\n            Comparator.class,\n            Collections.<Expression>emptyList(),\n            memberDeclarations));\n  }\n","date":"2016-01-06 18:37:31","endLine":372,"groupId":"723","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"generateCollationKey","params":"(finalList<RelFieldCollation>collations)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/91/8833e8d3a89ac245f3906e51b3756c9c4536bf.src","preCode":"  public Pair<Expression, Expression> generateCollationKey(\n      final List<RelFieldCollation> collations) {\n    final Expression selector;\n    if (collations.size() == 1) {\n      RelFieldCollation collation = collations.get(0);\n      ParameterExpression parameter =\n          Expressions.parameter(javaRowClass, \"v\");\n      selector =\n          Expressions.lambda(\n              Function1.class,\n              fieldReference(parameter, collation.getFieldIndex()),\n              parameter);\n      return Pair.<Expression, Expression>of(\n          selector,\n          Expressions.call(\n              BuiltInMethod.NULLS_COMPARATOR.method,\n              Expressions.constant(\n                  collation.nullDirection\n                      == RelFieldCollation.NullDirection.FIRST),\n              Expressions.constant(\n                  collation.getDirection()\n                      == RelFieldCollation.Direction.DESCENDING)));\n    }\n    selector =\n        Expressions.call(BuiltInMethod.IDENTITY_SELECTOR.method);\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod = collations.size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation collation : collations) {\n      final int index = collation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = Types.castIfNecessary(Comparable.class, arg0);\n        arg1 = Types.castIfNecessary(Comparable.class, arg1);\n      }\n      final boolean nullsFirst =\n          collation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          collation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst ^ descending\n                              ? \"compareNullsFirst\"\n                              : \"compareNullsLast\")\n                          : \"compare\",\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.<MemberDeclaration>list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(\n                    parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Pair.<Expression, Expression>of(\n        selector,\n        Expressions.new_(\n            Comparator.class,\n            Collections.<Expression>emptyList(),\n            memberDeclarations));\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":250,"status":"M"},{"authorDate":"2014-11-14 10:11:34","commitOrder":4,"curCode":"  public Expression generateComparator(RelCollation collation) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final Type javaRowClass = Primitive.box(this.javaRowClass);\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod =\n        collation.getFieldCollations().size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation fieldCollation : collation.getFieldCollations()) {\n      final int index = fieldCollation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = Types.castIfNecessary(Comparable.class, arg0);\n        arg1 = Types.castIfNecessary(Comparable.class, arg1);\n      }\n      final boolean nullsFirst =\n          fieldCollation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          fieldCollation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst != descending\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.<MemberDeclaration>list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Expressions.new_(\n        Comparator.class,\n        Collections.<Expression>emptyList(),\n        memberDeclarations);\n  }\n","date":"2014-11-14 10:22:06","endLine":423,"groupId":"3802","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"generateComparator","params":"(RelCollationcollation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/56/2e4bad2be22b2ef22ff6aa5b449a8bf88c3bf1.src","preCode":"  public Expression generateComparator(RelCollation collation) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final Type javaRowClass = Primitive.box(this.javaRowClass);\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod =\n        collation.getFieldCollations().size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation fieldCollation : collation.getFieldCollations()) {\n      final int index = fieldCollation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = Types.castIfNecessary(Comparable.class, arg0);\n        arg1 = Types.castIfNecessary(Comparable.class, arg1);\n      }\n      final boolean nullsFirst =\n          fieldCollation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          fieldCollation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst != descending\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.<MemberDeclaration>list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Expressions.new_(\n        Comparator.class,\n        Collections.<Expression>emptyList(),\n        memberDeclarations);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":327,"status":"N"}],"commitId":"d4bbf58d6e5f4f67ebae412b5a1aae23769eccb7","commitMessage":"@@@[CALCITE-1041] User-defined function that returns DATE or TIMESTAMP value\n\nRationalize code that translates to an from internal representation (e.g. DATE stored as int).\n\nFix an bug with overloaded UDFs.  and a bug with UDF args of type SMALLINT (short).\n\nDeprecate Utilities.equal.\n\nAdd methods to in BuiltInMethod.\n","date":"2016-01-06 18:37:31","modifiedFileCount":"18","status":"M","submitter":"Julian Hyde"},{"authorTime":"2018-07-06 04:21:59","codes":[{"authorDate":"2018-07-06 04:21:59","commitOrder":5,"curCode":"  public Pair<Expression, Expression> generateCollationKey(\n      final List<RelFieldCollation> collations) {\n    final Expression selector;\n    if (collations.size() == 1) {\n      RelFieldCollation collation = collations.get(0);\n      ParameterExpression parameter =\n          Expressions.parameter(javaRowClass, \"v\");\n      selector =\n          Expressions.lambda(\n              Function1.class,\n              fieldReference(parameter, collation.getFieldIndex()),\n              parameter);\n      return Pair.of(selector,\n          Expressions.call(\n              BuiltInMethod.NULLS_COMPARATOR.method,\n              Expressions.constant(\n                  collation.nullDirection\n                      == RelFieldCollation.NullDirection.FIRST),\n              Expressions.constant(\n                  collation.getDirection()\n                      == RelFieldCollation.Direction.DESCENDING)));\n    }\n    selector =\n        Expressions.call(BuiltInMethod.IDENTITY_SELECTOR.method);\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod = collations.size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation collation : collations) {\n      final int index = collation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = Types.castIfNecessary(Comparable.class, arg0);\n        arg1 = Types.castIfNecessary(Comparable.class, arg1);\n      }\n      final boolean nullsFirst =\n          collation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          collation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      final Method method = (fieldNullable(index)\n          ? (nullsFirst ^ descending\n              ? BuiltInMethod.COMPARE_NULLS_FIRST\n              : BuiltInMethod.COMPARE_NULLS_LAST)\n          : BuiltInMethod.COMPARE).method;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(method.getDeclaringClass(),\n                      method.getName(),\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(\n                    parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Pair.of(selector,\n        Expressions.new_(Comparator.class,\n            ImmutableList.of(),\n            memberDeclarations));\n  }\n","date":"2018-07-09 01:16:26","endLine":369,"groupId":"8678","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"generateCollationKey","params":"(finalList<RelFieldCollation>collations)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/74/64a273eae792779944fd72135119f782f14948.src","preCode":"  public Pair<Expression, Expression> generateCollationKey(\n      final List<RelFieldCollation> collations) {\n    final Expression selector;\n    if (collations.size() == 1) {\n      RelFieldCollation collation = collations.get(0);\n      ParameterExpression parameter =\n          Expressions.parameter(javaRowClass, \"v\");\n      selector =\n          Expressions.lambda(\n              Function1.class,\n              fieldReference(parameter, collation.getFieldIndex()),\n              parameter);\n      return Pair.<Expression, Expression>of(\n          selector,\n          Expressions.call(\n              BuiltInMethod.NULLS_COMPARATOR.method,\n              Expressions.constant(\n                  collation.nullDirection\n                      == RelFieldCollation.NullDirection.FIRST),\n              Expressions.constant(\n                  collation.getDirection()\n                      == RelFieldCollation.Direction.DESCENDING)));\n    }\n    selector =\n        Expressions.call(BuiltInMethod.IDENTITY_SELECTOR.method);\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod = collations.size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation collation : collations) {\n      final int index = collation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = Types.castIfNecessary(Comparable.class, arg0);\n        arg1 = Types.castIfNecessary(Comparable.class, arg1);\n      }\n      final boolean nullsFirst =\n          collation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          collation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      final Method method = (fieldNullable(index)\n          ? (nullsFirst ^ descending\n              ? BuiltInMethod.COMPARE_NULLS_FIRST\n              : BuiltInMethod.COMPARE_NULLS_LAST)\n          : BuiltInMethod.COMPARE).method;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(method.getDeclaringClass(),\n                      method.getName(),\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.<MemberDeclaration>list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(\n                    parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Pair.<Expression, Expression>of(\n        selector,\n        Expressions.new_(\n            Comparator.class,\n            Collections.<Expression>emptyList(),\n            memberDeclarations));\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":250,"status":"M"},{"authorDate":"2018-07-06 04:21:59","commitOrder":5,"curCode":"  public Expression generateComparator(RelCollation collation) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final Type javaRowClass = Primitive.box(this.javaRowClass);\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod =\n        collation.getFieldCollations().size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation fieldCollation : collation.getFieldCollations()) {\n      final int index = fieldCollation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = Types.castIfNecessary(Comparable.class, arg0);\n        arg1 = Types.castIfNecessary(Comparable.class, arg1);\n      }\n      final boolean nullsFirst =\n          fieldCollation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          fieldCollation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst != descending\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Expressions.new_(\n        Comparator.class,\n        ImmutableList.of(),\n        memberDeclarations);\n  }\n","date":"2018-07-09 01:16:26","endLine":467,"groupId":"12722","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"generateComparator","params":"(RelCollationcollation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/74/64a273eae792779944fd72135119f782f14948.src","preCode":"  public Expression generateComparator(RelCollation collation) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final Type javaRowClass = Primitive.box(this.javaRowClass);\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod =\n        collation.getFieldCollations().size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation fieldCollation : collation.getFieldCollations()) {\n      final int index = fieldCollation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = Types.castIfNecessary(Comparable.class, arg0);\n        arg1 = Types.castIfNecessary(Comparable.class, arg1);\n      }\n      final boolean nullsFirst =\n          fieldCollation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          fieldCollation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst != descending\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.<MemberDeclaration>list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Expressions.new_(\n        Comparator.class,\n        Collections.<Expression>emptyList(),\n        memberDeclarations);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":371,"status":"M"}],"commitId":"d59b639d27da704f00eff616324a2c04aa06f84c","commitMessage":"@@@[CALCITE-2259] Allow Java 8 syntax\n\nIn summary: use lambdas where possible.  switch from Guava function\ntypes to Java function types or lambdas.  but continue to use Guava\ncomponents (such as immutable collections and cache) that have no\nequivalent in the Java runtime.\n\n1. Change single-abstract-method (SAM) classes to lambdas. Preserve\nformatting wherever possible.\n\n2. Change AssertQuery.returns argument type from Guava Function to Java\nConsumer. If you are using a lambda and see 'returns is deprecated'. \nremove the 'return null;' line.  and the lambda will become a Consumer\n(whose return is void).\n\n3. Change RelOptRuleOperand and RelOptRule.operand methods to take Java\nPredicate rather than Guava Predicate.\n\n4. Change the argument of Hook.add and .addThread from Guava Function to\nJava Consumer.\n\n5. Change 'list.toArray(new T[list.size()])' to 'list.toArray(new T[0])'\nbecause the latter is simpler.  and just as efficient on recent Java\nversions.\n\n6. Resource references; change \"try (Closeable ignore = foo())\" to \"try\n  (foo())\".  especially uses of TryThreadLocal and Hook.Closeable.\n\n7. Convert linq4j Function1 to java Function.  Function2 to java BiFunction\n\n8. Fix occurrences of Intellij's \"Explicit type can be replaced with\n<>\" inspection. (Occurs for \"List<String> list = new\nArrayList<String>();\".)\n\n9. Change Guava Preconditions.checkNotNull to Java\nObjects.requireNonNull. (Kevin Risden)\n\n10. Break out anonymous classes and fix dependency problems.\n\n11. Use CacheLoader.of(Function) where possible.\n\n12. Replace sub-classes of ThreadLocal with ThreadLocal.withInitial().\n\n13. Replace Guava collection methods with calls to Java collection types. \nfor example replace Lists.newArrayList() with new ArrayList<>(). \nMaps.newHashSet() with new HashSet<>().  similarly Sets.\n\n14. Replace Guava Joiner with String.join.\n\n15. Replace Collections.emptyList() with ImmutableList.of() in a few\nplaces.\n\nFor backwards compatibility.  we preserved (and deprecated) the old\nmethods that used Guava types. In a few cases where new and old have\nthe same signature (after erasure).  we could not add a method with the\nsame name.  so we gave the new method a \"J\" suffix. Examples include\nHook.property and .propertyJ.  RelOptRule.operand and .operandJ.\n\nIn test code.  we have not slavishly ensured backwards compatibility.\n\nWe do not intend to remove uses of Guava's immutable collections.\n\nWe have ignored Intellij's \"Pseudo functional style code\" inspection\nmost of the time.  but in a few cases have converted Lists.transform(). \nIterables.transform().  and Iterables.filter() into Java streams. Use\nthe Util.toImmutableList() collector if the result is to be an\nimmutable list. Use Util.transform() rather than Lists.transform()\nif you have a Java function rather than a Guava function or lambda.\n\nNot covered in this change (might be done in future):\n* Convert Collections.sort(list) to list.sort.\n* Review uses of 'for (Map.Entry<K.  V> e : map.entrySet())' and see\n  whether it makes sense to convert to 'map.forEach((k.  v) ->\n  ...)'. Intellij inspection is called 'Replace with Map.forEach'.\n\nBreaking changes:\n* LatticeStatisticProvider.Factory.  result of RexUtil.notFun().  and\n  arguments to Mappings.target() are Function (was Guava.  now Java)\n* Argument to SqlSpecialOperator.TokenSequence.parser() is Predicate\n  (was Guava.  now Java)\n* AggregateNode.AccumulatorFactory extends Supplier (was Guava.  now Java)\n","date":"2018-07-09 01:16:26","modifiedFileCount":"514","status":"M","submitter":"Julian Hyde"},{"authorTime":"2019-10-14 20:44:01","codes":[{"authorDate":"2019-10-14 20:44:01","commitOrder":6,"curCode":"  public Pair<Expression, Expression> generateCollationKey(\n      final List<RelFieldCollation> collations) {\n    final Expression selector;\n    if (collations.size() == 1) {\n      RelFieldCollation collation = collations.get(0);\n      ParameterExpression parameter =\n          Expressions.parameter(javaRowClass, \"v\");\n      selector =\n          Expressions.lambda(\n              Function1.class,\n              fieldReference(parameter, collation.getFieldIndex()),\n              parameter);\n      return Pair.of(selector,\n          Expressions.call(\n              BuiltInMethod.NULLS_COMPARATOR.method,\n              Expressions.constant(\n                  collation.nullDirection\n                      == RelFieldCollation.NullDirection.FIRST),\n              Expressions.constant(\n                  collation.getDirection()\n                      == RelFieldCollation.Direction.DESCENDING)));\n    }\n    selector =\n        Expressions.call(BuiltInMethod.IDENTITY_SELECTOR.method);\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod = collations.size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation collation : collations) {\n      final int index = collation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = RexToLixTranslator.convert(arg0, Comparable.class);\n        arg1 = RexToLixTranslator.convert(arg1, Comparable.class);\n      }\n      final boolean nullsFirst =\n          collation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          collation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      final Method method = (fieldNullable(index)\n          ? (nullsFirst ^ descending\n              ? BuiltInMethod.COMPARE_NULLS_FIRST\n              : BuiltInMethod.COMPARE_NULLS_LAST)\n          : BuiltInMethod.COMPARE).method;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(method.getDeclaringClass(),\n                      method.getName(),\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(\n                    parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Pair.of(selector,\n        Expressions.new_(Comparator.class,\n            ImmutableList.of(),\n            memberDeclarations));\n  }\n","date":"2019-10-23 14:36:20","endLine":385,"groupId":"8678","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"generateCollationKey","params":"(finalList<RelFieldCollation>collations)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/a4/8d0ebf9d6577b9faca58b9d34f17ae25b1b7b9.src","preCode":"  public Pair<Expression, Expression> generateCollationKey(\n      final List<RelFieldCollation> collations) {\n    final Expression selector;\n    if (collations.size() == 1) {\n      RelFieldCollation collation = collations.get(0);\n      ParameterExpression parameter =\n          Expressions.parameter(javaRowClass, \"v\");\n      selector =\n          Expressions.lambda(\n              Function1.class,\n              fieldReference(parameter, collation.getFieldIndex()),\n              parameter);\n      return Pair.of(selector,\n          Expressions.call(\n              BuiltInMethod.NULLS_COMPARATOR.method,\n              Expressions.constant(\n                  collation.nullDirection\n                      == RelFieldCollation.NullDirection.FIRST),\n              Expressions.constant(\n                  collation.getDirection()\n                      == RelFieldCollation.Direction.DESCENDING)));\n    }\n    selector =\n        Expressions.call(BuiltInMethod.IDENTITY_SELECTOR.method);\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod = collations.size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation collation : collations) {\n      final int index = collation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = Types.castIfNecessary(Comparable.class, arg0);\n        arg1 = Types.castIfNecessary(Comparable.class, arg1);\n      }\n      final boolean nullsFirst =\n          collation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          collation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      final Method method = (fieldNullable(index)\n          ? (nullsFirst ^ descending\n              ? BuiltInMethod.COMPARE_NULLS_FIRST\n              : BuiltInMethod.COMPARE_NULLS_LAST)\n          : BuiltInMethod.COMPARE).method;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(method.getDeclaringClass(),\n                      method.getName(),\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(\n                    parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Pair.of(selector,\n        Expressions.new_(Comparator.class,\n            ImmutableList.of(),\n            memberDeclarations));\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":266,"status":"M"},{"authorDate":"2019-10-14 20:44:01","commitOrder":6,"curCode":"  public Expression generateComparator(RelCollation collation) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final Type javaRowClass = Primitive.box(this.javaRowClass);\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod =\n        collation.getFieldCollations().size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation fieldCollation : collation.getFieldCollations()) {\n      final int index = fieldCollation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = RexToLixTranslator.convert(arg0, Comparable.class);\n        arg1 = RexToLixTranslator.convert(arg1, Comparable.class);\n      }\n      final boolean nullsFirst =\n          fieldCollation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          fieldCollation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst != descending\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Expressions.new_(\n        Comparator.class,\n        ImmutableList.of(),\n        memberDeclarations);\n  }\n","date":"2019-10-23 14:36:20","endLine":483,"groupId":"9911","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"generateComparator","params":"(RelCollationcollation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/a4/8d0ebf9d6577b9faca58b9d34f17ae25b1b7b9.src","preCode":"  public Expression generateComparator(RelCollation collation) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final Type javaRowClass = Primitive.box(this.javaRowClass);\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod =\n        collation.getFieldCollations().size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation fieldCollation : collation.getFieldCollations()) {\n      final int index = fieldCollation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = Types.castIfNecessary(Comparable.class, arg0);\n        arg1 = Types.castIfNecessary(Comparable.class, arg1);\n      }\n      final boolean nullsFirst =\n          fieldCollation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          fieldCollation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst != descending\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Expressions.new_(\n        Comparator.class,\n        ImmutableList.of(),\n        memberDeclarations);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":387,"status":"M"}],"commitId":"429c0d0e4cacc76933ae6cc651e5e4164f868383","commitMessage":"@@@[CALCITE-3414] In calcite-core.  use RexToLixTranslator.convert for type conversion code generation uniformly (DonnyZone)\n\nclose apache/calcite#1507\n","date":"2019-10-23 14:36:20","modifiedFileCount":"11","status":"M","submitter":"wellfengzhu"},{"authorTime":"2019-11-18 17:00:52","codes":[{"authorDate":"2019-11-18 17:00:52","commitOrder":7,"curCode":"  public Pair<Expression, Expression> generateCollationKey(\n      final List<RelFieldCollation> collations) {\n    final Expression selector;\n    if (collations.size() == 1) {\n      RelFieldCollation collation = collations.get(0);\n      ParameterExpression parameter =\n          Expressions.parameter(javaRowClass, \"v\");\n      selector =\n          Expressions.lambda(\n              Function1.class,\n              fieldReference(parameter, collation.getFieldIndex()),\n              parameter);\n      return Pair.of(selector,\n          Expressions.call(\n              BuiltInMethod.NULLS_COMPARATOR.method,\n              Expressions.constant(\n                  collation.nullDirection\n                      == RelFieldCollation.NullDirection.FIRST),\n              Expressions.constant(\n                  collation.getDirection()\n                      == RelFieldCollation.Direction.DESCENDING)));\n    }\n    selector =\n        Expressions.call(BuiltInMethod.IDENTITY_SELECTOR.method);\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod = collations.size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation collation : collations) {\n      final int index = collation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = EnumUtils.convert(arg0, Comparable.class);\n        arg1 = EnumUtils.convert(arg1, Comparable.class);\n      }\n      final boolean nullsFirst =\n          collation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          collation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      final Method method = (fieldNullable(index)\n          ? (nullsFirst ^ descending\n              ? BuiltInMethod.COMPARE_NULLS_FIRST\n              : BuiltInMethod.COMPARE_NULLS_LAST)\n          : BuiltInMethod.COMPARE).method;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(method.getDeclaringClass(),\n                      method.getName(),\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(\n                    parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Pair.of(selector,\n        Expressions.new_(Comparator.class,\n            ImmutableList.of(),\n            memberDeclarations));\n  }\n","date":"2019-11-27 14:48:38","endLine":385,"groupId":"8678","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"generateCollationKey","params":"(finalList<RelFieldCollation>collations)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/91/2f714d75a2364d32a7f45116092c7b166b607d.src","preCode":"  public Pair<Expression, Expression> generateCollationKey(\n      final List<RelFieldCollation> collations) {\n    final Expression selector;\n    if (collations.size() == 1) {\n      RelFieldCollation collation = collations.get(0);\n      ParameterExpression parameter =\n          Expressions.parameter(javaRowClass, \"v\");\n      selector =\n          Expressions.lambda(\n              Function1.class,\n              fieldReference(parameter, collation.getFieldIndex()),\n              parameter);\n      return Pair.of(selector,\n          Expressions.call(\n              BuiltInMethod.NULLS_COMPARATOR.method,\n              Expressions.constant(\n                  collation.nullDirection\n                      == RelFieldCollation.NullDirection.FIRST),\n              Expressions.constant(\n                  collation.getDirection()\n                      == RelFieldCollation.Direction.DESCENDING)));\n    }\n    selector =\n        Expressions.call(BuiltInMethod.IDENTITY_SELECTOR.method);\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod = collations.size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation collation : collations) {\n      final int index = collation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = RexToLixTranslator.convert(arg0, Comparable.class);\n        arg1 = RexToLixTranslator.convert(arg1, Comparable.class);\n      }\n      final boolean nullsFirst =\n          collation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          collation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      final Method method = (fieldNullable(index)\n          ? (nullsFirst ^ descending\n              ? BuiltInMethod.COMPARE_NULLS_FIRST\n              : BuiltInMethod.COMPARE_NULLS_LAST)\n          : BuiltInMethod.COMPARE).method;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(method.getDeclaringClass(),\n                      method.getName(),\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(\n                    parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Pair.of(selector,\n        Expressions.new_(Comparator.class,\n            ImmutableList.of(),\n            memberDeclarations));\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":266,"status":"M"},{"authorDate":"2019-11-18 17:00:52","commitOrder":7,"curCode":"  public Expression generateComparator(RelCollation collation) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final Type javaRowClass = Primitive.box(this.javaRowClass);\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod =\n        collation.getFieldCollations().size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation fieldCollation : collation.getFieldCollations()) {\n      final int index = fieldCollation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = EnumUtils.convert(arg0, Comparable.class);\n        arg1 = EnumUtils.convert(arg1, Comparable.class);\n      }\n      final boolean nullsFirst =\n          fieldCollation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          fieldCollation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst != descending\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Expressions.new_(\n        Comparator.class,\n        ImmutableList.of(),\n        memberDeclarations);\n  }\n","date":"2019-11-27 14:48:38","endLine":483,"groupId":"9911","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"generateComparator","params":"(RelCollationcollation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/91/2f714d75a2364d32a7f45116092c7b166b607d.src","preCode":"  public Expression generateComparator(RelCollation collation) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final Type javaRowClass = Primitive.box(this.javaRowClass);\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod =\n        collation.getFieldCollations().size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation fieldCollation : collation.getFieldCollations()) {\n      final int index = fieldCollation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = RexToLixTranslator.convert(arg0, Comparable.class);\n        arg1 = RexToLixTranslator.convert(arg1, Comparable.class);\n      }\n      final boolean nullsFirst =\n          fieldCollation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          fieldCollation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst != descending\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Expressions.new_(\n        Comparator.class,\n        ImmutableList.of(),\n        memberDeclarations);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":387,"status":"M"}],"commitId":"33157f42f9ec7779b53b807db7b5066c1314fb6e","commitMessage":"@@@[CALCITE-3512] Query fails when comparing Time/TimeStamp types (DonnyZone)\n\n* Remove EnumUtils#enforce and merge the logic to EnumUtils.toInternal\n* Move RexToLixTranslator#convert to EnumUtils\n\nclose apache/calcite#1592\n","date":"2019-11-27 14:48:38","modifiedFileCount":"16","status":"M","submitter":"wellfengzhu"},{"authorTime":"2020-04-22 18:19:06","codes":[{"authorDate":"2020-04-22 18:19:06","commitOrder":8,"curCode":"  public Pair<Expression, Expression> generateCollationKey(\n      final List<RelFieldCollation> collations) {\n    final Expression selector;\n    if (collations.size() == 1) {\n      RelFieldCollation collation = collations.get(0);\n      RelDataType fieldType = rowType.getFieldList() == null || rowType.getFieldList().isEmpty()\n          ? rowType\n          : rowType.getFieldList().get(collation.getFieldIndex()).getType();\n      Expression fieldComparator = generateCollatorExpression(fieldType.getCollation());\n      ParameterExpression parameter =\n          Expressions.parameter(javaRowClass, \"v\");\n      selector =\n          Expressions.lambda(\n              Function1.class,\n              fieldReference(parameter, collation.getFieldIndex()),\n              parameter);\n      return Pair.of(selector,\n          Expressions.call(\n              fieldComparator == null ? BuiltInMethod.NULLS_COMPARATOR.method\n                  : BuiltInMethod.NULLS_COMPARATOR2.method,\n              Expressions.list(\n                  (Expression) Expressions.constant(\n                      collation.nullDirection\n                          == RelFieldCollation.NullDirection.FIRST),\n                  Expressions.constant(\n                      collation.direction\n                          == RelFieldCollation.Direction.DESCENDING))\n                  .appendIfNotNull(fieldComparator)));\n    }\n    selector =\n        Expressions.call(BuiltInMethod.IDENTITY_SELECTOR.method);\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod = collations.size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation collation : collations) {\n      final int index = collation.getFieldIndex();\n      final RelDataType fieldType = rowType.getFieldList().get(index).getType();\n      final Expression fieldComparator = generateCollatorExpression(fieldType.getCollation());\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = EnumUtils.convert(arg0, Comparable.class);\n        arg1 = EnumUtils.convert(arg1, Comparable.class);\n      }\n      final boolean nullsFirst =\n          collation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          collation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst != descending\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      Expressions.list(\n                          arg0,\n                          arg1)\n                          .appendIfNotNull(fieldComparator)))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(\n                    parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Pair.of(selector,\n        Expressions.new_(Comparator.class,\n            ImmutableList.of(),\n            memberDeclarations));\n  }\n","date":"2020-06-19 00:07:16","endLine":389,"groupId":"10991","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"generateCollationKey","params":"(finalList<RelFieldCollation>collations)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/d6/f23b3562f0861ed71ec72f3e4460a7ce1bb39b.src","preCode":"  public Pair<Expression, Expression> generateCollationKey(\n      final List<RelFieldCollation> collations) {\n    final Expression selector;\n    if (collations.size() == 1) {\n      RelFieldCollation collation = collations.get(0);\n      ParameterExpression parameter =\n          Expressions.parameter(javaRowClass, \"v\");\n      selector =\n          Expressions.lambda(\n              Function1.class,\n              fieldReference(parameter, collation.getFieldIndex()),\n              parameter);\n      return Pair.of(selector,\n          Expressions.call(\n              BuiltInMethod.NULLS_COMPARATOR.method,\n              Expressions.constant(\n                  collation.nullDirection\n                      == RelFieldCollation.NullDirection.FIRST),\n              Expressions.constant(\n                  collation.getDirection()\n                      == RelFieldCollation.Direction.DESCENDING)));\n    }\n    selector =\n        Expressions.call(BuiltInMethod.IDENTITY_SELECTOR.method);\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod = collations.size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation collation : collations) {\n      final int index = collation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = EnumUtils.convert(arg0, Comparable.class);\n        arg1 = EnumUtils.convert(arg1, Comparable.class);\n      }\n      final boolean nullsFirst =\n          collation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          collation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      final Method method = (fieldNullable(index)\n          ? (nullsFirst ^ descending\n              ? BuiltInMethod.COMPARE_NULLS_FIRST\n              : BuiltInMethod.COMPARE_NULLS_LAST)\n          : BuiltInMethod.COMPARE).method;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(method.getDeclaringClass(),\n                      method.getName(),\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(\n                    parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Pair.of(selector,\n        Expressions.new_(Comparator.class,\n            ImmutableList.of(),\n            memberDeclarations));\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":259,"status":"M"},{"authorDate":"2020-04-22 18:19:06","commitOrder":8,"curCode":"  public Expression generateComparator(RelCollation collation) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final Type javaRowClass = Primitive.box(this.javaRowClass);\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod =\n        collation.getFieldCollations().size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation fieldCollation : collation.getFieldCollations()) {\n      final int index = fieldCollation.getFieldIndex();\n      final RelDataType fieldType = rowType.getFieldList().get(index).getType();\n      final Expression fieldComparator = generateCollatorExpression(fieldType.getCollation());\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = EnumUtils.convert(arg0, Comparable.class);\n        arg1 = EnumUtils.convert(arg1, Comparable.class);\n      }\n      final boolean nullsFirst =\n          fieldCollation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          fieldCollation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst != descending\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      Expressions.list(\n                          arg0,\n                          arg1)\n                          .appendIfNotNull(fieldComparator)))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Expressions.new_(\n        Comparator.class,\n        ImmutableList.of(),\n        memberDeclarations);\n  }\n","date":"2020-06-19 00:07:16","endLine":491,"groupId":"10991","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"generateComparator","params":"(RelCollationcollation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/d6/f23b3562f0861ed71ec72f3e4460a7ce1bb39b.src","preCode":"  public Expression generateComparator(RelCollation collation) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final Type javaRowClass = Primitive.box(this.javaRowClass);\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod =\n        collation.getFieldCollations().size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation fieldCollation : collation.getFieldCollations()) {\n      final int index = fieldCollation.getFieldIndex();\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = EnumUtils.convert(arg0, Comparable.class);\n        arg1 = EnumUtils.convert(arg1, Comparable.class);\n      }\n      final boolean nullsFirst =\n          fieldCollation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          fieldCollation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst != descending\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      arg0,\n                      arg1))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Expressions.new_(\n        Comparator.class,\n        ImmutableList.of(),\n        memberDeclarations);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":391,"status":"M"}],"commitId":"fa8349069d141d3c75bafa06d5fb8800711ec8d6","commitMessage":"@@@[CALCITE-3951] Support different string comparison based on SqlCollation\n","date":"2020-06-19 00:07:16","modifiedFileCount":"14","status":"M","submitter":"rubenada"},{"authorTime":"2020-09-29 22:09:05","codes":[{"authorDate":"2020-09-29 22:09:05","commitOrder":9,"curCode":"  @Override public Pair<Expression, Expression> generateCollationKey(\n      final List<RelFieldCollation> collations) {\n    final Expression selector;\n    if (collations.size() == 1) {\n      RelFieldCollation collation = collations.get(0);\n      RelDataType fieldType = rowType.getFieldList() == null || rowType.getFieldList().isEmpty()\n          ? rowType\n          : rowType.getFieldList().get(collation.getFieldIndex()).getType();\n      Expression fieldComparator = generateCollatorExpression(fieldType.getCollation());\n      ParameterExpression parameter =\n          Expressions.parameter(javaRowClass, \"v\");\n      selector =\n          Expressions.lambda(\n              Function1.class,\n              fieldReference(parameter, collation.getFieldIndex()),\n              parameter);\n      return Pair.of(selector,\n          Expressions.call(\n              fieldComparator == null ? BuiltInMethod.NULLS_COMPARATOR.method\n                  : BuiltInMethod.NULLS_COMPARATOR2.method,\n              Expressions.list(\n                  (Expression) Expressions.constant(\n                      collation.nullDirection\n                          == RelFieldCollation.NullDirection.FIRST),\n                  Expressions.constant(\n                      collation.direction\n                          == RelFieldCollation.Direction.DESCENDING))\n                  .appendIfNotNull(fieldComparator)));\n    }\n    selector =\n        Expressions.call(BuiltInMethod.IDENTITY_SELECTOR.method);\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod = collations.size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation collation : collations) {\n      final int index = collation.getFieldIndex();\n      final RelDataType fieldType = rowType.getFieldList().get(index).getType();\n      final Expression fieldComparator = generateCollatorExpression(fieldType.getCollation());\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = EnumUtils.convert(arg0, Comparable.class);\n        arg1 = EnumUtils.convert(arg1, Comparable.class);\n      }\n      final boolean nullsFirst =\n          collation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          collation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst != descending\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      Expressions.list(\n                          arg0,\n                          arg1)\n                          .appendIfNotNull(fieldComparator)))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(\n                    parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Pair.of(selector,\n        Expressions.new_(Comparator.class,\n            ImmutableList.of(),\n            memberDeclarations));\n  }\n","date":"2020-10-07 05:42:47","endLine":389,"groupId":"10991","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"generateCollationKey","params":"(finalList<RelFieldCollation>collations)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/47/f6c4649b375d9fb3da2f3379117e8a02b27620.src","preCode":"  public Pair<Expression, Expression> generateCollationKey(\n      final List<RelFieldCollation> collations) {\n    final Expression selector;\n    if (collations.size() == 1) {\n      RelFieldCollation collation = collations.get(0);\n      RelDataType fieldType = rowType.getFieldList() == null || rowType.getFieldList().isEmpty()\n          ? rowType\n          : rowType.getFieldList().get(collation.getFieldIndex()).getType();\n      Expression fieldComparator = generateCollatorExpression(fieldType.getCollation());\n      ParameterExpression parameter =\n          Expressions.parameter(javaRowClass, \"v\");\n      selector =\n          Expressions.lambda(\n              Function1.class,\n              fieldReference(parameter, collation.getFieldIndex()),\n              parameter);\n      return Pair.of(selector,\n          Expressions.call(\n              fieldComparator == null ? BuiltInMethod.NULLS_COMPARATOR.method\n                  : BuiltInMethod.NULLS_COMPARATOR2.method,\n              Expressions.list(\n                  (Expression) Expressions.constant(\n                      collation.nullDirection\n                          == RelFieldCollation.NullDirection.FIRST),\n                  Expressions.constant(\n                      collation.direction\n                          == RelFieldCollation.Direction.DESCENDING))\n                  .appendIfNotNull(fieldComparator)));\n    }\n    selector =\n        Expressions.call(BuiltInMethod.IDENTITY_SELECTOR.method);\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod = collations.size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation collation : collations) {\n      final int index = collation.getFieldIndex();\n      final RelDataType fieldType = rowType.getFieldList().get(index).getType();\n      final Expression fieldComparator = generateCollatorExpression(fieldType.getCollation());\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = EnumUtils.convert(arg0, Comparable.class);\n        arg1 = EnumUtils.convert(arg1, Comparable.class);\n      }\n      final boolean nullsFirst =\n          collation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          collation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst != descending\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      Expressions.list(\n                          arg0,\n                          arg1)\n                          .appendIfNotNull(fieldComparator)))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(\n                    parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Pair.of(selector,\n        Expressions.new_(Comparator.class,\n            ImmutableList.of(),\n            memberDeclarations));\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":259,"status":"M"},{"authorDate":"2020-09-29 22:09:05","commitOrder":9,"curCode":"  @Override public Expression generateComparator(RelCollation collation) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final Type javaRowClass = Primitive.box(this.javaRowClass);\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod =\n        collation.getFieldCollations().size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation fieldCollation : collation.getFieldCollations()) {\n      final int index = fieldCollation.getFieldIndex();\n      final RelDataType fieldType = rowType.getFieldList().get(index).getType();\n      final Expression fieldComparator = generateCollatorExpression(fieldType.getCollation());\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = EnumUtils.convert(arg0, Comparable.class);\n        arg1 = EnumUtils.convert(arg1, Comparable.class);\n      }\n      final boolean nullsFirst =\n          fieldCollation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          fieldCollation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst != descending\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      Expressions.list(\n                          arg0,\n                          arg1)\n                          .appendIfNotNull(fieldComparator)))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Expressions.new_(\n        Comparator.class,\n        ImmutableList.of(),\n        memberDeclarations);\n  }\n","date":"2020-10-07 05:42:47","endLine":491,"groupId":"10991","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"generateComparator","params":"(RelCollationcollation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/47/f6c4649b375d9fb3da2f3379117e8a02b27620.src","preCode":"  public Expression generateComparator(RelCollation collation) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final Type javaRowClass = Primitive.box(this.javaRowClass);\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod =\n        collation.getFieldCollations().size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation fieldCollation : collation.getFieldCollations()) {\n      final int index = fieldCollation.getFieldIndex();\n      final RelDataType fieldType = rowType.getFieldList().get(index).getType();\n      final Expression fieldComparator = generateCollatorExpression(fieldType.getCollation());\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = EnumUtils.convert(arg0, Comparable.class);\n        arg1 = EnumUtils.convert(arg1, Comparable.class);\n      }\n      final boolean nullsFirst =\n          fieldCollation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          fieldCollation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst != descending\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      Expressions.list(\n                          arg0,\n                          arg1)\n                          .appendIfNotNull(fieldComparator)))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Expressions.new_(\n        Comparator.class,\n        ImmutableList.of(),\n        memberDeclarations);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":391,"status":"M"}],"commitId":"66caa54c5e272f8287ca132ca012733898a38768","commitMessage":"@@@[CALCITE-4314] Add missing @Override annotations\n","date":"2020-10-07 05:42:47","modifiedFileCount":"745","status":"M","submitter":"Vladimir Sitnikov"},{"authorTime":"2020-09-30 01:31:14","codes":[{"authorDate":"2020-09-30 01:31:14","commitOrder":10,"curCode":"  @Override public Pair<Expression, Expression> generateCollationKey(\n      final List<RelFieldCollation> collations) {\n    final Expression selector;\n    if (collations.size() == 1) {\n      RelFieldCollation collation = collations.get(0);\n      RelDataType fieldType = rowType.getFieldList() == null || rowType.getFieldList().isEmpty()\n          ? rowType\n          : rowType.getFieldList().get(collation.getFieldIndex()).getType();\n      Expression fieldComparator = generateCollatorExpression(fieldType.getCollation());\n      ParameterExpression parameter =\n          Expressions.parameter(javaRowClass, \"v\");\n      selector =\n          Expressions.lambda(\n              Function1.class,\n              fieldReference(parameter, collation.getFieldIndex()),\n              parameter);\n      return Pair.of(selector,\n          Expressions.call(\n              fieldComparator == null ? BuiltInMethod.NULLS_COMPARATOR.method\n                  : BuiltInMethod.NULLS_COMPARATOR2.method,\n              Expressions.list(\n                  (Expression) Expressions.constant(\n                      collation.nullDirection\n                          == RelFieldCollation.NullDirection.FIRST),\n                  Expressions.constant(\n                      collation.direction\n                          == RelFieldCollation.Direction.DESCENDING))\n                  .appendIfNotNull(fieldComparator)));\n    }\n    selector =\n        Expressions.call(BuiltInMethod.IDENTITY_SELECTOR.method);\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod = collations.size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation collation : collations) {\n      final int index = collation.getFieldIndex();\n      final RelDataType fieldType = rowType.getFieldList().get(index).getType();\n      final Expression fieldComparator = generateCollatorExpression(fieldType.getCollation());\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = EnumUtils.convert(arg0, Comparable.class);\n        arg1 = EnumUtils.convert(arg1, Comparable.class);\n        break;\n      default:\n        break;\n      }\n      final boolean nullsFirst =\n          collation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          collation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst != descending\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      Expressions.list(\n                          arg0,\n                          arg1)\n                          .appendIfNotNull(fieldComparator)))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(\n                    parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Pair.of(selector,\n        Expressions.new_(Comparator.class,\n            ImmutableList.of(),\n            memberDeclarations));\n  }\n","date":"2020-10-07 05:43:06","endLine":396,"groupId":"102150","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"generateCollationKey","params":"(finalList<RelFieldCollation>collations)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/b9/6ebf6d75e8fbbc6f8cdecbbc905e168c14382e.src","preCode":"  @Override public Pair<Expression, Expression> generateCollationKey(\n      final List<RelFieldCollation> collations) {\n    final Expression selector;\n    if (collations.size() == 1) {\n      RelFieldCollation collation = collations.get(0);\n      RelDataType fieldType = rowType.getFieldList() == null || rowType.getFieldList().isEmpty()\n          ? rowType\n          : rowType.getFieldList().get(collation.getFieldIndex()).getType();\n      Expression fieldComparator = generateCollatorExpression(fieldType.getCollation());\n      ParameterExpression parameter =\n          Expressions.parameter(javaRowClass, \"v\");\n      selector =\n          Expressions.lambda(\n              Function1.class,\n              fieldReference(parameter, collation.getFieldIndex()),\n              parameter);\n      return Pair.of(selector,\n          Expressions.call(\n              fieldComparator == null ? BuiltInMethod.NULLS_COMPARATOR.method\n                  : BuiltInMethod.NULLS_COMPARATOR2.method,\n              Expressions.list(\n                  (Expression) Expressions.constant(\n                      collation.nullDirection\n                          == RelFieldCollation.NullDirection.FIRST),\n                  Expressions.constant(\n                      collation.direction\n                          == RelFieldCollation.Direction.DESCENDING))\n                  .appendIfNotNull(fieldComparator)));\n    }\n    selector =\n        Expressions.call(BuiltInMethod.IDENTITY_SELECTOR.method);\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod = collations.size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation collation : collations) {\n      final int index = collation.getFieldIndex();\n      final RelDataType fieldType = rowType.getFieldList().get(index).getType();\n      final Expression fieldComparator = generateCollatorExpression(fieldType.getCollation());\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = EnumUtils.convert(arg0, Comparable.class);\n        arg1 = EnumUtils.convert(arg1, Comparable.class);\n      }\n      final boolean nullsFirst =\n          collation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          collation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst != descending\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      Expressions.list(\n                          arg0,\n                          arg1)\n                          .appendIfNotNull(fieldComparator)))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(\n                    parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Pair.of(selector,\n        Expressions.new_(Comparator.class,\n            ImmutableList.of(),\n            memberDeclarations));\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":263,"status":"M"},{"authorDate":"2020-09-30 01:31:14","commitOrder":10,"curCode":"  @Override public Expression generateComparator(RelCollation collation) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final Type javaRowClass = Primitive.box(this.javaRowClass);\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod =\n        collation.getFieldCollations().size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation fieldCollation : collation.getFieldCollations()) {\n      final int index = fieldCollation.getFieldIndex();\n      final RelDataType fieldType = rowType.getFieldList().get(index).getType();\n      final Expression fieldComparator = generateCollatorExpression(fieldType.getCollation());\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = EnumUtils.convert(arg0, Comparable.class);\n        arg1 = EnumUtils.convert(arg1, Comparable.class);\n        break;\n      default:\n        break;\n      }\n      final boolean nullsFirst =\n          fieldCollation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          fieldCollation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst != descending\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      Expressions.list(\n                          arg0,\n                          arg1)\n                          .appendIfNotNull(fieldComparator)))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Expressions.new_(\n        Comparator.class,\n        ImmutableList.of(),\n        memberDeclarations);\n  }\n","date":"2020-10-07 05:43:06","endLine":501,"groupId":"102150","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"generateComparator","params":"(RelCollationcollation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/b9/6ebf6d75e8fbbc6f8cdecbbc905e168c14382e.src","preCode":"  @Override public Expression generateComparator(RelCollation collation) {\n    \r\n    \r\n    \r\n    \r\n    \r\n    BlockBuilder body = new BlockBuilder();\n    final Type javaRowClass = Primitive.box(this.javaRowClass);\n    final ParameterExpression parameterV0 =\n        Expressions.parameter(javaRowClass, \"v0\");\n    final ParameterExpression parameterV1 =\n        Expressions.parameter(javaRowClass, \"v1\");\n    final ParameterExpression parameterC =\n        Expressions.parameter(int.class, \"c\");\n    final int mod =\n        collation.getFieldCollations().size() == 1 ? Modifier.FINAL : 0;\n    body.add(Expressions.declare(mod, parameterC, null));\n    for (RelFieldCollation fieldCollation : collation.getFieldCollations()) {\n      final int index = fieldCollation.getFieldIndex();\n      final RelDataType fieldType = rowType.getFieldList().get(index).getType();\n      final Expression fieldComparator = generateCollatorExpression(fieldType.getCollation());\n      Expression arg0 = fieldReference(parameterV0, index);\n      Expression arg1 = fieldReference(parameterV1, index);\n      switch (Primitive.flavor(fieldClass(index))) {\n      case OBJECT:\n        arg0 = EnumUtils.convert(arg0, Comparable.class);\n        arg1 = EnumUtils.convert(arg1, Comparable.class);\n      }\n      final boolean nullsFirst =\n          fieldCollation.nullDirection\n              == RelFieldCollation.NullDirection.FIRST;\n      final boolean descending =\n          fieldCollation.getDirection()\n              == RelFieldCollation.Direction.DESCENDING;\n      body.add(\n          Expressions.statement(\n              Expressions.assign(\n                  parameterC,\n                  Expressions.call(\n                      Utilities.class,\n                      fieldNullable(index)\n                          ? (nullsFirst != descending\n                          ? \"compareNullsFirst\"\n                          : \"compareNullsLast\")\n                          : \"compare\",\n                      Expressions.list(\n                          arg0,\n                          arg1)\n                          .appendIfNotNull(fieldComparator)))));\n      body.add(\n          Expressions.ifThen(\n              Expressions.notEqual(\n                  parameterC, Expressions.constant(0)),\n              Expressions.return_(\n                  null,\n                  descending\n                      ? Expressions.negate(parameterC)\n                      : parameterC)));\n    }\n    body.add(\n        Expressions.return_(null, Expressions.constant(0)));\n\n    final List<MemberDeclaration> memberDeclarations =\n        Expressions.list(\n            Expressions.methodDecl(\n                Modifier.PUBLIC,\n                int.class,\n                \"compare\",\n                ImmutableList.of(parameterV0, parameterV1),\n                body.toBlock()));\n\n    if (EnumerableRules.BRIDGE_METHODS) {\n      final ParameterExpression parameterO0 =\n          Expressions.parameter(Object.class, \"o0\");\n      final ParameterExpression parameterO1 =\n          Expressions.parameter(Object.class, \"o1\");\n      BlockBuilder bridgeBody = new BlockBuilder();\n      bridgeBody.add(\n          Expressions.return_(\n              null,\n              Expressions.call(\n                  Expressions.parameter(\n                      Comparable.class, \"this\"),\n                  BuiltInMethod.COMPARATOR_COMPARE.method,\n                  Expressions.convert_(\n                      parameterO0,\n                      javaRowClass),\n                  Expressions.convert_(\n                      parameterO1,\n                      javaRowClass))));\n      memberDeclarations.add(\n          overridingMethodDecl(\n              BuiltInMethod.COMPARATOR_COMPARE.method,\n              ImmutableList.of(parameterO0, parameterO1),\n              bridgeBody.toBlock()));\n    }\n    return Expressions.new_(\n        Comparator.class,\n        ImmutableList.of(),\n        memberDeclarations);\n  }\n","realPath":"core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":398,"status":"M"}],"commitId":"1b94f37e888cf2d186362473529e6c147afe0f6e","commitMessage":"@@@[CALCITE-4314] Add missing default branches to switch statement\n\nNote: the changes are mechanical.\nThe intention is to keep the previous behavior and prevent adding new\nnon exchaustive switch statements in the future.\n\nSee https://errorprone.info/bugpattern/MissingCasesInEnumSwitch\n","date":"2020-10-07 05:43:06","modifiedFileCount":"98","status":"M","submitter":"Vladimir Sitnikov"}]
