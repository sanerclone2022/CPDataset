[{"authorTime":"2016-09-27 15:44:32","codes":[{"authorDate":"2016-09-27 15:44:32","commitOrder":1,"curCode":"  public void testInvalidAccessUseStringForIndexOnArray() throws Exception {\n    Connection connection = setupConnectionWithNestedTable();\n\n    final Statement statement = connection.createStatement();\n\n    try {\n      final String sql = \"select \\\"ID\\\",\"\n          + \" \\\"MAPFIELD\\\", \\\"NESTEDMAPFIELD\\\", \\\"ARRAYFIELD\\\" \"\n          + \"from \\\"s\\\".\\\"nested\\\" \"\n          + \"where \\\"ARRAYFIELD\\\"['a'] = 200\";\n      statement.executeQuery(sql);\n\n      fail(\"This query shouldn't be evaluated properly\");\n    } catch (SQLException e) {\n      Throwable e2 = e.getCause();\n      assertThat(e2, is(instanceOf(CalciteContextException.class)));\n    }\n  }\n","date":"2016-09-30 03:25:47","endLine":124,"groupId":"9764","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testInvalidAccessUseStringForIndexOnArray","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/72/19aeb83275f45cd2a770c4293ac36b7c52cda0.src","preCode":"  public void testInvalidAccessUseStringForIndexOnArray() throws Exception {\n    Connection connection = setupConnectionWithNestedTable();\n\n    final Statement statement = connection.createStatement();\n\n    try {\n      final String sql = \"select \\\"ID\\\",\"\n          + \" \\\"MAPFIELD\\\", \\\"NESTEDMAPFIELD\\\", \\\"ARRAYFIELD\\\" \"\n          + \"from \\\"s\\\".\\\"nested\\\" \"\n          + \"where \\\"ARRAYFIELD\\\"['a'] = 200\";\n      statement.executeQuery(sql);\n\n      fail(\"This query shouldn't be evaluated properly\");\n    } catch (SQLException e) {\n      Throwable e2 = e.getCause();\n      assertThat(e2, is(instanceOf(CalciteContextException.class)));\n    }\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/CollectionTypeTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":107,"status":"B"},{"authorDate":"2016-09-27 15:44:32","commitOrder":1,"curCode":"  public void testInvalidAccessUseStringForIndexOnArrayWithAnyType() throws Exception {\n    Connection connection = setupConnectionWithNestedTable();\n\n    final Statement statement = connection.createStatement();\n\n    try {\n      final String sql = \"select \\\"ID\\\", \\\"MAPFIELD\\\",\"\n          + \" \\\"NESTEDMAPFIELD\\\", \\\"ARRAYFIELD\\\" \"\n          + \"from \\\"s\\\".\\\"nested\\\" \"\n          + \"where CAST(\\\"ARRAYFIELD\\\"['a'] AS INTEGER) = 200\";\n      statement.executeQuery(sql);\n\n      fail(\"This query shouldn't be evaluated properly\");\n    } catch (SQLException e) {\n      Throwable e2 = e.getCause();\n      assertThat(e2, is(instanceOf(CalciteContextException.class)));\n    }\n  }\n","date":"2016-09-30 03:25:47","endLine":239,"groupId":"9764","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testInvalidAccessUseStringForIndexOnArrayWithAnyType","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/72/19aeb83275f45cd2a770c4293ac36b7c52cda0.src","preCode":"  public void testInvalidAccessUseStringForIndexOnArrayWithAnyType() throws Exception {\n    Connection connection = setupConnectionWithNestedTable();\n\n    final Statement statement = connection.createStatement();\n\n    try {\n      final String sql = \"select \\\"ID\\\", \\\"MAPFIELD\\\",\"\n          + \" \\\"NESTEDMAPFIELD\\\", \\\"ARRAYFIELD\\\" \"\n          + \"from \\\"s\\\".\\\"nested\\\" \"\n          + \"where CAST(\\\"ARRAYFIELD\\\"['a'] AS INTEGER) = 200\";\n      statement.executeQuery(sql);\n\n      fail(\"This query shouldn't be evaluated properly\");\n    } catch (SQLException e) {\n      Throwable e2 = e.getCause();\n      assertThat(e2, is(instanceOf(CalciteContextException.class)));\n    }\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/CollectionTypeTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":222,"status":"B"}],"commitId":"963876bbbf4e9da2d0ea7687b9ed10ca7e9172c4","commitMessage":"@@@[CALCITE-1386] ITEM operator ignores the value type of the collection.  assigns to Object variable (Jungtaek Lim)\n\n* Modify MethodImplementor to cast return value to desired return type\n  when necessary\n* Change ItemImplementor to use NullPolicy.ANY since ITEM can still\n  return null even though both operands are not null\n* Fix Types.castIfNecessary to handle RecordType as an exceptional\n  case (can't be converted to Class)\n* Change Csv tests to test its behavior\n* Address Array / Map type to be nullable\n* Address unit tests\n\nClose apache/calcite#283\n","date":"2016-09-30 03:25:47","modifiedFileCount":"9","status":"B","submitter":"Jungtaek Lim"},{"authorTime":"2019-12-04 02:44:13","codes":[{"authorDate":"2019-12-04 02:44:13","commitOrder":2,"curCode":"  @Test public void testInvalidAccessUseStringForIndexOnArray() throws Exception {\n    Connection connection = setupConnectionWithNestedTable();\n\n    final Statement statement = connection.createStatement();\n\n    try {\n      final String sql = \"select \\\"ID\\\",\"\n          + \" \\\"MAPFIELD\\\", \\\"NESTEDMAPFIELD\\\", \\\"ARRAYFIELD\\\" \"\n          + \"from \\\"s\\\".\\\"nested\\\" \"\n          + \"where \\\"ARRAYFIELD\\\"['a'] = 200\";\n      statement.executeQuery(sql);\n\n      fail(\"This query shouldn't be evaluated properly\");\n    } catch (SQLException e) {\n      Throwable e2 = e.getCause();\n      assertThat(e2, is(instanceOf(CalciteContextException.class)));\n    }\n  }\n","date":"2019-12-14 23:57:27","endLine":126,"groupId":"9764","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testInvalidAccessUseStringForIndexOnArray","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/d1/f52a8e52cd2752db59aedf58656dd1abcb6630.src","preCode":"  public void testInvalidAccessUseStringForIndexOnArray() throws Exception {\n    Connection connection = setupConnectionWithNestedTable();\n\n    final Statement statement = connection.createStatement();\n\n    try {\n      final String sql = \"select \\\"ID\\\",\"\n          + \" \\\"MAPFIELD\\\", \\\"NESTEDMAPFIELD\\\", \\\"ARRAYFIELD\\\" \"\n          + \"from \\\"s\\\".\\\"nested\\\" \"\n          + \"where \\\"ARRAYFIELD\\\"['a'] = 200\";\n      statement.executeQuery(sql);\n\n      fail(\"This query shouldn't be evaluated properly\");\n    } catch (SQLException e) {\n      Throwable e2 = e.getCause();\n      assertThat(e2, is(instanceOf(CalciteContextException.class)));\n    }\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/CollectionTypeTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":109,"status":"M"},{"authorDate":"2019-12-04 02:44:13","commitOrder":2,"curCode":"  @Test public void testInvalidAccessUseStringForIndexOnArrayWithAnyType() throws Exception {\n    Connection connection = setupConnectionWithNestedTable();\n\n    final Statement statement = connection.createStatement();\n\n    try {\n      final String sql = \"select \\\"ID\\\", \\\"MAPFIELD\\\",\"\n          + \" \\\"NESTEDMAPFIELD\\\", \\\"ARRAYFIELD\\\" \"\n          + \"from \\\"s\\\".\\\"nested\\\" \"\n          + \"where CAST(\\\"ARRAYFIELD\\\"['a'] AS INTEGER) = 200\";\n      statement.executeQuery(sql);\n\n      fail(\"This query shouldn't be evaluated properly\");\n    } catch (SQLException e) {\n      Throwable e2 = e.getCause();\n      assertThat(e2, is(instanceOf(CalciteContextException.class)));\n    }\n  }\n","date":"2019-12-14 23:57:27","endLine":267,"groupId":"9764","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testInvalidAccessUseStringForIndexOnArrayWithAnyType","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/d1/f52a8e52cd2752db59aedf58656dd1abcb6630.src","preCode":"  public void testInvalidAccessUseStringForIndexOnArrayWithAnyType() throws Exception {\n    Connection connection = setupConnectionWithNestedTable();\n\n    final Statement statement = connection.createStatement();\n\n    try {\n      final String sql = \"select \\\"ID\\\", \\\"MAPFIELD\\\",\"\n          + \" \\\"NESTEDMAPFIELD\\\", \\\"ARRAYFIELD\\\" \"\n          + \"from \\\"s\\\".\\\"nested\\\" \"\n          + \"where CAST(\\\"ARRAYFIELD\\\"['a'] AS INTEGER) = 200\";\n      statement.executeQuery(sql);\n\n      fail(\"This query shouldn't be evaluated properly\");\n    } catch (SQLException e) {\n      Throwable e2 = e.getCause();\n      assertThat(e2, is(instanceOf(CalciteContextException.class)));\n    }\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/CollectionTypeTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":250,"status":"M"}],"commitId":"571731b80a58eb095ebac7123285c375e7afff90","commitMessage":"@@@[CALCITE-3559] Update formatting: remove \"// End\" trailers.  move @Test from their own lines\n","date":"2019-12-14 23:57:27","modifiedFileCount":"1961","status":"M","submitter":"Vladimir Sitnikov"},{"authorTime":"2020-04-02 10:39:10","codes":[{"authorDate":"2020-04-02 10:39:10","commitOrder":3,"curCode":"  @Test void testInvalidAccessUseStringForIndexOnArray() throws Exception {\n    Connection connection = setupConnectionWithNestedTable();\n\n    final Statement statement = connection.createStatement();\n\n    try {\n      final String sql = \"select \\\"ID\\\",\"\n          + \" \\\"MAPFIELD\\\", \\\"NESTEDMAPFIELD\\\", \\\"ARRAYFIELD\\\" \"\n          + \"from \\\"s\\\".\\\"nested\\\" \"\n          + \"where \\\"ARRAYFIELD\\\"['a'] = 200\";\n      statement.executeQuery(sql);\n\n      fail(\"This query shouldn't be evaluated properly\");\n    } catch (SQLException e) {\n      Throwable e2 = e.getCause();\n      assertThat(e2, is(instanceOf(CalciteContextException.class)));\n    }\n  }\n","date":"2020-04-06 04:57:49","endLine":126,"groupId":"101377","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testInvalidAccessUseStringForIndexOnArray","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/b9/5a69a31b8ac230d7825c76ad72c85f49331902.src","preCode":"  @Test public void testInvalidAccessUseStringForIndexOnArray() throws Exception {\n    Connection connection = setupConnectionWithNestedTable();\n\n    final Statement statement = connection.createStatement();\n\n    try {\n      final String sql = \"select \\\"ID\\\",\"\n          + \" \\\"MAPFIELD\\\", \\\"NESTEDMAPFIELD\\\", \\\"ARRAYFIELD\\\" \"\n          + \"from \\\"s\\\".\\\"nested\\\" \"\n          + \"where \\\"ARRAYFIELD\\\"['a'] = 200\";\n      statement.executeQuery(sql);\n\n      fail(\"This query shouldn't be evaluated properly\");\n    } catch (SQLException e) {\n      Throwable e2 = e.getCause();\n      assertThat(e2, is(instanceOf(CalciteContextException.class)));\n    }\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/CollectionTypeTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":109,"status":"M"},{"authorDate":"2020-04-02 10:39:10","commitOrder":3,"curCode":"  @Test void testInvalidAccessUseStringForIndexOnArrayWithAnyType() throws Exception {\n    Connection connection = setupConnectionWithNestedTable();\n\n    final Statement statement = connection.createStatement();\n\n    try {\n      final String sql = \"select \\\"ID\\\", \\\"MAPFIELD\\\",\"\n          + \" \\\"NESTEDMAPFIELD\\\", \\\"ARRAYFIELD\\\" \"\n          + \"from \\\"s\\\".\\\"nested\\\" \"\n          + \"where CAST(\\\"ARRAYFIELD\\\"['a'] AS INTEGER) = 200\";\n      statement.executeQuery(sql);\n\n      fail(\"This query shouldn't be evaluated properly\");\n    } catch (SQLException e) {\n      Throwable e2 = e.getCause();\n      assertThat(e2, is(instanceOf(CalciteContextException.class)));\n    }\n  }\n","date":"2020-04-06 04:57:49","endLine":267,"groupId":"101377","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testInvalidAccessUseStringForIndexOnArrayWithAnyType","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/b9/5a69a31b8ac230d7825c76ad72c85f49331902.src","preCode":"  @Test public void testInvalidAccessUseStringForIndexOnArrayWithAnyType() throws Exception {\n    Connection connection = setupConnectionWithNestedTable();\n\n    final Statement statement = connection.createStatement();\n\n    try {\n      final String sql = \"select \\\"ID\\\", \\\"MAPFIELD\\\",\"\n          + \" \\\"NESTEDMAPFIELD\\\", \\\"ARRAYFIELD\\\" \"\n          + \"from \\\"s\\\".\\\"nested\\\" \"\n          + \"where CAST(\\\"ARRAYFIELD\\\"['a'] AS INTEGER) = 200\";\n      statement.executeQuery(sql);\n\n      fail(\"This query shouldn't be evaluated properly\");\n    } catch (SQLException e) {\n      Throwable e2 = e.getCause();\n      assertThat(e2, is(instanceOf(CalciteContextException.class)));\n    }\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/CollectionTypeTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":250,"status":"M"}],"commitId":"9492dd4146f63ddc028010d6c4e86f6a5cb29a8d","commitMessage":"@@@[CALCITE-3892] Make junit test classes and methods non-public where possible\n\nPrior to junit 5.  classes and methods had to be public. This is no\nlonger the case.\n\nSome classes need to remain public because they are referenced from\nelsewhere.  or if they use reflection somehow. The remaining 'public'\nkeyword will be informative to maintainers.\n","date":"2020-04-06 04:57:49","modifiedFileCount":"196","status":"M","submitter":"Julian Hyde"}]
