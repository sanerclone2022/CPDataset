[{"authorTime":"2020-01-07 11:10:46","codes":[{"authorDate":"2019-08-27 04:28:31","commitOrder":6,"curCode":"  @Test public void testByteString() {\n    final byte[] bytes = {(byte) 0xAB, (byte) 0xFF};\n    final ByteString byteString = new ByteString(bytes);\n    assertThat(byteString.length(), is(2));\n    assertThat(byteString.toString(), is(\"abff\"));\n    assertThat(byteString.toString(16), is(\"abff\"));\n    assertThat(byteString.toString(2), is(\"1010101111111111\"));\n\n    final ByteString emptyByteString = new ByteString(new byte[0]);\n    assertThat(emptyByteString.length(), is(0));\n    assertThat(emptyByteString.toString(), is(\"\"));\n    assertThat(emptyByteString.toString(16), is(\"\"));\n    assertThat(emptyByteString.toString(2), is(\"\"));\n\n    assertThat(ByteString.EMPTY, is(emptyByteString));\n\n    assertThat(byteString.substring(1, 2).toString(), is(\"ff\"));\n    assertThat(byteString.substring(0, 2).toString(), is(\"abff\"));\n    assertThat(byteString.substring(2, 2).toString(), is(\"\"));\n\n    \r\n    assertSame(byteString.concat(emptyByteString), byteString);\n    final ByteString byteString1 = new ByteString(new byte[]{(byte) 12});\n    assertThat(byteString.concat(byteString1).toString(), is(\"abff0c\"));\n\n    final byte[] bytes3 = {(byte) 0xFF};\n    final ByteString byteString3 = new ByteString(bytes3);\n\n    assertThat(byteString.indexOf(emptyByteString), is(0));\n    assertThat(byteString.indexOf(byteString1), is(-1));\n    assertThat(byteString.indexOf(byteString3), is(1));\n    assertThat(byteString3.indexOf(byteString), is(-1));\n\n    thereAndBack(bytes);\n    thereAndBack(emptyByteString.getBytes());\n    thereAndBack(new byte[]{10, 0, 29, -80});\n\n    assertThat(ByteString.of(\"ab12\", 16).toString(16), equalTo(\"ab12\"));\n    assertThat(ByteString.of(\"AB0001DdeAD3\", 16).toString(16),\n        equalTo(\"ab0001ddead3\"));\n    assertThat(ByteString.of(\"\", 16), equalTo(emptyByteString));\n    try {\n      ByteString x = ByteString.of(\"ABg0\", 16);\n      fail(\"expected error, got \" + x);\n    } catch (IllegalArgumentException e) {\n      assertThat(e.getMessage(), equalTo(\"invalid hex character: g\"));\n    }\n    try {\n      ByteString x = ByteString.of(\"ABC\", 16);\n      fail(\"expected error, got \" + x);\n    } catch (IllegalArgumentException e) {\n      assertThat(e.getMessage(), equalTo(\"hex string has odd length\"));\n    }\n\n    final byte[] bytes4 = {10, 0, 1, -80};\n    final ByteString byteString4 = new ByteString(bytes4);\n    final byte[] bytes5 = {10, 0, 1, 127};\n    final ByteString byteString5 = new ByteString(bytes5);\n    final ByteString byteString6 = new ByteString(bytes4);\n\n    assertThat(byteString4.compareTo(byteString5) > 0, is(true));\n    assertThat(byteString4.compareTo(byteString6) == 0, is(true));\n    assertThat(byteString5.compareTo(byteString4) < 0, is(true));\n  }\n","date":"2019-08-27 11:42:53","endLine":533,"groupId":"2670","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testByteString","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/69/c3963a80ec204303fc8a66ccea405ca1398a84.src","preCode":"  @Test public void testByteString() {\n    final byte[] bytes = {(byte) 0xAB, (byte) 0xFF};\n    final ByteString byteString = new ByteString(bytes);\n    assertThat(byteString.length(), is(2));\n    assertThat(byteString.toString(), is(\"abff\"));\n    assertThat(byteString.toString(16), is(\"abff\"));\n    assertThat(byteString.toString(2), is(\"1010101111111111\"));\n\n    final ByteString emptyByteString = new ByteString(new byte[0]);\n    assertThat(emptyByteString.length(), is(0));\n    assertThat(emptyByteString.toString(), is(\"\"));\n    assertThat(emptyByteString.toString(16), is(\"\"));\n    assertThat(emptyByteString.toString(2), is(\"\"));\n\n    assertThat(ByteString.EMPTY, is(emptyByteString));\n\n    assertThat(byteString.substring(1, 2).toString(), is(\"ff\"));\n    assertThat(byteString.substring(0, 2).toString(), is(\"abff\"));\n    assertThat(byteString.substring(2, 2).toString(), is(\"\"));\n\n    \r\n    assertSame(byteString.concat(emptyByteString), byteString);\n    final ByteString byteString1 = new ByteString(new byte[]{(byte) 12});\n    assertThat(byteString.concat(byteString1).toString(), is(\"abff0c\"));\n\n    final byte[] bytes3 = {(byte) 0xFF};\n    final ByteString byteString3 = new ByteString(bytes3);\n\n    assertThat(byteString.indexOf(emptyByteString), is(0));\n    assertThat(byteString.indexOf(byteString1), is(-1));\n    assertThat(byteString.indexOf(byteString3), is(1));\n    assertThat(byteString3.indexOf(byteString), is(-1));\n\n    thereAndBack(bytes);\n    thereAndBack(emptyByteString.getBytes());\n    thereAndBack(new byte[]{10, 0, 29, -80});\n\n    assertThat(ByteString.of(\"ab12\", 16).toString(16), equalTo(\"ab12\"));\n    assertThat(ByteString.of(\"AB0001DdeAD3\", 16).toString(16),\n        equalTo(\"ab0001ddead3\"));\n    assertThat(ByteString.of(\"\", 16), equalTo(emptyByteString));\n    try {\n      ByteString x = ByteString.of(\"ABg0\", 16);\n      fail(\"expected error, got \" + x);\n    } catch (IllegalArgumentException e) {\n      assertThat(e.getMessage(), equalTo(\"invalid hex character: g\"));\n    }\n    try {\n      ByteString x = ByteString.of(\"ABC\", 16);\n      fail(\"expected error, got \" + x);\n    } catch (IllegalArgumentException e) {\n      assertThat(e.getMessage(), equalTo(\"hex string has odd length\"));\n    }\n\n    final byte[] bytes4 = {10, 0, 1, -80};\n    final ByteString byteString4 = new ByteString(bytes4);\n    final byte[] bytes5 = {10, 0, 1, 127};\n    final ByteString byteString5 = new ByteString(bytes5);\n    final ByteString byteString6 = new ByteString(bytes4);\n\n    assertThat(byteString4.compareTo(byteString5) > 0, is(true));\n    assertThat(byteString4.compareTo(byteString6) == 0, is(true));\n    assertThat(byteString5.compareTo(byteString4) < 0, is(true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/SqlFunctionsTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":470,"status":"NB"},{"authorDate":"2020-01-07 11:10:46","commitOrder":6,"curCode":"  private static void assertReversible(String s) {\n    final BitString bitString = BitString.createFromBitString(s);\n    assertThat(bitString.toBitString(), is(s));\n    assertThat(BitString.createFromHexString(s).toHexString(), is(s));\n\n    final BitString bitString8 =\n        BitString.createFromBytes(bitString.getAsByteArray());\n    assertThat(bitString8.getAsByteArray(), is(bitString.getAsByteArray()));\n  }\n","date":"2020-01-08 03:12:36","endLine":357,"groupId":"8714","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"assertReversible","params":"(Strings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/b8/53f673395d11a12255f3e98d50b19340f091ae.src","preCode":"  private static void assertReversible(String s) {\n    final BitString bitString = BitString.createFromBitString(s);\n    assertThat(bitString.toBitString(), is(s));\n    assertThat(BitString.createFromHexString(s).toHexString(), is(s));\n\n    final BitString bitString8 =\n        BitString.createFromBytes(bitString.getAsByteArray());\n    assertThat(bitString8.getAsByteArray(), is(bitString.getAsByteArray()));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/util/UtilTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":349,"status":"B"}],"commitId":"8555e1bc14f0e94a2f1c1e25d56c1a04341e432e","commitMessage":"@@@[CALCITE-3714] BitString.createFromBytes reverses order of the bits in each byte\n\nAlso.  implement hashCode and equals in BitString.\n","date":"2020-01-08 03:12:36","modifiedFileCount":"2","status":"M","submitter":"Julian Hyde"},{"authorTime":"2020-01-07 11:10:46","codes":[{"authorDate":"2020-04-02 10:39:10","commitOrder":7,"curCode":"  @Test void testByteString() {\n    final byte[] bytes = {(byte) 0xAB, (byte) 0xFF};\n    final ByteString byteString = new ByteString(bytes);\n    assertThat(byteString.length(), is(2));\n    assertThat(byteString.toString(), is(\"abff\"));\n    assertThat(byteString.toString(16), is(\"abff\"));\n    assertThat(byteString.toString(2), is(\"1010101111111111\"));\n\n    final ByteString emptyByteString = new ByteString(new byte[0]);\n    assertThat(emptyByteString.length(), is(0));\n    assertThat(emptyByteString.toString(), is(\"\"));\n    assertThat(emptyByteString.toString(16), is(\"\"));\n    assertThat(emptyByteString.toString(2), is(\"\"));\n\n    assertThat(ByteString.EMPTY, is(emptyByteString));\n\n    assertThat(byteString.substring(1, 2).toString(), is(\"ff\"));\n    assertThat(byteString.substring(0, 2).toString(), is(\"abff\"));\n    assertThat(byteString.substring(2, 2).toString(), is(\"\"));\n\n    \r\n    assertSame(byteString.concat(emptyByteString), byteString);\n    final ByteString byteString1 = new ByteString(new byte[]{(byte) 12});\n    assertThat(byteString.concat(byteString1).toString(), is(\"abff0c\"));\n\n    final byte[] bytes3 = {(byte) 0xFF};\n    final ByteString byteString3 = new ByteString(bytes3);\n\n    assertThat(byteString.indexOf(emptyByteString), is(0));\n    assertThat(byteString.indexOf(byteString1), is(-1));\n    assertThat(byteString.indexOf(byteString3), is(1));\n    assertThat(byteString3.indexOf(byteString), is(-1));\n\n    thereAndBack(bytes);\n    thereAndBack(emptyByteString.getBytes());\n    thereAndBack(new byte[]{10, 0, 29, -80});\n\n    assertThat(ByteString.of(\"ab12\", 16).toString(16), equalTo(\"ab12\"));\n    assertThat(ByteString.of(\"AB0001DdeAD3\", 16).toString(16),\n        equalTo(\"ab0001ddead3\"));\n    assertThat(ByteString.of(\"\", 16), equalTo(emptyByteString));\n    try {\n      ByteString x = ByteString.of(\"ABg0\", 16);\n      fail(\"expected error, got \" + x);\n    } catch (IllegalArgumentException e) {\n      assertThat(e.getMessage(), equalTo(\"invalid hex character: g\"));\n    }\n    try {\n      ByteString x = ByteString.of(\"ABC\", 16);\n      fail(\"expected error, got \" + x);\n    } catch (IllegalArgumentException e) {\n      assertThat(e.getMessage(), equalTo(\"hex string has odd length\"));\n    }\n\n    final byte[] bytes4 = {10, 0, 1, -80};\n    final ByteString byteString4 = new ByteString(bytes4);\n    final byte[] bytes5 = {10, 0, 1, 127};\n    final ByteString byteString5 = new ByteString(bytes5);\n    final ByteString byteString6 = new ByteString(bytes4);\n\n    assertThat(byteString4.compareTo(byteString5) > 0, is(true));\n    assertThat(byteString4.compareTo(byteString6) == 0, is(true));\n    assertThat(byteString5.compareTo(byteString4) < 0, is(true));\n  }\n","date":"2020-04-06 04:57:49","endLine":600,"groupId":"101390","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testByteString","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/75/779b1e03c3474d16a7ae04eb78bfc01c01ecac.src","preCode":"  @Test public void testByteString() {\n    final byte[] bytes = {(byte) 0xAB, (byte) 0xFF};\n    final ByteString byteString = new ByteString(bytes);\n    assertThat(byteString.length(), is(2));\n    assertThat(byteString.toString(), is(\"abff\"));\n    assertThat(byteString.toString(16), is(\"abff\"));\n    assertThat(byteString.toString(2), is(\"1010101111111111\"));\n\n    final ByteString emptyByteString = new ByteString(new byte[0]);\n    assertThat(emptyByteString.length(), is(0));\n    assertThat(emptyByteString.toString(), is(\"\"));\n    assertThat(emptyByteString.toString(16), is(\"\"));\n    assertThat(emptyByteString.toString(2), is(\"\"));\n\n    assertThat(ByteString.EMPTY, is(emptyByteString));\n\n    assertThat(byteString.substring(1, 2).toString(), is(\"ff\"));\n    assertThat(byteString.substring(0, 2).toString(), is(\"abff\"));\n    assertThat(byteString.substring(2, 2).toString(), is(\"\"));\n\n    \r\n    assertSame(byteString.concat(emptyByteString), byteString);\n    final ByteString byteString1 = new ByteString(new byte[]{(byte) 12});\n    assertThat(byteString.concat(byteString1).toString(), is(\"abff0c\"));\n\n    final byte[] bytes3 = {(byte) 0xFF};\n    final ByteString byteString3 = new ByteString(bytes3);\n\n    assertThat(byteString.indexOf(emptyByteString), is(0));\n    assertThat(byteString.indexOf(byteString1), is(-1));\n    assertThat(byteString.indexOf(byteString3), is(1));\n    assertThat(byteString3.indexOf(byteString), is(-1));\n\n    thereAndBack(bytes);\n    thereAndBack(emptyByteString.getBytes());\n    thereAndBack(new byte[]{10, 0, 29, -80});\n\n    assertThat(ByteString.of(\"ab12\", 16).toString(16), equalTo(\"ab12\"));\n    assertThat(ByteString.of(\"AB0001DdeAD3\", 16).toString(16),\n        equalTo(\"ab0001ddead3\"));\n    assertThat(ByteString.of(\"\", 16), equalTo(emptyByteString));\n    try {\n      ByteString x = ByteString.of(\"ABg0\", 16);\n      fail(\"expected error, got \" + x);\n    } catch (IllegalArgumentException e) {\n      assertThat(e.getMessage(), equalTo(\"invalid hex character: g\"));\n    }\n    try {\n      ByteString x = ByteString.of(\"ABC\", 16);\n      fail(\"expected error, got \" + x);\n    } catch (IllegalArgumentException e) {\n      assertThat(e.getMessage(), equalTo(\"hex string has odd length\"));\n    }\n\n    final byte[] bytes4 = {10, 0, 1, -80};\n    final ByteString byteString4 = new ByteString(bytes4);\n    final byte[] bytes5 = {10, 0, 1, 127};\n    final ByteString byteString5 = new ByteString(bytes5);\n    final ByteString byteString6 = new ByteString(bytes4);\n\n    assertThat(byteString4.compareTo(byteString5) > 0, is(true));\n    assertThat(byteString4.compareTo(byteString6) == 0, is(true));\n    assertThat(byteString5.compareTo(byteString4) < 0, is(true));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/test/SqlFunctionsTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":537,"status":"M"},{"authorDate":"2020-01-07 11:10:46","commitOrder":7,"curCode":"  private static void assertReversible(String s) {\n    final BitString bitString = BitString.createFromBitString(s);\n    assertThat(bitString.toBitString(), is(s));\n    assertThat(BitString.createFromHexString(s).toHexString(), is(s));\n\n    final BitString bitString8 =\n        BitString.createFromBytes(bitString.getAsByteArray());\n    assertThat(bitString8.getAsByteArray(), is(bitString.getAsByteArray()));\n  }\n","date":"2020-01-08 03:12:36","endLine":357,"groupId":"101390","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"assertReversible","params":"(Strings)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/b8/53f673395d11a12255f3e98d50b19340f091ae.src","preCode":"  private static void assertReversible(String s) {\n    final BitString bitString = BitString.createFromBitString(s);\n    assertThat(bitString.toBitString(), is(s));\n    assertThat(BitString.createFromHexString(s).toHexString(), is(s));\n\n    final BitString bitString8 =\n        BitString.createFromBytes(bitString.getAsByteArray());\n    assertThat(bitString8.getAsByteArray(), is(bitString.getAsByteArray()));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/util/UtilTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":349,"status":"N"}],"commitId":"9492dd4146f63ddc028010d6c4e86f6a5cb29a8d","commitMessage":"@@@[CALCITE-3892] Make junit test classes and methods non-public where possible\n\nPrior to junit 5.  classes and methods had to be public. This is no\nlonger the case.\n\nSome classes need to remain public because they are referenced from\nelsewhere.  or if they use reflection somehow. The remaining 'public'\nkeyword will be informative to maintainers.\n","date":"2020-04-06 04:57:49","modifiedFileCount":"196","status":"M","submitter":"Julian Hyde"}]
