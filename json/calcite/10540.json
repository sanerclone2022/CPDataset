[{"authorTime":"2016-02-19 03:49:20","codes":[{"authorDate":"2016-11-03 13:30:04","commitOrder":2,"curCode":"    private boolean checkConditionContainsInputRefOrLiterals(RexNode left,\n        RexNode right, List<String> fieldNames) {\n      \r\n      if (left.isA(SqlKind.CAST)) {\n        left = ((RexCall) left).getOperands().get(0);\n      }\n\n      if (right.isA(SqlKind.CAST)) {\n        right = ((RexCall) right).getOperands().get(0);\n      }\n\n      if (left.isA(SqlKind.INPUT_REF) && right.isA(SqlKind.LITERAL)) {\n        final RexInputRef left1 = (RexInputRef) left;\n        String name = fieldNames.get(left1.getIndex());\n        return name != null;\n      } else if (left.isA(SqlKind.INPUT_REF) && right.isA(SqlKind.INPUT_REF)) {\n\n        final RexInputRef left1 = (RexInputRef) left;\n        String leftName = fieldNames.get(left1.getIndex());\n\n        final RexInputRef right1 = (RexInputRef) right;\n        String rightName = fieldNames.get(right1.getIndex());\n\n        return (leftName != null) && (rightName != null);\n      }\n      if (left.isA(SqlKind.OTHER_FUNCTION) && right.isA(SqlKind.LITERAL)) {\n        if (((RexCall) left).getOperator() != SqlStdOperatorTable.ITEM) {\n          return false;\n        }\n        \r\n        return true;\n      }\n\n      return false;\n    }\n","date":"2018-02-17 02:18:02","endLine":335,"groupId":"8966","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"checkConditionContainsInputRefOrLiterals","params":"(RexNodeleft@RexNoderight@List<String>fieldNames)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/bf/ac3f08abf27e85f22111dd64e2d14e52da5041.src","preCode":"    private boolean checkConditionContainsInputRefOrLiterals(RexNode left,\n        RexNode right, List<String> fieldNames) {\n      \r\n      if (left.isA(SqlKind.CAST)) {\n        left = ((RexCall) left).getOperands().get(0);\n      }\n\n      if (right.isA(SqlKind.CAST)) {\n        right = ((RexCall) right).getOperands().get(0);\n      }\n\n      if (left.isA(SqlKind.INPUT_REF) && right.isA(SqlKind.LITERAL)) {\n        final RexInputRef left1 = (RexInputRef) left;\n        String name = fieldNames.get(left1.getIndex());\n        return name != null;\n      } else if (left.isA(SqlKind.INPUT_REF) && right.isA(SqlKind.INPUT_REF)) {\n\n        final RexInputRef left1 = (RexInputRef) left;\n        String leftName = fieldNames.get(left1.getIndex());\n\n        final RexInputRef right1 = (RexInputRef) right;\n        String rightName = fieldNames.get(right1.getIndex());\n\n        return (leftName != null) && (rightName != null);\n      }\n      if (left.isA(SqlKind.OTHER_FUNCTION) && right.isA(SqlKind.LITERAL)) {\n        if (((RexCall) left).getOperator() != SqlStdOperatorTable.ITEM) {\n          return false;\n        }\n        \r\n        return true;\n      }\n\n      return false;\n    }\n","realPath":"geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeRules.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":301,"status":"B"},{"authorDate":"2016-02-19 03:49:20","commitOrder":2,"curCode":"    private String compareFieldWithLiteral(RexNode left, RexNode right, List<String> fieldNames) {\n      \r\n      if (left.isA(SqlKind.CAST)) {\n        left = ((RexCall) left).getOperands().get(0);\n      }\n\n      if (left.isA(SqlKind.INPUT_REF) && right.isA(SqlKind.LITERAL)) {\n        final RexInputRef left1 = (RexInputRef) left;\n        String name = fieldNames.get(left1.getIndex());\n        return name;\n      } else {\n        return null;\n      }\n    }\n","date":"2016-02-19 13:16:50","endLine":213,"groupId":"8966","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"compareFieldWithLiteral","params":"(RexNodeleft@RexNoderight@List<String>fieldNames)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/72/cbcd5c5912a74b28700362c10c388dc0fe474d.src","preCode":"    private String compareFieldWithLiteral(RexNode left, RexNode right, List<String> fieldNames) {\n      \r\n      if (left.isA(SqlKind.CAST)) {\n        left = ((RexCall) left).getOperands().get(0);\n      }\n\n      if (left.isA(SqlKind.INPUT_REF) && right.isA(SqlKind.LITERAL)) {\n        final RexInputRef left1 = (RexInputRef) left;\n        String name = fieldNames.get(left1.getIndex());\n        return name;\n      } else {\n        return null;\n      }\n    }\n","realPath":"cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraRules.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":200,"status":"NB"}],"commitId":"707f4de9cafc474d0daf807b1e4c339f6eb42d7e","commitMessage":"@@@[CALCITE-2059] Apache Geode Adapter (Christian Tzolov)\n\n- Downgrade Geode from 1.4.0 to 1.3.0 - Geode server allows connections\n  only from clients with same or lower version\n- Add links to presentations and tutorials\n\nClose apache/calcite#581\n","date":"2018-02-17 02:18:02","modifiedFileCount":"0","status":"M","submitter":"Christian Tzolov"},{"authorTime":"2016-02-19 03:49:20","codes":[{"authorDate":"2019-10-01 08:53:56","commitOrder":3,"curCode":"    private boolean checkConditionContainsInputRefOrLiterals(RexNode left,\n        RexNode right, List<String> fieldNames) {\n      \r\n      if (left.isA(SqlKind.CAST)) {\n        left = ((RexCall) left).getOperands().get(0);\n      }\n\n      if (right.isA(SqlKind.CAST)) {\n        right = ((RexCall) right).getOperands().get(0);\n      }\n\n      if (left.isA(SqlKind.INPUT_REF) && right.isA(SqlKind.LITERAL)) {\n        final RexInputRef left1 = (RexInputRef) left;\n        String name = fieldNames.get(left1.getIndex());\n        return name != null;\n      } else if (left.isA(SqlKind.INPUT_REF) && right.isA(SqlKind.INPUT_REF)) {\n\n        final RexInputRef left1 = (RexInputRef) left;\n        String leftName = fieldNames.get(left1.getIndex());\n\n        final RexInputRef right1 = (RexInputRef) right;\n        String rightName = fieldNames.get(right1.getIndex());\n\n        return (leftName != null) && (rightName != null);\n      } else if (left.isA(SqlKind.ITEM) && right.isA(SqlKind.LITERAL)) {\n        return true;\n      }\n\n      return false;\n    }\n","date":"2019-10-28 14:28:09","endLine":339,"groupId":"8966","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"checkConditionContainsInputRefOrLiterals","params":"(RexNodeleft@RexNoderight@List<String>fieldNames)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/22/93dd14e41fb537aebdb0154a9d69e222a2b5f0.src","preCode":"    private boolean checkConditionContainsInputRefOrLiterals(RexNode left,\n        RexNode right, List<String> fieldNames) {\n      \r\n      if (left.isA(SqlKind.CAST)) {\n        left = ((RexCall) left).getOperands().get(0);\n      }\n\n      if (right.isA(SqlKind.CAST)) {\n        right = ((RexCall) right).getOperands().get(0);\n      }\n\n      if (left.isA(SqlKind.INPUT_REF) && right.isA(SqlKind.LITERAL)) {\n        final RexInputRef left1 = (RexInputRef) left;\n        String name = fieldNames.get(left1.getIndex());\n        return name != null;\n      } else if (left.isA(SqlKind.INPUT_REF) && right.isA(SqlKind.INPUT_REF)) {\n\n        final RexInputRef left1 = (RexInputRef) left;\n        String leftName = fieldNames.get(left1.getIndex());\n\n        final RexInputRef right1 = (RexInputRef) right;\n        String rightName = fieldNames.get(right1.getIndex());\n\n        return (leftName != null) && (rightName != null);\n      }\n      if (left.isA(SqlKind.OTHER_FUNCTION) && right.isA(SqlKind.LITERAL)) {\n        if (((RexCall) left).getOperator() != SqlStdOperatorTable.ITEM) {\n          return false;\n        }\n        \r\n        return true;\n      }\n\n      return false;\n    }\n","realPath":"geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeRules.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":310,"status":"M"},{"authorDate":"2016-02-19 03:49:20","commitOrder":3,"curCode":"    private String compareFieldWithLiteral(RexNode left, RexNode right, List<String> fieldNames) {\n      \r\n      if (left.isA(SqlKind.CAST)) {\n        left = ((RexCall) left).getOperands().get(0);\n      }\n\n      if (left.isA(SqlKind.INPUT_REF) && right.isA(SqlKind.LITERAL)) {\n        final RexInputRef left1 = (RexInputRef) left;\n        String name = fieldNames.get(left1.getIndex());\n        return name;\n      } else {\n        return null;\n      }\n    }\n","date":"2016-02-19 13:16:50","endLine":213,"groupId":"8966","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"compareFieldWithLiteral","params":"(RexNodeleft@RexNoderight@List<String>fieldNames)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/72/cbcd5c5912a74b28700362c10c388dc0fe474d.src","preCode":"    private String compareFieldWithLiteral(RexNode left, RexNode right, List<String> fieldNames) {\n      \r\n      if (left.isA(SqlKind.CAST)) {\n        left = ((RexCall) left).getOperands().get(0);\n      }\n\n      if (left.isA(SqlKind.INPUT_REF) && right.isA(SqlKind.LITERAL)) {\n        final RexInputRef left1 = (RexInputRef) left;\n        String name = fieldNames.get(left1.getIndex());\n        return name;\n      } else {\n        return null;\n      }\n    }\n","realPath":"cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraRules.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":200,"status":"N"}],"commitId":"a02155a70a1fe98c8930a0060dc043902ebbd88f","commitMessage":"@@@[CALCITE-3390] Add ITEM expression to SqlKind and include it in the policy map for Strong (Aman Sinha)\n\n* Use ITEM in selected places where OTHER_FUNCTION was used\n* Add unit test\n\nclose apache/calcite#1492\n","date":"2019-10-28 14:28:09","modifiedFileCount":"10","status":"M","submitter":"Aman Sinha"},{"authorTime":"2020-12-02 05:40:39","codes":[{"authorDate":"2020-12-02 05:40:39","commitOrder":4,"curCode":"    private static boolean checkConditionContainsInputRefOrLiterals(RexNode left,\n        RexNode right, List<String> fieldNames) {\n      \r\n      if (left.isA(SqlKind.CAST)) {\n        left = ((RexCall) left).getOperands().get(0);\n      }\n\n      if (right.isA(SqlKind.CAST)) {\n        right = ((RexCall) right).getOperands().get(0);\n      }\n\n      if (left.isA(SqlKind.INPUT_REF) && right.isA(SqlKind.LITERAL)) {\n        final RexInputRef left1 = (RexInputRef) left;\n        String name = fieldNames.get(left1.getIndex());\n        return name != null;\n      } else if (left.isA(SqlKind.INPUT_REF) && right.isA(SqlKind.INPUT_REF)) {\n\n        final RexInputRef left1 = (RexInputRef) left;\n        String leftName = fieldNames.get(left1.getIndex());\n\n        final RexInputRef right1 = (RexInputRef) right;\n        String rightName = fieldNames.get(right1.getIndex());\n\n        return (leftName != null) && (rightName != null);\n      } else if (left.isA(SqlKind.ITEM) && right.isA(SqlKind.LITERAL)) {\n        return true;\n      }\n\n      return false;\n    }\n","date":"2020-12-08 15:07:23","endLine":363,"groupId":"10540","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"checkConditionContainsInputRefOrLiterals","params":"(RexNodeleft@RexNoderight@List<String>fieldNames)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/cd/253a4606658508ef556716cb03d83040b3b7fb.src","preCode":"    private boolean checkConditionContainsInputRefOrLiterals(RexNode left,\n        RexNode right, List<String> fieldNames) {\n      \r\n      if (left.isA(SqlKind.CAST)) {\n        left = ((RexCall) left).getOperands().get(0);\n      }\n\n      if (right.isA(SqlKind.CAST)) {\n        right = ((RexCall) right).getOperands().get(0);\n      }\n\n      if (left.isA(SqlKind.INPUT_REF) && right.isA(SqlKind.LITERAL)) {\n        final RexInputRef left1 = (RexInputRef) left;\n        String name = fieldNames.get(left1.getIndex());\n        return name != null;\n      } else if (left.isA(SqlKind.INPUT_REF) && right.isA(SqlKind.INPUT_REF)) {\n\n        final RexInputRef left1 = (RexInputRef) left;\n        String leftName = fieldNames.get(left1.getIndex());\n\n        final RexInputRef right1 = (RexInputRef) right;\n        String rightName = fieldNames.get(right1.getIndex());\n\n        return (leftName != null) && (rightName != null);\n      } else if (left.isA(SqlKind.ITEM) && right.isA(SqlKind.LITERAL)) {\n        return true;\n      }\n\n      return false;\n    }\n","realPath":"geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeRules.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":334,"status":"M"},{"authorDate":"2020-12-02 05:40:39","commitOrder":4,"curCode":"    private static String compareFieldWithLiteral(RexNode left, RexNode right,\n        List<String> fieldNames) {\n      \r\n      if (left.isA(SqlKind.CAST)) {\n        left = ((RexCall) left).getOperands().get(0);\n      }\n\n      if (left.isA(SqlKind.INPUT_REF) && right.isA(SqlKind.LITERAL)) {\n        final RexInputRef left1 = (RexInputRef) left;\n        String name = fieldNames.get(left1.getIndex());\n        return name;\n      } else {\n        return null;\n      }\n    }\n","date":"2020-12-08 15:07:23","endLine":199,"groupId":"10540","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"compareFieldWithLiteral","params":"(RexNodeleft@RexNoderight@List<String>fieldNames)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/9f/5786fe59d7aefe1063425e069d6e6535071062.src","preCode":"    private String compareFieldWithLiteral(RexNode left, RexNode right, List<String> fieldNames) {\n      \r\n      if (left.isA(SqlKind.CAST)) {\n        left = ((RexCall) left).getOperands().get(0);\n      }\n\n      if (left.isA(SqlKind.INPUT_REF) && right.isA(SqlKind.LITERAL)) {\n        final RexInputRef left1 = (RexInputRef) left;\n        String name = fieldNames.get(left1.getIndex());\n        return name;\n      } else {\n        return null;\n      }\n    }\n","realPath":"cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraRules.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":185,"status":"M"}],"commitId":"404f968f6079360621896e6ee20ec12488a40bc2","commitMessage":"@@@[CALCITE-4422] Add MethodCanBeStatic check via ErrorProne\n\nprivate and final methods can be made static.  so it is clear they do not access instance fields\n","date":"2020-12-08 15:07:23","modifiedFileCount":"169","status":"M","submitter":"Vladimir Sitnikov"}]
