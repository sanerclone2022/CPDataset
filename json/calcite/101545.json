[{"authorTime":"2018-08-28 15:30:07","codes":[{"authorDate":"2018-08-28 15:30:07","commitOrder":1,"curCode":"  @Test public void testUnparseIn1() {\n    final RexNode condition =\n        builder.call(SqlStdOperatorTable.IN, builder.field(\"DEPTNO\"),\n            builder.literal(21));\n    final String sql = unparseRelTree(empScan.filter(condition).build());\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE \\\"DEPTNO\\\" IN (21)\";\n    assertThat(sql, is(expectedSql));\n  }\n","date":"2018-09-18 00:43:03","endLine":397,"groupId":"5788","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnparseIn1","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/c3/c724e1ed484270383ed1e48a855318bdcc350c.src","preCode":"  @Test public void testUnparseIn1() {\n    final RexNode condition =\n        builder.call(SqlStdOperatorTable.IN, builder.field(\"DEPTNO\"),\n            builder.literal(21));\n    final String sql = unparseRelTree(empScan.filter(condition).build());\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE \\\"DEPTNO\\\" IN (21)\";\n    assertThat(sql, is(expectedSql));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":388,"status":"B"},{"authorDate":"2018-08-28 15:30:07","commitOrder":1,"curCode":"  @Test public void testUnparseIn2() {\n    final RexNode filter =\n        builder.call(SqlStdOperatorTable.IN, builder.field(\"DEPTNO\"),\n            builder.literal(20), builder.literal(21));\n    final String sql = unparseRelTree(empScan.filter(filter).build());\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE \\\"DEPTNO\\\" IN (20, 21)\";\n    assertThat(sql, is(expectedSql));\n  }\n","date":"2018-09-18 00:43:03","endLine":408,"groupId":"5790","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnparseIn2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/c3/c724e1ed484270383ed1e48a855318bdcc350c.src","preCode":"  @Test public void testUnparseIn2() {\n    final RexNode filter =\n        builder.call(SqlStdOperatorTable.IN, builder.field(\"DEPTNO\"),\n            builder.literal(20), builder.literal(21));\n    final String sql = unparseRelTree(empScan.filter(filter).build());\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE \\\"DEPTNO\\\" IN (20, 21)\";\n    assertThat(sql, is(expectedSql));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":399,"status":"B"}],"commitId":"37a6f9f4f85d59185225e8883df74ffa8ca94c1b","commitMessage":"@@@[CALCITE-2444] Handle IN expressions when converting SqlNode to SQL (Zoltan Haindrich)\n\nPreviously RelToSqlConverter could not handle IN expressions because\nit never saw them: SqlToRelConverter had converted them to OR.  and if\nan IN expression had been created internally - say via RelBuilder -\nRelToSqlConverter would throw a ClassCastException.\n\nNow we convert IN expressions to \"IN\" SQL.  as you would expect.\n\nClose apache/calcite#805\n","date":"2018-09-18 00:43:03","modifiedFileCount":"2","status":"B","submitter":"Zoltan Haindrich"},{"authorTime":"2018-09-18 17:16:19","codes":[{"authorDate":"2018-09-18 17:16:19","commitOrder":2,"curCode":"  @Test public void testUnparseIn1() {\n    final RexNode condition =\n        builder.call(SqlStdOperatorTable.IN, builder.field(\"DEPTNO\"),\n            builder.literal(21));\n    final String sql = unparseRelTree(empScan.filter(condition).build());\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE \\\"DEPTNO\\\" IN (21)\";\n    assertThat(sql, isLinux(expectedSql));\n  }\n","date":"2018-09-20 11:11:29","endLine":397,"groupId":"5788","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnparseIn1","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e9/a37bd9146d723a10793bc463320cf78c32a6fb.src","preCode":"  @Test public void testUnparseIn1() {\n    final RexNode condition =\n        builder.call(SqlStdOperatorTable.IN, builder.field(\"DEPTNO\"),\n            builder.literal(21));\n    final String sql = unparseRelTree(empScan.filter(condition).build());\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE \\\"DEPTNO\\\" IN (21)\";\n    assertThat(sql, is(expectedSql));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":388,"status":"M"},{"authorDate":"2018-09-18 17:16:19","commitOrder":2,"curCode":"  @Test public void testUnparseIn2() {\n    final RexNode filter =\n        builder.call(SqlStdOperatorTable.IN, builder.field(\"DEPTNO\"),\n            builder.literal(20), builder.literal(21));\n    final String sql = unparseRelTree(empScan.filter(filter).build());\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE \\\"DEPTNO\\\" IN (20, 21)\";\n    assertThat(sql, isLinux(expectedSql));\n  }\n","date":"2018-09-20 11:11:29","endLine":408,"groupId":"5790","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnparseIn2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/e9/a37bd9146d723a10793bc463320cf78c32a6fb.src","preCode":"  @Test public void testUnparseIn2() {\n    final RexNode filter =\n        builder.call(SqlStdOperatorTable.IN, builder.field(\"DEPTNO\"),\n            builder.literal(20), builder.literal(21));\n    final String sql = unparseRelTree(empScan.filter(filter).build());\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE \\\"DEPTNO\\\" IN (20, 21)\";\n    assertThat(sql, is(expectedSql));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":399,"status":"M"}],"commitId":"19826da5bae2b390ea0cdbb060d2d3f1e28c07ac","commitMessage":"@@@Fix Windows tests broken by [CALCITE-2444] Handle IN expressions when converting SqlNode to SQL (Zoltan Haindrich)\n\nClose apache/calcite#837\n","date":"2018-09-20 11:11:29","modifiedFileCount":"1","status":"M","submitter":"Zoltan Haindrich"},{"authorTime":"2018-10-17 09:47:44","codes":[{"authorDate":"2018-10-17 09:47:44","commitOrder":3,"curCode":"  @Test public void testUnparseIn1() {\n    final RelBuilder builder = relBuilder().scan(\"EMP\");\n    final RexNode condition =\n        builder.call(SqlStdOperatorTable.IN, builder.field(\"DEPTNO\"),\n            builder.literal(21));\n    final RelNode root = relBuilder().scan(\"EMP\").filter(condition).build();\n    final String sql = toSql(root);\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE \\\"DEPTNO\\\" IN (21)\";\n    assertThat(sql, isLinux(expectedSql));\n  }\n","date":"2018-10-25 14:04:46","endLine":444,"groupId":"14669","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnparseIn1","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/7e/5115842871c6c3b4273e514149109fdf78a071.src","preCode":"  @Test public void testUnparseIn1() {\n    final RexNode condition =\n        builder.call(SqlStdOperatorTable.IN, builder.field(\"DEPTNO\"),\n            builder.literal(21));\n    final String sql = unparseRelTree(empScan.filter(condition).build());\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE \\\"DEPTNO\\\" IN (21)\";\n    assertThat(sql, isLinux(expectedSql));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":433,"status":"M"},{"authorDate":"2018-10-17 09:47:44","commitOrder":3,"curCode":"  @Test public void testUnparseIn2() {\n    final RelBuilder builder = relBuilder();\n    final RelNode rel = builder\n        .scan(\"EMP\")\n        .filter(\n            builder.call(SqlStdOperatorTable.IN, builder.field(\"DEPTNO\"),\n                builder.literal(20), builder.literal(21)))\n        .build();\n    final String sql = toSql(rel);\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE \\\"DEPTNO\\\" IN (20, 21)\";\n    assertThat(sql, isLinux(expectedSql));\n  }\n","date":"2018-10-25 14:04:46","endLine":459,"groupId":"11041","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnparseIn2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/7e/5115842871c6c3b4273e514149109fdf78a071.src","preCode":"  @Test public void testUnparseIn2() {\n    final RexNode filter =\n        builder.call(SqlStdOperatorTable.IN, builder.field(\"DEPTNO\"),\n            builder.literal(20), builder.literal(21));\n    final String sql = unparseRelTree(empScan.filter(filter).build());\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE \\\"DEPTNO\\\" IN (20, 21)\";\n    assertThat(sql, isLinux(expectedSql));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":446,"status":"M"}],"commitId":"784372debb2b51c3041c0d5b420a6f93a2457a16","commitMessage":"@@@[CALCITE-2628] JDBC adapter throws NullPointerException while generating GROUP BY query for MySQL\n\nAlso.  refactor RelToSqlConverterTest a little.\n","date":"2018-10-25 14:04:46","modifiedFileCount":"2","status":"M","submitter":"Julian Hyde"},{"authorTime":"2020-02-21 10:29:14","codes":[{"authorDate":"2020-02-21 10:29:14","commitOrder":4,"curCode":"  @Test public void testUnparseIn1() {\n    final Function<RelBuilder, RelNode> relFn = b ->\n        b.scan(\"EMP\")\n            .filter(\n                b.call(SqlStdOperatorTable.IN, b.field(\"DEPTNO\"),\n                    b.literal(21)))\n            .build();\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE \\\"DEPTNO\\\" IN (21)\";\n    relFn(relFn).ok(expectedSql);\n  }\n","date":"2020-02-22 01:55:43","endLine":1192,"groupId":"5081","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnparseIn1","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/d2/8abea1fd2182ece1feb8d73e94b8b494b4d043.src","preCode":"  @Test public void testUnparseIn1() {\n    final RelBuilder builder = relBuilder().scan(\"EMP\");\n    final RexNode condition =\n        builder.call(SqlStdOperatorTable.IN, builder.field(\"DEPTNO\"),\n            builder.literal(21));\n    final RelNode root = relBuilder().scan(\"EMP\").filter(condition).build();\n    final String sql = toSql(root);\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE \\\"DEPTNO\\\" IN (21)\";\n    assertThat(sql, isLinux(expectedSql));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1181,"status":"M"},{"authorDate":"2020-02-21 10:29:14","commitOrder":4,"curCode":"  @Test public void testUnparseIn2() {\n    final Function<RelBuilder, RelNode> relFn = b -> b\n        .scan(\"EMP\")\n        .filter(\n            b.call(SqlStdOperatorTable.IN, b.field(\"DEPTNO\"),\n                b.literal(20), b.literal(21)))\n        .build();\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE \\\"DEPTNO\\\" IN (20, 21)\";\n    relFn(relFn).ok(expectedSql);\n  }\n","date":"2020-02-22 01:55:43","endLine":1205,"groupId":"12200","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnparseIn2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/d2/8abea1fd2182ece1feb8d73e94b8b494b4d043.src","preCode":"  @Test public void testUnparseIn2() {\n    final RelBuilder builder = relBuilder();\n    final RelNode rel = builder\n        .scan(\"EMP\")\n        .filter(\n            builder.call(SqlStdOperatorTable.IN, builder.field(\"DEPTNO\"),\n                builder.literal(20), builder.literal(21)))\n        .build();\n    final String sql = toSql(rel);\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE \\\"DEPTNO\\\" IN (20, 21)\";\n    assertThat(sql, isLinux(expectedSql));\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1194,"status":"M"}],"commitId":"6d974f1b23bdca566d01cb7cbb1ec46d7ef5e84c","commitMessage":"@@@Refactor RelToSqlConverterTest\n\nMake test cases that use RelBuilder fluent.  like test cases that use SQL.\n","date":"2020-02-22 01:55:43","modifiedFileCount":"2","status":"M","submitter":"Julian Hyde"},{"authorTime":"2020-04-02 10:39:10","codes":[{"authorDate":"2020-04-02 10:39:10","commitOrder":5,"curCode":"  @Test void testUnparseIn1() {\n    final Function<RelBuilder, RelNode> relFn = b ->\n        b.scan(\"EMP\")\n            .filter(\n                b.call(SqlStdOperatorTable.IN, b.field(\"DEPTNO\"),\n                    b.literal(21)))\n            .build();\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE \\\"DEPTNO\\\" IN (21)\";\n    relFn(relFn).ok(expectedSql);\n  }\n","date":"2020-04-06 04:57:49","endLine":1355,"groupId":"5081","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnparseIn1","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/a7/568223fb7dbbd6fb8b19514d3893973975f662.src","preCode":"  @Test public void testUnparseIn1() {\n    final Function<RelBuilder, RelNode> relFn = b ->\n        b.scan(\"EMP\")\n            .filter(\n                b.call(SqlStdOperatorTable.IN, b.field(\"DEPTNO\"),\n                    b.literal(21)))\n            .build();\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE \\\"DEPTNO\\\" IN (21)\";\n    relFn(relFn).ok(expectedSql);\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1344,"status":"M"},{"authorDate":"2020-04-02 10:39:10","commitOrder":5,"curCode":"  @Test void testUnparseIn2() {\n    final Function<RelBuilder, RelNode> relFn = b -> b\n        .scan(\"EMP\")\n        .filter(\n            b.call(SqlStdOperatorTable.IN, b.field(\"DEPTNO\"),\n                b.literal(20), b.literal(21)))\n        .build();\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE \\\"DEPTNO\\\" IN (20, 21)\";\n    relFn(relFn).ok(expectedSql);\n  }\n","date":"2020-04-06 04:57:49","endLine":1368,"groupId":"12200","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnparseIn2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/a7/568223fb7dbbd6fb8b19514d3893973975f662.src","preCode":"  @Test public void testUnparseIn2() {\n    final Function<RelBuilder, RelNode> relFn = b -> b\n        .scan(\"EMP\")\n        .filter(\n            b.call(SqlStdOperatorTable.IN, b.field(\"DEPTNO\"),\n                b.literal(20), b.literal(21)))\n        .build();\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE \\\"DEPTNO\\\" IN (20, 21)\";\n    relFn(relFn).ok(expectedSql);\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1357,"status":"M"}],"commitId":"9492dd4146f63ddc028010d6c4e86f6a5cb29a8d","commitMessage":"@@@[CALCITE-3892] Make junit test classes and methods non-public where possible\n\nPrior to junit 5.  classes and methods had to be public. This is no\nlonger the case.\n\nSome classes need to remain public because they are referenced from\nelsewhere.  or if they use reflection somehow. The remaining 'public'\nkeyword will be informative to maintainers.\n","date":"2020-04-06 04:57:49","modifiedFileCount":"196","status":"M","submitter":"Julian Hyde"},{"authorTime":"2020-08-13 15:59:15","codes":[{"authorDate":"2020-08-13 15:59:15","commitOrder":6,"curCode":"  @Test void testUnparseIn1() {\n    final Function<RelBuilder, RelNode> relFn = b ->\n        b.scan(\"EMP\")\n            .filter(b.in(b.field(\"DEPTNO\"), b.literal(21)))\n            .build();\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE \\\"DEPTNO\\\" = 21\";\n    relFn(relFn).ok(expectedSql);\n  }\n","date":"2020-09-05 00:58:49","endLine":1455,"groupId":"101545","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnparseIn1","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/71/df0dec66d409be480715d898d5ea0bcd1a8bc9.src","preCode":"  @Test void testUnparseIn1() {\n    final Function<RelBuilder, RelNode> relFn = b ->\n        b.scan(\"EMP\")\n            .filter(\n                b.call(SqlStdOperatorTable.IN, b.field(\"DEPTNO\"),\n                    b.literal(21)))\n            .build();\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE \\\"DEPTNO\\\" IN (21)\";\n    relFn(relFn).ok(expectedSql);\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1446,"status":"M"},{"authorDate":"2020-08-13 15:59:15","commitOrder":6,"curCode":"  @Test void testUnparseIn2() {\n    final Function<RelBuilder, RelNode> relFn = b -> b\n        .scan(\"EMP\")\n        .filter(b.in(b.field(\"DEPTNO\"), b.literal(20), b.literal(21)))\n        .build();\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE \\\"DEPTNO\\\" IN (20, 21)\";\n    relFn(relFn).ok(expectedSql);\n  }\n","date":"2020-09-05 00:58:49","endLine":1466,"groupId":"101545","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testUnparseIn2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/71/df0dec66d409be480715d898d5ea0bcd1a8bc9.src","preCode":"  @Test void testUnparseIn2() {\n    final Function<RelBuilder, RelNode> relFn = b -> b\n        .scan(\"EMP\")\n        .filter(\n            b.call(SqlStdOperatorTable.IN, b.field(\"DEPTNO\"),\n                b.literal(20), b.literal(21)))\n        .build();\n    final String expectedSql = \"SELECT *\\n\"\n        + \"FROM \\\"scott\\\".\\\"EMP\\\"\\n\"\n        + \"WHERE \\\"DEPTNO\\\" IN (20, 21)\";\n    relFn(relFn).ok(expectedSql);\n  }\n","realPath":"core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":1457,"status":"M"}],"commitId":"850f0f4a04fc2399b8fd1c1fed532cd8e1e39514","commitMessage":"@@@[CALCITE-4173] Add internal SEARCH operator and Sarg literal that represents a set of values or ranges\n\nObsolete use of IN in RexCall; in Druid.  replace some uses\nwith DRUID_IN operator.\n\nCreate Sarg instances during RexSimplify of AND.  OR. Also\nduring simplify.  strengthen Sarg.containsNull from true to\nfalse if predicates prove that NULL values are impossible.\n\nIn JDBC adapter we handle SEARCH natively.  but in Geode. \nMongoDB and Spark adapters.  expand SEARCH before translating\nto target query language. Later.  it may be better to handle\nSEARCH explicitly. For instance.  it will be easier to recognize\nexpressions that can be translated to Geode's 'IN SET'\nconstruct.\n\nClose apache/calcite#2124\n","date":"2020-09-05 00:58:49","modifiedFileCount":"44","status":"M","submitter":"Julian Hyde"}]
