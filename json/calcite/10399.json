[{"authorTime":"2018-01-11 02:10:44","codes":[{"authorDate":"2019-07-26 18:41:29","commitOrder":2,"curCode":"  public void testDistinctCountOnMetricRenamed() {\n    final String sql = \"select \\\"B\\\", count(distinct \\\"A\\\") from \"\n        + \"(select \\\"unit_sales\\\" as \\\"A\\\", \\\"store_state\\\" as \\\"B\\\" from \\\"foodmart\\\") \"\n        + \"group by \\\"B\\\"\";\n    final String expectedSubExplainNoApprox = \"PLAN=EnumerableInterpreter\\n\"\n        + \"  BindableAggregate(group=[{0}], EXPR$1=[COUNT($1)])\\n\"\n        + \"    DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], projects=[[$63, $89]], groups=[{0, 1}], aggs=[[]])\";\n    final String expectedPlanWithApprox = \"PLAN=EnumerableInterpreter\\n\"\n        + \"  DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], groups=[{63}], aggs=[[COUNT(DISTINCT $89)]])\";\n\n    testCountWithApproxDistinct(true, sql, expectedPlanWithApprox, \"'queryType':'groupBy'\");\n    testCountWithApproxDistinct(false, sql, expectedSubExplainNoApprox, \"'queryType':'groupBy'\");\n  }\n","date":"2019-07-26 18:41:29","endLine":2646,"groupId":"13139","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testDistinctCountOnMetricRenamed","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/02/b3ad0d5008a0228c8f3ee8b0550059f0beed2c.src","preCode":"  public void testDistinctCountOnMetricRenamed() {\n    final String sql = \"select \\\"B\\\", count(distinct \\\"A\\\") from \"\n        + \"(select \\\"unit_sales\\\" as \\\"A\\\", \\\"store_state\\\" as \\\"B\\\" from \\\"foodmart\\\") \"\n        + \"group by \\\"B\\\"\";\n    final String expectedSubExplainNoApprox = \"PLAN=EnumerableInterpreter\\n\"\n        + \"  BindableAggregate(group=[{0}], EXPR$1=[COUNT($1)])\\n\"\n        + \"    DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], projects=[[$63, $89]], groups=[{0, 1}], aggs=[[]])\";\n    final String expectedPlanWithApprox = \"PLAN=EnumerableInterpreter\\n\"\n        + \"  DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], groups=[{63}], aggs=[[COUNT(DISTINCT $89)]])\";\n\n    testCountWithApproxDistinct(true, sql, expectedPlanWithApprox, \"'queryType':'groupBy'\");\n    testCountWithApproxDistinct(false, sql, expectedSubExplainNoApprox, \"'queryType':'groupBy'\");\n  }\n","realPath":"druid/src/test/java/org/apache/calcite/test/DruidAdapter2IT.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":2632,"status":"B"},{"authorDate":"2018-01-11 02:10:44","commitOrder":2,"curCode":"  public void testDistinctCountOnMetricRenamed() {\n    final String sql = \"select \\\"B\\\", count(distinct \\\"A\\\") from \"\n        + \"(select \\\"unit_sales\\\" as \\\"A\\\", \\\"store_state\\\" as \\\"B\\\" from \\\"foodmart\\\") \"\n        + \"group by \\\"B\\\"\";\n    final String expectedSubExplainNoApprox = \"PLAN=EnumerableInterpreter\\n\"\n        + \"  BindableAggregate(group=[{0}], EXPR$1=[COUNT($1)])\\n\"\n        + \"    DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], projects=[[$63, $89]], groups=[{0, 1}], aggs=[[]])\";\n    final String expectedPlanWithApprox = \"PLAN=EnumerableInterpreter\\n\"\n        + \"  DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], groups=[{63}], aggs=[[COUNT(DISTINCT $89)]])\";\n\n    testCountWithApproxDistinct(true, sql, expectedPlanWithApprox, \"'queryType':'groupBy'\");\n    testCountWithApproxDistinct(false, sql, expectedSubExplainNoApprox, \"'queryType':'groupBy'\");\n  }\n","date":"2018-02-17 11:35:34","endLine":2983,"groupId":"13139","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testDistinctCountOnMetricRenamed","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/7c/7ba4abd553a9311f4f4698ebea7c586bb556a8.src","preCode":"  public void testDistinctCountOnMetricRenamed() {\n    final String sql = \"select \\\"B\\\", count(distinct \\\"A\\\") from \"\n        + \"(select \\\"unit_sales\\\" as \\\"A\\\", \\\"store_state\\\" as \\\"B\\\" from \\\"foodmart\\\") \"\n        + \"group by \\\"B\\\"\";\n    final String expectedSubExplainNoApprox = \"PLAN=EnumerableInterpreter\\n\"\n        + \"  BindableAggregate(group=[{0}], EXPR$1=[COUNT($1)])\\n\"\n        + \"    DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], projects=[[$63, $89]], groups=[{0, 1}], aggs=[[]])\";\n    final String expectedPlanWithApprox = \"PLAN=EnumerableInterpreter\\n\"\n        + \"  DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], groups=[{63}], aggs=[[COUNT(DISTINCT $89)]])\";\n\n    testCountWithApproxDistinct(true, sql, expectedPlanWithApprox, \"'queryType':'groupBy'\");\n    testCountWithApproxDistinct(false, sql, expectedSubExplainNoApprox, \"'queryType':'groupBy'\");\n  }\n","realPath":"druid/src/test/java/org/apache/calcite/test/DruidAdapterIT.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":2969,"status":"NB"}],"commitId":"689a5bbb14614d3f8eef4a4f7e832c6c02029b3c","commitMessage":"@@@Update stale tests in DruidAdapter\n\n1. Adapt plans based on the improvements in the simplifier and elsewhere.\n2. Rename DruidAdapterIT2 to DruidAdapterIT to be run in integration tests.\n","date":"2019-07-26 18:41:29","modifiedFileCount":"1","status":"M","submitter":"Stamatis Zampetakis"},{"authorTime":"2019-12-04 02:44:13","codes":[{"authorDate":"2019-12-04 02:44:13","commitOrder":3,"curCode":"  @Test public void testDistinctCountOnMetricRenamed() {\n    final String sql = \"select \\\"B\\\", count(distinct \\\"A\\\") from \"\n        + \"(select \\\"unit_sales\\\" as \\\"A\\\", \\\"store_state\\\" as \\\"B\\\" from \\\"foodmart\\\") \"\n        + \"group by \\\"B\\\"\";\n    final String expectedSubExplainNoApprox = \"PLAN=EnumerableInterpreter\\n\"\n        + \"  BindableAggregate(group=[{0}], EXPR$1=[COUNT($1)])\\n\"\n        + \"    DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], projects=[[$63, $89]], groups=[{0, 1}], aggs=[[]])\";\n    final String expectedPlanWithApprox = \"PLAN=EnumerableInterpreter\\n\"\n        + \"  DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], groups=[{63}], aggs=[[COUNT(DISTINCT $89)]])\";\n\n    testCountWithApproxDistinct(true, sql, expectedPlanWithApprox, \"'queryType':'groupBy'\");\n    testCountWithApproxDistinct(false, sql, expectedSubExplainNoApprox, \"'queryType':'groupBy'\");\n  }\n","date":"2019-12-14 23:57:27","endLine":2634,"groupId":"13139","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testDistinctCountOnMetricRenamed","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/c9/4f09b105f883eabd942cd69cba5fa11f4769a1.src","preCode":"  public void testDistinctCountOnMetricRenamed() {\n    final String sql = \"select \\\"B\\\", count(distinct \\\"A\\\") from \"\n        + \"(select \\\"unit_sales\\\" as \\\"A\\\", \\\"store_state\\\" as \\\"B\\\" from \\\"foodmart\\\") \"\n        + \"group by \\\"B\\\"\";\n    final String expectedSubExplainNoApprox = \"PLAN=EnumerableInterpreter\\n\"\n        + \"  BindableAggregate(group=[{0}], EXPR$1=[COUNT($1)])\\n\"\n        + \"    DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], projects=[[$63, $89]], groups=[{0, 1}], aggs=[[]])\";\n    final String expectedPlanWithApprox = \"PLAN=EnumerableInterpreter\\n\"\n        + \"  DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], groups=[{63}], aggs=[[COUNT(DISTINCT $89)]])\";\n\n    testCountWithApproxDistinct(true, sql, expectedPlanWithApprox, \"'queryType':'groupBy'\");\n    testCountWithApproxDistinct(false, sql, expectedSubExplainNoApprox, \"'queryType':'groupBy'\");\n  }\n","realPath":"druid/src/test/java/org/apache/calcite/test/DruidAdapter2IT.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":2620,"status":"M"},{"authorDate":"2019-12-04 02:44:13","commitOrder":3,"curCode":"  @Test public void testDistinctCountOnMetricRenamed() {\n    final String sql = \"select \\\"B\\\", count(distinct \\\"A\\\") from \"\n        + \"(select \\\"unit_sales\\\" as \\\"A\\\", \\\"store_state\\\" as \\\"B\\\" from \\\"foodmart\\\") \"\n        + \"group by \\\"B\\\"\";\n    final String expectedSubExplainNoApprox = \"PLAN=EnumerableInterpreter\\n\"\n        + \"  BindableAggregate(group=[{0}], EXPR$1=[COUNT($1)])\\n\"\n        + \"    DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], projects=[[$63, $89]], groups=[{0, 1}], aggs=[[]])\";\n    final String expectedPlanWithApprox = \"PLAN=EnumerableInterpreter\\n\"\n        + \"  DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], groups=[{63}], aggs=[[COUNT(DISTINCT $89)]])\";\n\n    testCountWithApproxDistinct(true, sql, expectedPlanWithApprox, \"'queryType':'groupBy'\");\n    testCountWithApproxDistinct(false, sql, expectedSubExplainNoApprox, \"'queryType':'groupBy'\");\n  }\n","date":"2019-12-14 23:57:27","endLine":2952,"groupId":"13139","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testDistinctCountOnMetricRenamed","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/16/2df38cd6813dcd057a94a189dd6bc463668579.src","preCode":"  public void testDistinctCountOnMetricRenamed() {\n    final String sql = \"select \\\"B\\\", count(distinct \\\"A\\\") from \"\n        + \"(select \\\"unit_sales\\\" as \\\"A\\\", \\\"store_state\\\" as \\\"B\\\" from \\\"foodmart\\\") \"\n        + \"group by \\\"B\\\"\";\n    final String expectedSubExplainNoApprox = \"PLAN=EnumerableInterpreter\\n\"\n        + \"  BindableAggregate(group=[{0}], EXPR$1=[COUNT($1)])\\n\"\n        + \"    DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], projects=[[$63, $89]], groups=[{0, 1}], aggs=[[]])\";\n    final String expectedPlanWithApprox = \"PLAN=EnumerableInterpreter\\n\"\n        + \"  DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], groups=[{63}], aggs=[[COUNT(DISTINCT $89)]])\";\n\n    testCountWithApproxDistinct(true, sql, expectedPlanWithApprox, \"'queryType':'groupBy'\");\n    testCountWithApproxDistinct(false, sql, expectedSubExplainNoApprox, \"'queryType':'groupBy'\");\n  }\n","realPath":"druid/src/test/java/org/apache/calcite/test/DruidAdapterIT.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":2938,"status":"M"}],"commitId":"571731b80a58eb095ebac7123285c375e7afff90","commitMessage":"@@@[CALCITE-3559] Update formatting: remove \"// End\" trailers.  move @Test from their own lines\n","date":"2019-12-14 23:57:27","modifiedFileCount":"1961","status":"M","submitter":"Vladimir Sitnikov"},{"authorTime":"2020-04-02 10:39:10","codes":[{"authorDate":"2020-04-02 10:39:10","commitOrder":4,"curCode":"  @Test void testDistinctCountOnMetricRenamed() {\n    final String sql = \"select \\\"B\\\", count(distinct \\\"A\\\") from \"\n        + \"(select \\\"unit_sales\\\" as \\\"A\\\", \\\"store_state\\\" as \\\"B\\\" from \\\"foodmart\\\") \"\n        + \"group by \\\"B\\\"\";\n    final String expectedSubExplainNoApprox = \"PLAN=EnumerableInterpreter\\n\"\n        + \"  BindableAggregate(group=[{0}], EXPR$1=[COUNT($1)])\\n\"\n        + \"    DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], projects=[[$63, $89]], groups=[{0, 1}], aggs=[[]])\";\n    final String expectedPlanWithApprox = \"PLAN=EnumerableInterpreter\\n\"\n        + \"  DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], groups=[{63}], aggs=[[COUNT(DISTINCT $89)]])\";\n\n    testCountWithApproxDistinct(true, sql, expectedPlanWithApprox, \"'queryType':'groupBy'\");\n    testCountWithApproxDistinct(false, sql, expectedSubExplainNoApprox, \"'queryType':'groupBy'\");\n  }\n","date":"2020-04-06 04:57:49","endLine":2634,"groupId":"13139","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testDistinctCountOnMetricRenamed","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/c1/fa4337f27a4c651cca27b069aed6b60ee0e782.src","preCode":"  @Test public void testDistinctCountOnMetricRenamed() {\n    final String sql = \"select \\\"B\\\", count(distinct \\\"A\\\") from \"\n        + \"(select \\\"unit_sales\\\" as \\\"A\\\", \\\"store_state\\\" as \\\"B\\\" from \\\"foodmart\\\") \"\n        + \"group by \\\"B\\\"\";\n    final String expectedSubExplainNoApprox = \"PLAN=EnumerableInterpreter\\n\"\n        + \"  BindableAggregate(group=[{0}], EXPR$1=[COUNT($1)])\\n\"\n        + \"    DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], projects=[[$63, $89]], groups=[{0, 1}], aggs=[[]])\";\n    final String expectedPlanWithApprox = \"PLAN=EnumerableInterpreter\\n\"\n        + \"  DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], groups=[{63}], aggs=[[COUNT(DISTINCT $89)]])\";\n\n    testCountWithApproxDistinct(true, sql, expectedPlanWithApprox, \"'queryType':'groupBy'\");\n    testCountWithApproxDistinct(false, sql, expectedSubExplainNoApprox, \"'queryType':'groupBy'\");\n  }\n","realPath":"druid/src/test/java/org/apache/calcite/test/DruidAdapter2IT.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":2620,"status":"M"},{"authorDate":"2020-04-02 10:39:10","commitOrder":4,"curCode":"  @Test void testDistinctCountOnMetricRenamed() {\n    final String sql = \"select \\\"B\\\", count(distinct \\\"A\\\") from \"\n        + \"(select \\\"unit_sales\\\" as \\\"A\\\", \\\"store_state\\\" as \\\"B\\\" from \\\"foodmart\\\") \"\n        + \"group by \\\"B\\\"\";\n    final String expectedSubExplainNoApprox = \"PLAN=EnumerableInterpreter\\n\"\n        + \"  BindableAggregate(group=[{0}], EXPR$1=[COUNT($1)])\\n\"\n        + \"    DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], projects=[[$63, $89]], groups=[{0, 1}], aggs=[[]])\";\n    final String expectedPlanWithApprox = \"PLAN=EnumerableInterpreter\\n\"\n        + \"  DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], groups=[{63}], aggs=[[COUNT(DISTINCT $89)]])\";\n\n    testCountWithApproxDistinct(true, sql, expectedPlanWithApprox, \"'queryType':'groupBy'\");\n    testCountWithApproxDistinct(false, sql, expectedSubExplainNoApprox, \"'queryType':'groupBy'\");\n  }\n","date":"2020-04-06 04:57:49","endLine":2952,"groupId":"13139","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testDistinctCountOnMetricRenamed","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/7a/4c255a8931d21fca61278e3f99936a6e0b3678.src","preCode":"  @Test public void testDistinctCountOnMetricRenamed() {\n    final String sql = \"select \\\"B\\\", count(distinct \\\"A\\\") from \"\n        + \"(select \\\"unit_sales\\\" as \\\"A\\\", \\\"store_state\\\" as \\\"B\\\" from \\\"foodmart\\\") \"\n        + \"group by \\\"B\\\"\";\n    final String expectedSubExplainNoApprox = \"PLAN=EnumerableInterpreter\\n\"\n        + \"  BindableAggregate(group=[{0}], EXPR$1=[COUNT($1)])\\n\"\n        + \"    DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], projects=[[$63, $89]], groups=[{0, 1}], aggs=[[]])\";\n    final String expectedPlanWithApprox = \"PLAN=EnumerableInterpreter\\n\"\n        + \"  DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], groups=[{63}], aggs=[[COUNT(DISTINCT $89)]])\";\n\n    testCountWithApproxDistinct(true, sql, expectedPlanWithApprox, \"'queryType':'groupBy'\");\n    testCountWithApproxDistinct(false, sql, expectedSubExplainNoApprox, \"'queryType':'groupBy'\");\n  }\n","realPath":"druid/src/test/java/org/apache/calcite/test/DruidAdapterIT.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":2938,"status":"M"}],"commitId":"9492dd4146f63ddc028010d6c4e86f6a5cb29a8d","commitMessage":"@@@[CALCITE-3892] Make junit test classes and methods non-public where possible\n\nPrior to junit 5.  classes and methods had to be public. This is no\nlonger the case.\n\nSome classes need to remain public because they are referenced from\nelsewhere.  or if they use reflection somehow. The remaining 'public'\nkeyword will be informative to maintainers.\n","date":"2020-04-06 04:57:49","modifiedFileCount":"196","status":"M","submitter":"Julian Hyde"},{"authorTime":"2020-09-02 18:54:17","codes":[{"authorDate":"2020-09-02 18:54:17","commitOrder":5,"curCode":"  @Test void testDistinctCountOnMetricRenamed() {\n    final String sql = \"select \\\"B\\\", count(distinct \\\"A\\\") from \"\n        + \"(select \\\"unit_sales\\\" as \\\"A\\\", \\\"store_state\\\" as \\\"B\\\" from \\\"foodmart\\\") \"\n        + \"group by \\\"B\\\"\";\n    final String expectedSubExplainNoApprox = \"PLAN=\"\n        + \"EnumerableAggregate(group=[{0}], EXPR$1=[COUNT($1)])\\n\"\n        + \"  EnumerableInterpreter\\n\"\n        + \"    DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/2992-01-10T00:00:00.000Z]], projects=[[$63, $89]], groups=[{0, 1}], aggs=[[]])\";\n    final String expectedPlanWithApprox = \"PLAN=\"\n        + \"EnumerableInterpreter\\n\"\n        + \"  DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/2992-01-10T00:00:00.000Z]], projects=[[$63, $89]], groups=[{0}], aggs=[[COUNT(DISTINCT $1)]])\";\n\n    testCountWithApproxDistinct(true, sql, expectedPlanWithApprox, \"'queryType':'groupBy'\");\n    testCountWithApproxDistinct(false, sql, expectedSubExplainNoApprox, \"'queryType':'groupBy'\");\n  }\n","date":"2020-09-10 06:10:51","endLine":2582,"groupId":"10399","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testDistinctCountOnMetricRenamed","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/a2/bcf78ffe3c12458c3d3bcde9517f8c0e887f0a.src","preCode":"  @Test void testDistinctCountOnMetricRenamed() {\n    final String sql = \"select \\\"B\\\", count(distinct \\\"A\\\") from \"\n        + \"(select \\\"unit_sales\\\" as \\\"A\\\", \\\"store_state\\\" as \\\"B\\\" from \\\"foodmart\\\") \"\n        + \"group by \\\"B\\\"\";\n    final String expectedSubExplainNoApprox = \"PLAN=EnumerableInterpreter\\n\"\n        + \"  BindableAggregate(group=[{0}], EXPR$1=[COUNT($1)])\\n\"\n        + \"    DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], projects=[[$63, $89]], groups=[{0, 1}], aggs=[[]])\";\n    final String expectedPlanWithApprox = \"PLAN=EnumerableInterpreter\\n\"\n        + \"  DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], groups=[{63}], aggs=[[COUNT(DISTINCT $89)]])\";\n\n    testCountWithApproxDistinct(true, sql, expectedPlanWithApprox, \"'queryType':'groupBy'\");\n    testCountWithApproxDistinct(false, sql, expectedSubExplainNoApprox, \"'queryType':'groupBy'\");\n  }\n","realPath":"druid/src/test/java/org/apache/calcite/test/DruidAdapter2IT.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":2568,"status":"M"},{"authorDate":"2020-09-02 18:54:17","commitOrder":5,"curCode":"  @Test void testDistinctCountOnMetricRenamed() {\n    final String sql = \"select \\\"B\\\", count(distinct \\\"A\\\") from \"\n        + \"(select \\\"unit_sales\\\" as \\\"A\\\", \\\"store_state\\\" as \\\"B\\\" from \\\"foodmart\\\") \"\n        + \"group by \\\"B\\\"\";\n    final String expectedSubExplainNoApprox = \"PLAN=\"\n        + \"EnumerableAggregate(group=[{0}], EXPR$1=[COUNT($1)])\\n\"\n        + \"  EnumerableInterpreter\\n\"\n        + \"    DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], projects=[[$63, $89]], groups=[{0, 1}], aggs=[[]])\";\n    final String expectedPlanWithApprox = \"PLAN=\"\n        + \"EnumerableInterpreter\\n\"\n        + \"  DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00\"\n        + \".000Z/2992-01-10T00:00:00.000Z]], projects=[[$63, $89]], groups=[{0}], aggs=[[COUNT\"\n        + \"(DISTINCT $1)]])\\n\";\n\n    testCountWithApproxDistinct(true, sql, expectedPlanWithApprox, \"'queryType':'groupBy'\");\n    testCountWithApproxDistinct(false, sql, expectedSubExplainNoApprox, \"'queryType':'groupBy'\");\n  }\n","date":"2020-09-10 06:10:51","endLine":2925,"groupId":"10399","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testDistinctCountOnMetricRenamed","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-calcite-10-0.7/blobInfo/CC_OUT/blobs/be/2b8fb776ec0bc8d35170d2ca1ca4fbb10a557b.src","preCode":"  @Test void testDistinctCountOnMetricRenamed() {\n    final String sql = \"select \\\"B\\\", count(distinct \\\"A\\\") from \"\n        + \"(select \\\"unit_sales\\\" as \\\"A\\\", \\\"store_state\\\" as \\\"B\\\" from \\\"foodmart\\\") \"\n        + \"group by \\\"B\\\"\";\n    final String expectedSubExplainNoApprox = \"PLAN=EnumerableInterpreter\\n\"\n        + \"  BindableAggregate(group=[{0}], EXPR$1=[COUNT($1)])\\n\"\n        + \"    DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], projects=[[$63, $89]], groups=[{0, 1}], aggs=[[]])\";\n    final String expectedPlanWithApprox = \"PLAN=EnumerableInterpreter\\n\"\n        + \"  DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/\"\n        + \"2992-01-10T00:00:00.000Z]], groups=[{63}], aggs=[[COUNT(DISTINCT $89)]])\";\n\n    testCountWithApproxDistinct(true, sql, expectedPlanWithApprox, \"'queryType':'groupBy'\");\n    testCountWithApproxDistinct(false, sql, expectedSubExplainNoApprox, \"'queryType':'groupBy'\");\n  }\n","realPath":"druid/src/test/java/org/apache/calcite/test/DruidAdapterIT.java","repoName":"calcite","snippetEndLine":0,"snippetStartLine":0,"startLine":2908,"status":"M"}],"commitId":"fb8961528ff559e109612465cdef3e62eee852e2","commitMessage":"@@@[CALCITE-4221] Update stale integration tests in Druid adapter\n\nUpdate doc of DruidAdapterIT and DruidAdapter2IT to reflect the\nnew dockerized Druid setup.\n\nThe changes in the following tests are due to CALCITE-4202:\n\n* testSelectDistinctWiki\n* testSelectDistinctWikiNoColumns\n* testSelectDistinctWikiNoTables\n* testSelectDistinct\n* testFilterUnionPlan\n* testDistinctCount\n* testPushComplexFilter\n* testCountOnMetric\n* testCountOnMetricRenamed\n* testPushEqualsCastDimension\n* testPushNotEqualsCastDimension\n* testComplexExpressionsIsNull\n\nThe changes in the following tests are due to CALCITE-4212:\n\n* testSelectTimestampColumnNoTables1\n* testUnionPlan\n* testProject\n* testTimeExtractThatCannotBePushed\n* testSubStringExpressionFilter\n\nThe changes in the following tests are due to both CALCITE-4212 and\nCALCITE-4202:\n\n* testUnionPlan\n* testDistinctCountOnMetric\n* testDistinctCountOnMetricRenamed\n* testDistinctCountWhenApproxResultsNotAccepted\n* testFilterClauseWithMetricRefAndAggregates\n\nThe rest of the changes are normal improvements of the optimizer.\n\nProblematic tests are skipped with the appropriate JIRA references\ndescribing the problem.\n","date":"2020-09-10 06:10:51","modifiedFileCount":"3","status":"M","submitter":"Stamatis Zampetakis"}]
