[{"authorTime":"2021-02-24 17:28:33","codes":[{"authorDate":"2021-02-24 17:28:33","commitOrder":2,"curCode":"    private AsyncCallFuture<VolumeApiResult> copyManagedVolume(VolumeInfo srcVolume, DataStore destStore) {\n        AsyncCallFuture<VolumeApiResult> future = new AsyncCallFuture<VolumeApiResult>();\n        VolumeApiResult res = new VolumeApiResult(srcVolume);\n        try {\n            if (!snapshotMgr.canOperateOnVolume(srcVolume)) {\n                s_logger.debug(\"There are snapshots creating for this volume, can not move this volume\");\n                res.setResult(\"There are snapshots creating for this volume, can not move this volume\");\n                future.complete(res);\n                return future;\n            }\n\n            if (snapshotMgr.backedUpSnapshotsExistsForVolume(srcVolume)) {\n                s_logger.debug(\"There are backed up snapshots for this volume, can not move.\");\n                res.setResult(\"[UNSUPPORTED] There are backed up snapshots for this volume, can not move. Please try again after removing them.\");\n                future.complete(res);\n                return future;\n            }\n\n            List<Long> poolIds = new ArrayList<Long>();\n            poolIds.add(srcVolume.getPoolId());\n            poolIds.add(destStore.getId());\n\n            Host hostWithPoolsAccess = _storageMgr.findUpAndEnabledHostWithAccessToStoragePools(poolIds);\n            if (hostWithPoolsAccess == null) {\n                s_logger.debug(\"No host(s) available with pool access, can not move this volume\");\n                res.setResult(\"No host(s) available with pool access, can not move this volume\");\n                future.complete(res);\n                return future;\n            }\n\n            VolumeVO destVol = duplicateVolumeOnAnotherStorage(srcVolume, (StoragePool)destStore);\n            VolumeInfo destVolume = volFactory.getVolume(destVol.getId(), destStore);\n\n            \r\n            AsyncCallFuture<VolumeApiResult> createVolumeFuture = createVolumeAsync(destVolume, destStore);\n            VolumeApiResult createVolumeResult = createVolumeFuture.get();\n            if (createVolumeResult.isFailed()) {\n                throw new CloudRuntimeException(\"Creation of a dest volume failed: \" + createVolumeResult.getResult());\n            }\n\n            \r\n            destVolume = volFactory.getVolume(destVolume.getId(), destStore);\n\n            PrimaryDataStore srcPrimaryDataStore = (PrimaryDataStore) srcVolume.getDataStore();\n            if (srcPrimaryDataStore.isManaged()) {\n                Map<String, String> srcPrimaryDataStoreDetails = new HashMap<String, String>();\n                srcPrimaryDataStoreDetails.put(PrimaryDataStore.MANAGED, Boolean.TRUE.toString());\n                srcPrimaryDataStoreDetails.put(PrimaryDataStore.STORAGE_HOST, srcPrimaryDataStore.getHostAddress());\n                srcPrimaryDataStoreDetails.put(PrimaryDataStore.STORAGE_PORT, String.valueOf(srcPrimaryDataStore.getPort()));\n                srcPrimaryDataStoreDetails.put(PrimaryDataStore.MANAGED_STORE_TARGET, srcVolume.get_iScsiName());\n                srcPrimaryDataStoreDetails.put(PrimaryDataStore.MANAGED_STORE_TARGET_ROOT_VOLUME, srcVolume.getName());\n                srcPrimaryDataStoreDetails.put(PrimaryDataStore.VOLUME_SIZE, String.valueOf(srcVolume.getSize()));\n                srcPrimaryDataStoreDetails.put(StorageManager.STORAGE_POOL_DISK_WAIT.toString(), String.valueOf(StorageManager.STORAGE_POOL_DISK_WAIT.valueIn(srcPrimaryDataStore.getId())));\n                srcPrimaryDataStore.setDetails(srcPrimaryDataStoreDetails);\n                grantAccess(srcVolume, hostWithPoolsAccess, srcVolume.getDataStore());\n            }\n\n            PrimaryDataStore destPrimaryDataStore = (PrimaryDataStore) destStore;\n            Map<String, String> destPrimaryDataStoreDetails = new HashMap<String, String>();\n            destPrimaryDataStoreDetails.put(PrimaryDataStore.MANAGED, Boolean.TRUE.toString());\n            destPrimaryDataStoreDetails.put(PrimaryDataStore.STORAGE_HOST, destPrimaryDataStore.getHostAddress());\n            destPrimaryDataStoreDetails.put(PrimaryDataStore.STORAGE_PORT, String.valueOf(destPrimaryDataStore.getPort()));\n            destPrimaryDataStoreDetails.put(PrimaryDataStore.MANAGED_STORE_TARGET, destVolume.get_iScsiName());\n            destPrimaryDataStoreDetails.put(PrimaryDataStore.MANAGED_STORE_TARGET_ROOT_VOLUME, destVolume.getName());\n            destPrimaryDataStoreDetails.put(PrimaryDataStore.VOLUME_SIZE, String.valueOf(destVolume.getSize()));\n            destPrimaryDataStoreDetails.put(StorageManager.STORAGE_POOL_DISK_WAIT.toString(), String.valueOf(StorageManager.STORAGE_POOL_DISK_WAIT.valueIn(destPrimaryDataStore.getId())));\n            destPrimaryDataStore.setDetails(destPrimaryDataStoreDetails);\n\n            grantAccess(destVolume, hostWithPoolsAccess, destStore);\n\n            destVolume.processEvent(Event.CreateRequested);\n            srcVolume.processEvent(Event.MigrationRequested);\n\n            CopyManagedVolumeContext<VolumeApiResult> context = new CopyManagedVolumeContext<VolumeApiResult>(null, future, srcVolume, destVolume, hostWithPoolsAccess);\n            AsyncCallbackDispatcher<VolumeServiceImpl, CopyCommandResult> caller = AsyncCallbackDispatcher.create(this);\n            caller.setCallback(caller.getTarget().copyManagedVolumeCallBack(null, null)).setContext(context);\n\n            motionSrv.copyAsync(srcVolume, destVolume, hostWithPoolsAccess, caller);\n        } catch (Exception e) {\n            s_logger.error(\"Copy to managed volume failed due to: \" + e);\n            if(s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Copy to managed volume failed.\", e);\n            }\n            res.setResult(e.toString());\n            future.complete(res);\n        }\n\n        return future;\n    }\n","date":"2021-02-24 17:28:33","endLine":1973,"groupId":"10263","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"copyManagedVolume","params":"(VolumeInfosrcVolume@DataStoredestStore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/68/940d48b36222eb25c76ce999b3df3838eefea5.src","preCode":"    private AsyncCallFuture<VolumeApiResult> copyManagedVolume(VolumeInfo srcVolume, DataStore destStore) {\n        AsyncCallFuture<VolumeApiResult> future = new AsyncCallFuture<VolumeApiResult>();\n        VolumeApiResult res = new VolumeApiResult(srcVolume);\n        try {\n            if (!snapshotMgr.canOperateOnVolume(srcVolume)) {\n                s_logger.debug(\"There are snapshots creating for this volume, can not move this volume\");\n                res.setResult(\"There are snapshots creating for this volume, can not move this volume\");\n                future.complete(res);\n                return future;\n            }\n\n            if (snapshotMgr.backedUpSnapshotsExistsForVolume(srcVolume)) {\n                s_logger.debug(\"There are backed up snapshots for this volume, can not move.\");\n                res.setResult(\"[UNSUPPORTED] There are backed up snapshots for this volume, can not move. Please try again after removing them.\");\n                future.complete(res);\n                return future;\n            }\n\n            List<Long> poolIds = new ArrayList<Long>();\n            poolIds.add(srcVolume.getPoolId());\n            poolIds.add(destStore.getId());\n\n            Host hostWithPoolsAccess = _storageMgr.findUpAndEnabledHostWithAccessToStoragePools(poolIds);\n            if (hostWithPoolsAccess == null) {\n                s_logger.debug(\"No host(s) available with pool access, can not move this volume\");\n                res.setResult(\"No host(s) available with pool access, can not move this volume\");\n                future.complete(res);\n                return future;\n            }\n\n            VolumeVO destVol = duplicateVolumeOnAnotherStorage(srcVolume, (StoragePool)destStore);\n            VolumeInfo destVolume = volFactory.getVolume(destVol.getId(), destStore);\n\n            \r\n            AsyncCallFuture<VolumeApiResult> createVolumeFuture = createVolumeAsync(destVolume, destStore);\n            VolumeApiResult createVolumeResult = createVolumeFuture.get();\n            if (createVolumeResult.isFailed()) {\n                throw new CloudRuntimeException(\"Creation of a dest volume failed: \" + createVolumeResult.getResult());\n            }\n\n            \r\n            destVolume = volFactory.getVolume(destVolume.getId(), destStore);\n\n            PrimaryDataStore srcPrimaryDataStore = (PrimaryDataStore) srcVolume.getDataStore();\n            if (srcPrimaryDataStore.isManaged()) {\n                Map<String, String> srcPrimaryDataStoreDetails = new HashMap<String, String>();\n                srcPrimaryDataStoreDetails.put(PrimaryDataStore.MANAGED, Boolean.TRUE.toString());\n                srcPrimaryDataStoreDetails.put(PrimaryDataStore.STORAGE_HOST, srcPrimaryDataStore.getHostAddress());\n                srcPrimaryDataStoreDetails.put(PrimaryDataStore.STORAGE_PORT, String.valueOf(srcPrimaryDataStore.getPort()));\n                srcPrimaryDataStoreDetails.put(PrimaryDataStore.MANAGED_STORE_TARGET, srcVolume.get_iScsiName());\n                srcPrimaryDataStoreDetails.put(PrimaryDataStore.MANAGED_STORE_TARGET_ROOT_VOLUME, srcVolume.getName());\n                srcPrimaryDataStoreDetails.put(PrimaryDataStore.VOLUME_SIZE, String.valueOf(srcVolume.getSize()));\n                srcPrimaryDataStoreDetails.put(StorageManager.STORAGE_POOL_DISK_WAIT.toString(), String.valueOf(StorageManager.STORAGE_POOL_DISK_WAIT.valueIn(srcPrimaryDataStore.getId())));\n                srcPrimaryDataStore.setDetails(srcPrimaryDataStoreDetails);\n                grantAccess(srcVolume, hostWithPoolsAccess, srcVolume.getDataStore());\n            }\n\n            PrimaryDataStore destPrimaryDataStore = (PrimaryDataStore) destStore;\n            Map<String, String> destPrimaryDataStoreDetails = new HashMap<String, String>();\n            destPrimaryDataStoreDetails.put(PrimaryDataStore.MANAGED, Boolean.TRUE.toString());\n            destPrimaryDataStoreDetails.put(PrimaryDataStore.STORAGE_HOST, destPrimaryDataStore.getHostAddress());\n            destPrimaryDataStoreDetails.put(PrimaryDataStore.STORAGE_PORT, String.valueOf(destPrimaryDataStore.getPort()));\n            destPrimaryDataStoreDetails.put(PrimaryDataStore.MANAGED_STORE_TARGET, destVolume.get_iScsiName());\n            destPrimaryDataStoreDetails.put(PrimaryDataStore.MANAGED_STORE_TARGET_ROOT_VOLUME, destVolume.getName());\n            destPrimaryDataStoreDetails.put(PrimaryDataStore.VOLUME_SIZE, String.valueOf(destVolume.getSize()));\n            destPrimaryDataStoreDetails.put(StorageManager.STORAGE_POOL_DISK_WAIT.toString(), String.valueOf(StorageManager.STORAGE_POOL_DISK_WAIT.valueIn(destPrimaryDataStore.getId())));\n            destPrimaryDataStore.setDetails(destPrimaryDataStoreDetails);\n\n            grantAccess(destVolume, hostWithPoolsAccess, destStore);\n\n            destVolume.processEvent(Event.CreateRequested);\n            srcVolume.processEvent(Event.MigrationRequested);\n\n            CopyManagedVolumeContext<VolumeApiResult> context = new CopyManagedVolumeContext<VolumeApiResult>(null, future, srcVolume, destVolume, hostWithPoolsAccess);\n            AsyncCallbackDispatcher<VolumeServiceImpl, CopyCommandResult> caller = AsyncCallbackDispatcher.create(this);\n            caller.setCallback(caller.getTarget().copyManagedVolumeCallBack(null, null)).setContext(context);\n\n            motionSrv.copyAsync(srcVolume, destVolume, hostWithPoolsAccess, caller);\n        } catch (Exception e) {\n            s_logger.error(\"Copy to managed volume failed due to: \" + e);\n            if(s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Copy to managed volume failed.\", e);\n            }\n            res.setResult(e.toString());\n            future.complete(res);\n        }\n\n        return future;\n    }\n","realPath":"engine/storage/volume/src/main/java/org/apache/cloudstack/storage/volume/VolumeServiceImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1885,"status":"B"},{"authorDate":"2021-02-24 17:28:33","commitOrder":2,"curCode":"    public AsyncCallFuture<VolumeApiResult> migrateVolume(VolumeInfo srcVolume, DataStore destStore) {\n        AsyncCallFuture<VolumeApiResult> future = new AsyncCallFuture<VolumeApiResult>();\n        VolumeApiResult res = new VolumeApiResult(srcVolume);\n        try {\n            if (!snapshotMgr.canOperateOnVolume(srcVolume)) {\n                s_logger.debug(\"Snapshots are being created on this volume. This volume cannot be migrated now.\");\n                res.setResult(\"Snapshots are being created on this volume. This volume cannot be migrated now.\");\n                future.complete(res);\n                return future;\n            }\n\n            VolumeInfo destVolume = volFactory.getVolume(srcVolume.getId(), destStore);\n            srcVolume.processEvent(Event.MigrationRequested);\n            MigrateVolumeContext<VolumeApiResult> context = new MigrateVolumeContext<VolumeApiResult>(null, future, srcVolume, destVolume, destStore);\n            AsyncCallbackDispatcher<VolumeServiceImpl, CopyCommandResult> caller = AsyncCallbackDispatcher.create(this);\n            caller.setCallback(caller.getTarget().migrateVolumeCallBack(null, null)).setContext(context);\n            motionSrv.copyAsync(srcVolume, destVolume, caller);\n        } catch (Exception e) {\n            s_logger.debug(\"Failed to migrate volume\", e);\n            res.setResult(e.toString());\n            future.complete(res);\n        }\n        return future;\n    }\n","date":"2021-02-24 17:28:33","endLine":2117,"groupId":"19446","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"migrateVolume","params":"(VolumeInfosrcVolume@DataStoredestStore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/68/940d48b36222eb25c76ce999b3df3838eefea5.src","preCode":"    public AsyncCallFuture<VolumeApiResult> migrateVolume(VolumeInfo srcVolume, DataStore destStore) {\n        AsyncCallFuture<VolumeApiResult> future = new AsyncCallFuture<VolumeApiResult>();\n        VolumeApiResult res = new VolumeApiResult(srcVolume);\n        try {\n            if (!snapshotMgr.canOperateOnVolume(srcVolume)) {\n                s_logger.debug(\"Snapshots are being created on this volume. This volume cannot be migrated now.\");\n                res.setResult(\"Snapshots are being created on this volume. This volume cannot be migrated now.\");\n                future.complete(res);\n                return future;\n            }\n\n            VolumeInfo destVolume = volFactory.getVolume(srcVolume.getId(), destStore);\n            srcVolume.processEvent(Event.MigrationRequested);\n            MigrateVolumeContext<VolumeApiResult> context = new MigrateVolumeContext<VolumeApiResult>(null, future, srcVolume, destVolume, destStore);\n            AsyncCallbackDispatcher<VolumeServiceImpl, CopyCommandResult> caller = AsyncCallbackDispatcher.create(this);\n            caller.setCallback(caller.getTarget().migrateVolumeCallBack(null, null)).setContext(context);\n            motionSrv.copyAsync(srcVolume, destVolume, caller);\n        } catch (Exception e) {\n            s_logger.debug(\"Failed to migrate volume\", e);\n            res.setResult(e.toString());\n            future.complete(res);\n        }\n        return future;\n    }\n","realPath":"engine/storage/volume/src/main/java/org/apache/cloudstack/storage/volume/VolumeServiceImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":2094,"status":"MB"}],"commitId":"eba186aa40f16911c019bf06cd33d7d0cbbc303b","commitMessage":"@@@storage: New Dell EMC PowerFlex Plugin (formerly ScaleIO.  VxFlexOS) (#4304)\n\nAdded support for PowerFlex/ScaleIO (v3.5 onwards) storage pool as a primary storage in CloudStack (for KVM hypervisor) and enabled VM/Volume operations on that pool (using pool tag).\nPlease find more details in the FS here:\nhttps://cwiki.apache.org/confluence/x/cDl4CQ\n\nDocumentation PR: apache/cloudstack-documentation#169\n\nThis enables support for PowerFlex/ScaleIO (v3.5 onwards) storage pool as a primary storage in CloudStack\n\nOther improvements addressed in addition to PowerFlex/ScaleIO support:\n\n- Added support for config drives in host cache for KVM\n\t=> Changed configuration \"vm.configdrive.primarypool.enabled\" scope from Global to Zone level\n\t=> Introduced new zone level configuration \"vm.configdrive.force.host.cache.use\" (default: false) to force host cache for config drives\n\t=> Introduced new zone level configuration \"vm.configdrive.use.host.cache.on.unsupported.pool\" (default: true) to use host cache for config drives when storage pool doesn't support config drive\n\t=> Added new parameter \"host.cache.location\" (default: /var/cache/cloud) in KVM agent.properties for specifying the host cache path and create config drives on the \"/config\" directory on the host cache path\n\t=> Maintain the config drive location and use it when required on any config drive operation (migrate.  delete)\n\n- Detect virtual size from the template URL while registering direct download qcow2 (of KVM hypervisor) templates\n\n- Updated full deployment destination for preparing the network(s) on VM start\n\n- Propagate the direct download certificates uploaded to the newly added KVM hosts\n\n- Discover the template size for direct download templates using any available host from the zones specified on template registration\n\t=> When zones are not specified while registering template.  template size discovery is performed using any available host.  which is picked up randomly from one of the available zones\n\n- Release the VM resources when VM is sync-ed to Stopped state on PowerReportMissing (after graceful period)\n\n- Retry VM deployment/start when the host cannot grant access to volume/template\n\n- Mark never-used or downloaded templates as Destroyed on deletion.  without sending any DeleteCommand\n\t=> Do not trigger any DeleteCommand for never-used or downloaded templates as these doesn't exist and cannot be deleted from the datastore\n\n- Check the router filesystem is writable or not.  before performing health checks\n\t=> Introduce a new test \"filesystem.writable.test\" to check the filesystem is writable or not\n\t=> The router health checks keeps the config info at \"/var/cache/cloud\" and updates the monitor results at \"/root\" for health checks.  both are different partitions. So.  test at both the locations.\n\t=> Added new script: \"filesystem_writable_check.py\" at /opt/cloud/bin/ to check the filesystem is writable or not\n\n- Fixed NPE issue.  template is null for DATA disks. Copy template to target storage for ROOT disk (with template id).  skip DATA disk(s)\n\n* Addressed some issues for few operations on PowerFlex storage pool.\n\n- Updated migration volume operation to sync the status and wait for migration to complete.\n\n- Updated VM Snapshot naming.  for uniqueness in ScaleIO volume name when more than one volume exists in the VM.\n\n- Added sync lock while spooling managed storage template before volume creation from the template (non-direct download).\n\n- Updated resize volume error message string.\n\n- Blocked the below operations on PowerFlex storage pool:\n  -> Extract Volume\n  -> Create Snapshot for VMSnapshot\n\n* Added the PowerFlex/ScaleIO client connection pool to manage the ScaleIO gateway clients.  which uses a single gateway client per Powerflex/ScaleIO storage pool and renews it when the session token expires.\n\n- The token is valid for 8 hours from the time it was created.  unless there has been no activity for 10 minutes.\n  Reference: https://cpsdocs.dellemc.com/bundle/PF_REST_API_RG/page/GUID-92430F19-9F44-42B6-B898-87D5307AE59B.html\n\nOther fixes included:\n\n- Fail the VM deployment when the host specified in the deployVirtualMachine cmd is not in the right state (i.e. either Resource State is not Enabled or Status is not Up)\n\n- Use the physical file size of the template to check the free space availability on the host.  while downloading the direct download templates.\n\n- Perform basic tests (for connectivity and file system) on router before updating the health check config data\n\t=> Validate the basic tests (connectivity and file system check) on router\n\t=> Cleanup the health check results when router is destroyed\n\n* Updated PowerFlex/ScaleIO storage plugin version to 4.16.0.0\n\n* UI Changes to support storage plugin for PowerFlex/ScaleIO storage pool.\n- PowerFlex pool URL generated from the UI inputs(Gateway.  Username.  Password.  Storage Pool) when adding \"PowerFlex\" Primary Storage\n- Updated protocol to \"custom\" for PowerFlex provider\n- Allow VM Snapshot for stopped VM on KVM hypervisor and PowerFlex/ScaleIO storage pool\n\nand Minor improvements in PowerFlex/ScaleIO storage plugin code\n\n* Added support for PowerFlex/ScaleIO volume migration across different PowerFlex storage instances.\n\n- findStoragePoolsForMigration API returns PowerFlex pool(s) of different instance as suitable pool(s).  for volume(s) on PowerFlex storage pool.\n- Volume(s) with snapshots are not allowed to migrate to different PowerFlex instance.\n- Volume(s) of running VM are not allowed to migrate to other PowerFlex storage pools.\n- Volume migration from PowerFlex pool to Non-PowerFlex pool.  and vice versa are not supported.\n\n* Fixed change service offering smoke tests in test_service_offerings.py.  test_vm_snapshots.py\n\n* Added the PowerFlex/ScaleIO volume/snapshot name to the paths of respective CloudStack resources (Templates.  Volumes.  Snapshots and VM Snapshots)\n\n* Added new response parameter ?supportsStorageSnapshot? (true/false) to volume response.  and Updated UI to hide the async backup option while taking snapshot for volume(s) with storage snapshot support.\n\n* Fix to remove the duplicate zone wide pools listed while finding storage pools for migration\n\n* Updated PowerFlex/ScaleIO volume migration checks and rollback migration on failure\n\n* Fixed the PowerFlex/ScaleIO volume name inconsistency issue in the volume path after migration.  due to rename failure","date":"2021-02-24 17:28:33","modifiedFileCount":"112","status":"M","submitter":"sureshanaparti"},{"authorTime":"2021-02-24 17:28:33","codes":[{"authorDate":"2021-03-03 16:00:08","commitOrder":3,"curCode":"    private AsyncCallFuture<VolumeApiResult> copyManagedVolume(VolumeInfo srcVolume, DataStore destStore) {\n        AsyncCallFuture<VolumeApiResult> future = new AsyncCallFuture<VolumeApiResult>();\n        VolumeApiResult res = new VolumeApiResult(srcVolume);\n        try {\n            if (!snapshotMgr.canOperateOnVolume(srcVolume)) {\n                s_logger.debug(\"There are snapshots creating for this volume, can not move this volume\");\n                res.setResult(\"There are snapshots creating for this volume, can not move this volume\");\n                future.complete(res);\n                return future;\n            }\n\n            if (snapshotMgr.backedUpSnapshotsExistsForVolume(srcVolume)) {\n                s_logger.debug(\"There are backed up snapshots for this volume, can not move.\");\n                res.setResult(\"[UNSUPPORTED] There are backed up snapshots for this volume, can not move. Please try again after removing them.\");\n                future.complete(res);\n                return future;\n            }\n\n            List<Long> poolIds = new ArrayList<Long>();\n            poolIds.add(srcVolume.getPoolId());\n            poolIds.add(destStore.getId());\n\n            Host hostWithPoolsAccess = _storageMgr.findUpAndEnabledHostWithAccessToStoragePools(poolIds);\n            if (hostWithPoolsAccess == null) {\n                s_logger.debug(\"No host(s) available with pool access, can not move this volume\");\n                res.setResult(\"No host(s) available with pool access, can not move this volume\");\n                future.complete(res);\n                return future;\n            }\n\n            VolumeVO destVol = duplicateVolumeOnAnotherStorage(srcVolume, (StoragePool)destStore);\n            VolumeInfo destVolume = volFactory.getVolume(destVol.getId(), destStore);\n\n            \r\n            AsyncCallFuture<VolumeApiResult> createVolumeFuture = createVolumeAsync(destVolume, destStore);\n            VolumeApiResult createVolumeResult = createVolumeFuture.get();\n            if (createVolumeResult.isFailed()) {\n                s_logger.debug(\"Failed to create dest volume \" + destVolume.getId() + \", volume can be removed\");\n                destroyVolume(destVolume.getId());\n                destVolume.processEvent(Event.ExpungeRequested);\n                destVolume.processEvent(Event.OperationSuccessed);\n                volDao.remove(destVolume.getId());\n                throw new CloudRuntimeException(\"Creation of a dest volume failed: \" + createVolumeResult.getResult());\n            }\n\n            \r\n            destVolume = volFactory.getVolume(destVolume.getId(), destStore);\n\n            PrimaryDataStore srcPrimaryDataStore = (PrimaryDataStore) srcVolume.getDataStore();\n            if (srcPrimaryDataStore.isManaged()) {\n                Map<String, String> srcPrimaryDataStoreDetails = new HashMap<String, String>();\n                srcPrimaryDataStoreDetails.put(PrimaryDataStore.MANAGED, Boolean.TRUE.toString());\n                srcPrimaryDataStoreDetails.put(PrimaryDataStore.STORAGE_HOST, srcPrimaryDataStore.getHostAddress());\n                srcPrimaryDataStoreDetails.put(PrimaryDataStore.STORAGE_PORT, String.valueOf(srcPrimaryDataStore.getPort()));\n                srcPrimaryDataStoreDetails.put(PrimaryDataStore.MANAGED_STORE_TARGET, srcVolume.get_iScsiName());\n                srcPrimaryDataStoreDetails.put(PrimaryDataStore.MANAGED_STORE_TARGET_ROOT_VOLUME, srcVolume.getName());\n                srcPrimaryDataStoreDetails.put(PrimaryDataStore.VOLUME_SIZE, String.valueOf(srcVolume.getSize()));\n                srcPrimaryDataStoreDetails.put(StorageManager.STORAGE_POOL_DISK_WAIT.toString(), String.valueOf(StorageManager.STORAGE_POOL_DISK_WAIT.valueIn(srcPrimaryDataStore.getId())));\n                srcPrimaryDataStore.setDetails(srcPrimaryDataStoreDetails);\n                grantAccess(srcVolume, hostWithPoolsAccess, srcVolume.getDataStore());\n            }\n\n            PrimaryDataStore destPrimaryDataStore = (PrimaryDataStore) destStore;\n            Map<String, String> destPrimaryDataStoreDetails = new HashMap<String, String>();\n            destPrimaryDataStoreDetails.put(PrimaryDataStore.MANAGED, Boolean.TRUE.toString());\n            destPrimaryDataStoreDetails.put(PrimaryDataStore.STORAGE_HOST, destPrimaryDataStore.getHostAddress());\n            destPrimaryDataStoreDetails.put(PrimaryDataStore.STORAGE_PORT, String.valueOf(destPrimaryDataStore.getPort()));\n            destPrimaryDataStoreDetails.put(PrimaryDataStore.MANAGED_STORE_TARGET, destVolume.get_iScsiName());\n            destPrimaryDataStoreDetails.put(PrimaryDataStore.MANAGED_STORE_TARGET_ROOT_VOLUME, destVolume.getName());\n            destPrimaryDataStoreDetails.put(PrimaryDataStore.VOLUME_SIZE, String.valueOf(destVolume.getSize()));\n            destPrimaryDataStoreDetails.put(StorageManager.STORAGE_POOL_DISK_WAIT.toString(), String.valueOf(StorageManager.STORAGE_POOL_DISK_WAIT.valueIn(destPrimaryDataStore.getId())));\n            destPrimaryDataStore.setDetails(destPrimaryDataStoreDetails);\n\n            grantAccess(destVolume, hostWithPoolsAccess, destStore);\n\n            destVolume.processEvent(Event.CreateRequested);\n            srcVolume.processEvent(Event.MigrationRequested);\n\n            CopyManagedVolumeContext<VolumeApiResult> context = new CopyManagedVolumeContext<VolumeApiResult>(null, future, srcVolume, destVolume, hostWithPoolsAccess);\n            AsyncCallbackDispatcher<VolumeServiceImpl, CopyCommandResult> caller = AsyncCallbackDispatcher.create(this);\n            caller.setCallback(caller.getTarget().copyManagedVolumeCallBack(null, null)).setContext(context);\n\n            motionSrv.copyAsync(srcVolume, destVolume, hostWithPoolsAccess, caller);\n        } catch (Exception e) {\n            s_logger.error(\"Copy to managed volume failed due to: \" + e);\n            if(s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Copy to managed volume failed.\", e);\n            }\n            res.setResult(e.toString());\n            future.complete(res);\n        }\n\n        return future;\n    }\n","date":"2021-03-03 16:00:08","endLine":1979,"groupId":"10675","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"copyManagedVolume","params":"(VolumeInfosrcVolume@DataStoredestStore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/34/8c1423433fb4646bb8ec4250dd7824868a99e7.src","preCode":"    private AsyncCallFuture<VolumeApiResult> copyManagedVolume(VolumeInfo srcVolume, DataStore destStore) {\n        AsyncCallFuture<VolumeApiResult> future = new AsyncCallFuture<VolumeApiResult>();\n        VolumeApiResult res = new VolumeApiResult(srcVolume);\n        try {\n            if (!snapshotMgr.canOperateOnVolume(srcVolume)) {\n                s_logger.debug(\"There are snapshots creating for this volume, can not move this volume\");\n                res.setResult(\"There are snapshots creating for this volume, can not move this volume\");\n                future.complete(res);\n                return future;\n            }\n\n            if (snapshotMgr.backedUpSnapshotsExistsForVolume(srcVolume)) {\n                s_logger.debug(\"There are backed up snapshots for this volume, can not move.\");\n                res.setResult(\"[UNSUPPORTED] There are backed up snapshots for this volume, can not move. Please try again after removing them.\");\n                future.complete(res);\n                return future;\n            }\n\n            List<Long> poolIds = new ArrayList<Long>();\n            poolIds.add(srcVolume.getPoolId());\n            poolIds.add(destStore.getId());\n\n            Host hostWithPoolsAccess = _storageMgr.findUpAndEnabledHostWithAccessToStoragePools(poolIds);\n            if (hostWithPoolsAccess == null) {\n                s_logger.debug(\"No host(s) available with pool access, can not move this volume\");\n                res.setResult(\"No host(s) available with pool access, can not move this volume\");\n                future.complete(res);\n                return future;\n            }\n\n            VolumeVO destVol = duplicateVolumeOnAnotherStorage(srcVolume, (StoragePool)destStore);\n            VolumeInfo destVolume = volFactory.getVolume(destVol.getId(), destStore);\n\n            \r\n            AsyncCallFuture<VolumeApiResult> createVolumeFuture = createVolumeAsync(destVolume, destStore);\n            VolumeApiResult createVolumeResult = createVolumeFuture.get();\n            if (createVolumeResult.isFailed()) {\n                throw new CloudRuntimeException(\"Creation of a dest volume failed: \" + createVolumeResult.getResult());\n            }\n\n            \r\n            destVolume = volFactory.getVolume(destVolume.getId(), destStore);\n\n            PrimaryDataStore srcPrimaryDataStore = (PrimaryDataStore) srcVolume.getDataStore();\n            if (srcPrimaryDataStore.isManaged()) {\n                Map<String, String> srcPrimaryDataStoreDetails = new HashMap<String, String>();\n                srcPrimaryDataStoreDetails.put(PrimaryDataStore.MANAGED, Boolean.TRUE.toString());\n                srcPrimaryDataStoreDetails.put(PrimaryDataStore.STORAGE_HOST, srcPrimaryDataStore.getHostAddress());\n                srcPrimaryDataStoreDetails.put(PrimaryDataStore.STORAGE_PORT, String.valueOf(srcPrimaryDataStore.getPort()));\n                srcPrimaryDataStoreDetails.put(PrimaryDataStore.MANAGED_STORE_TARGET, srcVolume.get_iScsiName());\n                srcPrimaryDataStoreDetails.put(PrimaryDataStore.MANAGED_STORE_TARGET_ROOT_VOLUME, srcVolume.getName());\n                srcPrimaryDataStoreDetails.put(PrimaryDataStore.VOLUME_SIZE, String.valueOf(srcVolume.getSize()));\n                srcPrimaryDataStoreDetails.put(StorageManager.STORAGE_POOL_DISK_WAIT.toString(), String.valueOf(StorageManager.STORAGE_POOL_DISK_WAIT.valueIn(srcPrimaryDataStore.getId())));\n                srcPrimaryDataStore.setDetails(srcPrimaryDataStoreDetails);\n                grantAccess(srcVolume, hostWithPoolsAccess, srcVolume.getDataStore());\n            }\n\n            PrimaryDataStore destPrimaryDataStore = (PrimaryDataStore) destStore;\n            Map<String, String> destPrimaryDataStoreDetails = new HashMap<String, String>();\n            destPrimaryDataStoreDetails.put(PrimaryDataStore.MANAGED, Boolean.TRUE.toString());\n            destPrimaryDataStoreDetails.put(PrimaryDataStore.STORAGE_HOST, destPrimaryDataStore.getHostAddress());\n            destPrimaryDataStoreDetails.put(PrimaryDataStore.STORAGE_PORT, String.valueOf(destPrimaryDataStore.getPort()));\n            destPrimaryDataStoreDetails.put(PrimaryDataStore.MANAGED_STORE_TARGET, destVolume.get_iScsiName());\n            destPrimaryDataStoreDetails.put(PrimaryDataStore.MANAGED_STORE_TARGET_ROOT_VOLUME, destVolume.getName());\n            destPrimaryDataStoreDetails.put(PrimaryDataStore.VOLUME_SIZE, String.valueOf(destVolume.getSize()));\n            destPrimaryDataStoreDetails.put(StorageManager.STORAGE_POOL_DISK_WAIT.toString(), String.valueOf(StorageManager.STORAGE_POOL_DISK_WAIT.valueIn(destPrimaryDataStore.getId())));\n            destPrimaryDataStore.setDetails(destPrimaryDataStoreDetails);\n\n            grantAccess(destVolume, hostWithPoolsAccess, destStore);\n\n            destVolume.processEvent(Event.CreateRequested);\n            srcVolume.processEvent(Event.MigrationRequested);\n\n            CopyManagedVolumeContext<VolumeApiResult> context = new CopyManagedVolumeContext<VolumeApiResult>(null, future, srcVolume, destVolume, hostWithPoolsAccess);\n            AsyncCallbackDispatcher<VolumeServiceImpl, CopyCommandResult> caller = AsyncCallbackDispatcher.create(this);\n            caller.setCallback(caller.getTarget().copyManagedVolumeCallBack(null, null)).setContext(context);\n\n            motionSrv.copyAsync(srcVolume, destVolume, hostWithPoolsAccess, caller);\n        } catch (Exception e) {\n            s_logger.error(\"Copy to managed volume failed due to: \" + e);\n            if(s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Copy to managed volume failed.\", e);\n            }\n            res.setResult(e.toString());\n            future.complete(res);\n        }\n\n        return future;\n    }\n","realPath":"engine/storage/volume/src/main/java/org/apache/cloudstack/storage/volume/VolumeServiceImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1886,"status":"M"},{"authorDate":"2021-02-24 17:28:33","commitOrder":3,"curCode":"    public AsyncCallFuture<VolumeApiResult> migrateVolume(VolumeInfo srcVolume, DataStore destStore) {\n        AsyncCallFuture<VolumeApiResult> future = new AsyncCallFuture<VolumeApiResult>();\n        VolumeApiResult res = new VolumeApiResult(srcVolume);\n        try {\n            if (!snapshotMgr.canOperateOnVolume(srcVolume)) {\n                s_logger.debug(\"Snapshots are being created on this volume. This volume cannot be migrated now.\");\n                res.setResult(\"Snapshots are being created on this volume. This volume cannot be migrated now.\");\n                future.complete(res);\n                return future;\n            }\n\n            VolumeInfo destVolume = volFactory.getVolume(srcVolume.getId(), destStore);\n            srcVolume.processEvent(Event.MigrationRequested);\n            MigrateVolumeContext<VolumeApiResult> context = new MigrateVolumeContext<VolumeApiResult>(null, future, srcVolume, destVolume, destStore);\n            AsyncCallbackDispatcher<VolumeServiceImpl, CopyCommandResult> caller = AsyncCallbackDispatcher.create(this);\n            caller.setCallback(caller.getTarget().migrateVolumeCallBack(null, null)).setContext(context);\n            motionSrv.copyAsync(srcVolume, destVolume, caller);\n        } catch (Exception e) {\n            s_logger.debug(\"Failed to migrate volume\", e);\n            res.setResult(e.toString());\n            future.complete(res);\n        }\n        return future;\n    }\n","date":"2021-02-24 17:28:33","endLine":2117,"groupId":"10675","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"migrateVolume","params":"(VolumeInfosrcVolume@DataStoredestStore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/68/940d48b36222eb25c76ce999b3df3838eefea5.src","preCode":"    public AsyncCallFuture<VolumeApiResult> migrateVolume(VolumeInfo srcVolume, DataStore destStore) {\n        AsyncCallFuture<VolumeApiResult> future = new AsyncCallFuture<VolumeApiResult>();\n        VolumeApiResult res = new VolumeApiResult(srcVolume);\n        try {\n            if (!snapshotMgr.canOperateOnVolume(srcVolume)) {\n                s_logger.debug(\"Snapshots are being created on this volume. This volume cannot be migrated now.\");\n                res.setResult(\"Snapshots are being created on this volume. This volume cannot be migrated now.\");\n                future.complete(res);\n                return future;\n            }\n\n            VolumeInfo destVolume = volFactory.getVolume(srcVolume.getId(), destStore);\n            srcVolume.processEvent(Event.MigrationRequested);\n            MigrateVolumeContext<VolumeApiResult> context = new MigrateVolumeContext<VolumeApiResult>(null, future, srcVolume, destVolume, destStore);\n            AsyncCallbackDispatcher<VolumeServiceImpl, CopyCommandResult> caller = AsyncCallbackDispatcher.create(this);\n            caller.setCallback(caller.getTarget().migrateVolumeCallBack(null, null)).setContext(context);\n            motionSrv.copyAsync(srcVolume, destVolume, caller);\n        } catch (Exception e) {\n            s_logger.debug(\"Failed to migrate volume\", e);\n            res.setResult(e.toString());\n            future.complete(res);\n        }\n        return future;\n    }\n","realPath":"engine/storage/volume/src/main/java/org/apache/cloudstack/storage/volume/VolumeServiceImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":2094,"status":"N"}],"commitId":"45e77dd6f0b707b7fd087d50aee5c8294e813cc9","commitMessage":"@@@server: Clean up the duplicate volume when the destination managed volume creation failed on migrate volume operation (#4730)\n\nDuplicated volumes after failed migration in Allocated state\n\nFix: Clean up the duplicate volume when the destination managed volume creation failed on migrate volume operation\n\n","date":"2021-03-03 16:00:08","modifiedFileCount":"1","status":"M","submitter":"sureshanaparti"}]
