[{"authorTime":"2018-01-20 05:49:27","codes":[{"authorDate":"2018-01-20 05:49:27","commitOrder":1,"curCode":"    public Answer attachVolume(final AttachCommand cmd) {\n        final DiskTO disk = cmd.getDisk();\n        final VolumeObjectTO vol = (VolumeObjectTO)disk.getData();\n        final PrimaryDataStoreTO primaryStore = (PrimaryDataStoreTO)vol.getDataStore();\n        final String vmName = cmd.getVmName();\n        final String serial = resource.diskUuidToSerial(vol.getUuid());\n        try {\n            final Connect conn = LibvirtConnection.getConnectionByVmName(vmName);\n\n            storagePoolMgr.connectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath(), disk.getDetails());\n\n            final KVMPhysicalDisk phyDisk = storagePoolMgr.getPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n\n            attachOrDetachDisk(conn, true, vmName, phyDisk, disk.getDiskSeq().intValue(), serial, vol.getBytesReadRate(), vol.getBytesWriteRate(), vol.getIopsReadRate(), vol.getIopsWriteRate());\n\n            return new AttachAnswer(disk);\n        } catch (final LibvirtException e) {\n            s_logger.debug(\"Failed to attach volume: \" + vol.getPath() + \", due to \", e);\n            storagePoolMgr.disconnectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n            return new AttachAnswer(e.toString());\n        } catch (final InternalErrorException e) {\n            s_logger.debug(\"Failed to attach volume: \" + vol.getPath() + \", due to \", e);\n            return new AttachAnswer(e.toString());\n        }\n    }\n","date":"2018-01-20 05:49:27","endLine":1278,"groupId":"8934","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"attachVolume","params":"(finalAttachCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/f0/9e8f7b0ea63f78c91238751e5c02986f3c7b59.src","preCode":"    public Answer attachVolume(final AttachCommand cmd) {\n        final DiskTO disk = cmd.getDisk();\n        final VolumeObjectTO vol = (VolumeObjectTO)disk.getData();\n        final PrimaryDataStoreTO primaryStore = (PrimaryDataStoreTO)vol.getDataStore();\n        final String vmName = cmd.getVmName();\n        final String serial = resource.diskUuidToSerial(vol.getUuid());\n        try {\n            final Connect conn = LibvirtConnection.getConnectionByVmName(vmName);\n\n            storagePoolMgr.connectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath(), disk.getDetails());\n\n            final KVMPhysicalDisk phyDisk = storagePoolMgr.getPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n\n            attachOrDetachDisk(conn, true, vmName, phyDisk, disk.getDiskSeq().intValue(), serial, vol.getBytesReadRate(), vol.getBytesWriteRate(), vol.getIopsReadRate(), vol.getIopsWriteRate());\n\n            return new AttachAnswer(disk);\n        } catch (final LibvirtException e) {\n            s_logger.debug(\"Failed to attach volume: \" + vol.getPath() + \", due to \", e);\n            storagePoolMgr.disconnectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n            return new AttachAnswer(e.toString());\n        } catch (final InternalErrorException e) {\n            s_logger.debug(\"Failed to attach volume: \" + vol.getPath() + \", due to \", e);\n            return new AttachAnswer(e.toString());\n        }\n    }\n","realPath":"plugins/hypervisors/kvm/src/main/java/com/cloud/hypervisor/kvm/storage/KVMStorageProcessor.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1254,"status":"B"},{"authorDate":"2018-01-20 05:49:27","commitOrder":1,"curCode":"    public Answer dettachVolume(final DettachCommand cmd) {\n        final DiskTO disk = cmd.getDisk();\n        final VolumeObjectTO vol = (VolumeObjectTO)disk.getData();\n        final PrimaryDataStoreTO primaryStore = (PrimaryDataStoreTO)vol.getDataStore();\n        final String vmName = cmd.getVmName();\n        final String serial = resource.diskUuidToSerial(vol.getUuid());\n        try {\n            final Connect conn = LibvirtConnection.getConnectionByVmName(vmName);\n\n            final KVMPhysicalDisk phyDisk = storagePoolMgr.getPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n\n            attachOrDetachDisk(conn, false, vmName, phyDisk, disk.getDiskSeq().intValue(), serial, vol.getBytesReadRate(), vol.getBytesWriteRate(), vol.getIopsReadRate(), vol.getIopsWriteRate());\n\n            storagePoolMgr.disconnectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n\n            return new DettachAnswer(disk);\n        } catch (final LibvirtException e) {\n            s_logger.debug(\"Failed to attach volume: \" + vol.getPath() + \", due to \", e);\n            return new DettachAnswer(e.toString());\n        } catch (final InternalErrorException e) {\n            s_logger.debug(\"Failed to attach volume: \" + vol.getPath() + \", due to \", e);\n            return new DettachAnswer(e.toString());\n        }\n    }\n","date":"2018-01-20 05:49:27","endLine":1304,"groupId":"18172","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"dettachVolume","params":"(finalDettachCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/f0/9e8f7b0ea63f78c91238751e5c02986f3c7b59.src","preCode":"    public Answer dettachVolume(final DettachCommand cmd) {\n        final DiskTO disk = cmd.getDisk();\n        final VolumeObjectTO vol = (VolumeObjectTO)disk.getData();\n        final PrimaryDataStoreTO primaryStore = (PrimaryDataStoreTO)vol.getDataStore();\n        final String vmName = cmd.getVmName();\n        final String serial = resource.diskUuidToSerial(vol.getUuid());\n        try {\n            final Connect conn = LibvirtConnection.getConnectionByVmName(vmName);\n\n            final KVMPhysicalDisk phyDisk = storagePoolMgr.getPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n\n            attachOrDetachDisk(conn, false, vmName, phyDisk, disk.getDiskSeq().intValue(), serial, vol.getBytesReadRate(), vol.getBytesWriteRate(), vol.getIopsReadRate(), vol.getIopsWriteRate());\n\n            storagePoolMgr.disconnectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n\n            return new DettachAnswer(disk);\n        } catch (final LibvirtException e) {\n            s_logger.debug(\"Failed to attach volume: \" + vol.getPath() + \", due to \", e);\n            return new DettachAnswer(e.toString());\n        } catch (final InternalErrorException e) {\n            s_logger.debug(\"Failed to attach volume: \" + vol.getPath() + \", due to \", e);\n            return new DettachAnswer(e.toString());\n        }\n    }\n","realPath":"plugins/hypervisors/kvm/src/main/java/com/cloud/hypervisor/kvm/storage/KVMStorageProcessor.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1281,"status":"B"}],"commitId":"893a88d225276e45f12f9490e6af2c94a81c2965","commitMessage":"@@@CLOUDSTACK-10105: Use maven standard project structure in all projects (#2283)\n\nRemove maven standard module (which only a few were using) and get ride of maven customization for the projects structure.\n\n- moved all directories to src/main/java.  src/main/resources.  src/main/scripts.  src/test/java.  src/test/resources\n- grep scan to search for src/com and src/org left over\n- grep for <project>/scripts to fix pom.xml configuration\n- remove custom <build> configuration in pom.xml\n\nSigned-off-by: Marc-Aur?le Brothier <m@brothier.org>","date":"2018-01-20 05:49:27","modifiedFileCount":"1","status":"B","submitter":"Marc-Aur?le Brothier"},{"authorTime":"2018-04-20 03:03:27","codes":[{"authorDate":"2018-01-20 05:49:27","commitOrder":2,"curCode":"    public Answer attachVolume(final AttachCommand cmd) {\n        final DiskTO disk = cmd.getDisk();\n        final VolumeObjectTO vol = (VolumeObjectTO)disk.getData();\n        final PrimaryDataStoreTO primaryStore = (PrimaryDataStoreTO)vol.getDataStore();\n        final String vmName = cmd.getVmName();\n        final String serial = resource.diskUuidToSerial(vol.getUuid());\n        try {\n            final Connect conn = LibvirtConnection.getConnectionByVmName(vmName);\n\n            storagePoolMgr.connectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath(), disk.getDetails());\n\n            final KVMPhysicalDisk phyDisk = storagePoolMgr.getPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n\n            attachOrDetachDisk(conn, true, vmName, phyDisk, disk.getDiskSeq().intValue(), serial, vol.getBytesReadRate(), vol.getBytesWriteRate(), vol.getIopsReadRate(), vol.getIopsWriteRate());\n\n            return new AttachAnswer(disk);\n        } catch (final LibvirtException e) {\n            s_logger.debug(\"Failed to attach volume: \" + vol.getPath() + \", due to \", e);\n            storagePoolMgr.disconnectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n            return new AttachAnswer(e.toString());\n        } catch (final InternalErrorException e) {\n            s_logger.debug(\"Failed to attach volume: \" + vol.getPath() + \", due to \", e);\n            return new AttachAnswer(e.toString());\n        }\n    }\n","date":"2018-01-20 05:49:27","endLine":1278,"groupId":"8934","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"attachVolume","params":"(finalAttachCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/f0/9e8f7b0ea63f78c91238751e5c02986f3c7b59.src","preCode":"    public Answer attachVolume(final AttachCommand cmd) {\n        final DiskTO disk = cmd.getDisk();\n        final VolumeObjectTO vol = (VolumeObjectTO)disk.getData();\n        final PrimaryDataStoreTO primaryStore = (PrimaryDataStoreTO)vol.getDataStore();\n        final String vmName = cmd.getVmName();\n        final String serial = resource.diskUuidToSerial(vol.getUuid());\n        try {\n            final Connect conn = LibvirtConnection.getConnectionByVmName(vmName);\n\n            storagePoolMgr.connectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath(), disk.getDetails());\n\n            final KVMPhysicalDisk phyDisk = storagePoolMgr.getPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n\n            attachOrDetachDisk(conn, true, vmName, phyDisk, disk.getDiskSeq().intValue(), serial, vol.getBytesReadRate(), vol.getBytesWriteRate(), vol.getIopsReadRate(), vol.getIopsWriteRate());\n\n            return new AttachAnswer(disk);\n        } catch (final LibvirtException e) {\n            s_logger.debug(\"Failed to attach volume: \" + vol.getPath() + \", due to \", e);\n            storagePoolMgr.disconnectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n            return new AttachAnswer(e.toString());\n        } catch (final InternalErrorException e) {\n            s_logger.debug(\"Failed to attach volume: \" + vol.getPath() + \", due to \", e);\n            return new AttachAnswer(e.toString());\n        }\n    }\n","realPath":"plugins/hypervisors/kvm/src/main/java/com/cloud/hypervisor/kvm/storage/KVMStorageProcessor.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1254,"status":"N"},{"authorDate":"2018-04-20 03:03:27","commitOrder":2,"curCode":"    public Answer dettachVolume(final DettachCommand cmd) {\n        final DiskTO disk = cmd.getDisk();\n        final VolumeObjectTO vol = (VolumeObjectTO)disk.getData();\n        final PrimaryDataStoreTO primaryStore = (PrimaryDataStoreTO)vol.getDataStore();\n        final String vmName = cmd.getVmName();\n        final String serial = resource.diskUuidToSerial(vol.getUuid());\n        try {\n            final Connect conn = LibvirtConnection.getConnectionByVmName(vmName);\n\n            final KVMPhysicalDisk phyDisk = storagePoolMgr.getPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n\n            attachOrDetachDisk(conn, false, vmName, phyDisk, disk.getDiskSeq().intValue(), serial, vol.getBytesReadRate(), vol.getBytesWriteRate(), vol.getIopsReadRate(), vol.getIopsWriteRate());\n\n            storagePoolMgr.disconnectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n\n            return new DettachAnswer(disk);\n        } catch (final LibvirtException e) {\n            s_logger.debug(\"Failed to detach volume: \" + vol.getPath() + \", due to \", e);\n            return new DettachAnswer(e.toString());\n        } catch (final InternalErrorException e) {\n            s_logger.debug(\"Failed to detach volume: \" + vol.getPath() + \", due to \", e);\n            return new DettachAnswer(e.toString());\n        }\n    }\n","date":"2018-04-20 03:03:27","endLine":1318,"groupId":"18172","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"dettachVolume","params":"(finalDettachCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/e7/e0ea26b6052933d77010d72b6143eb85240dac.src","preCode":"    public Answer dettachVolume(final DettachCommand cmd) {\n        final DiskTO disk = cmd.getDisk();\n        final VolumeObjectTO vol = (VolumeObjectTO)disk.getData();\n        final PrimaryDataStoreTO primaryStore = (PrimaryDataStoreTO)vol.getDataStore();\n        final String vmName = cmd.getVmName();\n        final String serial = resource.diskUuidToSerial(vol.getUuid());\n        try {\n            final Connect conn = LibvirtConnection.getConnectionByVmName(vmName);\n\n            final KVMPhysicalDisk phyDisk = storagePoolMgr.getPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n\n            attachOrDetachDisk(conn, false, vmName, phyDisk, disk.getDiskSeq().intValue(), serial, vol.getBytesReadRate(), vol.getBytesWriteRate(), vol.getIopsReadRate(), vol.getIopsWriteRate());\n\n            storagePoolMgr.disconnectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n\n            return new DettachAnswer(disk);\n        } catch (final LibvirtException e) {\n            s_logger.debug(\"Failed to attach volume: \" + vol.getPath() + \", due to \", e);\n            return new DettachAnswer(e.toString());\n        } catch (final InternalErrorException e) {\n            s_logger.debug(\"Failed to attach volume: \" + vol.getPath() + \", due to \", e);\n            return new DettachAnswer(e.toString());\n        }\n    }\n","realPath":"plugins/hypervisors/kvm/src/main/java/com/cloud/hypervisor/kvm/storage/KVMStorageProcessor.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1295,"status":"M"}],"commitId":"fed3492b57625f415df556b5e2e44efee2257f50","commitMessage":"@@@CLOUDSTACK-10357: Improve log messages in methods (#2580)\n\nFix several logs that mismatch method.\nAdd stacktraces for throw new statements.","date":"2018-04-20 03:03:27","modifiedFileCount":"12","status":"M","submitter":"lzh3636"},{"authorTime":"2019-02-05 05:47:44","codes":[{"authorDate":"2019-02-05 05:47:44","commitOrder":3,"curCode":"    public Answer attachVolume(final AttachCommand cmd) {\n        final DiskTO disk = cmd.getDisk();\n        final VolumeObjectTO vol = (VolumeObjectTO)disk.getData();\n        final PrimaryDataStoreTO primaryStore = (PrimaryDataStoreTO)vol.getDataStore();\n        final String vmName = cmd.getVmName();\n        final String serial = resource.diskUuidToSerial(vol.getUuid());\n        try {\n            final Connect conn = LibvirtConnection.getConnectionByVmName(vmName);\n\n            storagePoolMgr.connectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath(), disk.getDetails());\n\n            final KVMPhysicalDisk phyDisk = storagePoolMgr.getPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n\n            attachOrDetachDisk(conn, true, vmName, phyDisk, disk.getDiskSeq().intValue(), serial,\n                    vol.getBytesReadRate(), vol.getBytesReadRateMax(), vol.getBytesReadRateMaxLength(),\n                    vol.getBytesWriteRate(), vol.getBytesWriteRateMax(), vol.getBytesWriteRateMaxLength(),\n                    vol.getIopsReadRate(), vol.getIopsReadRateMax(), vol.getIopsReadRateMaxLength(),\n                    vol.getIopsWriteRate(), vol.getIopsWriteRateMax(), vol.getIopsWriteRateMaxLength());\n\n            return new AttachAnswer(disk);\n        } catch (final LibvirtException e) {\n            s_logger.debug(\"Failed to attach volume: \" + vol.getPath() + \", due to \", e);\n            storagePoolMgr.disconnectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n            return new AttachAnswer(e.toString());\n        } catch (final InternalErrorException e) {\n            s_logger.debug(\"Failed to attach volume: \" + vol.getPath() + \", due to \", e);\n            return new AttachAnswer(e.toString());\n        }\n    }\n","date":"2019-02-05 05:47:44","endLine":1323,"groupId":"8934","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"attachVolume","params":"(finalAttachCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/83/a7a12d22ba9019b86650fda3b082f87954e079.src","preCode":"    public Answer attachVolume(final AttachCommand cmd) {\n        final DiskTO disk = cmd.getDisk();\n        final VolumeObjectTO vol = (VolumeObjectTO)disk.getData();\n        final PrimaryDataStoreTO primaryStore = (PrimaryDataStoreTO)vol.getDataStore();\n        final String vmName = cmd.getVmName();\n        final String serial = resource.diskUuidToSerial(vol.getUuid());\n        try {\n            final Connect conn = LibvirtConnection.getConnectionByVmName(vmName);\n\n            storagePoolMgr.connectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath(), disk.getDetails());\n\n            final KVMPhysicalDisk phyDisk = storagePoolMgr.getPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n\n            attachOrDetachDisk(conn, true, vmName, phyDisk, disk.getDiskSeq().intValue(), serial, vol.getBytesReadRate(), vol.getBytesWriteRate(), vol.getIopsReadRate(), vol.getIopsWriteRate());\n\n            return new AttachAnswer(disk);\n        } catch (final LibvirtException e) {\n            s_logger.debug(\"Failed to attach volume: \" + vol.getPath() + \", due to \", e);\n            storagePoolMgr.disconnectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n            return new AttachAnswer(e.toString());\n        } catch (final InternalErrorException e) {\n            s_logger.debug(\"Failed to attach volume: \" + vol.getPath() + \", due to \", e);\n            return new AttachAnswer(e.toString());\n        }\n    }\n","realPath":"plugins/hypervisors/kvm/src/main/java/com/cloud/hypervisor/kvm/storage/KVMStorageProcessor.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1295,"status":"M"},{"authorDate":"2019-02-05 05:47:44","commitOrder":3,"curCode":"    public Answer dettachVolume(final DettachCommand cmd) {\n        final DiskTO disk = cmd.getDisk();\n        final VolumeObjectTO vol = (VolumeObjectTO)disk.getData();\n        final PrimaryDataStoreTO primaryStore = (PrimaryDataStoreTO)vol.getDataStore();\n        final String vmName = cmd.getVmName();\n        final String serial = resource.diskUuidToSerial(vol.getUuid());\n        try {\n            final Connect conn = LibvirtConnection.getConnectionByVmName(vmName);\n\n            final KVMPhysicalDisk phyDisk = storagePoolMgr.getPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n\n            attachOrDetachDisk(conn, false, vmName, phyDisk, disk.getDiskSeq().intValue(), serial,\n                    vol.getBytesReadRate(), vol.getBytesReadRateMax(), vol.getBytesReadRateMaxLength(),\n                    vol.getBytesWriteRate(), vol.getBytesWriteRateMax(), vol.getBytesWriteRateMaxLength(),\n                    vol.getIopsReadRate(), vol.getIopsReadRateMax(), vol.getIopsReadRateMaxLength(),\n                    vol.getIopsWriteRate(), vol.getIopsWriteRateMax(), vol.getIopsWriteRateMaxLength());\n\n            storagePoolMgr.disconnectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n\n            return new DettachAnswer(disk);\n        } catch (final LibvirtException e) {\n            s_logger.debug(\"Failed to detach volume: \" + vol.getPath() + \", due to \", e);\n            return new DettachAnswer(e.toString());\n        } catch (final InternalErrorException e) {\n            s_logger.debug(\"Failed to detach volume: \" + vol.getPath() + \", due to \", e);\n            return new DettachAnswer(e.toString());\n        }\n    }\n","date":"2019-02-05 05:47:44","endLine":1353,"groupId":"18172","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"dettachVolume","params":"(finalDettachCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/83/a7a12d22ba9019b86650fda3b082f87954e079.src","preCode":"    public Answer dettachVolume(final DettachCommand cmd) {\n        final DiskTO disk = cmd.getDisk();\n        final VolumeObjectTO vol = (VolumeObjectTO)disk.getData();\n        final PrimaryDataStoreTO primaryStore = (PrimaryDataStoreTO)vol.getDataStore();\n        final String vmName = cmd.getVmName();\n        final String serial = resource.diskUuidToSerial(vol.getUuid());\n        try {\n            final Connect conn = LibvirtConnection.getConnectionByVmName(vmName);\n\n            final KVMPhysicalDisk phyDisk = storagePoolMgr.getPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n\n            attachOrDetachDisk(conn, false, vmName, phyDisk, disk.getDiskSeq().intValue(), serial, vol.getBytesReadRate(), vol.getBytesWriteRate(), vol.getIopsReadRate(), vol.getIopsWriteRate());\n\n            storagePoolMgr.disconnectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n\n            return new DettachAnswer(disk);\n        } catch (final LibvirtException e) {\n            s_logger.debug(\"Failed to detach volume: \" + vol.getPath() + \", due to \", e);\n            return new DettachAnswer(e.toString());\n        } catch (final InternalErrorException e) {\n            s_logger.debug(\"Failed to detach volume: \" + vol.getPath() + \", due to \", e);\n            return new DettachAnswer(e.toString());\n        }\n    }\n","realPath":"plugins/hypervisors/kvm/src/main/java/com/cloud/hypervisor/kvm/storage/KVMStorageProcessor.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1326,"status":"M"}],"commitId":"637cc6ec4ec4f1d15ceb4c792ac737a14330b3a7","commitMessage":"@@@feature: add libvirt / qemu io bursting (#3133)\n\n* feature: add libvirt / qemu io bursting\n\nAdds the ability to set bursting features from libvirt / qemu\n\nThis allows you to utilize the iops and bytes temporary \"burst\" mode\nintroduced with libvirt 2.4 and improved upon with libvirt 2.6.\n\nhttps://blogs.igalia.com/berto/2016/05/24/io-bursts-with-qemu-2-6/\n\n* updates per rafael et al\n","date":"2019-02-05 05:47:44","modifiedFileCount":"20","status":"M","submitter":"Nathan Johnson"},{"authorTime":"2020-03-09 20:17:21","codes":[{"authorDate":"2020-03-09 20:17:21","commitOrder":4,"curCode":"    public Answer attachVolume(final AttachCommand cmd) {\n        final DiskTO disk = cmd.getDisk();\n        final VolumeObjectTO vol = (VolumeObjectTO)disk.getData();\n        final PrimaryDataStoreTO primaryStore = (PrimaryDataStoreTO)vol.getDataStore();\n        final String vmName = cmd.getVmName();\n        final String serial = resource.diskUuidToSerial(vol.getUuid());\n        try {\n            final Connect conn = LibvirtConnection.getConnectionByVmName(vmName);\n\n            storagePoolMgr.connectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath(), disk.getDetails());\n\n            final KVMPhysicalDisk phyDisk = storagePoolMgr.getPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n            final String volCacheMode = vol.getCacheMode() == null ? null : vol.getCacheMode().toString();\n\n            attachOrDetachDisk(conn, true, vmName, phyDisk, disk.getDiskSeq().intValue(), serial,\n                    vol.getBytesReadRate(), vol.getBytesReadRateMax(), vol.getBytesReadRateMaxLength(),\n                    vol.getBytesWriteRate(), vol.getBytesWriteRateMax(), vol.getBytesWriteRateMaxLength(),\n                    vol.getIopsReadRate(), vol.getIopsReadRateMax(), vol.getIopsReadRateMaxLength(),\n                    vol.getIopsWriteRate(), vol.getIopsWriteRateMax(), vol.getIopsWriteRateMaxLength(), volCacheMode);\n\n            return new AttachAnswer(disk);\n        } catch (final LibvirtException e) {\n            s_logger.debug(\"Failed to attach volume: \" + vol.getPath() + \", due to \", e);\n            storagePoolMgr.disconnectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n            return new AttachAnswer(e.toString());\n        } catch (final InternalErrorException e) {\n            s_logger.debug(\"Failed to attach volume: \" + vol.getPath() + \", due to \", e);\n            return new AttachAnswer(e.toString());\n        }\n    }\n","date":"2020-03-09 20:17:21","endLine":1328,"groupId":"8934","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"attachVolume","params":"(finalAttachCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/da/b80c9dc19f06c67cb822ccf9eda73f23f3c776.src","preCode":"    public Answer attachVolume(final AttachCommand cmd) {\n        final DiskTO disk = cmd.getDisk();\n        final VolumeObjectTO vol = (VolumeObjectTO)disk.getData();\n        final PrimaryDataStoreTO primaryStore = (PrimaryDataStoreTO)vol.getDataStore();\n        final String vmName = cmd.getVmName();\n        final String serial = resource.diskUuidToSerial(vol.getUuid());\n        try {\n            final Connect conn = LibvirtConnection.getConnectionByVmName(vmName);\n\n            storagePoolMgr.connectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath(), disk.getDetails());\n\n            final KVMPhysicalDisk phyDisk = storagePoolMgr.getPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n\n            attachOrDetachDisk(conn, true, vmName, phyDisk, disk.getDiskSeq().intValue(), serial,\n                    vol.getBytesReadRate(), vol.getBytesReadRateMax(), vol.getBytesReadRateMaxLength(),\n                    vol.getBytesWriteRate(), vol.getBytesWriteRateMax(), vol.getBytesWriteRateMaxLength(),\n                    vol.getIopsReadRate(), vol.getIopsReadRateMax(), vol.getIopsReadRateMaxLength(),\n                    vol.getIopsWriteRate(), vol.getIopsWriteRateMax(), vol.getIopsWriteRateMaxLength());\n\n            return new AttachAnswer(disk);\n        } catch (final LibvirtException e) {\n            s_logger.debug(\"Failed to attach volume: \" + vol.getPath() + \", due to \", e);\n            storagePoolMgr.disconnectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n            return new AttachAnswer(e.toString());\n        } catch (final InternalErrorException e) {\n            s_logger.debug(\"Failed to attach volume: \" + vol.getPath() + \", due to \", e);\n            return new AttachAnswer(e.toString());\n        }\n    }\n","realPath":"plugins/hypervisors/kvm/src/main/java/com/cloud/hypervisor/kvm/storage/KVMStorageProcessor.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1299,"status":"M"},{"authorDate":"2020-03-09 20:17:21","commitOrder":4,"curCode":"    public Answer dettachVolume(final DettachCommand cmd) {\n        final DiskTO disk = cmd.getDisk();\n        final VolumeObjectTO vol = (VolumeObjectTO)disk.getData();\n        final PrimaryDataStoreTO primaryStore = (PrimaryDataStoreTO)vol.getDataStore();\n        final String vmName = cmd.getVmName();\n        final String serial = resource.diskUuidToSerial(vol.getUuid());\n        try {\n            final Connect conn = LibvirtConnection.getConnectionByVmName(vmName);\n\n            final KVMPhysicalDisk phyDisk = storagePoolMgr.getPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n            final String volCacheMode = vol.getCacheMode() == null ? null : vol.getCacheMode().toString();\n\n            attachOrDetachDisk(conn, false, vmName, phyDisk, disk.getDiskSeq().intValue(), serial,\n                    vol.getBytesReadRate(), vol.getBytesReadRateMax(), vol.getBytesReadRateMaxLength(),\n                    vol.getBytesWriteRate(), vol.getBytesWriteRateMax(), vol.getBytesWriteRateMaxLength(),\n                    vol.getIopsReadRate(), vol.getIopsReadRateMax(), vol.getIopsReadRateMaxLength(),\n                    vol.getIopsWriteRate(), vol.getIopsWriteRateMax(), vol.getIopsWriteRateMaxLength(), volCacheMode);\n\n            storagePoolMgr.disconnectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n\n            return new DettachAnswer(disk);\n        } catch (final LibvirtException e) {\n            s_logger.debug(\"Failed to detach volume: \" + vol.getPath() + \", due to \", e);\n            return new DettachAnswer(e.toString());\n        } catch (final InternalErrorException e) {\n            s_logger.debug(\"Failed to detach volume: \" + vol.getPath() + \", due to \", e);\n            return new DettachAnswer(e.toString());\n        }\n    }\n","date":"2020-03-09 20:17:21","endLine":1359,"groupId":"8930","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"dettachVolume","params":"(finalDettachCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/da/b80c9dc19f06c67cb822ccf9eda73f23f3c776.src","preCode":"    public Answer dettachVolume(final DettachCommand cmd) {\n        final DiskTO disk = cmd.getDisk();\n        final VolumeObjectTO vol = (VolumeObjectTO)disk.getData();\n        final PrimaryDataStoreTO primaryStore = (PrimaryDataStoreTO)vol.getDataStore();\n        final String vmName = cmd.getVmName();\n        final String serial = resource.diskUuidToSerial(vol.getUuid());\n        try {\n            final Connect conn = LibvirtConnection.getConnectionByVmName(vmName);\n\n            final KVMPhysicalDisk phyDisk = storagePoolMgr.getPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n\n            attachOrDetachDisk(conn, false, vmName, phyDisk, disk.getDiskSeq().intValue(), serial,\n                    vol.getBytesReadRate(), vol.getBytesReadRateMax(), vol.getBytesReadRateMaxLength(),\n                    vol.getBytesWriteRate(), vol.getBytesWriteRateMax(), vol.getBytesWriteRateMaxLength(),\n                    vol.getIopsReadRate(), vol.getIopsReadRateMax(), vol.getIopsReadRateMaxLength(),\n                    vol.getIopsWriteRate(), vol.getIopsWriteRateMax(), vol.getIopsWriteRateMaxLength());\n\n            storagePoolMgr.disconnectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n\n            return new DettachAnswer(disk);\n        } catch (final LibvirtException e) {\n            s_logger.debug(\"Failed to detach volume: \" + vol.getPath() + \", due to \", e);\n            return new DettachAnswer(e.toString());\n        } catch (final InternalErrorException e) {\n            s_logger.debug(\"Failed to detach volume: \" + vol.getPath() + \", due to \", e);\n            return new DettachAnswer(e.toString());\n        }\n    }\n","realPath":"plugins/hypervisors/kvm/src/main/java/com/cloud/hypervisor/kvm/storage/KVMStorageProcessor.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1331,"status":"M"}],"commitId":"d549f3bdc8e70400c3c0330ab97afc9df5efc0ea","commitMessage":"@@@Add cache mode param properly (#3925)\n\n","date":"2020-03-09 20:17:21","modifiedFileCount":"8","status":"M","submitter":"Radu Todirica"},{"authorTime":"2021-02-24 17:28:33","codes":[{"authorDate":"2021-02-24 17:28:33","commitOrder":5,"curCode":"    public Answer attachVolume(final AttachCommand cmd) {\n        final DiskTO disk = cmd.getDisk();\n        final VolumeObjectTO vol = (VolumeObjectTO)disk.getData();\n        final PrimaryDataStoreTO primaryStore = (PrimaryDataStoreTO)vol.getDataStore();\n        final String vmName = cmd.getVmName();\n        final String serial = resource.diskUuidToSerial(vol.getUuid());\n        try {\n            final Connect conn = LibvirtConnection.getConnectionByVmName(vmName);\n\n            storagePoolMgr.connectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath(), disk.getDetails());\n\n            final KVMPhysicalDisk phyDisk = storagePoolMgr.getPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n            final String volCacheMode = vol.getCacheMode() == null ? null : vol.getCacheMode().toString();\n\n            attachOrDetachDisk(conn, true, vmName, phyDisk, disk.getDiskSeq().intValue(), serial,\n                    vol.getBytesReadRate(), vol.getBytesReadRateMax(), vol.getBytesReadRateMaxLength(),\n                    vol.getBytesWriteRate(), vol.getBytesWriteRateMax(), vol.getBytesWriteRateMaxLength(),\n                    vol.getIopsReadRate(), vol.getIopsReadRateMax(), vol.getIopsReadRateMaxLength(),\n                    vol.getIopsWriteRate(), vol.getIopsWriteRateMax(), vol.getIopsWriteRateMaxLength(), volCacheMode);\n\n            return new AttachAnswer(disk);\n        } catch (final LibvirtException e) {\n            s_logger.debug(\"Failed to attach volume: \" + vol.getPath() + \", due to \", e);\n            storagePoolMgr.disconnectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n            return new AttachAnswer(e.toString());\n        } catch (final InternalErrorException e) {\n            s_logger.debug(\"Failed to attach volume: \" + vol.getPath() + \", due to \", e);\n            return new AttachAnswer(e.toString());\n        } catch (final CloudRuntimeException e) {\n            s_logger.debug(\"Failed to attach volume: \" + vol.getPath() + \", due to \", e);\n            return new AttachAnswer(e.toString());\n        }\n    }\n","date":"2021-02-24 17:28:33","endLine":1377,"groupId":"103372","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"attachVolume","params":"(finalAttachCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/d1/d0f0c262f9362dca8830a6a0af00a52f93759d.src","preCode":"    public Answer attachVolume(final AttachCommand cmd) {\n        final DiskTO disk = cmd.getDisk();\n        final VolumeObjectTO vol = (VolumeObjectTO)disk.getData();\n        final PrimaryDataStoreTO primaryStore = (PrimaryDataStoreTO)vol.getDataStore();\n        final String vmName = cmd.getVmName();\n        final String serial = resource.diskUuidToSerial(vol.getUuid());\n        try {\n            final Connect conn = LibvirtConnection.getConnectionByVmName(vmName);\n\n            storagePoolMgr.connectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath(), disk.getDetails());\n\n            final KVMPhysicalDisk phyDisk = storagePoolMgr.getPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n            final String volCacheMode = vol.getCacheMode() == null ? null : vol.getCacheMode().toString();\n\n            attachOrDetachDisk(conn, true, vmName, phyDisk, disk.getDiskSeq().intValue(), serial,\n                    vol.getBytesReadRate(), vol.getBytesReadRateMax(), vol.getBytesReadRateMaxLength(),\n                    vol.getBytesWriteRate(), vol.getBytesWriteRateMax(), vol.getBytesWriteRateMaxLength(),\n                    vol.getIopsReadRate(), vol.getIopsReadRateMax(), vol.getIopsReadRateMaxLength(),\n                    vol.getIopsWriteRate(), vol.getIopsWriteRateMax(), vol.getIopsWriteRateMaxLength(), volCacheMode);\n\n            return new AttachAnswer(disk);\n        } catch (final LibvirtException e) {\n            s_logger.debug(\"Failed to attach volume: \" + vol.getPath() + \", due to \", e);\n            storagePoolMgr.disconnectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n            return new AttachAnswer(e.toString());\n        } catch (final InternalErrorException e) {\n            s_logger.debug(\"Failed to attach volume: \" + vol.getPath() + \", due to \", e);\n            return new AttachAnswer(e.toString());\n        }\n    }\n","realPath":"plugins/hypervisors/kvm/src/main/java/com/cloud/hypervisor/kvm/storage/KVMStorageProcessor.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1345,"status":"M"},{"authorDate":"2021-02-24 17:28:33","commitOrder":5,"curCode":"    public Answer dettachVolume(final DettachCommand cmd) {\n        final DiskTO disk = cmd.getDisk();\n        final VolumeObjectTO vol = (VolumeObjectTO)disk.getData();\n        final PrimaryDataStoreTO primaryStore = (PrimaryDataStoreTO)vol.getDataStore();\n        final String vmName = cmd.getVmName();\n        final String serial = resource.diskUuidToSerial(vol.getUuid());\n        try {\n            final Connect conn = LibvirtConnection.getConnectionByVmName(vmName);\n\n            final KVMPhysicalDisk phyDisk = storagePoolMgr.getPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n            final String volCacheMode = vol.getCacheMode() == null ? null : vol.getCacheMode().toString();\n\n            attachOrDetachDisk(conn, false, vmName, phyDisk, disk.getDiskSeq().intValue(), serial,\n                    vol.getBytesReadRate(), vol.getBytesReadRateMax(), vol.getBytesReadRateMaxLength(),\n                    vol.getBytesWriteRate(), vol.getBytesWriteRateMax(), vol.getBytesWriteRateMaxLength(),\n                    vol.getIopsReadRate(), vol.getIopsReadRateMax(), vol.getIopsReadRateMaxLength(),\n                    vol.getIopsWriteRate(), vol.getIopsWriteRateMax(), vol.getIopsWriteRateMaxLength(), volCacheMode);\n\n            storagePoolMgr.disconnectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n\n            return new DettachAnswer(disk);\n        } catch (final LibvirtException e) {\n            s_logger.debug(\"Failed to detach volume: \" + vol.getPath() + \", due to \", e);\n            return new DettachAnswer(e.toString());\n        } catch (final InternalErrorException e) {\n            s_logger.debug(\"Failed to detach volume: \" + vol.getPath() + \", due to \", e);\n            return new DettachAnswer(e.toString());\n        } catch (final CloudRuntimeException e) {\n            s_logger.debug(\"Failed to detach volume: \" + vol.getPath() + \", due to \", e);\n            return new DettachAnswer(e.toString());\n        }\n    }\n","date":"2021-02-24 17:28:33","endLine":1411,"groupId":"103372","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"dettachVolume","params":"(finalDettachCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/d1/d0f0c262f9362dca8830a6a0af00a52f93759d.src","preCode":"    public Answer dettachVolume(final DettachCommand cmd) {\n        final DiskTO disk = cmd.getDisk();\n        final VolumeObjectTO vol = (VolumeObjectTO)disk.getData();\n        final PrimaryDataStoreTO primaryStore = (PrimaryDataStoreTO)vol.getDataStore();\n        final String vmName = cmd.getVmName();\n        final String serial = resource.diskUuidToSerial(vol.getUuid());\n        try {\n            final Connect conn = LibvirtConnection.getConnectionByVmName(vmName);\n\n            final KVMPhysicalDisk phyDisk = storagePoolMgr.getPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n            final String volCacheMode = vol.getCacheMode() == null ? null : vol.getCacheMode().toString();\n\n            attachOrDetachDisk(conn, false, vmName, phyDisk, disk.getDiskSeq().intValue(), serial,\n                    vol.getBytesReadRate(), vol.getBytesReadRateMax(), vol.getBytesReadRateMaxLength(),\n                    vol.getBytesWriteRate(), vol.getBytesWriteRateMax(), vol.getBytesWriteRateMaxLength(),\n                    vol.getIopsReadRate(), vol.getIopsReadRateMax(), vol.getIopsReadRateMaxLength(),\n                    vol.getIopsWriteRate(), vol.getIopsWriteRateMax(), vol.getIopsWriteRateMaxLength(), volCacheMode);\n\n            storagePoolMgr.disconnectPhysicalDisk(primaryStore.getPoolType(), primaryStore.getUuid(), vol.getPath());\n\n            return new DettachAnswer(disk);\n        } catch (final LibvirtException e) {\n            s_logger.debug(\"Failed to detach volume: \" + vol.getPath() + \", due to \", e);\n            return new DettachAnswer(e.toString());\n        } catch (final InternalErrorException e) {\n            s_logger.debug(\"Failed to detach volume: \" + vol.getPath() + \", due to \", e);\n            return new DettachAnswer(e.toString());\n        }\n    }\n","realPath":"plugins/hypervisors/kvm/src/main/java/com/cloud/hypervisor/kvm/storage/KVMStorageProcessor.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1380,"status":"M"}],"commitId":"eba186aa40f16911c019bf06cd33d7d0cbbc303b","commitMessage":"@@@storage: New Dell EMC PowerFlex Plugin (formerly ScaleIO.  VxFlexOS) (#4304)\n\nAdded support for PowerFlex/ScaleIO (v3.5 onwards) storage pool as a primary storage in CloudStack (for KVM hypervisor) and enabled VM/Volume operations on that pool (using pool tag).\nPlease find more details in the FS here:\nhttps://cwiki.apache.org/confluence/x/cDl4CQ\n\nDocumentation PR: apache/cloudstack-documentation#169\n\nThis enables support for PowerFlex/ScaleIO (v3.5 onwards) storage pool as a primary storage in CloudStack\n\nOther improvements addressed in addition to PowerFlex/ScaleIO support:\n\n- Added support for config drives in host cache for KVM\n\t=> Changed configuration \"vm.configdrive.primarypool.enabled\" scope from Global to Zone level\n\t=> Introduced new zone level configuration \"vm.configdrive.force.host.cache.use\" (default: false) to force host cache for config drives\n\t=> Introduced new zone level configuration \"vm.configdrive.use.host.cache.on.unsupported.pool\" (default: true) to use host cache for config drives when storage pool doesn't support config drive\n\t=> Added new parameter \"host.cache.location\" (default: /var/cache/cloud) in KVM agent.properties for specifying the host cache path and create config drives on the \"/config\" directory on the host cache path\n\t=> Maintain the config drive location and use it when required on any config drive operation (migrate.  delete)\n\n- Detect virtual size from the template URL while registering direct download qcow2 (of KVM hypervisor) templates\n\n- Updated full deployment destination for preparing the network(s) on VM start\n\n- Propagate the direct download certificates uploaded to the newly added KVM hosts\n\n- Discover the template size for direct download templates using any available host from the zones specified on template registration\n\t=> When zones are not specified while registering template.  template size discovery is performed using any available host.  which is picked up randomly from one of the available zones\n\n- Release the VM resources when VM is sync-ed to Stopped state on PowerReportMissing (after graceful period)\n\n- Retry VM deployment/start when the host cannot grant access to volume/template\n\n- Mark never-used or downloaded templates as Destroyed on deletion.  without sending any DeleteCommand\n\t=> Do not trigger any DeleteCommand for never-used or downloaded templates as these doesn't exist and cannot be deleted from the datastore\n\n- Check the router filesystem is writable or not.  before performing health checks\n\t=> Introduce a new test \"filesystem.writable.test\" to check the filesystem is writable or not\n\t=> The router health checks keeps the config info at \"/var/cache/cloud\" and updates the monitor results at \"/root\" for health checks.  both are different partitions. So.  test at both the locations.\n\t=> Added new script: \"filesystem_writable_check.py\" at /opt/cloud/bin/ to check the filesystem is writable or not\n\n- Fixed NPE issue.  template is null for DATA disks. Copy template to target storage for ROOT disk (with template id).  skip DATA disk(s)\n\n* Addressed some issues for few operations on PowerFlex storage pool.\n\n- Updated migration volume operation to sync the status and wait for migration to complete.\n\n- Updated VM Snapshot naming.  for uniqueness in ScaleIO volume name when more than one volume exists in the VM.\n\n- Added sync lock while spooling managed storage template before volume creation from the template (non-direct download).\n\n- Updated resize volume error message string.\n\n- Blocked the below operations on PowerFlex storage pool:\n  -> Extract Volume\n  -> Create Snapshot for VMSnapshot\n\n* Added the PowerFlex/ScaleIO client connection pool to manage the ScaleIO gateway clients.  which uses a single gateway client per Powerflex/ScaleIO storage pool and renews it when the session token expires.\n\n- The token is valid for 8 hours from the time it was created.  unless there has been no activity for 10 minutes.\n  Reference: https://cpsdocs.dellemc.com/bundle/PF_REST_API_RG/page/GUID-92430F19-9F44-42B6-B898-87D5307AE59B.html\n\nOther fixes included:\n\n- Fail the VM deployment when the host specified in the deployVirtualMachine cmd is not in the right state (i.e. either Resource State is not Enabled or Status is not Up)\n\n- Use the physical file size of the template to check the free space availability on the host.  while downloading the direct download templates.\n\n- Perform basic tests (for connectivity and file system) on router before updating the health check config data\n\t=> Validate the basic tests (connectivity and file system check) on router\n\t=> Cleanup the health check results when router is destroyed\n\n* Updated PowerFlex/ScaleIO storage plugin version to 4.16.0.0\n\n* UI Changes to support storage plugin for PowerFlex/ScaleIO storage pool.\n- PowerFlex pool URL generated from the UI inputs(Gateway.  Username.  Password.  Storage Pool) when adding \"PowerFlex\" Primary Storage\n- Updated protocol to \"custom\" for PowerFlex provider\n- Allow VM Snapshot for stopped VM on KVM hypervisor and PowerFlex/ScaleIO storage pool\n\nand Minor improvements in PowerFlex/ScaleIO storage plugin code\n\n* Added support for PowerFlex/ScaleIO volume migration across different PowerFlex storage instances.\n\n- findStoragePoolsForMigration API returns PowerFlex pool(s) of different instance as suitable pool(s).  for volume(s) on PowerFlex storage pool.\n- Volume(s) with snapshots are not allowed to migrate to different PowerFlex instance.\n- Volume(s) of running VM are not allowed to migrate to other PowerFlex storage pools.\n- Volume migration from PowerFlex pool to Non-PowerFlex pool.  and vice versa are not supported.\n\n* Fixed change service offering smoke tests in test_service_offerings.py.  test_vm_snapshots.py\n\n* Added the PowerFlex/ScaleIO volume/snapshot name to the paths of respective CloudStack resources (Templates.  Volumes.  Snapshots and VM Snapshots)\n\n* Added new response parameter ?supportsStorageSnapshot? (true/false) to volume response.  and Updated UI to hide the async backup option while taking snapshot for volume(s) with storage snapshot support.\n\n* Fix to remove the duplicate zone wide pools listed while finding storage pools for migration\n\n* Updated PowerFlex/ScaleIO volume migration checks and rollback migration on failure\n\n* Fixed the PowerFlex/ScaleIO volume name inconsistency issue in the volume path after migration.  due to rename failure","date":"2021-02-24 17:28:33","modifiedFileCount":"112","status":"M","submitter":"sureshanaparti"}]
