[{"authorTime":"2020-06-26 19:31:43","codes":[{"authorDate":"2020-06-09 11:00:51","commitOrder":4,"curCode":"    protected void advanceExpunge(VMInstanceVO vm) throws ResourceUnavailableException, OperationTimedoutException, ConcurrentOperationException {\n        if (vm == null || vm.getRemoved() != null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find vm or vm is destroyed: \" + vm);\n            }\n            return;\n        }\n\n        advanceStop(vm.getUuid(), VmDestroyForcestop.value());\n        vm = _vmDao.findByUuid(vm.getUuid());\n\n        try {\n            if (!stateTransitTo(vm, VirtualMachine.Event.ExpungeOperation, vm.getHostId())) {\n                s_logger.debug(\"Unable to destroy the vm because it is not in the correct state: \" + vm);\n                throw new CloudRuntimeException(\"Unable to destroy \" + vm);\n\n            }\n        } catch (final NoTransitionException e) {\n            s_logger.debug(\"Unable to destroy the vm because it is not in the correct state: \" + vm);\n            throw new CloudRuntimeException(\"Unable to destroy \" + vm, e);\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Destroying vm \" + vm);\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        s_logger.debug(\"Cleaning up NICS\");\n        final List<Command> nicExpungeCommands = hvGuru.finalizeExpungeNics(vm, profile.getNics());\n        _networkMgr.cleanupNics(profile);\n\n        s_logger.debug(\"Cleaning up hypervisor data structures (ex. SRs in XenServer) for managed storage\");\n\n        final List<Command> volumeExpungeCommands = hvGuru.finalizeExpungeVolumes(vm);\n\n        final Long hostId = vm.getHostId() != null ? vm.getHostId() : vm.getLastHostId();\n\n        List<Map<String, String>> targets = getTargets(hostId, vm.getId());\n\n        if (volumeExpungeCommands != null && volumeExpungeCommands.size() > 0 && hostId != null) {\n            final Commands cmds = new Commands(Command.OnError.Stop);\n\n            for (final Command volumeExpungeCommand : volumeExpungeCommands) {\n                cmds.addCommand(volumeExpungeCommand);\n            }\n\n            _agentMgr.send(hostId, cmds);\n\n            if (!cmds.isSuccessful()) {\n                for (final Answer answer : cmds.getAnswers()) {\n                    if (!answer.getResult()) {\n                        s_logger.warn(\"Failed to expunge vm due to: \" + answer.getDetails());\n\n                        throw new CloudRuntimeException(\"Unable to expunge \" + vm + \" due to \" + answer.getDetails());\n                    }\n                }\n            }\n        }\n\n        if (hostId != null) {\n            volumeMgr.revokeAccess(vm.getId(), hostId);\n        }\n\n        \r\n        volumeMgr.cleanupVolumes(vm.getId());\n\n        if (hostId != null && CollectionUtils.isNotEmpty(targets)) {\n            removeDynamicTargets(hostId, targets);\n        }\n\n        final VirtualMachineGuru guru = getVmGuru(vm);\n        guru.finalizeExpunge(vm);\n        \r\n        userVmDetailsDao.removeDetails(vm.getId());\n\n        \r\n        final List<Command> finalizeExpungeCommands = hvGuru.finalizeExpunge(vm);\n        if (finalizeExpungeCommands != null && finalizeExpungeCommands.size() > 0) {\n            if (hostId != null) {\n                final Commands cmds = new Commands(Command.OnError.Stop);\n                for (final Command command : finalizeExpungeCommands) {\n                    cmds.addCommand(command);\n                }\n                if (nicExpungeCommands != null) {\n                    for (final Command command : nicExpungeCommands) {\n                        cmds.addCommand(command);\n                    }\n                }\n                _agentMgr.send(hostId, cmds);\n                if (!cmds.isSuccessful()) {\n                    for (final Answer answer : cmds.getAnswers()) {\n                        if (!answer.getResult()) {\n                            s_logger.warn(\"Failed to expunge vm due to: \" + answer.getDetails());\n                            throw new CloudRuntimeException(\"Unable to expunge \" + vm + \" due to \" + answer.getDetails());\n                        }\n                    }\n                }\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Expunged \" + vm);\n        }\n\n    }\n","date":"2020-06-09 11:00:51","endLine":617,"groupId":"22273","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"advanceExpunge","params":"(VMInstanceVOvm)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/88/9777442fd2e16825ff71b0deae1669fbd8152d.src","preCode":"    protected void advanceExpunge(VMInstanceVO vm) throws ResourceUnavailableException, OperationTimedoutException, ConcurrentOperationException {\n        if (vm == null || vm.getRemoved() != null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find vm or vm is destroyed: \" + vm);\n            }\n            return;\n        }\n\n        advanceStop(vm.getUuid(), VmDestroyForcestop.value());\n        vm = _vmDao.findByUuid(vm.getUuid());\n\n        try {\n            if (!stateTransitTo(vm, VirtualMachine.Event.ExpungeOperation, vm.getHostId())) {\n                s_logger.debug(\"Unable to destroy the vm because it is not in the correct state: \" + vm);\n                throw new CloudRuntimeException(\"Unable to destroy \" + vm);\n\n            }\n        } catch (final NoTransitionException e) {\n            s_logger.debug(\"Unable to destroy the vm because it is not in the correct state: \" + vm);\n            throw new CloudRuntimeException(\"Unable to destroy \" + vm, e);\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Destroying vm \" + vm);\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        s_logger.debug(\"Cleaning up NICS\");\n        final List<Command> nicExpungeCommands = hvGuru.finalizeExpungeNics(vm, profile.getNics());\n        _networkMgr.cleanupNics(profile);\n\n        s_logger.debug(\"Cleaning up hypervisor data structures (ex. SRs in XenServer) for managed storage\");\n\n        final List<Command> volumeExpungeCommands = hvGuru.finalizeExpungeVolumes(vm);\n\n        final Long hostId = vm.getHostId() != null ? vm.getHostId() : vm.getLastHostId();\n\n        List<Map<String, String>> targets = getTargets(hostId, vm.getId());\n\n        if (volumeExpungeCommands != null && volumeExpungeCommands.size() > 0 && hostId != null) {\n            final Commands cmds = new Commands(Command.OnError.Stop);\n\n            for (final Command volumeExpungeCommand : volumeExpungeCommands) {\n                cmds.addCommand(volumeExpungeCommand);\n            }\n\n            _agentMgr.send(hostId, cmds);\n\n            if (!cmds.isSuccessful()) {\n                for (final Answer answer : cmds.getAnswers()) {\n                    if (!answer.getResult()) {\n                        s_logger.warn(\"Failed to expunge vm due to: \" + answer.getDetails());\n\n                        throw new CloudRuntimeException(\"Unable to expunge \" + vm + \" due to \" + answer.getDetails());\n                    }\n                }\n            }\n        }\n\n        if (hostId != null) {\n            volumeMgr.revokeAccess(vm.getId(), hostId);\n        }\n\n        \r\n        volumeMgr.cleanupVolumes(vm.getId());\n\n        if (hostId != null && CollectionUtils.isNotEmpty(targets)) {\n            removeDynamicTargets(hostId, targets);\n        }\n\n        final VirtualMachineGuru guru = getVmGuru(vm);\n        guru.finalizeExpunge(vm);\n        \r\n        userVmDetailsDao.removeDetails(vm.getId());\n\n        \r\n        final List<Command> finalizeExpungeCommands = hvGuru.finalizeExpunge(vm);\n        if (finalizeExpungeCommands != null && finalizeExpungeCommands.size() > 0) {\n            if (hostId != null) {\n                final Commands cmds = new Commands(Command.OnError.Stop);\n                for (final Command command : finalizeExpungeCommands) {\n                    cmds.addCommand(command);\n                }\n                if (nicExpungeCommands != null) {\n                    for (final Command command : nicExpungeCommands) {\n                        cmds.addCommand(command);\n                    }\n                }\n                _agentMgr.send(hostId, cmds);\n                if (!cmds.isSuccessful()) {\n                    for (final Answer answer : cmds.getAnswers()) {\n                        if (!answer.getResult()) {\n                            s_logger.warn(\"Failed to expunge vm due to: \" + answer.getDetails());\n                            throw new CloudRuntimeException(\"Unable to expunge \" + vm + \" due to \" + answer.getDetails());\n                        }\n                    }\n                }\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Expunged \" + vm);\n        }\n\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":510,"status":"NB"},{"authorDate":"2020-06-26 19:31:43","commitOrder":4,"curCode":"    private void unmanageVMVolumes(VMInstanceVO vm) {\n        final Long hostId = vm.getHostId() != null ? vm.getHostId() : vm.getLastHostId();\n        if (hostId != null) {\n            volumeMgr.revokeAccess(vm.getId(), hostId);\n        }\n        volumeMgr.unmanageVolumes(vm.getId());\n\n        List<Map<String, String>> targets = getTargets(hostId, vm.getId());\n        if (hostId != null && CollectionUtils.isNotEmpty(targets)) {\n            removeDynamicTargets(hostId, targets);\n        }\n    }\n","date":"2020-06-26 19:31:43","endLine":1559,"groupId":"12896","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"unmanageVMVolumes","params":"(VMInstanceVOvm)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/e7/4e6fffa4dcf33f9201aae9be26180bfc4fdd4e.src","preCode":"    private void unmanageVMVolumes(VMInstanceVO vm) {\n        final Long hostId = vm.getHostId() != null ? vm.getHostId() : vm.getLastHostId();\n        if (hostId != null) {\n            volumeMgr.revokeAccess(vm.getId(), hostId);\n        }\n        volumeMgr.unmanageVolumes(vm.getId());\n\n        List<Map<String, String>> targets = getTargets(hostId, vm.getId());\n        if (hostId != null && CollectionUtils.isNotEmpty(targets)) {\n            removeDynamicTargets(hostId, targets);\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1548,"status":"B"}],"commitId":"8c1d749360657a4909c558c3df5dec57ca66c977","commitMessage":"@@@[VMware] Enable unmanaging guest VMs (#4103)\n\n* Enable unmanaging guest VMs\n\n* Minor fixes\n\n* Fix stop usage event only if VM is not stopped when unmanaging\n\n* Rename unmanaged VMs manager\n\n* Generate netofferingremove usage event if VM is not stopped\n\n* Generate usage event VM snapshot primary off when unmanaging","date":"2020-06-26 19:31:43","modifiedFileCount":"28","status":"M","submitter":"Nicolas Vazquez"},{"authorTime":"2020-06-26 19:31:43","codes":[{"authorDate":"2020-10-26 21:24:14","commitOrder":5,"curCode":"    protected void advanceExpunge(VMInstanceVO vm) throws ResourceUnavailableException, OperationTimedoutException, ConcurrentOperationException {\n        if (vm == null || vm.getRemoved() != null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find vm or vm is destroyed: \" + vm);\n            }\n            return;\n        }\n\n        advanceStop(vm.getUuid(), VmDestroyForcestop.value());\n        vm = _vmDao.findByUuid(vm.getUuid());\n\n        try {\n            if (!stateTransitTo(vm, VirtualMachine.Event.ExpungeOperation, vm.getHostId())) {\n                s_logger.debug(\"Unable to destroy the vm because it is not in the correct state: \" + vm);\n                throw new CloudRuntimeException(\"Unable to destroy \" + vm);\n\n            }\n        } catch (final NoTransitionException e) {\n            s_logger.debug(\"Unable to destroy the vm because it is not in the correct state: \" + vm);\n            throw new CloudRuntimeException(\"Unable to destroy \" + vm, e);\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Destroying vm \" + vm);\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        s_logger.debug(\"Cleaning up NICS\");\n        final List<Command> nicExpungeCommands = hvGuru.finalizeExpungeNics(vm, profile.getNics());\n        _networkMgr.cleanupNics(profile);\n\n        s_logger.debug(\"Cleaning up hypervisor data structures (ex. SRs in XenServer) for managed storage\");\n\n        final List<Command> volumeExpungeCommands = hvGuru.finalizeExpungeVolumes(vm);\n\n        final Long hostId = vm.getHostId() != null ? vm.getHostId() : vm.getLastHostId();\n\n        List<Map<String, String>> targets = getTargets(hostId, vm.getId());\n\n        if (volumeExpungeCommands != null && volumeExpungeCommands.size() > 0 && hostId != null) {\n            final Commands cmds = new Commands(Command.OnError.Stop);\n\n            for (final Command volumeExpungeCommand : volumeExpungeCommands) {\n                cmds.addCommand(volumeExpungeCommand);\n            }\n\n            _agentMgr.send(hostId, cmds);\n\n            if (!cmds.isSuccessful()) {\n                for (final Answer answer : cmds.getAnswers()) {\n                    if (!answer.getResult()) {\n                        s_logger.warn(\"Failed to expunge vm due to: \" + answer.getDetails());\n\n                        throw new CloudRuntimeException(\"Unable to expunge \" + vm + \" due to \" + answer.getDetails());\n                    }\n                }\n            }\n        }\n\n        if (hostId != null) {\n            volumeMgr.revokeAccess(vm.getId(), hostId);\n        }\n\n        \r\n        volumeMgr.cleanupVolumes(vm.getId());\n\n        if (hostId != null && CollectionUtils.isNotEmpty(targets)) {\n            removeDynamicTargets(hostId, targets);\n        }\n\n        final VirtualMachineGuru guru = getVmGuru(vm);\n        guru.finalizeExpunge(vm);\n        \r\n        userVmDetailsDao.removeDetails(vm.getId());\n\n        \r\n        userVmDeployAsIsDetailsDao.removeDetails(vm.getId());\n\n        \r\n        final List<Command> finalizeExpungeCommands = hvGuru.finalizeExpunge(vm);\n        if (finalizeExpungeCommands != null && finalizeExpungeCommands.size() > 0) {\n            if (hostId != null) {\n                final Commands cmds = new Commands(Command.OnError.Stop);\n                for (final Command command : finalizeExpungeCommands) {\n                    cmds.addCommand(command);\n                }\n                if (nicExpungeCommands != null) {\n                    for (final Command command : nicExpungeCommands) {\n                        cmds.addCommand(command);\n                    }\n                }\n                _agentMgr.send(hostId, cmds);\n                if (!cmds.isSuccessful()) {\n                    for (final Answer answer : cmds.getAnswers()) {\n                        if (!answer.getResult()) {\n                            s_logger.warn(\"Failed to expunge vm due to: \" + answer.getDetails());\n                            throw new CloudRuntimeException(\"Unable to expunge \" + vm + \" due to \" + answer.getDetails());\n                        }\n                    }\n                }\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Expunged \" + vm);\n        }\n\n    }\n","date":"2020-10-26 21:24:14","endLine":632,"groupId":"22273","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"advanceExpunge","params":"(VMInstanceVOvm)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/8e/9ec450b1ed7b3b97645bd472313fd926bfc998.src","preCode":"    protected void advanceExpunge(VMInstanceVO vm) throws ResourceUnavailableException, OperationTimedoutException, ConcurrentOperationException {\n        if (vm == null || vm.getRemoved() != null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find vm or vm is destroyed: \" + vm);\n            }\n            return;\n        }\n\n        advanceStop(vm.getUuid(), VmDestroyForcestop.value());\n        vm = _vmDao.findByUuid(vm.getUuid());\n\n        try {\n            if (!stateTransitTo(vm, VirtualMachine.Event.ExpungeOperation, vm.getHostId())) {\n                s_logger.debug(\"Unable to destroy the vm because it is not in the correct state: \" + vm);\n                throw new CloudRuntimeException(\"Unable to destroy \" + vm);\n\n            }\n        } catch (final NoTransitionException e) {\n            s_logger.debug(\"Unable to destroy the vm because it is not in the correct state: \" + vm);\n            throw new CloudRuntimeException(\"Unable to destroy \" + vm, e);\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Destroying vm \" + vm);\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        s_logger.debug(\"Cleaning up NICS\");\n        final List<Command> nicExpungeCommands = hvGuru.finalizeExpungeNics(vm, profile.getNics());\n        _networkMgr.cleanupNics(profile);\n\n        s_logger.debug(\"Cleaning up hypervisor data structures (ex. SRs in XenServer) for managed storage\");\n\n        final List<Command> volumeExpungeCommands = hvGuru.finalizeExpungeVolumes(vm);\n\n        final Long hostId = vm.getHostId() != null ? vm.getHostId() : vm.getLastHostId();\n\n        List<Map<String, String>> targets = getTargets(hostId, vm.getId());\n\n        if (volumeExpungeCommands != null && volumeExpungeCommands.size() > 0 && hostId != null) {\n            final Commands cmds = new Commands(Command.OnError.Stop);\n\n            for (final Command volumeExpungeCommand : volumeExpungeCommands) {\n                cmds.addCommand(volumeExpungeCommand);\n            }\n\n            _agentMgr.send(hostId, cmds);\n\n            if (!cmds.isSuccessful()) {\n                for (final Answer answer : cmds.getAnswers()) {\n                    if (!answer.getResult()) {\n                        s_logger.warn(\"Failed to expunge vm due to: \" + answer.getDetails());\n\n                        throw new CloudRuntimeException(\"Unable to expunge \" + vm + \" due to \" + answer.getDetails());\n                    }\n                }\n            }\n        }\n\n        if (hostId != null) {\n            volumeMgr.revokeAccess(vm.getId(), hostId);\n        }\n\n        \r\n        volumeMgr.cleanupVolumes(vm.getId());\n\n        if (hostId != null && CollectionUtils.isNotEmpty(targets)) {\n            removeDynamicTargets(hostId, targets);\n        }\n\n        final VirtualMachineGuru guru = getVmGuru(vm);\n        guru.finalizeExpunge(vm);\n        \r\n        userVmDetailsDao.removeDetails(vm.getId());\n\n        \r\n        final List<Command> finalizeExpungeCommands = hvGuru.finalizeExpunge(vm);\n        if (finalizeExpungeCommands != null && finalizeExpungeCommands.size() > 0) {\n            if (hostId != null) {\n                final Commands cmds = new Commands(Command.OnError.Stop);\n                for (final Command command : finalizeExpungeCommands) {\n                    cmds.addCommand(command);\n                }\n                if (nicExpungeCommands != null) {\n                    for (final Command command : nicExpungeCommands) {\n                        cmds.addCommand(command);\n                    }\n                }\n                _agentMgr.send(hostId, cmds);\n                if (!cmds.isSuccessful()) {\n                    for (final Answer answer : cmds.getAnswers()) {\n                        if (!answer.getResult()) {\n                            s_logger.warn(\"Failed to expunge vm due to: \" + answer.getDetails());\n                            throw new CloudRuntimeException(\"Unable to expunge \" + vm + \" due to \" + answer.getDetails());\n                        }\n                    }\n                }\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Expunged \" + vm);\n        }\n\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":522,"status":"M"},{"authorDate":"2020-06-26 19:31:43","commitOrder":5,"curCode":"    private void unmanageVMVolumes(VMInstanceVO vm) {\n        final Long hostId = vm.getHostId() != null ? vm.getHostId() : vm.getLastHostId();\n        if (hostId != null) {\n            volumeMgr.revokeAccess(vm.getId(), hostId);\n        }\n        volumeMgr.unmanageVolumes(vm.getId());\n\n        List<Map<String, String>> targets = getTargets(hostId, vm.getId());\n        if (hostId != null && CollectionUtils.isNotEmpty(targets)) {\n            removeDynamicTargets(hostId, targets);\n        }\n    }\n","date":"2020-06-26 19:31:43","endLine":1559,"groupId":"12896","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"unmanageVMVolumes","params":"(VMInstanceVOvm)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/e7/4e6fffa4dcf33f9201aae9be26180bfc4fdd4e.src","preCode":"    private void unmanageVMVolumes(VMInstanceVO vm) {\n        final Long hostId = vm.getHostId() != null ? vm.getHostId() : vm.getLastHostId();\n        if (hostId != null) {\n            volumeMgr.revokeAccess(vm.getId(), hostId);\n        }\n        volumeMgr.unmanageVolumes(vm.getId());\n\n        List<Map<String, String>> targets = getTargets(hostId, vm.getId());\n        if (hostId != null && CollectionUtils.isNotEmpty(targets)) {\n            removeDynamicTargets(hostId, targets);\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1548,"status":"N"}],"commitId":"1a75872cd484dd387552bae58996a56679fdb51e","commitMessage":"@@@Merge pull request #4307 from shapeblue/ovfprops-and-vsphere-adv-together\n\n[VMware] vSphere advanced capabilities and Full OVF properties support","date":"2020-10-26 21:24:14","modifiedFileCount":"173","status":"M","submitter":"Boris Stoyanov - a.k.a Bobby"},{"authorTime":"2020-06-26 19:31:43","codes":[{"authorDate":"2021-05-18 17:49:20","commitOrder":6,"curCode":"    protected void advanceExpunge(VMInstanceVO vm) throws ResourceUnavailableException, OperationTimedoutException, ConcurrentOperationException {\n        if (vm == null || vm.getRemoved() != null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find vm or vm is destroyed: \" + vm);\n            }\n            return;\n        }\n\n        advanceStop(vm.getUuid(), VmDestroyForcestop.value());\n        vm = _vmDao.findByUuid(vm.getUuid());\n\n        try {\n            if (!stateTransitTo(vm, VirtualMachine.Event.ExpungeOperation, vm.getHostId())) {\n                s_logger.debug(\"Unable to destroy the vm because it is not in the correct state: \" + vm);\n                throw new CloudRuntimeException(\"Unable to destroy \" + vm);\n\n            }\n        } catch (final NoTransitionException e) {\n            s_logger.debug(\"Unable to destroy the vm because it is not in the correct state: \" + vm);\n            throw new CloudRuntimeException(\"Unable to destroy \" + vm, e);\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Destroying vm \" + vm);\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        s_logger.debug(\"Cleaning up NICS\");\n        final List<Command> nicExpungeCommands = hvGuru.finalizeExpungeNics(vm, profile.getNics());\n        _networkMgr.cleanupNics(profile);\n\n        s_logger.debug(\"Cleaning up hypervisor data structures (ex. SRs in XenServer) for managed storage\");\n\n        final List<Command> volumeExpungeCommands = hvGuru.finalizeExpungeVolumes(vm);\n\n        final Long hostId = vm.getHostId() != null ? vm.getHostId() : vm.getLastHostId();\n\n        List<Map<String, String>> targets = getTargets(hostId, vm.getId());\n\n        if (volumeExpungeCommands != null && volumeExpungeCommands.size() > 0 && hostId != null) {\n            final Commands cmds = new Commands(Command.OnError.Stop);\n\n            for (final Command volumeExpungeCommand : volumeExpungeCommands) {\n                volumeExpungeCommand.setBypassHostMaintenance(expungeCommandCanBypassHostMaintenance(vm));\n                cmds.addCommand(volumeExpungeCommand);\n            }\n\n            _agentMgr.send(hostId, cmds);\n\n            if (!cmds.isSuccessful()) {\n                for (final Answer answer : cmds.getAnswers()) {\n                    if (!answer.getResult()) {\n                        s_logger.warn(\"Failed to expunge vm due to: \" + answer.getDetails());\n\n                        throw new CloudRuntimeException(\"Unable to expunge \" + vm + \" due to \" + answer.getDetails());\n                    }\n                }\n            }\n        }\n\n        if (hostId != null) {\n            volumeMgr.revokeAccess(vm.getId(), hostId);\n        }\n\n        \r\n        volumeMgr.cleanupVolumes(vm.getId());\n\n        if (hostId != null && CollectionUtils.isNotEmpty(targets)) {\n            removeDynamicTargets(hostId, targets);\n        }\n\n        final VirtualMachineGuru guru = getVmGuru(vm);\n        guru.finalizeExpunge(vm);\n        \r\n        userVmDetailsDao.removeDetails(vm.getId());\n\n        \r\n        userVmDeployAsIsDetailsDao.removeDetails(vm.getId());\n\n        \r\n        final List<Command> finalizeExpungeCommands = hvGuru.finalizeExpunge(vm);\n        if (finalizeExpungeCommands != null && finalizeExpungeCommands.size() > 0) {\n            if (hostId != null) {\n                final Commands cmds = new Commands(Command.OnError.Stop);\n                for (final Command command : finalizeExpungeCommands) {\n                    command.setBypassHostMaintenance(expungeCommandCanBypassHostMaintenance(vm));\n                    cmds.addCommand(command);\n                }\n                if (nicExpungeCommands != null) {\n                    for (final Command command : nicExpungeCommands) {\n                        command.setBypassHostMaintenance(expungeCommandCanBypassHostMaintenance(vm));\n                        cmds.addCommand(command);\n                    }\n                }\n                _agentMgr.send(hostId, cmds);\n                if (!cmds.isSuccessful()) {\n                    for (final Answer answer : cmds.getAnswers()) {\n                        if (!answer.getResult()) {\n                            s_logger.warn(\"Failed to expunge vm due to: \" + answer.getDetails());\n                            throw new CloudRuntimeException(\"Unable to expunge \" + vm + \" due to \" + answer.getDetails());\n                        }\n                    }\n                }\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Expunged \" + vm);\n        }\n\n    }\n","date":"2021-05-18 17:49:20","endLine":656,"groupId":"22273","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"advanceExpunge","params":"(VMInstanceVOvm)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/56/5d4de8788c2ed3c4352343605722bc89ab10aa.src","preCode":"    protected void advanceExpunge(VMInstanceVO vm) throws ResourceUnavailableException, OperationTimedoutException, ConcurrentOperationException {\n        if (vm == null || vm.getRemoved() != null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find vm or vm is destroyed: \" + vm);\n            }\n            return;\n        }\n\n        advanceStop(vm.getUuid(), VmDestroyForcestop.value());\n        vm = _vmDao.findByUuid(vm.getUuid());\n\n        try {\n            if (!stateTransitTo(vm, VirtualMachine.Event.ExpungeOperation, vm.getHostId())) {\n                s_logger.debug(\"Unable to destroy the vm because it is not in the correct state: \" + vm);\n                throw new CloudRuntimeException(\"Unable to destroy \" + vm);\n\n            }\n        } catch (final NoTransitionException e) {\n            s_logger.debug(\"Unable to destroy the vm because it is not in the correct state: \" + vm);\n            throw new CloudRuntimeException(\"Unable to destroy \" + vm, e);\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Destroying vm \" + vm);\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        s_logger.debug(\"Cleaning up NICS\");\n        final List<Command> nicExpungeCommands = hvGuru.finalizeExpungeNics(vm, profile.getNics());\n        _networkMgr.cleanupNics(profile);\n\n        s_logger.debug(\"Cleaning up hypervisor data structures (ex. SRs in XenServer) for managed storage\");\n\n        final List<Command> volumeExpungeCommands = hvGuru.finalizeExpungeVolumes(vm);\n\n        final Long hostId = vm.getHostId() != null ? vm.getHostId() : vm.getLastHostId();\n\n        List<Map<String, String>> targets = getTargets(hostId, vm.getId());\n\n        if (volumeExpungeCommands != null && volumeExpungeCommands.size() > 0 && hostId != null) {\n            final Commands cmds = new Commands(Command.OnError.Stop);\n\n            for (final Command volumeExpungeCommand : volumeExpungeCommands) {\n                cmds.addCommand(volumeExpungeCommand);\n            }\n\n            _agentMgr.send(hostId, cmds);\n\n            if (!cmds.isSuccessful()) {\n                for (final Answer answer : cmds.getAnswers()) {\n                    if (!answer.getResult()) {\n                        s_logger.warn(\"Failed to expunge vm due to: \" + answer.getDetails());\n\n                        throw new CloudRuntimeException(\"Unable to expunge \" + vm + \" due to \" + answer.getDetails());\n                    }\n                }\n            }\n        }\n\n        if (hostId != null) {\n            volumeMgr.revokeAccess(vm.getId(), hostId);\n        }\n\n        \r\n        volumeMgr.cleanupVolumes(vm.getId());\n\n        if (hostId != null && CollectionUtils.isNotEmpty(targets)) {\n            removeDynamicTargets(hostId, targets);\n        }\n\n        final VirtualMachineGuru guru = getVmGuru(vm);\n        guru.finalizeExpunge(vm);\n        \r\n        userVmDetailsDao.removeDetails(vm.getId());\n\n        \r\n        userVmDeployAsIsDetailsDao.removeDetails(vm.getId());\n\n        \r\n        final List<Command> finalizeExpungeCommands = hvGuru.finalizeExpunge(vm);\n        if (finalizeExpungeCommands != null && finalizeExpungeCommands.size() > 0) {\n            if (hostId != null) {\n                final Commands cmds = new Commands(Command.OnError.Stop);\n                for (final Command command : finalizeExpungeCommands) {\n                    cmds.addCommand(command);\n                }\n                if (nicExpungeCommands != null) {\n                    for (final Command command : nicExpungeCommands) {\n                        cmds.addCommand(command);\n                    }\n                }\n                _agentMgr.send(hostId, cmds);\n                if (!cmds.isSuccessful()) {\n                    for (final Answer answer : cmds.getAnswers()) {\n                        if (!answer.getResult()) {\n                            s_logger.warn(\"Failed to expunge vm due to: \" + answer.getDetails());\n                            throw new CloudRuntimeException(\"Unable to expunge \" + vm + \" due to \" + answer.getDetails());\n                        }\n                    }\n                }\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Expunged \" + vm);\n        }\n\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":543,"status":"M"},{"authorDate":"2020-06-26 19:31:43","commitOrder":6,"curCode":"    private void unmanageVMVolumes(VMInstanceVO vm) {\n        final Long hostId = vm.getHostId() != null ? vm.getHostId() : vm.getLastHostId();\n        if (hostId != null) {\n            volumeMgr.revokeAccess(vm.getId(), hostId);\n        }\n        volumeMgr.unmanageVolumes(vm.getId());\n\n        List<Map<String, String>> targets = getTargets(hostId, vm.getId());\n        if (hostId != null && CollectionUtils.isNotEmpty(targets)) {\n            removeDynamicTargets(hostId, targets);\n        }\n    }\n","date":"2020-06-26 19:31:43","endLine":1559,"groupId":"12896","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"unmanageVMVolumes","params":"(VMInstanceVOvm)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/e7/4e6fffa4dcf33f9201aae9be26180bfc4fdd4e.src","preCode":"    private void unmanageVMVolumes(VMInstanceVO vm) {\n        final Long hostId = vm.getHostId() != null ? vm.getHostId() : vm.getLastHostId();\n        if (hostId != null) {\n            volumeMgr.revokeAccess(vm.getId(), hostId);\n        }\n        volumeMgr.unmanageVolumes(vm.getId());\n\n        List<Map<String, String>> targets = getTargets(hostId, vm.getId());\n        if (hostId != null && CollectionUtils.isNotEmpty(targets)) {\n            removeDynamicTargets(hostId, targets);\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1548,"status":"N"}],"commitId":"426f14b6ed87c3dc072ee1d95d84892fc624bcf0","commitMessage":"@@@Merge remote-tracking branch 'apache/4.15'\n\nSigned-off-by: Abhishek Kumar <abhishek.mrt22@gmail.com>\n","date":"2021-05-18 17:49:20","modifiedFileCount":"23","status":"M","submitter":"Abhishek Kumar"},{"authorTime":"2020-06-26 19:31:43","codes":[{"authorDate":"2021-09-08 12:44:06","commitOrder":7,"curCode":"    protected void advanceExpunge(VMInstanceVO vm) throws ResourceUnavailableException, OperationTimedoutException, ConcurrentOperationException {\n        if (vm == null || vm.getRemoved() != null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find vm or vm is destroyed: \" + vm);\n            }\n            return;\n        }\n\n        advanceStop(vm.getUuid(), VmDestroyForcestop.value());\n        vm = _vmDao.findByUuid(vm.getUuid());\n\n        try {\n            if (!stateTransitTo(vm, VirtualMachine.Event.ExpungeOperation, vm.getHostId())) {\n                s_logger.debug(\"Unable to destroy the vm because it is not in the correct state: \" + vm);\n                throw new CloudRuntimeException(\"Unable to destroy \" + vm);\n\n            }\n        } catch (final NoTransitionException e) {\n            s_logger.debug(\"Unable to destroy the vm because it is not in the correct state: \" + vm);\n            throw new CloudRuntimeException(\"Unable to destroy \" + vm, e);\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Destroying vm \" + vm);\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        s_logger.debug(\"Cleaning up NICS\");\n        final List<Command> nicExpungeCommands = hvGuru.finalizeExpungeNics(vm, profile.getNics());\n        _networkMgr.cleanupNics(profile);\n\n        s_logger.debug(\"Cleaning up hypervisor data structures (ex. SRs in XenServer) for managed storage\");\n\n        final List<Command> volumeExpungeCommands = hvGuru.finalizeExpungeVolumes(vm);\n\n        final Long hostId = vm.getHostId() != null ? vm.getHostId() : vm.getLastHostId();\n\n        List<Map<String, String>> targets = getTargets(hostId, vm.getId());\n\n        if (volumeExpungeCommands != null && volumeExpungeCommands.size() > 0 && hostId != null) {\n            final Commands cmds = new Commands(Command.OnError.Stop);\n\n            for (final Command volumeExpungeCommand : volumeExpungeCommands) {\n                volumeExpungeCommand.setBypassHostMaintenance(expungeCommandCanBypassHostMaintenance(vm));\n                cmds.addCommand(volumeExpungeCommand);\n            }\n\n            _agentMgr.send(hostId, cmds);\n\n            if (!cmds.isSuccessful()) {\n                for (final Answer answer : cmds.getAnswers()) {\n                    if (!answer.getResult()) {\n                        s_logger.warn(\"Failed to expunge vm due to: \" + answer.getDetails());\n\n                        throw new CloudRuntimeException(\"Unable to expunge \" + vm + \" due to \" + answer.getDetails());\n                    }\n                }\n            }\n        }\n\n        if (hostId != null) {\n            volumeMgr.revokeAccess(vm.getId(), hostId);\n        }\n\n        \r\n        volumeMgr.cleanupVolumes(vm.getId());\n\n        if (hostId != null && CollectionUtils.isNotEmpty(targets)) {\n            removeDynamicTargets(hostId, targets);\n        }\n\n        final VirtualMachineGuru guru = getVmGuru(vm);\n        guru.finalizeExpunge(vm);\n        \r\n        userVmDetailsDao.removeDetails(vm.getId());\n\n        \r\n        userVmDeployAsIsDetailsDao.removeDetails(vm.getId());\n\n        \r\n        annotationDao.removeByEntityType(AnnotationService.EntityType.VM.name(), vm.getUuid());\n\n        \r\n        final List<Command> finalizeExpungeCommands = hvGuru.finalizeExpunge(vm);\n        if (finalizeExpungeCommands != null && finalizeExpungeCommands.size() > 0) {\n            if (hostId != null) {\n                final Commands cmds = new Commands(Command.OnError.Stop);\n                for (final Command command : finalizeExpungeCommands) {\n                    command.setBypassHostMaintenance(expungeCommandCanBypassHostMaintenance(vm));\n                    cmds.addCommand(command);\n                }\n                if (nicExpungeCommands != null) {\n                    for (final Command command : nicExpungeCommands) {\n                        command.setBypassHostMaintenance(expungeCommandCanBypassHostMaintenance(vm));\n                        cmds.addCommand(command);\n                    }\n                }\n                _agentMgr.send(hostId, cmds);\n                if (!cmds.isSuccessful()) {\n                    for (final Answer answer : cmds.getAnswers()) {\n                        if (!answer.getResult()) {\n                            s_logger.warn(\"Failed to expunge vm due to: \" + answer.getDetails());\n                            throw new CloudRuntimeException(\"Unable to expunge \" + vm + \" due to \" + answer.getDetails());\n                        }\n                    }\n                }\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Expunged \" + vm);\n        }\n\n    }\n","date":"2021-09-08 12:44:06","endLine":668,"groupId":"22273","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"advanceExpunge","params":"(VMInstanceVOvm)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/69/c5cc6e27889d4760e97b8048f2ea7a1b1b6ddf.src","preCode":"    protected void advanceExpunge(VMInstanceVO vm) throws ResourceUnavailableException, OperationTimedoutException, ConcurrentOperationException {\n        if (vm == null || vm.getRemoved() != null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find vm or vm is destroyed: \" + vm);\n            }\n            return;\n        }\n\n        advanceStop(vm.getUuid(), VmDestroyForcestop.value());\n        vm = _vmDao.findByUuid(vm.getUuid());\n\n        try {\n            if (!stateTransitTo(vm, VirtualMachine.Event.ExpungeOperation, vm.getHostId())) {\n                s_logger.debug(\"Unable to destroy the vm because it is not in the correct state: \" + vm);\n                throw new CloudRuntimeException(\"Unable to destroy \" + vm);\n\n            }\n        } catch (final NoTransitionException e) {\n            s_logger.debug(\"Unable to destroy the vm because it is not in the correct state: \" + vm);\n            throw new CloudRuntimeException(\"Unable to destroy \" + vm, e);\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Destroying vm \" + vm);\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        s_logger.debug(\"Cleaning up NICS\");\n        final List<Command> nicExpungeCommands = hvGuru.finalizeExpungeNics(vm, profile.getNics());\n        _networkMgr.cleanupNics(profile);\n\n        s_logger.debug(\"Cleaning up hypervisor data structures (ex. SRs in XenServer) for managed storage\");\n\n        final List<Command> volumeExpungeCommands = hvGuru.finalizeExpungeVolumes(vm);\n\n        final Long hostId = vm.getHostId() != null ? vm.getHostId() : vm.getLastHostId();\n\n        List<Map<String, String>> targets = getTargets(hostId, vm.getId());\n\n        if (volumeExpungeCommands != null && volumeExpungeCommands.size() > 0 && hostId != null) {\n            final Commands cmds = new Commands(Command.OnError.Stop);\n\n            for (final Command volumeExpungeCommand : volumeExpungeCommands) {\n                volumeExpungeCommand.setBypassHostMaintenance(expungeCommandCanBypassHostMaintenance(vm));\n                cmds.addCommand(volumeExpungeCommand);\n            }\n\n            _agentMgr.send(hostId, cmds);\n\n            if (!cmds.isSuccessful()) {\n                for (final Answer answer : cmds.getAnswers()) {\n                    if (!answer.getResult()) {\n                        s_logger.warn(\"Failed to expunge vm due to: \" + answer.getDetails());\n\n                        throw new CloudRuntimeException(\"Unable to expunge \" + vm + \" due to \" + answer.getDetails());\n                    }\n                }\n            }\n        }\n\n        if (hostId != null) {\n            volumeMgr.revokeAccess(vm.getId(), hostId);\n        }\n\n        \r\n        volumeMgr.cleanupVolumes(vm.getId());\n\n        if (hostId != null && CollectionUtils.isNotEmpty(targets)) {\n            removeDynamicTargets(hostId, targets);\n        }\n\n        final VirtualMachineGuru guru = getVmGuru(vm);\n        guru.finalizeExpunge(vm);\n        \r\n        userVmDetailsDao.removeDetails(vm.getId());\n\n        \r\n        userVmDeployAsIsDetailsDao.removeDetails(vm.getId());\n\n        \r\n        final List<Command> finalizeExpungeCommands = hvGuru.finalizeExpunge(vm);\n        if (finalizeExpungeCommands != null && finalizeExpungeCommands.size() > 0) {\n            if (hostId != null) {\n                final Commands cmds = new Commands(Command.OnError.Stop);\n                for (final Command command : finalizeExpungeCommands) {\n                    command.setBypassHostMaintenance(expungeCommandCanBypassHostMaintenance(vm));\n                    cmds.addCommand(command);\n                }\n                if (nicExpungeCommands != null) {\n                    for (final Command command : nicExpungeCommands) {\n                        command.setBypassHostMaintenance(expungeCommandCanBypassHostMaintenance(vm));\n                        cmds.addCommand(command);\n                    }\n                }\n                _agentMgr.send(hostId, cmds);\n                if (!cmds.isSuccessful()) {\n                    for (final Answer answer : cmds.getAnswers()) {\n                        if (!answer.getResult()) {\n                            s_logger.warn(\"Failed to expunge vm due to: \" + answer.getDetails());\n                            throw new CloudRuntimeException(\"Unable to expunge \" + vm + \" due to \" + answer.getDetails());\n                        }\n                    }\n                }\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Expunged \" + vm);\n        }\n\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":552,"status":"M"},{"authorDate":"2020-06-26 19:31:43","commitOrder":7,"curCode":"    private void unmanageVMVolumes(VMInstanceVO vm) {\n        final Long hostId = vm.getHostId() != null ? vm.getHostId() : vm.getLastHostId();\n        if (hostId != null) {\n            volumeMgr.revokeAccess(vm.getId(), hostId);\n        }\n        volumeMgr.unmanageVolumes(vm.getId());\n\n        List<Map<String, String>> targets = getTargets(hostId, vm.getId());\n        if (hostId != null && CollectionUtils.isNotEmpty(targets)) {\n            removeDynamicTargets(hostId, targets);\n        }\n    }\n","date":"2020-06-26 19:31:43","endLine":1559,"groupId":"12896","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"unmanageVMVolumes","params":"(VMInstanceVOvm)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/e7/4e6fffa4dcf33f9201aae9be26180bfc4fdd4e.src","preCode":"    private void unmanageVMVolumes(VMInstanceVO vm) {\n        final Long hostId = vm.getHostId() != null ? vm.getHostId() : vm.getLastHostId();\n        if (hostId != null) {\n            volumeMgr.revokeAccess(vm.getId(), hostId);\n        }\n        volumeMgr.unmanageVolumes(vm.getId());\n\n        List<Map<String, String>> targets = getTargets(hostId, vm.getId());\n        if (hostId != null && CollectionUtils.isNotEmpty(targets)) {\n            removeDynamicTargets(hostId, targets);\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1548,"status":"N"}],"commitId":"413d10dd8106af9b3c369c1a393fbcca5e7217ce","commitMessage":"@@@server: Extend the Annotations framework (#5103)\n\n* Extend addAnnotation and listAnnotations APIs\n\n* Allow users to add.  list and remove comments\n\n* Add adminsonly UI and allow admins or owners to remove comments\n\n* New annotations tab\n\n* In progress: new comments section\n\n* Address review comments\n\n* Fix\n\n* Fix annotationfilter and comments section\n\n* Add keyword and delete action\n\n* Fix and rename annotations tab\n\n* Update annotation visibility API and update comments table accordingly\n\n* Allow users seeing all the comments for their owned resources\n\n* Extend comments for volumes and snapshots\n\n* Extend comments to multiple entities\n\n* Add uuid to ssh keypairs\n\n* SSH keypair UI refactor\n\n* Extend comments to the infrastructure entities\n\n* Add missing entities\n\n* Fix upgrade version for ssh keypairs\n\n* Fix typo on DB upgrade schema\n\n* Fix annotations table columns when there is no data\n\n* Extend the list view of items showing they if they have comments\n\n* Remove extra test\n\n* Add annotation permissions\n\n* Address review comments\n\n* Extend marvin tests for annotations\n\n* updating ui stuff\n\n* addition to toggle visibility\n\n* Fix pagination on comments section\n\n* Extend to kubernetes clusters\n\n* Fixes after last review\n\n* Change default value for adminsonly column\n\n* Remove the required field for the annotationfilter parameter\n\n* Small fixes on visibility and other fixes\n\n* Cleanup to reduce files changed\n\n* Rollback extra line\n\n* Address review comments\n\n* Fix cleanup error on smoke test\n\n* Fix sending incorrect parameter to checkPermissions method\n\n* Add check domain access for the calling account for domain networks\n\n* Fix only display annotations icon if there are comments the user can see\n\n* Simply change the Save button label to Submit\n\n* Change order of the Tools menu to provent users getting 404 error on clicking the text instead of expanding\n\n* Remove comments when removing entities\n\n* Address review comments on marvin tests\n\n* Allow users to list annotations for an entity ID\n\n* Allow users to see all comments for allowed entities\n\n* Fix search filters\n\n* Remove username from search filter\n\n* Add pagination to the annotations tab\n\n* Display username for user comments\n\n* Fix add permissions for domain and resource admins\n\n* Fix for domain admins\n\n* Trivial but important UI fix\n\n* Replace pagination for annotations tab\n\n* Add confirmation for delete comment\n\n* Lint warnings\n\n* Fix reduced list as domain admin\n\n* Fix display remove comment button for non admins\n\n* Improve display remove action button\n\n* Remove unused parameter on groupShow\n\n* Include a clock icon to the all comments filter except for root admin\n\n* Move cleanup SQL to the correct file after rebasing main\n\nCo-authored-by: davidjumani <dj.davidjumani1994@gmail.com>","date":"2021-09-08 12:44:06","modifiedFileCount":"109","status":"M","submitter":"Nicolas Vazquez"},{"authorTime":"2020-06-26 19:31:43","codes":[{"authorDate":"2021-09-18 00:24:52","commitOrder":8,"curCode":"    protected void advanceExpunge(VMInstanceVO vm) throws ResourceUnavailableException, OperationTimedoutException, ConcurrentOperationException {\n        if (vm == null || vm.getRemoved() != null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find vm or vm is destroyed: \" + vm);\n            }\n            return;\n        }\n\n        advanceStop(vm.getUuid(), VmDestroyForcestop.value());\n        vm = _vmDao.findByUuid(vm.getUuid());\n\n        try {\n            if (!stateTransitTo(vm, VirtualMachine.Event.ExpungeOperation, vm.getHostId())) {\n                s_logger.debug(\"Unable to destroy the vm because it is not in the correct state: \" + vm);\n                throw new CloudRuntimeException(\"Unable to destroy \" + vm);\n\n            }\n        } catch (final NoTransitionException e) {\n            s_logger.debug(\"Unable to destroy the vm because it is not in the correct state: \" + vm);\n            throw new CloudRuntimeException(\"Unable to destroy \" + vm, e);\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Destroying vm \" + vm);\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        s_logger.debug(\"Cleaning up NICS\");\n        final List<Command> nicExpungeCommands = hvGuru.finalizeExpungeNics(vm, profile.getNics());\n        _networkMgr.cleanupNics(profile);\n\n        s_logger.debug(\"Cleaning up hypervisor data structures (ex. SRs in XenServer) for managed storage\");\n\n        final List<Command> volumeExpungeCommands = hvGuru.finalizeExpungeVolumes(vm);\n\n        final Long hostId = vm.getHostId() != null ? vm.getHostId() : vm.getLastHostId();\n\n        List<Map<String, String>> targets = getTargets(hostId, vm.getId());\n\n        if (volumeExpungeCommands != null && volumeExpungeCommands.size() > 0 && hostId != null) {\n            final Commands cmds = new Commands(Command.OnError.Stop);\n\n            for (final Command volumeExpungeCommand : volumeExpungeCommands) {\n                volumeExpungeCommand.setBypassHostMaintenance(expungeCommandCanBypassHostMaintenance(vm));\n                cmds.addCommand(volumeExpungeCommand);\n            }\n\n            _agentMgr.send(hostId, cmds);\n\n            if (!cmds.isSuccessful()) {\n                for (final Answer answer : cmds.getAnswers()) {\n                    if (!answer.getResult()) {\n                        s_logger.warn(\"Failed to expunge vm due to: \" + answer.getDetails());\n\n                        throw new CloudRuntimeException(\"Unable to expunge \" + vm + \" due to \" + answer.getDetails());\n                    }\n                }\n            }\n        }\n\n        if (hostId != null) {\n            volumeMgr.revokeAccess(vm.getId(), hostId);\n        }\n\n        \r\n        volumeMgr.cleanupVolumes(vm.getId());\n\n        if (hostId != null && CollectionUtils.isNotEmpty(targets)) {\n            removeDynamicTargets(hostId, targets);\n        }\n\n        final VirtualMachineGuru guru = getVmGuru(vm);\n        guru.finalizeExpunge(vm);\n        \r\n        userVmDetailsDao.removeDetails(vm.getId());\n\n        \r\n        userVmDeployAsIsDetailsDao.removeDetails(vm.getId());\n\n        \r\n        annotationDao.removeByEntityType(AnnotationService.EntityType.VM.name(), vm.getUuid());\n\n        \r\n        final List<Command> finalizeExpungeCommands = hvGuru.finalizeExpunge(vm);\n        if (CollectionUtils.isNotEmpty(finalizeExpungeCommands) || CollectionUtils.isNotEmpty(nicExpungeCommands)) {\n            if (hostId != null) {\n                final Commands cmds = new Commands(Command.OnError.Stop);\n                addAllExpungeCommandsFromList(finalizeExpungeCommands, cmds, vm);\n                addAllExpungeCommandsFromList(nicExpungeCommands, cmds, vm);\n                _agentMgr.send(hostId, cmds);\n                if (!cmds.isSuccessful()) {\n                    for (final Answer answer : cmds.getAnswers()) {\n                        if (!answer.getResult()) {\n                            s_logger.warn(\"Failed to expunge vm due to: \" + answer.getDetails());\n                            throw new CloudRuntimeException(\"Unable to expunge \" + vm + \" due to \" + answer.getDetails());\n                        }\n                    }\n                }\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Expunged \" + vm);\n        }\n\n    }\n","date":"2021-09-18 00:24:52","endLine":660,"groupId":"10541","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"advanceExpunge","params":"(VMInstanceVOvm)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/d4/5b92098d2f2f0237cd136b8cb86f8f2cd2332d.src","preCode":"    protected void advanceExpunge(VMInstanceVO vm) throws ResourceUnavailableException, OperationTimedoutException, ConcurrentOperationException {\n        if (vm == null || vm.getRemoved() != null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find vm or vm is destroyed: \" + vm);\n            }\n            return;\n        }\n\n        advanceStop(vm.getUuid(), VmDestroyForcestop.value());\n        vm = _vmDao.findByUuid(vm.getUuid());\n\n        try {\n            if (!stateTransitTo(vm, VirtualMachine.Event.ExpungeOperation, vm.getHostId())) {\n                s_logger.debug(\"Unable to destroy the vm because it is not in the correct state: \" + vm);\n                throw new CloudRuntimeException(\"Unable to destroy \" + vm);\n\n            }\n        } catch (final NoTransitionException e) {\n            s_logger.debug(\"Unable to destroy the vm because it is not in the correct state: \" + vm);\n            throw new CloudRuntimeException(\"Unable to destroy \" + vm, e);\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Destroying vm \" + vm);\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        s_logger.debug(\"Cleaning up NICS\");\n        final List<Command> nicExpungeCommands = hvGuru.finalizeExpungeNics(vm, profile.getNics());\n        _networkMgr.cleanupNics(profile);\n\n        s_logger.debug(\"Cleaning up hypervisor data structures (ex. SRs in XenServer) for managed storage\");\n\n        final List<Command> volumeExpungeCommands = hvGuru.finalizeExpungeVolumes(vm);\n\n        final Long hostId = vm.getHostId() != null ? vm.getHostId() : vm.getLastHostId();\n\n        List<Map<String, String>> targets = getTargets(hostId, vm.getId());\n\n        if (volumeExpungeCommands != null && volumeExpungeCommands.size() > 0 && hostId != null) {\n            final Commands cmds = new Commands(Command.OnError.Stop);\n\n            for (final Command volumeExpungeCommand : volumeExpungeCommands) {\n                volumeExpungeCommand.setBypassHostMaintenance(expungeCommandCanBypassHostMaintenance(vm));\n                cmds.addCommand(volumeExpungeCommand);\n            }\n\n            _agentMgr.send(hostId, cmds);\n\n            if (!cmds.isSuccessful()) {\n                for (final Answer answer : cmds.getAnswers()) {\n                    if (!answer.getResult()) {\n                        s_logger.warn(\"Failed to expunge vm due to: \" + answer.getDetails());\n\n                        throw new CloudRuntimeException(\"Unable to expunge \" + vm + \" due to \" + answer.getDetails());\n                    }\n                }\n            }\n        }\n\n        if (hostId != null) {\n            volumeMgr.revokeAccess(vm.getId(), hostId);\n        }\n\n        \r\n        volumeMgr.cleanupVolumes(vm.getId());\n\n        if (hostId != null && CollectionUtils.isNotEmpty(targets)) {\n            removeDynamicTargets(hostId, targets);\n        }\n\n        final VirtualMachineGuru guru = getVmGuru(vm);\n        guru.finalizeExpunge(vm);\n        \r\n        userVmDetailsDao.removeDetails(vm.getId());\n\n        \r\n        userVmDeployAsIsDetailsDao.removeDetails(vm.getId());\n\n        \r\n        annotationDao.removeByEntityType(AnnotationService.EntityType.VM.name(), vm.getUuid());\n\n        \r\n        final List<Command> finalizeExpungeCommands = hvGuru.finalizeExpunge(vm);\n        if (finalizeExpungeCommands != null && finalizeExpungeCommands.size() > 0) {\n            if (hostId != null) {\n                final Commands cmds = new Commands(Command.OnError.Stop);\n                for (final Command command : finalizeExpungeCommands) {\n                    command.setBypassHostMaintenance(expungeCommandCanBypassHostMaintenance(vm));\n                    cmds.addCommand(command);\n                }\n                if (nicExpungeCommands != null) {\n                    for (final Command command : nicExpungeCommands) {\n                        command.setBypassHostMaintenance(expungeCommandCanBypassHostMaintenance(vm));\n                        cmds.addCommand(command);\n                    }\n                }\n                _agentMgr.send(hostId, cmds);\n                if (!cmds.isSuccessful()) {\n                    for (final Answer answer : cmds.getAnswers()) {\n                        if (!answer.getResult()) {\n                            s_logger.warn(\"Failed to expunge vm due to: \" + answer.getDetails());\n                            throw new CloudRuntimeException(\"Unable to expunge \" + vm + \" due to \" + answer.getDetails());\n                        }\n                    }\n                }\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Expunged \" + vm);\n        }\n\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":552,"status":"M"},{"authorDate":"2020-06-26 19:31:43","commitOrder":8,"curCode":"    private void unmanageVMVolumes(VMInstanceVO vm) {\n        final Long hostId = vm.getHostId() != null ? vm.getHostId() : vm.getLastHostId();\n        if (hostId != null) {\n            volumeMgr.revokeAccess(vm.getId(), hostId);\n        }\n        volumeMgr.unmanageVolumes(vm.getId());\n\n        List<Map<String, String>> targets = getTargets(hostId, vm.getId());\n        if (hostId != null && CollectionUtils.isNotEmpty(targets)) {\n            removeDynamicTargets(hostId, targets);\n        }\n    }\n","date":"2020-06-26 19:31:43","endLine":1559,"groupId":"10541","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"unmanageVMVolumes","params":"(VMInstanceVOvm)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/e7/4e6fffa4dcf33f9201aae9be26180bfc4fdd4e.src","preCode":"    private void unmanageVMVolumes(VMInstanceVO vm) {\n        final Long hostId = vm.getHostId() != null ? vm.getHostId() : vm.getLastHostId();\n        if (hostId != null) {\n            volumeMgr.revokeAccess(vm.getId(), hostId);\n        }\n        volumeMgr.unmanageVolumes(vm.getId());\n\n        List<Map<String, String>> targets = getTargets(hostId, vm.getId());\n        if (hostId != null && CollectionUtils.isNotEmpty(targets)) {\n            removeDynamicTargets(hostId, targets);\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1548,"status":"N"}],"commitId":"8228ecee43b5a16e8a811f4c289725260c5e74ef","commitMessage":"@@@[Vmware] Add missing condition to cleanup nics if there are commands to send (#5449)\n\n* [Vmware] Add missing condition to cleanup nics if there are commands to send\n","date":"2021-09-18 00:24:52","modifiedFileCount":"1","status":"M","submitter":"Nicolas Vazquez"}]
