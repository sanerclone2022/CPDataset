[{"authorTime":"2018-01-20 05:49:27","codes":[{"authorDate":"2018-01-20 05:49:27","commitOrder":1,"curCode":"    protected void finalizeNetworkRulesForNetwork(final Commands cmds, final DomainRouterVO router, final Provider provider, final Long guestNetworkId) {\n        s_logger.debug(\"Resending ipAssoc, port forwarding, load balancing rules as a part of Virtual router start\");\n\n        final ArrayList<? extends PublicIpAddress> publicIps = getPublicIpsToApply(router, provider, guestNetworkId);\n        final List<FirewallRule> firewallRulesEgress = new ArrayList<FirewallRule>();\n\n        \r\n        if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.Firewall, provider)) {\n            firewallRulesEgress.addAll(_rulesDao.listByNetworkPurposeTrafficType(guestNetworkId, Purpose.Firewall, FirewallRule.TrafficType.Egress));\n            if (firewallRulesEgress.isEmpty()) {\n                \r\n                createDefaultEgressFirewallRule(firewallRulesEgress, guestNetworkId);\n            }\n        }\n\n        \r\n        s_logger.debug(\"Found \" + firewallRulesEgress.size() + \" firewall Egress rule(s) to apply as a part of domR \" + router + \" start.\");\n        if (!firewallRulesEgress.isEmpty()) {\n            _commandSetupHelper.createFirewallRulesCommands(firewallRulesEgress, router, cmds, guestNetworkId);\n        }\n\n        if (publicIps != null && !publicIps.isEmpty()) {\n            final List<RemoteAccessVpn> vpns = new ArrayList<RemoteAccessVpn>();\n            final List<PortForwardingRule> pfRules = new ArrayList<PortForwardingRule>();\n            final List<FirewallRule> staticNatFirewallRules = new ArrayList<FirewallRule>();\n            final List<StaticNat> staticNats = new ArrayList<StaticNat>();\n            final List<FirewallRule> firewallRulesIngress = new ArrayList<FirewallRule>();\n\n            \r\n            \r\n            for (final PublicIpAddress ip : publicIps) {\n                if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.PortForwarding, provider)) {\n                    pfRules.addAll(_pfRulesDao.listForApplication(ip.getId()));\n                }\n                if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.StaticNat, provider)) {\n                    staticNatFirewallRules.addAll(_rulesDao.listByIpAndPurpose(ip.getId(), Purpose.StaticNat));\n                }\n                if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.Firewall, provider)) {\n                    firewallRulesIngress.addAll(_rulesDao.listByIpAndPurpose(ip.getId(), Purpose.Firewall));\n                }\n\n                if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.Vpn, provider)) {\n                    final RemoteAccessVpn vpn = _vpnDao.findByPublicIpAddress(ip.getId());\n                    if (vpn != null) {\n                        vpns.add(vpn);\n                    }\n                }\n\n                if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.StaticNat, provider)) {\n                    if (ip.isOneToOneNat()) {\n\n                        boolean revoke = false;\n                        if (ip.getState() == IpAddress.State.Releasing ) {\n                            \r\n                            s_logger.debug(\"Rule revoke set to true for the ip \" + ip.getAddress() +\" becasue it is in releasing state\");\n                            revoke = true;\n                        }\n                        final StaticNatImpl staticNat = new StaticNatImpl(ip.getAccountId(), ip.getDomainId(), guestNetworkId, ip.getId(), ip.getVmIp(), revoke);\n\n                        staticNats.add(staticNat);\n                    }\n                }\n            }\n\n            \r\n            s_logger.debug(\"Found \" + staticNats.size() + \" static nat(s) to apply as a part of domR \" + router + \" start.\");\n            if (!staticNats.isEmpty()) {\n                _commandSetupHelper.createApplyStaticNatCommands(staticNats, router, cmds, guestNetworkId);\n            }\n\n            \r\n            s_logger.debug(\"Found \" + firewallRulesIngress.size() + \" firewall Ingress rule(s) to apply as a part of domR \" + router + \" start.\");\n            if (!firewallRulesIngress.isEmpty()) {\n                _commandSetupHelper.createFirewallRulesCommands(firewallRulesIngress, router, cmds, guestNetworkId);\n            }\n\n            \r\n            s_logger.debug(\"Found \" + pfRules.size() + \" port forwarding rule(s) to apply as a part of domR \" + router + \" start.\");\n            if (!pfRules.isEmpty()) {\n                _commandSetupHelper.createApplyPortForwardingRulesCommands(pfRules, router, cmds, guestNetworkId);\n            }\n\n            \r\n            s_logger.debug(\"Found \" + staticNatFirewallRules.size() + \" static nat rule(s) to apply as a part of domR \" + router + \" start.\");\n            if (!staticNatFirewallRules.isEmpty()) {\n                final List<StaticNatRule> staticNatRules = new ArrayList<StaticNatRule>();\n                for (final FirewallRule rule : staticNatFirewallRules) {\n                    staticNatRules.add(_rulesMgr.buildStaticNatRule(rule, false));\n                }\n                _commandSetupHelper.createApplyStaticNatRulesCommands(staticNatRules, router, cmds, guestNetworkId);\n            }\n\n            \r\n            s_logger.debug(\"Found \" + vpns.size() + \" vpn(s) to apply as a part of domR \" + router + \" start.\");\n            if (!vpns.isEmpty()) {\n                for (final RemoteAccessVpn vpn : vpns) {\n                    _commandSetupHelper.createApplyVpnCommands(true, vpn, router, cmds);\n                }\n            }\n\n            final List<LoadBalancerVO> lbs = _loadBalancerDao.listByNetworkIdAndScheme(guestNetworkId, Scheme.Public);\n            final List<LoadBalancingRule> lbRules = new ArrayList<LoadBalancingRule>();\n            if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.Lb, provider)) {\n                \r\n                for (final LoadBalancerVO lb : lbs) {\n                    final List<LbDestination> dstList = _lbMgr.getExistingDestinations(lb.getId());\n                    final List<LbStickinessPolicy> policyList = _lbMgr.getStickinessPolicies(lb.getId());\n                    final List<LbHealthCheckPolicy> hcPolicyList = _lbMgr.getHealthCheckPolicies(lb.getId());\n                    final Ip sourceIp = _networkModel.getPublicIpAddress(lb.getSourceIpAddressId()).getAddress();\n                    final LbSslCert sslCert = _lbMgr.getLbSslCert(lb.getId());\n                    final LoadBalancingRule loadBalancing = new LoadBalancingRule(lb, dstList, policyList, hcPolicyList, sourceIp, sslCert, lb.getLbProtocol());\n                    lbRules.add(loadBalancing);\n                }\n            }\n\n            s_logger.debug(\"Found \" + lbRules.size() + \" load balancing rule(s) to apply as a part of domR \" + router + \" start.\");\n            if (!lbRules.isEmpty()) {\n                _commandSetupHelper.createApplyLoadBalancingRulesCommands(lbRules, router, cmds, guestNetworkId);\n            }\n        }\n        \r\n        final Network guestNetwork = _networkDao.findById(guestNetworkId);\n        if (guestNetwork.getGuestType() == GuestType.Shared && _networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.Dhcp, provider)) {\n            final Map<Network.Capability, String> dhcpCapabilities = _networkSvc.getNetworkOfferingServiceCapabilities(\n                    _networkOfferingDao.findById(_networkDao.findById(guestNetworkId).getNetworkOfferingId()), Service.Dhcp);\n            final String supportsMultipleSubnets = dhcpCapabilities.get(Network.Capability.DhcpAccrossMultipleSubnets);\n            if (supportsMultipleSubnets != null && Boolean.valueOf(supportsMultipleSubnets)) {\n                final List<NicIpAliasVO> revokedIpAliasVOs = _nicIpAliasDao.listByNetworkIdAndState(guestNetworkId, NicIpAlias.State.revoked);\n                s_logger.debug(\"Found\" + revokedIpAliasVOs.size() + \"ip Aliases to revoke on the router as a part of dhcp configuration\");\n                removeRevokedIpAliasFromDb(revokedIpAliasVOs);\n\n                final List<NicIpAliasVO> aliasVOs = _nicIpAliasDao.listByNetworkIdAndState(guestNetworkId, NicIpAlias.State.active);\n                s_logger.debug(\"Found\" + aliasVOs.size() + \"ip Aliases to apply on the router as a part of dhcp configuration\");\n                final List<IpAliasTO> activeIpAliasTOs = new ArrayList<IpAliasTO>();\n                for (final NicIpAliasVO aliasVO : aliasVOs) {\n                    activeIpAliasTOs.add(new IpAliasTO(aliasVO.getIp4Address(), aliasVO.getNetmask(), aliasVO.getAliasCount().toString()));\n                }\n                if (activeIpAliasTOs.size() != 0) {\n                    _commandSetupHelper.createIpAlias(router, activeIpAliasTOs, guestNetworkId, cmds);\n                    _commandSetupHelper.configDnsMasq(router, _networkDao.findById(guestNetworkId), cmds);\n                }\n            }\n        }\n    }\n","date":"2018-01-20 05:49:27","endLine":1945,"groupId":"18341","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"finalizeNetworkRulesForNetwork","params":"(finalCommandscmds@finalDomainRouterVOrouter@finalProviderprovider@finalLongguestNetworkId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/f3/035d05e61271ea58a41be185404248abc43aea.src","preCode":"    protected void finalizeNetworkRulesForNetwork(final Commands cmds, final DomainRouterVO router, final Provider provider, final Long guestNetworkId) {\n        s_logger.debug(\"Resending ipAssoc, port forwarding, load balancing rules as a part of Virtual router start\");\n\n        final ArrayList<? extends PublicIpAddress> publicIps = getPublicIpsToApply(router, provider, guestNetworkId);\n        final List<FirewallRule> firewallRulesEgress = new ArrayList<FirewallRule>();\n\n        \r\n        if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.Firewall, provider)) {\n            firewallRulesEgress.addAll(_rulesDao.listByNetworkPurposeTrafficType(guestNetworkId, Purpose.Firewall, FirewallRule.TrafficType.Egress));\n            if (firewallRulesEgress.isEmpty()) {\n                \r\n                createDefaultEgressFirewallRule(firewallRulesEgress, guestNetworkId);\n            }\n        }\n\n        \r\n        s_logger.debug(\"Found \" + firewallRulesEgress.size() + \" firewall Egress rule(s) to apply as a part of domR \" + router + \" start.\");\n        if (!firewallRulesEgress.isEmpty()) {\n            _commandSetupHelper.createFirewallRulesCommands(firewallRulesEgress, router, cmds, guestNetworkId);\n        }\n\n        if (publicIps != null && !publicIps.isEmpty()) {\n            final List<RemoteAccessVpn> vpns = new ArrayList<RemoteAccessVpn>();\n            final List<PortForwardingRule> pfRules = new ArrayList<PortForwardingRule>();\n            final List<FirewallRule> staticNatFirewallRules = new ArrayList<FirewallRule>();\n            final List<StaticNat> staticNats = new ArrayList<StaticNat>();\n            final List<FirewallRule> firewallRulesIngress = new ArrayList<FirewallRule>();\n\n            \r\n            \r\n            for (final PublicIpAddress ip : publicIps) {\n                if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.PortForwarding, provider)) {\n                    pfRules.addAll(_pfRulesDao.listForApplication(ip.getId()));\n                }\n                if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.StaticNat, provider)) {\n                    staticNatFirewallRules.addAll(_rulesDao.listByIpAndPurpose(ip.getId(), Purpose.StaticNat));\n                }\n                if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.Firewall, provider)) {\n                    firewallRulesIngress.addAll(_rulesDao.listByIpAndPurpose(ip.getId(), Purpose.Firewall));\n                }\n\n                if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.Vpn, provider)) {\n                    final RemoteAccessVpn vpn = _vpnDao.findByPublicIpAddress(ip.getId());\n                    if (vpn != null) {\n                        vpns.add(vpn);\n                    }\n                }\n\n                if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.StaticNat, provider)) {\n                    if (ip.isOneToOneNat()) {\n\n                        boolean revoke = false;\n                        if (ip.getState() == IpAddress.State.Releasing ) {\n                            \r\n                            s_logger.debug(\"Rule revoke set to true for the ip \" + ip.getAddress() +\" becasue it is in releasing state\");\n                            revoke = true;\n                        }\n                        final StaticNatImpl staticNat = new StaticNatImpl(ip.getAccountId(), ip.getDomainId(), guestNetworkId, ip.getId(), ip.getVmIp(), revoke);\n\n                        staticNats.add(staticNat);\n                    }\n                }\n            }\n\n            \r\n            s_logger.debug(\"Found \" + staticNats.size() + \" static nat(s) to apply as a part of domR \" + router + \" start.\");\n            if (!staticNats.isEmpty()) {\n                _commandSetupHelper.createApplyStaticNatCommands(staticNats, router, cmds, guestNetworkId);\n            }\n\n            \r\n            s_logger.debug(\"Found \" + firewallRulesIngress.size() + \" firewall Ingress rule(s) to apply as a part of domR \" + router + \" start.\");\n            if (!firewallRulesIngress.isEmpty()) {\n                _commandSetupHelper.createFirewallRulesCommands(firewallRulesIngress, router, cmds, guestNetworkId);\n            }\n\n            \r\n            s_logger.debug(\"Found \" + pfRules.size() + \" port forwarding rule(s) to apply as a part of domR \" + router + \" start.\");\n            if (!pfRules.isEmpty()) {\n                _commandSetupHelper.createApplyPortForwardingRulesCommands(pfRules, router, cmds, guestNetworkId);\n            }\n\n            \r\n            s_logger.debug(\"Found \" + staticNatFirewallRules.size() + \" static nat rule(s) to apply as a part of domR \" + router + \" start.\");\n            if (!staticNatFirewallRules.isEmpty()) {\n                final List<StaticNatRule> staticNatRules = new ArrayList<StaticNatRule>();\n                for (final FirewallRule rule : staticNatFirewallRules) {\n                    staticNatRules.add(_rulesMgr.buildStaticNatRule(rule, false));\n                }\n                _commandSetupHelper.createApplyStaticNatRulesCommands(staticNatRules, router, cmds, guestNetworkId);\n            }\n\n            \r\n            s_logger.debug(\"Found \" + vpns.size() + \" vpn(s) to apply as a part of domR \" + router + \" start.\");\n            if (!vpns.isEmpty()) {\n                for (final RemoteAccessVpn vpn : vpns) {\n                    _commandSetupHelper.createApplyVpnCommands(true, vpn, router, cmds);\n                }\n            }\n\n            final List<LoadBalancerVO> lbs = _loadBalancerDao.listByNetworkIdAndScheme(guestNetworkId, Scheme.Public);\n            final List<LoadBalancingRule> lbRules = new ArrayList<LoadBalancingRule>();\n            if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.Lb, provider)) {\n                \r\n                for (final LoadBalancerVO lb : lbs) {\n                    final List<LbDestination> dstList = _lbMgr.getExistingDestinations(lb.getId());\n                    final List<LbStickinessPolicy> policyList = _lbMgr.getStickinessPolicies(lb.getId());\n                    final List<LbHealthCheckPolicy> hcPolicyList = _lbMgr.getHealthCheckPolicies(lb.getId());\n                    final Ip sourceIp = _networkModel.getPublicIpAddress(lb.getSourceIpAddressId()).getAddress();\n                    final LbSslCert sslCert = _lbMgr.getLbSslCert(lb.getId());\n                    final LoadBalancingRule loadBalancing = new LoadBalancingRule(lb, dstList, policyList, hcPolicyList, sourceIp, sslCert, lb.getLbProtocol());\n                    lbRules.add(loadBalancing);\n                }\n            }\n\n            s_logger.debug(\"Found \" + lbRules.size() + \" load balancing rule(s) to apply as a part of domR \" + router + \" start.\");\n            if (!lbRules.isEmpty()) {\n                _commandSetupHelper.createApplyLoadBalancingRulesCommands(lbRules, router, cmds, guestNetworkId);\n            }\n        }\n        \r\n        final Network guestNetwork = _networkDao.findById(guestNetworkId);\n        if (guestNetwork.getGuestType() == GuestType.Shared && _networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.Dhcp, provider)) {\n            final Map<Network.Capability, String> dhcpCapabilities = _networkSvc.getNetworkOfferingServiceCapabilities(\n                    _networkOfferingDao.findById(_networkDao.findById(guestNetworkId).getNetworkOfferingId()), Service.Dhcp);\n            final String supportsMultipleSubnets = dhcpCapabilities.get(Network.Capability.DhcpAccrossMultipleSubnets);\n            if (supportsMultipleSubnets != null && Boolean.valueOf(supportsMultipleSubnets)) {\n                final List<NicIpAliasVO> revokedIpAliasVOs = _nicIpAliasDao.listByNetworkIdAndState(guestNetworkId, NicIpAlias.State.revoked);\n                s_logger.debug(\"Found\" + revokedIpAliasVOs.size() + \"ip Aliases to revoke on the router as a part of dhcp configuration\");\n                removeRevokedIpAliasFromDb(revokedIpAliasVOs);\n\n                final List<NicIpAliasVO> aliasVOs = _nicIpAliasDao.listByNetworkIdAndState(guestNetworkId, NicIpAlias.State.active);\n                s_logger.debug(\"Found\" + aliasVOs.size() + \"ip Aliases to apply on the router as a part of dhcp configuration\");\n                final List<IpAliasTO> activeIpAliasTOs = new ArrayList<IpAliasTO>();\n                for (final NicIpAliasVO aliasVO : aliasVOs) {\n                    activeIpAliasTOs.add(new IpAliasTO(aliasVO.getIp4Address(), aliasVO.getNetmask(), aliasVO.getAliasCount().toString()));\n                }\n                if (activeIpAliasTOs.size() != 0) {\n                    _commandSetupHelper.createIpAlias(router, activeIpAliasTOs, guestNetworkId, cmds);\n                    _commandSetupHelper.configDnsMasq(router, _networkDao.findById(guestNetworkId), cmds);\n                }\n            }\n        }\n    }\n","realPath":"server/src/main/java/com/cloud/network/router/VirtualNetworkApplianceManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1802,"status":"B"},{"authorDate":"2018-01-20 05:49:27","commitOrder":1,"curCode":"    protected void finalizeLbRulesForIp(final Commands cmds, final DomainRouterVO internalLbVm, final Provider provider, final Ip sourceIp, final long guestNtwkId) {\n        s_logger.debug(\"Resending load balancing rules as a part of start for \" + internalLbVm);\n        final List<ApplicationLoadBalancerRuleVO> lbs = _lbDao.listBySrcIpSrcNtwkId(sourceIp, guestNtwkId);\n        final List<LoadBalancingRule> lbRules = new ArrayList<LoadBalancingRule>();\n        if (_ntwkModel.isProviderSupportServiceInNetwork(guestNtwkId, Service.Lb, provider)) {\n            \r\n            for (final ApplicationLoadBalancerRuleVO lb : lbs) {\n                final List<LbDestination> dstList = _lbMgr.getExistingDestinations(lb.getId());\n                final List<LbStickinessPolicy> policyList = _lbMgr.getStickinessPolicies(lb.getId());\n                final List<LbHealthCheckPolicy> hcPolicyList = _lbMgr.getHealthCheckPolicies(lb.getId());\n                final LoadBalancingRule loadBalancing = new LoadBalancingRule(lb, dstList, policyList, hcPolicyList, sourceIp);\n                lbRules.add(loadBalancing);\n            }\n        }\n\n        s_logger.debug(\"Found \" + lbRules.size() + \" load balancing rule(s) to apply as a part of Intenrnal LB vm\" + internalLbVm + \" start.\");\n        if (!lbRules.isEmpty()) {\n            createApplyLoadBalancingRulesCommands(lbRules, internalLbVm, cmds, guestNtwkId);\n        }\n    }\n","date":"2018-01-20 05:49:27","endLine":446,"groupId":"6965","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"finalizeLbRulesForIp","params":"(finalCommandscmds@finalDomainRouterVOinternalLbVm@finalProviderprovider@finalIpsourceIp@finallongguestNtwkId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/52/ecebc08bcfe21b12ef4861a469e743c51bb7c3.src","preCode":"    protected void finalizeLbRulesForIp(final Commands cmds, final DomainRouterVO internalLbVm, final Provider provider, final Ip sourceIp, final long guestNtwkId) {\n        s_logger.debug(\"Resending load balancing rules as a part of start for \" + internalLbVm);\n        final List<ApplicationLoadBalancerRuleVO> lbs = _lbDao.listBySrcIpSrcNtwkId(sourceIp, guestNtwkId);\n        final List<LoadBalancingRule> lbRules = new ArrayList<LoadBalancingRule>();\n        if (_ntwkModel.isProviderSupportServiceInNetwork(guestNtwkId, Service.Lb, provider)) {\n            \r\n            for (final ApplicationLoadBalancerRuleVO lb : lbs) {\n                final List<LbDestination> dstList = _lbMgr.getExistingDestinations(lb.getId());\n                final List<LbStickinessPolicy> policyList = _lbMgr.getStickinessPolicies(lb.getId());\n                final List<LbHealthCheckPolicy> hcPolicyList = _lbMgr.getHealthCheckPolicies(lb.getId());\n                final LoadBalancingRule loadBalancing = new LoadBalancingRule(lb, dstList, policyList, hcPolicyList, sourceIp);\n                lbRules.add(loadBalancing);\n            }\n        }\n\n        s_logger.debug(\"Found \" + lbRules.size() + \" load balancing rule(s) to apply as a part of Intenrnal LB vm\" + internalLbVm + \" start.\");\n        if (!lbRules.isEmpty()) {\n            createApplyLoadBalancingRulesCommands(lbRules, internalLbVm, cmds, guestNtwkId);\n        }\n    }\n","realPath":"plugins/network-elements/internal-loadbalancer/src/main/java/org/apache/cloudstack/network/lb/InternalLoadBalancerVMManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":427,"status":"B"}],"commitId":"893a88d225276e45f12f9490e6af2c94a81c2965","commitMessage":"@@@CLOUDSTACK-10105: Use maven standard project structure in all projects (#2283)\n\nRemove maven standard module (which only a few were using) and get ride of maven customization for the projects structure.\n\n- moved all directories to src/main/java.  src/main/resources.  src/main/scripts.  src/test/java.  src/test/resources\n- grep scan to search for src/com and src/org left over\n- grep for <project>/scripts to fix pom.xml configuration\n- remove custom <build> configuration in pom.xml\n\nSigned-off-by: Marc-Aur?le Brothier <m@brothier.org>","date":"2018-01-20 05:49:27","modifiedFileCount":"1","status":"B","submitter":"Marc-Aur?le Brothier"},{"authorTime":"2018-01-20 05:49:27","codes":[{"authorDate":"2020-02-24 05:23:50","commitOrder":2,"curCode":"    protected void finalizeNetworkRulesForNetwork(final Commands cmds, final DomainRouterVO router, final Provider provider, final Long guestNetworkId) {\n        s_logger.debug(\"Resending ipAssoc, port forwarding, load balancing rules as a part of Virtual router start\");\n\n        final ArrayList<? extends PublicIpAddress> publicIps = getPublicIpsToApply(router, provider, guestNetworkId);\n        final List<FirewallRule> firewallRulesEgress = new ArrayList<FirewallRule>();\n\n        \r\n        if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.Firewall, provider)) {\n            firewallRulesEgress.addAll(_rulesDao.listByNetworkPurposeTrafficType(guestNetworkId, Purpose.Firewall, FirewallRule.TrafficType.Egress));\n            \r\n            createDefaultEgressFirewallRule(firewallRulesEgress, guestNetworkId);\n        }\n\n        \r\n        s_logger.debug(\"Found \" + firewallRulesEgress.size() + \" firewall Egress rule(s) to apply as a part of domR \" + router + \" start.\");\n        if (!firewallRulesEgress.isEmpty()) {\n            _commandSetupHelper.createFirewallRulesCommands(firewallRulesEgress, router, cmds, guestNetworkId);\n        }\n\n        if (publicIps != null && !publicIps.isEmpty()) {\n            final List<RemoteAccessVpn> vpns = new ArrayList<RemoteAccessVpn>();\n            final List<PortForwardingRule> pfRules = new ArrayList<PortForwardingRule>();\n            final List<FirewallRule> staticNatFirewallRules = new ArrayList<FirewallRule>();\n            final List<StaticNat> staticNats = new ArrayList<StaticNat>();\n            final List<FirewallRule> firewallRulesIngress = new ArrayList<FirewallRule>();\n\n            \r\n            \r\n            for (final PublicIpAddress ip : publicIps) {\n                if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.PortForwarding, provider)) {\n                    pfRules.addAll(_pfRulesDao.listForApplication(ip.getId()));\n                }\n                if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.StaticNat, provider)) {\n                    staticNatFirewallRules.addAll(_rulesDao.listByIpAndPurpose(ip.getId(), Purpose.StaticNat));\n                }\n                if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.Firewall, provider)) {\n                    firewallRulesIngress.addAll(_rulesDao.listByIpAndPurpose(ip.getId(), Purpose.Firewall));\n                }\n\n                if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.Vpn, provider)) {\n                    final RemoteAccessVpn vpn = _vpnDao.findByPublicIpAddress(ip.getId());\n                    if (vpn != null) {\n                        vpns.add(vpn);\n                    }\n                }\n\n                if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.StaticNat, provider)) {\n                    if (ip.isOneToOneNat()) {\n\n                        boolean revoke = false;\n                        if (ip.getState() == IpAddress.State.Releasing ) {\n                            \r\n                            s_logger.debug(\"Rule revoke set to true for the ip \" + ip.getAddress() +\" becasue it is in releasing state\");\n                            revoke = true;\n                        }\n                        final StaticNatImpl staticNat = new StaticNatImpl(ip.getAccountId(), ip.getDomainId(), guestNetworkId, ip.getId(), ip.getVmIp(), revoke);\n\n                        staticNats.add(staticNat);\n                    }\n                }\n            }\n\n            \r\n            s_logger.debug(\"Found \" + staticNats.size() + \" static nat(s) to apply as a part of domR \" + router + \" start.\");\n            if (!staticNats.isEmpty()) {\n                _commandSetupHelper.createApplyStaticNatCommands(staticNats, router, cmds, guestNetworkId);\n            }\n\n            \r\n            s_logger.debug(\"Found \" + firewallRulesIngress.size() + \" firewall Ingress rule(s) to apply as a part of domR \" + router + \" start.\");\n            if (!firewallRulesIngress.isEmpty()) {\n                _commandSetupHelper.createFirewallRulesCommands(firewallRulesIngress, router, cmds, guestNetworkId);\n            }\n\n            \r\n            s_logger.debug(\"Found \" + pfRules.size() + \" port forwarding rule(s) to apply as a part of domR \" + router + \" start.\");\n            if (!pfRules.isEmpty()) {\n                _commandSetupHelper.createApplyPortForwardingRulesCommands(pfRules, router, cmds, guestNetworkId);\n            }\n\n            \r\n            s_logger.debug(\"Found \" + staticNatFirewallRules.size() + \" static nat rule(s) to apply as a part of domR \" + router + \" start.\");\n            if (!staticNatFirewallRules.isEmpty()) {\n                final List<StaticNatRule> staticNatRules = new ArrayList<StaticNatRule>();\n                for (final FirewallRule rule : staticNatFirewallRules) {\n                    staticNatRules.add(_rulesMgr.buildStaticNatRule(rule, false));\n                }\n                _commandSetupHelper.createApplyStaticNatRulesCommands(staticNatRules, router, cmds, guestNetworkId);\n            }\n\n            \r\n            s_logger.debug(\"Found \" + vpns.size() + \" vpn(s) to apply as a part of domR \" + router + \" start.\");\n            if (!vpns.isEmpty()) {\n                for (final RemoteAccessVpn vpn : vpns) {\n                    _commandSetupHelper.createApplyVpnCommands(true, vpn, router, cmds);\n                }\n            }\n\n            final List<LoadBalancerVO> lbs = _loadBalancerDao.listByNetworkIdAndScheme(guestNetworkId, Scheme.Public);\n            final List<LoadBalancingRule> lbRules = new ArrayList<LoadBalancingRule>();\n            if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.Lb, provider)) {\n                \r\n                for (final LoadBalancerVO lb : lbs) {\n                    final List<LbDestination> dstList = _lbMgr.getExistingDestinations(lb.getId());\n                    final List<LbStickinessPolicy> policyList = _lbMgr.getStickinessPolicies(lb.getId());\n                    final List<LbHealthCheckPolicy> hcPolicyList = _lbMgr.getHealthCheckPolicies(lb.getId());\n                    final Ip sourceIp = _networkModel.getPublicIpAddress(lb.getSourceIpAddressId()).getAddress();\n                    final LbSslCert sslCert = _lbMgr.getLbSslCert(lb.getId());\n                    final LoadBalancingRule loadBalancing = new LoadBalancingRule(lb, dstList, policyList, hcPolicyList, sourceIp, sslCert, lb.getLbProtocol());\n                    lbRules.add(loadBalancing);\n                }\n            }\n\n            s_logger.debug(\"Found \" + lbRules.size() + \" load balancing rule(s) to apply as a part of domR \" + router + \" start.\");\n            if (!lbRules.isEmpty()) {\n                _commandSetupHelper.createApplyLoadBalancingRulesCommands(lbRules, router, cmds, guestNetworkId);\n            }\n        }\n        \r\n        final Network guestNetwork = _networkDao.findById(guestNetworkId);\n        if (guestNetwork.getGuestType() == GuestType.Shared && _networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.Dhcp, provider)) {\n            final Map<Network.Capability, String> dhcpCapabilities = _networkSvc.getNetworkOfferingServiceCapabilities(\n                    _networkOfferingDao.findById(_networkDao.findById(guestNetworkId).getNetworkOfferingId()), Service.Dhcp);\n            final String supportsMultipleSubnets = dhcpCapabilities.get(Network.Capability.DhcpAccrossMultipleSubnets);\n            if (supportsMultipleSubnets != null && Boolean.valueOf(supportsMultipleSubnets)) {\n                final List<NicIpAliasVO> revokedIpAliasVOs = _nicIpAliasDao.listByNetworkIdAndState(guestNetworkId, NicIpAlias.State.revoked);\n                s_logger.debug(\"Found\" + revokedIpAliasVOs.size() + \"ip Aliases to revoke on the router as a part of dhcp configuration\");\n                removeRevokedIpAliasFromDb(revokedIpAliasVOs);\n\n                final List<NicIpAliasVO> aliasVOs = _nicIpAliasDao.listByNetworkIdAndState(guestNetworkId, NicIpAlias.State.active);\n                s_logger.debug(\"Found\" + aliasVOs.size() + \"ip Aliases to apply on the router as a part of dhcp configuration\");\n                final List<IpAliasTO> activeIpAliasTOs = new ArrayList<IpAliasTO>();\n                for (final NicIpAliasVO aliasVO : aliasVOs) {\n                    activeIpAliasTOs.add(new IpAliasTO(aliasVO.getIp4Address(), aliasVO.getNetmask(), aliasVO.getAliasCount().toString()));\n                }\n                if (activeIpAliasTOs.size() != 0) {\n                    _commandSetupHelper.createIpAlias(router, activeIpAliasTOs, guestNetworkId, cmds);\n                    _commandSetupHelper.configDnsMasq(router, _networkDao.findById(guestNetworkId), cmds);\n                }\n            }\n        }\n    }\n","date":"2020-02-24 05:23:50","endLine":2583,"groupId":"101830","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"finalizeNetworkRulesForNetwork","params":"(finalCommandscmds@finalDomainRouterVOrouter@finalProviderprovider@finalLongguestNetworkId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/ab/e00dd7d4719cc6fb3de26f12f6275f73cf39f0.src","preCode":"    protected void finalizeNetworkRulesForNetwork(final Commands cmds, final DomainRouterVO router, final Provider provider, final Long guestNetworkId) {\n        s_logger.debug(\"Resending ipAssoc, port forwarding, load balancing rules as a part of Virtual router start\");\n\n        final ArrayList<? extends PublicIpAddress> publicIps = getPublicIpsToApply(router, provider, guestNetworkId);\n        final List<FirewallRule> firewallRulesEgress = new ArrayList<FirewallRule>();\n\n        \r\n        if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.Firewall, provider)) {\n            firewallRulesEgress.addAll(_rulesDao.listByNetworkPurposeTrafficType(guestNetworkId, Purpose.Firewall, FirewallRule.TrafficType.Egress));\n            if (firewallRulesEgress.isEmpty()) {\n                \r\n                createDefaultEgressFirewallRule(firewallRulesEgress, guestNetworkId);\n            }\n        }\n\n        \r\n        s_logger.debug(\"Found \" + firewallRulesEgress.size() + \" firewall Egress rule(s) to apply as a part of domR \" + router + \" start.\");\n        if (!firewallRulesEgress.isEmpty()) {\n            _commandSetupHelper.createFirewallRulesCommands(firewallRulesEgress, router, cmds, guestNetworkId);\n        }\n\n        if (publicIps != null && !publicIps.isEmpty()) {\n            final List<RemoteAccessVpn> vpns = new ArrayList<RemoteAccessVpn>();\n            final List<PortForwardingRule> pfRules = new ArrayList<PortForwardingRule>();\n            final List<FirewallRule> staticNatFirewallRules = new ArrayList<FirewallRule>();\n            final List<StaticNat> staticNats = new ArrayList<StaticNat>();\n            final List<FirewallRule> firewallRulesIngress = new ArrayList<FirewallRule>();\n\n            \r\n            \r\n            for (final PublicIpAddress ip : publicIps) {\n                if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.PortForwarding, provider)) {\n                    pfRules.addAll(_pfRulesDao.listForApplication(ip.getId()));\n                }\n                if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.StaticNat, provider)) {\n                    staticNatFirewallRules.addAll(_rulesDao.listByIpAndPurpose(ip.getId(), Purpose.StaticNat));\n                }\n                if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.Firewall, provider)) {\n                    firewallRulesIngress.addAll(_rulesDao.listByIpAndPurpose(ip.getId(), Purpose.Firewall));\n                }\n\n                if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.Vpn, provider)) {\n                    final RemoteAccessVpn vpn = _vpnDao.findByPublicIpAddress(ip.getId());\n                    if (vpn != null) {\n                        vpns.add(vpn);\n                    }\n                }\n\n                if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.StaticNat, provider)) {\n                    if (ip.isOneToOneNat()) {\n\n                        boolean revoke = false;\n                        if (ip.getState() == IpAddress.State.Releasing ) {\n                            \r\n                            s_logger.debug(\"Rule revoke set to true for the ip \" + ip.getAddress() +\" becasue it is in releasing state\");\n                            revoke = true;\n                        }\n                        final StaticNatImpl staticNat = new StaticNatImpl(ip.getAccountId(), ip.getDomainId(), guestNetworkId, ip.getId(), ip.getVmIp(), revoke);\n\n                        staticNats.add(staticNat);\n                    }\n                }\n            }\n\n            \r\n            s_logger.debug(\"Found \" + staticNats.size() + \" static nat(s) to apply as a part of domR \" + router + \" start.\");\n            if (!staticNats.isEmpty()) {\n                _commandSetupHelper.createApplyStaticNatCommands(staticNats, router, cmds, guestNetworkId);\n            }\n\n            \r\n            s_logger.debug(\"Found \" + firewallRulesIngress.size() + \" firewall Ingress rule(s) to apply as a part of domR \" + router + \" start.\");\n            if (!firewallRulesIngress.isEmpty()) {\n                _commandSetupHelper.createFirewallRulesCommands(firewallRulesIngress, router, cmds, guestNetworkId);\n            }\n\n            \r\n            s_logger.debug(\"Found \" + pfRules.size() + \" port forwarding rule(s) to apply as a part of domR \" + router + \" start.\");\n            if (!pfRules.isEmpty()) {\n                _commandSetupHelper.createApplyPortForwardingRulesCommands(pfRules, router, cmds, guestNetworkId);\n            }\n\n            \r\n            s_logger.debug(\"Found \" + staticNatFirewallRules.size() + \" static nat rule(s) to apply as a part of domR \" + router + \" start.\");\n            if (!staticNatFirewallRules.isEmpty()) {\n                final List<StaticNatRule> staticNatRules = new ArrayList<StaticNatRule>();\n                for (final FirewallRule rule : staticNatFirewallRules) {\n                    staticNatRules.add(_rulesMgr.buildStaticNatRule(rule, false));\n                }\n                _commandSetupHelper.createApplyStaticNatRulesCommands(staticNatRules, router, cmds, guestNetworkId);\n            }\n\n            \r\n            s_logger.debug(\"Found \" + vpns.size() + \" vpn(s) to apply as a part of domR \" + router + \" start.\");\n            if (!vpns.isEmpty()) {\n                for (final RemoteAccessVpn vpn : vpns) {\n                    _commandSetupHelper.createApplyVpnCommands(true, vpn, router, cmds);\n                }\n            }\n\n            final List<LoadBalancerVO> lbs = _loadBalancerDao.listByNetworkIdAndScheme(guestNetworkId, Scheme.Public);\n            final List<LoadBalancingRule> lbRules = new ArrayList<LoadBalancingRule>();\n            if (_networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.Lb, provider)) {\n                \r\n                for (final LoadBalancerVO lb : lbs) {\n                    final List<LbDestination> dstList = _lbMgr.getExistingDestinations(lb.getId());\n                    final List<LbStickinessPolicy> policyList = _lbMgr.getStickinessPolicies(lb.getId());\n                    final List<LbHealthCheckPolicy> hcPolicyList = _lbMgr.getHealthCheckPolicies(lb.getId());\n                    final Ip sourceIp = _networkModel.getPublicIpAddress(lb.getSourceIpAddressId()).getAddress();\n                    final LbSslCert sslCert = _lbMgr.getLbSslCert(lb.getId());\n                    final LoadBalancingRule loadBalancing = new LoadBalancingRule(lb, dstList, policyList, hcPolicyList, sourceIp, sslCert, lb.getLbProtocol());\n                    lbRules.add(loadBalancing);\n                }\n            }\n\n            s_logger.debug(\"Found \" + lbRules.size() + \" load balancing rule(s) to apply as a part of domR \" + router + \" start.\");\n            if (!lbRules.isEmpty()) {\n                _commandSetupHelper.createApplyLoadBalancingRulesCommands(lbRules, router, cmds, guestNetworkId);\n            }\n        }\n        \r\n        final Network guestNetwork = _networkDao.findById(guestNetworkId);\n        if (guestNetwork.getGuestType() == GuestType.Shared && _networkModel.isProviderSupportServiceInNetwork(guestNetworkId, Service.Dhcp, provider)) {\n            final Map<Network.Capability, String> dhcpCapabilities = _networkSvc.getNetworkOfferingServiceCapabilities(\n                    _networkOfferingDao.findById(_networkDao.findById(guestNetworkId).getNetworkOfferingId()), Service.Dhcp);\n            final String supportsMultipleSubnets = dhcpCapabilities.get(Network.Capability.DhcpAccrossMultipleSubnets);\n            if (supportsMultipleSubnets != null && Boolean.valueOf(supportsMultipleSubnets)) {\n                final List<NicIpAliasVO> revokedIpAliasVOs = _nicIpAliasDao.listByNetworkIdAndState(guestNetworkId, NicIpAlias.State.revoked);\n                s_logger.debug(\"Found\" + revokedIpAliasVOs.size() + \"ip Aliases to revoke on the router as a part of dhcp configuration\");\n                removeRevokedIpAliasFromDb(revokedIpAliasVOs);\n\n                final List<NicIpAliasVO> aliasVOs = _nicIpAliasDao.listByNetworkIdAndState(guestNetworkId, NicIpAlias.State.active);\n                s_logger.debug(\"Found\" + aliasVOs.size() + \"ip Aliases to apply on the router as a part of dhcp configuration\");\n                final List<IpAliasTO> activeIpAliasTOs = new ArrayList<IpAliasTO>();\n                for (final NicIpAliasVO aliasVO : aliasVOs) {\n                    activeIpAliasTOs.add(new IpAliasTO(aliasVO.getIp4Address(), aliasVO.getNetmask(), aliasVO.getAliasCount().toString()));\n                }\n                if (activeIpAliasTOs.size() != 0) {\n                    _commandSetupHelper.createIpAlias(router, activeIpAliasTOs, guestNetworkId, cmds);\n                    _commandSetupHelper.configDnsMasq(router, _networkDao.findById(guestNetworkId), cmds);\n                }\n            }\n        }\n    }\n","realPath":"server/src/main/java/com/cloud/network/router/VirtualNetworkApplianceManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":2442,"status":"M"},{"authorDate":"2018-01-20 05:49:27","commitOrder":2,"curCode":"    protected void finalizeLbRulesForIp(final Commands cmds, final DomainRouterVO internalLbVm, final Provider provider, final Ip sourceIp, final long guestNtwkId) {\n        s_logger.debug(\"Resending load balancing rules as a part of start for \" + internalLbVm);\n        final List<ApplicationLoadBalancerRuleVO> lbs = _lbDao.listBySrcIpSrcNtwkId(sourceIp, guestNtwkId);\n        final List<LoadBalancingRule> lbRules = new ArrayList<LoadBalancingRule>();\n        if (_ntwkModel.isProviderSupportServiceInNetwork(guestNtwkId, Service.Lb, provider)) {\n            \r\n            for (final ApplicationLoadBalancerRuleVO lb : lbs) {\n                final List<LbDestination> dstList = _lbMgr.getExistingDestinations(lb.getId());\n                final List<LbStickinessPolicy> policyList = _lbMgr.getStickinessPolicies(lb.getId());\n                final List<LbHealthCheckPolicy> hcPolicyList = _lbMgr.getHealthCheckPolicies(lb.getId());\n                final LoadBalancingRule loadBalancing = new LoadBalancingRule(lb, dstList, policyList, hcPolicyList, sourceIp);\n                lbRules.add(loadBalancing);\n            }\n        }\n\n        s_logger.debug(\"Found \" + lbRules.size() + \" load balancing rule(s) to apply as a part of Intenrnal LB vm\" + internalLbVm + \" start.\");\n        if (!lbRules.isEmpty()) {\n            createApplyLoadBalancingRulesCommands(lbRules, internalLbVm, cmds, guestNtwkId);\n        }\n    }\n","date":"2018-01-20 05:49:27","endLine":446,"groupId":"101830","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"finalizeLbRulesForIp","params":"(finalCommandscmds@finalDomainRouterVOinternalLbVm@finalProviderprovider@finalIpsourceIp@finallongguestNtwkId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/52/ecebc08bcfe21b12ef4861a469e743c51bb7c3.src","preCode":"    protected void finalizeLbRulesForIp(final Commands cmds, final DomainRouterVO internalLbVm, final Provider provider, final Ip sourceIp, final long guestNtwkId) {\n        s_logger.debug(\"Resending load balancing rules as a part of start for \" + internalLbVm);\n        final List<ApplicationLoadBalancerRuleVO> lbs = _lbDao.listBySrcIpSrcNtwkId(sourceIp, guestNtwkId);\n        final List<LoadBalancingRule> lbRules = new ArrayList<LoadBalancingRule>();\n        if (_ntwkModel.isProviderSupportServiceInNetwork(guestNtwkId, Service.Lb, provider)) {\n            \r\n            for (final ApplicationLoadBalancerRuleVO lb : lbs) {\n                final List<LbDestination> dstList = _lbMgr.getExistingDestinations(lb.getId());\n                final List<LbStickinessPolicy> policyList = _lbMgr.getStickinessPolicies(lb.getId());\n                final List<LbHealthCheckPolicy> hcPolicyList = _lbMgr.getHealthCheckPolicies(lb.getId());\n                final LoadBalancingRule loadBalancing = new LoadBalancingRule(lb, dstList, policyList, hcPolicyList, sourceIp);\n                lbRules.add(loadBalancing);\n            }\n        }\n\n        s_logger.debug(\"Found \" + lbRules.size() + \" load balancing rule(s) to apply as a part of Intenrnal LB vm\" + internalLbVm + \" start.\");\n        if (!lbRules.isEmpty()) {\n            createApplyLoadBalancingRulesCommands(lbRules, internalLbVm, cmds, guestNtwkId);\n        }\n    }\n","realPath":"plugins/network-elements/internal-loadbalancer/src/main/java/org/apache/cloudstack/network/lb/InternalLoadBalancerVMManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":427,"status":"N"}],"commitId":"b96fbee9e5dccb422557f1f84287095c4fb253b0","commitMessage":"@@@Merge release branch 4.13 to master\n\n* 4.13:\n  Fix network rules issue if default egress policy is Allow (#3905)\n","date":"2020-02-24 05:23:50","modifiedFileCount":"1","status":"M","submitter":"Daan Hoogland"}]
