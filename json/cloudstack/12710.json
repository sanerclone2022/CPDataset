[{"authorTime":"2019-08-07 18:11:30","codes":[{"authorDate":"2019-08-07 18:11:30","commitOrder":7,"curCode":"    public void copyAsync(Map<VolumeInfo, DataStore> volumeDataStoreMap, VirtualMachineTO vmTO, Host srcHost, Host destHost, AsyncCompletionCallback<CopyCommandResult> callback) {\n        String errMsg = null;\n\n        try {\n            if (srcHost.getHypervisorType() != HypervisorType.KVM) {\n                throw new CloudRuntimeException(\"Invalid hypervisor type (only KVM supported for this operation at the time being)\");\n            }\n\n            verifyLiveMigrationForKVM(volumeDataStoreMap, destHost);\n\n            VMInstanceVO vmInstance = _vmDao.findById(vmTO.getId());\n            vmTO.setState(vmInstance.getState());\n            List<MigrateDiskInfo> migrateDiskInfoList = new ArrayList<MigrateDiskInfo>();\n\n            Map<String, MigrateCommand.MigrateDiskInfo> migrateStorage = new HashMap<>();\n            Map<VolumeInfo, VolumeInfo> srcVolumeInfoToDestVolumeInfo = new HashMap<>();\n\n            boolean managedStorageDestination = false;\n            for (Map.Entry<VolumeInfo, DataStore> entry : volumeDataStoreMap.entrySet()) {\n                VolumeInfo srcVolumeInfo = entry.getKey();\n                DataStore destDataStore = entry.getValue();\n\n                VolumeVO srcVolume = _volumeDao.findById(srcVolumeInfo.getId());\n                StoragePoolVO destStoragePool = _storagePoolDao.findById(destDataStore.getId());\n                StoragePoolVO sourceStoragePool = _storagePoolDao.findById(srcVolumeInfo.getPoolId());\n\n                if (!shouldMigrateVolume(sourceStoragePool, destHost, destStoragePool)) {\n                    continue;\n                }\n\n                copyTemplateToTargetFilesystemStorageIfNeeded(srcVolumeInfo, sourceStoragePool, destDataStore, destStoragePool, destHost);\n\n                VolumeVO destVolume = duplicateVolumeOnAnotherStorage(srcVolume, destStoragePool);\n                VolumeInfo destVolumeInfo = _volumeDataFactory.getVolume(destVolume.getId(), destDataStore);\n\n                \r\n                destVolumeInfo.processEvent(Event.MigrationCopyRequested);\n                \r\n                destVolumeInfo.processEvent(Event.MigrationCopySucceeded);\n                \r\n                destVolumeInfo.processEvent(Event.MigrationRequested);\n\n                setVolumeMigrationOptions(srcVolumeInfo, destVolumeInfo, vmTO, srcHost, destStoragePool);\n\n                \r\n                destDataStore.getDriver().createAsync(destDataStore, destVolumeInfo, null);\n\n                managedStorageDestination = destStoragePool.isManaged();\n                String volumeIdentifier = managedStorageDestination ? destVolumeInfo.get_iScsiName() : destVolumeInfo.getUuid();\n\n                destVolume = _volumeDao.findById(destVolume.getId());\n                destVolume.setPath(volumeIdentifier);\n\n                setVolumePath(destVolume);\n\n                _volumeDao.update(destVolume.getId(), destVolume);\n\n                postVolumeCreationActions(srcVolumeInfo, destVolumeInfo, vmTO, srcHost);\n\n                destVolumeInfo = _volumeDataFactory.getVolume(destVolume.getId(), destDataStore);\n\n                handleQualityOfServiceForVolumeMigration(destVolumeInfo, PrimaryDataStoreDriver.QualityOfServiceState.MIGRATION);\n\n                _volumeService.grantAccess(destVolumeInfo, destHost, destDataStore);\n\n                String destPath = generateDestPath(destHost, destStoragePool, destVolumeInfo);\n\n                MigrateCommand.MigrateDiskInfo migrateDiskInfo;\n\n                boolean isNonManagedNfsToNfs = sourceStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem\n                        && destStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem && !managedStorageDestination;\n                if (isNonManagedNfsToNfs) {\n                    migrateDiskInfo = new MigrateCommand.MigrateDiskInfo(srcVolumeInfo.getPath(),\n                            MigrateCommand.MigrateDiskInfo.DiskType.FILE,\n                            MigrateCommand.MigrateDiskInfo.DriverType.QCOW2,\n                            MigrateCommand.MigrateDiskInfo.Source.FILE,\n                            connectHostToVolume(destHost, destVolumeInfo.getPoolId(), volumeIdentifier));\n                } else {\n                    migrateDiskInfo = configureMigrateDiskInfo(srcVolumeInfo, destPath);\n                    migrateDiskInfo.setSourceDiskOnStorageFileSystem(isStoragePoolTypeOfFile(sourceStoragePool));\n                    migrateDiskInfoList.add(migrateDiskInfo);\n                }\n\n                migrateStorage.put(srcVolumeInfo.getPath(), migrateDiskInfo);\n\n                srcVolumeInfoToDestVolumeInfo.put(srcVolumeInfo, destVolumeInfo);\n            }\n\n            PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(vmTO);\n\n            try {\n                Answer pfma = agentManager.send(destHost.getId(), pfmc);\n\n                if (pfma == null || !pfma.getResult()) {\n                    String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                    String msg = \"Unable to prepare for migration due to the following: \" + details;\n\n                    throw new AgentUnavailableException(msg, destHost.getId());\n                }\n            }\n            catch (final OperationTimedoutException e) {\n                throw new AgentUnavailableException(\"Operation timed out\", destHost.getId());\n            }\n\n            VMInstanceVO vm = _vmDao.findById(vmTO.getId());\n            boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n\n            boolean migrateNonSharedInc = isSourceAndDestinationPoolTypeOfNfs(volumeDataStoreMap);\n\n            MigrateCommand migrateCommand = new MigrateCommand(vmTO.getName(), destHost.getPrivateIpAddress(), isWindows, vmTO, true);\n            migrateCommand.setWait(StorageManager.KvmStorageOnlineMigrationWait.value());\n            migrateCommand.setMigrateStorage(migrateStorage);\n            migrateCommand.setMigrateDiskInfoList(migrateDiskInfoList);\n            migrateCommand.setMigrateStorageManaged(managedStorageDestination);\n            migrateCommand.setMigrateNonSharedInc(migrateNonSharedInc);\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            migrateCommand.setAutoConvergence(kvmAutoConvergence);\n\n            MigrateAnswer migrateAnswer = (MigrateAnswer)agentManager.send(srcHost.getId(), migrateCommand);\n\n            boolean success = migrateAnswer != null && migrateAnswer.getResult();\n\n            handlePostMigration(success, srcVolumeInfoToDestVolumeInfo, vmTO, destHost);\n\n            if (migrateAnswer == null) {\n                throw new CloudRuntimeException(\"Unable to get an answer to the migrate command\");\n            }\n\n            if (!migrateAnswer.getResult()) {\n                errMsg = migrateAnswer.getDetails();\n\n                throw new CloudRuntimeException(errMsg);\n            }\n        }\n        catch (Exception ex) {\n            errMsg = \"Copy operation failed in 'StorageSystemDataMotionStrategy.copyAsync': \" + ex.getMessage();\n\n            throw new CloudRuntimeException(errMsg);\n        }\n        finally {\n            CopyCmdAnswer copyCmdAnswer = new CopyCmdAnswer(errMsg);\n\n            CopyCommandResult result = new CopyCommandResult(null, copyCmdAnswer);\n\n            result.setResult(errMsg);\n\n            callback.complete(result);\n        }\n    }\n","date":"2019-08-07 18:11:30","endLine":1912,"groupId":"1885","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"copyAsync","params":"(Map<VolumeInfo@DataStore>volumeDataStoreMap@VirtualMachineTOvmTO@HostsrcHost@HostdestHost@AsyncCompletionCallback<CopyCommandResult>callback)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/4d/3ec184ac169f2c7210194889c7bc6a65d0ce89.src","preCode":"    public void copyAsync(Map<VolumeInfo, DataStore> volumeDataStoreMap, VirtualMachineTO vmTO, Host srcHost, Host destHost, AsyncCompletionCallback<CopyCommandResult> callback) {\n        String errMsg = null;\n\n        try {\n            if (srcHost.getHypervisorType() != HypervisorType.KVM) {\n                throw new CloudRuntimeException(\"Invalid hypervisor type (only KVM supported for this operation at the time being)\");\n            }\n\n            verifyLiveMigrationForKVM(volumeDataStoreMap, destHost);\n\n            VMInstanceVO vmInstance = _vmDao.findById(vmTO.getId());\n            vmTO.setState(vmInstance.getState());\n            List<MigrateDiskInfo> migrateDiskInfoList = new ArrayList<MigrateDiskInfo>();\n\n            Map<String, MigrateCommand.MigrateDiskInfo> migrateStorage = new HashMap<>();\n            Map<VolumeInfo, VolumeInfo> srcVolumeInfoToDestVolumeInfo = new HashMap<>();\n\n            boolean managedStorageDestination = false;\n            for (Map.Entry<VolumeInfo, DataStore> entry : volumeDataStoreMap.entrySet()) {\n                VolumeInfo srcVolumeInfo = entry.getKey();\n                DataStore destDataStore = entry.getValue();\n\n                VolumeVO srcVolume = _volumeDao.findById(srcVolumeInfo.getId());\n                StoragePoolVO destStoragePool = _storagePoolDao.findById(destDataStore.getId());\n                StoragePoolVO sourceStoragePool = _storagePoolDao.findById(srcVolumeInfo.getPoolId());\n\n                if (!shouldMigrateVolume(sourceStoragePool, destHost, destStoragePool)) {\n                    continue;\n                }\n\n                copyTemplateToTargetFilesystemStorageIfNeeded(srcVolumeInfo, sourceStoragePool, destDataStore, destStoragePool, destHost);\n\n                VolumeVO destVolume = duplicateVolumeOnAnotherStorage(srcVolume, destStoragePool);\n                VolumeInfo destVolumeInfo = _volumeDataFactory.getVolume(destVolume.getId(), destDataStore);\n\n                \r\n                destVolumeInfo.processEvent(Event.MigrationCopyRequested);\n                \r\n                destVolumeInfo.processEvent(Event.MigrationCopySucceeded);\n                \r\n                destVolumeInfo.processEvent(Event.MigrationRequested);\n\n                setVolumeMigrationOptions(srcVolumeInfo, destVolumeInfo, vmTO, srcHost, destStoragePool);\n\n                \r\n                destDataStore.getDriver().createAsync(destDataStore, destVolumeInfo, null);\n\n                managedStorageDestination = destStoragePool.isManaged();\n                String volumeIdentifier = managedStorageDestination ? destVolumeInfo.get_iScsiName() : destVolumeInfo.getUuid();\n\n                destVolume = _volumeDao.findById(destVolume.getId());\n                destVolume.setPath(volumeIdentifier);\n\n                setVolumePath(destVolume);\n\n                _volumeDao.update(destVolume.getId(), destVolume);\n\n                postVolumeCreationActions(srcVolumeInfo, destVolumeInfo, vmTO, srcHost);\n\n                destVolumeInfo = _volumeDataFactory.getVolume(destVolume.getId(), destDataStore);\n\n                handleQualityOfServiceForVolumeMigration(destVolumeInfo, PrimaryDataStoreDriver.QualityOfServiceState.MIGRATION);\n\n                _volumeService.grantAccess(destVolumeInfo, destHost, destDataStore);\n\n                String destPath = generateDestPath(destHost, destStoragePool, destVolumeInfo);\n\n                MigrateCommand.MigrateDiskInfo migrateDiskInfo;\n\n                boolean isNonManagedNfsToNfs = sourceStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem\n                        && destStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem && !managedStorageDestination;\n                if (isNonManagedNfsToNfs) {\n                    migrateDiskInfo = new MigrateCommand.MigrateDiskInfo(srcVolumeInfo.getPath(),\n                            MigrateCommand.MigrateDiskInfo.DiskType.FILE,\n                            MigrateCommand.MigrateDiskInfo.DriverType.QCOW2,\n                            MigrateCommand.MigrateDiskInfo.Source.FILE,\n                            connectHostToVolume(destHost, destVolumeInfo.getPoolId(), volumeIdentifier));\n                } else {\n                    migrateDiskInfo = configureMigrateDiskInfo(srcVolumeInfo, destPath);\n                    migrateDiskInfo.setSourceDiskOnStorageFileSystem(isStoragePoolTypeOfFile(sourceStoragePool));\n                    migrateDiskInfoList.add(migrateDiskInfo);\n                }\n\n                migrateStorage.put(srcVolumeInfo.getPath(), migrateDiskInfo);\n\n                srcVolumeInfoToDestVolumeInfo.put(srcVolumeInfo, destVolumeInfo);\n            }\n\n            PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(vmTO);\n\n            try {\n                Answer pfma = agentManager.send(destHost.getId(), pfmc);\n\n                if (pfma == null || !pfma.getResult()) {\n                    String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                    String msg = \"Unable to prepare for migration due to the following: \" + details;\n\n                    throw new AgentUnavailableException(msg, destHost.getId());\n                }\n            }\n            catch (final OperationTimedoutException e) {\n                throw new AgentUnavailableException(\"Operation timed out\", destHost.getId());\n            }\n\n            VMInstanceVO vm = _vmDao.findById(vmTO.getId());\n            boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n\n            boolean migrateNonSharedInc = isSourceAndDestinationPoolTypeOfNfs(volumeDataStoreMap);\n\n            MigrateCommand migrateCommand = new MigrateCommand(vmTO.getName(), destHost.getPrivateIpAddress(), isWindows, vmTO, true);\n            migrateCommand.setWait(StorageManager.KvmStorageOnlineMigrationWait.value());\n            migrateCommand.setMigrateStorage(migrateStorage);\n            migrateCommand.setMigrateDiskInfoList(migrateDiskInfoList);\n            migrateCommand.setMigrateStorageManaged(managedStorageDestination);\n            migrateCommand.setMigrateNonSharedInc(migrateNonSharedInc);\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            migrateCommand.setAutoConvergence(kvmAutoConvergence);\n\n            MigrateAnswer migrateAnswer = (MigrateAnswer)agentManager.send(srcHost.getId(), migrateCommand);\n\n            boolean success = migrateAnswer != null && migrateAnswer.getResult();\n\n            handlePostMigration(success, srcVolumeInfoToDestVolumeInfo, vmTO, destHost);\n\n            if (migrateAnswer == null) {\n                throw new CloudRuntimeException(\"Unable to get an answer to the migrate command\");\n            }\n\n            if (!migrateAnswer.getResult()) {\n                errMsg = migrateAnswer.getDetails();\n\n                throw new CloudRuntimeException(errMsg);\n            }\n        }\n        catch (Exception ex) {\n            errMsg = \"Copy operation failed in 'StorageSystemDataMotionStrategy.copyAsync': \" + ex.getMessage();\n\n            throw new CloudRuntimeException(errMsg);\n        }\n        finally {\n            CopyCmdAnswer copyCmdAnswer = new CopyCmdAnswer(errMsg);\n\n            CopyCommandResult result = new CopyCommandResult(null, copyCmdAnswer);\n\n            result.setResult(errMsg);\n\n            callback.complete(result);\n        }\n    }\n","realPath":"engine/storage/datamotion/src/main/java/org/apache/cloudstack/storage/motion/StorageSystemDataMotionStrategy.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1763,"status":"MB"},{"authorDate":"2019-08-07 18:11:30","commitOrder":7,"curCode":"    protected boolean isSourceAndDestinationPoolTypeOfNfs(Map<VolumeInfo, DataStore> volumeDataStoreMap) {\n        for (Map.Entry<VolumeInfo, DataStore> entry : volumeDataStoreMap.entrySet()) {\n            VolumeInfo srcVolumeInfo = entry.getKey();\n            DataStore destDataStore = entry.getValue();\n\n            StoragePoolVO destStoragePool = _storagePoolDao.findById(destDataStore.getId());\n            StoragePoolVO sourceStoragePool = _storagePoolDao.findById(srcVolumeInfo.getPoolId());\n            if (sourceStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem && destStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem) {\n                return true;\n            }\n        }\n        return false;\n    }\n","date":"2019-08-07 18:11:30","endLine":1929,"groupId":"4567","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"isSourceAndDestinationPoolTypeOfNfs","params":"(Map<VolumeInfo@DataStore>volumeDataStoreMap)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/4d/3ec184ac169f2c7210194889c7bc6a65d0ce89.src","preCode":"    protected boolean isSourceAndDestinationPoolTypeOfNfs(Map<VolumeInfo, DataStore> volumeDataStoreMap) {\n        for (Map.Entry<VolumeInfo, DataStore> entry : volumeDataStoreMap.entrySet()) {\n            VolumeInfo srcVolumeInfo = entry.getKey();\n            DataStore destDataStore = entry.getValue();\n\n            StoragePoolVO destStoragePool = _storagePoolDao.findById(destDataStore.getId());\n            StoragePoolVO sourceStoragePool = _storagePoolDao.findById(srcVolumeInfo.getPoolId());\n            if (sourceStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem && destStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem) {\n                return true;\n            }\n        }\n        return false;\n    }\n","realPath":"engine/storage/datamotion/src/main/java/org/apache/cloudstack/storage/motion/StorageSystemDataMotionStrategy.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1917,"status":"B"}],"commitId":"5dc982d8bab4ed16533dd56b39e98dadc79eeafe","commitMessage":"@@@KVM local migration issue #3521 (#3533)\n\nFix regression bug that affects KVM local storage migration. Some of the desired execution flows for KVM local storage migration had been altered to allow only managed storage to execute. Fixed allowing managed and non managed storages to execute.\n\nFixes #3521","date":"2019-08-07 18:11:30","modifiedFileCount":"5","status":"M","submitter":"Gabriel Beims Br?scher"},{"authorTime":"2019-08-07 18:11:30","codes":[{"authorDate":"2021-02-24 17:28:33","commitOrder":8,"curCode":"    public void copyAsync(Map<VolumeInfo, DataStore> volumeDataStoreMap, VirtualMachineTO vmTO, Host srcHost, Host destHost, AsyncCompletionCallback<CopyCommandResult> callback) {\n        String errMsg = null;\n\n        try {\n            if (srcHost.getHypervisorType() != HypervisorType.KVM) {\n                throw new CloudRuntimeException(\"Invalid hypervisor type (only KVM supported for this operation at the time being)\");\n            }\n\n            verifyLiveMigrationForKVM(volumeDataStoreMap, destHost);\n\n            VMInstanceVO vmInstance = _vmDao.findById(vmTO.getId());\n            vmTO.setState(vmInstance.getState());\n            List<MigrateDiskInfo> migrateDiskInfoList = new ArrayList<MigrateDiskInfo>();\n\n            Map<String, MigrateCommand.MigrateDiskInfo> migrateStorage = new HashMap<>();\n            Map<VolumeInfo, VolumeInfo> srcVolumeInfoToDestVolumeInfo = new HashMap<>();\n\n            boolean managedStorageDestination = false;\n            for (Map.Entry<VolumeInfo, DataStore> entry : volumeDataStoreMap.entrySet()) {\n                VolumeInfo srcVolumeInfo = entry.getKey();\n                DataStore destDataStore = entry.getValue();\n\n                VolumeVO srcVolume = _volumeDao.findById(srcVolumeInfo.getId());\n                StoragePoolVO destStoragePool = _storagePoolDao.findById(destDataStore.getId());\n                StoragePoolVO sourceStoragePool = _storagePoolDao.findById(srcVolumeInfo.getPoolId());\n\n                \r\n                if (sourceStoragePool.getId() == destStoragePool.getId() && sourceStoragePool.getPoolType() == Storage.StoragePoolType.PowerFlex) {\n                    continue;\n                }\n\n                if (!shouldMigrateVolume(sourceStoragePool, destHost, destStoragePool)) {\n                    continue;\n                }\n\n                copyTemplateToTargetFilesystemStorageIfNeeded(srcVolumeInfo, sourceStoragePool, destDataStore, destStoragePool, destHost);\n\n                VolumeVO destVolume = duplicateVolumeOnAnotherStorage(srcVolume, destStoragePool);\n                VolumeInfo destVolumeInfo = _volumeDataFactory.getVolume(destVolume.getId(), destDataStore);\n\n                \r\n                destVolumeInfo.processEvent(Event.MigrationCopyRequested);\n                \r\n                destVolumeInfo.processEvent(Event.MigrationCopySucceeded);\n                \r\n                destVolumeInfo.processEvent(Event.MigrationRequested);\n\n                setVolumeMigrationOptions(srcVolumeInfo, destVolumeInfo, vmTO, srcHost, destStoragePool);\n\n                \r\n                destDataStore.getDriver().createAsync(destDataStore, destVolumeInfo, null);\n\n                managedStorageDestination = destStoragePool.isManaged();\n                String volumeIdentifier = managedStorageDestination ? destVolumeInfo.get_iScsiName() : destVolumeInfo.getUuid();\n\n                destVolume = _volumeDao.findById(destVolume.getId());\n                destVolume.setPath(volumeIdentifier);\n\n                setVolumePath(destVolume);\n\n                _volumeDao.update(destVolume.getId(), destVolume);\n\n                postVolumeCreationActions(srcVolumeInfo, destVolumeInfo, vmTO, srcHost);\n\n                destVolumeInfo = _volumeDataFactory.getVolume(destVolume.getId(), destDataStore);\n\n                handleQualityOfServiceForVolumeMigration(destVolumeInfo, PrimaryDataStoreDriver.QualityOfServiceState.MIGRATION);\n\n                _volumeService.grantAccess(destVolumeInfo, destHost, destDataStore);\n\n                String destPath = generateDestPath(destHost, destStoragePool, destVolumeInfo);\n\n                MigrateCommand.MigrateDiskInfo migrateDiskInfo;\n\n                boolean isNonManagedNfsToNfs = sourceStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem\n                        && destStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem && !managedStorageDestination;\n                if (isNonManagedNfsToNfs) {\n                    migrateDiskInfo = new MigrateCommand.MigrateDiskInfo(srcVolumeInfo.getPath(),\n                            MigrateCommand.MigrateDiskInfo.DiskType.FILE,\n                            MigrateCommand.MigrateDiskInfo.DriverType.QCOW2,\n                            MigrateCommand.MigrateDiskInfo.Source.FILE,\n                            connectHostToVolume(destHost, destVolumeInfo.getPoolId(), volumeIdentifier));\n                } else {\n                    migrateDiskInfo = configureMigrateDiskInfo(srcVolumeInfo, destPath);\n                    migrateDiskInfo.setSourceDiskOnStorageFileSystem(isStoragePoolTypeOfFile(sourceStoragePool));\n                    migrateDiskInfoList.add(migrateDiskInfo);\n                }\n\n                migrateStorage.put(srcVolumeInfo.getPath(), migrateDiskInfo);\n\n                srcVolumeInfoToDestVolumeInfo.put(srcVolumeInfo, destVolumeInfo);\n            }\n\n            PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(vmTO);\n\n            try {\n                Answer pfma = agentManager.send(destHost.getId(), pfmc);\n\n                if (pfma == null || !pfma.getResult()) {\n                    String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                    String msg = \"Unable to prepare for migration due to the following: \" + details;\n\n                    throw new AgentUnavailableException(msg, destHost.getId());\n                }\n            }\n            catch (final OperationTimedoutException e) {\n                throw new AgentUnavailableException(\"Operation timed out\", destHost.getId());\n            }\n\n            VMInstanceVO vm = _vmDao.findById(vmTO.getId());\n            boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n\n            boolean migrateNonSharedInc = isSourceAndDestinationPoolTypeOfNfs(volumeDataStoreMap);\n\n            MigrateCommand migrateCommand = new MigrateCommand(vmTO.getName(), destHost.getPrivateIpAddress(), isWindows, vmTO, true);\n            migrateCommand.setWait(StorageManager.KvmStorageOnlineMigrationWait.value());\n            migrateCommand.setMigrateStorage(migrateStorage);\n            migrateCommand.setMigrateDiskInfoList(migrateDiskInfoList);\n            migrateCommand.setMigrateStorageManaged(managedStorageDestination);\n            migrateCommand.setMigrateNonSharedInc(migrateNonSharedInc);\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            migrateCommand.setAutoConvergence(kvmAutoConvergence);\n\n            MigrateAnswer migrateAnswer = (MigrateAnswer)agentManager.send(srcHost.getId(), migrateCommand);\n\n            boolean success = migrateAnswer != null && migrateAnswer.getResult();\n\n            handlePostMigration(success, srcVolumeInfoToDestVolumeInfo, vmTO, destHost);\n\n            if (migrateAnswer == null) {\n                throw new CloudRuntimeException(\"Unable to get an answer to the migrate command\");\n            }\n\n            if (!migrateAnswer.getResult()) {\n                errMsg = migrateAnswer.getDetails();\n\n                throw new CloudRuntimeException(errMsg);\n            }\n        } catch (Exception ex) {\n            errMsg = \"Copy operation failed in 'StorageSystemDataMotionStrategy.copyAsync': \" + ex.getMessage();\n            LOGGER.error(errMsg, ex);\n            throw new CloudRuntimeException(errMsg);\n        } finally {\n            CopyCmdAnswer copyCmdAnswer = new CopyCmdAnswer(errMsg);\n\n            CopyCommandResult result = new CopyCommandResult(null, copyCmdAnswer);\n\n            result.setResult(errMsg);\n\n            callback.complete(result);\n        }\n    }\n","date":"2021-02-24 17:28:33","endLine":1936,"groupId":"1885","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"copyAsync","params":"(Map<VolumeInfo@DataStore>volumeDataStoreMap@VirtualMachineTOvmTO@HostsrcHost@HostdestHost@AsyncCompletionCallback<CopyCommandResult>callback)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/95/2dbb200dd04f66a159d80797944a212dfd5ed1.src","preCode":"    public void copyAsync(Map<VolumeInfo, DataStore> volumeDataStoreMap, VirtualMachineTO vmTO, Host srcHost, Host destHost, AsyncCompletionCallback<CopyCommandResult> callback) {\n        String errMsg = null;\n\n        try {\n            if (srcHost.getHypervisorType() != HypervisorType.KVM) {\n                throw new CloudRuntimeException(\"Invalid hypervisor type (only KVM supported for this operation at the time being)\");\n            }\n\n            verifyLiveMigrationForKVM(volumeDataStoreMap, destHost);\n\n            VMInstanceVO vmInstance = _vmDao.findById(vmTO.getId());\n            vmTO.setState(vmInstance.getState());\n            List<MigrateDiskInfo> migrateDiskInfoList = new ArrayList<MigrateDiskInfo>();\n\n            Map<String, MigrateCommand.MigrateDiskInfo> migrateStorage = new HashMap<>();\n            Map<VolumeInfo, VolumeInfo> srcVolumeInfoToDestVolumeInfo = new HashMap<>();\n\n            boolean managedStorageDestination = false;\n            for (Map.Entry<VolumeInfo, DataStore> entry : volumeDataStoreMap.entrySet()) {\n                VolumeInfo srcVolumeInfo = entry.getKey();\n                DataStore destDataStore = entry.getValue();\n\n                VolumeVO srcVolume = _volumeDao.findById(srcVolumeInfo.getId());\n                StoragePoolVO destStoragePool = _storagePoolDao.findById(destDataStore.getId());\n                StoragePoolVO sourceStoragePool = _storagePoolDao.findById(srcVolumeInfo.getPoolId());\n\n                if (!shouldMigrateVolume(sourceStoragePool, destHost, destStoragePool)) {\n                    continue;\n                }\n\n                copyTemplateToTargetFilesystemStorageIfNeeded(srcVolumeInfo, sourceStoragePool, destDataStore, destStoragePool, destHost);\n\n                VolumeVO destVolume = duplicateVolumeOnAnotherStorage(srcVolume, destStoragePool);\n                VolumeInfo destVolumeInfo = _volumeDataFactory.getVolume(destVolume.getId(), destDataStore);\n\n                \r\n                destVolumeInfo.processEvent(Event.MigrationCopyRequested);\n                \r\n                destVolumeInfo.processEvent(Event.MigrationCopySucceeded);\n                \r\n                destVolumeInfo.processEvent(Event.MigrationRequested);\n\n                setVolumeMigrationOptions(srcVolumeInfo, destVolumeInfo, vmTO, srcHost, destStoragePool);\n\n                \r\n                destDataStore.getDriver().createAsync(destDataStore, destVolumeInfo, null);\n\n                managedStorageDestination = destStoragePool.isManaged();\n                String volumeIdentifier = managedStorageDestination ? destVolumeInfo.get_iScsiName() : destVolumeInfo.getUuid();\n\n                destVolume = _volumeDao.findById(destVolume.getId());\n                destVolume.setPath(volumeIdentifier);\n\n                setVolumePath(destVolume);\n\n                _volumeDao.update(destVolume.getId(), destVolume);\n\n                postVolumeCreationActions(srcVolumeInfo, destVolumeInfo, vmTO, srcHost);\n\n                destVolumeInfo = _volumeDataFactory.getVolume(destVolume.getId(), destDataStore);\n\n                handleQualityOfServiceForVolumeMigration(destVolumeInfo, PrimaryDataStoreDriver.QualityOfServiceState.MIGRATION);\n\n                _volumeService.grantAccess(destVolumeInfo, destHost, destDataStore);\n\n                String destPath = generateDestPath(destHost, destStoragePool, destVolumeInfo);\n\n                MigrateCommand.MigrateDiskInfo migrateDiskInfo;\n\n                boolean isNonManagedNfsToNfs = sourceStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem\n                        && destStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem && !managedStorageDestination;\n                if (isNonManagedNfsToNfs) {\n                    migrateDiskInfo = new MigrateCommand.MigrateDiskInfo(srcVolumeInfo.getPath(),\n                            MigrateCommand.MigrateDiskInfo.DiskType.FILE,\n                            MigrateCommand.MigrateDiskInfo.DriverType.QCOW2,\n                            MigrateCommand.MigrateDiskInfo.Source.FILE,\n                            connectHostToVolume(destHost, destVolumeInfo.getPoolId(), volumeIdentifier));\n                } else {\n                    migrateDiskInfo = configureMigrateDiskInfo(srcVolumeInfo, destPath);\n                    migrateDiskInfo.setSourceDiskOnStorageFileSystem(isStoragePoolTypeOfFile(sourceStoragePool));\n                    migrateDiskInfoList.add(migrateDiskInfo);\n                }\n\n                migrateStorage.put(srcVolumeInfo.getPath(), migrateDiskInfo);\n\n                srcVolumeInfoToDestVolumeInfo.put(srcVolumeInfo, destVolumeInfo);\n            }\n\n            PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(vmTO);\n\n            try {\n                Answer pfma = agentManager.send(destHost.getId(), pfmc);\n\n                if (pfma == null || !pfma.getResult()) {\n                    String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                    String msg = \"Unable to prepare for migration due to the following: \" + details;\n\n                    throw new AgentUnavailableException(msg, destHost.getId());\n                }\n            }\n            catch (final OperationTimedoutException e) {\n                throw new AgentUnavailableException(\"Operation timed out\", destHost.getId());\n            }\n\n            VMInstanceVO vm = _vmDao.findById(vmTO.getId());\n            boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n\n            boolean migrateNonSharedInc = isSourceAndDestinationPoolTypeOfNfs(volumeDataStoreMap);\n\n            MigrateCommand migrateCommand = new MigrateCommand(vmTO.getName(), destHost.getPrivateIpAddress(), isWindows, vmTO, true);\n            migrateCommand.setWait(StorageManager.KvmStorageOnlineMigrationWait.value());\n            migrateCommand.setMigrateStorage(migrateStorage);\n            migrateCommand.setMigrateDiskInfoList(migrateDiskInfoList);\n            migrateCommand.setMigrateStorageManaged(managedStorageDestination);\n            migrateCommand.setMigrateNonSharedInc(migrateNonSharedInc);\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            migrateCommand.setAutoConvergence(kvmAutoConvergence);\n\n            MigrateAnswer migrateAnswer = (MigrateAnswer)agentManager.send(srcHost.getId(), migrateCommand);\n\n            boolean success = migrateAnswer != null && migrateAnswer.getResult();\n\n            handlePostMigration(success, srcVolumeInfoToDestVolumeInfo, vmTO, destHost);\n\n            if (migrateAnswer == null) {\n                throw new CloudRuntimeException(\"Unable to get an answer to the migrate command\");\n            }\n\n            if (!migrateAnswer.getResult()) {\n                errMsg = migrateAnswer.getDetails();\n\n                throw new CloudRuntimeException(errMsg);\n            }\n        }\n        catch (Exception ex) {\n            errMsg = \"Copy operation failed in 'StorageSystemDataMotionStrategy.copyAsync': \" + ex.getMessage();\n\n            throw new CloudRuntimeException(errMsg);\n        }\n        finally {\n            CopyCmdAnswer copyCmdAnswer = new CopyCmdAnswer(errMsg);\n\n            CopyCommandResult result = new CopyCommandResult(null, copyCmdAnswer);\n\n            result.setResult(errMsg);\n\n            callback.complete(result);\n        }\n    }\n","realPath":"engine/storage/datamotion/src/main/java/org/apache/cloudstack/storage/motion/StorageSystemDataMotionStrategy.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1784,"status":"M"},{"authorDate":"2019-08-07 18:11:30","commitOrder":8,"curCode":"    protected boolean isSourceAndDestinationPoolTypeOfNfs(Map<VolumeInfo, DataStore> volumeDataStoreMap) {\n        for (Map.Entry<VolumeInfo, DataStore> entry : volumeDataStoreMap.entrySet()) {\n            VolumeInfo srcVolumeInfo = entry.getKey();\n            DataStore destDataStore = entry.getValue();\n\n            StoragePoolVO destStoragePool = _storagePoolDao.findById(destDataStore.getId());\n            StoragePoolVO sourceStoragePool = _storagePoolDao.findById(srcVolumeInfo.getPoolId());\n            if (sourceStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem && destStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem) {\n                return true;\n            }\n        }\n        return false;\n    }\n","date":"2019-08-07 18:11:30","endLine":1929,"groupId":"4567","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"isSourceAndDestinationPoolTypeOfNfs","params":"(Map<VolumeInfo@DataStore>volumeDataStoreMap)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/4d/3ec184ac169f2c7210194889c7bc6a65d0ce89.src","preCode":"    protected boolean isSourceAndDestinationPoolTypeOfNfs(Map<VolumeInfo, DataStore> volumeDataStoreMap) {\n        for (Map.Entry<VolumeInfo, DataStore> entry : volumeDataStoreMap.entrySet()) {\n            VolumeInfo srcVolumeInfo = entry.getKey();\n            DataStore destDataStore = entry.getValue();\n\n            StoragePoolVO destStoragePool = _storagePoolDao.findById(destDataStore.getId());\n            StoragePoolVO sourceStoragePool = _storagePoolDao.findById(srcVolumeInfo.getPoolId());\n            if (sourceStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem && destStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem) {\n                return true;\n            }\n        }\n        return false;\n    }\n","realPath":"engine/storage/datamotion/src/main/java/org/apache/cloudstack/storage/motion/StorageSystemDataMotionStrategy.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1917,"status":"N"}],"commitId":"eba186aa40f16911c019bf06cd33d7d0cbbc303b","commitMessage":"@@@storage: New Dell EMC PowerFlex Plugin (formerly ScaleIO.  VxFlexOS) (#4304)\n\nAdded support for PowerFlex/ScaleIO (v3.5 onwards) storage pool as a primary storage in CloudStack (for KVM hypervisor) and enabled VM/Volume operations on that pool (using pool tag).\nPlease find more details in the FS here:\nhttps://cwiki.apache.org/confluence/x/cDl4CQ\n\nDocumentation PR: apache/cloudstack-documentation#169\n\nThis enables support for PowerFlex/ScaleIO (v3.5 onwards) storage pool as a primary storage in CloudStack\n\nOther improvements addressed in addition to PowerFlex/ScaleIO support:\n\n- Added support for config drives in host cache for KVM\n\t=> Changed configuration \"vm.configdrive.primarypool.enabled\" scope from Global to Zone level\n\t=> Introduced new zone level configuration \"vm.configdrive.force.host.cache.use\" (default: false) to force host cache for config drives\n\t=> Introduced new zone level configuration \"vm.configdrive.use.host.cache.on.unsupported.pool\" (default: true) to use host cache for config drives when storage pool doesn't support config drive\n\t=> Added new parameter \"host.cache.location\" (default: /var/cache/cloud) in KVM agent.properties for specifying the host cache path and create config drives on the \"/config\" directory on the host cache path\n\t=> Maintain the config drive location and use it when required on any config drive operation (migrate.  delete)\n\n- Detect virtual size from the template URL while registering direct download qcow2 (of KVM hypervisor) templates\n\n- Updated full deployment destination for preparing the network(s) on VM start\n\n- Propagate the direct download certificates uploaded to the newly added KVM hosts\n\n- Discover the template size for direct download templates using any available host from the zones specified on template registration\n\t=> When zones are not specified while registering template.  template size discovery is performed using any available host.  which is picked up randomly from one of the available zones\n\n- Release the VM resources when VM is sync-ed to Stopped state on PowerReportMissing (after graceful period)\n\n- Retry VM deployment/start when the host cannot grant access to volume/template\n\n- Mark never-used or downloaded templates as Destroyed on deletion.  without sending any DeleteCommand\n\t=> Do not trigger any DeleteCommand for never-used or downloaded templates as these doesn't exist and cannot be deleted from the datastore\n\n- Check the router filesystem is writable or not.  before performing health checks\n\t=> Introduce a new test \"filesystem.writable.test\" to check the filesystem is writable or not\n\t=> The router health checks keeps the config info at \"/var/cache/cloud\" and updates the monitor results at \"/root\" for health checks.  both are different partitions. So.  test at both the locations.\n\t=> Added new script: \"filesystem_writable_check.py\" at /opt/cloud/bin/ to check the filesystem is writable or not\n\n- Fixed NPE issue.  template is null for DATA disks. Copy template to target storage for ROOT disk (with template id).  skip DATA disk(s)\n\n* Addressed some issues for few operations on PowerFlex storage pool.\n\n- Updated migration volume operation to sync the status and wait for migration to complete.\n\n- Updated VM Snapshot naming.  for uniqueness in ScaleIO volume name when more than one volume exists in the VM.\n\n- Added sync lock while spooling managed storage template before volume creation from the template (non-direct download).\n\n- Updated resize volume error message string.\n\n- Blocked the below operations on PowerFlex storage pool:\n  -> Extract Volume\n  -> Create Snapshot for VMSnapshot\n\n* Added the PowerFlex/ScaleIO client connection pool to manage the ScaleIO gateway clients.  which uses a single gateway client per Powerflex/ScaleIO storage pool and renews it when the session token expires.\n\n- The token is valid for 8 hours from the time it was created.  unless there has been no activity for 10 minutes.\n  Reference: https://cpsdocs.dellemc.com/bundle/PF_REST_API_RG/page/GUID-92430F19-9F44-42B6-B898-87D5307AE59B.html\n\nOther fixes included:\n\n- Fail the VM deployment when the host specified in the deployVirtualMachine cmd is not in the right state (i.e. either Resource State is not Enabled or Status is not Up)\n\n- Use the physical file size of the template to check the free space availability on the host.  while downloading the direct download templates.\n\n- Perform basic tests (for connectivity and file system) on router before updating the health check config data\n\t=> Validate the basic tests (connectivity and file system check) on router\n\t=> Cleanup the health check results when router is destroyed\n\n* Updated PowerFlex/ScaleIO storage plugin version to 4.16.0.0\n\n* UI Changes to support storage plugin for PowerFlex/ScaleIO storage pool.\n- PowerFlex pool URL generated from the UI inputs(Gateway.  Username.  Password.  Storage Pool) when adding \"PowerFlex\" Primary Storage\n- Updated protocol to \"custom\" for PowerFlex provider\n- Allow VM Snapshot for stopped VM on KVM hypervisor and PowerFlex/ScaleIO storage pool\n\nand Minor improvements in PowerFlex/ScaleIO storage plugin code\n\n* Added support for PowerFlex/ScaleIO volume migration across different PowerFlex storage instances.\n\n- findStoragePoolsForMigration API returns PowerFlex pool(s) of different instance as suitable pool(s).  for volume(s) on PowerFlex storage pool.\n- Volume(s) with snapshots are not allowed to migrate to different PowerFlex instance.\n- Volume(s) of running VM are not allowed to migrate to other PowerFlex storage pools.\n- Volume migration from PowerFlex pool to Non-PowerFlex pool.  and vice versa are not supported.\n\n* Fixed change service offering smoke tests in test_service_offerings.py.  test_vm_snapshots.py\n\n* Added the PowerFlex/ScaleIO volume/snapshot name to the paths of respective CloudStack resources (Templates.  Volumes.  Snapshots and VM Snapshots)\n\n* Added new response parameter ?supportsStorageSnapshot? (true/false) to volume response.  and Updated UI to hide the async backup option while taking snapshot for volume(s) with storage snapshot support.\n\n* Fix to remove the duplicate zone wide pools listed while finding storage pools for migration\n\n* Updated PowerFlex/ScaleIO volume migration checks and rollback migration on failure\n\n* Fixed the PowerFlex/ScaleIO volume name inconsistency issue in the volume path after migration.  due to rename failure","date":"2021-02-24 17:28:33","modifiedFileCount":"112","status":"M","submitter":"sureshanaparti"},{"authorTime":"2019-08-07 18:11:30","codes":[{"authorDate":"2021-03-09 00:56:56","commitOrder":9,"curCode":"    public void copyAsync(Map<VolumeInfo, DataStore> volumeDataStoreMap, VirtualMachineTO vmTO, Host srcHost, Host destHost, AsyncCompletionCallback<CopyCommandResult> callback) {\n        String errMsg = null;\n\n        try {\n            if (srcHost.getHypervisorType() != HypervisorType.KVM) {\n                throw new CloudRuntimeException(\"Invalid hypervisor type (only KVM supported for this operation at the time being)\");\n            }\n\n            verifyLiveMigrationForKVM(volumeDataStoreMap, destHost);\n\n            VMInstanceVO vmInstance = _vmDao.findById(vmTO.getId());\n            vmTO.setState(vmInstance.getState());\n            List<MigrateDiskInfo> migrateDiskInfoList = new ArrayList<MigrateDiskInfo>();\n\n            Map<String, MigrateCommand.MigrateDiskInfo> migrateStorage = new HashMap<>();\n            Map<VolumeInfo, VolumeInfo> srcVolumeInfoToDestVolumeInfo = new HashMap<>();\n\n            boolean managedStorageDestination = false;\n            for (Map.Entry<VolumeInfo, DataStore> entry : volumeDataStoreMap.entrySet()) {\n                VolumeInfo srcVolumeInfo = entry.getKey();\n                DataStore destDataStore = entry.getValue();\n\n                VolumeVO srcVolume = _volumeDao.findById(srcVolumeInfo.getId());\n                StoragePoolVO destStoragePool = _storagePoolDao.findById(destDataStore.getId());\n                StoragePoolVO sourceStoragePool = _storagePoolDao.findById(srcVolumeInfo.getPoolId());\n\n                \r\n                if (sourceStoragePool.getId() == destStoragePool.getId() && sourceStoragePool.getPoolType() == Storage.StoragePoolType.PowerFlex) {\n                    continue;\n                }\n\n                if (!shouldMigrateVolume(sourceStoragePool, destHost, destStoragePool)) {\n                    continue;\n                }\n\n                if (srcVolumeInfo.getTemplateId() != null) {\n                    LOGGER.debug(String.format(\"Copying template [%s] of volume [%s] from source storage pool [%s] to target storage pool [%s].\", srcVolumeInfo.getTemplateId(), srcVolumeInfo.getId(), sourceStoragePool.getId(), destStoragePool.getId()));\n                    copyTemplateToTargetFilesystemStorageIfNeeded(srcVolumeInfo, sourceStoragePool, destDataStore, destStoragePool, destHost);\n                } else {\n                    LOGGER.debug(String.format(\"Skipping copy template from source storage pool [%s] to target storage pool [%s] before migration due to volume [%s] does not have a template.\", sourceStoragePool.getId(), destStoragePool.getId(), srcVolumeInfo.getId()));\n                }\n\n                VolumeVO destVolume = duplicateVolumeOnAnotherStorage(srcVolume, destStoragePool);\n                VolumeInfo destVolumeInfo = _volumeDataFactory.getVolume(destVolume.getId(), destDataStore);\n\n                \r\n                destVolumeInfo.processEvent(Event.MigrationCopyRequested);\n                \r\n                destVolumeInfo.processEvent(Event.MigrationCopySucceeded);\n                \r\n                destVolumeInfo.processEvent(Event.MigrationRequested);\n\n                setVolumeMigrationOptions(srcVolumeInfo, destVolumeInfo, vmTO, srcHost, destStoragePool);\n\n                \r\n                destDataStore.getDriver().createAsync(destDataStore, destVolumeInfo, null);\n\n                managedStorageDestination = destStoragePool.isManaged();\n                String volumeIdentifier = managedStorageDestination ? destVolumeInfo.get_iScsiName() : destVolumeInfo.getUuid();\n\n                destVolume = _volumeDao.findById(destVolume.getId());\n                destVolume.setPath(volumeIdentifier);\n\n                setVolumePath(destVolume);\n\n                _volumeDao.update(destVolume.getId(), destVolume);\n\n                postVolumeCreationActions(srcVolumeInfo, destVolumeInfo, vmTO, srcHost);\n\n                destVolumeInfo = _volumeDataFactory.getVolume(destVolume.getId(), destDataStore);\n\n                handleQualityOfServiceForVolumeMigration(destVolumeInfo, PrimaryDataStoreDriver.QualityOfServiceState.MIGRATION);\n\n                _volumeService.grantAccess(destVolumeInfo, destHost, destDataStore);\n\n                String destPath = generateDestPath(destHost, destStoragePool, destVolumeInfo);\n\n                MigrateCommand.MigrateDiskInfo migrateDiskInfo;\n\n                boolean isNonManagedNfsToNfs = sourceStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem\n                        && destStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem && !managedStorageDestination;\n                if (isNonManagedNfsToNfs) {\n                    migrateDiskInfo = new MigrateCommand.MigrateDiskInfo(srcVolumeInfo.getPath(),\n                            MigrateCommand.MigrateDiskInfo.DiskType.FILE,\n                            MigrateCommand.MigrateDiskInfo.DriverType.QCOW2,\n                            MigrateCommand.MigrateDiskInfo.Source.FILE,\n                            connectHostToVolume(destHost, destVolumeInfo.getPoolId(), volumeIdentifier));\n                } else {\n                    migrateDiskInfo = configureMigrateDiskInfo(srcVolumeInfo, destPath);\n                    migrateDiskInfo.setSourceDiskOnStorageFileSystem(isStoragePoolTypeOfFile(sourceStoragePool));\n                    migrateDiskInfoList.add(migrateDiskInfo);\n                }\n\n                migrateStorage.put(srcVolumeInfo.getPath(), migrateDiskInfo);\n\n                srcVolumeInfoToDestVolumeInfo.put(srcVolumeInfo, destVolumeInfo);\n            }\n\n            PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(vmTO);\n\n            try {\n                Answer pfma = agentManager.send(destHost.getId(), pfmc);\n\n                if (pfma == null || !pfma.getResult()) {\n                    String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                    String msg = \"Unable to prepare for migration due to the following: \" + details;\n\n                    throw new AgentUnavailableException(msg, destHost.getId());\n                }\n            }\n            catch (final OperationTimedoutException e) {\n                throw new AgentUnavailableException(\"Operation timed out\", destHost.getId());\n            }\n\n            VMInstanceVO vm = _vmDao.findById(vmTO.getId());\n            boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n\n            boolean migrateNonSharedInc = isSourceAndDestinationPoolTypeOfNfs(volumeDataStoreMap);\n\n            MigrateCommand migrateCommand = new MigrateCommand(vmTO.getName(), destHost.getPrivateIpAddress(), isWindows, vmTO, true);\n            migrateCommand.setWait(StorageManager.KvmStorageOnlineMigrationWait.value());\n            migrateCommand.setMigrateStorage(migrateStorage);\n            migrateCommand.setMigrateDiskInfoList(migrateDiskInfoList);\n            migrateCommand.setMigrateStorageManaged(managedStorageDestination);\n            migrateCommand.setMigrateNonSharedInc(migrateNonSharedInc);\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            migrateCommand.setAutoConvergence(kvmAutoConvergence);\n\n            MigrateAnswer migrateAnswer = (MigrateAnswer)agentManager.send(srcHost.getId(), migrateCommand);\n\n            boolean success = migrateAnswer != null && migrateAnswer.getResult();\n\n            handlePostMigration(success, srcVolumeInfoToDestVolumeInfo, vmTO, destHost);\n\n            if (migrateAnswer == null) {\n                throw new CloudRuntimeException(\"Unable to get an answer to the migrate command\");\n            }\n\n            if (!migrateAnswer.getResult()) {\n                errMsg = migrateAnswer.getDetails();\n\n                throw new CloudRuntimeException(errMsg);\n            }\n        } catch (AgentUnavailableException | OperationTimedoutException | CloudRuntimeException ex) {\n            String volumesAndStorages = volumeDataStoreMap.entrySet().stream().map(entry -> formatEntryOfVolumesAndStoragesAsJsonToDisplayOnLog(entry)).collect(Collectors.joining(\",\"));\n\n            errMsg = String.format(\"Copy volume(s) to storage(s) [%s] and VM to host [%s] failed in StorageSystemDataMotionStrategy.copyAsync. Error message: [%s].\", volumesAndStorages, formatMigrationElementsAsJsonToDisplayOnLog(\"vm\", vmTO.getId(), srcHost.getId(), destHost.getId()), ex.getMessage());\n            LOGGER.error(errMsg, ex);\n\n            throw new CloudRuntimeException(errMsg);\n        } finally {\n            CopyCmdAnswer copyCmdAnswer = new CopyCmdAnswer(errMsg);\n\n            CopyCommandResult result = new CopyCommandResult(null, copyCmdAnswer);\n\n            result.setResult(errMsg);\n\n            callback.complete(result);\n        }\n    }\n","date":"2021-03-09 00:56:56","endLine":1945,"groupId":"1885","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"copyAsync","params":"(Map<VolumeInfo@DataStore>volumeDataStoreMap@VirtualMachineTOvmTO@HostsrcHost@HostdestHost@AsyncCompletionCallback<CopyCommandResult>callback)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/46/0c337074433b73cefebe3598da4fee07160f7a.src","preCode":"    public void copyAsync(Map<VolumeInfo, DataStore> volumeDataStoreMap, VirtualMachineTO vmTO, Host srcHost, Host destHost, AsyncCompletionCallback<CopyCommandResult> callback) {\n        String errMsg = null;\n\n        try {\n            if (srcHost.getHypervisorType() != HypervisorType.KVM) {\n                throw new CloudRuntimeException(\"Invalid hypervisor type (only KVM supported for this operation at the time being)\");\n            }\n\n            verifyLiveMigrationForKVM(volumeDataStoreMap, destHost);\n\n            VMInstanceVO vmInstance = _vmDao.findById(vmTO.getId());\n            vmTO.setState(vmInstance.getState());\n            List<MigrateDiskInfo> migrateDiskInfoList = new ArrayList<MigrateDiskInfo>();\n\n            Map<String, MigrateCommand.MigrateDiskInfo> migrateStorage = new HashMap<>();\n            Map<VolumeInfo, VolumeInfo> srcVolumeInfoToDestVolumeInfo = new HashMap<>();\n\n            boolean managedStorageDestination = false;\n            for (Map.Entry<VolumeInfo, DataStore> entry : volumeDataStoreMap.entrySet()) {\n                VolumeInfo srcVolumeInfo = entry.getKey();\n                DataStore destDataStore = entry.getValue();\n\n                VolumeVO srcVolume = _volumeDao.findById(srcVolumeInfo.getId());\n                StoragePoolVO destStoragePool = _storagePoolDao.findById(destDataStore.getId());\n                StoragePoolVO sourceStoragePool = _storagePoolDao.findById(srcVolumeInfo.getPoolId());\n\n                \r\n                if (sourceStoragePool.getId() == destStoragePool.getId() && sourceStoragePool.getPoolType() == Storage.StoragePoolType.PowerFlex) {\n                    continue;\n                }\n\n                if (!shouldMigrateVolume(sourceStoragePool, destHost, destStoragePool)) {\n                    continue;\n                }\n\n                copyTemplateToTargetFilesystemStorageIfNeeded(srcVolumeInfo, sourceStoragePool, destDataStore, destStoragePool, destHost);\n\n                VolumeVO destVolume = duplicateVolumeOnAnotherStorage(srcVolume, destStoragePool);\n                VolumeInfo destVolumeInfo = _volumeDataFactory.getVolume(destVolume.getId(), destDataStore);\n\n                \r\n                destVolumeInfo.processEvent(Event.MigrationCopyRequested);\n                \r\n                destVolumeInfo.processEvent(Event.MigrationCopySucceeded);\n                \r\n                destVolumeInfo.processEvent(Event.MigrationRequested);\n\n                setVolumeMigrationOptions(srcVolumeInfo, destVolumeInfo, vmTO, srcHost, destStoragePool);\n\n                \r\n                destDataStore.getDriver().createAsync(destDataStore, destVolumeInfo, null);\n\n                managedStorageDestination = destStoragePool.isManaged();\n                String volumeIdentifier = managedStorageDestination ? destVolumeInfo.get_iScsiName() : destVolumeInfo.getUuid();\n\n                destVolume = _volumeDao.findById(destVolume.getId());\n                destVolume.setPath(volumeIdentifier);\n\n                setVolumePath(destVolume);\n\n                _volumeDao.update(destVolume.getId(), destVolume);\n\n                postVolumeCreationActions(srcVolumeInfo, destVolumeInfo, vmTO, srcHost);\n\n                destVolumeInfo = _volumeDataFactory.getVolume(destVolume.getId(), destDataStore);\n\n                handleQualityOfServiceForVolumeMigration(destVolumeInfo, PrimaryDataStoreDriver.QualityOfServiceState.MIGRATION);\n\n                _volumeService.grantAccess(destVolumeInfo, destHost, destDataStore);\n\n                String destPath = generateDestPath(destHost, destStoragePool, destVolumeInfo);\n\n                MigrateCommand.MigrateDiskInfo migrateDiskInfo;\n\n                boolean isNonManagedNfsToNfs = sourceStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem\n                        && destStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem && !managedStorageDestination;\n                if (isNonManagedNfsToNfs) {\n                    migrateDiskInfo = new MigrateCommand.MigrateDiskInfo(srcVolumeInfo.getPath(),\n                            MigrateCommand.MigrateDiskInfo.DiskType.FILE,\n                            MigrateCommand.MigrateDiskInfo.DriverType.QCOW2,\n                            MigrateCommand.MigrateDiskInfo.Source.FILE,\n                            connectHostToVolume(destHost, destVolumeInfo.getPoolId(), volumeIdentifier));\n                } else {\n                    migrateDiskInfo = configureMigrateDiskInfo(srcVolumeInfo, destPath);\n                    migrateDiskInfo.setSourceDiskOnStorageFileSystem(isStoragePoolTypeOfFile(sourceStoragePool));\n                    migrateDiskInfoList.add(migrateDiskInfo);\n                }\n\n                migrateStorage.put(srcVolumeInfo.getPath(), migrateDiskInfo);\n\n                srcVolumeInfoToDestVolumeInfo.put(srcVolumeInfo, destVolumeInfo);\n            }\n\n            PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(vmTO);\n\n            try {\n                Answer pfma = agentManager.send(destHost.getId(), pfmc);\n\n                if (pfma == null || !pfma.getResult()) {\n                    String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                    String msg = \"Unable to prepare for migration due to the following: \" + details;\n\n                    throw new AgentUnavailableException(msg, destHost.getId());\n                }\n            }\n            catch (final OperationTimedoutException e) {\n                throw new AgentUnavailableException(\"Operation timed out\", destHost.getId());\n            }\n\n            VMInstanceVO vm = _vmDao.findById(vmTO.getId());\n            boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n\n            boolean migrateNonSharedInc = isSourceAndDestinationPoolTypeOfNfs(volumeDataStoreMap);\n\n            MigrateCommand migrateCommand = new MigrateCommand(vmTO.getName(), destHost.getPrivateIpAddress(), isWindows, vmTO, true);\n            migrateCommand.setWait(StorageManager.KvmStorageOnlineMigrationWait.value());\n            migrateCommand.setMigrateStorage(migrateStorage);\n            migrateCommand.setMigrateDiskInfoList(migrateDiskInfoList);\n            migrateCommand.setMigrateStorageManaged(managedStorageDestination);\n            migrateCommand.setMigrateNonSharedInc(migrateNonSharedInc);\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            migrateCommand.setAutoConvergence(kvmAutoConvergence);\n\n            MigrateAnswer migrateAnswer = (MigrateAnswer)agentManager.send(srcHost.getId(), migrateCommand);\n\n            boolean success = migrateAnswer != null && migrateAnswer.getResult();\n\n            handlePostMigration(success, srcVolumeInfoToDestVolumeInfo, vmTO, destHost);\n\n            if (migrateAnswer == null) {\n                throw new CloudRuntimeException(\"Unable to get an answer to the migrate command\");\n            }\n\n            if (!migrateAnswer.getResult()) {\n                errMsg = migrateAnswer.getDetails();\n\n                throw new CloudRuntimeException(errMsg);\n            }\n        } catch (Exception ex) {\n            errMsg = \"Copy operation failed in 'StorageSystemDataMotionStrategy.copyAsync': \" + ex.getMessage();\n            LOGGER.error(errMsg, ex);\n            throw new CloudRuntimeException(errMsg);\n        } finally {\n            CopyCmdAnswer copyCmdAnswer = new CopyCmdAnswer(errMsg);\n\n            CopyCommandResult result = new CopyCommandResult(null, copyCmdAnswer);\n\n            result.setResult(errMsg);\n\n            callback.complete(result);\n        }\n    }\n","realPath":"engine/storage/datamotion/src/main/java/org/apache/cloudstack/storage/motion/StorageSystemDataMotionStrategy.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1785,"status":"M"},{"authorDate":"2019-08-07 18:11:30","commitOrder":9,"curCode":"    protected boolean isSourceAndDestinationPoolTypeOfNfs(Map<VolumeInfo, DataStore> volumeDataStoreMap) {\n        for (Map.Entry<VolumeInfo, DataStore> entry : volumeDataStoreMap.entrySet()) {\n            VolumeInfo srcVolumeInfo = entry.getKey();\n            DataStore destDataStore = entry.getValue();\n\n            StoragePoolVO destStoragePool = _storagePoolDao.findById(destDataStore.getId());\n            StoragePoolVO sourceStoragePool = _storagePoolDao.findById(srcVolumeInfo.getPoolId());\n            if (sourceStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem && destStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem) {\n                return true;\n            }\n        }\n        return false;\n    }\n","date":"2019-08-07 18:11:30","endLine":1929,"groupId":"4567","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"isSourceAndDestinationPoolTypeOfNfs","params":"(Map<VolumeInfo@DataStore>volumeDataStoreMap)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/4d/3ec184ac169f2c7210194889c7bc6a65d0ce89.src","preCode":"    protected boolean isSourceAndDestinationPoolTypeOfNfs(Map<VolumeInfo, DataStore> volumeDataStoreMap) {\n        for (Map.Entry<VolumeInfo, DataStore> entry : volumeDataStoreMap.entrySet()) {\n            VolumeInfo srcVolumeInfo = entry.getKey();\n            DataStore destDataStore = entry.getValue();\n\n            StoragePoolVO destStoragePool = _storagePoolDao.findById(destDataStore.getId());\n            StoragePoolVO sourceStoragePool = _storagePoolDao.findById(srcVolumeInfo.getPoolId());\n            if (sourceStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem && destStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem) {\n                return true;\n            }\n        }\n        return false;\n    }\n","realPath":"engine/storage/datamotion/src/main/java/org/apache/cloudstack/storage/motion/StorageSystemDataMotionStrategy.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1917,"status":"N"}],"commitId":"59fba4916b5c52ca5b3101faaa0f43498201644b","commitMessage":"@@@Fix npe when migrating vm with volume (#4698)\n\nCo-authored-by: Daniel Augusto Veronezi Salvador <daniel@scclouds.com.br>","date":"2021-03-09 00:56:56","modifiedFileCount":"3","status":"M","submitter":"Daniel Augusto Veronezi Salvador"},{"authorTime":"2019-08-07 18:11:30","codes":[{"authorDate":"2021-08-16 23:32:19","commitOrder":10,"curCode":"    public void copyAsync(Map<VolumeInfo, DataStore> volumeDataStoreMap, VirtualMachineTO vmTO, Host srcHost, Host destHost, AsyncCompletionCallback<CopyCommandResult> callback) {\n        String errMsg = null;\n\n        try {\n            if (srcHost.getHypervisorType() != HypervisorType.KVM) {\n                throw new CloudRuntimeException(\"Invalid hypervisor type (only KVM supported for this operation at the time being)\");\n            }\n\n            verifyLiveMigrationForKVM(volumeDataStoreMap, destHost);\n\n            VMInstanceVO vmInstance = _vmDao.findById(vmTO.getId());\n            vmTO.setState(vmInstance.getState());\n            List<MigrateDiskInfo> migrateDiskInfoList = new ArrayList<MigrateDiskInfo>();\n\n            Map<String, MigrateCommand.MigrateDiskInfo> migrateStorage = new HashMap<>();\n            Map<VolumeInfo, VolumeInfo> srcVolumeInfoToDestVolumeInfo = new HashMap<>();\n\n            boolean managedStorageDestination = false;\n            for (Map.Entry<VolumeInfo, DataStore> entry : volumeDataStoreMap.entrySet()) {\n                VolumeInfo srcVolumeInfo = entry.getKey();\n                DataStore destDataStore = entry.getValue();\n\n                VolumeVO srcVolume = _volumeDao.findById(srcVolumeInfo.getId());\n                StoragePoolVO destStoragePool = _storagePoolDao.findById(destDataStore.getId());\n                StoragePoolVO sourceStoragePool = _storagePoolDao.findById(srcVolumeInfo.getPoolId());\n\n                \r\n                if (sourceStoragePool.getId() == destStoragePool.getId() && sourceStoragePool.getPoolType() == Storage.StoragePoolType.PowerFlex) {\n                    continue;\n                }\n\n                if (!shouldMigrateVolume(sourceStoragePool, destHost, destStoragePool)) {\n                    continue;\n                }\n\n                if (srcVolumeInfo.getTemplateId() != null) {\n                    LOGGER.debug(String.format(\"Copying template [%s] of volume [%s] from source storage pool [%s] to target storage pool [%s].\", srcVolumeInfo.getTemplateId(), srcVolumeInfo.getId(), sourceStoragePool.getId(), destStoragePool.getId()));\n                    copyTemplateToTargetFilesystemStorageIfNeeded(srcVolumeInfo, sourceStoragePool, destDataStore, destStoragePool, destHost);\n                } else {\n                    LOGGER.debug(String.format(\"Skipping copy template from source storage pool [%s] to target storage pool [%s] before migration due to volume [%s] does not have a template.\", sourceStoragePool.getId(), destStoragePool.getId(), srcVolumeInfo.getId()));\n                }\n\n                VolumeVO destVolume = duplicateVolumeOnAnotherStorage(srcVolume, destStoragePool);\n                VolumeInfo destVolumeInfo = _volumeDataFactory.getVolume(destVolume.getId(), destDataStore);\n\n                \r\n                destVolumeInfo.processEvent(Event.MigrationCopyRequested);\n                \r\n                destVolumeInfo.processEvent(Event.MigrationCopySucceeded);\n                \r\n                destVolumeInfo.processEvent(Event.MigrationRequested);\n\n                setVolumeMigrationOptions(srcVolumeInfo, destVolumeInfo, vmTO, srcHost, destStoragePool);\n\n                \r\n                destDataStore.getDriver().createAsync(destDataStore, destVolumeInfo, null);\n\n                managedStorageDestination = destStoragePool.isManaged();\n                String volumeIdentifier = managedStorageDestination ? destVolumeInfo.get_iScsiName() : destVolumeInfo.getUuid();\n\n                destVolume = _volumeDao.findById(destVolume.getId());\n                destVolume.setPath(volumeIdentifier);\n\n                setVolumePath(destVolume);\n\n                _volumeDao.update(destVolume.getId(), destVolume);\n\n                postVolumeCreationActions(srcVolumeInfo, destVolumeInfo, vmTO, srcHost);\n\n                destVolumeInfo = _volumeDataFactory.getVolume(destVolume.getId(), destDataStore);\n\n                handleQualityOfServiceForVolumeMigration(destVolumeInfo, PrimaryDataStoreDriver.QualityOfServiceState.MIGRATION);\n\n                _volumeService.grantAccess(destVolumeInfo, destHost, destDataStore);\n\n                String destPath = generateDestPath(destHost, destStoragePool, destVolumeInfo);\n\n                MigrateCommand.MigrateDiskInfo migrateDiskInfo;\n\n                boolean isNonManagedNfsToNfsOrSharedMountPointToNfs = supportStoragePoolType(sourceStoragePool.getPoolType()) && destStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem && !managedStorageDestination;\n                if (isNonManagedNfsToNfsOrSharedMountPointToNfs) {\n                    migrateDiskInfo = new MigrateCommand.MigrateDiskInfo(srcVolumeInfo.getPath(),\n                            MigrateCommand.MigrateDiskInfo.DiskType.FILE,\n                            MigrateCommand.MigrateDiskInfo.DriverType.QCOW2,\n                            MigrateCommand.MigrateDiskInfo.Source.FILE,\n                            connectHostToVolume(destHost, destVolumeInfo.getPoolId(), volumeIdentifier));\n                } else {\n                    migrateDiskInfo = configureMigrateDiskInfo(srcVolumeInfo, destPath);\n                    migrateDiskInfo.setSourceDiskOnStorageFileSystem(isStoragePoolTypeOfFile(sourceStoragePool));\n                    migrateDiskInfoList.add(migrateDiskInfo);\n                }\n\n                migrateStorage.put(srcVolumeInfo.getPath(), migrateDiskInfo);\n\n                srcVolumeInfoToDestVolumeInfo.put(srcVolumeInfo, destVolumeInfo);\n            }\n\n            PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(vmTO);\n\n            try {\n                Answer pfma = agentManager.send(destHost.getId(), pfmc);\n\n                if (pfma == null || !pfma.getResult()) {\n                    String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                    String msg = \"Unable to prepare for migration due to the following: \" + details;\n\n                    throw new AgentUnavailableException(msg, destHost.getId());\n                }\n            }\n            catch (final OperationTimedoutException e) {\n                throw new AgentUnavailableException(\"Operation timed out\", destHost.getId());\n            }\n\n            VMInstanceVO vm = _vmDao.findById(vmTO.getId());\n            boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n\n            boolean migrateNonSharedInc = isSourceAndDestinationPoolTypeOfNfs(volumeDataStoreMap);\n\n            MigrateCommand migrateCommand = new MigrateCommand(vmTO.getName(), destHost.getPrivateIpAddress(), isWindows, vmTO, true);\n            migrateCommand.setWait(StorageManager.KvmStorageOnlineMigrationWait.value());\n            migrateCommand.setMigrateStorage(migrateStorage);\n            migrateCommand.setMigrateDiskInfoList(migrateDiskInfoList);\n            migrateCommand.setMigrateStorageManaged(managedStorageDestination);\n            migrateCommand.setMigrateNonSharedInc(migrateNonSharedInc);\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            migrateCommand.setAutoConvergence(kvmAutoConvergence);\n\n            MigrateAnswer migrateAnswer = (MigrateAnswer)agentManager.send(srcHost.getId(), migrateCommand);\n\n            boolean success = migrateAnswer != null && migrateAnswer.getResult();\n\n            handlePostMigration(success, srcVolumeInfoToDestVolumeInfo, vmTO, destHost);\n\n            if (migrateAnswer == null) {\n                throw new CloudRuntimeException(\"Unable to get an answer to the migrate command\");\n            }\n\n            if (!migrateAnswer.getResult()) {\n                errMsg = migrateAnswer.getDetails();\n\n                throw new CloudRuntimeException(errMsg);\n            }\n        } catch (AgentUnavailableException | OperationTimedoutException | CloudRuntimeException ex) {\n            String volumesAndStorages = volumeDataStoreMap.entrySet().stream().map(entry -> formatEntryOfVolumesAndStoragesAsJsonToDisplayOnLog(entry)).collect(Collectors.joining(\",\"));\n\n            errMsg = String.format(\"Copy volume(s) to storage(s) [%s] and VM to host [%s] failed in StorageSystemDataMotionStrategy.copyAsync. Error message: [%s].\", volumesAndStorages, formatMigrationElementsAsJsonToDisplayOnLog(\"vm\", vmTO.getId(), srcHost.getId(), destHost.getId()), ex.getMessage());\n            LOGGER.error(errMsg, ex);\n\n            throw new CloudRuntimeException(errMsg);\n        } finally {\n            CopyCmdAnswer copyCmdAnswer = new CopyCmdAnswer(errMsg);\n\n            CopyCommandResult result = new CopyCommandResult(null, copyCmdAnswer);\n\n            result.setResult(errMsg);\n\n            callback.complete(result);\n        }\n    }\n","date":"2021-08-16 23:32:19","endLine":1947,"groupId":"12710","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"copyAsync","params":"(Map<VolumeInfo@DataStore>volumeDataStoreMap@VirtualMachineTOvmTO@HostsrcHost@HostdestHost@AsyncCompletionCallback<CopyCommandResult>callback)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/3c/68793e348395fa5f6c50c93f5abb2c5837b419.src","preCode":"    public void copyAsync(Map<VolumeInfo, DataStore> volumeDataStoreMap, VirtualMachineTO vmTO, Host srcHost, Host destHost, AsyncCompletionCallback<CopyCommandResult> callback) {\n        String errMsg = null;\n\n        try {\n            if (srcHost.getHypervisorType() != HypervisorType.KVM) {\n                throw new CloudRuntimeException(\"Invalid hypervisor type (only KVM supported for this operation at the time being)\");\n            }\n\n            verifyLiveMigrationForKVM(volumeDataStoreMap, destHost);\n\n            VMInstanceVO vmInstance = _vmDao.findById(vmTO.getId());\n            vmTO.setState(vmInstance.getState());\n            List<MigrateDiskInfo> migrateDiskInfoList = new ArrayList<MigrateDiskInfo>();\n\n            Map<String, MigrateCommand.MigrateDiskInfo> migrateStorage = new HashMap<>();\n            Map<VolumeInfo, VolumeInfo> srcVolumeInfoToDestVolumeInfo = new HashMap<>();\n\n            boolean managedStorageDestination = false;\n            for (Map.Entry<VolumeInfo, DataStore> entry : volumeDataStoreMap.entrySet()) {\n                VolumeInfo srcVolumeInfo = entry.getKey();\n                DataStore destDataStore = entry.getValue();\n\n                VolumeVO srcVolume = _volumeDao.findById(srcVolumeInfo.getId());\n                StoragePoolVO destStoragePool = _storagePoolDao.findById(destDataStore.getId());\n                StoragePoolVO sourceStoragePool = _storagePoolDao.findById(srcVolumeInfo.getPoolId());\n\n                \r\n                if (sourceStoragePool.getId() == destStoragePool.getId() && sourceStoragePool.getPoolType() == Storage.StoragePoolType.PowerFlex) {\n                    continue;\n                }\n\n                if (!shouldMigrateVolume(sourceStoragePool, destHost, destStoragePool)) {\n                    continue;\n                }\n\n                if (srcVolumeInfo.getTemplateId() != null) {\n                    LOGGER.debug(String.format(\"Copying template [%s] of volume [%s] from source storage pool [%s] to target storage pool [%s].\", srcVolumeInfo.getTemplateId(), srcVolumeInfo.getId(), sourceStoragePool.getId(), destStoragePool.getId()));\n                    copyTemplateToTargetFilesystemStorageIfNeeded(srcVolumeInfo, sourceStoragePool, destDataStore, destStoragePool, destHost);\n                } else {\n                    LOGGER.debug(String.format(\"Skipping copy template from source storage pool [%s] to target storage pool [%s] before migration due to volume [%s] does not have a template.\", sourceStoragePool.getId(), destStoragePool.getId(), srcVolumeInfo.getId()));\n                }\n\n                VolumeVO destVolume = duplicateVolumeOnAnotherStorage(srcVolume, destStoragePool);\n                VolumeInfo destVolumeInfo = _volumeDataFactory.getVolume(destVolume.getId(), destDataStore);\n\n                \r\n                destVolumeInfo.processEvent(Event.MigrationCopyRequested);\n                \r\n                destVolumeInfo.processEvent(Event.MigrationCopySucceeded);\n                \r\n                destVolumeInfo.processEvent(Event.MigrationRequested);\n\n                setVolumeMigrationOptions(srcVolumeInfo, destVolumeInfo, vmTO, srcHost, destStoragePool);\n\n                \r\n                destDataStore.getDriver().createAsync(destDataStore, destVolumeInfo, null);\n\n                managedStorageDestination = destStoragePool.isManaged();\n                String volumeIdentifier = managedStorageDestination ? destVolumeInfo.get_iScsiName() : destVolumeInfo.getUuid();\n\n                destVolume = _volumeDao.findById(destVolume.getId());\n                destVolume.setPath(volumeIdentifier);\n\n                setVolumePath(destVolume);\n\n                _volumeDao.update(destVolume.getId(), destVolume);\n\n                postVolumeCreationActions(srcVolumeInfo, destVolumeInfo, vmTO, srcHost);\n\n                destVolumeInfo = _volumeDataFactory.getVolume(destVolume.getId(), destDataStore);\n\n                handleQualityOfServiceForVolumeMigration(destVolumeInfo, PrimaryDataStoreDriver.QualityOfServiceState.MIGRATION);\n\n                _volumeService.grantAccess(destVolumeInfo, destHost, destDataStore);\n\n                String destPath = generateDestPath(destHost, destStoragePool, destVolumeInfo);\n\n                MigrateCommand.MigrateDiskInfo migrateDiskInfo;\n\n                boolean isNonManagedNfsToNfs = sourceStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem\n                        && destStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem && !managedStorageDestination;\n                if (isNonManagedNfsToNfs) {\n                    migrateDiskInfo = new MigrateCommand.MigrateDiskInfo(srcVolumeInfo.getPath(),\n                            MigrateCommand.MigrateDiskInfo.DiskType.FILE,\n                            MigrateCommand.MigrateDiskInfo.DriverType.QCOW2,\n                            MigrateCommand.MigrateDiskInfo.Source.FILE,\n                            connectHostToVolume(destHost, destVolumeInfo.getPoolId(), volumeIdentifier));\n                } else {\n                    migrateDiskInfo = configureMigrateDiskInfo(srcVolumeInfo, destPath);\n                    migrateDiskInfo.setSourceDiskOnStorageFileSystem(isStoragePoolTypeOfFile(sourceStoragePool));\n                    migrateDiskInfoList.add(migrateDiskInfo);\n                }\n\n                migrateStorage.put(srcVolumeInfo.getPath(), migrateDiskInfo);\n\n                srcVolumeInfoToDestVolumeInfo.put(srcVolumeInfo, destVolumeInfo);\n            }\n\n            PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(vmTO);\n\n            try {\n                Answer pfma = agentManager.send(destHost.getId(), pfmc);\n\n                if (pfma == null || !pfma.getResult()) {\n                    String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                    String msg = \"Unable to prepare for migration due to the following: \" + details;\n\n                    throw new AgentUnavailableException(msg, destHost.getId());\n                }\n            }\n            catch (final OperationTimedoutException e) {\n                throw new AgentUnavailableException(\"Operation timed out\", destHost.getId());\n            }\n\n            VMInstanceVO vm = _vmDao.findById(vmTO.getId());\n            boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n\n            boolean migrateNonSharedInc = isSourceAndDestinationPoolTypeOfNfs(volumeDataStoreMap);\n\n            MigrateCommand migrateCommand = new MigrateCommand(vmTO.getName(), destHost.getPrivateIpAddress(), isWindows, vmTO, true);\n            migrateCommand.setWait(StorageManager.KvmStorageOnlineMigrationWait.value());\n            migrateCommand.setMigrateStorage(migrateStorage);\n            migrateCommand.setMigrateDiskInfoList(migrateDiskInfoList);\n            migrateCommand.setMigrateStorageManaged(managedStorageDestination);\n            migrateCommand.setMigrateNonSharedInc(migrateNonSharedInc);\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            migrateCommand.setAutoConvergence(kvmAutoConvergence);\n\n            MigrateAnswer migrateAnswer = (MigrateAnswer)agentManager.send(srcHost.getId(), migrateCommand);\n\n            boolean success = migrateAnswer != null && migrateAnswer.getResult();\n\n            handlePostMigration(success, srcVolumeInfoToDestVolumeInfo, vmTO, destHost);\n\n            if (migrateAnswer == null) {\n                throw new CloudRuntimeException(\"Unable to get an answer to the migrate command\");\n            }\n\n            if (!migrateAnswer.getResult()) {\n                errMsg = migrateAnswer.getDetails();\n\n                throw new CloudRuntimeException(errMsg);\n            }\n        } catch (AgentUnavailableException | OperationTimedoutException | CloudRuntimeException ex) {\n            String volumesAndStorages = volumeDataStoreMap.entrySet().stream().map(entry -> formatEntryOfVolumesAndStoragesAsJsonToDisplayOnLog(entry)).collect(Collectors.joining(\",\"));\n\n            errMsg = String.format(\"Copy volume(s) to storage(s) [%s] and VM to host [%s] failed in StorageSystemDataMotionStrategy.copyAsync. Error message: [%s].\", volumesAndStorages, formatMigrationElementsAsJsonToDisplayOnLog(\"vm\", vmTO.getId(), srcHost.getId(), destHost.getId()), ex.getMessage());\n            LOGGER.error(errMsg, ex);\n\n            throw new CloudRuntimeException(errMsg);\n        } finally {\n            CopyCmdAnswer copyCmdAnswer = new CopyCmdAnswer(errMsg);\n\n            CopyCommandResult result = new CopyCommandResult(null, copyCmdAnswer);\n\n            result.setResult(errMsg);\n\n            callback.complete(result);\n        }\n    }\n","realPath":"engine/storage/datamotion/src/main/java/org/apache/cloudstack/storage/motion/StorageSystemDataMotionStrategy.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1788,"status":"M"},{"authorDate":"2019-08-07 18:11:30","commitOrder":10,"curCode":"    protected boolean isSourceAndDestinationPoolTypeOfNfs(Map<VolumeInfo, DataStore> volumeDataStoreMap) {\n        for (Map.Entry<VolumeInfo, DataStore> entry : volumeDataStoreMap.entrySet()) {\n            VolumeInfo srcVolumeInfo = entry.getKey();\n            DataStore destDataStore = entry.getValue();\n\n            StoragePoolVO destStoragePool = _storagePoolDao.findById(destDataStore.getId());\n            StoragePoolVO sourceStoragePool = _storagePoolDao.findById(srcVolumeInfo.getPoolId());\n            if (sourceStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem && destStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem) {\n                return true;\n            }\n        }\n        return false;\n    }\n","date":"2019-08-07 18:11:30","endLine":1929,"groupId":"12710","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"isSourceAndDestinationPoolTypeOfNfs","params":"(Map<VolumeInfo@DataStore>volumeDataStoreMap)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/4d/3ec184ac169f2c7210194889c7bc6a65d0ce89.src","preCode":"    protected boolean isSourceAndDestinationPoolTypeOfNfs(Map<VolumeInfo, DataStore> volumeDataStoreMap) {\n        for (Map.Entry<VolumeInfo, DataStore> entry : volumeDataStoreMap.entrySet()) {\n            VolumeInfo srcVolumeInfo = entry.getKey();\n            DataStore destDataStore = entry.getValue();\n\n            StoragePoolVO destStoragePool = _storagePoolDao.findById(destDataStore.getId());\n            StoragePoolVO sourceStoragePool = _storagePoolDao.findById(srcVolumeInfo.getPoolId());\n            if (sourceStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem && destStoragePool.getPoolType() == StoragePoolType.NetworkFilesystem) {\n                return true;\n            }\n        }\n        return false;\n    }\n","realPath":"engine/storage/datamotion/src/main/java/org/apache/cloudstack/storage/motion/StorageSystemDataMotionStrategy.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1917,"status":"N"}],"commitId":"65a48dcb74e53ea977ea133b46f4acc10378ab34","commitMessage":"@@@Add SharedMountPoint to KVMs supported storage pool types (#4780)\n\n* Add SharedMountPoint to KVMs supported storage pool types\n\n* Fix live migration to iSCSI and improve logs\n\nCo-authored-by: Daniel Augusto Veronezi Salvador <daniel@scclouds.com.br>","date":"2021-08-16 23:32:19","modifiedFileCount":"5","status":"M","submitter":"Daniel Augusto Veronezi Salvador"}]
