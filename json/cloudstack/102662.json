[{"authorTime":"2016-05-04 22:30:58","codes":[{"authorDate":"2016-05-04 22:30:58","commitOrder":1,"curCode":"    private static boolean doHandshakeUnwrap(final SocketChannel socketChannel, final SSLEngine sslEngine,\n                                             ByteBuffer peerAppData, ByteBuffer peerNetData, final int appBufferSize) throws IOException {\n        if (socketChannel == null || sslEngine == null || peerAppData == null || peerNetData == null || appBufferSize < 0) {\n            return false;\n        }\n        if (socketChannel.read(peerNetData) < 0) {\n            if (sslEngine.isInboundDone() && sslEngine.isOutboundDone()) {\n                return false;\n            }\n            try {\n                sslEngine.closeInbound();\n            } catch (SSLException e) {\n                s_logger.warn(\"This SSL engine was forced to close inbound due to end of stream.\");\n            }\n            sslEngine.closeOutbound();\n            \r\n            \r\n            return true;\n        }\n        peerNetData.flip();\n        SSLEngineResult result = null;\n        try {\n            result = sslEngine.unwrap(peerNetData, peerAppData);\n            peerNetData.compact();\n        } catch (SSLException sslException) {\n            s_logger.error(\"SSL error occurred while processing unwrap data: \" + sslException.getMessage());\n            sslEngine.closeOutbound();\n            return true;\n        }\n        switch (result.getStatus()) {\n            case OK:\n                break;\n            case BUFFER_OVERFLOW:\n                \r\n                peerAppData = enlargeBuffer(peerAppData, appBufferSize);\n                break;\n            case BUFFER_UNDERFLOW:\n                \r\n                \r\n                peerNetData = handleBufferUnderflow(sslEngine, peerNetData);\n                break;\n            case CLOSED:\n                if (sslEngine.isOutboundDone()) {\n                    return false;\n                } else {\n                    sslEngine.closeOutbound();\n                    break;\n                }\n            default:\n                throw new IllegalStateException(\"Invalid SSL status: \" + result.getStatus());\n        }\n        return true;\n    }\n","date":"2016-05-04 22:30:58","endLine":529,"groupId":"5170","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"doHandshakeUnwrap","params":"(finalSocketChannelsocketChannel@finalSSLEnginesslEngine@ByteBufferpeerAppData@ByteBufferpeerNetData@finalintappBufferSize)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/f2/97d52c077bb06fd6b775968a8d4218e18dbabd.src","preCode":"    private static boolean doHandshakeUnwrap(final SocketChannel socketChannel, final SSLEngine sslEngine,\n                                             ByteBuffer peerAppData, ByteBuffer peerNetData, final int appBufferSize) throws IOException {\n        if (socketChannel == null || sslEngine == null || peerAppData == null || peerNetData == null || appBufferSize < 0) {\n            return false;\n        }\n        if (socketChannel.read(peerNetData) < 0) {\n            if (sslEngine.isInboundDone() && sslEngine.isOutboundDone()) {\n                return false;\n            }\n            try {\n                sslEngine.closeInbound();\n            } catch (SSLException e) {\n                s_logger.warn(\"This SSL engine was forced to close inbound due to end of stream.\");\n            }\n            sslEngine.closeOutbound();\n            \r\n            \r\n            return true;\n        }\n        peerNetData.flip();\n        SSLEngineResult result = null;\n        try {\n            result = sslEngine.unwrap(peerNetData, peerAppData);\n            peerNetData.compact();\n        } catch (SSLException sslException) {\n            s_logger.error(\"SSL error occurred while processing unwrap data: \" + sslException.getMessage());\n            sslEngine.closeOutbound();\n            return true;\n        }\n        switch (result.getStatus()) {\n            case OK:\n                break;\n            case BUFFER_OVERFLOW:\n                \r\n                peerAppData = enlargeBuffer(peerAppData, appBufferSize);\n                break;\n            case BUFFER_UNDERFLOW:\n                \r\n                \r\n                peerNetData = handleBufferUnderflow(sslEngine, peerNetData);\n                break;\n            case CLOSED:\n                if (sslEngine.isOutboundDone()) {\n                    return false;\n                } else {\n                    sslEngine.closeOutbound();\n                    break;\n                }\n            default:\n                throw new IllegalStateException(\"Invalid SSL status: \" + result.getStatus());\n        }\n        return true;\n    }\n","realPath":"utils/src/main/java/com/cloud/utils/nio/Link.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":477,"status":"B"},{"authorDate":"2016-05-04 22:30:58","commitOrder":1,"curCode":"    private static boolean doHandshakeWrap(final SocketChannel socketChannel, final SSLEngine sslEngine,\n                                           ByteBuffer myAppData, ByteBuffer myNetData, ByteBuffer peerNetData,\n                                           final int netBufferSize) throws IOException {\n        if (socketChannel == null || sslEngine == null || myNetData == null || peerNetData == null\n                || myAppData == null || netBufferSize < 0) {\n            return false;\n        }\n        myNetData.clear();\n        SSLEngineResult result = null;\n        try {\n            result = sslEngine.wrap(myAppData, myNetData);\n        } catch (SSLException sslException) {\n            s_logger.error(\"SSL error occurred while processing wrap data: \" + sslException.getMessage());\n            sslEngine.closeOutbound();\n            return true;\n        }\n        switch (result.getStatus()) {\n            case OK :\n                myNetData.flip();\n                while (myNetData.hasRemaining()) {\n                    socketChannel.write(myNetData);\n                }\n                break;\n            case BUFFER_OVERFLOW:\n                \r\n                \r\n                \r\n                \r\n                myNetData = enlargeBuffer(myNetData, netBufferSize);\n                break;\n            case BUFFER_UNDERFLOW:\n                throw new SSLException(\"Buffer underflow occurred after a wrap. We should not reach here.\");\n            case CLOSED:\n                try {\n                    myNetData.flip();\n                    while (myNetData.hasRemaining()) {\n                        socketChannel.write(myNetData);\n                    }\n                    \r\n                    \r\n                    peerNetData.clear();\n                } catch (Exception e) {\n                    s_logger.error(\"Failed to send server's CLOSE message due to socket channel's failure.\");\n                }\n                break;\n            default:\n                throw new IllegalStateException(\"Invalid SSL status: \" + result.getStatus());\n        }\n        return true;\n    }\n","date":"2016-05-04 22:30:58","endLine":580,"groupId":"5172","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"doHandshakeWrap","params":"(finalSocketChannelsocketChannel@finalSSLEnginesslEngine@ByteBuffermyAppData@ByteBuffermyNetData@ByteBufferpeerNetData@finalintnetBufferSize)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/f2/97d52c077bb06fd6b775968a8d4218e18dbabd.src","preCode":"    private static boolean doHandshakeWrap(final SocketChannel socketChannel, final SSLEngine sslEngine,\n                                           ByteBuffer myAppData, ByteBuffer myNetData, ByteBuffer peerNetData,\n                                           final int netBufferSize) throws IOException {\n        if (socketChannel == null || sslEngine == null || myNetData == null || peerNetData == null\n                || myAppData == null || netBufferSize < 0) {\n            return false;\n        }\n        myNetData.clear();\n        SSLEngineResult result = null;\n        try {\n            result = sslEngine.wrap(myAppData, myNetData);\n        } catch (SSLException sslException) {\n            s_logger.error(\"SSL error occurred while processing wrap data: \" + sslException.getMessage());\n            sslEngine.closeOutbound();\n            return true;\n        }\n        switch (result.getStatus()) {\n            case OK :\n                myNetData.flip();\n                while (myNetData.hasRemaining()) {\n                    socketChannel.write(myNetData);\n                }\n                break;\n            case BUFFER_OVERFLOW:\n                \r\n                \r\n                \r\n                \r\n                myNetData = enlargeBuffer(myNetData, netBufferSize);\n                break;\n            case BUFFER_UNDERFLOW:\n                throw new SSLException(\"Buffer underflow occurred after a wrap. We should not reach here.\");\n            case CLOSED:\n                try {\n                    myNetData.flip();\n                    while (myNetData.hasRemaining()) {\n                        socketChannel.write(myNetData);\n                    }\n                    \r\n                    \r\n                    peerNetData.clear();\n                } catch (Exception e) {\n                    s_logger.error(\"Failed to send server's CLOSE message due to socket channel's failure.\");\n                }\n                break;\n            default:\n                throw new IllegalStateException(\"Invalid SSL status: \" + result.getStatus());\n        }\n        return true;\n    }\n","realPath":"utils/src/main/java/com/cloud/utils/nio/Link.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":531,"status":"B"}],"commitId":"7ce0e10fbcd949375e43535aae168421ecdaa562","commitMessage":"@@@Merge pull request #1493 from shapeblue/nio-fix\n\nCLOUDSTACK-9348: Use non-blocking SSL handshake in NioConnection/Link- Uses non-blocking socket config in NioClient and NioServer/NioConnection\n- Scalable connectivity from agents and peer clustered-management server\n- Removes blocking ssl handshake code with a non-blocking code\n- Protects from denial-of-service issues that can degrade mgmt server responsiveness\n  due to an aggressive/malicious client\n- Uses separate executor services for handling connect/accept events\n\nChanges are covered the NioTest so I did not write a new test.  advise how we can improve this. Further.  I tried to invest time on writing a benchmark test to reproduce a degraded server but could not write it deterministic-ally (sometimes fails/passes but not always). Review.  CI testing and feedback requested /cc @swill @jburwell @DaanHoogland @wido @remibergsma @rafaelweingartner @GabrielBrascher\n\n* pr/1493:\n  CLOUDSTACK-9348: Use non-blocking SSL handshake\n  CLOUDSTACK-9348: Unit test to demonstrate denial of service attack\n\nSigned-off-by: Will Stevens <williamstevens@gmail.com>\n","date":"2016-05-04 22:30:58","modifiedFileCount":"6","status":"B","submitter":"Will Stevens"},{"authorTime":"2017-08-28 18:15:11","codes":[{"authorDate":"2017-08-28 18:15:11","commitOrder":2,"curCode":"    private static boolean doHandshakeUnwrap(final SocketChannel socketChannel, final SSLEngine sslEngine,\n                                             ByteBuffer peerAppData, ByteBuffer peerNetData, final int appBufferSize) throws IOException {\n        if (socketChannel == null || sslEngine == null || peerAppData == null || peerNetData == null || appBufferSize < 0) {\n            return false;\n        }\n        if (socketChannel.read(peerNetData) < 0) {\n            if (sslEngine.isInboundDone() && sslEngine.isOutboundDone()) {\n                return false;\n            }\n            try {\n                sslEngine.closeInbound();\n            } catch (SSLException e) {\n                s_logger.warn(\"This SSL engine was forced to close inbound due to end of stream.\");\n            }\n            sslEngine.closeOutbound();\n            \r\n            \r\n            return true;\n        }\n        peerNetData.flip();\n        SSLEngineResult result = null;\n        try {\n            result = sslEngine.unwrap(peerNetData, peerAppData);\n            peerNetData.compact();\n        } catch (final SSLException sslException) {\n            s_logger.error(String.format(\"SSL error caught during unwrap data: %s, for local address=%s, remote address=%s. The client may have invalid ca-certificates.\",\n                    sslException.getMessage(), socketChannel.getLocalAddress(), socketChannel.getRemoteAddress()));\n            sslEngine.closeOutbound();\n            return true;\n        }\n        switch (result.getStatus()) {\n            case OK:\n                break;\n            case BUFFER_OVERFLOW:\n                \r\n                peerAppData = enlargeBuffer(peerAppData, appBufferSize);\n                break;\n            case BUFFER_UNDERFLOW:\n                \r\n                \r\n                peerNetData = handleBufferUnderflow(sslEngine, peerNetData);\n                break;\n            case CLOSED:\n                if (sslEngine.isOutboundDone()) {\n                    return false;\n                } else {\n                    sslEngine.closeOutbound();\n                    break;\n                }\n            default:\n                throw new IllegalStateException(\"Invalid SSL status: \" + result.getStatus());\n        }\n        return true;\n    }\n","date":"2017-08-28 18:15:11","endLine":525,"groupId":"5170","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"doHandshakeUnwrap","params":"(finalSocketChannelsocketChannel@finalSSLEnginesslEngine@ByteBufferpeerAppData@ByteBufferpeerNetData@finalintappBufferSize)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/e8/f36c69944d849ac5b40f1fa26fcb2e92593b66.src","preCode":"    private static boolean doHandshakeUnwrap(final SocketChannel socketChannel, final SSLEngine sslEngine,\n                                             ByteBuffer peerAppData, ByteBuffer peerNetData, final int appBufferSize) throws IOException {\n        if (socketChannel == null || sslEngine == null || peerAppData == null || peerNetData == null || appBufferSize < 0) {\n            return false;\n        }\n        if (socketChannel.read(peerNetData) < 0) {\n            if (sslEngine.isInboundDone() && sslEngine.isOutboundDone()) {\n                return false;\n            }\n            try {\n                sslEngine.closeInbound();\n            } catch (SSLException e) {\n                s_logger.warn(\"This SSL engine was forced to close inbound due to end of stream.\");\n            }\n            sslEngine.closeOutbound();\n            \r\n            \r\n            return true;\n        }\n        peerNetData.flip();\n        SSLEngineResult result = null;\n        try {\n            result = sslEngine.unwrap(peerNetData, peerAppData);\n            peerNetData.compact();\n        } catch (SSLException sslException) {\n            s_logger.error(\"SSL error occurred while processing unwrap data: \" + sslException.getMessage());\n            sslEngine.closeOutbound();\n            return true;\n        }\n        switch (result.getStatus()) {\n            case OK:\n                break;\n            case BUFFER_OVERFLOW:\n                \r\n                peerAppData = enlargeBuffer(peerAppData, appBufferSize);\n                break;\n            case BUFFER_UNDERFLOW:\n                \r\n                \r\n                peerNetData = handleBufferUnderflow(sslEngine, peerNetData);\n                break;\n            case CLOSED:\n                if (sslEngine.isOutboundDone()) {\n                    return false;\n                } else {\n                    sslEngine.closeOutbound();\n                    break;\n                }\n            default:\n                throw new IllegalStateException(\"Invalid SSL status: \" + result.getStatus());\n        }\n        return true;\n    }\n","realPath":"utils/src/main/java/com/cloud/utils/nio/Link.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":472,"status":"M"},{"authorDate":"2017-08-28 18:15:11","commitOrder":2,"curCode":"    private static boolean doHandshakeWrap(final SocketChannel socketChannel, final SSLEngine sslEngine,\n                                           ByteBuffer myAppData, ByteBuffer myNetData, ByteBuffer peerNetData,\n                                           final int netBufferSize) throws IOException {\n        if (socketChannel == null || sslEngine == null || myNetData == null || peerNetData == null\n                || myAppData == null || netBufferSize < 0) {\n            return false;\n        }\n        myNetData.clear();\n        SSLEngineResult result = null;\n        try {\n            result = sslEngine.wrap(myAppData, myNetData);\n        } catch (final SSLException sslException) {\n            s_logger.error(String.format(\"SSL error caught during wrap data: %s, for local address=%s, remote address=%s.\",\n                    sslException.getMessage(), socketChannel.getLocalAddress(), socketChannel.getRemoteAddress()));\n            sslEngine.closeOutbound();\n            return true;\n        }\n        switch (result.getStatus()) {\n            case OK :\n                myNetData.flip();\n                while (myNetData.hasRemaining()) {\n                    socketChannel.write(myNetData);\n                }\n                break;\n            case BUFFER_OVERFLOW:\n                \r\n                \r\n                \r\n                \r\n                myNetData = enlargeBuffer(myNetData, netBufferSize);\n                break;\n            case BUFFER_UNDERFLOW:\n                throw new SSLException(\"Buffer underflow occurred after a wrap. We should not reach here.\");\n            case CLOSED:\n                try {\n                    myNetData.flip();\n                    while (myNetData.hasRemaining()) {\n                        socketChannel.write(myNetData);\n                    }\n                    \r\n                    \r\n                    peerNetData.clear();\n                } catch (Exception e) {\n                    s_logger.error(\"Failed to send server's CLOSE message due to socket channel's failure.\");\n                }\n                break;\n            default:\n                throw new IllegalStateException(\"Invalid SSL status: \" + result.getStatus());\n        }\n        return true;\n    }\n","date":"2017-08-28 18:15:11","endLine":577,"groupId":"6587","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"doHandshakeWrap","params":"(finalSocketChannelsocketChannel@finalSSLEnginesslEngine@ByteBuffermyAppData@ByteBuffermyNetData@ByteBufferpeerNetData@finalintnetBufferSize)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/e8/f36c69944d849ac5b40f1fa26fcb2e92593b66.src","preCode":"    private static boolean doHandshakeWrap(final SocketChannel socketChannel, final SSLEngine sslEngine,\n                                           ByteBuffer myAppData, ByteBuffer myNetData, ByteBuffer peerNetData,\n                                           final int netBufferSize) throws IOException {\n        if (socketChannel == null || sslEngine == null || myNetData == null || peerNetData == null\n                || myAppData == null || netBufferSize < 0) {\n            return false;\n        }\n        myNetData.clear();\n        SSLEngineResult result = null;\n        try {\n            result = sslEngine.wrap(myAppData, myNetData);\n        } catch (SSLException sslException) {\n            s_logger.error(\"SSL error occurred while processing wrap data: \" + sslException.getMessage());\n            sslEngine.closeOutbound();\n            return true;\n        }\n        switch (result.getStatus()) {\n            case OK :\n                myNetData.flip();\n                while (myNetData.hasRemaining()) {\n                    socketChannel.write(myNetData);\n                }\n                break;\n            case BUFFER_OVERFLOW:\n                \r\n                \r\n                \r\n                \r\n                myNetData = enlargeBuffer(myNetData, netBufferSize);\n                break;\n            case BUFFER_UNDERFLOW:\n                throw new SSLException(\"Buffer underflow occurred after a wrap. We should not reach here.\");\n            case CLOSED:\n                try {\n                    myNetData.flip();\n                    while (myNetData.hasRemaining()) {\n                        socketChannel.write(myNetData);\n                    }\n                    \r\n                    \r\n                    peerNetData.clear();\n                } catch (Exception e) {\n                    s_logger.error(\"Failed to send server's CLOSE message due to socket channel's failure.\");\n                }\n                break;\n            default:\n                throw new IllegalStateException(\"Invalid SSL status: \" + result.getStatus());\n        }\n        return true;\n    }\n","realPath":"utils/src/main/java/com/cloud/utils/nio/Link.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":527,"status":"M"}],"commitId":"7ce54bf7a85d6df72f84c00fadf9b0fd42ab0d99","commitMessage":"@@@CLOUDSTACK-9993: Securing Agents Communications (#2239)\n\nThis introduces a new certificate authority framework that allows\npluggable CA provider implementations to handle certificate operations\naround issuance.  revocation and propagation. The framework injects\nitself to `NioServer` to handle agent connections securely. The\nframework adds assumptions in `NioClient` that a keystore if available\nwith known name `cloud.jks` will be used for SSL negotiations and\nhandshake.\n\nThis includes a default 'root' CA provider plugin which creates its own\nself-signed root certificate authority on first run and uses it for\nissuance and provisioning of certificate to CloudStack agents such as\nthe KVM.  CPVM and SSVM agents and also for the management server for\npeer clustering.\n\nAdditional changes and notes:\n- Comma separate list of management server IPs can be set to the 'host'\n  global setting. Newly provisioned agents (KVM/CPVM/SSVM etc) will get\n  radomized comma separated list to which they will attempt connection\n  or reconnection in provided order. This removes need of a TCP LB on\n  port 8250 (default) of the management server(s).\n- All fresh deployment will enforce two-way SSL authentication where\n  connecting agents will be required to present certificates issued\n  by the 'root' CA plugin.\n- Existing environment on upgrade will continue to use one-way SSL\n  authentication and connecting agents will not be required to present\n  certificates.\n- A script `keystore-setup` is responsible for initial keystore setup\n  and CSR generation on the agent/hosts.\n- A script `keystore-cert-import` is responsible for import provided\n  certificate payload to the java keystore file.\n- Agent security (keystore.  certificates etc) are setup initially using\n  SSH.  and later provisioning is handled via an existing agent connection\n  using command-answers. The supported clients and agents are limited to\n  CPVM.  SSVM.  and KVM agents.  and clustered management server (peering).\n- Certificate revocation does not revoke an existing agent-mgmt server\n  connection.  however rejects a revoked certificate used during SSL\n  handshake.\n- Older `cloudstackmanagement.keystore` is deprecated and will no longer\n  be used by mgmt server(s) for SSL negotiations and handshake. New\n  keystores will be named `cloud.jks`.  any additional SSL certificates\n  should not be imported in it for use with tomcat etc. The `cloud.jks`\n  keystore is stricly used for agent-server communications.\n- Management server keystore are validated and renewed on start up only. \n  the validity of them are same as the CA certificates.\n\nNew APIs:\n- listCaProviders: lists all available CA provider plugins\n- listCaCertificate: lists the CA certificate(s)\n- issueCertificate: issues X509 client certificate with/without a CSR\n- provisionCertificate: provisions certificate to a host\n- revokeCertificate: revokes a client certificate using its serial\n\nGlobal settings for the CA framework:\n- ca.framework.provider.plugin: The configured CA provider plugin\n- ca.framework.cert.keysize: The key size for certificate generation\n- ca.framework.cert.signature.algorithm: The certificate signature algorithm\n- ca.framework.cert.validity.period: Certificate validity in days\n- ca.framework.cert.automatic.renewal: Certificate auto-renewal setting\n- ca.framework.background.task.delay: CA background task delay/interval\n- ca.framework.cert.expiry.alert.period: Days to check and alert expiring certificates\n\nGlobal settings for the default 'root' CA provider:\n- ca.plugin.root.private.key: (hidden/encrypted) CA private key\n- ca.plugin.root.public.key: (hidden/encrypted) CA public key\n- ca.plugin.root.ca.certificate: (hidden/encrypted) CA certificate\n- ca.plugin.root.issuer.dn: The CA issue distinguished name\n- ca.plugin.root.auth.strictness: Are clients required to present certificates\n- ca.plugin.root.allow.expired.cert: Are clients with expired certificates allowed\n\nUI changes:\n- Button to download/save the CA certificates.\n\nMisc changes:\n- Upgrades bountycastle version and uses newer classes\n- Refactors SAMLUtil to use new CertUtils\n\nSigned-off-by: Rohit Yadav <rohit.yadav@shapeblue.com>","date":"2017-08-28 18:15:11","modifiedFileCount":"49","status":"M","submitter":"Rohit Yadav"},{"authorTime":"2017-12-24 14:50:54","codes":[{"authorDate":"2017-12-24 14:50:54","commitOrder":3,"curCode":"    private static HandshakeHolder doHandshakeUnwrap(final SocketChannel socketChannel, final SSLEngine sslEngine,\n                                             ByteBuffer peerAppData, ByteBuffer peerNetData, final int appBufferSize) throws IOException {\n        if (socketChannel == null || sslEngine == null || peerAppData == null || peerNetData == null || appBufferSize < 0) {\n            return new HandshakeHolder(peerAppData, peerNetData, false);\n        }\n        if (socketChannel.read(peerNetData) < 0) {\n            if (sslEngine.isInboundDone() && sslEngine.isOutboundDone()) {\n                return new HandshakeHolder(peerAppData, peerNetData, false);\n            }\n            try {\n                sslEngine.closeInbound();\n            } catch (SSLException e) {\n                s_logger.warn(\"This SSL engine was forced to close inbound due to end of stream.\");\n            }\n            sslEngine.closeOutbound();\n            \r\n            \r\n            return new HandshakeHolder(peerAppData, peerNetData, true);\n        }\n        peerNetData.flip();\n        SSLEngineResult result = null;\n        try {\n            result = sslEngine.unwrap(peerNetData, peerAppData);\n            peerNetData.compact();\n        } catch (final SSLException sslException) {\n            s_logger.error(String.format(\"SSL error caught during unwrap data: %s, for local address=%s, remote address=%s. The client may have invalid ca-certificates.\",\n                    sslException.getMessage(), socketChannel.getLocalAddress(), socketChannel.getRemoteAddress()));\n            sslEngine.closeOutbound();\n            return new HandshakeHolder(peerAppData, peerNetData, false);\n        }\n        if (result == null) {\n            return new HandshakeHolder(peerAppData, peerNetData, false);\n        }\n        switch (result.getStatus()) {\n            case OK:\n                break;\n            case BUFFER_OVERFLOW:\n                \r\n                peerAppData = enlargeBuffer(peerAppData, appBufferSize);\n                break;\n            case BUFFER_UNDERFLOW:\n                \r\n                \r\n                peerNetData = handleBufferUnderflow(sslEngine, peerNetData);\n                break;\n            case CLOSED:\n                if (sslEngine.isOutboundDone()) {\n                    return new HandshakeHolder(peerAppData, peerNetData, false);\n                } else {\n                    sslEngine.closeOutbound();\n                }\n                break;\n            default:\n                throw new IllegalStateException(\"Invalid SSL status: \" + result.getStatus());\n        }\n        return new HandshakeHolder(peerAppData, peerNetData, true);\n    }\n","date":"2017-12-24 14:50:54","endLine":536,"groupId":"5170","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"doHandshakeUnwrap","params":"(finalSocketChannelsocketChannel@finalSSLEnginesslEngine@ByteBufferpeerAppData@ByteBufferpeerNetData@finalintappBufferSize)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/25/f6662c5225b19637211b11cda77115f9eefb9d.src","preCode":"    private static boolean doHandshakeUnwrap(final SocketChannel socketChannel, final SSLEngine sslEngine,\n                                             ByteBuffer peerAppData, ByteBuffer peerNetData, final int appBufferSize) throws IOException {\n        if (socketChannel == null || sslEngine == null || peerAppData == null || peerNetData == null || appBufferSize < 0) {\n            return false;\n        }\n        if (socketChannel.read(peerNetData) < 0) {\n            if (sslEngine.isInboundDone() && sslEngine.isOutboundDone()) {\n                return false;\n            }\n            try {\n                sslEngine.closeInbound();\n            } catch (SSLException e) {\n                s_logger.warn(\"This SSL engine was forced to close inbound due to end of stream.\");\n            }\n            sslEngine.closeOutbound();\n            \r\n            \r\n            return true;\n        }\n        peerNetData.flip();\n        SSLEngineResult result = null;\n        try {\n            result = sslEngine.unwrap(peerNetData, peerAppData);\n            peerNetData.compact();\n        } catch (final SSLException sslException) {\n            s_logger.error(String.format(\"SSL error caught during unwrap data: %s, for local address=%s, remote address=%s. The client may have invalid ca-certificates.\",\n                    sslException.getMessage(), socketChannel.getLocalAddress(), socketChannel.getRemoteAddress()));\n            sslEngine.closeOutbound();\n            return true;\n        }\n        switch (result.getStatus()) {\n            case OK:\n                break;\n            case BUFFER_OVERFLOW:\n                \r\n                peerAppData = enlargeBuffer(peerAppData, appBufferSize);\n                break;\n            case BUFFER_UNDERFLOW:\n                \r\n                \r\n                peerNetData = handleBufferUnderflow(sslEngine, peerNetData);\n                break;\n            case CLOSED:\n                if (sslEngine.isOutboundDone()) {\n                    return false;\n                } else {\n                    sslEngine.closeOutbound();\n                    break;\n                }\n            default:\n                throw new IllegalStateException(\"Invalid SSL status: \" + result.getStatus());\n        }\n        return true;\n    }\n","realPath":"utils/src/main/java/com/cloud/utils/nio/Link.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":480,"status":"M"},{"authorDate":"2017-12-24 14:50:54","commitOrder":3,"curCode":"    private static HandshakeHolder doHandshakeWrap(final SocketChannel socketChannel, final SSLEngine sslEngine,\n                                           ByteBuffer myAppData, ByteBuffer myNetData, ByteBuffer peerNetData,\n                                           final int netBufferSize) throws IOException {\n        if (socketChannel == null || sslEngine == null || myNetData == null || peerNetData == null\n                || myAppData == null || netBufferSize < 0) {\n            return new HandshakeHolder(myAppData, myNetData, false);\n        }\n        myNetData.clear();\n        SSLEngineResult result = null;\n        try {\n            result = sslEngine.wrap(myAppData, myNetData);\n        } catch (final SSLException sslException) {\n            s_logger.error(String.format(\"SSL error caught during wrap data: %s, for local address=%s, remote address=%s.\",\n                    sslException.getMessage(), socketChannel.getLocalAddress(), socketChannel.getRemoteAddress()));\n            sslEngine.closeOutbound();\n            return new HandshakeHolder(myAppData, myNetData, true);\n        }\n        if (result == null) {\n            return new HandshakeHolder(myAppData, myNetData, false);\n        }\n        switch (result.getStatus()) {\n            case OK :\n                myNetData.flip();\n                while (myNetData.hasRemaining()) {\n                    socketChannel.write(myNetData);\n                }\n                break;\n            case BUFFER_OVERFLOW:\n                \r\n                \r\n                \r\n                \r\n                myNetData = enlargeBuffer(myNetData, netBufferSize);\n                break;\n            case BUFFER_UNDERFLOW:\n                throw new SSLException(\"Buffer underflow occurred after a wrap. We should not reach here.\");\n            case CLOSED:\n                try {\n                    myNetData.flip();\n                    while (myNetData.hasRemaining()) {\n                        socketChannel.write(myNetData);\n                    }\n                    \r\n                    \r\n                    peerNetData.clear();\n                } catch (Exception e) {\n                    s_logger.error(\"Failed to send server's CLOSE message due to socket channel's failure.\");\n                }\n                break;\n            default:\n                throw new IllegalStateException(\"Invalid SSL status: \" + result.getStatus());\n        }\n        return new HandshakeHolder(myAppData, myNetData, true);\n    }\n","date":"2017-12-24 14:50:54","endLine":591,"groupId":"5172","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"doHandshakeWrap","params":"(finalSocketChannelsocketChannel@finalSSLEnginesslEngine@ByteBuffermyAppData@ByteBuffermyNetData@ByteBufferpeerNetData@finalintnetBufferSize)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/25/f6662c5225b19637211b11cda77115f9eefb9d.src","preCode":"    private static boolean doHandshakeWrap(final SocketChannel socketChannel, final SSLEngine sslEngine,\n                                           ByteBuffer myAppData, ByteBuffer myNetData, ByteBuffer peerNetData,\n                                           final int netBufferSize) throws IOException {\n        if (socketChannel == null || sslEngine == null || myNetData == null || peerNetData == null\n                || myAppData == null || netBufferSize < 0) {\n            return false;\n        }\n        myNetData.clear();\n        SSLEngineResult result = null;\n        try {\n            result = sslEngine.wrap(myAppData, myNetData);\n        } catch (final SSLException sslException) {\n            s_logger.error(String.format(\"SSL error caught during wrap data: %s, for local address=%s, remote address=%s.\",\n                    sslException.getMessage(), socketChannel.getLocalAddress(), socketChannel.getRemoteAddress()));\n            sslEngine.closeOutbound();\n            return true;\n        }\n        switch (result.getStatus()) {\n            case OK :\n                myNetData.flip();\n                while (myNetData.hasRemaining()) {\n                    socketChannel.write(myNetData);\n                }\n                break;\n            case BUFFER_OVERFLOW:\n                \r\n                \r\n                \r\n                \r\n                myNetData = enlargeBuffer(myNetData, netBufferSize);\n                break;\n            case BUFFER_UNDERFLOW:\n                throw new SSLException(\"Buffer underflow occurred after a wrap. We should not reach here.\");\n            case CLOSED:\n                try {\n                    myNetData.flip();\n                    while (myNetData.hasRemaining()) {\n                        socketChannel.write(myNetData);\n                    }\n                    \r\n                    \r\n                    peerNetData.clear();\n                } catch (Exception e) {\n                    s_logger.error(\"Failed to send server's CLOSE message due to socket channel's failure.\");\n                }\n                break;\n            default:\n                throw new IllegalStateException(\"Invalid SSL status: \" + result.getStatus());\n        }\n        return true;\n    }\n","realPath":"utils/src/main/java/com/cloud/utils/nio/Link.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":538,"status":"M"}],"commitId":"f8a31b09c78ce6b3dcad9e52771554e404cd0285","commitMessage":"@@@Merge pull request #2211 from apache/debian9-systemvmtemplate\n\nCLOUDSTACK-10013: Migrate systemvmtemplate to Debian9\n\nSigned-off-by: Rohit Yadav <rohit@apache.org>","date":"2017-12-24 14:50:54","modifiedFileCount":"36","status":"M","submitter":"Rohit Yadav"},{"authorTime":"2017-12-24 14:50:54","codes":[{"authorDate":"2019-10-22 17:23:11","commitOrder":4,"curCode":"    private static HandshakeHolder doHandshakeUnwrap(final SocketChannel socketChannel, final SSLEngine sslEngine,\n                                             ByteBuffer peerAppData, ByteBuffer peerNetData, final int appBufferSize) throws IOException {\n        if (socketChannel == null || sslEngine == null || peerAppData == null || peerNetData == null || appBufferSize < 0) {\n            return new HandshakeHolder(peerAppData, peerNetData, false);\n        }\n        if (socketChannel.read(peerNetData) < 0) {\n            if (sslEngine.isInboundDone() && sslEngine.isOutboundDone()) {\n                return new HandshakeHolder(peerAppData, peerNetData, false);\n            }\n            try {\n                sslEngine.closeInbound();\n            } catch (SSLException e) {\n                s_logger.warn(\"This SSL engine was forced to close inbound due to end of stream.\", e);\n            }\n            sslEngine.closeOutbound();\n            \r\n            \r\n            return new HandshakeHolder(peerAppData, peerNetData, true);\n        }\n        peerNetData.flip();\n        SSLEngineResult result = null;\n        try {\n            result = sslEngine.unwrap(peerNetData, peerAppData);\n            peerNetData.compact();\n        } catch (final SSLException sslException) {\n            s_logger.error(String.format(\"SSL error caught during unwrap data: %s, for local address=%s, remote address=%s. The client may have invalid ca-certificates.\",\n                    sslException.getMessage(), socketChannel.getLocalAddress(), socketChannel.getRemoteAddress()));\n            sslEngine.closeOutbound();\n            return new HandshakeHolder(peerAppData, peerNetData, false);\n        }\n        if (result == null) {\n            return new HandshakeHolder(peerAppData, peerNetData, false);\n        }\n        switch (result.getStatus()) {\n            case OK:\n                break;\n            case BUFFER_OVERFLOW:\n                \r\n                peerAppData = enlargeBuffer(peerAppData, appBufferSize);\n                break;\n            case BUFFER_UNDERFLOW:\n                \r\n                \r\n                peerNetData = handleBufferUnderflow(sslEngine, peerNetData);\n                break;\n            case CLOSED:\n                if (sslEngine.isOutboundDone()) {\n                    return new HandshakeHolder(peerAppData, peerNetData, false);\n                } else {\n                    sslEngine.closeOutbound();\n                }\n                break;\n            default:\n                throw new IllegalStateException(\"Invalid SSL status: \" + result.getStatus());\n        }\n        return new HandshakeHolder(peerAppData, peerNetData, true);\n    }\n","date":"2019-10-22 17:23:11","endLine":536,"groupId":"102662","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"doHandshakeUnwrap","params":"(finalSocketChannelsocketChannel@finalSSLEnginesslEngine@ByteBufferpeerAppData@ByteBufferpeerNetData@finalintappBufferSize)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/9b/c6abb985b6b0b3c8f574a7bdb71601de4a56be.src","preCode":"    private static HandshakeHolder doHandshakeUnwrap(final SocketChannel socketChannel, final SSLEngine sslEngine,\n                                             ByteBuffer peerAppData, ByteBuffer peerNetData, final int appBufferSize) throws IOException {\n        if (socketChannel == null || sslEngine == null || peerAppData == null || peerNetData == null || appBufferSize < 0) {\n            return new HandshakeHolder(peerAppData, peerNetData, false);\n        }\n        if (socketChannel.read(peerNetData) < 0) {\n            if (sslEngine.isInboundDone() && sslEngine.isOutboundDone()) {\n                return new HandshakeHolder(peerAppData, peerNetData, false);\n            }\n            try {\n                sslEngine.closeInbound();\n            } catch (SSLException e) {\n                s_logger.warn(\"This SSL engine was forced to close inbound due to end of stream.\");\n            }\n            sslEngine.closeOutbound();\n            \r\n            \r\n            return new HandshakeHolder(peerAppData, peerNetData, true);\n        }\n        peerNetData.flip();\n        SSLEngineResult result = null;\n        try {\n            result = sslEngine.unwrap(peerNetData, peerAppData);\n            peerNetData.compact();\n        } catch (final SSLException sslException) {\n            s_logger.error(String.format(\"SSL error caught during unwrap data: %s, for local address=%s, remote address=%s. The client may have invalid ca-certificates.\",\n                    sslException.getMessage(), socketChannel.getLocalAddress(), socketChannel.getRemoteAddress()));\n            sslEngine.closeOutbound();\n            return new HandshakeHolder(peerAppData, peerNetData, false);\n        }\n        if (result == null) {\n            return new HandshakeHolder(peerAppData, peerNetData, false);\n        }\n        switch (result.getStatus()) {\n            case OK:\n                break;\n            case BUFFER_OVERFLOW:\n                \r\n                peerAppData = enlargeBuffer(peerAppData, appBufferSize);\n                break;\n            case BUFFER_UNDERFLOW:\n                \r\n                \r\n                peerNetData = handleBufferUnderflow(sslEngine, peerNetData);\n                break;\n            case CLOSED:\n                if (sslEngine.isOutboundDone()) {\n                    return new HandshakeHolder(peerAppData, peerNetData, false);\n                } else {\n                    sslEngine.closeOutbound();\n                }\n                break;\n            default:\n                throw new IllegalStateException(\"Invalid SSL status: \" + result.getStatus());\n        }\n        return new HandshakeHolder(peerAppData, peerNetData, true);\n    }\n","realPath":"utils/src/main/java/com/cloud/utils/nio/Link.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":480,"status":"M"},{"authorDate":"2017-12-24 14:50:54","commitOrder":4,"curCode":"    private static HandshakeHolder doHandshakeWrap(final SocketChannel socketChannel, final SSLEngine sslEngine,\n                                           ByteBuffer myAppData, ByteBuffer myNetData, ByteBuffer peerNetData,\n                                           final int netBufferSize) throws IOException {\n        if (socketChannel == null || sslEngine == null || myNetData == null || peerNetData == null\n                || myAppData == null || netBufferSize < 0) {\n            return new HandshakeHolder(myAppData, myNetData, false);\n        }\n        myNetData.clear();\n        SSLEngineResult result = null;\n        try {\n            result = sslEngine.wrap(myAppData, myNetData);\n        } catch (final SSLException sslException) {\n            s_logger.error(String.format(\"SSL error caught during wrap data: %s, for local address=%s, remote address=%s.\",\n                    sslException.getMessage(), socketChannel.getLocalAddress(), socketChannel.getRemoteAddress()));\n            sslEngine.closeOutbound();\n            return new HandshakeHolder(myAppData, myNetData, true);\n        }\n        if (result == null) {\n            return new HandshakeHolder(myAppData, myNetData, false);\n        }\n        switch (result.getStatus()) {\n            case OK :\n                myNetData.flip();\n                while (myNetData.hasRemaining()) {\n                    socketChannel.write(myNetData);\n                }\n                break;\n            case BUFFER_OVERFLOW:\n                \r\n                \r\n                \r\n                \r\n                myNetData = enlargeBuffer(myNetData, netBufferSize);\n                break;\n            case BUFFER_UNDERFLOW:\n                throw new SSLException(\"Buffer underflow occurred after a wrap. We should not reach here.\");\n            case CLOSED:\n                try {\n                    myNetData.flip();\n                    while (myNetData.hasRemaining()) {\n                        socketChannel.write(myNetData);\n                    }\n                    \r\n                    \r\n                    peerNetData.clear();\n                } catch (Exception e) {\n                    s_logger.error(\"Failed to send server's CLOSE message due to socket channel's failure.\");\n                }\n                break;\n            default:\n                throw new IllegalStateException(\"Invalid SSL status: \" + result.getStatus());\n        }\n        return new HandshakeHolder(myAppData, myNetData, true);\n    }\n","date":"2017-12-24 14:50:54","endLine":591,"groupId":"102662","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"doHandshakeWrap","params":"(finalSocketChannelsocketChannel@finalSSLEnginesslEngine@ByteBuffermyAppData@ByteBuffermyNetData@ByteBufferpeerNetData@finalintnetBufferSize)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/25/f6662c5225b19637211b11cda77115f9eefb9d.src","preCode":"    private static HandshakeHolder doHandshakeWrap(final SocketChannel socketChannel, final SSLEngine sslEngine,\n                                           ByteBuffer myAppData, ByteBuffer myNetData, ByteBuffer peerNetData,\n                                           final int netBufferSize) throws IOException {\n        if (socketChannel == null || sslEngine == null || myNetData == null || peerNetData == null\n                || myAppData == null || netBufferSize < 0) {\n            return new HandshakeHolder(myAppData, myNetData, false);\n        }\n        myNetData.clear();\n        SSLEngineResult result = null;\n        try {\n            result = sslEngine.wrap(myAppData, myNetData);\n        } catch (final SSLException sslException) {\n            s_logger.error(String.format(\"SSL error caught during wrap data: %s, for local address=%s, remote address=%s.\",\n                    sslException.getMessage(), socketChannel.getLocalAddress(), socketChannel.getRemoteAddress()));\n            sslEngine.closeOutbound();\n            return new HandshakeHolder(myAppData, myNetData, true);\n        }\n        if (result == null) {\n            return new HandshakeHolder(myAppData, myNetData, false);\n        }\n        switch (result.getStatus()) {\n            case OK :\n                myNetData.flip();\n                while (myNetData.hasRemaining()) {\n                    socketChannel.write(myNetData);\n                }\n                break;\n            case BUFFER_OVERFLOW:\n                \r\n                \r\n                \r\n                \r\n                myNetData = enlargeBuffer(myNetData, netBufferSize);\n                break;\n            case BUFFER_UNDERFLOW:\n                throw new SSLException(\"Buffer underflow occurred after a wrap. We should not reach here.\");\n            case CLOSED:\n                try {\n                    myNetData.flip();\n                    while (myNetData.hasRemaining()) {\n                        socketChannel.write(myNetData);\n                    }\n                    \r\n                    \r\n                    peerNetData.clear();\n                } catch (Exception e) {\n                    s_logger.error(\"Failed to send server's CLOSE message due to socket channel's failure.\");\n                }\n                break;\n            default:\n                throw new IllegalStateException(\"Invalid SSL status: \" + result.getStatus());\n        }\n        return new HandshakeHolder(myAppData, myNetData, true);\n    }\n","realPath":"utils/src/main/java/com/cloud/utils/nio/Link.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":538,"status":"N"}],"commitId":"9ee129ae6a08935645734ad520bec72bf5f22217","commitMessage":"@@@NioServer: retain links by address string to minimize resource leak (#3525)\n\nEvery time a client connects.  the NioServer will retain the link against\nthe InetSocketAddress object. If the same agent/client reconnects.  it\nwill grow older links over time and in case of denial of service attack\nor a client/script/monitoring-service reconnecting aggressively against\nport 8250 will cause the `_links` weak hashmap to grow over time and\nvery quickly.\n\nThe fix will ensure that only one Link gets weakly retained for an\nincoming client based on its address string.\n\nSigned-off-by: Rohit Yadav <rohit.yadav@shapeblue.com>","date":"2019-10-22 17:23:11","modifiedFileCount":"2","status":"M","submitter":"Rohit Yadav"}]
