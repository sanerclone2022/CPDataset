[{"authorTime":"2018-01-20 05:49:27","codes":[{"authorDate":"2018-01-20 05:49:27","commitOrder":1,"curCode":"    protected void migrate(final VMInstanceVO vm, final long srcHostId, final DeployDestination dest) throws ResourceUnavailableException, ConcurrentOperationException {\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {\n            final List<VolumeVO> volumes = _volsDao.findCreatedByInstance(vm.getId());\n            for (final VolumeVO volume : volumes) {\n                if (!_storagePoolDao.findById(volume.getPoolId()).getScope().equals(ScopeType.ZONE)) {\n                    s_logger.info(\"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                            + dest.getHost().getId());\n                    throw new CloudRuntimeException(\n                            \"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                                    + dest.getHost().getId());\n                }\n            }\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile vmSrc = new VirtualMachineProfileImpl(vm);\n        for (final NicProfile nic : _networkMgr.getNicProfiles(vm)) {\n            vmSrc.addNic(nic);\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        _networkMgr.prepareNicForMigration(profile, dest);\n        volumeMgr.prepareForMigration(profile, dest);\n        profile.setConfigDriveLabel(VmConfigDriveLabel.value());\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        }\n\n        boolean migrated = false;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            String autoConvergence = _configDao.getValue(Config.KvmAutoConvergence.toString());\n            boolean kvmAutoConvergence = Boolean.parseBoolean(autoConvergence);\n\n            mc.setAutoConvergence(kvmAutoConvergence);\n\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    throw new CloudRuntimeException(details);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm)), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm)), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            } else {\n                _networkMgr.commitNicForMigration(vmSrc, profile);\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","date":"2018-01-20 05:49:27","endLine":2293,"groupId":"8474","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"migrate","params":"(finalVMInstanceVOvm@finallongsrcHostId@finalDeployDestinationdest)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/37/5b091062473ccd85428a27886ac001b7c6652b.src","preCode":"    protected void migrate(final VMInstanceVO vm, final long srcHostId, final DeployDestination dest) throws ResourceUnavailableException, ConcurrentOperationException {\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {\n            final List<VolumeVO> volumes = _volsDao.findCreatedByInstance(vm.getId());\n            for (final VolumeVO volume : volumes) {\n                if (!_storagePoolDao.findById(volume.getPoolId()).getScope().equals(ScopeType.ZONE)) {\n                    s_logger.info(\"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                            + dest.getHost().getId());\n                    throw new CloudRuntimeException(\n                            \"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                                    + dest.getHost().getId());\n                }\n            }\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile vmSrc = new VirtualMachineProfileImpl(vm);\n        for (final NicProfile nic : _networkMgr.getNicProfiles(vm)) {\n            vmSrc.addNic(nic);\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        _networkMgr.prepareNicForMigration(profile, dest);\n        volumeMgr.prepareForMigration(profile, dest);\n        profile.setConfigDriveLabel(VmConfigDriveLabel.value());\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        }\n\n        boolean migrated = false;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            String autoConvergence = _configDao.getValue(Config.KvmAutoConvergence.toString());\n            boolean kvmAutoConvergence = Boolean.parseBoolean(autoConvergence);\n\n            mc.setAutoConvergence(kvmAutoConvergence);\n\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    throw new CloudRuntimeException(details);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm)), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm)), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            } else {\n                _networkMgr.commitNicForMigration(vmSrc, profile);\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":2127,"status":"B"},{"authorDate":"2018-01-20 05:49:27","commitOrder":1,"curCode":"    private void orchestrateMigrateForScale(final String vmUuid, final long srcHostId, final DeployDestination dest, final Long oldSvcOfferingId)\n            throws ResourceUnavailableException, ConcurrentOperationException {\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n\n        vm.getServiceOfferingId();\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {\n            s_logger.info(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dstHostId);\n            throw new CloudRuntimeException(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dest.getHost().getId());\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final long vmId = vm.getId();\n        vm = _vmDao.findByUuid(vmUuid);\n        if (vm == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"Unable to find a virtual machine with id \" + vmId);\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);\n        _networkMgr.prepareNicForMigration(profile, dest);\n\n        volumeMgr.prepareForMigration(profile, dest);\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        }\n\n        boolean migrated = false;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            String autoConvergence = _configDao.getValue(Config.KvmAutoConvergence.toString());\n            boolean kvmAutoConvergence = Boolean.parseBoolean(autoConvergence);\n\n            mc.setAutoConvergence(kvmAutoConvergence);\n\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    final String msg = \"Unable to migrate due to \" + details;\n                    s_logger.error(msg);\n                    throw new CloudRuntimeException(msg);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                final long newServiceOfferingId = vm.getServiceOfferingId();\n                vm.setServiceOfferingId(oldSvcOfferingId); \r\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n                vm.setServiceOfferingId(newServiceOfferingId);\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","date":"2018-01-20 05:49:27","endLine":3802,"groupId":"23580","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"orchestrateMigrateForScale","params":"(finalStringvmUuid@finallongsrcHostId@finalDeployDestinationdest@finalLongoldSvcOfferingId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/37/5b091062473ccd85428a27886ac001b7c6652b.src","preCode":"    private void orchestrateMigrateForScale(final String vmUuid, final long srcHostId, final DeployDestination dest, final Long oldSvcOfferingId)\n            throws ResourceUnavailableException, ConcurrentOperationException {\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n\n        vm.getServiceOfferingId();\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {\n            s_logger.info(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dstHostId);\n            throw new CloudRuntimeException(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dest.getHost().getId());\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final long vmId = vm.getId();\n        vm = _vmDao.findByUuid(vmUuid);\n        if (vm == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"Unable to find a virtual machine with id \" + vmId);\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);\n        _networkMgr.prepareNicForMigration(profile, dest);\n\n        volumeMgr.prepareForMigration(profile, dest);\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        }\n\n        boolean migrated = false;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            String autoConvergence = _configDao.getValue(Config.KvmAutoConvergence.toString());\n            boolean kvmAutoConvergence = Boolean.parseBoolean(autoConvergence);\n\n            mc.setAutoConvergence(kvmAutoConvergence);\n\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    final String msg = \"Unable to migrate due to \" + details;\n                    s_logger.error(msg);\n                    throw new CloudRuntimeException(msg);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                final long newServiceOfferingId = vm.getServiceOfferingId();\n                vm.setServiceOfferingId(oldSvcOfferingId); \r\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n                vm.setServiceOfferingId(newServiceOfferingId);\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":3637,"status":"B"}],"commitId":"893a88d225276e45f12f9490e6af2c94a81c2965","commitMessage":"@@@CLOUDSTACK-10105: Use maven standard project structure in all projects (#2283)\n\nRemove maven standard module (which only a few were using) and get ride of maven customization for the projects structure.\n\n- moved all directories to src/main/java.  src/main/resources.  src/main/scripts.  src/test/java.  src/test/resources\n- grep scan to search for src/com and src/org left over\n- grep for <project>/scripts to fix pom.xml configuration\n- remove custom <build> configuration in pom.xml\n\nSigned-off-by: Marc-Aur?le Brothier <m@brothier.org>","date":"2018-01-20 05:49:27","modifiedFileCount":"1","status":"B","submitter":"Marc-Aur?le Brothier"},{"authorTime":"2019-06-10 18:05:26","codes":[{"authorDate":"2019-06-10 18:05:26","commitOrder":2,"curCode":"    protected void migrate(final VMInstanceVO vm, final long srcHostId, final DeployDestination dest) throws ResourceUnavailableException, ConcurrentOperationException {\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {\n            final List<VolumeVO> volumes = _volsDao.findCreatedByInstance(vm.getId());\n            for (final VolumeVO volume : volumes) {\n                if (!_storagePoolDao.findById(volume.getPoolId()).getScope().equals(ScopeType.ZONE)) {\n                    s_logger.info(\"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                            + dest.getHost().getId());\n                    throw new CloudRuntimeException(\n                            \"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                                    + dest.getHost().getId());\n                }\n            }\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile vmSrc = new VirtualMachineProfileImpl(vm);\n        for (final NicProfile nic : _networkMgr.getNicProfiles(vm)) {\n            vmSrc.addNic(nic);\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        _networkMgr.prepareNicForMigration(profile, dest);\n        volumeMgr.prepareForMigration(profile, dest);\n        profile.setConfigDriveLabel(VmConfigDriveLabel.value());\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        }\n\n        boolean migrated = false;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    throw new CloudRuntimeException(details);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm)), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm)), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            } else {\n                _networkMgr.commitNicForMigration(vmSrc, profile);\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","date":"2019-06-10 18:05:26","endLine":2437,"groupId":"0","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"migrate","params":"(finalVMInstanceVOvm@finallongsrcHostId@finalDeployDestinationdest)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/35/4323ecd2f2aace2d9fe3a7ab2da48db54773b7.src","preCode":"    protected void migrate(final VMInstanceVO vm, final long srcHostId, final DeployDestination dest) throws ResourceUnavailableException, ConcurrentOperationException {\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {\n            final List<VolumeVO> volumes = _volsDao.findCreatedByInstance(vm.getId());\n            for (final VolumeVO volume : volumes) {\n                if (!_storagePoolDao.findById(volume.getPoolId()).getScope().equals(ScopeType.ZONE)) {\n                    s_logger.info(\"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                            + dest.getHost().getId());\n                    throw new CloudRuntimeException(\n                            \"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                                    + dest.getHost().getId());\n                }\n            }\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile vmSrc = new VirtualMachineProfileImpl(vm);\n        for (final NicProfile nic : _networkMgr.getNicProfiles(vm)) {\n            vmSrc.addNic(nic);\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        _networkMgr.prepareNicForMigration(profile, dest);\n        volumeMgr.prepareForMigration(profile, dest);\n        profile.setConfigDriveLabel(VmConfigDriveLabel.value());\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        }\n\n        boolean migrated = false;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            String autoConvergence = _configDao.getValue(Config.KvmAutoConvergence.toString());\n            boolean kvmAutoConvergence = Boolean.parseBoolean(autoConvergence);\n\n            mc.setAutoConvergence(kvmAutoConvergence);\n\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    throw new CloudRuntimeException(details);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm)), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm)), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            } else {\n                _networkMgr.commitNicForMigration(vmSrc, profile);\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":2274,"status":"M"},{"authorDate":"2019-06-10 18:05:26","commitOrder":2,"curCode":"    private void orchestrateMigrateForScale(final String vmUuid, final long srcHostId, final DeployDestination dest, final Long oldSvcOfferingId)\n            throws ResourceUnavailableException, ConcurrentOperationException {\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n\n        vm.getServiceOfferingId();\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {\n            s_logger.info(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dstHostId);\n            throw new CloudRuntimeException(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dest.getHost().getId());\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final long vmId = vm.getId();\n        vm = _vmDao.findByUuid(vmUuid);\n        if (vm == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"Unable to find a virtual machine with id \" + vmId);\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);\n        _networkMgr.prepareNicForMigration(profile, dest);\n\n        volumeMgr.prepareForMigration(profile, dest);\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        }\n\n        boolean migrated = false;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    final String msg = \"Unable to migrate due to \" + details;\n                    s_logger.error(msg);\n                    throw new CloudRuntimeException(msg);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                final long newServiceOfferingId = vm.getServiceOfferingId();\n                vm.setServiceOfferingId(oldSvcOfferingId); \r\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n                vm.setServiceOfferingId(newServiceOfferingId);\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","date":"2019-06-10 18:05:26","endLine":3966,"groupId":"13189","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"orchestrateMigrateForScale","params":"(finalStringvmUuid@finallongsrcHostId@finalDeployDestinationdest@finalLongoldSvcOfferingId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/35/4323ecd2f2aace2d9fe3a7ab2da48db54773b7.src","preCode":"    private void orchestrateMigrateForScale(final String vmUuid, final long srcHostId, final DeployDestination dest, final Long oldSvcOfferingId)\n            throws ResourceUnavailableException, ConcurrentOperationException {\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n\n        vm.getServiceOfferingId();\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {\n            s_logger.info(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dstHostId);\n            throw new CloudRuntimeException(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dest.getHost().getId());\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final long vmId = vm.getId();\n        vm = _vmDao.findByUuid(vmUuid);\n        if (vm == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"Unable to find a virtual machine with id \" + vmId);\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);\n        _networkMgr.prepareNicForMigration(profile, dest);\n\n        volumeMgr.prepareForMigration(profile, dest);\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        }\n\n        boolean migrated = false;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            String autoConvergence = _configDao.getValue(Config.KvmAutoConvergence.toString());\n            boolean kvmAutoConvergence = Boolean.parseBoolean(autoConvergence);\n\n            mc.setAutoConvergence(kvmAutoConvergence);\n\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    final String msg = \"Unable to migrate due to \" + details;\n                    s_logger.error(msg);\n                    throw new CloudRuntimeException(msg);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                final long newServiceOfferingId = vm.getServiceOfferingId();\n                vm.setServiceOfferingId(oldSvcOfferingId); \r\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n                vm.setServiceOfferingId(newServiceOfferingId);\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":3804,"status":"M"}],"commitId":"0fbf5006b87b6c5bc6188e3e1dd226a98c3bb453","commitMessage":"@@@kvm: live storage migration intra cluster from NFS source and destination (#2983)\n\nFeature Specification: https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=95653548\n\nLive storage migration on KVM under these conditions:\n\nFrom source and destination hosts within the same cluster\nFrom NFS primary storage to NFS cluster-wide primary storage\nSource NFS and destination NFS storage mounted on hosts\nIn order to enable this functionality.  database should be updated in order to enable live storage capacibilty for KVM.  if previous conditions are met. This is due to existing conflicts between qemu and libvirt versions. This has been tested on CentOS 6 hosts.\n\nAdditional notes:\n\nTo use this feature set the storage_motion_supported=1 in the hypervisor_capability table for KVM. This is done by default as the feature may not work in some environments.  read below.\nThis feature of online storage+VM migration for KVM will only work with CentOS6 and possible Ubuntu as KVM hosts but not with CentOS7 due to:\nhttps://bugs.centos.org/view.php?id=14026\nhttps://bugzilla.redhat.com/show_bug.cgi?id=1219541\nOn CentOS7 the error we see is: \" error: unable to execute QEMU command 'migrate': this feature or command is not currently supported\" (reference https://ask.openstack.org/en/question/94186/live-migration-unable-to-execute-qemu-command-migrate/). Reading through various lists looks like the migrate feature with qemu may be available with paid versions of RHEL-EV but not centos7 however this works with CentOS6.\nFix for CentOS 7:\n\nCreate repo file on /etc/yum.repos.d/:\n[qemu-kvm-rhev]\nname=oVirt rebuilds of qemu-kvm-rhev\nbaseurl=http://resources.ovirt.org/pub/ovirt-3.5/rpm/el7Server/\nmirrorlist=http://resources.ovirt.org/pub/yum-repo/mirrorlist-ovirt-3.5-el7Server\nenabled=1\nskip_if_unavailable=1\ngpgcheck=0\nyum install qemu-kvm-common-ev-2.3.0-29.1.el7.x86_64 qemu-kvm-ev-2.3.0-29.1.el7.x86_64 qemu-img-ev-2.3.0-29.1.el7.x86_64\nReboot host\n\nSigned-off-by: Rohit Yadav <rohit.yadav@shapeblue.com>","date":"2019-06-10 18:05:26","modifiedFileCount":"25","status":"M","submitter":"Nicolas Vazquez"},{"authorTime":"2019-06-10 18:05:26","codes":[{"authorDate":"2019-06-25 23:23:09","commitOrder":3,"curCode":"    protected void migrate(final VMInstanceVO vm, final long srcHostId, final DeployDestination dest) throws ResourceUnavailableException, ConcurrentOperationException {\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {\n            final List<VolumeVO> volumes = _volsDao.findCreatedByInstance(vm.getId());\n            for (final VolumeVO volume : volumes) {\n                if (!_storagePoolDao.findById(volume.getPoolId()).getScope().equals(ScopeType.ZONE)) {\n                    s_logger.info(\"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                            + dest.getHost().getId());\n                    throw new CloudRuntimeException(\n                            \"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                                    + dest.getHost().getId());\n                }\n            }\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile vmSrc = new VirtualMachineProfileImpl(vm);\n        for (final NicProfile nic : _networkMgr.getNicProfiles(vm)) {\n            vmSrc.addNic(nic);\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        _networkMgr.prepareNicForMigration(profile, dest);\n        volumeMgr.prepareForMigration(profile, dest);\n        profile.setConfigDriveLabel(VmConfigDriveLabel.value());\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        }\n\n        boolean migrated = false;\n        Map<String, DpdkTO> dpdkInterfaceMapping = null;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            dpdkInterfaceMapping = ((PrepareForMigrationAnswer) pfma).getDpdkInterfaceMapping();\n            if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n                mc.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n            }\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    throw new CloudRuntimeException(details);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm, dpdkInterfaceMapping)), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm, dpdkInterfaceMapping)), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            } else {\n                _networkMgr.commitNicForMigration(vmSrc, profile);\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","date":"2019-06-25 23:23:09","endLine":2433,"groupId":"11395","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"migrate","params":"(finalVMInstanceVOvm@finallongsrcHostId@finalDeployDestinationdest)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/79/5705345962a468ec5b626e71be73e2c2815950.src","preCode":"    protected void migrate(final VMInstanceVO vm, final long srcHostId, final DeployDestination dest) throws ResourceUnavailableException, ConcurrentOperationException {\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {\n            final List<VolumeVO> volumes = _volsDao.findCreatedByInstance(vm.getId());\n            for (final VolumeVO volume : volumes) {\n                if (!_storagePoolDao.findById(volume.getPoolId()).getScope().equals(ScopeType.ZONE)) {\n                    s_logger.info(\"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                            + dest.getHost().getId());\n                    throw new CloudRuntimeException(\n                            \"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                                    + dest.getHost().getId());\n                }\n            }\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile vmSrc = new VirtualMachineProfileImpl(vm);\n        for (final NicProfile nic : _networkMgr.getNicProfiles(vm)) {\n            vmSrc.addNic(nic);\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        _networkMgr.prepareNicForMigration(profile, dest);\n        volumeMgr.prepareForMigration(profile, dest);\n        profile.setConfigDriveLabel(VmConfigDriveLabel.value());\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        }\n\n        boolean migrated = false;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    throw new CloudRuntimeException(details);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm)), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm)), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            } else {\n                _networkMgr.commitNicForMigration(vmSrc, profile);\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":2264,"status":"M"},{"authorDate":"2019-06-10 18:05:26","commitOrder":3,"curCode":"    private void orchestrateMigrateForScale(final String vmUuid, final long srcHostId, final DeployDestination dest, final Long oldSvcOfferingId)\n            throws ResourceUnavailableException, ConcurrentOperationException {\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n\n        vm.getServiceOfferingId();\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {\n            s_logger.info(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dstHostId);\n            throw new CloudRuntimeException(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dest.getHost().getId());\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final long vmId = vm.getId();\n        vm = _vmDao.findByUuid(vmUuid);\n        if (vm == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"Unable to find a virtual machine with id \" + vmId);\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);\n        _networkMgr.prepareNicForMigration(profile, dest);\n\n        volumeMgr.prepareForMigration(profile, dest);\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        }\n\n        boolean migrated = false;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    final String msg = \"Unable to migrate due to \" + details;\n                    s_logger.error(msg);\n                    throw new CloudRuntimeException(msg);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                final long newServiceOfferingId = vm.getServiceOfferingId();\n                vm.setServiceOfferingId(oldSvcOfferingId); \r\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n                vm.setServiceOfferingId(newServiceOfferingId);\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","date":"2019-06-10 18:05:26","endLine":3966,"groupId":"13189","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"orchestrateMigrateForScale","params":"(finalStringvmUuid@finallongsrcHostId@finalDeployDestinationdest@finalLongoldSvcOfferingId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/35/4323ecd2f2aace2d9fe3a7ab2da48db54773b7.src","preCode":"    private void orchestrateMigrateForScale(final String vmUuid, final long srcHostId, final DeployDestination dest, final Long oldSvcOfferingId)\n            throws ResourceUnavailableException, ConcurrentOperationException {\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n\n        vm.getServiceOfferingId();\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {\n            s_logger.info(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dstHostId);\n            throw new CloudRuntimeException(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dest.getHost().getId());\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final long vmId = vm.getId();\n        vm = _vmDao.findByUuid(vmUuid);\n        if (vm == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"Unable to find a virtual machine with id \" + vmId);\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);\n        _networkMgr.prepareNicForMigration(profile, dest);\n\n        volumeMgr.prepareForMigration(profile, dest);\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        }\n\n        boolean migrated = false;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    final String msg = \"Unable to migrate due to \" + details;\n                    s_logger.error(msg);\n                    throw new CloudRuntimeException(msg);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                final long newServiceOfferingId = vm.getServiceOfferingId();\n                vm.setServiceOfferingId(oldSvcOfferingId); \r\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n                vm.setServiceOfferingId(newServiceOfferingId);\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":3804,"status":"N"}],"commitId":"a75444a585b952aeb3e984430238cae9e6be4dc5","commitMessage":"@@@KVM: DPDK live migrations (#3365)\n\n* DPDK live migrations\n\n* Remove DPDK created ports if VM migration fails or prepare migration fails\n\n* Rename DPDK classes lowercase\n","date":"2019-06-25 23:23:09","modifiedFileCount":"19","status":"M","submitter":"Nicolas Vazquez"},{"authorTime":"2019-06-10 18:05:26","codes":[{"authorDate":"2020-01-28 13:56:40","commitOrder":4,"curCode":"    protected void migrate(final VMInstanceVO vm, final long srcHostId, final DeployDestination dest) throws ResourceUnavailableException, ConcurrentOperationException {\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {\n            final List<VolumeVO> volumes = _volsDao.findCreatedByInstance(vm.getId());\n            for (final VolumeVO volume : volumes) {\n                if (!_storagePoolDao.findById(volume.getPoolId()).getScope().equals(ScopeType.ZONE)) {\n                    s_logger.info(\"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                            + dest.getHost().getId());\n                    throw new CloudRuntimeException(\n                            \"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                                    + dest.getHost().getId());\n                }\n            }\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile vmSrc = new VirtualMachineProfileImpl(vm);\n        for (final NicProfile nic : _networkMgr.getNicProfiles(vm)) {\n            vmSrc.addNic(nic);\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        _networkMgr.prepareNicForMigration(profile, dest);\n        volumeMgr.prepareForMigration(profile, dest);\n        profile.setConfigDriveLabel(VmConfigDriveLabel.value());\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        } catch (final CloudRuntimeException e2) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            s_logger.info(\"Migration cancelled because \" + e2.getMessage());\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n            try {\n                stateTransitTo(vm, Event.OperationFailed, srcHostId);\n            } catch (final NoTransitionException e3) {\n                s_logger.warn(e3.getMessage());\n            }\n            throw new CloudRuntimeException(\"Migration cancelled because \" + e2.getMessage());\n        }\n\n        boolean migrated = false;\n        Map<String, DpdkTO> dpdkInterfaceMapping = null;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            dpdkInterfaceMapping = ((PrepareForMigrationAnswer) pfma).getDpdkInterfaceMapping();\n            if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n                mc.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n            }\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    throw new CloudRuntimeException(details);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm, dpdkInterfaceMapping)), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm, dpdkInterfaceMapping)), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            } else {\n                _networkMgr.commitNicForMigration(vmSrc, profile);\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","date":"2020-01-28 13:56:40","endLine":2462,"groupId":"4482","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"migrate","params":"(finalVMInstanceVOvm@finallongsrcHostId@finalDeployDestinationdest)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/58/eed4ee679f86efa36f2b9f25b300fa5a652bc8.src","preCode":"    protected void migrate(final VMInstanceVO vm, final long srcHostId, final DeployDestination dest) throws ResourceUnavailableException, ConcurrentOperationException {\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {\n            final List<VolumeVO> volumes = _volsDao.findCreatedByInstance(vm.getId());\n            for (final VolumeVO volume : volumes) {\n                if (!_storagePoolDao.findById(volume.getPoolId()).getScope().equals(ScopeType.ZONE)) {\n                    s_logger.info(\"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                            + dest.getHost().getId());\n                    throw new CloudRuntimeException(\n                            \"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                                    + dest.getHost().getId());\n                }\n            }\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile vmSrc = new VirtualMachineProfileImpl(vm);\n        for (final NicProfile nic : _networkMgr.getNicProfiles(vm)) {\n            vmSrc.addNic(nic);\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        _networkMgr.prepareNicForMigration(profile, dest);\n        volumeMgr.prepareForMigration(profile, dest);\n        profile.setConfigDriveLabel(VmConfigDriveLabel.value());\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        }\n\n        boolean migrated = false;\n        Map<String, DpdkTO> dpdkInterfaceMapping = null;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            dpdkInterfaceMapping = ((PrepareForMigrationAnswer) pfma).getDpdkInterfaceMapping();\n            if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n                mc.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n            }\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    throw new CloudRuntimeException(details);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm, dpdkInterfaceMapping)), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm, dpdkInterfaceMapping)), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            } else {\n                _networkMgr.commitNicForMigration(vmSrc, profile);\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":2282,"status":"M"},{"authorDate":"2019-06-10 18:05:26","commitOrder":4,"curCode":"    private void orchestrateMigrateForScale(final String vmUuid, final long srcHostId, final DeployDestination dest, final Long oldSvcOfferingId)\n            throws ResourceUnavailableException, ConcurrentOperationException {\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n\n        vm.getServiceOfferingId();\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {\n            s_logger.info(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dstHostId);\n            throw new CloudRuntimeException(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dest.getHost().getId());\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final long vmId = vm.getId();\n        vm = _vmDao.findByUuid(vmUuid);\n        if (vm == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"Unable to find a virtual machine with id \" + vmId);\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);\n        _networkMgr.prepareNicForMigration(profile, dest);\n\n        volumeMgr.prepareForMigration(profile, dest);\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        }\n\n        boolean migrated = false;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    final String msg = \"Unable to migrate due to \" + details;\n                    s_logger.error(msg);\n                    throw new CloudRuntimeException(msg);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                final long newServiceOfferingId = vm.getServiceOfferingId();\n                vm.setServiceOfferingId(oldSvcOfferingId); \r\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n                vm.setServiceOfferingId(newServiceOfferingId);\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","date":"2019-06-10 18:05:26","endLine":3966,"groupId":"13189","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"orchestrateMigrateForScale","params":"(finalStringvmUuid@finallongsrcHostId@finalDeployDestinationdest@finalLongoldSvcOfferingId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/35/4323ecd2f2aace2d9fe3a7ab2da48db54773b7.src","preCode":"    private void orchestrateMigrateForScale(final String vmUuid, final long srcHostId, final DeployDestination dest, final Long oldSvcOfferingId)\n            throws ResourceUnavailableException, ConcurrentOperationException {\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n\n        vm.getServiceOfferingId();\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {\n            s_logger.info(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dstHostId);\n            throw new CloudRuntimeException(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dest.getHost().getId());\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final long vmId = vm.getId();\n        vm = _vmDao.findByUuid(vmUuid);\n        if (vm == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"Unable to find a virtual machine with id \" + vmId);\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);\n        _networkMgr.prepareNicForMigration(profile, dest);\n\n        volumeMgr.prepareForMigration(profile, dest);\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        }\n\n        boolean migrated = false;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    final String msg = \"Unable to migrate due to \" + details;\n                    s_logger.error(msg);\n                    throw new CloudRuntimeException(msg);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                final long newServiceOfferingId = vm.getServiceOfferingId();\n                vm.setServiceOfferingId(oldSvcOfferingId); \r\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n                vm.setServiceOfferingId(newServiceOfferingId);\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":3804,"status":"N"}],"commitId":"0cb2db6e1de985f4e2b3923a26fe21c6e86cacbe","commitMessage":"@@@Merge remote-tracking branch 'origin/4.13'\n","date":"2020-01-28 13:56:40","modifiedFileCount":"4","status":"M","submitter":"Rohit Yadav"},{"authorTime":"2020-07-01 11:14:11","codes":[{"authorDate":"2020-07-01 11:14:11","commitOrder":5,"curCode":"    protected void migrate(final VMInstanceVO vm, final long srcHostId, final DeployDestination dest) throws ResourceUnavailableException, ConcurrentOperationException {\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n        final UserVmVO userVm = _userVmDao.findById(vm.getId());\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {\n            final List<VolumeVO> volumes = _volsDao.findCreatedByInstance(vm.getId());\n            for (final VolumeVO volume : volumes) {\n                if (!_storagePoolDao.findById(volume.getPoolId()).getScope().equals(ScopeType.ZONE)) {\n                    s_logger.info(\"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                            + dest.getHost().getId());\n                    throw new CloudRuntimeException(\n                            \"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                                    + dest.getHost().getId());\n                }\n            }\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile vmSrc = new VirtualMachineProfileImpl(vm);\n        for (final NicProfile nic : _networkMgr.getNicProfiles(vm)) {\n            vmSrc.addNic(nic);\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        _networkMgr.prepareNicForMigration(profile, dest);\n        volumeMgr.prepareForMigration(profile, dest);\n        profile.setConfigDriveLabel(VmConfigDriveLabel.value());\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        } catch (final CloudRuntimeException e2) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            s_logger.info(\"Migration cancelled because \" + e2.getMessage());\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n            try {\n                stateTransitTo(vm, Event.OperationFailed, srcHostId);\n            } catch (final NoTransitionException e3) {\n                s_logger.warn(e3.getMessage());\n            }\n            throw new CloudRuntimeException(\"Migration cancelled because \" + e2.getMessage());\n        }\n\n        boolean migrated = false;\n        Map<String, DpdkTO> dpdkInterfaceMapping = null;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            dpdkInterfaceMapping = ((PrepareForMigrationAnswer) pfma).getDpdkInterfaceMapping();\n            if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n                mc.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n            }\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    throw new CloudRuntimeException(details);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm, dpdkInterfaceMapping)), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm, dpdkInterfaceMapping)), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n                _networkMgr.setHypervisorHostname(profile, dest, false);\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            } else {\n                _networkMgr.commitNicForMigration(vmSrc, profile);\n                _networkMgr.setHypervisorHostname(profile, dest, true);\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","date":"2020-07-01 11:14:11","endLine":2613,"groupId":"4482","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"migrate","params":"(finalVMInstanceVOvm@finallongsrcHostId@finalDeployDestinationdest)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/0a/e249c584f88fec5be799063a20fa6c1902e9ac.src","preCode":"    protected void migrate(final VMInstanceVO vm, final long srcHostId, final DeployDestination dest) throws ResourceUnavailableException, ConcurrentOperationException {\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {\n            final List<VolumeVO> volumes = _volsDao.findCreatedByInstance(vm.getId());\n            for (final VolumeVO volume : volumes) {\n                if (!_storagePoolDao.findById(volume.getPoolId()).getScope().equals(ScopeType.ZONE)) {\n                    s_logger.info(\"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                            + dest.getHost().getId());\n                    throw new CloudRuntimeException(\n                            \"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                                    + dest.getHost().getId());\n                }\n            }\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile vmSrc = new VirtualMachineProfileImpl(vm);\n        for (final NicProfile nic : _networkMgr.getNicProfiles(vm)) {\n            vmSrc.addNic(nic);\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        _networkMgr.prepareNicForMigration(profile, dest);\n        volumeMgr.prepareForMigration(profile, dest);\n        profile.setConfigDriveLabel(VmConfigDriveLabel.value());\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        } catch (final CloudRuntimeException e2) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            s_logger.info(\"Migration cancelled because \" + e2.getMessage());\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n            try {\n                stateTransitTo(vm, Event.OperationFailed, srcHostId);\n            } catch (final NoTransitionException e3) {\n                s_logger.warn(e3.getMessage());\n            }\n            throw new CloudRuntimeException(\"Migration cancelled because \" + e2.getMessage());\n        }\n\n        boolean migrated = false;\n        Map<String, DpdkTO> dpdkInterfaceMapping = null;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            dpdkInterfaceMapping = ((PrepareForMigrationAnswer) pfma).getDpdkInterfaceMapping();\n            if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n                mc.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n            }\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    throw new CloudRuntimeException(details);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm, dpdkInterfaceMapping)), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm, dpdkInterfaceMapping)), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            } else {\n                _networkMgr.commitNicForMigration(vmSrc, profile);\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":2433,"status":"M"},{"authorDate":"2020-07-01 11:14:11","commitOrder":5,"curCode":"    private void orchestrateMigrateForScale(final String vmUuid, final long srcHostId, final DeployDestination dest, final Long oldSvcOfferingId)\n            throws ResourceUnavailableException, ConcurrentOperationException {\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n\n        vm.getServiceOfferingId();\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {\n            s_logger.info(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dstHostId);\n            throw new CloudRuntimeException(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dest.getHost().getId());\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final long vmId = vm.getId();\n        vm = _vmDao.findByUuid(vmUuid);\n        if (vm == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"Unable to find a virtual machine with id \" + vmId);\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);\n        _networkMgr.prepareNicForMigration(profile, dest);\n\n        volumeMgr.prepareForMigration(profile, dest);\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        }\n\n        boolean migrated = false;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    final String msg = \"Unable to migrate due to \" + details;\n                    s_logger.error(msg);\n                    throw new CloudRuntimeException(msg);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                final long newServiceOfferingId = vm.getServiceOfferingId();\n                vm.setServiceOfferingId(oldSvcOfferingId); \r\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n                vm.setServiceOfferingId(newServiceOfferingId);\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n                _networkMgr.setHypervisorHostname(profile, dest, false);\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            } else {\n                _networkMgr.setHypervisorHostname(profile, dest, true);\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","date":"2020-07-01 11:14:11","endLine":4217,"groupId":"13189","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"orchestrateMigrateForScale","params":"(finalStringvmUuid@finallongsrcHostId@finalDeployDestinationdest@finalLongoldSvcOfferingId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/0a/e249c584f88fec5be799063a20fa6c1902e9ac.src","preCode":"    private void orchestrateMigrateForScale(final String vmUuid, final long srcHostId, final DeployDestination dest, final Long oldSvcOfferingId)\n            throws ResourceUnavailableException, ConcurrentOperationException {\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n\n        vm.getServiceOfferingId();\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {\n            s_logger.info(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dstHostId);\n            throw new CloudRuntimeException(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dest.getHost().getId());\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final long vmId = vm.getId();\n        vm = _vmDao.findByUuid(vmUuid);\n        if (vm == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"Unable to find a virtual machine with id \" + vmId);\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);\n        _networkMgr.prepareNicForMigration(profile, dest);\n\n        volumeMgr.prepareForMigration(profile, dest);\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        }\n\n        boolean migrated = false;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    final String msg = \"Unable to migrate due to \" + details;\n                    s_logger.error(msg);\n                    throw new CloudRuntimeException(msg);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                final long newServiceOfferingId = vm.getServiceOfferingId();\n                vm.setServiceOfferingId(oldSvcOfferingId); \r\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n                vm.setServiceOfferingId(newServiceOfferingId);\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":4053,"status":"M"}],"commitId":"a73712ec4ea0deae58d0b43edcbe9ca5e8f33fd4","commitMessage":"@@@server: Enable sending hypervior host name via metadata - VR and Config Drive (#3976)\n\nEnable sending hypervisor host details via metadata for VR and Config Drive providers\n\nCo-authored-by: Pearl Dsilva <pearl.dsilva@shapeblue.com>","date":"2020-07-01 11:14:11","modifiedFileCount":"23","status":"M","submitter":"Pearl Dsilva"},{"authorTime":"2020-07-01 11:14:11","codes":[{"authorDate":"2020-10-26 21:24:14","commitOrder":6,"curCode":"    protected void migrate(final VMInstanceVO vm, final long srcHostId, final DeployDestination dest) throws ResourceUnavailableException, ConcurrentOperationException {\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n        final UserVmVO userVm = _userVmDao.findById(vm.getId());\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId() && vm.getHypervisorType() != HypervisorType.VMware) {\n            final List<VolumeVO> volumes = _volsDao.findCreatedByInstance(vm.getId());\n            for (final VolumeVO volume : volumes) {\n                if (!_storagePoolDao.findById(volume.getPoolId()).getScope().equals(ScopeType.ZONE)) {\n                    s_logger.info(\"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                            + dest.getHost().getId());\n                    throw new CloudRuntimeException(\n                            \"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                                    + dest.getHost().getId());\n                }\n            }\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile vmSrc = new VirtualMachineProfileImpl(vm);\n        for (final NicProfile nic : _networkMgr.getNicProfiles(vm)) {\n            vmSrc.addNic(nic);\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        _networkMgr.prepareNicForMigration(profile, dest);\n        volumeMgr.prepareForMigration(profile, dest);\n        profile.setConfigDriveLabel(VmConfigDriveLabel.value());\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        } catch (final CloudRuntimeException e2) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            s_logger.info(\"Migration cancelled because \" + e2.getMessage());\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n            try {\n                stateTransitTo(vm, Event.OperationFailed, srcHostId);\n            } catch (final NoTransitionException e3) {\n                s_logger.warn(e3.getMessage());\n            }\n            throw new CloudRuntimeException(\"Migration cancelled because \" + e2.getMessage());\n        }\n\n        boolean migrated = false;\n        Map<String, DpdkTO> dpdkInterfaceMapping = null;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            dpdkInterfaceMapping = ((PrepareForMigrationAnswer) pfma).getDpdkInterfaceMapping();\n            if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n                mc.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n            }\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    throw new CloudRuntimeException(details);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm, dpdkInterfaceMapping)), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm, dpdkInterfaceMapping)), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n                _networkMgr.setHypervisorHostname(profile, dest, false);\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            } else {\n                _networkMgr.commitNicForMigration(vmSrc, profile);\n                _networkMgr.setHypervisorHostname(profile, dest, true);\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","date":"2020-10-26 21:24:14","endLine":2657,"groupId":"4482","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"migrate","params":"(finalVMInstanceVOvm@finallongsrcHostId@finalDeployDestinationdest)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/8e/9ec450b1ed7b3b97645bd472313fd926bfc998.src","preCode":"    protected void migrate(final VMInstanceVO vm, final long srcHostId, final DeployDestination dest) throws ResourceUnavailableException, ConcurrentOperationException {\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n        final UserVmVO userVm = _userVmDao.findById(vm.getId());\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {\n            final List<VolumeVO> volumes = _volsDao.findCreatedByInstance(vm.getId());\n            for (final VolumeVO volume : volumes) {\n                if (!_storagePoolDao.findById(volume.getPoolId()).getScope().equals(ScopeType.ZONE)) {\n                    s_logger.info(\"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                            + dest.getHost().getId());\n                    throw new CloudRuntimeException(\n                            \"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                                    + dest.getHost().getId());\n                }\n            }\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile vmSrc = new VirtualMachineProfileImpl(vm);\n        for (final NicProfile nic : _networkMgr.getNicProfiles(vm)) {\n            vmSrc.addNic(nic);\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        _networkMgr.prepareNicForMigration(profile, dest);\n        volumeMgr.prepareForMigration(profile, dest);\n        profile.setConfigDriveLabel(VmConfigDriveLabel.value());\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        } catch (final CloudRuntimeException e2) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            s_logger.info(\"Migration cancelled because \" + e2.getMessage());\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n            try {\n                stateTransitTo(vm, Event.OperationFailed, srcHostId);\n            } catch (final NoTransitionException e3) {\n                s_logger.warn(e3.getMessage());\n            }\n            throw new CloudRuntimeException(\"Migration cancelled because \" + e2.getMessage());\n        }\n\n        boolean migrated = false;\n        Map<String, DpdkTO> dpdkInterfaceMapping = null;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            dpdkInterfaceMapping = ((PrepareForMigrationAnswer) pfma).getDpdkInterfaceMapping();\n            if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n                mc.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n            }\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    throw new CloudRuntimeException(details);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm, dpdkInterfaceMapping)), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm, dpdkInterfaceMapping)), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n                _networkMgr.setHypervisorHostname(profile, dest, false);\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            } else {\n                _networkMgr.commitNicForMigration(vmSrc, profile);\n                _networkMgr.setHypervisorHostname(profile, dest, true);\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":2477,"status":"M"},{"authorDate":"2020-07-01 11:14:11","commitOrder":6,"curCode":"    private void orchestrateMigrateForScale(final String vmUuid, final long srcHostId, final DeployDestination dest, final Long oldSvcOfferingId)\n            throws ResourceUnavailableException, ConcurrentOperationException {\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n\n        vm.getServiceOfferingId();\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {\n            s_logger.info(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dstHostId);\n            throw new CloudRuntimeException(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dest.getHost().getId());\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final long vmId = vm.getId();\n        vm = _vmDao.findByUuid(vmUuid);\n        if (vm == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"Unable to find a virtual machine with id \" + vmId);\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);\n        _networkMgr.prepareNicForMigration(profile, dest);\n\n        volumeMgr.prepareForMigration(profile, dest);\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        }\n\n        boolean migrated = false;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    final String msg = \"Unable to migrate due to \" + details;\n                    s_logger.error(msg);\n                    throw new CloudRuntimeException(msg);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                final long newServiceOfferingId = vm.getServiceOfferingId();\n                vm.setServiceOfferingId(oldSvcOfferingId); \r\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n                vm.setServiceOfferingId(newServiceOfferingId);\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n                _networkMgr.setHypervisorHostname(profile, dest, false);\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            } else {\n                _networkMgr.setHypervisorHostname(profile, dest, true);\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","date":"2020-07-01 11:14:11","endLine":4217,"groupId":"13189","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"orchestrateMigrateForScale","params":"(finalStringvmUuid@finallongsrcHostId@finalDeployDestinationdest@finalLongoldSvcOfferingId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/0a/e249c584f88fec5be799063a20fa6c1902e9ac.src","preCode":"    private void orchestrateMigrateForScale(final String vmUuid, final long srcHostId, final DeployDestination dest, final Long oldSvcOfferingId)\n            throws ResourceUnavailableException, ConcurrentOperationException {\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n\n        vm.getServiceOfferingId();\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {\n            s_logger.info(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dstHostId);\n            throw new CloudRuntimeException(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dest.getHost().getId());\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final long vmId = vm.getId();\n        vm = _vmDao.findByUuid(vmUuid);\n        if (vm == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"Unable to find a virtual machine with id \" + vmId);\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);\n        _networkMgr.prepareNicForMigration(profile, dest);\n\n        volumeMgr.prepareForMigration(profile, dest);\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        }\n\n        boolean migrated = false;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    final String msg = \"Unable to migrate due to \" + details;\n                    s_logger.error(msg);\n                    throw new CloudRuntimeException(msg);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                final long newServiceOfferingId = vm.getServiceOfferingId();\n                vm.setServiceOfferingId(oldSvcOfferingId); \r\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n                vm.setServiceOfferingId(newServiceOfferingId);\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n                _networkMgr.setHypervisorHostname(profile, dest, false);\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            } else {\n                _networkMgr.setHypervisorHostname(profile, dest, true);\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":4053,"status":"N"}],"commitId":"1a75872cd484dd387552bae58996a56679fdb51e","commitMessage":"@@@Merge pull request #4307 from shapeblue/ovfprops-and-vsphere-adv-together\n\n[VMware] vSphere advanced capabilities and Full OVF properties support","date":"2020-10-26 21:24:14","modifiedFileCount":"173","status":"M","submitter":"Boris Stoyanov - a.k.a Bobby"},{"authorTime":"2020-07-01 11:14:11","codes":[{"authorDate":"2021-02-24 17:28:33","commitOrder":7,"curCode":"    protected void migrate(final VMInstanceVO vm, final long srcHostId, final DeployDestination dest) throws ResourceUnavailableException, ConcurrentOperationException {\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n        final UserVmVO userVm = _userVmDao.findById(vm.getId());\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId() && vm.getHypervisorType() != HypervisorType.VMware) {\n            final List<VolumeVO> volumes = _volsDao.findCreatedByInstance(vm.getId());\n            for (final VolumeVO volume : volumes) {\n                if (!_storagePoolDao.findById(volume.getPoolId()).getScope().equals(ScopeType.ZONE)) {\n                    s_logger.info(\"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                            + dest.getHost().getId());\n                    throw new CloudRuntimeException(\n                            \"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                                    + dest.getHost().getId());\n                }\n            }\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile vmSrc = new VirtualMachineProfileImpl(vm);\n        vmSrc.setHost(fromHost);\n        for (final NicProfile nic : _networkMgr.getNicProfiles(vm)) {\n            vmSrc.addNic(nic);\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        profile.setHost(dest.getHost());\n\n        _networkMgr.prepareNicForMigration(profile, dest);\n        volumeMgr.prepareForMigration(profile, dest);\n        profile.setConfigDriveLabel(VmConfigDriveLabel.value());\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                volumeMgr.release(vm.getId(), dstHostId);\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                if (vm != null) {\n                    volumeMgr.release(vm.getId(), dstHostId);\n                }\n\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            volumeMgr.release(vm.getId(), dstHostId);\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        } catch (final CloudRuntimeException e2) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            volumeMgr.release(vm.getId(), dstHostId);\n            s_logger.info(\"Migration cancelled because \" + e2.getMessage());\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n            try {\n                stateTransitTo(vm, Event.OperationFailed, srcHostId);\n            } catch (final NoTransitionException e3) {\n                s_logger.warn(e3.getMessage());\n            }\n            throw new CloudRuntimeException(\"Migration cancelled because \" + e2.getMessage());\n        }\n\n        boolean migrated = false;\n        Map<String, DpdkTO> dpdkInterfaceMapping = null;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            dpdkInterfaceMapping = ((PrepareForMigrationAnswer) pfma).getDpdkInterfaceMapping();\n            if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n                mc.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n            }\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    throw new CloudRuntimeException(details);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm, dpdkInterfaceMapping)), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                volumeMgr.release(vm.getId(), dstHostId);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm, dpdkInterfaceMapping)), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n                _networkMgr.setHypervisorHostname(profile, dest, false);\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            } else {\n                _networkMgr.commitNicForMigration(vmSrc, profile);\n                volumeMgr.release(vm.getId(), srcHostId);\n                _networkMgr.setHypervisorHostname(profile, dest, true);\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","date":"2021-02-24 17:28:33","endLine":2762,"groupId":"13175","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"migrate","params":"(finalVMInstanceVOvm@finallongsrcHostId@finalDeployDestinationdest)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/df/ec0b1de77881a5a59a098404ec19de1ccca48e.src","preCode":"    protected void migrate(final VMInstanceVO vm, final long srcHostId, final DeployDestination dest) throws ResourceUnavailableException, ConcurrentOperationException {\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n        final UserVmVO userVm = _userVmDao.findById(vm.getId());\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId() && vm.getHypervisorType() != HypervisorType.VMware) {\n            final List<VolumeVO> volumes = _volsDao.findCreatedByInstance(vm.getId());\n            for (final VolumeVO volume : volumes) {\n                if (!_storagePoolDao.findById(volume.getPoolId()).getScope().equals(ScopeType.ZONE)) {\n                    s_logger.info(\"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                            + dest.getHost().getId());\n                    throw new CloudRuntimeException(\n                            \"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                                    + dest.getHost().getId());\n                }\n            }\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile vmSrc = new VirtualMachineProfileImpl(vm);\n        for (final NicProfile nic : _networkMgr.getNicProfiles(vm)) {\n            vmSrc.addNic(nic);\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        _networkMgr.prepareNicForMigration(profile, dest);\n        volumeMgr.prepareForMigration(profile, dest);\n        profile.setConfigDriveLabel(VmConfigDriveLabel.value());\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        } catch (final CloudRuntimeException e2) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            s_logger.info(\"Migration cancelled because \" + e2.getMessage());\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n            try {\n                stateTransitTo(vm, Event.OperationFailed, srcHostId);\n            } catch (final NoTransitionException e3) {\n                s_logger.warn(e3.getMessage());\n            }\n            throw new CloudRuntimeException(\"Migration cancelled because \" + e2.getMessage());\n        }\n\n        boolean migrated = false;\n        Map<String, DpdkTO> dpdkInterfaceMapping = null;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            dpdkInterfaceMapping = ((PrepareForMigrationAnswer) pfma).getDpdkInterfaceMapping();\n            if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n                mc.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n            }\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    throw new CloudRuntimeException(details);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm, dpdkInterfaceMapping)), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm, dpdkInterfaceMapping)), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n                _networkMgr.setHypervisorHostname(profile, dest, false);\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            } else {\n                _networkMgr.commitNicForMigration(vmSrc, profile);\n                _networkMgr.setHypervisorHostname(profile, dest, true);\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":2570,"status":"M"},{"authorDate":"2020-07-01 11:14:11","commitOrder":7,"curCode":"    private void orchestrateMigrateForScale(final String vmUuid, final long srcHostId, final DeployDestination dest, final Long oldSvcOfferingId)\n            throws ResourceUnavailableException, ConcurrentOperationException {\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n\n        vm.getServiceOfferingId();\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {\n            s_logger.info(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dstHostId);\n            throw new CloudRuntimeException(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dest.getHost().getId());\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final long vmId = vm.getId();\n        vm = _vmDao.findByUuid(vmUuid);\n        if (vm == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"Unable to find a virtual machine with id \" + vmId);\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);\n        _networkMgr.prepareNicForMigration(profile, dest);\n\n        volumeMgr.prepareForMigration(profile, dest);\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        }\n\n        boolean migrated = false;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    final String msg = \"Unable to migrate due to \" + details;\n                    s_logger.error(msg);\n                    throw new CloudRuntimeException(msg);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                final long newServiceOfferingId = vm.getServiceOfferingId();\n                vm.setServiceOfferingId(oldSvcOfferingId); \r\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n                vm.setServiceOfferingId(newServiceOfferingId);\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n                _networkMgr.setHypervisorHostname(profile, dest, false);\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            } else {\n                _networkMgr.setHypervisorHostname(profile, dest, true);\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","date":"2020-07-01 11:14:11","endLine":4217,"groupId":"13189","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"orchestrateMigrateForScale","params":"(finalStringvmUuid@finallongsrcHostId@finalDeployDestinationdest@finalLongoldSvcOfferingId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/0a/e249c584f88fec5be799063a20fa6c1902e9ac.src","preCode":"    private void orchestrateMigrateForScale(final String vmUuid, final long srcHostId, final DeployDestination dest, final Long oldSvcOfferingId)\n            throws ResourceUnavailableException, ConcurrentOperationException {\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n\n        vm.getServiceOfferingId();\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {\n            s_logger.info(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dstHostId);\n            throw new CloudRuntimeException(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dest.getHost().getId());\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final long vmId = vm.getId();\n        vm = _vmDao.findByUuid(vmUuid);\n        if (vm == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"Unable to find a virtual machine with id \" + vmId);\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);\n        _networkMgr.prepareNicForMigration(profile, dest);\n\n        volumeMgr.prepareForMigration(profile, dest);\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        }\n\n        boolean migrated = false;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    final String msg = \"Unable to migrate due to \" + details;\n                    s_logger.error(msg);\n                    throw new CloudRuntimeException(msg);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                final long newServiceOfferingId = vm.getServiceOfferingId();\n                vm.setServiceOfferingId(oldSvcOfferingId); \r\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n                vm.setServiceOfferingId(newServiceOfferingId);\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n                _networkMgr.setHypervisorHostname(profile, dest, false);\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            } else {\n                _networkMgr.setHypervisorHostname(profile, dest, true);\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":4053,"status":"N"}],"commitId":"eba186aa40f16911c019bf06cd33d7d0cbbc303b","commitMessage":"@@@storage: New Dell EMC PowerFlex Plugin (formerly ScaleIO.  VxFlexOS) (#4304)\n\nAdded support for PowerFlex/ScaleIO (v3.5 onwards) storage pool as a primary storage in CloudStack (for KVM hypervisor) and enabled VM/Volume operations on that pool (using pool tag).\nPlease find more details in the FS here:\nhttps://cwiki.apache.org/confluence/x/cDl4CQ\n\nDocumentation PR: apache/cloudstack-documentation#169\n\nThis enables support for PowerFlex/ScaleIO (v3.5 onwards) storage pool as a primary storage in CloudStack\n\nOther improvements addressed in addition to PowerFlex/ScaleIO support:\n\n- Added support for config drives in host cache for KVM\n\t=> Changed configuration \"vm.configdrive.primarypool.enabled\" scope from Global to Zone level\n\t=> Introduced new zone level configuration \"vm.configdrive.force.host.cache.use\" (default: false) to force host cache for config drives\n\t=> Introduced new zone level configuration \"vm.configdrive.use.host.cache.on.unsupported.pool\" (default: true) to use host cache for config drives when storage pool doesn't support config drive\n\t=> Added new parameter \"host.cache.location\" (default: /var/cache/cloud) in KVM agent.properties for specifying the host cache path and create config drives on the \"/config\" directory on the host cache path\n\t=> Maintain the config drive location and use it when required on any config drive operation (migrate.  delete)\n\n- Detect virtual size from the template URL while registering direct download qcow2 (of KVM hypervisor) templates\n\n- Updated full deployment destination for preparing the network(s) on VM start\n\n- Propagate the direct download certificates uploaded to the newly added KVM hosts\n\n- Discover the template size for direct download templates using any available host from the zones specified on template registration\n\t=> When zones are not specified while registering template.  template size discovery is performed using any available host.  which is picked up randomly from one of the available zones\n\n- Release the VM resources when VM is sync-ed to Stopped state on PowerReportMissing (after graceful period)\n\n- Retry VM deployment/start when the host cannot grant access to volume/template\n\n- Mark never-used or downloaded templates as Destroyed on deletion.  without sending any DeleteCommand\n\t=> Do not trigger any DeleteCommand for never-used or downloaded templates as these doesn't exist and cannot be deleted from the datastore\n\n- Check the router filesystem is writable or not.  before performing health checks\n\t=> Introduce a new test \"filesystem.writable.test\" to check the filesystem is writable or not\n\t=> The router health checks keeps the config info at \"/var/cache/cloud\" and updates the monitor results at \"/root\" for health checks.  both are different partitions. So.  test at both the locations.\n\t=> Added new script: \"filesystem_writable_check.py\" at /opt/cloud/bin/ to check the filesystem is writable or not\n\n- Fixed NPE issue.  template is null for DATA disks. Copy template to target storage for ROOT disk (with template id).  skip DATA disk(s)\n\n* Addressed some issues for few operations on PowerFlex storage pool.\n\n- Updated migration volume operation to sync the status and wait for migration to complete.\n\n- Updated VM Snapshot naming.  for uniqueness in ScaleIO volume name when more than one volume exists in the VM.\n\n- Added sync lock while spooling managed storage template before volume creation from the template (non-direct download).\n\n- Updated resize volume error message string.\n\n- Blocked the below operations on PowerFlex storage pool:\n  -> Extract Volume\n  -> Create Snapshot for VMSnapshot\n\n* Added the PowerFlex/ScaleIO client connection pool to manage the ScaleIO gateway clients.  which uses a single gateway client per Powerflex/ScaleIO storage pool and renews it when the session token expires.\n\n- The token is valid for 8 hours from the time it was created.  unless there has been no activity for 10 minutes.\n  Reference: https://cpsdocs.dellemc.com/bundle/PF_REST_API_RG/page/GUID-92430F19-9F44-42B6-B898-87D5307AE59B.html\n\nOther fixes included:\n\n- Fail the VM deployment when the host specified in the deployVirtualMachine cmd is not in the right state (i.e. either Resource State is not Enabled or Status is not Up)\n\n- Use the physical file size of the template to check the free space availability on the host.  while downloading the direct download templates.\n\n- Perform basic tests (for connectivity and file system) on router before updating the health check config data\n\t=> Validate the basic tests (connectivity and file system check) on router\n\t=> Cleanup the health check results when router is destroyed\n\n* Updated PowerFlex/ScaleIO storage plugin version to 4.16.0.0\n\n* UI Changes to support storage plugin for PowerFlex/ScaleIO storage pool.\n- PowerFlex pool URL generated from the UI inputs(Gateway.  Username.  Password.  Storage Pool) when adding \"PowerFlex\" Primary Storage\n- Updated protocol to \"custom\" for PowerFlex provider\n- Allow VM Snapshot for stopped VM on KVM hypervisor and PowerFlex/ScaleIO storage pool\n\nand Minor improvements in PowerFlex/ScaleIO storage plugin code\n\n* Added support for PowerFlex/ScaleIO volume migration across different PowerFlex storage instances.\n\n- findStoragePoolsForMigration API returns PowerFlex pool(s) of different instance as suitable pool(s).  for volume(s) on PowerFlex storage pool.\n- Volume(s) with snapshots are not allowed to migrate to different PowerFlex instance.\n- Volume(s) of running VM are not allowed to migrate to other PowerFlex storage pools.\n- Volume migration from PowerFlex pool to Non-PowerFlex pool.  and vice versa are not supported.\n\n* Fixed change service offering smoke tests in test_service_offerings.py.  test_vm_snapshots.py\n\n* Added the PowerFlex/ScaleIO volume/snapshot name to the paths of respective CloudStack resources (Templates.  Volumes.  Snapshots and VM Snapshots)\n\n* Added new response parameter ?supportsStorageSnapshot? (true/false) to volume response.  and Updated UI to hide the async backup option while taking snapshot for volume(s) with storage snapshot support.\n\n* Fix to remove the duplicate zone wide pools listed while finding storage pools for migration\n\n* Updated PowerFlex/ScaleIO volume migration checks and rollback migration on failure\n\n* Fixed the PowerFlex/ScaleIO volume name inconsistency issue in the volume path after migration.  due to rename failure","date":"2021-02-24 17:28:33","modifiedFileCount":"112","status":"M","submitter":"sureshanaparti"},{"authorTime":"2021-04-05 17:07:11","codes":[{"authorDate":"2021-04-05 17:07:11","commitOrder":8,"curCode":"    protected void migrate(final VMInstanceVO vm, final long srcHostId, final DeployDestination dest) throws ResourceUnavailableException, ConcurrentOperationException {\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n        final UserVmVO userVm = _userVmDao.findById(vm.getId());\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId() && vm.getHypervisorType() != HypervisorType.VMware) {\n            final List<VolumeVO> volumes = _volsDao.findCreatedByInstance(vm.getId());\n            for (final VolumeVO volume : volumes) {\n                if (!_storagePoolDao.findById(volume.getPoolId()).getScope().equals(ScopeType.ZONE)) {\n                    s_logger.info(\"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                            + dest.getHost().getId());\n                    throw new CloudRuntimeException(\n                            \"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                                    + dest.getHost().getId());\n                }\n            }\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile vmSrc = new VirtualMachineProfileImpl(vm);\n        vmSrc.setHost(fromHost);\n        for (final NicProfile nic : _networkMgr.getNicProfiles(vm)) {\n            vmSrc.addNic(nic);\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        profile.setHost(dest.getHost());\n\n        _networkMgr.prepareNicForMigration(profile, dest);\n        volumeMgr.prepareForMigration(profile, dest);\n        profile.setConfigDriveLabel(VmConfigDriveLabel.value());\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                volumeMgr.release(vm.getId(), dstHostId);\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                if (vm != null) {\n                    volumeMgr.release(vm.getId(), dstHostId);\n                }\n\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            volumeMgr.release(vm.getId(), dstHostId);\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        } catch (final CloudRuntimeException e2) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            volumeMgr.release(vm.getId(), dstHostId);\n            s_logger.info(\"Migration cancelled because \" + e2.getMessage());\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n            try {\n                stateTransitTo(vm, Event.OperationFailed, srcHostId);\n            } catch (final NoTransitionException e3) {\n                s_logger.warn(e3.getMessage());\n            }\n            throw new CloudRuntimeException(\"Migration cancelled because \" + e2.getMessage());\n        }\n\n        boolean migrated = false;\n        Map<String, DpdkTO> dpdkInterfaceMapping = null;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            Map<String, Boolean> vlanToPersistenceMap = getVlanToPersistenceMapForVM(vm.getId());\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n            if (MapUtils.isNotEmpty(vlanToPersistenceMap)) {\n                mc.setVlanToPersistenceMap(vlanToPersistenceMap);\n            }\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            dpdkInterfaceMapping = ((PrepareForMigrationAnswer) pfma).getDpdkInterfaceMapping();\n            if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n                mc.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n            }\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    throw new CloudRuntimeException(details);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm, dpdkInterfaceMapping)), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                volumeMgr.release(vm.getId(), dstHostId);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm, dpdkInterfaceMapping)), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n                _networkMgr.setHypervisorHostname(profile, dest, false);\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            } else {\n                _networkMgr.commitNicForMigration(vmSrc, profile);\n                volumeMgr.release(vm.getId(), srcHostId);\n                _networkMgr.setHypervisorHostname(profile, dest, true);\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","date":"2021-04-05 17:07:11","endLine":2849,"groupId":"158","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"migrate","params":"(finalVMInstanceVOvm@finallongsrcHostId@finalDeployDestinationdest)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/1e/92c3ed5be7e6ac76091149b4cc4fcfba874141.src","preCode":"    protected void migrate(final VMInstanceVO vm, final long srcHostId, final DeployDestination dest) throws ResourceUnavailableException, ConcurrentOperationException {\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n        final UserVmVO userVm = _userVmDao.findById(vm.getId());\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId() && vm.getHypervisorType() != HypervisorType.VMware) {\n            final List<VolumeVO> volumes = _volsDao.findCreatedByInstance(vm.getId());\n            for (final VolumeVO volume : volumes) {\n                if (!_storagePoolDao.findById(volume.getPoolId()).getScope().equals(ScopeType.ZONE)) {\n                    s_logger.info(\"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                            + dest.getHost().getId());\n                    throw new CloudRuntimeException(\n                            \"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                                    + dest.getHost().getId());\n                }\n            }\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile vmSrc = new VirtualMachineProfileImpl(vm);\n        vmSrc.setHost(fromHost);\n        for (final NicProfile nic : _networkMgr.getNicProfiles(vm)) {\n            vmSrc.addNic(nic);\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        profile.setHost(dest.getHost());\n\n        _networkMgr.prepareNicForMigration(profile, dest);\n        volumeMgr.prepareForMigration(profile, dest);\n        profile.setConfigDriveLabel(VmConfigDriveLabel.value());\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                volumeMgr.release(vm.getId(), dstHostId);\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                if (vm != null) {\n                    volumeMgr.release(vm.getId(), dstHostId);\n                }\n\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            volumeMgr.release(vm.getId(), dstHostId);\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        } catch (final CloudRuntimeException e2) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            volumeMgr.release(vm.getId(), dstHostId);\n            s_logger.info(\"Migration cancelled because \" + e2.getMessage());\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n            try {\n                stateTransitTo(vm, Event.OperationFailed, srcHostId);\n            } catch (final NoTransitionException e3) {\n                s_logger.warn(e3.getMessage());\n            }\n            throw new CloudRuntimeException(\"Migration cancelled because \" + e2.getMessage());\n        }\n\n        boolean migrated = false;\n        Map<String, DpdkTO> dpdkInterfaceMapping = null;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            dpdkInterfaceMapping = ((PrepareForMigrationAnswer) pfma).getDpdkInterfaceMapping();\n            if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n                mc.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n            }\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    throw new CloudRuntimeException(details);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm, dpdkInterfaceMapping)), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                volumeMgr.release(vm.getId(), dstHostId);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm, dpdkInterfaceMapping)), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n                _networkMgr.setHypervisorHostname(profile, dest, false);\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            } else {\n                _networkMgr.commitNicForMigration(vmSrc, profile);\n                volumeMgr.release(vm.getId(), srcHostId);\n                _networkMgr.setHypervisorHostname(profile, dest, true);\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":2653,"status":"M"},{"authorDate":"2021-04-05 17:07:11","commitOrder":8,"curCode":"    private void orchestrateMigrateForScale(final String vmUuid, final long srcHostId, final DeployDestination dest, final Long oldSvcOfferingId)\n            throws ResourceUnavailableException, ConcurrentOperationException {\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n\n        vm.getServiceOfferingId();\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {\n            s_logger.info(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dstHostId);\n            throw new CloudRuntimeException(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dest.getHost().getId());\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final long vmId = vm.getId();\n        vm = _vmDao.findByUuid(vmUuid);\n        if (vm == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"Unable to find a virtual machine with id \" + vmId);\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);\n        _networkMgr.prepareNicForMigration(profile, dest);\n\n        volumeMgr.prepareForMigration(profile, dest);\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        }\n\n        boolean migrated = false;\n        try {\n            Map<String, Boolean> vlanToPersistenceMap = getVlanToPersistenceMapForVM(vm.getId());\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n            if (MapUtils.isNotEmpty(vlanToPersistenceMap)) {\n                mc.setVlanToPersistenceMap(vlanToPersistenceMap);\n            }\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    final String msg = \"Unable to migrate due to \" + details;\n                    s_logger.error(msg);\n                    throw new CloudRuntimeException(msg);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                final long newServiceOfferingId = vm.getServiceOfferingId();\n                vm.setServiceOfferingId(oldSvcOfferingId); \r\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n                vm.setServiceOfferingId(newServiceOfferingId);\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n                _networkMgr.setHypervisorHostname(profile, dest, false);\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            } else {\n                _networkMgr.setHypervisorHostname(profile, dest, true);\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","date":"2021-04-05 17:07:11","endLine":4506,"groupId":"11473","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"orchestrateMigrateForScale","params":"(finalStringvmUuid@finallongsrcHostId@finalDeployDestinationdest@finalLongoldSvcOfferingId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/1e/92c3ed5be7e6ac76091149b4cc4fcfba874141.src","preCode":"    private void orchestrateMigrateForScale(final String vmUuid, final long srcHostId, final DeployDestination dest, final Long oldSvcOfferingId)\n            throws ResourceUnavailableException, ConcurrentOperationException {\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n\n        vm.getServiceOfferingId();\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {\n            s_logger.info(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dstHostId);\n            throw new CloudRuntimeException(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dest.getHost().getId());\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final long vmId = vm.getId();\n        vm = _vmDao.findByUuid(vmUuid);\n        if (vm == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"Unable to find a virtual machine with id \" + vmId);\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);\n        _networkMgr.prepareNicForMigration(profile, dest);\n\n        volumeMgr.prepareForMigration(profile, dest);\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        }\n\n        boolean migrated = false;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    final String msg = \"Unable to migrate due to \" + details;\n                    s_logger.error(msg);\n                    throw new CloudRuntimeException(msg);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                final long newServiceOfferingId = vm.getServiceOfferingId();\n                vm.setServiceOfferingId(oldSvcOfferingId); \r\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n                vm.setServiceOfferingId(newServiceOfferingId);\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n                _networkMgr.setHypervisorHostname(profile, dest, false);\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            } else {\n                _networkMgr.setHypervisorHostname(profile, dest, true);\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":4338,"status":"M"}],"commitId":"0dbeb262e4f483e06ca335aadcee9664cf7f35c4","commitMessage":"@@@server: Support for persistence mode in L2 networks (#4561)\n\nThis PR aims at introducing persistence mode in L2 networks and enhancing the behavior in Isolated networks\nDoc PR apache/cloudstack-documentation#183\n\nCo-authored-by: Pearl Dsilva <pearl.dsilva@shapeblue.com>","date":"2021-04-05 17:07:11","modifiedFileCount":"27","status":"M","submitter":"Pearl Dsilva"},{"authorTime":"2021-07-14 04:35:59","codes":[{"authorDate":"2021-04-05 17:07:11","commitOrder":9,"curCode":"    protected void migrate(final VMInstanceVO vm, final long srcHostId, final DeployDestination dest) throws ResourceUnavailableException, ConcurrentOperationException {\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n        final UserVmVO userVm = _userVmDao.findById(vm.getId());\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId() && vm.getHypervisorType() != HypervisorType.VMware) {\n            final List<VolumeVO> volumes = _volsDao.findCreatedByInstance(vm.getId());\n            for (final VolumeVO volume : volumes) {\n                if (!_storagePoolDao.findById(volume.getPoolId()).getScope().equals(ScopeType.ZONE)) {\n                    s_logger.info(\"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                            + dest.getHost().getId());\n                    throw new CloudRuntimeException(\n                            \"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                                    + dest.getHost().getId());\n                }\n            }\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile vmSrc = new VirtualMachineProfileImpl(vm);\n        vmSrc.setHost(fromHost);\n        for (final NicProfile nic : _networkMgr.getNicProfiles(vm)) {\n            vmSrc.addNic(nic);\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        profile.setHost(dest.getHost());\n\n        _networkMgr.prepareNicForMigration(profile, dest);\n        volumeMgr.prepareForMigration(profile, dest);\n        profile.setConfigDriveLabel(VmConfigDriveLabel.value());\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                volumeMgr.release(vm.getId(), dstHostId);\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                if (vm != null) {\n                    volumeMgr.release(vm.getId(), dstHostId);\n                }\n\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            volumeMgr.release(vm.getId(), dstHostId);\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        } catch (final CloudRuntimeException e2) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            volumeMgr.release(vm.getId(), dstHostId);\n            s_logger.info(\"Migration cancelled because \" + e2.getMessage());\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n            try {\n                stateTransitTo(vm, Event.OperationFailed, srcHostId);\n            } catch (final NoTransitionException e3) {\n                s_logger.warn(e3.getMessage());\n            }\n            throw new CloudRuntimeException(\"Migration cancelled because \" + e2.getMessage());\n        }\n\n        boolean migrated = false;\n        Map<String, DpdkTO> dpdkInterfaceMapping = null;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            Map<String, Boolean> vlanToPersistenceMap = getVlanToPersistenceMapForVM(vm.getId());\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n            if (MapUtils.isNotEmpty(vlanToPersistenceMap)) {\n                mc.setVlanToPersistenceMap(vlanToPersistenceMap);\n            }\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            dpdkInterfaceMapping = ((PrepareForMigrationAnswer) pfma).getDpdkInterfaceMapping();\n            if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n                mc.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n            }\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    throw new CloudRuntimeException(details);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm, dpdkInterfaceMapping)), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                volumeMgr.release(vm.getId(), dstHostId);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm, dpdkInterfaceMapping)), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n                _networkMgr.setHypervisorHostname(profile, dest, false);\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            } else {\n                _networkMgr.commitNicForMigration(vmSrc, profile);\n                volumeMgr.release(vm.getId(), srcHostId);\n                _networkMgr.setHypervisorHostname(profile, dest, true);\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","date":"2021-04-05 17:07:11","endLine":2849,"groupId":"12555","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"migrate","params":"(finalVMInstanceVOvm@finallongsrcHostId@finalDeployDestinationdest)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/1e/92c3ed5be7e6ac76091149b4cc4fcfba874141.src","preCode":"    protected void migrate(final VMInstanceVO vm, final long srcHostId, final DeployDestination dest) throws ResourceUnavailableException, ConcurrentOperationException {\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n        final UserVmVO userVm = _userVmDao.findById(vm.getId());\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId() && vm.getHypervisorType() != HypervisorType.VMware) {\n            final List<VolumeVO> volumes = _volsDao.findCreatedByInstance(vm.getId());\n            for (final VolumeVO volume : volumes) {\n                if (!_storagePoolDao.findById(volume.getPoolId()).getScope().equals(ScopeType.ZONE)) {\n                    s_logger.info(\"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                            + dest.getHost().getId());\n                    throw new CloudRuntimeException(\n                            \"Source and destination host are not in same cluster and all volumes are not on zone wide primary store, unable to migrate to host: \"\n                                    + dest.getHost().getId());\n                }\n            }\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile vmSrc = new VirtualMachineProfileImpl(vm);\n        vmSrc.setHost(fromHost);\n        for (final NicProfile nic : _networkMgr.getNicProfiles(vm)) {\n            vmSrc.addNic(nic);\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        profile.setHost(dest.getHost());\n\n        _networkMgr.prepareNicForMigration(profile, dest);\n        volumeMgr.prepareForMigration(profile, dest);\n        profile.setConfigDriveLabel(VmConfigDriveLabel.value());\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                volumeMgr.release(vm.getId(), dstHostId);\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                if (vm != null) {\n                    volumeMgr.release(vm.getId(), dstHostId);\n                }\n\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            volumeMgr.release(vm.getId(), dstHostId);\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        } catch (final CloudRuntimeException e2) {\n            _networkMgr.rollbackNicForMigration(vmSrc, profile);\n            volumeMgr.release(vm.getId(), dstHostId);\n            s_logger.info(\"Migration cancelled because \" + e2.getMessage());\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n            try {\n                stateTransitTo(vm, Event.OperationFailed, srcHostId);\n            } catch (final NoTransitionException e3) {\n                s_logger.warn(e3.getMessage());\n            }\n            throw new CloudRuntimeException(\"Migration cancelled because \" + e2.getMessage());\n        }\n\n        boolean migrated = false;\n        Map<String, DpdkTO> dpdkInterfaceMapping = null;\n        try {\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            Map<String, Boolean> vlanToPersistenceMap = getVlanToPersistenceMapForVM(vm.getId());\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n            if (MapUtils.isNotEmpty(vlanToPersistenceMap)) {\n                mc.setVlanToPersistenceMap(vlanToPersistenceMap);\n            }\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            dpdkInterfaceMapping = ((PrepareForMigrationAnswer) pfma).getDpdkInterfaceMapping();\n            if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n                mc.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n            }\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    throw new CloudRuntimeException(details);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm, dpdkInterfaceMapping)), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n                _networkMgr.rollbackNicForMigration(vmSrc, profile);\n                volumeMgr.release(vm.getId(), dstHostId);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm, dpdkInterfaceMapping)), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n                _networkMgr.setHypervisorHostname(profile, dest, false);\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            } else {\n                _networkMgr.commitNicForMigration(vmSrc, profile);\n                volumeMgr.release(vm.getId(), srcHostId);\n                _networkMgr.setHypervisorHostname(profile, dest, true);\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":2653,"status":"N"},{"authorDate":"2021-07-14 04:35:59","commitOrder":9,"curCode":"    private void orchestrateMigrateForScale(final String vmUuid, final long srcHostId, final DeployDestination dest, final Long oldSvcOfferingId)\n            throws ResourceUnavailableException, ConcurrentOperationException {\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n        s_logger.info(String.format(\"Migrating %s to %s\", vm, dest));\n\n        vm.getServiceOfferingId();\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        Host srcHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            String logMessageUnableToFindHost = String.format(\"Unable to find host to migrate from %s.\", srcHost);\n            s_logger.info(logMessageUnableToFindHost);\n            throw new CloudRuntimeException(logMessageUnableToFindHost);\n        }\n\n        Host dstHost = _hostDao.findById(dstHostId);\n        long destHostClusterId = dest.getCluster().getId();\n        long fromHostClusterId = fromHost.getClusterId();\n        if (fromHostClusterId != destHostClusterId) {\n            String logMessageHostsOnDifferentCluster = String.format(\"Source and destination host are not in same cluster, unable to migrate to %s\", srcHost);\n            s_logger.info(logMessageHostsOnDifferentCluster);\n            throw new CloudRuntimeException(logMessageHostsOnDifferentCluster);\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final long vmId = vm.getId();\n        vm = _vmDao.findByUuid(vmUuid);\n        if (vm == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"Unable to find a virtual machine with id \" + vmId);\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);\n        _networkMgr.prepareNicForMigration(profile, dest);\n\n        volumeMgr.prepareForMigration(profile, dest);\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        }\n\n        boolean migrated = false;\n        try {\n            Map<String, Boolean> vlanToPersistenceMap = getVlanToPersistenceMapForVM(vm.getId());\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n            if (MapUtils.isNotEmpty(vlanToPersistenceMap)) {\n                mc.setVlanToPersistenceMap(vlanToPersistenceMap);\n            }\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    final String msg = \"Unable to migrate due to \" + details;\n                    s_logger.error(msg);\n                    throw new CloudRuntimeException(msg);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                final long newServiceOfferingId = vm.getServiceOfferingId();\n                vm.setServiceOfferingId(oldSvcOfferingId); \r\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n                vm.setServiceOfferingId(newServiceOfferingId);\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(String.format(\"Unable to cleanup source %s. \", srcHost), e);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(String.format(\"Error while checking the %s on %s\", vm, dstHost), e);\n            }\n\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n\n                String alertSubject = String.format(\"Unable to migrate %s from %s in Zone [%s] and Pod [%s].\",\n                        vm.getInstanceName(), fromHost, dest.getDataCenter().getName(), dest.getPod().getName());\n                String alertBody = \"Migrate Command failed. Please check logs.\";\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(), alertSubject, alertBody);\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n                _networkMgr.setHypervisorHostname(profile, dest, false);\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            } else {\n                _networkMgr.setHypervisorHostname(profile, dest, true);\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","date":"2021-07-14 04:35:59","endLine":4520,"groupId":"12555","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"orchestrateMigrateForScale","params":"(finalStringvmUuid@finallongsrcHostId@finalDeployDestinationdest@finalLongoldSvcOfferingId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/ec/a0852060d8514e997ef2619b228166581bb284.src","preCode":"    private void orchestrateMigrateForScale(final String vmUuid, final long srcHostId, final DeployDestination dest, final Long oldSvcOfferingId)\n            throws ResourceUnavailableException, ConcurrentOperationException {\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n        s_logger.info(\"Migrating \" + vm + \" to \" + dest);\n\n        vm.getServiceOfferingId();\n        final long dstHostId = dest.getHost().getId();\n        final Host fromHost = _hostDao.findById(srcHostId);\n        if (fromHost == null) {\n            s_logger.info(\"Unable to find the host to migrate from: \" + srcHostId);\n            throw new CloudRuntimeException(\"Unable to find the host to migrate from: \" + srcHostId);\n        }\n\n        if (fromHost.getClusterId().longValue() != dest.getCluster().getId()) {\n            s_logger.info(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dstHostId);\n            throw new CloudRuntimeException(\"Source and destination host are not in same cluster, unable to migrate to host: \" + dest.getHost().getId());\n        }\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final long vmId = vm.getId();\n        vm = _vmDao.findByUuid(vmUuid);\n        if (vm == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"Unable to find a virtual machine with id \" + vmId);\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not Running, unable to migrate the vm \" + vm);\n            }\n            throw new CloudRuntimeException(\"VM is not Running, unable to migrate the vm currently \" + vm + \" , current state: \" + vm.getState().toString());\n        }\n\n        AlertManager.AlertType alertType = AlertManager.AlertType.ALERT_TYPE_USERVM_MIGRATE;\n        if (VirtualMachine.Type.DomainRouter.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_DOMAIN_ROUTER_MIGRATE;\n        } else if (VirtualMachine.Type.ConsoleProxy.equals(vm.getType())) {\n            alertType = AlertManager.AlertType.ALERT_TYPE_CONSOLE_PROXY_MIGRATE;\n        }\n\n        final VirtualMachineProfile profile = new VirtualMachineProfileImpl(vm);\n        _networkMgr.prepareNicForMigration(profile, dest);\n\n        volumeMgr.prepareForMigration(profile, dest);\n\n        final VirtualMachineTO to = toVmTO(profile);\n        final PrepareForMigrationCommand pfmc = new PrepareForMigrationCommand(to);\n\n        ItWorkVO work = new ItWorkVO(UUID.randomUUID().toString(), _nodeId, State.Migrating, vm.getType(), vm.getId());\n        work.setStep(Step.Prepare);\n        work.setResourceType(ItWorkVO.ResourceType.Host);\n        work.setResourceId(dstHostId);\n        work = _workDao.persist(work);\n\n        Answer pfma = null;\n        try {\n            pfma = _agentMgr.send(dstHostId, pfmc);\n            if (pfma == null || !pfma.getResult()) {\n                final String details = pfma != null ? pfma.getDetails() : \"null answer returned\";\n                final String msg = \"Unable to prepare for migration due to \" + details;\n                pfma = null;\n                throw new AgentUnavailableException(msg, dstHostId);\n            }\n        } catch (final OperationTimedoutException e1) {\n            throw new AgentUnavailableException(\"Operation timed out\", dstHostId);\n        } finally {\n            if (pfma == null) {\n                work.setStep(Step.Done);\n                _workDao.update(work.getId(), work);\n            }\n        }\n\n        vm.setLastHostId(srcHostId);\n        try {\n            if (vm == null || vm.getHostId() == null || vm.getHostId() != srcHostId || !changeState(vm, Event.MigrationRequested, dstHostId, work, Step.Migrating)) {\n                s_logger.info(\"Migration cancelled because state has changed: \" + vm);\n                throw new ConcurrentOperationException(\"Migration cancelled because state has changed: \" + vm);\n            }\n        } catch (final NoTransitionException e1) {\n            s_logger.info(\"Migration cancelled because \" + e1.getMessage());\n            throw new ConcurrentOperationException(\"Migration cancelled because \" + e1.getMessage());\n        }\n\n        boolean migrated = false;\n        try {\n            Map<String, Boolean> vlanToPersistenceMap = getVlanToPersistenceMapForVM(vm.getId());\n            final boolean isWindows = _guestOsCategoryDao.findById(_guestOsDao.findById(vm.getGuestOSId()).getCategoryId()).getName().equalsIgnoreCase(\"Windows\");\n            final MigrateCommand mc = new MigrateCommand(vm.getInstanceName(), dest.getHost().getPrivateIpAddress(), isWindows, to, getExecuteInSequence(vm.getHypervisorType()));\n            if (MapUtils.isNotEmpty(vlanToPersistenceMap)) {\n                mc.setVlanToPersistenceMap(vlanToPersistenceMap);\n            }\n\n            boolean kvmAutoConvergence = StorageManager.KvmAutoConvergence.value();\n            mc.setAutoConvergence(kvmAutoConvergence);\n            mc.setHostGuid(dest.getHost().getGuid());\n\n            try {\n                final Answer ma = _agentMgr.send(vm.getLastHostId(), mc);\n                if (ma == null || !ma.getResult()) {\n                    final String details = ma != null ? ma.getDetails() : \"null answer returned\";\n                    final String msg = \"Unable to migrate due to \" + details;\n                    s_logger.error(msg);\n                    throw new CloudRuntimeException(msg);\n                }\n            } catch (final OperationTimedoutException e) {\n                if (e.isActive()) {\n                    s_logger.warn(\"Active migration command so scheduling a restart for \" + vm);\n                    _haMgr.scheduleRestart(vm, true);\n                }\n                throw new AgentUnavailableException(\"Operation timed out on migrating \" + vm, dstHostId);\n            }\n\n            try {\n                final long newServiceOfferingId = vm.getServiceOfferingId();\n                vm.setServiceOfferingId(oldSvcOfferingId); \r\n                if (!changeState(vm, VirtualMachine.Event.OperationSucceeded, dstHostId, work, Step.Started)) {\n                    throw new ConcurrentOperationException(\"Unable to change the state for \" + vm);\n                }\n                vm.setServiceOfferingId(newServiceOfferingId);\n            } catch (final NoTransitionException e1) {\n                throw new ConcurrentOperationException(\"Unable to change state due to \" + e1.getMessage());\n            }\n\n            try {\n                if (!checkVmOnHost(vm, dstHostId)) {\n                    s_logger.error(\"Unable to complete migration for \" + vm);\n                    try {\n                        _agentMgr.send(srcHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                    } catch (final AgentUnavailableException e) {\n                        s_logger.error(\"AgentUnavailableException while cleanup on source host: \" + srcHostId);\n                    }\n                    cleanup(vmGuru, new VirtualMachineProfileImpl(vm), work, Event.AgentReportStopped, true);\n                    throw new CloudRuntimeException(\"Unable to complete migration for \" + vm);\n                }\n            } catch (final OperationTimedoutException e) {\n                s_logger.debug(\"Error while checking the vm \" + vm + \" on host \" + dstHostId, e);\n            }\n\n            migrated = true;\n        } finally {\n            if (!migrated) {\n                s_logger.info(\"Migration was unsuccessful.  Cleaning up: \" + vm);\n\n                _alertMgr.sendAlert(alertType, fromHost.getDataCenterId(), fromHost.getPodId(),\n                        \"Unable to migrate vm \" + vm.getInstanceName() + \" from host \" + fromHost.getName() + \" in zone \" + dest.getDataCenter().getName() + \" and pod \" +\n                                dest.getPod().getName(), \"Migrate Command failed.  Please check logs.\");\n                try {\n                    _agentMgr.send(dstHostId, new Commands(cleanup(vm.getInstanceName())), null);\n                } catch (final AgentUnavailableException ae) {\n                    s_logger.info(\"Looks like the destination Host is unavailable for cleanup\");\n                }\n                _networkMgr.setHypervisorHostname(profile, dest, false);\n                try {\n                    stateTransitTo(vm, Event.OperationFailed, srcHostId);\n                } catch (final NoTransitionException e) {\n                    s_logger.warn(e.getMessage());\n                }\n            } else {\n                _networkMgr.setHypervisorHostname(profile, dest, true);\n            }\n\n            work.setStep(Step.Done);\n            _workDao.update(work.getId(), work);\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":4345,"status":"M"}],"commitId":"ca78f5b38687bee264d9df2212e8ae4d0cac9a4c","commitMessage":"@@@Enhance log messages with host name (#4575)\n\n* Enhance log messages with hostName\n\n* Use host.toString() on most of host logs.\n\n* Remove redundant \"Host\" in logs and enhance logs\n\n* duplicated \"for\"\n\n* Adopt String.format.  and enhance code\n\n* Address reviews enhancing log messages\n\nUpdate server/src/main/java/com/cloud/resource/ResourceManagerImpl.java\n    -- server/src/main/java/com/cloud/vm/UserVmManagerImpl.java\n    -- server/src/main/java/com/cloud/resource/RollingMaintenanceManagerImpl.java\n\nCo-authored-by: Daniel Augusto Veronezi Salvador <38945620+GutoVeronezi@users.noreply.github.com>\n\n* Fix String.format issue and change log message from debug to warn\n\n* Fix checkstyle issue\n\n* Fix string.format log\n\n* Address review: enhance logs\n\n* Enhance log of hosts in maintenance avoid list\n\n* Remove \"VM\" on logs as vm.toString() already appends VM-<details>\n\n* Add more details of the VM when postStateTransitionEvent\n\n* Address reviewer and enhance VMInstanceVO.toString()\n\nCo-authored-by: Daniel Augusto Veronezi Salvador <38945620+GutoVeronezi@users.noreply.github.com>","date":"2021-07-14 04:35:59","modifiedFileCount":"11","status":"M","submitter":"Gabriel Beims Br?scher"}]
