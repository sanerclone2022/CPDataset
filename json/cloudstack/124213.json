[{"authorTime":"2020-03-06 15:51:23","codes":[{"authorDate":"2020-03-06 15:51:23","commitOrder":1,"curCode":"    protected DeployDestination plan(final long nodesCount, final DataCenter zone, final ServiceOffering offering) throws InsufficientServerCapacityException {\n        final int cpu_requested = offering.getCpu() * offering.getSpeed();\n        final long ram_requested = offering.getRamSize() * 1024L * 1024L;\n        List<HostVO> hosts = resourceManager.listAllHostsInOneZoneByType(Host.Type.Routing, zone.getId());\n        final Map<String, Pair<HostVO, Integer>> hosts_with_resevered_capacity = new ConcurrentHashMap<String, Pair<HostVO, Integer>>();\n        for (HostVO h : hosts) {\n            hosts_with_resevered_capacity.put(h.getUuid(), new Pair<HostVO, Integer>(h, 0));\n        }\n        boolean suitable_host_found = false;\n        for (int i = 1; i <= nodesCount + 1; i++) {\n            suitable_host_found = false;\n            for (Map.Entry<String, Pair<HostVO, Integer>> hostEntry : hosts_with_resevered_capacity.entrySet()) {\n                Pair<HostVO, Integer> hp = hostEntry.getValue();\n                HostVO h = hp.first();\n                int reserved = hp.second();\n                reserved++;\n                ClusterVO cluster = clusterDao.findById(h.getClusterId());\n                ClusterDetailsVO cluster_detail_cpu = clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n                ClusterDetailsVO cluster_detail_ram = clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n                Float cpuOvercommitRatio = Float.parseFloat(cluster_detail_cpu.getValue());\n                Float memoryOvercommitRatio = Float.parseFloat(cluster_detail_ram.getValue());\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(String.format(\"Checking host ID: %s for capacity already reserved %d\", h.getUuid(), reserved));\n                }\n                if (capacityManager.checkIfHostHasCapacity(h.getId(), cpu_requested * reserved, ram_requested * reserved, false, cpuOvercommitRatio, memoryOvercommitRatio, true)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(String.format(\"Found host ID: %s for with enough capacity, CPU=%d RAM=%d\", h.getUuid(), cpu_requested * reserved, ram_requested * reserved));\n                    }\n                    hostEntry.setValue(new Pair<HostVO, Integer>(h, reserved));\n                    suitable_host_found = true;\n                    break;\n                }\n            }\n            if (!suitable_host_found) {\n                if (LOGGER.isInfoEnabled()) {\n                    LOGGER.info(String.format(\"Suitable hosts not found in datacenter ID: %s for node %d\", zone.getUuid(), i));\n                }\n                break;\n            }\n        }\n        if (suitable_host_found) {\n            if (LOGGER.isInfoEnabled()) {\n                LOGGER.info(String.format(\"Suitable hosts found in datacenter ID: %s, creating deployment destination\", zone.getUuid()));\n            }\n            return new DeployDestination(zone, null, null, null);\n        }\n        String msg = String.format(\"Cannot find enough capacity for Kubernetes cluster(requested cpu=%1$s memory=%2$s)\",\n                cpu_requested * nodesCount, ram_requested * nodesCount);\n        LOGGER.warn(msg);\n        throw new InsufficientServerCapacityException(msg, DataCenter.class, zone.getId());\n    }\n","date":"2020-03-06 15:51:23","endLine":247,"groupId":"406","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"plan","params":"(finallongnodesCount@finalDataCenterzone@finalServiceOfferingoffering)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/5d/256140f345c508fcbf8f5422d41503fa48b75d.src","preCode":"    protected DeployDestination plan(final long nodesCount, final DataCenter zone, final ServiceOffering offering) throws InsufficientServerCapacityException {\n        final int cpu_requested = offering.getCpu() * offering.getSpeed();\n        final long ram_requested = offering.getRamSize() * 1024L * 1024L;\n        List<HostVO> hosts = resourceManager.listAllHostsInOneZoneByType(Host.Type.Routing, zone.getId());\n        final Map<String, Pair<HostVO, Integer>> hosts_with_resevered_capacity = new ConcurrentHashMap<String, Pair<HostVO, Integer>>();\n        for (HostVO h : hosts) {\n            hosts_with_resevered_capacity.put(h.getUuid(), new Pair<HostVO, Integer>(h, 0));\n        }\n        boolean suitable_host_found = false;\n        for (int i = 1; i <= nodesCount + 1; i++) {\n            suitable_host_found = false;\n            for (Map.Entry<String, Pair<HostVO, Integer>> hostEntry : hosts_with_resevered_capacity.entrySet()) {\n                Pair<HostVO, Integer> hp = hostEntry.getValue();\n                HostVO h = hp.first();\n                int reserved = hp.second();\n                reserved++;\n                ClusterVO cluster = clusterDao.findById(h.getClusterId());\n                ClusterDetailsVO cluster_detail_cpu = clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n                ClusterDetailsVO cluster_detail_ram = clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n                Float cpuOvercommitRatio = Float.parseFloat(cluster_detail_cpu.getValue());\n                Float memoryOvercommitRatio = Float.parseFloat(cluster_detail_ram.getValue());\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(String.format(\"Checking host ID: %s for capacity already reserved %d\", h.getUuid(), reserved));\n                }\n                if (capacityManager.checkIfHostHasCapacity(h.getId(), cpu_requested * reserved, ram_requested * reserved, false, cpuOvercommitRatio, memoryOvercommitRatio, true)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(String.format(\"Found host ID: %s for with enough capacity, CPU=%d RAM=%d\", h.getUuid(), cpu_requested * reserved, ram_requested * reserved));\n                    }\n                    hostEntry.setValue(new Pair<HostVO, Integer>(h, reserved));\n                    suitable_host_found = true;\n                    break;\n                }\n            }\n            if (!suitable_host_found) {\n                if (LOGGER.isInfoEnabled()) {\n                    LOGGER.info(String.format(\"Suitable hosts not found in datacenter ID: %s for node %d\", zone.getUuid(), i));\n                }\n                break;\n            }\n        }\n        if (suitable_host_found) {\n            if (LOGGER.isInfoEnabled()) {\n                LOGGER.info(String.format(\"Suitable hosts found in datacenter ID: %s, creating deployment destination\", zone.getUuid()));\n            }\n            return new DeployDestination(zone, null, null, null);\n        }\n        String msg = String.format(\"Cannot find enough capacity for Kubernetes cluster(requested cpu=%1$s memory=%2$s)\",\n                cpu_requested * nodesCount, ram_requested * nodesCount);\n        LOGGER.warn(msg);\n        throw new InsufficientServerCapacityException(msg, DataCenter.class, zone.getId());\n    }\n","realPath":"plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterResourceModifierActionWorker.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":197,"status":"B"},{"authorDate":"2020-03-06 15:51:23","commitOrder":1,"curCode":"    private DeployDestination plan(final long nodesCount, final DataCenter zone, final ServiceOffering offering) throws InsufficientServerCapacityException {\n        final int cpu_requested = offering.getCpu() * offering.getSpeed();\n        final long ram_requested = offering.getRamSize() * 1024L * 1024L;\n        List<HostVO> hosts = resourceManager.listAllHostsInOneZoneByType(Type.Routing, zone.getId());\n        final Map<String, Pair<HostVO, Integer>> hosts_with_resevered_capacity = new ConcurrentHashMap<String, Pair<HostVO, Integer>>();\n        for (HostVO h : hosts) {\n            hosts_with_resevered_capacity.put(h.getUuid(), new Pair<HostVO, Integer>(h, 0));\n        }\n        boolean suitable_host_found = false;\n        Cluster planCluster = null;\n        for (int i = 1; i <= nodesCount + 1; i++) {\n            suitable_host_found = false;\n            for (Map.Entry<String, Pair<HostVO, Integer>> hostEntry : hosts_with_resevered_capacity.entrySet()) {\n                Pair<HostVO, Integer> hp = hostEntry.getValue();\n                HostVO h = hp.first();\n                int reserved = hp.second();\n                reserved++;\n                ClusterVO cluster = clusterDao.findById(h.getClusterId());\n                ClusterDetailsVO cluster_detail_cpu = clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n                ClusterDetailsVO cluster_detail_ram = clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n                Float cpuOvercommitRatio = Float.parseFloat(cluster_detail_cpu.getValue());\n                Float memoryOvercommitRatio = Float.parseFloat(cluster_detail_ram.getValue());\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(String.format(\"Checking host ID: %s for capacity already reserved %d\", h.getUuid(), reserved));\n                }\n                if (capacityManager.checkIfHostHasCapacity(h.getId(), cpu_requested * reserved, ram_requested * reserved, false, cpuOvercommitRatio, memoryOvercommitRatio, true)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(String.format(\"Found host ID: %s for with enough capacity, CPU=%d RAM=%d\", h.getUuid(), cpu_requested * reserved, ram_requested * reserved));\n                    }\n                    hostEntry.setValue(new Pair<HostVO, Integer>(h, reserved));\n                    suitable_host_found = true;\n                    planCluster = cluster;\n                    break;\n                }\n            }\n            if (!suitable_host_found) {\n                if (LOGGER.isInfoEnabled()) {\n                    LOGGER.info(String.format(\"Suitable hosts not found in datacenter ID: %s for node %d\", zone.getUuid(), i));\n                }\n                break;\n            }\n        }\n        if (suitable_host_found) {\n            if (LOGGER.isInfoEnabled()) {\n                LOGGER.info(String.format(\"Suitable hosts found in datacenter ID: %s, creating deployment destination\", zone.getUuid()));\n            }\n            return new DeployDestination(zone, null, planCluster, null);\n        }\n        String msg = String.format(\"Cannot find enough capacity for Kubernetes cluster(requested cpu=%1$s memory=%2$s)\",\n                cpu_requested * nodesCount, ram_requested * nodesCount);\n        LOGGER.warn(msg);\n        throw new InsufficientServerCapacityException(msg, DataCenter.class, zone.getId());\n    }\n","date":"2020-03-06 15:51:23","endLine":563,"groupId":"406","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"plan","params":"(finallongnodesCount@finalDataCenterzone@finalServiceOfferingoffering)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/35/8fa034a8ba19c25ff80ea5a512ad96d333cf35.src","preCode":"    private DeployDestination plan(final long nodesCount, final DataCenter zone, final ServiceOffering offering) throws InsufficientServerCapacityException {\n        final int cpu_requested = offering.getCpu() * offering.getSpeed();\n        final long ram_requested = offering.getRamSize() * 1024L * 1024L;\n        List<HostVO> hosts = resourceManager.listAllHostsInOneZoneByType(Type.Routing, zone.getId());\n        final Map<String, Pair<HostVO, Integer>> hosts_with_resevered_capacity = new ConcurrentHashMap<String, Pair<HostVO, Integer>>();\n        for (HostVO h : hosts) {\n            hosts_with_resevered_capacity.put(h.getUuid(), new Pair<HostVO, Integer>(h, 0));\n        }\n        boolean suitable_host_found = false;\n        Cluster planCluster = null;\n        for (int i = 1; i <= nodesCount + 1; i++) {\n            suitable_host_found = false;\n            for (Map.Entry<String, Pair<HostVO, Integer>> hostEntry : hosts_with_resevered_capacity.entrySet()) {\n                Pair<HostVO, Integer> hp = hostEntry.getValue();\n                HostVO h = hp.first();\n                int reserved = hp.second();\n                reserved++;\n                ClusterVO cluster = clusterDao.findById(h.getClusterId());\n                ClusterDetailsVO cluster_detail_cpu = clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n                ClusterDetailsVO cluster_detail_ram = clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n                Float cpuOvercommitRatio = Float.parseFloat(cluster_detail_cpu.getValue());\n                Float memoryOvercommitRatio = Float.parseFloat(cluster_detail_ram.getValue());\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(String.format(\"Checking host ID: %s for capacity already reserved %d\", h.getUuid(), reserved));\n                }\n                if (capacityManager.checkIfHostHasCapacity(h.getId(), cpu_requested * reserved, ram_requested * reserved, false, cpuOvercommitRatio, memoryOvercommitRatio, true)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(String.format(\"Found host ID: %s for with enough capacity, CPU=%d RAM=%d\", h.getUuid(), cpu_requested * reserved, ram_requested * reserved));\n                    }\n                    hostEntry.setValue(new Pair<HostVO, Integer>(h, reserved));\n                    suitable_host_found = true;\n                    planCluster = cluster;\n                    break;\n                }\n            }\n            if (!suitable_host_found) {\n                if (LOGGER.isInfoEnabled()) {\n                    LOGGER.info(String.format(\"Suitable hosts not found in datacenter ID: %s for node %d\", zone.getUuid(), i));\n                }\n                break;\n            }\n        }\n        if (suitable_host_found) {\n            if (LOGGER.isInfoEnabled()) {\n                LOGGER.info(String.format(\"Suitable hosts found in datacenter ID: %s, creating deployment destination\", zone.getUuid()));\n            }\n            return new DeployDestination(zone, null, planCluster, null);\n        }\n        String msg = String.format(\"Cannot find enough capacity for Kubernetes cluster(requested cpu=%1$s memory=%2$s)\",\n                cpu_requested * nodesCount, ram_requested * nodesCount);\n        LOGGER.warn(msg);\n        throw new InsufficientServerCapacityException(msg, DataCenter.class, zone.getId());\n    }\n","realPath":"plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":511,"status":"B"}],"commitId":"8cc70c7d8725319ba5455c5fe17ede275e372f1c","commitMessage":"@@@CloudStack Kubernetes Service (#3680)\n\n","date":"2020-03-06 15:51:23","modifiedFileCount":"10","status":"B","submitter":"Abhishek Kumar"},{"authorTime":"2020-08-04 13:58:43","codes":[{"authorDate":"2020-08-04 13:58:43","commitOrder":2,"curCode":"    protected DeployDestination plan(final long nodesCount, final DataCenter zone, final ServiceOffering offering) throws InsufficientServerCapacityException {\n        final int cpu_requested = offering.getCpu() * offering.getSpeed();\n        final long ram_requested = offering.getRamSize() * 1024L * 1024L;\n        List<HostVO> hosts = resourceManager.listAllHostsInOneZoneByType(Host.Type.Routing, zone.getId());\n        final Map<String, Pair<HostVO, Integer>> hosts_with_resevered_capacity = new ConcurrentHashMap<String, Pair<HostVO, Integer>>();\n        for (HostVO h : hosts) {\n            hosts_with_resevered_capacity.put(h.getUuid(), new Pair<HostVO, Integer>(h, 0));\n        }\n        boolean suitable_host_found = false;\n        for (int i = 1; i <= nodesCount + 1; i++) {\n            suitable_host_found = false;\n            for (Map.Entry<String, Pair<HostVO, Integer>> hostEntry : hosts_with_resevered_capacity.entrySet()) {\n                Pair<HostVO, Integer> hp = hostEntry.getValue();\n                HostVO h = hp.first();\n                if (!h.getHypervisorType().equals(clusterTemplate.getHypervisorType())) {\n                    continue;\n                }\n                hostDao.loadHostTags(h);\n                if (!Strings.isNullOrEmpty(offering.getHostTag()) && !(h.getHostTags() != null && h.getHostTags().contains(offering.getHostTag()))) {\n                    continue;\n                }\n                int reserved = hp.second();\n                reserved++;\n                ClusterVO cluster = clusterDao.findById(h.getClusterId());\n                ClusterDetailsVO cluster_detail_cpu = clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n                ClusterDetailsVO cluster_detail_ram = clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n                Float cpuOvercommitRatio = Float.parseFloat(cluster_detail_cpu.getValue());\n                Float memoryOvercommitRatio = Float.parseFloat(cluster_detail_ram.getValue());\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(String.format(\"Checking host ID: %s for capacity already reserved %d\", h.getUuid(), reserved));\n                }\n                if (capacityManager.checkIfHostHasCapacity(h.getId(), cpu_requested * reserved, ram_requested * reserved, false, cpuOvercommitRatio, memoryOvercommitRatio, true)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(String.format(\"Found host ID: %s for with enough capacity, CPU=%d RAM=%d\", h.getUuid(), cpu_requested * reserved, ram_requested * reserved));\n                    }\n                    hostEntry.setValue(new Pair<HostVO, Integer>(h, reserved));\n                    suitable_host_found = true;\n                    break;\n                }\n            }\n            if (!suitable_host_found) {\n                if (LOGGER.isInfoEnabled()) {\n                    LOGGER.info(String.format(\"Suitable hosts not found in datacenter ID: %s for node %d, with offering ID: %s and hypervisor: %s\", zone.getUuid(), i, offering.getUuid(), clusterTemplate.getHypervisorType().toString()));\n                }\n                break;\n            }\n        }\n        if (suitable_host_found) {\n            if (LOGGER.isInfoEnabled()) {\n                LOGGER.info(String.format(\"Suitable hosts found in datacenter ID: %s, creating deployment destination\", zone.getUuid()));\n            }\n            return new DeployDestination(zone, null, null, null);\n        }\n        String msg = String.format(\"Cannot find enough capacity for Kubernetes cluster(requested cpu=%d memory=%d) with offering ID: %s and hypervisor: %s\",\n                cpu_requested * nodesCount, ram_requested * nodesCount, offering.getUuid(), clusterTemplate.getHypervisorType().toString());\n        LOGGER.warn(msg);\n        throw new InsufficientServerCapacityException(msg, DataCenter.class, zone.getId());\n    }\n","date":"2020-08-04 13:58:43","endLine":256,"groupId":"406","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"plan","params":"(finallongnodesCount@finalDataCenterzone@finalServiceOfferingoffering)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/ae/ed9b8de4a4e1e2b3f1ac87892a1068956f4e3b.src","preCode":"    protected DeployDestination plan(final long nodesCount, final DataCenter zone, final ServiceOffering offering) throws InsufficientServerCapacityException {\n        final int cpu_requested = offering.getCpu() * offering.getSpeed();\n        final long ram_requested = offering.getRamSize() * 1024L * 1024L;\n        List<HostVO> hosts = resourceManager.listAllHostsInOneZoneByType(Host.Type.Routing, zone.getId());\n        final Map<String, Pair<HostVO, Integer>> hosts_with_resevered_capacity = new ConcurrentHashMap<String, Pair<HostVO, Integer>>();\n        for (HostVO h : hosts) {\n            hosts_with_resevered_capacity.put(h.getUuid(), new Pair<HostVO, Integer>(h, 0));\n        }\n        boolean suitable_host_found = false;\n        for (int i = 1; i <= nodesCount + 1; i++) {\n            suitable_host_found = false;\n            for (Map.Entry<String, Pair<HostVO, Integer>> hostEntry : hosts_with_resevered_capacity.entrySet()) {\n                Pair<HostVO, Integer> hp = hostEntry.getValue();\n                HostVO h = hp.first();\n                int reserved = hp.second();\n                reserved++;\n                ClusterVO cluster = clusterDao.findById(h.getClusterId());\n                ClusterDetailsVO cluster_detail_cpu = clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n                ClusterDetailsVO cluster_detail_ram = clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n                Float cpuOvercommitRatio = Float.parseFloat(cluster_detail_cpu.getValue());\n                Float memoryOvercommitRatio = Float.parseFloat(cluster_detail_ram.getValue());\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(String.format(\"Checking host ID: %s for capacity already reserved %d\", h.getUuid(), reserved));\n                }\n                if (capacityManager.checkIfHostHasCapacity(h.getId(), cpu_requested * reserved, ram_requested * reserved, false, cpuOvercommitRatio, memoryOvercommitRatio, true)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(String.format(\"Found host ID: %s for with enough capacity, CPU=%d RAM=%d\", h.getUuid(), cpu_requested * reserved, ram_requested * reserved));\n                    }\n                    hostEntry.setValue(new Pair<HostVO, Integer>(h, reserved));\n                    suitable_host_found = true;\n                    break;\n                }\n            }\n            if (!suitable_host_found) {\n                if (LOGGER.isInfoEnabled()) {\n                    LOGGER.info(String.format(\"Suitable hosts not found in datacenter ID: %s for node %d\", zone.getUuid(), i));\n                }\n                break;\n            }\n        }\n        if (suitable_host_found) {\n            if (LOGGER.isInfoEnabled()) {\n                LOGGER.info(String.format(\"Suitable hosts found in datacenter ID: %s, creating deployment destination\", zone.getUuid()));\n            }\n            return new DeployDestination(zone, null, null, null);\n        }\n        String msg = String.format(\"Cannot find enough capacity for Kubernetes cluster(requested cpu=%1$s memory=%2$s)\",\n                cpu_requested * nodesCount, ram_requested * nodesCount);\n        LOGGER.warn(msg);\n        throw new InsufficientServerCapacityException(msg, DataCenter.class, zone.getId());\n    }\n","realPath":"plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterResourceModifierActionWorker.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":199,"status":"M"},{"authorDate":"2020-08-04 13:58:43","commitOrder":2,"curCode":"    private DeployDestination plan(final long nodesCount, final DataCenter zone, final ServiceOffering offering) throws InsufficientServerCapacityException {\n        final int cpu_requested = offering.getCpu() * offering.getSpeed();\n        final long ram_requested = offering.getRamSize() * 1024L * 1024L;\n        List<HostVO> hosts = resourceManager.listAllHostsInOneZoneByType(Type.Routing, zone.getId());\n        final Map<String, Pair<HostVO, Integer>> hosts_with_resevered_capacity = new ConcurrentHashMap<String, Pair<HostVO, Integer>>();\n        for (HostVO h : hosts) {\n            hosts_with_resevered_capacity.put(h.getUuid(), new Pair<HostVO, Integer>(h, 0));\n        }\n        boolean suitable_host_found = false;\n        Cluster planCluster = null;\n        for (int i = 1; i <= nodesCount + 1; i++) {\n            suitable_host_found = false;\n            for (Map.Entry<String, Pair<HostVO, Integer>> hostEntry : hosts_with_resevered_capacity.entrySet()) {\n                Pair<HostVO, Integer> hp = hostEntry.getValue();\n                HostVO h = hp.first();\n                hostDao.loadHostTags(h);\n                if (!Strings.isNullOrEmpty(offering.getHostTag()) && !(h.getHostTags() != null && h.getHostTags().contains(offering.getHostTag()))) {\n                    continue;\n                }\n                int reserved = hp.second();\n                reserved++;\n                ClusterVO cluster = clusterDao.findById(h.getClusterId());\n                ClusterDetailsVO cluster_detail_cpu = clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n                ClusterDetailsVO cluster_detail_ram = clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n                Float cpuOvercommitRatio = Float.parseFloat(cluster_detail_cpu.getValue());\n                Float memoryOvercommitRatio = Float.parseFloat(cluster_detail_ram.getValue());\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(String.format(\"Checking host ID: %s for capacity already reserved %d\", h.getUuid(), reserved));\n                }\n                if (capacityManager.checkIfHostHasCapacity(h.getId(), cpu_requested * reserved, ram_requested * reserved, false, cpuOvercommitRatio, memoryOvercommitRatio, true)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(String.format(\"Found host ID: %s for with enough capacity, CPU=%d RAM=%d\", h.getUuid(), cpu_requested * reserved, ram_requested * reserved));\n                    }\n                    hostEntry.setValue(new Pair<HostVO, Integer>(h, reserved));\n                    suitable_host_found = true;\n                    planCluster = cluster;\n                    break;\n                }\n            }\n            if (!suitable_host_found) {\n                if (LOGGER.isInfoEnabled()) {\n                    LOGGER.info(String.format(\"Suitable hosts not found in datacenter ID: %s for node %d with offering ID: %s\", zone.getUuid(), i, offering.getUuid()));\n                }\n                break;\n            }\n        }\n        if (suitable_host_found) {\n            if (LOGGER.isInfoEnabled()) {\n                LOGGER.info(String.format(\"Suitable hosts found in datacenter ID: %s, creating deployment destination\", zone.getUuid()));\n            }\n            return new DeployDestination(zone, null, planCluster, null);\n        }\n        String msg = String.format(\"Cannot find enough capacity for Kubernetes cluster(requested cpu=%d memory=%d) with offering ID: %s\",\n                cpu_requested * nodesCount, ram_requested * nodesCount, offering.getUuid());\n        LOGGER.warn(msg);\n        throw new InsufficientServerCapacityException(msg, DataCenter.class, zone.getId());\n    }\n","date":"2020-08-04 13:58:43","endLine":563,"groupId":"406","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"plan","params":"(finallongnodesCount@finalDataCenterzone@finalServiceOfferingoffering)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/20/4f2d7b83da366fef9bd4d0fb83589c75fa527b.src","preCode":"    private DeployDestination plan(final long nodesCount, final DataCenter zone, final ServiceOffering offering) throws InsufficientServerCapacityException {\n        final int cpu_requested = offering.getCpu() * offering.getSpeed();\n        final long ram_requested = offering.getRamSize() * 1024L * 1024L;\n        List<HostVO> hosts = resourceManager.listAllHostsInOneZoneByType(Type.Routing, zone.getId());\n        final Map<String, Pair<HostVO, Integer>> hosts_with_resevered_capacity = new ConcurrentHashMap<String, Pair<HostVO, Integer>>();\n        for (HostVO h : hosts) {\n            hosts_with_resevered_capacity.put(h.getUuid(), new Pair<HostVO, Integer>(h, 0));\n        }\n        boolean suitable_host_found = false;\n        Cluster planCluster = null;\n        for (int i = 1; i <= nodesCount + 1; i++) {\n            suitable_host_found = false;\n            for (Map.Entry<String, Pair<HostVO, Integer>> hostEntry : hosts_with_resevered_capacity.entrySet()) {\n                Pair<HostVO, Integer> hp = hostEntry.getValue();\n                HostVO h = hp.first();\n                int reserved = hp.second();\n                reserved++;\n                ClusterVO cluster = clusterDao.findById(h.getClusterId());\n                ClusterDetailsVO cluster_detail_cpu = clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n                ClusterDetailsVO cluster_detail_ram = clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n                Float cpuOvercommitRatio = Float.parseFloat(cluster_detail_cpu.getValue());\n                Float memoryOvercommitRatio = Float.parseFloat(cluster_detail_ram.getValue());\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(String.format(\"Checking host ID: %s for capacity already reserved %d\", h.getUuid(), reserved));\n                }\n                if (capacityManager.checkIfHostHasCapacity(h.getId(), cpu_requested * reserved, ram_requested * reserved, false, cpuOvercommitRatio, memoryOvercommitRatio, true)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(String.format(\"Found host ID: %s for with enough capacity, CPU=%d RAM=%d\", h.getUuid(), cpu_requested * reserved, ram_requested * reserved));\n                    }\n                    hostEntry.setValue(new Pair<HostVO, Integer>(h, reserved));\n                    suitable_host_found = true;\n                    planCluster = cluster;\n                    break;\n                }\n            }\n            if (!suitable_host_found) {\n                if (LOGGER.isInfoEnabled()) {\n                    LOGGER.info(String.format(\"Suitable hosts not found in datacenter ID: %s for node %d\", zone.getUuid(), i));\n                }\n                break;\n            }\n        }\n        if (suitable_host_found) {\n            if (LOGGER.isInfoEnabled()) {\n                LOGGER.info(String.format(\"Suitable hosts found in datacenter ID: %s, creating deployment destination\", zone.getUuid()));\n            }\n            return new DeployDestination(zone, null, planCluster, null);\n        }\n        String msg = String.format(\"Cannot find enough capacity for Kubernetes cluster(requested cpu=%1$s memory=%2$s)\",\n                cpu_requested * nodesCount, ram_requested * nodesCount);\n        LOGGER.warn(msg);\n        throw new InsufficientServerCapacityException(msg, DataCenter.class, zone.getId());\n    }\n","realPath":"plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":507,"status":"M"}],"commitId":"9ae1170b29fa001e712abf746e000898a71a5511","commitMessage":"@@@Merge remote-tracking branch 'origin/4.14'\n","date":"2020-08-04 13:58:43","modifiedFileCount":"10","status":"M","submitter":"Rohit Yadav"},{"authorTime":"2020-08-13 18:25:16","codes":[{"authorDate":"2020-08-13 18:25:16","commitOrder":3,"curCode":"    protected DeployDestination plan(final long nodesCount, final DataCenter zone, final ServiceOffering offering) throws InsufficientServerCapacityException {\n        final int cpu_requested = offering.getCpu() * offering.getSpeed();\n        final long ram_requested = offering.getRamSize() * 1024L * 1024L;\n        List<HostVO> hosts = resourceManager.listAllHostsInOneZoneByType(Host.Type.Routing, zone.getId());\n        final Map<String, Pair<HostVO, Integer>> hosts_with_resevered_capacity = new ConcurrentHashMap<String, Pair<HostVO, Integer>>();\n        for (HostVO h : hosts) {\n            hosts_with_resevered_capacity.put(h.getUuid(), new Pair<HostVO, Integer>(h, 0));\n        }\n        boolean suitable_host_found = false;\n        for (int i = 1; i <= nodesCount + 1; i++) {\n            suitable_host_found = false;\n            for (Map.Entry<String, Pair<HostVO, Integer>> hostEntry : hosts_with_resevered_capacity.entrySet()) {\n                Pair<HostVO, Integer> hp = hostEntry.getValue();\n                HostVO h = hp.first();\n                if (!h.getHypervisorType().equals(clusterTemplate.getHypervisorType())) {\n                    continue;\n                }\n                hostDao.loadHostTags(h);\n                if (!Strings.isNullOrEmpty(offering.getHostTag()) && !(h.getHostTags() != null && h.getHostTags().contains(offering.getHostTag()))) {\n                    continue;\n                }\n                int reserved = hp.second();\n                reserved++;\n                ClusterVO cluster = clusterDao.findById(h.getClusterId());\n                ClusterDetailsVO cluster_detail_cpu = clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n                ClusterDetailsVO cluster_detail_ram = clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n                Float cpuOvercommitRatio = Float.parseFloat(cluster_detail_cpu.getValue());\n                Float memoryOvercommitRatio = Float.parseFloat(cluster_detail_ram.getValue());\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(String.format(\"Checking host ID: %s for capacity already reserved %d\", h.getUuid(), reserved));\n                }\n                if (capacityManager.checkIfHostHasCapacity(h.getId(), cpu_requested * reserved, ram_requested * reserved, false, cpuOvercommitRatio, memoryOvercommitRatio, true)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(String.format(\"Found host ID: %s for with enough capacity, CPU=%d RAM=%d\", h.getUuid(), cpu_requested * reserved, toHumanReadableSize(ram_requested * reserved)));\n                    }\n                    hostEntry.setValue(new Pair<HostVO, Integer>(h, reserved));\n                    suitable_host_found = true;\n                    break;\n                }\n            }\n            if (!suitable_host_found) {\n                if (LOGGER.isInfoEnabled()) {\n                    LOGGER.info(String.format(\"Suitable hosts not found in datacenter ID: %s for node %d, with offering ID: %s and hypervisor: %s\", zone.getUuid(), i, offering.getUuid(), clusterTemplate.getHypervisorType().toString()));\n                }\n                break;\n            }\n        }\n        if (suitable_host_found) {\n            if (LOGGER.isInfoEnabled()) {\n                LOGGER.info(String.format(\"Suitable hosts found in datacenter ID: %s, creating deployment destination\", zone.getUuid()));\n            }\n            return new DeployDestination(zone, null, null, null);\n        }\n        String msg = String.format(\"Cannot find enough capacity for Kubernetes cluster(requested cpu=%d memory=%d) with offering ID: %s and hypervisor: %s\",\n                cpu_requested * nodesCount, toHumanReadableSize(ram_requested * nodesCount), offering.getUuid(), clusterTemplate.getHypervisorType().toString());\n\n        LOGGER.warn(msg);\n        throw new InsufficientServerCapacityException(msg, DataCenter.class, zone.getId());\n    }\n","date":"2020-08-13 18:25:16","endLine":259,"groupId":"406","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"plan","params":"(finallongnodesCount@finalDataCenterzone@finalServiceOfferingoffering)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/e2/74f5e1a43827ff573a726dabae9dcc50b90aca.src","preCode":"    protected DeployDestination plan(final long nodesCount, final DataCenter zone, final ServiceOffering offering) throws InsufficientServerCapacityException {\n        final int cpu_requested = offering.getCpu() * offering.getSpeed();\n        final long ram_requested = offering.getRamSize() * 1024L * 1024L;\n        List<HostVO> hosts = resourceManager.listAllHostsInOneZoneByType(Host.Type.Routing, zone.getId());\n        final Map<String, Pair<HostVO, Integer>> hosts_with_resevered_capacity = new ConcurrentHashMap<String, Pair<HostVO, Integer>>();\n        for (HostVO h : hosts) {\n            hosts_with_resevered_capacity.put(h.getUuid(), new Pair<HostVO, Integer>(h, 0));\n        }\n        boolean suitable_host_found = false;\n        for (int i = 1; i <= nodesCount + 1; i++) {\n            suitable_host_found = false;\n            for (Map.Entry<String, Pair<HostVO, Integer>> hostEntry : hosts_with_resevered_capacity.entrySet()) {\n                Pair<HostVO, Integer> hp = hostEntry.getValue();\n                HostVO h = hp.first();\n                if (!h.getHypervisorType().equals(clusterTemplate.getHypervisorType())) {\n                    continue;\n                }\n                hostDao.loadHostTags(h);\n                if (!Strings.isNullOrEmpty(offering.getHostTag()) && !(h.getHostTags() != null && h.getHostTags().contains(offering.getHostTag()))) {\n                    continue;\n                }\n                int reserved = hp.second();\n                reserved++;\n                ClusterVO cluster = clusterDao.findById(h.getClusterId());\n                ClusterDetailsVO cluster_detail_cpu = clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n                ClusterDetailsVO cluster_detail_ram = clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n                Float cpuOvercommitRatio = Float.parseFloat(cluster_detail_cpu.getValue());\n                Float memoryOvercommitRatio = Float.parseFloat(cluster_detail_ram.getValue());\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(String.format(\"Checking host ID: %s for capacity already reserved %d\", h.getUuid(), reserved));\n                }\n                if (capacityManager.checkIfHostHasCapacity(h.getId(), cpu_requested * reserved, ram_requested * reserved, false, cpuOvercommitRatio, memoryOvercommitRatio, true)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(String.format(\"Found host ID: %s for with enough capacity, CPU=%d RAM=%d\", h.getUuid(), cpu_requested * reserved, ram_requested * reserved));\n                    }\n                    hostEntry.setValue(new Pair<HostVO, Integer>(h, reserved));\n                    suitable_host_found = true;\n                    break;\n                }\n            }\n            if (!suitable_host_found) {\n                if (LOGGER.isInfoEnabled()) {\n                    LOGGER.info(String.format(\"Suitable hosts not found in datacenter ID: %s for node %d, with offering ID: %s and hypervisor: %s\", zone.getUuid(), i, offering.getUuid(), clusterTemplate.getHypervisorType().toString()));\n                }\n                break;\n            }\n        }\n        if (suitable_host_found) {\n            if (LOGGER.isInfoEnabled()) {\n                LOGGER.info(String.format(\"Suitable hosts found in datacenter ID: %s, creating deployment destination\", zone.getUuid()));\n            }\n            return new DeployDestination(zone, null, null, null);\n        }\n        String msg = String.format(\"Cannot find enough capacity for Kubernetes cluster(requested cpu=%d memory=%d) with offering ID: %s and hypervisor: %s\",\n                cpu_requested * nodesCount, ram_requested * nodesCount, offering.getUuid(), clusterTemplate.getHypervisorType().toString());\n        LOGGER.warn(msg);\n        throw new InsufficientServerCapacityException(msg, DataCenter.class, zone.getId());\n    }\n","realPath":"plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterResourceModifierActionWorker.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":201,"status":"M"},{"authorDate":"2020-08-13 18:25:16","commitOrder":3,"curCode":"    private DeployDestination plan(final long nodesCount, final DataCenter zone, final ServiceOffering offering) throws InsufficientServerCapacityException {\n        final int cpu_requested = offering.getCpu() * offering.getSpeed();\n        final long ram_requested = offering.getRamSize() * 1024L * 1024L;\n        List<HostVO> hosts = resourceManager.listAllHostsInOneZoneByType(Type.Routing, zone.getId());\n        final Map<String, Pair<HostVO, Integer>> hosts_with_resevered_capacity = new ConcurrentHashMap<String, Pair<HostVO, Integer>>();\n        for (HostVO h : hosts) {\n            hosts_with_resevered_capacity.put(h.getUuid(), new Pair<HostVO, Integer>(h, 0));\n        }\n        boolean suitable_host_found = false;\n        Cluster planCluster = null;\n        for (int i = 1; i <= nodesCount + 1; i++) {\n            suitable_host_found = false;\n            for (Map.Entry<String, Pair<HostVO, Integer>> hostEntry : hosts_with_resevered_capacity.entrySet()) {\n                Pair<HostVO, Integer> hp = hostEntry.getValue();\n                HostVO h = hp.first();\n                hostDao.loadHostTags(h);\n                if (!Strings.isNullOrEmpty(offering.getHostTag()) && !(h.getHostTags() != null && h.getHostTags().contains(offering.getHostTag()))) {\n                    continue;\n                }\n                int reserved = hp.second();\n                reserved++;\n                ClusterVO cluster = clusterDao.findById(h.getClusterId());\n                ClusterDetailsVO cluster_detail_cpu = clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n                ClusterDetailsVO cluster_detail_ram = clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n                Float cpuOvercommitRatio = Float.parseFloat(cluster_detail_cpu.getValue());\n                Float memoryOvercommitRatio = Float.parseFloat(cluster_detail_ram.getValue());\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(String.format(\"Checking host ID: %s for capacity already reserved %d\", h.getUuid(), reserved));\n                }\n                if (capacityManager.checkIfHostHasCapacity(h.getId(), cpu_requested * reserved, ram_requested * reserved, false, cpuOvercommitRatio, memoryOvercommitRatio, true)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(String.format(\"Found host ID: %s for with enough capacity, CPU=%d RAM=%d\", h.getUuid(), cpu_requested * reserved, toHumanReadableSize(ram_requested * reserved)));\n                    }\n                    hostEntry.setValue(new Pair<HostVO, Integer>(h, reserved));\n                    suitable_host_found = true;\n                    planCluster = cluster;\n                    break;\n                }\n            }\n            if (!suitable_host_found) {\n                if (LOGGER.isInfoEnabled()) {\n                    LOGGER.info(String.format(\"Suitable hosts not found in datacenter ID: %s for node %d with offering ID: %s\", zone.getUuid(), i, offering.getUuid()));\n                }\n                break;\n            }\n        }\n        if (suitable_host_found) {\n            if (LOGGER.isInfoEnabled()) {\n                LOGGER.info(String.format(\"Suitable hosts found in datacenter ID: %s, creating deployment destination\", zone.getUuid()));\n            }\n            return new DeployDestination(zone, null, planCluster, null);\n        }\n        String msg = String.format(\"Cannot find enough capacity for Kubernetes cluster(requested cpu=%d memory=%d) with offering ID: %s\",\n                cpu_requested * nodesCount, toHumanReadableSize(ram_requested * nodesCount), offering.getUuid());\n        LOGGER.warn(msg);\n        throw new InsufficientServerCapacityException(msg, DataCenter.class, zone.getId());\n    }\n","date":"2020-08-13 18:25:16","endLine":565,"groupId":"406","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"plan","params":"(finallongnodesCount@finalDataCenterzone@finalServiceOfferingoffering)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/37/e1ecd4b8a11e654401817c16a5627a374885d6.src","preCode":"    private DeployDestination plan(final long nodesCount, final DataCenter zone, final ServiceOffering offering) throws InsufficientServerCapacityException {\n        final int cpu_requested = offering.getCpu() * offering.getSpeed();\n        final long ram_requested = offering.getRamSize() * 1024L * 1024L;\n        List<HostVO> hosts = resourceManager.listAllHostsInOneZoneByType(Type.Routing, zone.getId());\n        final Map<String, Pair<HostVO, Integer>> hosts_with_resevered_capacity = new ConcurrentHashMap<String, Pair<HostVO, Integer>>();\n        for (HostVO h : hosts) {\n            hosts_with_resevered_capacity.put(h.getUuid(), new Pair<HostVO, Integer>(h, 0));\n        }\n        boolean suitable_host_found = false;\n        Cluster planCluster = null;\n        for (int i = 1; i <= nodesCount + 1; i++) {\n            suitable_host_found = false;\n            for (Map.Entry<String, Pair<HostVO, Integer>> hostEntry : hosts_with_resevered_capacity.entrySet()) {\n                Pair<HostVO, Integer> hp = hostEntry.getValue();\n                HostVO h = hp.first();\n                hostDao.loadHostTags(h);\n                if (!Strings.isNullOrEmpty(offering.getHostTag()) && !(h.getHostTags() != null && h.getHostTags().contains(offering.getHostTag()))) {\n                    continue;\n                }\n                int reserved = hp.second();\n                reserved++;\n                ClusterVO cluster = clusterDao.findById(h.getClusterId());\n                ClusterDetailsVO cluster_detail_cpu = clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n                ClusterDetailsVO cluster_detail_ram = clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n                Float cpuOvercommitRatio = Float.parseFloat(cluster_detail_cpu.getValue());\n                Float memoryOvercommitRatio = Float.parseFloat(cluster_detail_ram.getValue());\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(String.format(\"Checking host ID: %s for capacity already reserved %d\", h.getUuid(), reserved));\n                }\n                if (capacityManager.checkIfHostHasCapacity(h.getId(), cpu_requested * reserved, ram_requested * reserved, false, cpuOvercommitRatio, memoryOvercommitRatio, true)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(String.format(\"Found host ID: %s for with enough capacity, CPU=%d RAM=%d\", h.getUuid(), cpu_requested * reserved, ram_requested * reserved));\n                    }\n                    hostEntry.setValue(new Pair<HostVO, Integer>(h, reserved));\n                    suitable_host_found = true;\n                    planCluster = cluster;\n                    break;\n                }\n            }\n            if (!suitable_host_found) {\n                if (LOGGER.isInfoEnabled()) {\n                    LOGGER.info(String.format(\"Suitable hosts not found in datacenter ID: %s for node %d with offering ID: %s\", zone.getUuid(), i, offering.getUuid()));\n                }\n                break;\n            }\n        }\n        if (suitable_host_found) {\n            if (LOGGER.isInfoEnabled()) {\n                LOGGER.info(String.format(\"Suitable hosts found in datacenter ID: %s, creating deployment destination\", zone.getUuid()));\n            }\n            return new DeployDestination(zone, null, planCluster, null);\n        }\n        String msg = String.format(\"Cannot find enough capacity for Kubernetes cluster(requested cpu=%d memory=%d) with offering ID: %s\",\n                cpu_requested * nodesCount, ram_requested * nodesCount, offering.getUuid());\n        LOGGER.warn(msg);\n        throw new InsufficientServerCapacityException(msg, DataCenter.class, zone.getId());\n    }\n","realPath":"plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":509,"status":"M"}],"commitId":"b586eb22f1b31f3cab2f2cb1aaeafca4f4646abd","commitMessage":"@@@Human readable sizes in logs (#4207)\n\nThis PR adds outputting human readable byte sizes in the management server logs.  agent logs.  and usage records. A non-dynamic global variable is added (display.human.readable.sizes) to control switching this feature on and off. This setting is sent to the agent on connection and is only read from the database when the management server is started up. The setting is kept in memory by the use of a static field on the NumbersUtil class and is available throughout the codebase.\n\nInstead of seeing things like:\n2020-07-23 15:31:58. 593 DEBUG [c.c.a.t.Request] (AgentManager-Handler-12:null) (logid:) Seq 8-1863645820801253428: Processing: { Ans: .  MgmtId: 52238089807.  via: 8.  Ver: v1.  Flags: 10.  [{\"com.cloud.agent.api.NetworkUsageAnswer\":{\"routerName\":\"r-224-VM\". \"bytesSent\":\"106496\". \"bytesReceived\":\"0\". \"result\":\"true\". \"details\":\"\". \"wait\":\"0\". }}] }\n\nThe KB MB and GB values will be printed out:\n\n2020-07-23 15:31:58. 593 DEBUG [c.c.a.t.Request] (AgentManager-Handler-12:null) (logid:) Seq 8-1863645820801253428: Processing: { Ans: .  MgmtId: 52238089807.  via: 8.  Ver: v1.  Flags: 10.  [{\"com.cloud.agent.api.NetworkUsageAnswer\":{\"routerName\":\"r-224-VM\". \"bytesSent\":\"(104.00 KB) 106496\". \"bytesReceived\":\"(0 bytes) 0\". \"result\":\"true\". \"details\":\"\". \"wait\":\"0\". }}] }\n\nFS: https://cwiki.apache.org/confluence/display/CLOUDSTACK/Human+Readable+Byte+sizes","date":"2020-08-13 18:25:16","modifiedFileCount":"55","status":"M","submitter":"Spaceman1984"},{"authorTime":"2020-09-17 12:47:07","codes":[{"authorDate":"2020-09-17 12:47:07","commitOrder":4,"curCode":"    protected DeployDestination plan(final long nodesCount, final DataCenter zone, final ServiceOffering offering) throws InsufficientServerCapacityException {\n        final int cpu_requested = offering.getCpu() * offering.getSpeed();\n        final long ram_requested = offering.getRamSize() * 1024L * 1024L;\n        List<HostVO> hosts = resourceManager.listAllHostsInOneZoneByType(Host.Type.Routing, zone.getId());\n        final Map<String, Pair<HostVO, Integer>> hosts_with_resevered_capacity = new ConcurrentHashMap<String, Pair<HostVO, Integer>>();\n        for (HostVO h : hosts) {\n            hosts_with_resevered_capacity.put(h.getUuid(), new Pair<HostVO, Integer>(h, 0));\n        }\n        boolean suitable_host_found = false;\n        for (int i = 1; i <= nodesCount + 1; i++) {\n            suitable_host_found = false;\n            for (Map.Entry<String, Pair<HostVO, Integer>> hostEntry : hosts_with_resevered_capacity.entrySet()) {\n                Pair<HostVO, Integer> hp = hostEntry.getValue();\n                HostVO h = hp.first();\n                if (!h.getHypervisorType().equals(clusterTemplate.getHypervisorType())) {\n                    continue;\n                }\n                hostDao.loadHostTags(h);\n                if (!Strings.isNullOrEmpty(offering.getHostTag()) && !(h.getHostTags() != null && h.getHostTags().contains(offering.getHostTag()))) {\n                    continue;\n                }\n                int reserved = hp.second();\n                reserved++;\n                ClusterVO cluster = clusterDao.findById(h.getClusterId());\n                ClusterDetailsVO cluster_detail_cpu = clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n                ClusterDetailsVO cluster_detail_ram = clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n                Float cpuOvercommitRatio = Float.parseFloat(cluster_detail_cpu.getValue());\n                Float memoryOvercommitRatio = Float.parseFloat(cluster_detail_ram.getValue());\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(String.format(\"Checking host ID: %s for capacity already reserved %d\", h.getUuid(), reserved));\n                }\n                if (capacityManager.checkIfHostHasCapacity(h.getId(), cpu_requested * reserved, ram_requested * reserved, false, cpuOvercommitRatio, memoryOvercommitRatio, true)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(String.format(\"Found host ID: %s for with enough capacity, CPU=%d RAM=%s\", h.getUuid(), cpu_requested * reserved, toHumanReadableSize(ram_requested * reserved)));\n                    }\n                    hostEntry.setValue(new Pair<HostVO, Integer>(h, reserved));\n                    suitable_host_found = true;\n                    break;\n                }\n            }\n            if (!suitable_host_found) {\n                if (LOGGER.isInfoEnabled()) {\n                    LOGGER.info(String.format(\"Suitable hosts not found in datacenter ID: %s for node %d, with offering ID: %s and hypervisor: %s\", zone.getUuid(), i, offering.getUuid(), clusterTemplate.getHypervisorType().toString()));\n                }\n                break;\n            }\n        }\n        if (suitable_host_found) {\n            if (LOGGER.isInfoEnabled()) {\n                LOGGER.info(String.format(\"Suitable hosts found in datacenter ID: %s, creating deployment destination\", zone.getUuid()));\n            }\n            return new DeployDestination(zone, null, null, null);\n        }\n        String msg = String.format(\"Cannot find enough capacity for Kubernetes cluster(requested cpu=%d memory=%s) with offering ID: %s and hypervisor: %s\",\n                cpu_requested * nodesCount, toHumanReadableSize(ram_requested * nodesCount), offering.getUuid(), clusterTemplate.getHypervisorType().toString());\n\n        LOGGER.warn(msg);\n        throw new InsufficientServerCapacityException(msg, DataCenter.class, zone.getId());\n    }\n","date":"2020-09-17 12:47:07","endLine":259,"groupId":"406","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"plan","params":"(finallongnodesCount@finalDataCenterzone@finalServiceOfferingoffering)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/d8/d41bdf7ac65158e9c647d5fa3d5ccd13561b82.src","preCode":"    protected DeployDestination plan(final long nodesCount, final DataCenter zone, final ServiceOffering offering) throws InsufficientServerCapacityException {\n        final int cpu_requested = offering.getCpu() * offering.getSpeed();\n        final long ram_requested = offering.getRamSize() * 1024L * 1024L;\n        List<HostVO> hosts = resourceManager.listAllHostsInOneZoneByType(Host.Type.Routing, zone.getId());\n        final Map<String, Pair<HostVO, Integer>> hosts_with_resevered_capacity = new ConcurrentHashMap<String, Pair<HostVO, Integer>>();\n        for (HostVO h : hosts) {\n            hosts_with_resevered_capacity.put(h.getUuid(), new Pair<HostVO, Integer>(h, 0));\n        }\n        boolean suitable_host_found = false;\n        for (int i = 1; i <= nodesCount + 1; i++) {\n            suitable_host_found = false;\n            for (Map.Entry<String, Pair<HostVO, Integer>> hostEntry : hosts_with_resevered_capacity.entrySet()) {\n                Pair<HostVO, Integer> hp = hostEntry.getValue();\n                HostVO h = hp.first();\n                if (!h.getHypervisorType().equals(clusterTemplate.getHypervisorType())) {\n                    continue;\n                }\n                hostDao.loadHostTags(h);\n                if (!Strings.isNullOrEmpty(offering.getHostTag()) && !(h.getHostTags() != null && h.getHostTags().contains(offering.getHostTag()))) {\n                    continue;\n                }\n                int reserved = hp.second();\n                reserved++;\n                ClusterVO cluster = clusterDao.findById(h.getClusterId());\n                ClusterDetailsVO cluster_detail_cpu = clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n                ClusterDetailsVO cluster_detail_ram = clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n                Float cpuOvercommitRatio = Float.parseFloat(cluster_detail_cpu.getValue());\n                Float memoryOvercommitRatio = Float.parseFloat(cluster_detail_ram.getValue());\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(String.format(\"Checking host ID: %s for capacity already reserved %d\", h.getUuid(), reserved));\n                }\n                if (capacityManager.checkIfHostHasCapacity(h.getId(), cpu_requested * reserved, ram_requested * reserved, false, cpuOvercommitRatio, memoryOvercommitRatio, true)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(String.format(\"Found host ID: %s for with enough capacity, CPU=%d RAM=%d\", h.getUuid(), cpu_requested * reserved, toHumanReadableSize(ram_requested * reserved)));\n                    }\n                    hostEntry.setValue(new Pair<HostVO, Integer>(h, reserved));\n                    suitable_host_found = true;\n                    break;\n                }\n            }\n            if (!suitable_host_found) {\n                if (LOGGER.isInfoEnabled()) {\n                    LOGGER.info(String.format(\"Suitable hosts not found in datacenter ID: %s for node %d, with offering ID: %s and hypervisor: %s\", zone.getUuid(), i, offering.getUuid(), clusterTemplate.getHypervisorType().toString()));\n                }\n                break;\n            }\n        }\n        if (suitable_host_found) {\n            if (LOGGER.isInfoEnabled()) {\n                LOGGER.info(String.format(\"Suitable hosts found in datacenter ID: %s, creating deployment destination\", zone.getUuid()));\n            }\n            return new DeployDestination(zone, null, null, null);\n        }\n        String msg = String.format(\"Cannot find enough capacity for Kubernetes cluster(requested cpu=%d memory=%d) with offering ID: %s and hypervisor: %s\",\n                cpu_requested * nodesCount, toHumanReadableSize(ram_requested * nodesCount), offering.getUuid(), clusterTemplate.getHypervisorType().toString());\n\n        LOGGER.warn(msg);\n        throw new InsufficientServerCapacityException(msg, DataCenter.class, zone.getId());\n    }\n","realPath":"plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterResourceModifierActionWorker.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":201,"status":"M"},{"authorDate":"2020-09-17 12:47:07","commitOrder":4,"curCode":"    private DeployDestination plan(final long nodesCount, final DataCenter zone, final ServiceOffering offering) throws InsufficientServerCapacityException {\n        final int cpu_requested = offering.getCpu() * offering.getSpeed();\n        final long ram_requested = offering.getRamSize() * 1024L * 1024L;\n        List<HostVO> hosts = resourceManager.listAllHostsInOneZoneByType(Type.Routing, zone.getId());\n        final Map<String, Pair<HostVO, Integer>> hosts_with_resevered_capacity = new ConcurrentHashMap<String, Pair<HostVO, Integer>>();\n        for (HostVO h : hosts) {\n            hosts_with_resevered_capacity.put(h.getUuid(), new Pair<HostVO, Integer>(h, 0));\n        }\n        boolean suitable_host_found = false;\n        Cluster planCluster = null;\n        for (int i = 1; i <= nodesCount + 1; i++) {\n            suitable_host_found = false;\n            for (Map.Entry<String, Pair<HostVO, Integer>> hostEntry : hosts_with_resevered_capacity.entrySet()) {\n                Pair<HostVO, Integer> hp = hostEntry.getValue();\n                HostVO h = hp.first();\n                hostDao.loadHostTags(h);\n                if (!Strings.isNullOrEmpty(offering.getHostTag()) && !(h.getHostTags() != null && h.getHostTags().contains(offering.getHostTag()))) {\n                    continue;\n                }\n                int reserved = hp.second();\n                reserved++;\n                ClusterVO cluster = clusterDao.findById(h.getClusterId());\n                ClusterDetailsVO cluster_detail_cpu = clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n                ClusterDetailsVO cluster_detail_ram = clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n                Float cpuOvercommitRatio = Float.parseFloat(cluster_detail_cpu.getValue());\n                Float memoryOvercommitRatio = Float.parseFloat(cluster_detail_ram.getValue());\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(String.format(\"Checking host ID: %s for capacity already reserved %d\", h.getUuid(), reserved));\n                }\n                if (capacityManager.checkIfHostHasCapacity(h.getId(), cpu_requested * reserved, ram_requested * reserved, false, cpuOvercommitRatio, memoryOvercommitRatio, true)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(String.format(\"Found host ID: %s for with enough capacity, CPU=%d RAM=%s\", h.getUuid(), cpu_requested * reserved, toHumanReadableSize(ram_requested * reserved)));\n                    }\n                    hostEntry.setValue(new Pair<HostVO, Integer>(h, reserved));\n                    suitable_host_found = true;\n                    planCluster = cluster;\n                    break;\n                }\n            }\n            if (!suitable_host_found) {\n                if (LOGGER.isInfoEnabled()) {\n                    LOGGER.info(String.format(\"Suitable hosts not found in datacenter ID: %s for node %d with offering ID: %s\", zone.getUuid(), i, offering.getUuid()));\n                }\n                break;\n            }\n        }\n        if (suitable_host_found) {\n            if (LOGGER.isInfoEnabled()) {\n                LOGGER.info(String.format(\"Suitable hosts found in datacenter ID: %s, creating deployment destination\", zone.getUuid()));\n            }\n            return new DeployDestination(zone, null, planCluster, null);\n        }\n        String msg = String.format(\"Cannot find enough capacity for Kubernetes cluster(requested cpu=%d memory=%s) with offering ID: %s\",\n                cpu_requested * nodesCount, toHumanReadableSize(ram_requested * nodesCount), offering.getUuid());\n        LOGGER.warn(msg);\n        throw new InsufficientServerCapacityException(msg, DataCenter.class, zone.getId());\n    }\n","date":"2020-09-17 12:47:07","endLine":565,"groupId":"406","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"plan","params":"(finallongnodesCount@finalDataCenterzone@finalServiceOfferingoffering)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/b0/5c782d1e80a3fcfa289892453e83868ef65edc.src","preCode":"    private DeployDestination plan(final long nodesCount, final DataCenter zone, final ServiceOffering offering) throws InsufficientServerCapacityException {\n        final int cpu_requested = offering.getCpu() * offering.getSpeed();\n        final long ram_requested = offering.getRamSize() * 1024L * 1024L;\n        List<HostVO> hosts = resourceManager.listAllHostsInOneZoneByType(Type.Routing, zone.getId());\n        final Map<String, Pair<HostVO, Integer>> hosts_with_resevered_capacity = new ConcurrentHashMap<String, Pair<HostVO, Integer>>();\n        for (HostVO h : hosts) {\n            hosts_with_resevered_capacity.put(h.getUuid(), new Pair<HostVO, Integer>(h, 0));\n        }\n        boolean suitable_host_found = false;\n        Cluster planCluster = null;\n        for (int i = 1; i <= nodesCount + 1; i++) {\n            suitable_host_found = false;\n            for (Map.Entry<String, Pair<HostVO, Integer>> hostEntry : hosts_with_resevered_capacity.entrySet()) {\n                Pair<HostVO, Integer> hp = hostEntry.getValue();\n                HostVO h = hp.first();\n                hostDao.loadHostTags(h);\n                if (!Strings.isNullOrEmpty(offering.getHostTag()) && !(h.getHostTags() != null && h.getHostTags().contains(offering.getHostTag()))) {\n                    continue;\n                }\n                int reserved = hp.second();\n                reserved++;\n                ClusterVO cluster = clusterDao.findById(h.getClusterId());\n                ClusterDetailsVO cluster_detail_cpu = clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n                ClusterDetailsVO cluster_detail_ram = clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n                Float cpuOvercommitRatio = Float.parseFloat(cluster_detail_cpu.getValue());\n                Float memoryOvercommitRatio = Float.parseFloat(cluster_detail_ram.getValue());\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(String.format(\"Checking host ID: %s for capacity already reserved %d\", h.getUuid(), reserved));\n                }\n                if (capacityManager.checkIfHostHasCapacity(h.getId(), cpu_requested * reserved, ram_requested * reserved, false, cpuOvercommitRatio, memoryOvercommitRatio, true)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(String.format(\"Found host ID: %s for with enough capacity, CPU=%d RAM=%d\", h.getUuid(), cpu_requested * reserved, toHumanReadableSize(ram_requested * reserved)));\n                    }\n                    hostEntry.setValue(new Pair<HostVO, Integer>(h, reserved));\n                    suitable_host_found = true;\n                    planCluster = cluster;\n                    break;\n                }\n            }\n            if (!suitable_host_found) {\n                if (LOGGER.isInfoEnabled()) {\n                    LOGGER.info(String.format(\"Suitable hosts not found in datacenter ID: %s for node %d with offering ID: %s\", zone.getUuid(), i, offering.getUuid()));\n                }\n                break;\n            }\n        }\n        if (suitable_host_found) {\n            if (LOGGER.isInfoEnabled()) {\n                LOGGER.info(String.format(\"Suitable hosts found in datacenter ID: %s, creating deployment destination\", zone.getUuid()));\n            }\n            return new DeployDestination(zone, null, planCluster, null);\n        }\n        String msg = String.format(\"Cannot find enough capacity for Kubernetes cluster(requested cpu=%d memory=%d) with offering ID: %s\",\n                cpu_requested * nodesCount, toHumanReadableSize(ram_requested * nodesCount), offering.getUuid());\n        LOGGER.warn(msg);\n        throw new InsufficientServerCapacityException(msg, DataCenter.class, zone.getId());\n    }\n","realPath":"plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":509,"status":"M"}],"commitId":"87e08f82249ed35c38a91dc86c33858f3914ff52","commitMessage":"@@@cks: fix logging exception (#4309)\n\nSigned-off-by: Abhishek Kumar <abhishek.mrt22@gmail.com>","date":"2020-09-17 12:47:07","modifiedFileCount":"2","status":"M","submitter":"Abhishek Kumar"},{"authorTime":"2020-09-29 17:03:58","codes":[{"authorDate":"2020-09-29 17:03:58","commitOrder":5,"curCode":"    protected DeployDestination plan(final long nodesCount, final DataCenter zone, final ServiceOffering offering) throws InsufficientServerCapacityException {\n        final int cpu_requested = offering.getCpu() * offering.getSpeed();\n        final long ram_requested = offering.getRamSize() * 1024L * 1024L;\n        List<HostVO> hosts = resourceManager.listAllHostsInOneZoneByType(Host.Type.Routing, zone.getId());\n        final Map<String, Pair<HostVO, Integer>> hosts_with_resevered_capacity = new ConcurrentHashMap<String, Pair<HostVO, Integer>>();\n        for (HostVO h : hosts) {\n            hosts_with_resevered_capacity.put(h.getUuid(), new Pair<HostVO, Integer>(h, 0));\n        }\n        boolean suitable_host_found = false;\n        for (int i = 1; i <= nodesCount; i++) {\n            suitable_host_found = false;\n            for (Map.Entry<String, Pair<HostVO, Integer>> hostEntry : hosts_with_resevered_capacity.entrySet()) {\n                Pair<HostVO, Integer> hp = hostEntry.getValue();\n                HostVO h = hp.first();\n                if (!h.getHypervisorType().equals(clusterTemplate.getHypervisorType())) {\n                    continue;\n                }\n                hostDao.loadHostTags(h);\n                if (!Strings.isNullOrEmpty(offering.getHostTag()) && !(h.getHostTags() != null && h.getHostTags().contains(offering.getHostTag()))) {\n                    continue;\n                }\n                int reserved = hp.second();\n                reserved++;\n                ClusterVO cluster = clusterDao.findById(h.getClusterId());\n                ClusterDetailsVO cluster_detail_cpu = clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n                ClusterDetailsVO cluster_detail_ram = clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n                Float cpuOvercommitRatio = Float.parseFloat(cluster_detail_cpu.getValue());\n                Float memoryOvercommitRatio = Float.parseFloat(cluster_detail_ram.getValue());\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(String.format(\"Checking host ID: %s for capacity already reserved %d\", h.getUuid(), reserved));\n                }\n                if (capacityManager.checkIfHostHasCapacity(h.getId(), cpu_requested * reserved, ram_requested * reserved, false, cpuOvercommitRatio, memoryOvercommitRatio, true)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(String.format(\"Found host ID: %s for with enough capacity, CPU=%d RAM=%s\", h.getUuid(), cpu_requested * reserved, toHumanReadableSize(ram_requested * reserved)));\n                    }\n                    hostEntry.setValue(new Pair<HostVO, Integer>(h, reserved));\n                    suitable_host_found = true;\n                    break;\n                }\n            }\n            if (!suitable_host_found) {\n                if (LOGGER.isInfoEnabled()) {\n                    LOGGER.info(String.format(\"Suitable hosts not found in datacenter ID: %s for node %d, with offering ID: %s and hypervisor: %s\", zone.getUuid(), i, offering.getUuid(), clusterTemplate.getHypervisorType().toString()));\n                }\n                break;\n            }\n        }\n        if (suitable_host_found) {\n            if (LOGGER.isInfoEnabled()) {\n                LOGGER.info(String.format(\"Suitable hosts found in datacenter ID: %s, creating deployment destination\", zone.getUuid()));\n            }\n            return new DeployDestination(zone, null, null, null);\n        }\n        String msg = String.format(\"Cannot find enough capacity for Kubernetes cluster(requested cpu=%d memory=%s) with offering ID: %s and hypervisor: %s\",\n                cpu_requested * nodesCount, toHumanReadableSize(ram_requested * nodesCount), offering.getUuid(), clusterTemplate.getHypervisorType().toString());\n\n        LOGGER.warn(msg);\n        throw new InsufficientServerCapacityException(msg, DataCenter.class, zone.getId());\n    }\n","date":"2020-09-29 17:03:58","endLine":259,"groupId":"406","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"plan","params":"(finallongnodesCount@finalDataCenterzone@finalServiceOfferingoffering)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/52/828a7c5bb39ef95b17cdd6ede2ab3acafbdd56.src","preCode":"    protected DeployDestination plan(final long nodesCount, final DataCenter zone, final ServiceOffering offering) throws InsufficientServerCapacityException {\n        final int cpu_requested = offering.getCpu() * offering.getSpeed();\n        final long ram_requested = offering.getRamSize() * 1024L * 1024L;\n        List<HostVO> hosts = resourceManager.listAllHostsInOneZoneByType(Host.Type.Routing, zone.getId());\n        final Map<String, Pair<HostVO, Integer>> hosts_with_resevered_capacity = new ConcurrentHashMap<String, Pair<HostVO, Integer>>();\n        for (HostVO h : hosts) {\n            hosts_with_resevered_capacity.put(h.getUuid(), new Pair<HostVO, Integer>(h, 0));\n        }\n        boolean suitable_host_found = false;\n        for (int i = 1; i <= nodesCount + 1; i++) {\n            suitable_host_found = false;\n            for (Map.Entry<String, Pair<HostVO, Integer>> hostEntry : hosts_with_resevered_capacity.entrySet()) {\n                Pair<HostVO, Integer> hp = hostEntry.getValue();\n                HostVO h = hp.first();\n                if (!h.getHypervisorType().equals(clusterTemplate.getHypervisorType())) {\n                    continue;\n                }\n                hostDao.loadHostTags(h);\n                if (!Strings.isNullOrEmpty(offering.getHostTag()) && !(h.getHostTags() != null && h.getHostTags().contains(offering.getHostTag()))) {\n                    continue;\n                }\n                int reserved = hp.second();\n                reserved++;\n                ClusterVO cluster = clusterDao.findById(h.getClusterId());\n                ClusterDetailsVO cluster_detail_cpu = clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n                ClusterDetailsVO cluster_detail_ram = clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n                Float cpuOvercommitRatio = Float.parseFloat(cluster_detail_cpu.getValue());\n                Float memoryOvercommitRatio = Float.parseFloat(cluster_detail_ram.getValue());\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(String.format(\"Checking host ID: %s for capacity already reserved %d\", h.getUuid(), reserved));\n                }\n                if (capacityManager.checkIfHostHasCapacity(h.getId(), cpu_requested * reserved, ram_requested * reserved, false, cpuOvercommitRatio, memoryOvercommitRatio, true)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(String.format(\"Found host ID: %s for with enough capacity, CPU=%d RAM=%s\", h.getUuid(), cpu_requested * reserved, toHumanReadableSize(ram_requested * reserved)));\n                    }\n                    hostEntry.setValue(new Pair<HostVO, Integer>(h, reserved));\n                    suitable_host_found = true;\n                    break;\n                }\n            }\n            if (!suitable_host_found) {\n                if (LOGGER.isInfoEnabled()) {\n                    LOGGER.info(String.format(\"Suitable hosts not found in datacenter ID: %s for node %d, with offering ID: %s and hypervisor: %s\", zone.getUuid(), i, offering.getUuid(), clusterTemplate.getHypervisorType().toString()));\n                }\n                break;\n            }\n        }\n        if (suitable_host_found) {\n            if (LOGGER.isInfoEnabled()) {\n                LOGGER.info(String.format(\"Suitable hosts found in datacenter ID: %s, creating deployment destination\", zone.getUuid()));\n            }\n            return new DeployDestination(zone, null, null, null);\n        }\n        String msg = String.format(\"Cannot find enough capacity for Kubernetes cluster(requested cpu=%d memory=%s) with offering ID: %s and hypervisor: %s\",\n                cpu_requested * nodesCount, toHumanReadableSize(ram_requested * nodesCount), offering.getUuid(), clusterTemplate.getHypervisorType().toString());\n\n        LOGGER.warn(msg);\n        throw new InsufficientServerCapacityException(msg, DataCenter.class, zone.getId());\n    }\n","realPath":"plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterResourceModifierActionWorker.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":201,"status":"M"},{"authorDate":"2020-09-29 17:03:58","commitOrder":5,"curCode":"    private DeployDestination plan(final long nodesCount, final DataCenter zone, final ServiceOffering offering) throws InsufficientServerCapacityException {\n        final int cpu_requested = offering.getCpu() * offering.getSpeed();\n        final long ram_requested = offering.getRamSize() * 1024L * 1024L;\n        List<HostVO> hosts = resourceManager.listAllHostsInOneZoneByType(Type.Routing, zone.getId());\n        final Map<String, Pair<HostVO, Integer>> hosts_with_resevered_capacity = new ConcurrentHashMap<String, Pair<HostVO, Integer>>();\n        for (HostVO h : hosts) {\n            hosts_with_resevered_capacity.put(h.getUuid(), new Pair<HostVO, Integer>(h, 0));\n        }\n        boolean suitable_host_found = false;\n        Cluster planCluster = null;\n        for (int i = 1; i <= nodesCount; i++) {\n            suitable_host_found = false;\n            for (Map.Entry<String, Pair<HostVO, Integer>> hostEntry : hosts_with_resevered_capacity.entrySet()) {\n                Pair<HostVO, Integer> hp = hostEntry.getValue();\n                HostVO h = hp.first();\n                hostDao.loadHostTags(h);\n                if (!Strings.isNullOrEmpty(offering.getHostTag()) && !(h.getHostTags() != null && h.getHostTags().contains(offering.getHostTag()))) {\n                    continue;\n                }\n                int reserved = hp.second();\n                reserved++;\n                ClusterVO cluster = clusterDao.findById(h.getClusterId());\n                ClusterDetailsVO cluster_detail_cpu = clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n                ClusterDetailsVO cluster_detail_ram = clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n                Float cpuOvercommitRatio = Float.parseFloat(cluster_detail_cpu.getValue());\n                Float memoryOvercommitRatio = Float.parseFloat(cluster_detail_ram.getValue());\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(String.format(\"Checking host ID: %s for capacity already reserved %d\", h.getUuid(), reserved));\n                }\n                if (capacityManager.checkIfHostHasCapacity(h.getId(), cpu_requested * reserved, ram_requested * reserved, false, cpuOvercommitRatio, memoryOvercommitRatio, true)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(String.format(\"Found host ID: %s for with enough capacity, CPU=%d RAM=%s\", h.getUuid(), cpu_requested * reserved, toHumanReadableSize(ram_requested * reserved)));\n                    }\n                    hostEntry.setValue(new Pair<HostVO, Integer>(h, reserved));\n                    suitable_host_found = true;\n                    planCluster = cluster;\n                    break;\n                }\n            }\n            if (!suitable_host_found) {\n                if (LOGGER.isInfoEnabled()) {\n                    LOGGER.info(String.format(\"Suitable hosts not found in datacenter ID: %s for node %d with offering ID: %s\", zone.getUuid(), i, offering.getUuid()));\n                }\n                break;\n            }\n        }\n        if (suitable_host_found) {\n            if (LOGGER.isInfoEnabled()) {\n                LOGGER.info(String.format(\"Suitable hosts found in datacenter ID: %s, creating deployment destination\", zone.getUuid()));\n            }\n            return new DeployDestination(zone, null, planCluster, null);\n        }\n        String msg = String.format(\"Cannot find enough capacity for Kubernetes cluster(requested cpu=%d memory=%s) with offering ID: %s\",\n                cpu_requested * nodesCount, toHumanReadableSize(ram_requested * nodesCount), offering.getUuid());\n        LOGGER.warn(msg);\n        throw new InsufficientServerCapacityException(msg, DataCenter.class, zone.getId());\n    }\n","date":"2020-09-29 17:03:58","endLine":565,"groupId":"406","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"plan","params":"(finallongnodesCount@finalDataCenterzone@finalServiceOfferingoffering)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/88/96399ba4f4627f00c70578aa18784a885eddc7.src","preCode":"    private DeployDestination plan(final long nodesCount, final DataCenter zone, final ServiceOffering offering) throws InsufficientServerCapacityException {\n        final int cpu_requested = offering.getCpu() * offering.getSpeed();\n        final long ram_requested = offering.getRamSize() * 1024L * 1024L;\n        List<HostVO> hosts = resourceManager.listAllHostsInOneZoneByType(Type.Routing, zone.getId());\n        final Map<String, Pair<HostVO, Integer>> hosts_with_resevered_capacity = new ConcurrentHashMap<String, Pair<HostVO, Integer>>();\n        for (HostVO h : hosts) {\n            hosts_with_resevered_capacity.put(h.getUuid(), new Pair<HostVO, Integer>(h, 0));\n        }\n        boolean suitable_host_found = false;\n        Cluster planCluster = null;\n        for (int i = 1; i <= nodesCount + 1; i++) {\n            suitable_host_found = false;\n            for (Map.Entry<String, Pair<HostVO, Integer>> hostEntry : hosts_with_resevered_capacity.entrySet()) {\n                Pair<HostVO, Integer> hp = hostEntry.getValue();\n                HostVO h = hp.first();\n                hostDao.loadHostTags(h);\n                if (!Strings.isNullOrEmpty(offering.getHostTag()) && !(h.getHostTags() != null && h.getHostTags().contains(offering.getHostTag()))) {\n                    continue;\n                }\n                int reserved = hp.second();\n                reserved++;\n                ClusterVO cluster = clusterDao.findById(h.getClusterId());\n                ClusterDetailsVO cluster_detail_cpu = clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n                ClusterDetailsVO cluster_detail_ram = clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n                Float cpuOvercommitRatio = Float.parseFloat(cluster_detail_cpu.getValue());\n                Float memoryOvercommitRatio = Float.parseFloat(cluster_detail_ram.getValue());\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(String.format(\"Checking host ID: %s for capacity already reserved %d\", h.getUuid(), reserved));\n                }\n                if (capacityManager.checkIfHostHasCapacity(h.getId(), cpu_requested * reserved, ram_requested * reserved, false, cpuOvercommitRatio, memoryOvercommitRatio, true)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(String.format(\"Found host ID: %s for with enough capacity, CPU=%d RAM=%s\", h.getUuid(), cpu_requested * reserved, toHumanReadableSize(ram_requested * reserved)));\n                    }\n                    hostEntry.setValue(new Pair<HostVO, Integer>(h, reserved));\n                    suitable_host_found = true;\n                    planCluster = cluster;\n                    break;\n                }\n            }\n            if (!suitable_host_found) {\n                if (LOGGER.isInfoEnabled()) {\n                    LOGGER.info(String.format(\"Suitable hosts not found in datacenter ID: %s for node %d with offering ID: %s\", zone.getUuid(), i, offering.getUuid()));\n                }\n                break;\n            }\n        }\n        if (suitable_host_found) {\n            if (LOGGER.isInfoEnabled()) {\n                LOGGER.info(String.format(\"Suitable hosts found in datacenter ID: %s, creating deployment destination\", zone.getUuid()));\n            }\n            return new DeployDestination(zone, null, planCluster, null);\n        }\n        String msg = String.format(\"Cannot find enough capacity for Kubernetes cluster(requested cpu=%d memory=%s) with offering ID: %s\",\n                cpu_requested * nodesCount, toHumanReadableSize(ram_requested * nodesCount), offering.getUuid());\n        LOGGER.warn(msg);\n        throw new InsufficientServerCapacityException(msg, DataCenter.class, zone.getId());\n    }\n","realPath":"plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":509,"status":"M"}],"commitId":"b3bafffff3578f4cfe80f640076bcecd407e4b99","commitMessage":"@@@Merge remote-tracking branch 'origin/4.14'\n","date":"2020-09-29 17:03:58","modifiedFileCount":"15","status":"M","submitter":"Rohit Yadav"},{"authorTime":"2020-09-29 17:03:58","codes":[{"authorDate":"2020-10-27 14:45:43","commitOrder":6,"curCode":"    protected DeployDestination plan(final long nodesCount, final DataCenter zone, final ServiceOffering offering) throws InsufficientServerCapacityException {\n        final int cpu_requested = offering.getCpu() * offering.getSpeed();\n        final long ram_requested = offering.getRamSize() * 1024L * 1024L;\n        List<HostVO> hosts = resourceManager.listAllHostsInOneZoneByType(Host.Type.Routing, zone.getId());\n        final Map<String, Pair<HostVO, Integer>> hosts_with_resevered_capacity = new ConcurrentHashMap<String, Pair<HostVO, Integer>>();\n        for (HostVO h : hosts) {\n            hosts_with_resevered_capacity.put(h.getUuid(), new Pair<HostVO, Integer>(h, 0));\n        }\n        boolean suitable_host_found = false;\n        for (int i = 1; i <= nodesCount; i++) {\n            suitable_host_found = false;\n            for (Map.Entry<String, Pair<HostVO, Integer>> hostEntry : hosts_with_resevered_capacity.entrySet()) {\n                Pair<HostVO, Integer> hp = hostEntry.getValue();\n                HostVO h = hp.first();\n                if (!h.getHypervisorType().equals(clusterTemplate.getHypervisorType())) {\n                    continue;\n                }\n                hostDao.loadHostTags(h);\n                if (!Strings.isNullOrEmpty(offering.getHostTag()) && !(h.getHostTags() != null && h.getHostTags().contains(offering.getHostTag()))) {\n                    continue;\n                }\n                int reserved = hp.second();\n                reserved++;\n                ClusterVO cluster = clusterDao.findById(h.getClusterId());\n                ClusterDetailsVO cluster_detail_cpu = clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n                ClusterDetailsVO cluster_detail_ram = clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n                Float cpuOvercommitRatio = Float.parseFloat(cluster_detail_cpu.getValue());\n                Float memoryOvercommitRatio = Float.parseFloat(cluster_detail_ram.getValue());\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(String.format(\"Checking host : %s for capacity already reserved %d\", h.getName(), reserved));\n                }\n                if (capacityManager.checkIfHostHasCapacity(h.getId(), cpu_requested * reserved, ram_requested * reserved, false, cpuOvercommitRatio, memoryOvercommitRatio, true)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(String.format(\"Found host : %s for with enough capacity, CPU=%d RAM=%s\", h.getName(), cpu_requested * reserved, toHumanReadableSize(ram_requested * reserved)));\n                    }\n                    hostEntry.setValue(new Pair<HostVO, Integer>(h, reserved));\n                    suitable_host_found = true;\n                    break;\n                }\n            }\n            if (!suitable_host_found) {\n                if (LOGGER.isInfoEnabled()) {\n                    LOGGER.info(String.format(\"Suitable hosts not found in datacenter : %s for node %d, with offering : %s and hypervisor: %s\",\n                        zone.getName(), i, offering.getName(), clusterTemplate.getHypervisorType().toString()));\n                }\n                break;\n            }\n        }\n        if (suitable_host_found) {\n            if (LOGGER.isInfoEnabled()) {\n                LOGGER.info(String.format(\"Suitable hosts found in datacenter : %s, creating deployment destination\", zone.getName()));\n            }\n            return new DeployDestination(zone, null, null, null);\n        }\n        String msg = String.format(\"Cannot find enough capacity for Kubernetes cluster(requested cpu=%d memory=%s) with offering : %s and hypervisor: %s\",\n                cpu_requested * nodesCount, toHumanReadableSize(ram_requested * nodesCount), offering.getName(), clusterTemplate.getHypervisorType().toString());\n\n        LOGGER.warn(msg);\n        throw new InsufficientServerCapacityException(msg, DataCenter.class, zone.getId());\n    }\n","date":"2020-10-27 14:45:43","endLine":260,"groupId":"124213","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"plan","params":"(finallongnodesCount@finalDataCenterzone@finalServiceOfferingoffering)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/b7/15f09d7b88fa246b85976cba4ab28c0700cd61.src","preCode":"    protected DeployDestination plan(final long nodesCount, final DataCenter zone, final ServiceOffering offering) throws InsufficientServerCapacityException {\n        final int cpu_requested = offering.getCpu() * offering.getSpeed();\n        final long ram_requested = offering.getRamSize() * 1024L * 1024L;\n        List<HostVO> hosts = resourceManager.listAllHostsInOneZoneByType(Host.Type.Routing, zone.getId());\n        final Map<String, Pair<HostVO, Integer>> hosts_with_resevered_capacity = new ConcurrentHashMap<String, Pair<HostVO, Integer>>();\n        for (HostVO h : hosts) {\n            hosts_with_resevered_capacity.put(h.getUuid(), new Pair<HostVO, Integer>(h, 0));\n        }\n        boolean suitable_host_found = false;\n        for (int i = 1; i <= nodesCount; i++) {\n            suitable_host_found = false;\n            for (Map.Entry<String, Pair<HostVO, Integer>> hostEntry : hosts_with_resevered_capacity.entrySet()) {\n                Pair<HostVO, Integer> hp = hostEntry.getValue();\n                HostVO h = hp.first();\n                if (!h.getHypervisorType().equals(clusterTemplate.getHypervisorType())) {\n                    continue;\n                }\n                hostDao.loadHostTags(h);\n                if (!Strings.isNullOrEmpty(offering.getHostTag()) && !(h.getHostTags() != null && h.getHostTags().contains(offering.getHostTag()))) {\n                    continue;\n                }\n                int reserved = hp.second();\n                reserved++;\n                ClusterVO cluster = clusterDao.findById(h.getClusterId());\n                ClusterDetailsVO cluster_detail_cpu = clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n                ClusterDetailsVO cluster_detail_ram = clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n                Float cpuOvercommitRatio = Float.parseFloat(cluster_detail_cpu.getValue());\n                Float memoryOvercommitRatio = Float.parseFloat(cluster_detail_ram.getValue());\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(String.format(\"Checking host ID: %s for capacity already reserved %d\", h.getUuid(), reserved));\n                }\n                if (capacityManager.checkIfHostHasCapacity(h.getId(), cpu_requested * reserved, ram_requested * reserved, false, cpuOvercommitRatio, memoryOvercommitRatio, true)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(String.format(\"Found host ID: %s for with enough capacity, CPU=%d RAM=%s\", h.getUuid(), cpu_requested * reserved, toHumanReadableSize(ram_requested * reserved)));\n                    }\n                    hostEntry.setValue(new Pair<HostVO, Integer>(h, reserved));\n                    suitable_host_found = true;\n                    break;\n                }\n            }\n            if (!suitable_host_found) {\n                if (LOGGER.isInfoEnabled()) {\n                    LOGGER.info(String.format(\"Suitable hosts not found in datacenter ID: %s for node %d, with offering ID: %s and hypervisor: %s\", zone.getUuid(), i, offering.getUuid(), clusterTemplate.getHypervisorType().toString()));\n                }\n                break;\n            }\n        }\n        if (suitable_host_found) {\n            if (LOGGER.isInfoEnabled()) {\n                LOGGER.info(String.format(\"Suitable hosts found in datacenter ID: %s, creating deployment destination\", zone.getUuid()));\n            }\n            return new DeployDestination(zone, null, null, null);\n        }\n        String msg = String.format(\"Cannot find enough capacity for Kubernetes cluster(requested cpu=%d memory=%s) with offering ID: %s and hypervisor: %s\",\n                cpu_requested * nodesCount, toHumanReadableSize(ram_requested * nodesCount), offering.getUuid(), clusterTemplate.getHypervisorType().toString());\n\n        LOGGER.warn(msg);\n        throw new InsufficientServerCapacityException(msg, DataCenter.class, zone.getId());\n    }\n","realPath":"plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterResourceModifierActionWorker.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":201,"status":"M"},{"authorDate":"2020-09-29 17:03:58","commitOrder":6,"curCode":"    private DeployDestination plan(final long nodesCount, final DataCenter zone, final ServiceOffering offering) throws InsufficientServerCapacityException {\n        final int cpu_requested = offering.getCpu() * offering.getSpeed();\n        final long ram_requested = offering.getRamSize() * 1024L * 1024L;\n        List<HostVO> hosts = resourceManager.listAllHostsInOneZoneByType(Type.Routing, zone.getId());\n        final Map<String, Pair<HostVO, Integer>> hosts_with_resevered_capacity = new ConcurrentHashMap<String, Pair<HostVO, Integer>>();\n        for (HostVO h : hosts) {\n            hosts_with_resevered_capacity.put(h.getUuid(), new Pair<HostVO, Integer>(h, 0));\n        }\n        boolean suitable_host_found = false;\n        Cluster planCluster = null;\n        for (int i = 1; i <= nodesCount; i++) {\n            suitable_host_found = false;\n            for (Map.Entry<String, Pair<HostVO, Integer>> hostEntry : hosts_with_resevered_capacity.entrySet()) {\n                Pair<HostVO, Integer> hp = hostEntry.getValue();\n                HostVO h = hp.first();\n                hostDao.loadHostTags(h);\n                if (!Strings.isNullOrEmpty(offering.getHostTag()) && !(h.getHostTags() != null && h.getHostTags().contains(offering.getHostTag()))) {\n                    continue;\n                }\n                int reserved = hp.second();\n                reserved++;\n                ClusterVO cluster = clusterDao.findById(h.getClusterId());\n                ClusterDetailsVO cluster_detail_cpu = clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n                ClusterDetailsVO cluster_detail_ram = clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n                Float cpuOvercommitRatio = Float.parseFloat(cluster_detail_cpu.getValue());\n                Float memoryOvercommitRatio = Float.parseFloat(cluster_detail_ram.getValue());\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(String.format(\"Checking host ID: %s for capacity already reserved %d\", h.getUuid(), reserved));\n                }\n                if (capacityManager.checkIfHostHasCapacity(h.getId(), cpu_requested * reserved, ram_requested * reserved, false, cpuOvercommitRatio, memoryOvercommitRatio, true)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(String.format(\"Found host ID: %s for with enough capacity, CPU=%d RAM=%s\", h.getUuid(), cpu_requested * reserved, toHumanReadableSize(ram_requested * reserved)));\n                    }\n                    hostEntry.setValue(new Pair<HostVO, Integer>(h, reserved));\n                    suitable_host_found = true;\n                    planCluster = cluster;\n                    break;\n                }\n            }\n            if (!suitable_host_found) {\n                if (LOGGER.isInfoEnabled()) {\n                    LOGGER.info(String.format(\"Suitable hosts not found in datacenter ID: %s for node %d with offering ID: %s\", zone.getUuid(), i, offering.getUuid()));\n                }\n                break;\n            }\n        }\n        if (suitable_host_found) {\n            if (LOGGER.isInfoEnabled()) {\n                LOGGER.info(String.format(\"Suitable hosts found in datacenter ID: %s, creating deployment destination\", zone.getUuid()));\n            }\n            return new DeployDestination(zone, null, planCluster, null);\n        }\n        String msg = String.format(\"Cannot find enough capacity for Kubernetes cluster(requested cpu=%d memory=%s) with offering ID: %s\",\n                cpu_requested * nodesCount, toHumanReadableSize(ram_requested * nodesCount), offering.getUuid());\n        LOGGER.warn(msg);\n        throw new InsufficientServerCapacityException(msg, DataCenter.class, zone.getId());\n    }\n","date":"2020-09-29 17:03:58","endLine":565,"groupId":"124213","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"plan","params":"(finallongnodesCount@finalDataCenterzone@finalServiceOfferingoffering)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/88/96399ba4f4627f00c70578aa18784a885eddc7.src","preCode":"    private DeployDestination plan(final long nodesCount, final DataCenter zone, final ServiceOffering offering) throws InsufficientServerCapacityException {\n        final int cpu_requested = offering.getCpu() * offering.getSpeed();\n        final long ram_requested = offering.getRamSize() * 1024L * 1024L;\n        List<HostVO> hosts = resourceManager.listAllHostsInOneZoneByType(Type.Routing, zone.getId());\n        final Map<String, Pair<HostVO, Integer>> hosts_with_resevered_capacity = new ConcurrentHashMap<String, Pair<HostVO, Integer>>();\n        for (HostVO h : hosts) {\n            hosts_with_resevered_capacity.put(h.getUuid(), new Pair<HostVO, Integer>(h, 0));\n        }\n        boolean suitable_host_found = false;\n        Cluster planCluster = null;\n        for (int i = 1; i <= nodesCount; i++) {\n            suitable_host_found = false;\n            for (Map.Entry<String, Pair<HostVO, Integer>> hostEntry : hosts_with_resevered_capacity.entrySet()) {\n                Pair<HostVO, Integer> hp = hostEntry.getValue();\n                HostVO h = hp.first();\n                hostDao.loadHostTags(h);\n                if (!Strings.isNullOrEmpty(offering.getHostTag()) && !(h.getHostTags() != null && h.getHostTags().contains(offering.getHostTag()))) {\n                    continue;\n                }\n                int reserved = hp.second();\n                reserved++;\n                ClusterVO cluster = clusterDao.findById(h.getClusterId());\n                ClusterDetailsVO cluster_detail_cpu = clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n                ClusterDetailsVO cluster_detail_ram = clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n                Float cpuOvercommitRatio = Float.parseFloat(cluster_detail_cpu.getValue());\n                Float memoryOvercommitRatio = Float.parseFloat(cluster_detail_ram.getValue());\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(String.format(\"Checking host ID: %s for capacity already reserved %d\", h.getUuid(), reserved));\n                }\n                if (capacityManager.checkIfHostHasCapacity(h.getId(), cpu_requested * reserved, ram_requested * reserved, false, cpuOvercommitRatio, memoryOvercommitRatio, true)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(String.format(\"Found host ID: %s for with enough capacity, CPU=%d RAM=%s\", h.getUuid(), cpu_requested * reserved, toHumanReadableSize(ram_requested * reserved)));\n                    }\n                    hostEntry.setValue(new Pair<HostVO, Integer>(h, reserved));\n                    suitable_host_found = true;\n                    planCluster = cluster;\n                    break;\n                }\n            }\n            if (!suitable_host_found) {\n                if (LOGGER.isInfoEnabled()) {\n                    LOGGER.info(String.format(\"Suitable hosts not found in datacenter ID: %s for node %d with offering ID: %s\", zone.getUuid(), i, offering.getUuid()));\n                }\n                break;\n            }\n        }\n        if (suitable_host_found) {\n            if (LOGGER.isInfoEnabled()) {\n                LOGGER.info(String.format(\"Suitable hosts found in datacenter ID: %s, creating deployment destination\", zone.getUuid()));\n            }\n            return new DeployDestination(zone, null, planCluster, null);\n        }\n        String msg = String.format(\"Cannot find enough capacity for Kubernetes cluster(requested cpu=%d memory=%s) with offering ID: %s\",\n                cpu_requested * nodesCount, toHumanReadableSize(ram_requested * nodesCount), offering.getUuid());\n        LOGGER.warn(msg);\n        throw new InsufficientServerCapacityException(msg, DataCenter.class, zone.getId());\n    }\n","realPath":"plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":509,"status":"N"}],"commitId":"86f2b796cfd4d6758dff322ce31ae880a9c4e02b","commitMessage":"@@@CKS : More log changes from uuid to name (#4415)\n\n","date":"2020-10-27 14:45:43","modifiedFileCount":"9","status":"M","submitter":"davidjumani"}]
