[{"authorTime":"2018-01-20 05:49:27","codes":[{"authorDate":"2018-01-20 05:49:27","commitOrder":1,"curCode":"    public void recalculateCapacity() {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        try {\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"recalculating system capacity\");\n                s_logger.debug(\"Executing cpu/ram capacity update\");\n            }\n\n            \r\n            \r\n            List<HostVO> hosts = _resourceMgr.listAllNotInMaintenanceHostsInOneZone(Host.Type.Routing, null);\n            if (hosts != null) {\n                for (HostVO host : hosts) {\n                    _capacityMgr.updateCapacityForHost(host);\n                }\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing cpu/ram capacity update\");\n                s_logger.debug(\"Executing storage capacity update\");\n            }\n            \r\n            List<StoragePoolVO> storagePools = _storagePoolDao.listAll();\n            for (StoragePoolVO pool : storagePools) {\n                long disk = _capacityMgr.getAllocatedPoolCapacity(pool, null);\n                if (pool.isShared()) {\n                    _storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_STORAGE_ALLOCATED, disk);\n                } else {\n                    _storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_LOCAL_STORAGE, disk);\n                }\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing storage capacity update\");\n                s_logger.debug(\"Executing capacity updates for public ip and Vlans\");\n            }\n\n            List<DataCenterVO> datacenters = _dcDao.listAll();\n            for (DataCenterVO datacenter : datacenters) {\n                long dcId = datacenter.getId();\n\n                \r\n                \r\n                \r\n                \r\n                \r\n\n                \r\n                if (datacenter.getNetworkType() == NetworkType.Advanced) {\n                    createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_VIRTUAL_NETWORK_PUBLIC_IP, datacenter.getAllocationState());\n                }\n\n                \r\n                createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_DIRECT_ATTACHED_PUBLIC_IP, datacenter.getAllocationState());\n\n                if (datacenter.getNetworkType() == NetworkType.Advanced) {\n                    \r\n                    createOrUpdateVlanCapacity(dcId, datacenter.getAllocationState());\n                }\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done capacity updates for public ip and Vlans\");\n                s_logger.debug(\"Executing capacity updates for private ip\");\n            }\n\n            \r\n            List<HostPodVO> pods = _podDao.listAll();\n            for (HostPodVO pod : pods) {\n                long podId = pod.getId();\n                long dcId = pod.getDataCenterId();\n\n                createOrUpdateIpCapacity(dcId, podId, Capacity.CAPACITY_TYPE_PRIVATE_IP, _configMgr.findPodAllocationState(pod));\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing capacity updates for private ip\");\n                s_logger.debug(\"Done recalculating system capacity\");\n            }\n\n        } catch (Throwable t) {\n            s_logger.error(\"Caught exception in recalculating capacity\", t);\n        }\n    }\n","date":"2018-01-20 05:49:27","endLine":350,"groupId":"23680","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"recalculateCapacity","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/a5/8a4f8b0f91450e931ce96c942160b57ca0b1fa.src","preCode":"    public void recalculateCapacity() {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        try {\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"recalculating system capacity\");\n                s_logger.debug(\"Executing cpu/ram capacity update\");\n            }\n\n            \r\n            \r\n            List<HostVO> hosts = _resourceMgr.listAllNotInMaintenanceHostsInOneZone(Host.Type.Routing, null);\n            if (hosts != null) {\n                for (HostVO host : hosts) {\n                    _capacityMgr.updateCapacityForHost(host);\n                }\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing cpu/ram capacity update\");\n                s_logger.debug(\"Executing storage capacity update\");\n            }\n            \r\n            List<StoragePoolVO> storagePools = _storagePoolDao.listAll();\n            for (StoragePoolVO pool : storagePools) {\n                long disk = _capacityMgr.getAllocatedPoolCapacity(pool, null);\n                if (pool.isShared()) {\n                    _storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_STORAGE_ALLOCATED, disk);\n                } else {\n                    _storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_LOCAL_STORAGE, disk);\n                }\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing storage capacity update\");\n                s_logger.debug(\"Executing capacity updates for public ip and Vlans\");\n            }\n\n            List<DataCenterVO> datacenters = _dcDao.listAll();\n            for (DataCenterVO datacenter : datacenters) {\n                long dcId = datacenter.getId();\n\n                \r\n                \r\n                \r\n                \r\n                \r\n\n                \r\n                if (datacenter.getNetworkType() == NetworkType.Advanced) {\n                    createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_VIRTUAL_NETWORK_PUBLIC_IP, datacenter.getAllocationState());\n                }\n\n                \r\n                createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_DIRECT_ATTACHED_PUBLIC_IP, datacenter.getAllocationState());\n\n                if (datacenter.getNetworkType() == NetworkType.Advanced) {\n                    \r\n                    createOrUpdateVlanCapacity(dcId, datacenter.getAllocationState());\n                }\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done capacity updates for public ip and Vlans\");\n                s_logger.debug(\"Executing capacity updates for private ip\");\n            }\n\n            \r\n            List<HostPodVO> pods = _podDao.listAll();\n            for (HostPodVO pod : pods) {\n                long podId = pod.getId();\n                long dcId = pod.getDataCenterId();\n\n                createOrUpdateIpCapacity(dcId, podId, Capacity.CAPACITY_TYPE_PRIVATE_IP, _configMgr.findPodAllocationState(pod));\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing capacity updates for private ip\");\n                s_logger.debug(\"Done recalculating system capacity\");\n            }\n\n        } catch (Throwable t) {\n            s_logger.error(\"Caught exception in recalculating capacity\", t);\n        }\n    }\n","realPath":"server/src/main/java/com/cloud/alert/AlertManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":261,"status":"B"},{"authorDate":"2018-01-20 05:49:27","commitOrder":1,"curCode":"    public void updateCapacityForHost(final Host host) {\n        \r\n        List<ServiceOfferingVO> offerings = _offeringsDao.listAllIncludingRemoved();\n        Map<Long, ServiceOfferingVO> offeringsMap = new HashMap<Long, ServiceOfferingVO>();\n        for (ServiceOfferingVO offering : offerings) {\n            offeringsMap.put(offering.getId(), offering);\n        }\n\n        long usedCpuCore = 0;\n        long reservedCpuCore = 0;\n        long usedCpu = 0;\n        long usedMemory = 0;\n        long reservedMemory = 0;\n        long reservedCpu = 0;\n        final CapacityState capacityState = (host.getResourceState() == ResourceState.Enabled) ? CapacityState.Enabled : CapacityState.Disabled;\n\n        List<VMInstanceVO> vms = _vmDao.listUpByHostId(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vms.size() + \" VMs on host \" + host.getId());\n        }\n\n        ClusterVO cluster = _clusterDao.findById(host.getClusterId());\n        ClusterDetailsVO clusterDetailCpu = _clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n        ClusterDetailsVO clusterDetailRam = _clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n        Float clusterCpuOvercommitRatio = Float.parseFloat(clusterDetailCpu.getValue());\n        Float clusterRamOvercommitRatio = Float.parseFloat(clusterDetailRam.getValue());\n        Float cpuOvercommitRatio = 1f;\n        Float ramOvercommitRatio = 1f;\n        for (VMInstanceVO vm : vms) {\n            Map<String, String> vmDetails = _userVmDetailsDao.listDetailsKeyPairs(vm.getId());\n            String vmDetailCpu = vmDetails.get(\"cpuOvercommitRatio\");\n            String vmDetailRam = vmDetails.get(\"memoryOvercommitRatio\");\n            if (vmDetailCpu != null) {\n                \r\n                cpuOvercommitRatio = Float.parseFloat(vmDetailCpu);\n                ramOvercommitRatio = Float.parseFloat(vmDetailRam);\n            }\n            ServiceOffering so = offeringsMap.get(vm.getServiceOfferingId());\n            if (so.isDynamic()) {\n                usedMemory +=\n                    ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.memory.name())) * 1024L * 1024L) / ramOvercommitRatio) *\n                        clusterRamOvercommitRatio;\n                usedCpu +=\n                    ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuSpeed.name()))) / cpuOvercommitRatio) *\n                        clusterCpuOvercommitRatio;\n                usedCpuCore += Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name()));\n            } else {\n                usedMemory += ((so.getRamSize() * 1024L * 1024L) / ramOvercommitRatio) * clusterRamOvercommitRatio;\n                usedCpu += ((so.getCpu() * so.getSpeed()) / cpuOvercommitRatio) * clusterCpuOvercommitRatio;\n                usedCpuCore += so.getCpu();\n            }\n        }\n\n        List<VMInstanceVO> vmsByLastHostId = _vmDao.listByLastHostId(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vmsByLastHostId.size() + \" VM, not running on host \" + host.getId());\n        }\n        for (VMInstanceVO vm : vmsByLastHostId) {\n            long secondsSinceLastUpdate = (DateUtil.currentGMTTime().getTime() - vm.getUpdateTime().getTime()) / 1000;\n            if (secondsSinceLastUpdate < _vmCapacityReleaseInterval) {\n                UserVmDetailVO vmDetailCpu = _userVmDetailsDao.findDetail(vm.getId(), \"cpuOvercommitRatio\");\n                UserVmDetailVO vmDetailRam = _userVmDetailsDao.findDetail(vm.getId(), \"memoryOvercommitRatio\");\n                if (vmDetailCpu != null) {\n                    \r\n                    cpuOvercommitRatio = Float.parseFloat(vmDetailCpu.getValue());\n                    ramOvercommitRatio = Float.parseFloat(vmDetailRam.getValue());\n                }\n                ServiceOffering so = offeringsMap.get(vm.getServiceOfferingId());\n                Map<String, String> vmDetails = _userVmDetailsDao.listDetailsKeyPairs(vm.getId());\n                if (so.isDynamic()) {\n                    reservedMemory +=\n                        ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.memory.name())) * 1024L * 1024L) / ramOvercommitRatio) *\n                            clusterRamOvercommitRatio;\n                    reservedCpu +=\n                        ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuSpeed.name()))) / cpuOvercommitRatio) *\n                            clusterCpuOvercommitRatio;\n                    reservedCpuCore += Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name()));\n                } else {\n                    reservedMemory += ((so.getRamSize() * 1024L * 1024L) / ramOvercommitRatio) * clusterRamOvercommitRatio;\n                    reservedCpu += (so.getCpu() * so.getSpeed() / cpuOvercommitRatio) * clusterCpuOvercommitRatio;\n                    reservedCpuCore += so.getCpu();\n                }\n            } else {\n                \r\n                \r\n                UserVmDetailVO messageSentFlag = _userVmDetailsDao.findDetail(vm.getId(), MESSAGE_RESERVED_CAPACITY_FREED_FLAG);\n                if (messageSentFlag == null || !Boolean.valueOf(messageSentFlag.getValue())) {\n                    _messageBus.publish(_name, \"VM_ReservedCapacity_Free\", PublishScope.LOCAL, vm);\n\n                    if (vm.getType() == VirtualMachine.Type.User) {\n                        UserVmVO userVM = _userVMDao.findById(vm.getId());\n                        _userVMDao.loadDetails(userVM);\n                        userVM.setDetail(MESSAGE_RESERVED_CAPACITY_FREED_FLAG, \"true\");\n                        _userVMDao.saveDetails(userVM);\n                    }\n                }\n            }\n        }\n\n        CapacityVO cpuCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_CPU);\n        CapacityVO memCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_MEMORY);\n        CapacityVO cpuCoreCap = _capacityDao.findByHostIdType(host.getId(), CapacityVO.CAPACITY_TYPE_CPU_CORE);\n\n        if (cpuCoreCap != null) {\n            long hostTotalCpuCore = host.getCpus().longValue();\n\n            if (cpuCoreCap.getTotalCapacity() != hostTotalCpuCore) {\n                s_logger.debug(\"Calibrate total cpu for host: \" + host.getId() + \" old total CPU:\"\n                        + cpuCoreCap.getTotalCapacity() + \" new total CPU:\" + hostTotalCpuCore);\n                cpuCoreCap.setTotalCapacity(hostTotalCpuCore);\n\n            }\n\n            if (cpuCoreCap.getUsedCapacity() == usedCpuCore && cpuCoreCap.getReservedCapacity() == reservedCpuCore) {\n                s_logger.debug(\"No need to calibrate cpu capacity, host:\" + host.getId() + \" usedCpuCore: \" + cpuCoreCap.getUsedCapacity()\n                        + \" reservedCpuCore: \" + cpuCoreCap.getReservedCapacity());\n            } else {\n                if (cpuCoreCap.getReservedCapacity() != reservedCpuCore) {\n                    s_logger.debug(\"Calibrate reserved cpu core for host: \" + host.getId() + \" old reservedCpuCore:\"\n                            + cpuCoreCap.getReservedCapacity() + \" new reservedCpuCore:\" + reservedCpuCore);\n                    cpuCoreCap.setReservedCapacity(reservedCpuCore);\n                }\n                if (cpuCoreCap.getUsedCapacity() != usedCpuCore) {\n                    s_logger.debug(\"Calibrate used cpu core for host: \" + host.getId() + \" old usedCpuCore:\"\n                            + cpuCoreCap.getUsedCapacity() + \" new usedCpuCore:\" + usedCpuCore);\n                    cpuCoreCap.setUsedCapacity(usedCpuCore);\n                }\n            }\n            try {\n                _capacityDao.update(cpuCoreCap.getId(), cpuCoreCap);\n            } catch (Exception e) {\n                s_logger.error(\"Caught exception while updating cpucore capacity for the host \" +host.getId(), e);\n            }\n        } else {\n            final long usedCpuCoreFinal = usedCpuCore;\n            final long reservedCpuCoreFinal = reservedCpuCore;\n            Transaction.execute(new TransactionCallbackNoReturn() {\n                @Override\n                public void doInTransactionWithoutResult(TransactionStatus status) {\n                    CapacityVO capacity = new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedCpuCoreFinal, host.getCpus().longValue(),\n                            CapacityVO.CAPACITY_TYPE_CPU_CORE);\n                    capacity.setReservedCapacity(reservedCpuCoreFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n                }\n            });\n        }\n\n        if (cpuCap != null && memCap != null) {\n            if (host.getTotalMemory() != null) {\n                memCap.setTotalCapacity(host.getTotalMemory());\n            }\n            long hostTotalCpu = host.getCpus().longValue() * host.getSpeed().longValue();\n\n            if (cpuCap.getTotalCapacity() != hostTotalCpu) {\n                s_logger.debug(\"Calibrate total cpu for host: \" + host.getId() + \" old total CPU:\" + cpuCap.getTotalCapacity() + \" new total CPU:\" + hostTotalCpu);\n                cpuCap.setTotalCapacity(hostTotalCpu);\n\n            }\n            \r\n            if(capacityState != cpuCap.getCapacityState()){\n                s_logger.debug(\"Calibrate cpu capacity state for host: \" + host.getId() + \" old capacity state:\" + cpuCap.getTotalCapacity() + \" new capacity state:\" + hostTotalCpu);\n                cpuCap.setCapacityState(capacityState);\n            }\n            memCap.setCapacityState(capacityState);\n\n            if (cpuCap.getUsedCapacity() == usedCpu && cpuCap.getReservedCapacity() == reservedCpu) {\n                s_logger.debug(\"No need to calibrate cpu capacity, host:\" + host.getId() + \" usedCpu: \" + cpuCap.getUsedCapacity() + \" reservedCpu: \" +\n                    cpuCap.getReservedCapacity());\n            } else {\n                if (cpuCap.getReservedCapacity() != reservedCpu) {\n                    s_logger.debug(\"Calibrate reserved cpu for host: \" + host.getId() + \" old reservedCpu:\" + cpuCap.getReservedCapacity() + \" new reservedCpu:\" +\n                        reservedCpu);\n                    cpuCap.setReservedCapacity(reservedCpu);\n                }\n                if (cpuCap.getUsedCapacity() != usedCpu) {\n                    s_logger.debug(\"Calibrate used cpu for host: \" + host.getId() + \" old usedCpu:\" + cpuCap.getUsedCapacity() + \" new usedCpu:\" + usedCpu);\n                    cpuCap.setUsedCapacity(usedCpu);\n                }\n            }\n\n            if (memCap.getTotalCapacity() != host.getTotalMemory()) {\n                s_logger.debug(\"Calibrate total memory for host: \" + host.getId() + \" old total memory:\" + memCap.getTotalCapacity() + \" new total memory:\" +\n                    host.getTotalMemory());\n                memCap.setTotalCapacity(host.getTotalMemory());\n\n            }\n            \r\n            if(capacityState != memCap.getCapacityState()){\n                s_logger.debug(\"Calibrate memory capacity state for host: \" + host.getId() + \" old capacity state:\" + memCap.getTotalCapacity() + \" new capacity state:\" + hostTotalCpu);\n                memCap.setCapacityState(capacityState);\n            }\n\n            if (memCap.getUsedCapacity() == usedMemory && memCap.getReservedCapacity() == reservedMemory) {\n                s_logger.debug(\"No need to calibrate memory capacity, host:\" + host.getId() + \" usedMem: \" + memCap.getUsedCapacity() + \" reservedMem: \" +\n                    memCap.getReservedCapacity());\n            } else {\n                if (memCap.getReservedCapacity() != reservedMemory) {\n                    s_logger.debug(\"Calibrate reserved memory for host: \" + host.getId() + \" old reservedMem:\" + memCap.getReservedCapacity() + \" new reservedMem:\" +\n                        reservedMemory);\n                    memCap.setReservedCapacity(reservedMemory);\n                }\n                if (memCap.getUsedCapacity() != usedMemory) {\n                    \r\n\r\n\r\n\r\n\n                    s_logger.debug(\"Calibrate used memory for host: \" + host.getId() + \" old usedMem: \" + memCap.getUsedCapacity() + \" new usedMem: \" + usedMemory);\n                    memCap.setUsedCapacity(usedMemory);\n                }\n            }\n\n            try {\n                _capacityDao.update(cpuCap.getId(), cpuCap);\n                _capacityDao.update(memCap.getId(), memCap);\n            } catch (Exception e) {\n                s_logger.error(\"Caught exception while updating cpu/memory capacity for the host \" + host.getId(), e);\n            }\n        } else {\n            final long usedMemoryFinal = usedMemory;\n            final long reservedMemoryFinal = reservedMemory;\n            final long usedCpuFinal = usedCpu;\n            final long reservedCpuFinal = reservedCpu;\n            Transaction.execute(new TransactionCallbackNoReturn() {\n                @Override\n                public void doInTransactionWithoutResult(TransactionStatus status) {\n                    CapacityVO capacity =\n                        new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedMemoryFinal, host.getTotalMemory(),\n                            Capacity.CAPACITY_TYPE_MEMORY);\n                    capacity.setReservedCapacity(reservedMemoryFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n\n                    capacity =\n                        new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedCpuFinal, host.getCpus().longValue() *\n                            host.getSpeed().longValue(), Capacity.CAPACITY_TYPE_CPU);\n                    capacity.setReservedCapacity(reservedCpuFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n                }\n            });\n\n        }\n\n    }\n","date":"2018-01-20 05:49:27","endLine":831,"groupId":"8639","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"updateCapacityForHost","params":"(finalHosthost)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/9c/c5e4271b6607c4ed3e981344c073ccbb3d6c64.src","preCode":"    public void updateCapacityForHost(final Host host) {\n        \r\n        List<ServiceOfferingVO> offerings = _offeringsDao.listAllIncludingRemoved();\n        Map<Long, ServiceOfferingVO> offeringsMap = new HashMap<Long, ServiceOfferingVO>();\n        for (ServiceOfferingVO offering : offerings) {\n            offeringsMap.put(offering.getId(), offering);\n        }\n\n        long usedCpuCore = 0;\n        long reservedCpuCore = 0;\n        long usedCpu = 0;\n        long usedMemory = 0;\n        long reservedMemory = 0;\n        long reservedCpu = 0;\n        final CapacityState capacityState = (host.getResourceState() == ResourceState.Enabled) ? CapacityState.Enabled : CapacityState.Disabled;\n\n        List<VMInstanceVO> vms = _vmDao.listUpByHostId(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vms.size() + \" VMs on host \" + host.getId());\n        }\n\n        ClusterVO cluster = _clusterDao.findById(host.getClusterId());\n        ClusterDetailsVO clusterDetailCpu = _clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n        ClusterDetailsVO clusterDetailRam = _clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n        Float clusterCpuOvercommitRatio = Float.parseFloat(clusterDetailCpu.getValue());\n        Float clusterRamOvercommitRatio = Float.parseFloat(clusterDetailRam.getValue());\n        Float cpuOvercommitRatio = 1f;\n        Float ramOvercommitRatio = 1f;\n        for (VMInstanceVO vm : vms) {\n            Map<String, String> vmDetails = _userVmDetailsDao.listDetailsKeyPairs(vm.getId());\n            String vmDetailCpu = vmDetails.get(\"cpuOvercommitRatio\");\n            String vmDetailRam = vmDetails.get(\"memoryOvercommitRatio\");\n            if (vmDetailCpu != null) {\n                \r\n                cpuOvercommitRatio = Float.parseFloat(vmDetailCpu);\n                ramOvercommitRatio = Float.parseFloat(vmDetailRam);\n            }\n            ServiceOffering so = offeringsMap.get(vm.getServiceOfferingId());\n            if (so.isDynamic()) {\n                usedMemory +=\n                    ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.memory.name())) * 1024L * 1024L) / ramOvercommitRatio) *\n                        clusterRamOvercommitRatio;\n                usedCpu +=\n                    ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuSpeed.name()))) / cpuOvercommitRatio) *\n                        clusterCpuOvercommitRatio;\n                usedCpuCore += Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name()));\n            } else {\n                usedMemory += ((so.getRamSize() * 1024L * 1024L) / ramOvercommitRatio) * clusterRamOvercommitRatio;\n                usedCpu += ((so.getCpu() * so.getSpeed()) / cpuOvercommitRatio) * clusterCpuOvercommitRatio;\n                usedCpuCore += so.getCpu();\n            }\n        }\n\n        List<VMInstanceVO> vmsByLastHostId = _vmDao.listByLastHostId(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vmsByLastHostId.size() + \" VM, not running on host \" + host.getId());\n        }\n        for (VMInstanceVO vm : vmsByLastHostId) {\n            long secondsSinceLastUpdate = (DateUtil.currentGMTTime().getTime() - vm.getUpdateTime().getTime()) / 1000;\n            if (secondsSinceLastUpdate < _vmCapacityReleaseInterval) {\n                UserVmDetailVO vmDetailCpu = _userVmDetailsDao.findDetail(vm.getId(), \"cpuOvercommitRatio\");\n                UserVmDetailVO vmDetailRam = _userVmDetailsDao.findDetail(vm.getId(), \"memoryOvercommitRatio\");\n                if (vmDetailCpu != null) {\n                    \r\n                    cpuOvercommitRatio = Float.parseFloat(vmDetailCpu.getValue());\n                    ramOvercommitRatio = Float.parseFloat(vmDetailRam.getValue());\n                }\n                ServiceOffering so = offeringsMap.get(vm.getServiceOfferingId());\n                Map<String, String> vmDetails = _userVmDetailsDao.listDetailsKeyPairs(vm.getId());\n                if (so.isDynamic()) {\n                    reservedMemory +=\n                        ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.memory.name())) * 1024L * 1024L) / ramOvercommitRatio) *\n                            clusterRamOvercommitRatio;\n                    reservedCpu +=\n                        ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuSpeed.name()))) / cpuOvercommitRatio) *\n                            clusterCpuOvercommitRatio;\n                    reservedCpuCore += Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name()));\n                } else {\n                    reservedMemory += ((so.getRamSize() * 1024L * 1024L) / ramOvercommitRatio) * clusterRamOvercommitRatio;\n                    reservedCpu += (so.getCpu() * so.getSpeed() / cpuOvercommitRatio) * clusterCpuOvercommitRatio;\n                    reservedCpuCore += so.getCpu();\n                }\n            } else {\n                \r\n                \r\n                UserVmDetailVO messageSentFlag = _userVmDetailsDao.findDetail(vm.getId(), MESSAGE_RESERVED_CAPACITY_FREED_FLAG);\n                if (messageSentFlag == null || !Boolean.valueOf(messageSentFlag.getValue())) {\n                    _messageBus.publish(_name, \"VM_ReservedCapacity_Free\", PublishScope.LOCAL, vm);\n\n                    if (vm.getType() == VirtualMachine.Type.User) {\n                        UserVmVO userVM = _userVMDao.findById(vm.getId());\n                        _userVMDao.loadDetails(userVM);\n                        userVM.setDetail(MESSAGE_RESERVED_CAPACITY_FREED_FLAG, \"true\");\n                        _userVMDao.saveDetails(userVM);\n                    }\n                }\n            }\n        }\n\n        CapacityVO cpuCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_CPU);\n        CapacityVO memCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_MEMORY);\n        CapacityVO cpuCoreCap = _capacityDao.findByHostIdType(host.getId(), CapacityVO.CAPACITY_TYPE_CPU_CORE);\n\n        if (cpuCoreCap != null) {\n            long hostTotalCpuCore = host.getCpus().longValue();\n\n            if (cpuCoreCap.getTotalCapacity() != hostTotalCpuCore) {\n                s_logger.debug(\"Calibrate total cpu for host: \" + host.getId() + \" old total CPU:\"\n                        + cpuCoreCap.getTotalCapacity() + \" new total CPU:\" + hostTotalCpuCore);\n                cpuCoreCap.setTotalCapacity(hostTotalCpuCore);\n\n            }\n\n            if (cpuCoreCap.getUsedCapacity() == usedCpuCore && cpuCoreCap.getReservedCapacity() == reservedCpuCore) {\n                s_logger.debug(\"No need to calibrate cpu capacity, host:\" + host.getId() + \" usedCpuCore: \" + cpuCoreCap.getUsedCapacity()\n                        + \" reservedCpuCore: \" + cpuCoreCap.getReservedCapacity());\n            } else {\n                if (cpuCoreCap.getReservedCapacity() != reservedCpuCore) {\n                    s_logger.debug(\"Calibrate reserved cpu core for host: \" + host.getId() + \" old reservedCpuCore:\"\n                            + cpuCoreCap.getReservedCapacity() + \" new reservedCpuCore:\" + reservedCpuCore);\n                    cpuCoreCap.setReservedCapacity(reservedCpuCore);\n                }\n                if (cpuCoreCap.getUsedCapacity() != usedCpuCore) {\n                    s_logger.debug(\"Calibrate used cpu core for host: \" + host.getId() + \" old usedCpuCore:\"\n                            + cpuCoreCap.getUsedCapacity() + \" new usedCpuCore:\" + usedCpuCore);\n                    cpuCoreCap.setUsedCapacity(usedCpuCore);\n                }\n            }\n            try {\n                _capacityDao.update(cpuCoreCap.getId(), cpuCoreCap);\n            } catch (Exception e) {\n                s_logger.error(\"Caught exception while updating cpucore capacity for the host \" +host.getId(), e);\n            }\n        } else {\n            final long usedCpuCoreFinal = usedCpuCore;\n            final long reservedCpuCoreFinal = reservedCpuCore;\n            Transaction.execute(new TransactionCallbackNoReturn() {\n                @Override\n                public void doInTransactionWithoutResult(TransactionStatus status) {\n                    CapacityVO capacity = new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedCpuCoreFinal, host.getCpus().longValue(),\n                            CapacityVO.CAPACITY_TYPE_CPU_CORE);\n                    capacity.setReservedCapacity(reservedCpuCoreFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n                }\n            });\n        }\n\n        if (cpuCap != null && memCap != null) {\n            if (host.getTotalMemory() != null) {\n                memCap.setTotalCapacity(host.getTotalMemory());\n            }\n            long hostTotalCpu = host.getCpus().longValue() * host.getSpeed().longValue();\n\n            if (cpuCap.getTotalCapacity() != hostTotalCpu) {\n                s_logger.debug(\"Calibrate total cpu for host: \" + host.getId() + \" old total CPU:\" + cpuCap.getTotalCapacity() + \" new total CPU:\" + hostTotalCpu);\n                cpuCap.setTotalCapacity(hostTotalCpu);\n\n            }\n            \r\n            if(capacityState != cpuCap.getCapacityState()){\n                s_logger.debug(\"Calibrate cpu capacity state for host: \" + host.getId() + \" old capacity state:\" + cpuCap.getTotalCapacity() + \" new capacity state:\" + hostTotalCpu);\n                cpuCap.setCapacityState(capacityState);\n            }\n            memCap.setCapacityState(capacityState);\n\n            if (cpuCap.getUsedCapacity() == usedCpu && cpuCap.getReservedCapacity() == reservedCpu) {\n                s_logger.debug(\"No need to calibrate cpu capacity, host:\" + host.getId() + \" usedCpu: \" + cpuCap.getUsedCapacity() + \" reservedCpu: \" +\n                    cpuCap.getReservedCapacity());\n            } else {\n                if (cpuCap.getReservedCapacity() != reservedCpu) {\n                    s_logger.debug(\"Calibrate reserved cpu for host: \" + host.getId() + \" old reservedCpu:\" + cpuCap.getReservedCapacity() + \" new reservedCpu:\" +\n                        reservedCpu);\n                    cpuCap.setReservedCapacity(reservedCpu);\n                }\n                if (cpuCap.getUsedCapacity() != usedCpu) {\n                    s_logger.debug(\"Calibrate used cpu for host: \" + host.getId() + \" old usedCpu:\" + cpuCap.getUsedCapacity() + \" new usedCpu:\" + usedCpu);\n                    cpuCap.setUsedCapacity(usedCpu);\n                }\n            }\n\n            if (memCap.getTotalCapacity() != host.getTotalMemory()) {\n                s_logger.debug(\"Calibrate total memory for host: \" + host.getId() + \" old total memory:\" + memCap.getTotalCapacity() + \" new total memory:\" +\n                    host.getTotalMemory());\n                memCap.setTotalCapacity(host.getTotalMemory());\n\n            }\n            \r\n            if(capacityState != memCap.getCapacityState()){\n                s_logger.debug(\"Calibrate memory capacity state for host: \" + host.getId() + \" old capacity state:\" + memCap.getTotalCapacity() + \" new capacity state:\" + hostTotalCpu);\n                memCap.setCapacityState(capacityState);\n            }\n\n            if (memCap.getUsedCapacity() == usedMemory && memCap.getReservedCapacity() == reservedMemory) {\n                s_logger.debug(\"No need to calibrate memory capacity, host:\" + host.getId() + \" usedMem: \" + memCap.getUsedCapacity() + \" reservedMem: \" +\n                    memCap.getReservedCapacity());\n            } else {\n                if (memCap.getReservedCapacity() != reservedMemory) {\n                    s_logger.debug(\"Calibrate reserved memory for host: \" + host.getId() + \" old reservedMem:\" + memCap.getReservedCapacity() + \" new reservedMem:\" +\n                        reservedMemory);\n                    memCap.setReservedCapacity(reservedMemory);\n                }\n                if (memCap.getUsedCapacity() != usedMemory) {\n                    \r\n\r\n\r\n\r\n\n                    s_logger.debug(\"Calibrate used memory for host: \" + host.getId() + \" old usedMem: \" + memCap.getUsedCapacity() + \" new usedMem: \" + usedMemory);\n                    memCap.setUsedCapacity(usedMemory);\n                }\n            }\n\n            try {\n                _capacityDao.update(cpuCap.getId(), cpuCap);\n                _capacityDao.update(memCap.getId(), memCap);\n            } catch (Exception e) {\n                s_logger.error(\"Caught exception while updating cpu/memory capacity for the host \" + host.getId(), e);\n            }\n        } else {\n            final long usedMemoryFinal = usedMemory;\n            final long reservedMemoryFinal = reservedMemory;\n            final long usedCpuFinal = usedCpu;\n            final long reservedCpuFinal = reservedCpu;\n            Transaction.execute(new TransactionCallbackNoReturn() {\n                @Override\n                public void doInTransactionWithoutResult(TransactionStatus status) {\n                    CapacityVO capacity =\n                        new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedMemoryFinal, host.getTotalMemory(),\n                            Capacity.CAPACITY_TYPE_MEMORY);\n                    capacity.setReservedCapacity(reservedMemoryFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n\n                    capacity =\n                        new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedCpuFinal, host.getCpus().longValue() *\n                            host.getSpeed().longValue(), Capacity.CAPACITY_TYPE_CPU);\n                    capacity.setReservedCapacity(reservedCpuFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n                }\n            });\n\n        }\n\n    }\n","realPath":"server/src/main/java/com/cloud/capacity/CapacityManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":586,"status":"B"}],"commitId":"893a88d225276e45f12f9490e6af2c94a81c2965","commitMessage":"@@@CLOUDSTACK-10105: Use maven standard project structure in all projects (#2283)\n\nRemove maven standard module (which only a few were using) and get ride of maven customization for the projects structure.\n\n- moved all directories to src/main/java.  src/main/resources.  src/main/scripts.  src/test/java.  src/test/resources\n- grep scan to search for src/com and src/org left over\n- grep for <project>/scripts to fix pom.xml configuration\n- remove custom <build> configuration in pom.xml\n\nSigned-off-by: Marc-Aur?le Brothier <m@brothier.org>","date":"2018-01-20 05:49:27","modifiedFileCount":"1","status":"B","submitter":"Marc-Aur?le Brothier"},{"authorTime":"2018-05-23 23:12:10","codes":[{"authorDate":"2018-01-20 05:49:27","commitOrder":2,"curCode":"    public void recalculateCapacity() {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        try {\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"recalculating system capacity\");\n                s_logger.debug(\"Executing cpu/ram capacity update\");\n            }\n\n            \r\n            \r\n            List<HostVO> hosts = _resourceMgr.listAllNotInMaintenanceHostsInOneZone(Host.Type.Routing, null);\n            if (hosts != null) {\n                for (HostVO host : hosts) {\n                    _capacityMgr.updateCapacityForHost(host);\n                }\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing cpu/ram capacity update\");\n                s_logger.debug(\"Executing storage capacity update\");\n            }\n            \r\n            List<StoragePoolVO> storagePools = _storagePoolDao.listAll();\n            for (StoragePoolVO pool : storagePools) {\n                long disk = _capacityMgr.getAllocatedPoolCapacity(pool, null);\n                if (pool.isShared()) {\n                    _storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_STORAGE_ALLOCATED, disk);\n                } else {\n                    _storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_LOCAL_STORAGE, disk);\n                }\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing storage capacity update\");\n                s_logger.debug(\"Executing capacity updates for public ip and Vlans\");\n            }\n\n            List<DataCenterVO> datacenters = _dcDao.listAll();\n            for (DataCenterVO datacenter : datacenters) {\n                long dcId = datacenter.getId();\n\n                \r\n                \r\n                \r\n                \r\n                \r\n\n                \r\n                if (datacenter.getNetworkType() == NetworkType.Advanced) {\n                    createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_VIRTUAL_NETWORK_PUBLIC_IP, datacenter.getAllocationState());\n                }\n\n                \r\n                createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_DIRECT_ATTACHED_PUBLIC_IP, datacenter.getAllocationState());\n\n                if (datacenter.getNetworkType() == NetworkType.Advanced) {\n                    \r\n                    createOrUpdateVlanCapacity(dcId, datacenter.getAllocationState());\n                }\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done capacity updates for public ip and Vlans\");\n                s_logger.debug(\"Executing capacity updates for private ip\");\n            }\n\n            \r\n            List<HostPodVO> pods = _podDao.listAll();\n            for (HostPodVO pod : pods) {\n                long podId = pod.getId();\n                long dcId = pod.getDataCenterId();\n\n                createOrUpdateIpCapacity(dcId, podId, Capacity.CAPACITY_TYPE_PRIVATE_IP, _configMgr.findPodAllocationState(pod));\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing capacity updates for private ip\");\n                s_logger.debug(\"Done recalculating system capacity\");\n            }\n\n        } catch (Throwable t) {\n            s_logger.error(\"Caught exception in recalculating capacity\", t);\n        }\n    }\n","date":"2018-01-20 05:49:27","endLine":350,"groupId":"23680","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"recalculateCapacity","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/a5/8a4f8b0f91450e931ce96c942160b57ca0b1fa.src","preCode":"    public void recalculateCapacity() {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        try {\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"recalculating system capacity\");\n                s_logger.debug(\"Executing cpu/ram capacity update\");\n            }\n\n            \r\n            \r\n            List<HostVO> hosts = _resourceMgr.listAllNotInMaintenanceHostsInOneZone(Host.Type.Routing, null);\n            if (hosts != null) {\n                for (HostVO host : hosts) {\n                    _capacityMgr.updateCapacityForHost(host);\n                }\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing cpu/ram capacity update\");\n                s_logger.debug(\"Executing storage capacity update\");\n            }\n            \r\n            List<StoragePoolVO> storagePools = _storagePoolDao.listAll();\n            for (StoragePoolVO pool : storagePools) {\n                long disk = _capacityMgr.getAllocatedPoolCapacity(pool, null);\n                if (pool.isShared()) {\n                    _storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_STORAGE_ALLOCATED, disk);\n                } else {\n                    _storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_LOCAL_STORAGE, disk);\n                }\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing storage capacity update\");\n                s_logger.debug(\"Executing capacity updates for public ip and Vlans\");\n            }\n\n            List<DataCenterVO> datacenters = _dcDao.listAll();\n            for (DataCenterVO datacenter : datacenters) {\n                long dcId = datacenter.getId();\n\n                \r\n                \r\n                \r\n                \r\n                \r\n\n                \r\n                if (datacenter.getNetworkType() == NetworkType.Advanced) {\n                    createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_VIRTUAL_NETWORK_PUBLIC_IP, datacenter.getAllocationState());\n                }\n\n                \r\n                createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_DIRECT_ATTACHED_PUBLIC_IP, datacenter.getAllocationState());\n\n                if (datacenter.getNetworkType() == NetworkType.Advanced) {\n                    \r\n                    createOrUpdateVlanCapacity(dcId, datacenter.getAllocationState());\n                }\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done capacity updates for public ip and Vlans\");\n                s_logger.debug(\"Executing capacity updates for private ip\");\n            }\n\n            \r\n            List<HostPodVO> pods = _podDao.listAll();\n            for (HostPodVO pod : pods) {\n                long podId = pod.getId();\n                long dcId = pod.getDataCenterId();\n\n                createOrUpdateIpCapacity(dcId, podId, Capacity.CAPACITY_TYPE_PRIVATE_IP, _configMgr.findPodAllocationState(pod));\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing capacity updates for private ip\");\n                s_logger.debug(\"Done recalculating system capacity\");\n            }\n\n        } catch (Throwable t) {\n            s_logger.error(\"Caught exception in recalculating capacity\", t);\n        }\n    }\n","realPath":"server/src/main/java/com/cloud/alert/AlertManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":261,"status":"N"},{"authorDate":"2018-05-23 23:12:10","commitOrder":2,"curCode":"    public void updateCapacityForHost(final Host host) {\n        \r\n        List<ServiceOfferingVO> offerings = _offeringsDao.listAllIncludingRemoved();\n        Map<Long, ServiceOfferingVO> offeringsMap = new HashMap<Long, ServiceOfferingVO>();\n        for (ServiceOfferingVO offering : offerings) {\n            offeringsMap.put(offering.getId(), offering);\n        }\n\n        long usedCpuCore = 0;\n        long reservedCpuCore = 0;\n        long usedCpu = 0;\n        long usedMemory = 0;\n        long reservedMemory = 0;\n        long reservedCpu = 0;\n        final CapacityState capacityState = (host.getResourceState() == ResourceState.Enabled) ? CapacityState.Enabled : CapacityState.Disabled;\n\n        List<VMInstanceVO> vms = _vmDao.listUpByHostId(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vms.size() + \" VMs on host \" + host.getId());\n        }\n\n        ClusterVO cluster = _clusterDao.findById(host.getClusterId());\n        ClusterDetailsVO clusterDetailCpu = _clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n        ClusterDetailsVO clusterDetailRam = _clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n        Float clusterCpuOvercommitRatio = Float.parseFloat(clusterDetailCpu.getValue());\n        Float clusterRamOvercommitRatio = Float.parseFloat(clusterDetailRam.getValue());\n        for (VMInstanceVO vm : vms) {\n            Float cpuOvercommitRatio = 1.0f;\n            Float ramOvercommitRatio = 1.0f;\n            Map<String, String> vmDetails = _userVmDetailsDao.listDetailsKeyPairs(vm.getId());\n            String vmDetailCpu = vmDetails.get(\"cpuOvercommitRatio\");\n            String vmDetailRam = vmDetails.get(\"memoryOvercommitRatio\");\n            if (vmDetailCpu != null) {\n                \r\n                cpuOvercommitRatio = Float.parseFloat(vmDetailCpu);\n                ramOvercommitRatio = Float.parseFloat(vmDetailRam);\n            }\n            ServiceOffering so = offeringsMap.get(vm.getServiceOfferingId());\n            if (so.isDynamic()) {\n                usedMemory +=\n                    ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.memory.name())) * 1024L * 1024L) / ramOvercommitRatio) *\n                        clusterRamOvercommitRatio;\n                usedCpu +=\n                    ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuSpeed.name()))) / cpuOvercommitRatio) *\n                        clusterCpuOvercommitRatio;\n                usedCpuCore += Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name()));\n            } else {\n                usedMemory += ((so.getRamSize() * 1024L * 1024L) / ramOvercommitRatio) * clusterRamOvercommitRatio;\n                usedCpu += ((so.getCpu() * so.getSpeed()) / cpuOvercommitRatio) * clusterCpuOvercommitRatio;\n                usedCpuCore += so.getCpu();\n            }\n        }\n\n        List<VMInstanceVO> vmsByLastHostId = _vmDao.listByLastHostId(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vmsByLastHostId.size() + \" VM, not running on host \" + host.getId());\n        }\n        for (VMInstanceVO vm : vmsByLastHostId) {\n            Float cpuOvercommitRatio = 1.0f;\n            Float ramOvercommitRatio = 1.0f;\n            long secondsSinceLastUpdate = (DateUtil.currentGMTTime().getTime() - vm.getUpdateTime().getTime()) / 1000;\n            if (secondsSinceLastUpdate < _vmCapacityReleaseInterval) {\n                UserVmDetailVO vmDetailCpu = _userVmDetailsDao.findDetail(vm.getId(), \"cpuOvercommitRatio\");\n                UserVmDetailVO vmDetailRam = _userVmDetailsDao.findDetail(vm.getId(), \"memoryOvercommitRatio\");\n                if (vmDetailCpu != null) {\n                    \r\n                    cpuOvercommitRatio = Float.parseFloat(vmDetailCpu.getValue());\n                    ramOvercommitRatio = Float.parseFloat(vmDetailRam.getValue());\n                }\n                ServiceOffering so = offeringsMap.get(vm.getServiceOfferingId());\n                Map<String, String> vmDetails = _userVmDetailsDao.listDetailsKeyPairs(vm.getId());\n                if (so.isDynamic()) {\n                    reservedMemory +=\n                        ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.memory.name())) * 1024L * 1024L) / ramOvercommitRatio) *\n                            clusterRamOvercommitRatio;\n                    reservedCpu +=\n                        ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuSpeed.name()))) / cpuOvercommitRatio) *\n                            clusterCpuOvercommitRatio;\n                    reservedCpuCore += Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name()));\n                } else {\n                    reservedMemory += ((so.getRamSize() * 1024L * 1024L) / ramOvercommitRatio) * clusterRamOvercommitRatio;\n                    reservedCpu += (so.getCpu() * so.getSpeed() / cpuOvercommitRatio) * clusterCpuOvercommitRatio;\n                    reservedCpuCore += so.getCpu();\n                }\n            } else {\n                \r\n                \r\n                UserVmDetailVO messageSentFlag = _userVmDetailsDao.findDetail(vm.getId(), MESSAGE_RESERVED_CAPACITY_FREED_FLAG);\n                if (messageSentFlag == null || !Boolean.valueOf(messageSentFlag.getValue())) {\n                    _messageBus.publish(_name, \"VM_ReservedCapacity_Free\", PublishScope.LOCAL, vm);\n\n                    if (vm.getType() == VirtualMachine.Type.User) {\n                        UserVmVO userVM = _userVMDao.findById(vm.getId());\n                        _userVMDao.loadDetails(userVM);\n                        userVM.setDetail(MESSAGE_RESERVED_CAPACITY_FREED_FLAG, \"true\");\n                        _userVMDao.saveDetails(userVM);\n                    }\n                }\n            }\n        }\n\n        CapacityVO cpuCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_CPU);\n        CapacityVO memCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_MEMORY);\n        CapacityVO cpuCoreCap = _capacityDao.findByHostIdType(host.getId(), CapacityVO.CAPACITY_TYPE_CPU_CORE);\n\n        if (cpuCoreCap != null) {\n            long hostTotalCpuCore = host.getCpus().longValue();\n\n            if (cpuCoreCap.getTotalCapacity() != hostTotalCpuCore) {\n                s_logger.debug(\"Calibrate total cpu for host: \" + host.getId() + \" old total CPU:\"\n                        + cpuCoreCap.getTotalCapacity() + \" new total CPU:\" + hostTotalCpuCore);\n                cpuCoreCap.setTotalCapacity(hostTotalCpuCore);\n\n            }\n\n            if (cpuCoreCap.getUsedCapacity() == usedCpuCore && cpuCoreCap.getReservedCapacity() == reservedCpuCore) {\n                s_logger.debug(\"No need to calibrate cpu capacity, host:\" + host.getId() + \" usedCpuCore: \" + cpuCoreCap.getUsedCapacity()\n                        + \" reservedCpuCore: \" + cpuCoreCap.getReservedCapacity());\n            } else {\n                if (cpuCoreCap.getReservedCapacity() != reservedCpuCore) {\n                    s_logger.debug(\"Calibrate reserved cpu core for host: \" + host.getId() + \" old reservedCpuCore:\"\n                            + cpuCoreCap.getReservedCapacity() + \" new reservedCpuCore:\" + reservedCpuCore);\n                    cpuCoreCap.setReservedCapacity(reservedCpuCore);\n                }\n                if (cpuCoreCap.getUsedCapacity() != usedCpuCore) {\n                    s_logger.debug(\"Calibrate used cpu core for host: \" + host.getId() + \" old usedCpuCore:\"\n                            + cpuCoreCap.getUsedCapacity() + \" new usedCpuCore:\" + usedCpuCore);\n                    cpuCoreCap.setUsedCapacity(usedCpuCore);\n                }\n            }\n            try {\n                _capacityDao.update(cpuCoreCap.getId(), cpuCoreCap);\n            } catch (Exception e) {\n                s_logger.error(\"Caught exception while updating cpucore capacity for the host \" +host.getId(), e);\n            }\n        } else {\n            final long usedCpuCoreFinal = usedCpuCore;\n            final long reservedCpuCoreFinal = reservedCpuCore;\n            Transaction.execute(new TransactionCallbackNoReturn() {\n                @Override\n                public void doInTransactionWithoutResult(TransactionStatus status) {\n                    CapacityVO capacity = new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedCpuCoreFinal, host.getCpus().longValue(),\n                            CapacityVO.CAPACITY_TYPE_CPU_CORE);\n                    capacity.setReservedCapacity(reservedCpuCoreFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n                }\n            });\n        }\n\n        if (cpuCap != null && memCap != null) {\n            if (host.getTotalMemory() != null) {\n                memCap.setTotalCapacity(host.getTotalMemory());\n            }\n            long hostTotalCpu = host.getCpus().longValue() * host.getSpeed().longValue();\n\n            if (cpuCap.getTotalCapacity() != hostTotalCpu) {\n                s_logger.debug(\"Calibrate total cpu for host: \" + host.getId() + \" old total CPU:\" + cpuCap.getTotalCapacity() + \" new total CPU:\" + hostTotalCpu);\n                cpuCap.setTotalCapacity(hostTotalCpu);\n\n            }\n            \r\n            if(capacityState != cpuCap.getCapacityState()){\n                s_logger.debug(\"Calibrate cpu capacity state for host: \" + host.getId() + \" old capacity state:\" + cpuCap.getTotalCapacity() + \" new capacity state:\" + hostTotalCpu);\n                cpuCap.setCapacityState(capacityState);\n            }\n            memCap.setCapacityState(capacityState);\n\n            if (cpuCap.getUsedCapacity() == usedCpu && cpuCap.getReservedCapacity() == reservedCpu) {\n                s_logger.debug(\"No need to calibrate cpu capacity, host:\" + host.getId() + \" usedCpu: \" + cpuCap.getUsedCapacity() + \" reservedCpu: \" +\n                    cpuCap.getReservedCapacity());\n            } else {\n                if (cpuCap.getReservedCapacity() != reservedCpu) {\n                    s_logger.debug(\"Calibrate reserved cpu for host: \" + host.getId() + \" old reservedCpu:\" + cpuCap.getReservedCapacity() + \" new reservedCpu:\" +\n                        reservedCpu);\n                    cpuCap.setReservedCapacity(reservedCpu);\n                }\n                if (cpuCap.getUsedCapacity() != usedCpu) {\n                    s_logger.debug(\"Calibrate used cpu for host: \" + host.getId() + \" old usedCpu:\" + cpuCap.getUsedCapacity() + \" new usedCpu:\" + usedCpu);\n                    cpuCap.setUsedCapacity(usedCpu);\n                }\n            }\n\n            if (memCap.getTotalCapacity() != host.getTotalMemory()) {\n                s_logger.debug(\"Calibrate total memory for host: \" + host.getId() + \" old total memory:\" + memCap.getTotalCapacity() + \" new total memory:\" +\n                    host.getTotalMemory());\n                memCap.setTotalCapacity(host.getTotalMemory());\n\n            }\n            \r\n            if(capacityState != memCap.getCapacityState()){\n                s_logger.debug(\"Calibrate memory capacity state for host: \" + host.getId() + \" old capacity state:\" + memCap.getTotalCapacity() + \" new capacity state:\" + hostTotalCpu);\n                memCap.setCapacityState(capacityState);\n            }\n\n            if (memCap.getUsedCapacity() == usedMemory && memCap.getReservedCapacity() == reservedMemory) {\n                s_logger.debug(\"No need to calibrate memory capacity, host:\" + host.getId() + \" usedMem: \" + memCap.getUsedCapacity() + \" reservedMem: \" +\n                    memCap.getReservedCapacity());\n            } else {\n                if (memCap.getReservedCapacity() != reservedMemory) {\n                    s_logger.debug(\"Calibrate reserved memory for host: \" + host.getId() + \" old reservedMem:\" + memCap.getReservedCapacity() + \" new reservedMem:\" +\n                        reservedMemory);\n                    memCap.setReservedCapacity(reservedMemory);\n                }\n                if (memCap.getUsedCapacity() != usedMemory) {\n                    \r\n\r\n\r\n\r\n\n                    s_logger.debug(\"Calibrate used memory for host: \" + host.getId() + \" old usedMem: \" + memCap.getUsedCapacity() + \" new usedMem: \" + usedMemory);\n                    memCap.setUsedCapacity(usedMemory);\n                }\n            }\n\n            try {\n                _capacityDao.update(cpuCap.getId(), cpuCap);\n                _capacityDao.update(memCap.getId(), memCap);\n            } catch (Exception e) {\n                s_logger.error(\"Caught exception while updating cpu/memory capacity for the host \" + host.getId(), e);\n            }\n        } else {\n            final long usedMemoryFinal = usedMemory;\n            final long reservedMemoryFinal = reservedMemory;\n            final long usedCpuFinal = usedCpu;\n            final long reservedCpuFinal = reservedCpu;\n            Transaction.execute(new TransactionCallbackNoReturn() {\n                @Override\n                public void doInTransactionWithoutResult(TransactionStatus status) {\n                    CapacityVO capacity =\n                        new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedMemoryFinal, host.getTotalMemory(),\n                            Capacity.CAPACITY_TYPE_MEMORY);\n                    capacity.setReservedCapacity(reservedMemoryFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n\n                    capacity =\n                        new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedCpuFinal, host.getCpus().longValue() *\n                            host.getSpeed().longValue(), Capacity.CAPACITY_TYPE_CPU);\n                    capacity.setReservedCapacity(reservedCpuFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n                }\n            });\n\n        }\n\n    }\n","date":"2018-05-23 23:12:10","endLine":820,"groupId":"8639","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"updateCapacityForHost","params":"(finalHosthost)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/a9/042a760f86c25ea8f5cd2bf0a9743636f6c17c.src","preCode":"    public void updateCapacityForHost(final Host host) {\n        \r\n        List<ServiceOfferingVO> offerings = _offeringsDao.listAllIncludingRemoved();\n        Map<Long, ServiceOfferingVO> offeringsMap = new HashMap<Long, ServiceOfferingVO>();\n        for (ServiceOfferingVO offering : offerings) {\n            offeringsMap.put(offering.getId(), offering);\n        }\n\n        long usedCpuCore = 0;\n        long reservedCpuCore = 0;\n        long usedCpu = 0;\n        long usedMemory = 0;\n        long reservedMemory = 0;\n        long reservedCpu = 0;\n        final CapacityState capacityState = (host.getResourceState() == ResourceState.Enabled) ? CapacityState.Enabled : CapacityState.Disabled;\n\n        List<VMInstanceVO> vms = _vmDao.listUpByHostId(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vms.size() + \" VMs on host \" + host.getId());\n        }\n\n        ClusterVO cluster = _clusterDao.findById(host.getClusterId());\n        ClusterDetailsVO clusterDetailCpu = _clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n        ClusterDetailsVO clusterDetailRam = _clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n        Float clusterCpuOvercommitRatio = Float.parseFloat(clusterDetailCpu.getValue());\n        Float clusterRamOvercommitRatio = Float.parseFloat(clusterDetailRam.getValue());\n        Float cpuOvercommitRatio = 1f;\n        Float ramOvercommitRatio = 1f;\n        for (VMInstanceVO vm : vms) {\n            Map<String, String> vmDetails = _userVmDetailsDao.listDetailsKeyPairs(vm.getId());\n            String vmDetailCpu = vmDetails.get(\"cpuOvercommitRatio\");\n            String vmDetailRam = vmDetails.get(\"memoryOvercommitRatio\");\n            if (vmDetailCpu != null) {\n                \r\n                cpuOvercommitRatio = Float.parseFloat(vmDetailCpu);\n                ramOvercommitRatio = Float.parseFloat(vmDetailRam);\n            }\n            ServiceOffering so = offeringsMap.get(vm.getServiceOfferingId());\n            if (so.isDynamic()) {\n                usedMemory +=\n                    ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.memory.name())) * 1024L * 1024L) / ramOvercommitRatio) *\n                        clusterRamOvercommitRatio;\n                usedCpu +=\n                    ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuSpeed.name()))) / cpuOvercommitRatio) *\n                        clusterCpuOvercommitRatio;\n                usedCpuCore += Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name()));\n            } else {\n                usedMemory += ((so.getRamSize() * 1024L * 1024L) / ramOvercommitRatio) * clusterRamOvercommitRatio;\n                usedCpu += ((so.getCpu() * so.getSpeed()) / cpuOvercommitRatio) * clusterCpuOvercommitRatio;\n                usedCpuCore += so.getCpu();\n            }\n        }\n\n        List<VMInstanceVO> vmsByLastHostId = _vmDao.listByLastHostId(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vmsByLastHostId.size() + \" VM, not running on host \" + host.getId());\n        }\n        for (VMInstanceVO vm : vmsByLastHostId) {\n            long secondsSinceLastUpdate = (DateUtil.currentGMTTime().getTime() - vm.getUpdateTime().getTime()) / 1000;\n            if (secondsSinceLastUpdate < _vmCapacityReleaseInterval) {\n                UserVmDetailVO vmDetailCpu = _userVmDetailsDao.findDetail(vm.getId(), \"cpuOvercommitRatio\");\n                UserVmDetailVO vmDetailRam = _userVmDetailsDao.findDetail(vm.getId(), \"memoryOvercommitRatio\");\n                if (vmDetailCpu != null) {\n                    \r\n                    cpuOvercommitRatio = Float.parseFloat(vmDetailCpu.getValue());\n                    ramOvercommitRatio = Float.parseFloat(vmDetailRam.getValue());\n                }\n                ServiceOffering so = offeringsMap.get(vm.getServiceOfferingId());\n                Map<String, String> vmDetails = _userVmDetailsDao.listDetailsKeyPairs(vm.getId());\n                if (so.isDynamic()) {\n                    reservedMemory +=\n                        ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.memory.name())) * 1024L * 1024L) / ramOvercommitRatio) *\n                            clusterRamOvercommitRatio;\n                    reservedCpu +=\n                        ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuSpeed.name()))) / cpuOvercommitRatio) *\n                            clusterCpuOvercommitRatio;\n                    reservedCpuCore += Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name()));\n                } else {\n                    reservedMemory += ((so.getRamSize() * 1024L * 1024L) / ramOvercommitRatio) * clusterRamOvercommitRatio;\n                    reservedCpu += (so.getCpu() * so.getSpeed() / cpuOvercommitRatio) * clusterCpuOvercommitRatio;\n                    reservedCpuCore += so.getCpu();\n                }\n            } else {\n                \r\n                \r\n                UserVmDetailVO messageSentFlag = _userVmDetailsDao.findDetail(vm.getId(), MESSAGE_RESERVED_CAPACITY_FREED_FLAG);\n                if (messageSentFlag == null || !Boolean.valueOf(messageSentFlag.getValue())) {\n                    _messageBus.publish(_name, \"VM_ReservedCapacity_Free\", PublishScope.LOCAL, vm);\n\n                    if (vm.getType() == VirtualMachine.Type.User) {\n                        UserVmVO userVM = _userVMDao.findById(vm.getId());\n                        _userVMDao.loadDetails(userVM);\n                        userVM.setDetail(MESSAGE_RESERVED_CAPACITY_FREED_FLAG, \"true\");\n                        _userVMDao.saveDetails(userVM);\n                    }\n                }\n            }\n        }\n\n        CapacityVO cpuCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_CPU);\n        CapacityVO memCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_MEMORY);\n        CapacityVO cpuCoreCap = _capacityDao.findByHostIdType(host.getId(), CapacityVO.CAPACITY_TYPE_CPU_CORE);\n\n        if (cpuCoreCap != null) {\n            long hostTotalCpuCore = host.getCpus().longValue();\n\n            if (cpuCoreCap.getTotalCapacity() != hostTotalCpuCore) {\n                s_logger.debug(\"Calibrate total cpu for host: \" + host.getId() + \" old total CPU:\"\n                        + cpuCoreCap.getTotalCapacity() + \" new total CPU:\" + hostTotalCpuCore);\n                cpuCoreCap.setTotalCapacity(hostTotalCpuCore);\n\n            }\n\n            if (cpuCoreCap.getUsedCapacity() == usedCpuCore && cpuCoreCap.getReservedCapacity() == reservedCpuCore) {\n                s_logger.debug(\"No need to calibrate cpu capacity, host:\" + host.getId() + \" usedCpuCore: \" + cpuCoreCap.getUsedCapacity()\n                        + \" reservedCpuCore: \" + cpuCoreCap.getReservedCapacity());\n            } else {\n                if (cpuCoreCap.getReservedCapacity() != reservedCpuCore) {\n                    s_logger.debug(\"Calibrate reserved cpu core for host: \" + host.getId() + \" old reservedCpuCore:\"\n                            + cpuCoreCap.getReservedCapacity() + \" new reservedCpuCore:\" + reservedCpuCore);\n                    cpuCoreCap.setReservedCapacity(reservedCpuCore);\n                }\n                if (cpuCoreCap.getUsedCapacity() != usedCpuCore) {\n                    s_logger.debug(\"Calibrate used cpu core for host: \" + host.getId() + \" old usedCpuCore:\"\n                            + cpuCoreCap.getUsedCapacity() + \" new usedCpuCore:\" + usedCpuCore);\n                    cpuCoreCap.setUsedCapacity(usedCpuCore);\n                }\n            }\n            try {\n                _capacityDao.update(cpuCoreCap.getId(), cpuCoreCap);\n            } catch (Exception e) {\n                s_logger.error(\"Caught exception while updating cpucore capacity for the host \" +host.getId(), e);\n            }\n        } else {\n            final long usedCpuCoreFinal = usedCpuCore;\n            final long reservedCpuCoreFinal = reservedCpuCore;\n            Transaction.execute(new TransactionCallbackNoReturn() {\n                @Override\n                public void doInTransactionWithoutResult(TransactionStatus status) {\n                    CapacityVO capacity = new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedCpuCoreFinal, host.getCpus().longValue(),\n                            CapacityVO.CAPACITY_TYPE_CPU_CORE);\n                    capacity.setReservedCapacity(reservedCpuCoreFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n                }\n            });\n        }\n\n        if (cpuCap != null && memCap != null) {\n            if (host.getTotalMemory() != null) {\n                memCap.setTotalCapacity(host.getTotalMemory());\n            }\n            long hostTotalCpu = host.getCpus().longValue() * host.getSpeed().longValue();\n\n            if (cpuCap.getTotalCapacity() != hostTotalCpu) {\n                s_logger.debug(\"Calibrate total cpu for host: \" + host.getId() + \" old total CPU:\" + cpuCap.getTotalCapacity() + \" new total CPU:\" + hostTotalCpu);\n                cpuCap.setTotalCapacity(hostTotalCpu);\n\n            }\n            \r\n            if(capacityState != cpuCap.getCapacityState()){\n                s_logger.debug(\"Calibrate cpu capacity state for host: \" + host.getId() + \" old capacity state:\" + cpuCap.getTotalCapacity() + \" new capacity state:\" + hostTotalCpu);\n                cpuCap.setCapacityState(capacityState);\n            }\n            memCap.setCapacityState(capacityState);\n\n            if (cpuCap.getUsedCapacity() == usedCpu && cpuCap.getReservedCapacity() == reservedCpu) {\n                s_logger.debug(\"No need to calibrate cpu capacity, host:\" + host.getId() + \" usedCpu: \" + cpuCap.getUsedCapacity() + \" reservedCpu: \" +\n                    cpuCap.getReservedCapacity());\n            } else {\n                if (cpuCap.getReservedCapacity() != reservedCpu) {\n                    s_logger.debug(\"Calibrate reserved cpu for host: \" + host.getId() + \" old reservedCpu:\" + cpuCap.getReservedCapacity() + \" new reservedCpu:\" +\n                        reservedCpu);\n                    cpuCap.setReservedCapacity(reservedCpu);\n                }\n                if (cpuCap.getUsedCapacity() != usedCpu) {\n                    s_logger.debug(\"Calibrate used cpu for host: \" + host.getId() + \" old usedCpu:\" + cpuCap.getUsedCapacity() + \" new usedCpu:\" + usedCpu);\n                    cpuCap.setUsedCapacity(usedCpu);\n                }\n            }\n\n            if (memCap.getTotalCapacity() != host.getTotalMemory()) {\n                s_logger.debug(\"Calibrate total memory for host: \" + host.getId() + \" old total memory:\" + memCap.getTotalCapacity() + \" new total memory:\" +\n                    host.getTotalMemory());\n                memCap.setTotalCapacity(host.getTotalMemory());\n\n            }\n            \r\n            if(capacityState != memCap.getCapacityState()){\n                s_logger.debug(\"Calibrate memory capacity state for host: \" + host.getId() + \" old capacity state:\" + memCap.getTotalCapacity() + \" new capacity state:\" + hostTotalCpu);\n                memCap.setCapacityState(capacityState);\n            }\n\n            if (memCap.getUsedCapacity() == usedMemory && memCap.getReservedCapacity() == reservedMemory) {\n                s_logger.debug(\"No need to calibrate memory capacity, host:\" + host.getId() + \" usedMem: \" + memCap.getUsedCapacity() + \" reservedMem: \" +\n                    memCap.getReservedCapacity());\n            } else {\n                if (memCap.getReservedCapacity() != reservedMemory) {\n                    s_logger.debug(\"Calibrate reserved memory for host: \" + host.getId() + \" old reservedMem:\" + memCap.getReservedCapacity() + \" new reservedMem:\" +\n                        reservedMemory);\n                    memCap.setReservedCapacity(reservedMemory);\n                }\n                if (memCap.getUsedCapacity() != usedMemory) {\n                    \r\n\r\n\r\n\r\n\n                    s_logger.debug(\"Calibrate used memory for host: \" + host.getId() + \" old usedMem: \" + memCap.getUsedCapacity() + \" new usedMem: \" + usedMemory);\n                    memCap.setUsedCapacity(usedMemory);\n                }\n            }\n\n            try {\n                _capacityDao.update(cpuCap.getId(), cpuCap);\n                _capacityDao.update(memCap.getId(), memCap);\n            } catch (Exception e) {\n                s_logger.error(\"Caught exception while updating cpu/memory capacity for the host \" + host.getId(), e);\n            }\n        } else {\n            final long usedMemoryFinal = usedMemory;\n            final long reservedMemoryFinal = reservedMemory;\n            final long usedCpuFinal = usedCpu;\n            final long reservedCpuFinal = reservedCpu;\n            Transaction.execute(new TransactionCallbackNoReturn() {\n                @Override\n                public void doInTransactionWithoutResult(TransactionStatus status) {\n                    CapacityVO capacity =\n                        new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedMemoryFinal, host.getTotalMemory(),\n                            Capacity.CAPACITY_TYPE_MEMORY);\n                    capacity.setReservedCapacity(reservedMemoryFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n\n                    capacity =\n                        new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedCpuFinal, host.getCpus().longValue() *\n                            host.getSpeed().longValue(), Capacity.CAPACITY_TYPE_CPU);\n                    capacity.setReservedCapacity(reservedCpuFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n                }\n            });\n\n        }\n\n    }\n","realPath":"server/src/main/java/com/cloud/capacity/CapacityManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":573,"status":"M"}],"commitId":"76a4e56ef30c506a6f0435f66a024ae62fe0e23e","commitMessage":"@@@Merge branch '4.11'\n","date":"2018-05-23 23:12:10","modifiedFileCount":"4","status":"M","submitter":"Rohit Yadav"},{"authorTime":"2019-05-23 14:17:53","codes":[{"authorDate":"2018-01-20 05:49:27","commitOrder":3,"curCode":"    public void recalculateCapacity() {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        try {\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"recalculating system capacity\");\n                s_logger.debug(\"Executing cpu/ram capacity update\");\n            }\n\n            \r\n            \r\n            List<HostVO> hosts = _resourceMgr.listAllNotInMaintenanceHostsInOneZone(Host.Type.Routing, null);\n            if (hosts != null) {\n                for (HostVO host : hosts) {\n                    _capacityMgr.updateCapacityForHost(host);\n                }\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing cpu/ram capacity update\");\n                s_logger.debug(\"Executing storage capacity update\");\n            }\n            \r\n            List<StoragePoolVO> storagePools = _storagePoolDao.listAll();\n            for (StoragePoolVO pool : storagePools) {\n                long disk = _capacityMgr.getAllocatedPoolCapacity(pool, null);\n                if (pool.isShared()) {\n                    _storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_STORAGE_ALLOCATED, disk);\n                } else {\n                    _storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_LOCAL_STORAGE, disk);\n                }\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing storage capacity update\");\n                s_logger.debug(\"Executing capacity updates for public ip and Vlans\");\n            }\n\n            List<DataCenterVO> datacenters = _dcDao.listAll();\n            for (DataCenterVO datacenter : datacenters) {\n                long dcId = datacenter.getId();\n\n                \r\n                \r\n                \r\n                \r\n                \r\n\n                \r\n                if (datacenter.getNetworkType() == NetworkType.Advanced) {\n                    createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_VIRTUAL_NETWORK_PUBLIC_IP, datacenter.getAllocationState());\n                }\n\n                \r\n                createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_DIRECT_ATTACHED_PUBLIC_IP, datacenter.getAllocationState());\n\n                if (datacenter.getNetworkType() == NetworkType.Advanced) {\n                    \r\n                    createOrUpdateVlanCapacity(dcId, datacenter.getAllocationState());\n                }\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done capacity updates for public ip and Vlans\");\n                s_logger.debug(\"Executing capacity updates for private ip\");\n            }\n\n            \r\n            List<HostPodVO> pods = _podDao.listAll();\n            for (HostPodVO pod : pods) {\n                long podId = pod.getId();\n                long dcId = pod.getDataCenterId();\n\n                createOrUpdateIpCapacity(dcId, podId, Capacity.CAPACITY_TYPE_PRIVATE_IP, _configMgr.findPodAllocationState(pod));\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing capacity updates for private ip\");\n                s_logger.debug(\"Done recalculating system capacity\");\n            }\n\n        } catch (Throwable t) {\n            s_logger.error(\"Caught exception in recalculating capacity\", t);\n        }\n    }\n","date":"2018-01-20 05:49:27","endLine":350,"groupId":"23680","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"recalculateCapacity","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/a5/8a4f8b0f91450e931ce96c942160b57ca0b1fa.src","preCode":"    public void recalculateCapacity() {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        try {\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"recalculating system capacity\");\n                s_logger.debug(\"Executing cpu/ram capacity update\");\n            }\n\n            \r\n            \r\n            List<HostVO> hosts = _resourceMgr.listAllNotInMaintenanceHostsInOneZone(Host.Type.Routing, null);\n            if (hosts != null) {\n                for (HostVO host : hosts) {\n                    _capacityMgr.updateCapacityForHost(host);\n                }\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing cpu/ram capacity update\");\n                s_logger.debug(\"Executing storage capacity update\");\n            }\n            \r\n            List<StoragePoolVO> storagePools = _storagePoolDao.listAll();\n            for (StoragePoolVO pool : storagePools) {\n                long disk = _capacityMgr.getAllocatedPoolCapacity(pool, null);\n                if (pool.isShared()) {\n                    _storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_STORAGE_ALLOCATED, disk);\n                } else {\n                    _storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_LOCAL_STORAGE, disk);\n                }\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing storage capacity update\");\n                s_logger.debug(\"Executing capacity updates for public ip and Vlans\");\n            }\n\n            List<DataCenterVO> datacenters = _dcDao.listAll();\n            for (DataCenterVO datacenter : datacenters) {\n                long dcId = datacenter.getId();\n\n                \r\n                \r\n                \r\n                \r\n                \r\n\n                \r\n                if (datacenter.getNetworkType() == NetworkType.Advanced) {\n                    createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_VIRTUAL_NETWORK_PUBLIC_IP, datacenter.getAllocationState());\n                }\n\n                \r\n                createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_DIRECT_ATTACHED_PUBLIC_IP, datacenter.getAllocationState());\n\n                if (datacenter.getNetworkType() == NetworkType.Advanced) {\n                    \r\n                    createOrUpdateVlanCapacity(dcId, datacenter.getAllocationState());\n                }\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done capacity updates for public ip and Vlans\");\n                s_logger.debug(\"Executing capacity updates for private ip\");\n            }\n\n            \r\n            List<HostPodVO> pods = _podDao.listAll();\n            for (HostPodVO pod : pods) {\n                long podId = pod.getId();\n                long dcId = pod.getDataCenterId();\n\n                createOrUpdateIpCapacity(dcId, podId, Capacity.CAPACITY_TYPE_PRIVATE_IP, _configMgr.findPodAllocationState(pod));\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing capacity updates for private ip\");\n                s_logger.debug(\"Done recalculating system capacity\");\n            }\n\n        } catch (Throwable t) {\n            s_logger.error(\"Caught exception in recalculating capacity\", t);\n        }\n    }\n","realPath":"server/src/main/java/com/cloud/alert/AlertManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":261,"status":"N"},{"authorDate":"2019-05-23 14:17:53","commitOrder":3,"curCode":"    public void updateCapacityForHost(final Host host) {\n        \r\n        List<ServiceOfferingVO> offerings = _offeringsDao.listAllIncludingRemoved();\n        Map<Long, ServiceOfferingVO> offeringsMap = new HashMap<Long, ServiceOfferingVO>();\n        for (ServiceOfferingVO offering : offerings) {\n            offeringsMap.put(offering.getId(), offering);\n        }\n\n        long usedCpuCore = 0;\n        long reservedCpuCore = 0;\n        long usedCpu = 0;\n        long usedMemory = 0;\n        long reservedMemory = 0;\n        long reservedCpu = 0;\n        final CapacityState capacityState = (host.getResourceState() == ResourceState.Enabled) ? CapacityState.Enabled : CapacityState.Disabled;\n\n        List<VMInstanceVO> vms = _vmDao.listUpByHostId(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vms.size() + \" VMs on host \" + host.getId());\n        }\n\n        ClusterVO cluster = _clusterDao.findById(host.getClusterId());\n        ClusterDetailsVO clusterDetailCpu = _clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n        ClusterDetailsVO clusterDetailRam = _clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n        Float clusterCpuOvercommitRatio = Float.parseFloat(clusterDetailCpu.getValue());\n        Float clusterRamOvercommitRatio = Float.parseFloat(clusterDetailRam.getValue());\n        for (VMInstanceVO vm : vms) {\n            Float cpuOvercommitRatio = 1.0f;\n            Float ramOvercommitRatio = 1.0f;\n            Map<String, String> vmDetails = _userVmDetailsDao.listDetailsKeyPairs(vm.getId());\n            String vmDetailCpu = vmDetails.get(\"cpuOvercommitRatio\");\n            String vmDetailRam = vmDetails.get(\"memoryOvercommitRatio\");\n            if (vmDetailCpu != null) {\n                \r\n                cpuOvercommitRatio = Float.parseFloat(vmDetailCpu);\n                ramOvercommitRatio = Float.parseFloat(vmDetailRam);\n            }\n            ServiceOffering so = offeringsMap.get(vm.getServiceOfferingId());\n            if (so.isDynamic()) {\n                usedMemory +=\n                    ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.memory.name())) * 1024L * 1024L) / ramOvercommitRatio) *\n                        clusterRamOvercommitRatio;\n                if(vmDetails.containsKey(UsageEventVO.DynamicParameters.cpuSpeed.name())) {\n                    usedCpu +=\n                            ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuSpeed.name()))) / cpuOvercommitRatio) *\n                                    clusterCpuOvercommitRatio;\n                } else {\n                    usedCpu +=\n                            ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * so.getSpeed()) / cpuOvercommitRatio) *\n                                    clusterCpuOvercommitRatio;\n                }\n                usedCpuCore += Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name()));\n            } else {\n                usedMemory += ((so.getRamSize() * 1024L * 1024L) / ramOvercommitRatio) * clusterRamOvercommitRatio;\n                usedCpu += ((so.getCpu() * so.getSpeed()) / cpuOvercommitRatio) * clusterCpuOvercommitRatio;\n                usedCpuCore += so.getCpu();\n            }\n        }\n\n        List<VMInstanceVO> vmsByLastHostId = _vmDao.listByLastHostId(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vmsByLastHostId.size() + \" VM, not running on host \" + host.getId());\n        }\n        for (VMInstanceVO vm : vmsByLastHostId) {\n            Float cpuOvercommitRatio = 1.0f;\n            Float ramOvercommitRatio = 1.0f;\n            long secondsSinceLastUpdate = (DateUtil.currentGMTTime().getTime() - vm.getUpdateTime().getTime()) / 1000;\n            if (secondsSinceLastUpdate < _vmCapacityReleaseInterval) {\n                UserVmDetailVO vmDetailCpu = _userVmDetailsDao.findDetail(vm.getId(), \"cpuOvercommitRatio\");\n                UserVmDetailVO vmDetailRam = _userVmDetailsDao.findDetail(vm.getId(), \"memoryOvercommitRatio\");\n                if (vmDetailCpu != null) {\n                    \r\n                    cpuOvercommitRatio = Float.parseFloat(vmDetailCpu.getValue());\n                    ramOvercommitRatio = Float.parseFloat(vmDetailRam.getValue());\n                }\n                ServiceOffering so = offeringsMap.get(vm.getServiceOfferingId());\n                Map<String, String> vmDetails = _userVmDetailsDao.listDetailsKeyPairs(vm.getId());\n                if (so.isDynamic()) {\n                    reservedMemory +=\n                        ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.memory.name())) * 1024L * 1024L) / ramOvercommitRatio) *\n                            clusterRamOvercommitRatio;\n                    if(vmDetails.containsKey(UsageEventVO.DynamicParameters.cpuSpeed.name())) {\n                        reservedCpu +=\n                                ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuSpeed.name()))) / cpuOvercommitRatio) *\n                                        clusterCpuOvercommitRatio;\n                    } else {\n                        reservedCpu +=\n                                ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * so.getSpeed()) / cpuOvercommitRatio) *\n                                        clusterCpuOvercommitRatio;\n                    }\n                    reservedCpuCore += Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name()));\n                } else {\n                    reservedMemory += ((so.getRamSize() * 1024L * 1024L) / ramOvercommitRatio) * clusterRamOvercommitRatio;\n                    reservedCpu += (so.getCpu() * so.getSpeed() / cpuOvercommitRatio) * clusterCpuOvercommitRatio;\n                    reservedCpuCore += so.getCpu();\n                }\n            } else {\n                \r\n                \r\n                UserVmDetailVO messageSentFlag = _userVmDetailsDao.findDetail(vm.getId(), MESSAGE_RESERVED_CAPACITY_FREED_FLAG);\n                if (messageSentFlag == null || !Boolean.valueOf(messageSentFlag.getValue())) {\n                    _messageBus.publish(_name, \"VM_ReservedCapacity_Free\", PublishScope.LOCAL, vm);\n\n                    if (vm.getType() == VirtualMachine.Type.User) {\n                        UserVmVO userVM = _userVMDao.findById(vm.getId());\n                        _userVMDao.loadDetails(userVM);\n                        userVM.setDetail(MESSAGE_RESERVED_CAPACITY_FREED_FLAG, \"true\");\n                        _userVMDao.saveDetails(userVM);\n                    }\n                }\n            }\n        }\n\n        CapacityVO cpuCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_CPU);\n        CapacityVO memCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_MEMORY);\n        CapacityVO cpuCoreCap = _capacityDao.findByHostIdType(host.getId(), CapacityVO.CAPACITY_TYPE_CPU_CORE);\n\n        if (cpuCoreCap != null) {\n            long hostTotalCpuCore = host.getCpus().longValue();\n\n            if (cpuCoreCap.getTotalCapacity() != hostTotalCpuCore) {\n                s_logger.debug(\"Calibrate total cpu for host: \" + host.getId() + \" old total CPU:\"\n                        + cpuCoreCap.getTotalCapacity() + \" new total CPU:\" + hostTotalCpuCore);\n                cpuCoreCap.setTotalCapacity(hostTotalCpuCore);\n\n            }\n\n            if (cpuCoreCap.getUsedCapacity() == usedCpuCore && cpuCoreCap.getReservedCapacity() == reservedCpuCore) {\n                s_logger.debug(\"No need to calibrate cpu capacity, host:\" + host.getId() + \" usedCpuCore: \" + cpuCoreCap.getUsedCapacity()\n                        + \" reservedCpuCore: \" + cpuCoreCap.getReservedCapacity());\n            } else {\n                if (cpuCoreCap.getReservedCapacity() != reservedCpuCore) {\n                    s_logger.debug(\"Calibrate reserved cpu core for host: \" + host.getId() + \" old reservedCpuCore:\"\n                            + cpuCoreCap.getReservedCapacity() + \" new reservedCpuCore:\" + reservedCpuCore);\n                    cpuCoreCap.setReservedCapacity(reservedCpuCore);\n                }\n                if (cpuCoreCap.getUsedCapacity() != usedCpuCore) {\n                    s_logger.debug(\"Calibrate used cpu core for host: \" + host.getId() + \" old usedCpuCore:\"\n                            + cpuCoreCap.getUsedCapacity() + \" new usedCpuCore:\" + usedCpuCore);\n                    cpuCoreCap.setUsedCapacity(usedCpuCore);\n                }\n            }\n            try {\n                _capacityDao.update(cpuCoreCap.getId(), cpuCoreCap);\n            } catch (Exception e) {\n                s_logger.error(\"Caught exception while updating cpucore capacity for the host \" +host.getId(), e);\n            }\n        } else {\n            final long usedCpuCoreFinal = usedCpuCore;\n            final long reservedCpuCoreFinal = reservedCpuCore;\n            Transaction.execute(new TransactionCallbackNoReturn() {\n                @Override\n                public void doInTransactionWithoutResult(TransactionStatus status) {\n                    CapacityVO capacity = new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedCpuCoreFinal, host.getCpus().longValue(),\n                            CapacityVO.CAPACITY_TYPE_CPU_CORE);\n                    capacity.setReservedCapacity(reservedCpuCoreFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n                }\n            });\n        }\n\n        if (cpuCap != null && memCap != null) {\n            if (host.getTotalMemory() != null) {\n                memCap.setTotalCapacity(host.getTotalMemory());\n            }\n            long hostTotalCpu = host.getCpus().longValue() * host.getSpeed().longValue();\n\n            if (cpuCap.getTotalCapacity() != hostTotalCpu) {\n                s_logger.debug(\"Calibrate total cpu for host: \" + host.getId() + \" old total CPU:\" + cpuCap.getTotalCapacity() + \" new total CPU:\" + hostTotalCpu);\n                cpuCap.setTotalCapacity(hostTotalCpu);\n\n            }\n            \r\n            if(capacityState != cpuCap.getCapacityState()){\n                s_logger.debug(\"Calibrate cpu capacity state for host: \" + host.getId() + \" old capacity state:\" + cpuCap.getTotalCapacity() + \" new capacity state:\" + hostTotalCpu);\n                cpuCap.setCapacityState(capacityState);\n            }\n            memCap.setCapacityState(capacityState);\n\n            if (cpuCap.getUsedCapacity() == usedCpu && cpuCap.getReservedCapacity() == reservedCpu) {\n                s_logger.debug(\"No need to calibrate cpu capacity, host:\" + host.getId() + \" usedCpu: \" + cpuCap.getUsedCapacity() + \" reservedCpu: \" +\n                    cpuCap.getReservedCapacity());\n            } else {\n                if (cpuCap.getReservedCapacity() != reservedCpu) {\n                    s_logger.debug(\"Calibrate reserved cpu for host: \" + host.getId() + \" old reservedCpu:\" + cpuCap.getReservedCapacity() + \" new reservedCpu:\" +\n                        reservedCpu);\n                    cpuCap.setReservedCapacity(reservedCpu);\n                }\n                if (cpuCap.getUsedCapacity() != usedCpu) {\n                    s_logger.debug(\"Calibrate used cpu for host: \" + host.getId() + \" old usedCpu:\" + cpuCap.getUsedCapacity() + \" new usedCpu:\" + usedCpu);\n                    cpuCap.setUsedCapacity(usedCpu);\n                }\n            }\n\n            if (memCap.getTotalCapacity() != host.getTotalMemory()) {\n                s_logger.debug(\"Calibrate total memory for host: \" + host.getId() + \" old total memory:\" + memCap.getTotalCapacity() + \" new total memory:\" +\n                    host.getTotalMemory());\n                memCap.setTotalCapacity(host.getTotalMemory());\n\n            }\n            \r\n            if(capacityState != memCap.getCapacityState()){\n                s_logger.debug(\"Calibrate memory capacity state for host: \" + host.getId() + \" old capacity state:\" + memCap.getTotalCapacity() + \" new capacity state:\" + hostTotalCpu);\n                memCap.setCapacityState(capacityState);\n            }\n\n            if (memCap.getUsedCapacity() == usedMemory && memCap.getReservedCapacity() == reservedMemory) {\n                s_logger.debug(\"No need to calibrate memory capacity, host:\" + host.getId() + \" usedMem: \" + memCap.getUsedCapacity() + \" reservedMem: \" +\n                    memCap.getReservedCapacity());\n            } else {\n                if (memCap.getReservedCapacity() != reservedMemory) {\n                    s_logger.debug(\"Calibrate reserved memory for host: \" + host.getId() + \" old reservedMem:\" + memCap.getReservedCapacity() + \" new reservedMem:\" +\n                        reservedMemory);\n                    memCap.setReservedCapacity(reservedMemory);\n                }\n                if (memCap.getUsedCapacity() != usedMemory) {\n                    \r\n\r\n\r\n\r\n\n                    s_logger.debug(\"Calibrate used memory for host: \" + host.getId() + \" old usedMem: \" + memCap.getUsedCapacity() + \" new usedMem: \" + usedMemory);\n                    memCap.setUsedCapacity(usedMemory);\n                }\n            }\n\n            try {\n                _capacityDao.update(cpuCap.getId(), cpuCap);\n                _capacityDao.update(memCap.getId(), memCap);\n            } catch (Exception e) {\n                s_logger.error(\"Caught exception while updating cpu/memory capacity for the host \" + host.getId(), e);\n            }\n        } else {\n            final long usedMemoryFinal = usedMemory;\n            final long reservedMemoryFinal = reservedMemory;\n            final long usedCpuFinal = usedCpu;\n            final long reservedCpuFinal = reservedCpu;\n            Transaction.execute(new TransactionCallbackNoReturn() {\n                @Override\n                public void doInTransactionWithoutResult(TransactionStatus status) {\n                    CapacityVO capacity =\n                        new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedMemoryFinal, host.getTotalMemory(),\n                            Capacity.CAPACITY_TYPE_MEMORY);\n                    capacity.setReservedCapacity(reservedMemoryFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n\n                    capacity =\n                        new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedCpuFinal, host.getCpus().longValue() *\n                            host.getSpeed().longValue(), Capacity.CAPACITY_TYPE_CPU);\n                    capacity.setReservedCapacity(reservedCpuFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n                }\n            });\n\n        }\n\n    }\n","date":"2019-05-23 14:17:53","endLine":832,"groupId":"10980","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"updateCapacityForHost","params":"(finalHosthost)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/67/75bfc6cff07d601c9da37412240dde096e6a98.src","preCode":"    public void updateCapacityForHost(final Host host) {\n        \r\n        List<ServiceOfferingVO> offerings = _offeringsDao.listAllIncludingRemoved();\n        Map<Long, ServiceOfferingVO> offeringsMap = new HashMap<Long, ServiceOfferingVO>();\n        for (ServiceOfferingVO offering : offerings) {\n            offeringsMap.put(offering.getId(), offering);\n        }\n\n        long usedCpuCore = 0;\n        long reservedCpuCore = 0;\n        long usedCpu = 0;\n        long usedMemory = 0;\n        long reservedMemory = 0;\n        long reservedCpu = 0;\n        final CapacityState capacityState = (host.getResourceState() == ResourceState.Enabled) ? CapacityState.Enabled : CapacityState.Disabled;\n\n        List<VMInstanceVO> vms = _vmDao.listUpByHostId(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vms.size() + \" VMs on host \" + host.getId());\n        }\n\n        ClusterVO cluster = _clusterDao.findById(host.getClusterId());\n        ClusterDetailsVO clusterDetailCpu = _clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n        ClusterDetailsVO clusterDetailRam = _clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n        Float clusterCpuOvercommitRatio = Float.parseFloat(clusterDetailCpu.getValue());\n        Float clusterRamOvercommitRatio = Float.parseFloat(clusterDetailRam.getValue());\n        for (VMInstanceVO vm : vms) {\n            Float cpuOvercommitRatio = 1.0f;\n            Float ramOvercommitRatio = 1.0f;\n            Map<String, String> vmDetails = _userVmDetailsDao.listDetailsKeyPairs(vm.getId());\n            String vmDetailCpu = vmDetails.get(\"cpuOvercommitRatio\");\n            String vmDetailRam = vmDetails.get(\"memoryOvercommitRatio\");\n            if (vmDetailCpu != null) {\n                \r\n                cpuOvercommitRatio = Float.parseFloat(vmDetailCpu);\n                ramOvercommitRatio = Float.parseFloat(vmDetailRam);\n            }\n            ServiceOffering so = offeringsMap.get(vm.getServiceOfferingId());\n            if (so.isDynamic()) {\n                usedMemory +=\n                    ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.memory.name())) * 1024L * 1024L) / ramOvercommitRatio) *\n                        clusterRamOvercommitRatio;\n                usedCpu +=\n                    ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuSpeed.name()))) / cpuOvercommitRatio) *\n                        clusterCpuOvercommitRatio;\n                usedCpuCore += Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name()));\n            } else {\n                usedMemory += ((so.getRamSize() * 1024L * 1024L) / ramOvercommitRatio) * clusterRamOvercommitRatio;\n                usedCpu += ((so.getCpu() * so.getSpeed()) / cpuOvercommitRatio) * clusterCpuOvercommitRatio;\n                usedCpuCore += so.getCpu();\n            }\n        }\n\n        List<VMInstanceVO> vmsByLastHostId = _vmDao.listByLastHostId(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vmsByLastHostId.size() + \" VM, not running on host \" + host.getId());\n        }\n        for (VMInstanceVO vm : vmsByLastHostId) {\n            Float cpuOvercommitRatio = 1.0f;\n            Float ramOvercommitRatio = 1.0f;\n            long secondsSinceLastUpdate = (DateUtil.currentGMTTime().getTime() - vm.getUpdateTime().getTime()) / 1000;\n            if (secondsSinceLastUpdate < _vmCapacityReleaseInterval) {\n                UserVmDetailVO vmDetailCpu = _userVmDetailsDao.findDetail(vm.getId(), \"cpuOvercommitRatio\");\n                UserVmDetailVO vmDetailRam = _userVmDetailsDao.findDetail(vm.getId(), \"memoryOvercommitRatio\");\n                if (vmDetailCpu != null) {\n                    \r\n                    cpuOvercommitRatio = Float.parseFloat(vmDetailCpu.getValue());\n                    ramOvercommitRatio = Float.parseFloat(vmDetailRam.getValue());\n                }\n                ServiceOffering so = offeringsMap.get(vm.getServiceOfferingId());\n                Map<String, String> vmDetails = _userVmDetailsDao.listDetailsKeyPairs(vm.getId());\n                if (so.isDynamic()) {\n                    reservedMemory +=\n                        ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.memory.name())) * 1024L * 1024L) / ramOvercommitRatio) *\n                            clusterRamOvercommitRatio;\n                    reservedCpu +=\n                        ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuSpeed.name()))) / cpuOvercommitRatio) *\n                            clusterCpuOvercommitRatio;\n                    reservedCpuCore += Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name()));\n                } else {\n                    reservedMemory += ((so.getRamSize() * 1024L * 1024L) / ramOvercommitRatio) * clusterRamOvercommitRatio;\n                    reservedCpu += (so.getCpu() * so.getSpeed() / cpuOvercommitRatio) * clusterCpuOvercommitRatio;\n                    reservedCpuCore += so.getCpu();\n                }\n            } else {\n                \r\n                \r\n                UserVmDetailVO messageSentFlag = _userVmDetailsDao.findDetail(vm.getId(), MESSAGE_RESERVED_CAPACITY_FREED_FLAG);\n                if (messageSentFlag == null || !Boolean.valueOf(messageSentFlag.getValue())) {\n                    _messageBus.publish(_name, \"VM_ReservedCapacity_Free\", PublishScope.LOCAL, vm);\n\n                    if (vm.getType() == VirtualMachine.Type.User) {\n                        UserVmVO userVM = _userVMDao.findById(vm.getId());\n                        _userVMDao.loadDetails(userVM);\n                        userVM.setDetail(MESSAGE_RESERVED_CAPACITY_FREED_FLAG, \"true\");\n                        _userVMDao.saveDetails(userVM);\n                    }\n                }\n            }\n        }\n\n        CapacityVO cpuCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_CPU);\n        CapacityVO memCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_MEMORY);\n        CapacityVO cpuCoreCap = _capacityDao.findByHostIdType(host.getId(), CapacityVO.CAPACITY_TYPE_CPU_CORE);\n\n        if (cpuCoreCap != null) {\n            long hostTotalCpuCore = host.getCpus().longValue();\n\n            if (cpuCoreCap.getTotalCapacity() != hostTotalCpuCore) {\n                s_logger.debug(\"Calibrate total cpu for host: \" + host.getId() + \" old total CPU:\"\n                        + cpuCoreCap.getTotalCapacity() + \" new total CPU:\" + hostTotalCpuCore);\n                cpuCoreCap.setTotalCapacity(hostTotalCpuCore);\n\n            }\n\n            if (cpuCoreCap.getUsedCapacity() == usedCpuCore && cpuCoreCap.getReservedCapacity() == reservedCpuCore) {\n                s_logger.debug(\"No need to calibrate cpu capacity, host:\" + host.getId() + \" usedCpuCore: \" + cpuCoreCap.getUsedCapacity()\n                        + \" reservedCpuCore: \" + cpuCoreCap.getReservedCapacity());\n            } else {\n                if (cpuCoreCap.getReservedCapacity() != reservedCpuCore) {\n                    s_logger.debug(\"Calibrate reserved cpu core for host: \" + host.getId() + \" old reservedCpuCore:\"\n                            + cpuCoreCap.getReservedCapacity() + \" new reservedCpuCore:\" + reservedCpuCore);\n                    cpuCoreCap.setReservedCapacity(reservedCpuCore);\n                }\n                if (cpuCoreCap.getUsedCapacity() != usedCpuCore) {\n                    s_logger.debug(\"Calibrate used cpu core for host: \" + host.getId() + \" old usedCpuCore:\"\n                            + cpuCoreCap.getUsedCapacity() + \" new usedCpuCore:\" + usedCpuCore);\n                    cpuCoreCap.setUsedCapacity(usedCpuCore);\n                }\n            }\n            try {\n                _capacityDao.update(cpuCoreCap.getId(), cpuCoreCap);\n            } catch (Exception e) {\n                s_logger.error(\"Caught exception while updating cpucore capacity for the host \" +host.getId(), e);\n            }\n        } else {\n            final long usedCpuCoreFinal = usedCpuCore;\n            final long reservedCpuCoreFinal = reservedCpuCore;\n            Transaction.execute(new TransactionCallbackNoReturn() {\n                @Override\n                public void doInTransactionWithoutResult(TransactionStatus status) {\n                    CapacityVO capacity = new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedCpuCoreFinal, host.getCpus().longValue(),\n                            CapacityVO.CAPACITY_TYPE_CPU_CORE);\n                    capacity.setReservedCapacity(reservedCpuCoreFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n                }\n            });\n        }\n\n        if (cpuCap != null && memCap != null) {\n            if (host.getTotalMemory() != null) {\n                memCap.setTotalCapacity(host.getTotalMemory());\n            }\n            long hostTotalCpu = host.getCpus().longValue() * host.getSpeed().longValue();\n\n            if (cpuCap.getTotalCapacity() != hostTotalCpu) {\n                s_logger.debug(\"Calibrate total cpu for host: \" + host.getId() + \" old total CPU:\" + cpuCap.getTotalCapacity() + \" new total CPU:\" + hostTotalCpu);\n                cpuCap.setTotalCapacity(hostTotalCpu);\n\n            }\n            \r\n            if(capacityState != cpuCap.getCapacityState()){\n                s_logger.debug(\"Calibrate cpu capacity state for host: \" + host.getId() + \" old capacity state:\" + cpuCap.getTotalCapacity() + \" new capacity state:\" + hostTotalCpu);\n                cpuCap.setCapacityState(capacityState);\n            }\n            memCap.setCapacityState(capacityState);\n\n            if (cpuCap.getUsedCapacity() == usedCpu && cpuCap.getReservedCapacity() == reservedCpu) {\n                s_logger.debug(\"No need to calibrate cpu capacity, host:\" + host.getId() + \" usedCpu: \" + cpuCap.getUsedCapacity() + \" reservedCpu: \" +\n                    cpuCap.getReservedCapacity());\n            } else {\n                if (cpuCap.getReservedCapacity() != reservedCpu) {\n                    s_logger.debug(\"Calibrate reserved cpu for host: \" + host.getId() + \" old reservedCpu:\" + cpuCap.getReservedCapacity() + \" new reservedCpu:\" +\n                        reservedCpu);\n                    cpuCap.setReservedCapacity(reservedCpu);\n                }\n                if (cpuCap.getUsedCapacity() != usedCpu) {\n                    s_logger.debug(\"Calibrate used cpu for host: \" + host.getId() + \" old usedCpu:\" + cpuCap.getUsedCapacity() + \" new usedCpu:\" + usedCpu);\n                    cpuCap.setUsedCapacity(usedCpu);\n                }\n            }\n\n            if (memCap.getTotalCapacity() != host.getTotalMemory()) {\n                s_logger.debug(\"Calibrate total memory for host: \" + host.getId() + \" old total memory:\" + memCap.getTotalCapacity() + \" new total memory:\" +\n                    host.getTotalMemory());\n                memCap.setTotalCapacity(host.getTotalMemory());\n\n            }\n            \r\n            if(capacityState != memCap.getCapacityState()){\n                s_logger.debug(\"Calibrate memory capacity state for host: \" + host.getId() + \" old capacity state:\" + memCap.getTotalCapacity() + \" new capacity state:\" + hostTotalCpu);\n                memCap.setCapacityState(capacityState);\n            }\n\n            if (memCap.getUsedCapacity() == usedMemory && memCap.getReservedCapacity() == reservedMemory) {\n                s_logger.debug(\"No need to calibrate memory capacity, host:\" + host.getId() + \" usedMem: \" + memCap.getUsedCapacity() + \" reservedMem: \" +\n                    memCap.getReservedCapacity());\n            } else {\n                if (memCap.getReservedCapacity() != reservedMemory) {\n                    s_logger.debug(\"Calibrate reserved memory for host: \" + host.getId() + \" old reservedMem:\" + memCap.getReservedCapacity() + \" new reservedMem:\" +\n                        reservedMemory);\n                    memCap.setReservedCapacity(reservedMemory);\n                }\n                if (memCap.getUsedCapacity() != usedMemory) {\n                    \r\n\r\n\r\n\r\n\n                    s_logger.debug(\"Calibrate used memory for host: \" + host.getId() + \" old usedMem: \" + memCap.getUsedCapacity() + \" new usedMem: \" + usedMemory);\n                    memCap.setUsedCapacity(usedMemory);\n                }\n            }\n\n            try {\n                _capacityDao.update(cpuCap.getId(), cpuCap);\n                _capacityDao.update(memCap.getId(), memCap);\n            } catch (Exception e) {\n                s_logger.error(\"Caught exception while updating cpu/memory capacity for the host \" + host.getId(), e);\n            }\n        } else {\n            final long usedMemoryFinal = usedMemory;\n            final long reservedMemoryFinal = reservedMemory;\n            final long usedCpuFinal = usedCpu;\n            final long reservedCpuFinal = reservedCpu;\n            Transaction.execute(new TransactionCallbackNoReturn() {\n                @Override\n                public void doInTransactionWithoutResult(TransactionStatus status) {\n                    CapacityVO capacity =\n                        new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedMemoryFinal, host.getTotalMemory(),\n                            Capacity.CAPACITY_TYPE_MEMORY);\n                    capacity.setReservedCapacity(reservedMemoryFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n\n                    capacity =\n                        new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedCpuFinal, host.getCpus().longValue() *\n                            host.getSpeed().longValue(), Capacity.CAPACITY_TYPE_CPU);\n                    capacity.setReservedCapacity(reservedCpuFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n                }\n            });\n\n        }\n\n    }\n","realPath":"server/src/main/java/com/cloud/capacity/CapacityManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":573,"status":"M"}],"commitId":"2020bfb6a3bf597d762e162a355ea3dfd26857eb","commitMessage":"@@@server: allows compute offering with or without constraints (#3245)\n\nProblem: Custom compute offering does not allow setting min and max values for CPU and VRAM for custom VMs.\n\nRoot Cause: Custom compute offerings cannot be created with a given range of CPU number and memory instead it allows only fixed values.\n\nSolution: createServiceOffering API has been modified to allow setting a defined range for CPU number and memory. Also.  UI form for compute offering creation is provided with a new field named 'compute offering type? with values - Fixed.  Custom Constrained.  Custom Constrained. It will allow the creation of compute offerings either with a fixed CPU speed and memory for fixed compute offering.  or with a range of CPU number and memory for custom constrained compute offering or without predefined CPU number.  CPU speed and memory for custom unconstrained compute offering.\n\nTo allow the user to set CPU number.  CPU speed and memory during VM deployment.  UI form for VM deployment has been modified to provide controls to change these values. These controls are depicted in screenshots below for custom constrained and custom unconstrained compute offering types.\n\nSample API calls using cmk to create a constrained service offering and deploying a VM using it. \n\ncreate serviceoffering name=Constrained displaytext=Constrained customized=true mincpunumber=2 maxcpunumber=4 cpuspeed=400 minmemory=256 maxmemory=1024\n\ndeploy virtualmachine displayname=ConstrainedVM serviceofferingid=60f3e500-6559-40b2-9a61-2192891c2bd6 templateid=8e0f4a3e-601b-11e9-9df4-a0afbd4a2d60 zoneid=9612a0c6-ed28-4fae-9a48-6eb207af29e3 details[0].cpuNumber=3 details[0].memory=800\n\nSigned-off-by: Abhishek Kumar <abhishek.kumar@shapeblue.com>\n","date":"2019-05-23 14:17:53","modifiedFileCount":"6","status":"M","submitter":"Abhishek Kumar"},{"authorTime":"2019-06-27 11:44:47","codes":[{"authorDate":"2018-01-20 05:49:27","commitOrder":4,"curCode":"    public void recalculateCapacity() {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        try {\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"recalculating system capacity\");\n                s_logger.debug(\"Executing cpu/ram capacity update\");\n            }\n\n            \r\n            \r\n            List<HostVO> hosts = _resourceMgr.listAllNotInMaintenanceHostsInOneZone(Host.Type.Routing, null);\n            if (hosts != null) {\n                for (HostVO host : hosts) {\n                    _capacityMgr.updateCapacityForHost(host);\n                }\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing cpu/ram capacity update\");\n                s_logger.debug(\"Executing storage capacity update\");\n            }\n            \r\n            List<StoragePoolVO> storagePools = _storagePoolDao.listAll();\n            for (StoragePoolVO pool : storagePools) {\n                long disk = _capacityMgr.getAllocatedPoolCapacity(pool, null);\n                if (pool.isShared()) {\n                    _storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_STORAGE_ALLOCATED, disk);\n                } else {\n                    _storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_LOCAL_STORAGE, disk);\n                }\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing storage capacity update\");\n                s_logger.debug(\"Executing capacity updates for public ip and Vlans\");\n            }\n\n            List<DataCenterVO> datacenters = _dcDao.listAll();\n            for (DataCenterVO datacenter : datacenters) {\n                long dcId = datacenter.getId();\n\n                \r\n                \r\n                \r\n                \r\n                \r\n\n                \r\n                if (datacenter.getNetworkType() == NetworkType.Advanced) {\n                    createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_VIRTUAL_NETWORK_PUBLIC_IP, datacenter.getAllocationState());\n                }\n\n                \r\n                createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_DIRECT_ATTACHED_PUBLIC_IP, datacenter.getAllocationState());\n\n                if (datacenter.getNetworkType() == NetworkType.Advanced) {\n                    \r\n                    createOrUpdateVlanCapacity(dcId, datacenter.getAllocationState());\n                }\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done capacity updates for public ip and Vlans\");\n                s_logger.debug(\"Executing capacity updates for private ip\");\n            }\n\n            \r\n            List<HostPodVO> pods = _podDao.listAll();\n            for (HostPodVO pod : pods) {\n                long podId = pod.getId();\n                long dcId = pod.getDataCenterId();\n\n                createOrUpdateIpCapacity(dcId, podId, Capacity.CAPACITY_TYPE_PRIVATE_IP, _configMgr.findPodAllocationState(pod));\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing capacity updates for private ip\");\n                s_logger.debug(\"Done recalculating system capacity\");\n            }\n\n        } catch (Throwable t) {\n            s_logger.error(\"Caught exception in recalculating capacity\", t);\n        }\n    }\n","date":"2018-01-20 05:49:27","endLine":350,"groupId":"23680","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"recalculateCapacity","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/a5/8a4f8b0f91450e931ce96c942160b57ca0b1fa.src","preCode":"    public void recalculateCapacity() {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        try {\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"recalculating system capacity\");\n                s_logger.debug(\"Executing cpu/ram capacity update\");\n            }\n\n            \r\n            \r\n            List<HostVO> hosts = _resourceMgr.listAllNotInMaintenanceHostsInOneZone(Host.Type.Routing, null);\n            if (hosts != null) {\n                for (HostVO host : hosts) {\n                    _capacityMgr.updateCapacityForHost(host);\n                }\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing cpu/ram capacity update\");\n                s_logger.debug(\"Executing storage capacity update\");\n            }\n            \r\n            List<StoragePoolVO> storagePools = _storagePoolDao.listAll();\n            for (StoragePoolVO pool : storagePools) {\n                long disk = _capacityMgr.getAllocatedPoolCapacity(pool, null);\n                if (pool.isShared()) {\n                    _storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_STORAGE_ALLOCATED, disk);\n                } else {\n                    _storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_LOCAL_STORAGE, disk);\n                }\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing storage capacity update\");\n                s_logger.debug(\"Executing capacity updates for public ip and Vlans\");\n            }\n\n            List<DataCenterVO> datacenters = _dcDao.listAll();\n            for (DataCenterVO datacenter : datacenters) {\n                long dcId = datacenter.getId();\n\n                \r\n                \r\n                \r\n                \r\n                \r\n\n                \r\n                if (datacenter.getNetworkType() == NetworkType.Advanced) {\n                    createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_VIRTUAL_NETWORK_PUBLIC_IP, datacenter.getAllocationState());\n                }\n\n                \r\n                createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_DIRECT_ATTACHED_PUBLIC_IP, datacenter.getAllocationState());\n\n                if (datacenter.getNetworkType() == NetworkType.Advanced) {\n                    \r\n                    createOrUpdateVlanCapacity(dcId, datacenter.getAllocationState());\n                }\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done capacity updates for public ip and Vlans\");\n                s_logger.debug(\"Executing capacity updates for private ip\");\n            }\n\n            \r\n            List<HostPodVO> pods = _podDao.listAll();\n            for (HostPodVO pod : pods) {\n                long podId = pod.getId();\n                long dcId = pod.getDataCenterId();\n\n                createOrUpdateIpCapacity(dcId, podId, Capacity.CAPACITY_TYPE_PRIVATE_IP, _configMgr.findPodAllocationState(pod));\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing capacity updates for private ip\");\n                s_logger.debug(\"Done recalculating system capacity\");\n            }\n\n        } catch (Throwable t) {\n            s_logger.error(\"Caught exception in recalculating capacity\", t);\n        }\n    }\n","realPath":"server/src/main/java/com/cloud/alert/AlertManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":261,"status":"N"},{"authorDate":"2019-06-27 11:44:47","commitOrder":4,"curCode":"    public void updateCapacityForHost(final Host host) {\n        \r\n        List<ServiceOfferingVO> offerings = _offeringsDao.listAllIncludingRemoved();\n        Map<Long, ServiceOfferingVO> offeringsMap = new HashMap<Long, ServiceOfferingVO>();\n        for (ServiceOfferingVO offering : offerings) {\n            offeringsMap.put(offering.getId(), offering);\n        }\n\n        long usedCpuCore = 0;\n        long reservedCpuCore = 0;\n        long usedCpu = 0;\n        long usedMemory = 0;\n        long reservedMemory = 0;\n        long reservedCpu = 0;\n        final CapacityState capacityState = (host.getResourceState() == ResourceState.Enabled) ? CapacityState.Enabled : CapacityState.Disabled;\n\n        List<VMInstanceVO> vms = _vmDao.listUpByHostId(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vms.size() + \" VMs on host \" + host.getId());\n        }\n\n        ClusterVO cluster = _clusterDao.findById(host.getClusterId());\n        ClusterDetailsVO clusterDetailCpu = _clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n        ClusterDetailsVO clusterDetailRam = _clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n        Float clusterCpuOvercommitRatio = Float.parseFloat(clusterDetailCpu.getValue());\n        Float clusterRamOvercommitRatio = Float.parseFloat(clusterDetailRam.getValue());\n        for (VMInstanceVO vm : vms) {\n            Float cpuOvercommitRatio = 1.0f;\n            Float ramOvercommitRatio = 1.0f;\n            Map<String, String> vmDetails = _userVmDetailsDao.listDetailsKeyPairs(vm.getId());\n            String vmDetailCpu = vmDetails.get(\"cpuOvercommitRatio\");\n            String vmDetailRam = vmDetails.get(\"memoryOvercommitRatio\");\n            if (vmDetailCpu != null) {\n                \r\n                cpuOvercommitRatio = Float.parseFloat(vmDetailCpu);\n                ramOvercommitRatio = Float.parseFloat(vmDetailRam);\n            }\n            ServiceOffering so = offeringsMap.get(vm.getServiceOfferingId());\n            if (so.isDynamic()) {\n                usedMemory +=\n                    ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.memory.name())) * 1024L * 1024L) / ramOvercommitRatio) *\n                        clusterRamOvercommitRatio;\n                if(vmDetails.containsKey(UsageEventVO.DynamicParameters.cpuSpeed.name())) {\n                    usedCpu +=\n                            ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuSpeed.name()))) / cpuOvercommitRatio) *\n                                    clusterCpuOvercommitRatio;\n                } else {\n                    usedCpu +=\n                            ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * so.getSpeed()) / cpuOvercommitRatio) *\n                                    clusterCpuOvercommitRatio;\n                }\n                usedCpuCore += Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name()));\n            } else {\n                usedMemory += ((so.getRamSize() * 1024L * 1024L) / ramOvercommitRatio) * clusterRamOvercommitRatio;\n                usedCpu += ((so.getCpu() * so.getSpeed()) / cpuOvercommitRatio) * clusterCpuOvercommitRatio;\n                usedCpuCore += so.getCpu();\n            }\n        }\n\n        List<VMInstanceVO> vmsByLastHostId = _vmDao.listByLastHostId(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vmsByLastHostId.size() + \" VM, not running on host \" + host.getId());\n        }\n        for (VMInstanceVO vm : vmsByLastHostId) {\n            Float cpuOvercommitRatio = 1.0f;\n            Float ramOvercommitRatio = 1.0f;\n            long secondsSinceLastUpdate = (DateUtil.currentGMTTime().getTime() - vm.getUpdateTime().getTime()) / 1000;\n            if (secondsSinceLastUpdate < _vmCapacityReleaseInterval) {\n                UserVmDetailVO vmDetailCpu = _userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                UserVmDetailVO vmDetailRam = _userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                if (vmDetailCpu != null) {\n                    \r\n                    cpuOvercommitRatio = Float.parseFloat(vmDetailCpu.getValue());\n                    ramOvercommitRatio = Float.parseFloat(vmDetailRam.getValue());\n                }\n                ServiceOffering so = offeringsMap.get(vm.getServiceOfferingId());\n                Map<String, String> vmDetails = _userVmDetailsDao.listDetailsKeyPairs(vm.getId());\n                if (so.isDynamic()) {\n                    reservedMemory +=\n                        ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.memory.name())) * 1024L * 1024L) / ramOvercommitRatio) *\n                            clusterRamOvercommitRatio;\n                    if(vmDetails.containsKey(UsageEventVO.DynamicParameters.cpuSpeed.name())) {\n                        reservedCpu +=\n                                ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuSpeed.name()))) / cpuOvercommitRatio) *\n                                        clusterCpuOvercommitRatio;\n                    } else {\n                        reservedCpu +=\n                                ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * so.getSpeed()) / cpuOvercommitRatio) *\n                                        clusterCpuOvercommitRatio;\n                    }\n                    reservedCpuCore += Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name()));\n                } else {\n                    reservedMemory += ((so.getRamSize() * 1024L * 1024L) / ramOvercommitRatio) * clusterRamOvercommitRatio;\n                    reservedCpu += (so.getCpu() * so.getSpeed() / cpuOvercommitRatio) * clusterCpuOvercommitRatio;\n                    reservedCpuCore += so.getCpu();\n                }\n            } else {\n                \r\n                \r\n                UserVmDetailVO messageSentFlag = _userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.MESSAGE_RESERVED_CAPACITY_FREED_FLAG);\n                if (messageSentFlag == null || !Boolean.valueOf(messageSentFlag.getValue())) {\n                    _messageBus.publish(_name, \"VM_ReservedCapacity_Free\", PublishScope.LOCAL, vm);\n\n                    if (vm.getType() == VirtualMachine.Type.User) {\n                        UserVmVO userVM = _userVMDao.findById(vm.getId());\n                        _userVMDao.loadDetails(userVM);\n                        userVM.setDetail(VmDetailConstants.MESSAGE_RESERVED_CAPACITY_FREED_FLAG, \"true\");\n                        _userVMDao.saveDetails(userVM);\n                    }\n                }\n            }\n        }\n\n        CapacityVO cpuCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_CPU);\n        CapacityVO memCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_MEMORY);\n        CapacityVO cpuCoreCap = _capacityDao.findByHostIdType(host.getId(), CapacityVO.CAPACITY_TYPE_CPU_CORE);\n\n        if (cpuCoreCap != null) {\n            long hostTotalCpuCore = host.getCpus().longValue();\n\n            if (cpuCoreCap.getTotalCapacity() != hostTotalCpuCore) {\n                s_logger.debug(\"Calibrate total cpu for host: \" + host.getId() + \" old total CPU:\"\n                        + cpuCoreCap.getTotalCapacity() + \" new total CPU:\" + hostTotalCpuCore);\n                cpuCoreCap.setTotalCapacity(hostTotalCpuCore);\n\n            }\n\n            if (cpuCoreCap.getUsedCapacity() == usedCpuCore && cpuCoreCap.getReservedCapacity() == reservedCpuCore) {\n                s_logger.debug(\"No need to calibrate cpu capacity, host:\" + host.getId() + \" usedCpuCore: \" + cpuCoreCap.getUsedCapacity()\n                        + \" reservedCpuCore: \" + cpuCoreCap.getReservedCapacity());\n            } else {\n                if (cpuCoreCap.getReservedCapacity() != reservedCpuCore) {\n                    s_logger.debug(\"Calibrate reserved cpu core for host: \" + host.getId() + \" old reservedCpuCore:\"\n                            + cpuCoreCap.getReservedCapacity() + \" new reservedCpuCore:\" + reservedCpuCore);\n                    cpuCoreCap.setReservedCapacity(reservedCpuCore);\n                }\n                if (cpuCoreCap.getUsedCapacity() != usedCpuCore) {\n                    s_logger.debug(\"Calibrate used cpu core for host: \" + host.getId() + \" old usedCpuCore:\"\n                            + cpuCoreCap.getUsedCapacity() + \" new usedCpuCore:\" + usedCpuCore);\n                    cpuCoreCap.setUsedCapacity(usedCpuCore);\n                }\n            }\n            try {\n                _capacityDao.update(cpuCoreCap.getId(), cpuCoreCap);\n            } catch (Exception e) {\n                s_logger.error(\"Caught exception while updating cpucore capacity for the host \" +host.getId(), e);\n            }\n        } else {\n            final long usedCpuCoreFinal = usedCpuCore;\n            final long reservedCpuCoreFinal = reservedCpuCore;\n            Transaction.execute(new TransactionCallbackNoReturn() {\n                @Override\n                public void doInTransactionWithoutResult(TransactionStatus status) {\n                    CapacityVO capacity = new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedCpuCoreFinal, host.getCpus().longValue(),\n                            CapacityVO.CAPACITY_TYPE_CPU_CORE);\n                    capacity.setReservedCapacity(reservedCpuCoreFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n                }\n            });\n        }\n\n        if (cpuCap != null && memCap != null) {\n            if (host.getTotalMemory() != null) {\n                memCap.setTotalCapacity(host.getTotalMemory());\n            }\n            long hostTotalCpu = host.getCpus().longValue() * host.getSpeed().longValue();\n\n            if (cpuCap.getTotalCapacity() != hostTotalCpu) {\n                s_logger.debug(\"Calibrate total cpu for host: \" + host.getId() + \" old total CPU:\" + cpuCap.getTotalCapacity() + \" new total CPU:\" + hostTotalCpu);\n                cpuCap.setTotalCapacity(hostTotalCpu);\n\n            }\n            \r\n            if(capacityState != cpuCap.getCapacityState()){\n                s_logger.debug(\"Calibrate cpu capacity state for host: \" + host.getId() + \" old capacity state:\" + cpuCap.getTotalCapacity() + \" new capacity state:\" + hostTotalCpu);\n                cpuCap.setCapacityState(capacityState);\n            }\n            memCap.setCapacityState(capacityState);\n\n            if (cpuCap.getUsedCapacity() == usedCpu && cpuCap.getReservedCapacity() == reservedCpu) {\n                s_logger.debug(\"No need to calibrate cpu capacity, host:\" + host.getId() + \" usedCpu: \" + cpuCap.getUsedCapacity() + \" reservedCpu: \" +\n                    cpuCap.getReservedCapacity());\n            } else {\n                if (cpuCap.getReservedCapacity() != reservedCpu) {\n                    s_logger.debug(\"Calibrate reserved cpu for host: \" + host.getId() + \" old reservedCpu:\" + cpuCap.getReservedCapacity() + \" new reservedCpu:\" +\n                        reservedCpu);\n                    cpuCap.setReservedCapacity(reservedCpu);\n                }\n                if (cpuCap.getUsedCapacity() != usedCpu) {\n                    s_logger.debug(\"Calibrate used cpu for host: \" + host.getId() + \" old usedCpu:\" + cpuCap.getUsedCapacity() + \" new usedCpu:\" + usedCpu);\n                    cpuCap.setUsedCapacity(usedCpu);\n                }\n            }\n\n            if (memCap.getTotalCapacity() != host.getTotalMemory()) {\n                s_logger.debug(\"Calibrate total memory for host: \" + host.getId() + \" old total memory:\" + memCap.getTotalCapacity() + \" new total memory:\" +\n                    host.getTotalMemory());\n                memCap.setTotalCapacity(host.getTotalMemory());\n\n            }\n            \r\n            if(capacityState != memCap.getCapacityState()){\n                s_logger.debug(\"Calibrate memory capacity state for host: \" + host.getId() + \" old capacity state:\" + memCap.getTotalCapacity() + \" new capacity state:\" + hostTotalCpu);\n                memCap.setCapacityState(capacityState);\n            }\n\n            if (memCap.getUsedCapacity() == usedMemory && memCap.getReservedCapacity() == reservedMemory) {\n                s_logger.debug(\"No need to calibrate memory capacity, host:\" + host.getId() + \" usedMem: \" + memCap.getUsedCapacity() + \" reservedMem: \" +\n                    memCap.getReservedCapacity());\n            } else {\n                if (memCap.getReservedCapacity() != reservedMemory) {\n                    s_logger.debug(\"Calibrate reserved memory for host: \" + host.getId() + \" old reservedMem:\" + memCap.getReservedCapacity() + \" new reservedMem:\" +\n                        reservedMemory);\n                    memCap.setReservedCapacity(reservedMemory);\n                }\n                if (memCap.getUsedCapacity() != usedMemory) {\n                    \r\n\r\n\r\n\r\n\n                    s_logger.debug(\"Calibrate used memory for host: \" + host.getId() + \" old usedMem: \" + memCap.getUsedCapacity() + \" new usedMem: \" + usedMemory);\n                    memCap.setUsedCapacity(usedMemory);\n                }\n            }\n\n            try {\n                _capacityDao.update(cpuCap.getId(), cpuCap);\n                _capacityDao.update(memCap.getId(), memCap);\n            } catch (Exception e) {\n                s_logger.error(\"Caught exception while updating cpu/memory capacity for the host \" + host.getId(), e);\n            }\n        } else {\n            final long usedMemoryFinal = usedMemory;\n            final long reservedMemoryFinal = reservedMemory;\n            final long usedCpuFinal = usedCpu;\n            final long reservedCpuFinal = reservedCpu;\n            Transaction.execute(new TransactionCallbackNoReturn() {\n                @Override\n                public void doInTransactionWithoutResult(TransactionStatus status) {\n                    CapacityVO capacity =\n                        new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedMemoryFinal, host.getTotalMemory(),\n                            Capacity.CAPACITY_TYPE_MEMORY);\n                    capacity.setReservedCapacity(reservedMemoryFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n\n                    capacity =\n                        new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedCpuFinal, host.getCpus().longValue() *\n                            host.getSpeed().longValue(), Capacity.CAPACITY_TYPE_CPU);\n                    capacity.setReservedCapacity(reservedCpuFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n                }\n            });\n\n        }\n\n    }\n","date":"2019-06-27 11:44:47","endLine":831,"groupId":"10980","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"updateCapacityForHost","params":"(finalHosthost)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/a7/fee9603a07edad5f9092242eefb540a7bb23ba.src","preCode":"    public void updateCapacityForHost(final Host host) {\n        \r\n        List<ServiceOfferingVO> offerings = _offeringsDao.listAllIncludingRemoved();\n        Map<Long, ServiceOfferingVO> offeringsMap = new HashMap<Long, ServiceOfferingVO>();\n        for (ServiceOfferingVO offering : offerings) {\n            offeringsMap.put(offering.getId(), offering);\n        }\n\n        long usedCpuCore = 0;\n        long reservedCpuCore = 0;\n        long usedCpu = 0;\n        long usedMemory = 0;\n        long reservedMemory = 0;\n        long reservedCpu = 0;\n        final CapacityState capacityState = (host.getResourceState() == ResourceState.Enabled) ? CapacityState.Enabled : CapacityState.Disabled;\n\n        List<VMInstanceVO> vms = _vmDao.listUpByHostId(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vms.size() + \" VMs on host \" + host.getId());\n        }\n\n        ClusterVO cluster = _clusterDao.findById(host.getClusterId());\n        ClusterDetailsVO clusterDetailCpu = _clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n        ClusterDetailsVO clusterDetailRam = _clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n        Float clusterCpuOvercommitRatio = Float.parseFloat(clusterDetailCpu.getValue());\n        Float clusterRamOvercommitRatio = Float.parseFloat(clusterDetailRam.getValue());\n        for (VMInstanceVO vm : vms) {\n            Float cpuOvercommitRatio = 1.0f;\n            Float ramOvercommitRatio = 1.0f;\n            Map<String, String> vmDetails = _userVmDetailsDao.listDetailsKeyPairs(vm.getId());\n            String vmDetailCpu = vmDetails.get(\"cpuOvercommitRatio\");\n            String vmDetailRam = vmDetails.get(\"memoryOvercommitRatio\");\n            if (vmDetailCpu != null) {\n                \r\n                cpuOvercommitRatio = Float.parseFloat(vmDetailCpu);\n                ramOvercommitRatio = Float.parseFloat(vmDetailRam);\n            }\n            ServiceOffering so = offeringsMap.get(vm.getServiceOfferingId());\n            if (so.isDynamic()) {\n                usedMemory +=\n                    ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.memory.name())) * 1024L * 1024L) / ramOvercommitRatio) *\n                        clusterRamOvercommitRatio;\n                if(vmDetails.containsKey(UsageEventVO.DynamicParameters.cpuSpeed.name())) {\n                    usedCpu +=\n                            ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuSpeed.name()))) / cpuOvercommitRatio) *\n                                    clusterCpuOvercommitRatio;\n                } else {\n                    usedCpu +=\n                            ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * so.getSpeed()) / cpuOvercommitRatio) *\n                                    clusterCpuOvercommitRatio;\n                }\n                usedCpuCore += Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name()));\n            } else {\n                usedMemory += ((so.getRamSize() * 1024L * 1024L) / ramOvercommitRatio) * clusterRamOvercommitRatio;\n                usedCpu += ((so.getCpu() * so.getSpeed()) / cpuOvercommitRatio) * clusterCpuOvercommitRatio;\n                usedCpuCore += so.getCpu();\n            }\n        }\n\n        List<VMInstanceVO> vmsByLastHostId = _vmDao.listByLastHostId(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vmsByLastHostId.size() + \" VM, not running on host \" + host.getId());\n        }\n        for (VMInstanceVO vm : vmsByLastHostId) {\n            Float cpuOvercommitRatio = 1.0f;\n            Float ramOvercommitRatio = 1.0f;\n            long secondsSinceLastUpdate = (DateUtil.currentGMTTime().getTime() - vm.getUpdateTime().getTime()) / 1000;\n            if (secondsSinceLastUpdate < _vmCapacityReleaseInterval) {\n                UserVmDetailVO vmDetailCpu = _userVmDetailsDao.findDetail(vm.getId(), \"cpuOvercommitRatio\");\n                UserVmDetailVO vmDetailRam = _userVmDetailsDao.findDetail(vm.getId(), \"memoryOvercommitRatio\");\n                if (vmDetailCpu != null) {\n                    \r\n                    cpuOvercommitRatio = Float.parseFloat(vmDetailCpu.getValue());\n                    ramOvercommitRatio = Float.parseFloat(vmDetailRam.getValue());\n                }\n                ServiceOffering so = offeringsMap.get(vm.getServiceOfferingId());\n                Map<String, String> vmDetails = _userVmDetailsDao.listDetailsKeyPairs(vm.getId());\n                if (so.isDynamic()) {\n                    reservedMemory +=\n                        ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.memory.name())) * 1024L * 1024L) / ramOvercommitRatio) *\n                            clusterRamOvercommitRatio;\n                    if(vmDetails.containsKey(UsageEventVO.DynamicParameters.cpuSpeed.name())) {\n                        reservedCpu +=\n                                ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuSpeed.name()))) / cpuOvercommitRatio) *\n                                        clusterCpuOvercommitRatio;\n                    } else {\n                        reservedCpu +=\n                                ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * so.getSpeed()) / cpuOvercommitRatio) *\n                                        clusterCpuOvercommitRatio;\n                    }\n                    reservedCpuCore += Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name()));\n                } else {\n                    reservedMemory += ((so.getRamSize() * 1024L * 1024L) / ramOvercommitRatio) * clusterRamOvercommitRatio;\n                    reservedCpu += (so.getCpu() * so.getSpeed() / cpuOvercommitRatio) * clusterCpuOvercommitRatio;\n                    reservedCpuCore += so.getCpu();\n                }\n            } else {\n                \r\n                \r\n                UserVmDetailVO messageSentFlag = _userVmDetailsDao.findDetail(vm.getId(), MESSAGE_RESERVED_CAPACITY_FREED_FLAG);\n                if (messageSentFlag == null || !Boolean.valueOf(messageSentFlag.getValue())) {\n                    _messageBus.publish(_name, \"VM_ReservedCapacity_Free\", PublishScope.LOCAL, vm);\n\n                    if (vm.getType() == VirtualMachine.Type.User) {\n                        UserVmVO userVM = _userVMDao.findById(vm.getId());\n                        _userVMDao.loadDetails(userVM);\n                        userVM.setDetail(MESSAGE_RESERVED_CAPACITY_FREED_FLAG, \"true\");\n                        _userVMDao.saveDetails(userVM);\n                    }\n                }\n            }\n        }\n\n        CapacityVO cpuCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_CPU);\n        CapacityVO memCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_MEMORY);\n        CapacityVO cpuCoreCap = _capacityDao.findByHostIdType(host.getId(), CapacityVO.CAPACITY_TYPE_CPU_CORE);\n\n        if (cpuCoreCap != null) {\n            long hostTotalCpuCore = host.getCpus().longValue();\n\n            if (cpuCoreCap.getTotalCapacity() != hostTotalCpuCore) {\n                s_logger.debug(\"Calibrate total cpu for host: \" + host.getId() + \" old total CPU:\"\n                        + cpuCoreCap.getTotalCapacity() + \" new total CPU:\" + hostTotalCpuCore);\n                cpuCoreCap.setTotalCapacity(hostTotalCpuCore);\n\n            }\n\n            if (cpuCoreCap.getUsedCapacity() == usedCpuCore && cpuCoreCap.getReservedCapacity() == reservedCpuCore) {\n                s_logger.debug(\"No need to calibrate cpu capacity, host:\" + host.getId() + \" usedCpuCore: \" + cpuCoreCap.getUsedCapacity()\n                        + \" reservedCpuCore: \" + cpuCoreCap.getReservedCapacity());\n            } else {\n                if (cpuCoreCap.getReservedCapacity() != reservedCpuCore) {\n                    s_logger.debug(\"Calibrate reserved cpu core for host: \" + host.getId() + \" old reservedCpuCore:\"\n                            + cpuCoreCap.getReservedCapacity() + \" new reservedCpuCore:\" + reservedCpuCore);\n                    cpuCoreCap.setReservedCapacity(reservedCpuCore);\n                }\n                if (cpuCoreCap.getUsedCapacity() != usedCpuCore) {\n                    s_logger.debug(\"Calibrate used cpu core for host: \" + host.getId() + \" old usedCpuCore:\"\n                            + cpuCoreCap.getUsedCapacity() + \" new usedCpuCore:\" + usedCpuCore);\n                    cpuCoreCap.setUsedCapacity(usedCpuCore);\n                }\n            }\n            try {\n                _capacityDao.update(cpuCoreCap.getId(), cpuCoreCap);\n            } catch (Exception e) {\n                s_logger.error(\"Caught exception while updating cpucore capacity for the host \" +host.getId(), e);\n            }\n        } else {\n            final long usedCpuCoreFinal = usedCpuCore;\n            final long reservedCpuCoreFinal = reservedCpuCore;\n            Transaction.execute(new TransactionCallbackNoReturn() {\n                @Override\n                public void doInTransactionWithoutResult(TransactionStatus status) {\n                    CapacityVO capacity = new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedCpuCoreFinal, host.getCpus().longValue(),\n                            CapacityVO.CAPACITY_TYPE_CPU_CORE);\n                    capacity.setReservedCapacity(reservedCpuCoreFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n                }\n            });\n        }\n\n        if (cpuCap != null && memCap != null) {\n            if (host.getTotalMemory() != null) {\n                memCap.setTotalCapacity(host.getTotalMemory());\n            }\n            long hostTotalCpu = host.getCpus().longValue() * host.getSpeed().longValue();\n\n            if (cpuCap.getTotalCapacity() != hostTotalCpu) {\n                s_logger.debug(\"Calibrate total cpu for host: \" + host.getId() + \" old total CPU:\" + cpuCap.getTotalCapacity() + \" new total CPU:\" + hostTotalCpu);\n                cpuCap.setTotalCapacity(hostTotalCpu);\n\n            }\n            \r\n            if(capacityState != cpuCap.getCapacityState()){\n                s_logger.debug(\"Calibrate cpu capacity state for host: \" + host.getId() + \" old capacity state:\" + cpuCap.getTotalCapacity() + \" new capacity state:\" + hostTotalCpu);\n                cpuCap.setCapacityState(capacityState);\n            }\n            memCap.setCapacityState(capacityState);\n\n            if (cpuCap.getUsedCapacity() == usedCpu && cpuCap.getReservedCapacity() == reservedCpu) {\n                s_logger.debug(\"No need to calibrate cpu capacity, host:\" + host.getId() + \" usedCpu: \" + cpuCap.getUsedCapacity() + \" reservedCpu: \" +\n                    cpuCap.getReservedCapacity());\n            } else {\n                if (cpuCap.getReservedCapacity() != reservedCpu) {\n                    s_logger.debug(\"Calibrate reserved cpu for host: \" + host.getId() + \" old reservedCpu:\" + cpuCap.getReservedCapacity() + \" new reservedCpu:\" +\n                        reservedCpu);\n                    cpuCap.setReservedCapacity(reservedCpu);\n                }\n                if (cpuCap.getUsedCapacity() != usedCpu) {\n                    s_logger.debug(\"Calibrate used cpu for host: \" + host.getId() + \" old usedCpu:\" + cpuCap.getUsedCapacity() + \" new usedCpu:\" + usedCpu);\n                    cpuCap.setUsedCapacity(usedCpu);\n                }\n            }\n\n            if (memCap.getTotalCapacity() != host.getTotalMemory()) {\n                s_logger.debug(\"Calibrate total memory for host: \" + host.getId() + \" old total memory:\" + memCap.getTotalCapacity() + \" new total memory:\" +\n                    host.getTotalMemory());\n                memCap.setTotalCapacity(host.getTotalMemory());\n\n            }\n            \r\n            if(capacityState != memCap.getCapacityState()){\n                s_logger.debug(\"Calibrate memory capacity state for host: \" + host.getId() + \" old capacity state:\" + memCap.getTotalCapacity() + \" new capacity state:\" + hostTotalCpu);\n                memCap.setCapacityState(capacityState);\n            }\n\n            if (memCap.getUsedCapacity() == usedMemory && memCap.getReservedCapacity() == reservedMemory) {\n                s_logger.debug(\"No need to calibrate memory capacity, host:\" + host.getId() + \" usedMem: \" + memCap.getUsedCapacity() + \" reservedMem: \" +\n                    memCap.getReservedCapacity());\n            } else {\n                if (memCap.getReservedCapacity() != reservedMemory) {\n                    s_logger.debug(\"Calibrate reserved memory for host: \" + host.getId() + \" old reservedMem:\" + memCap.getReservedCapacity() + \" new reservedMem:\" +\n                        reservedMemory);\n                    memCap.setReservedCapacity(reservedMemory);\n                }\n                if (memCap.getUsedCapacity() != usedMemory) {\n                    \r\n\r\n\r\n\r\n\n                    s_logger.debug(\"Calibrate used memory for host: \" + host.getId() + \" old usedMem: \" + memCap.getUsedCapacity() + \" new usedMem: \" + usedMemory);\n                    memCap.setUsedCapacity(usedMemory);\n                }\n            }\n\n            try {\n                _capacityDao.update(cpuCap.getId(), cpuCap);\n                _capacityDao.update(memCap.getId(), memCap);\n            } catch (Exception e) {\n                s_logger.error(\"Caught exception while updating cpu/memory capacity for the host \" + host.getId(), e);\n            }\n        } else {\n            final long usedMemoryFinal = usedMemory;\n            final long reservedMemoryFinal = reservedMemory;\n            final long usedCpuFinal = usedCpu;\n            final long reservedCpuFinal = reservedCpu;\n            Transaction.execute(new TransactionCallbackNoReturn() {\n                @Override\n                public void doInTransactionWithoutResult(TransactionStatus status) {\n                    CapacityVO capacity =\n                        new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedMemoryFinal, host.getTotalMemory(),\n                            Capacity.CAPACITY_TYPE_MEMORY);\n                    capacity.setReservedCapacity(reservedMemoryFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n\n                    capacity =\n                        new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedCpuFinal, host.getCpus().longValue() *\n                            host.getSpeed().longValue(), Capacity.CAPACITY_TYPE_CPU);\n                    capacity.setReservedCapacity(reservedCpuFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n                }\n            });\n\n        }\n\n    }\n","realPath":"server/src/main/java/com/cloud/capacity/CapacityManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":572,"status":"M"}],"commitId":"9f4f2c5348af93eeb790fbf4908cdde4f0b7806a","commitMessage":"@@@api: instance and template details are free text (#3240)\n\nProblem: Users don't know what keys/values to enter for template and VM details.\nRoot Cause: The feature does not exist that can list possible details and options.\nSolution: Based on the possible VM and template details handled by the\ncodebase.  those details were refactored and a list API is introduced\nthat can return users those details along with possible values. When\nusers add details now.  they will be presented with a list of key details\nand their possible options if any.\n\nSigned-off-by: Rohit Yadav <rohit.yadav@shapeblue.com>","date":"2019-06-27 11:44:47","modifiedFileCount":"16","status":"M","submitter":"Rohit Yadav"},{"authorTime":"2020-01-28 13:56:40","codes":[{"authorDate":"2018-01-20 05:49:27","commitOrder":5,"curCode":"    public void recalculateCapacity() {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        try {\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"recalculating system capacity\");\n                s_logger.debug(\"Executing cpu/ram capacity update\");\n            }\n\n            \r\n            \r\n            List<HostVO> hosts = _resourceMgr.listAllNotInMaintenanceHostsInOneZone(Host.Type.Routing, null);\n            if (hosts != null) {\n                for (HostVO host : hosts) {\n                    _capacityMgr.updateCapacityForHost(host);\n                }\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing cpu/ram capacity update\");\n                s_logger.debug(\"Executing storage capacity update\");\n            }\n            \r\n            List<StoragePoolVO> storagePools = _storagePoolDao.listAll();\n            for (StoragePoolVO pool : storagePools) {\n                long disk = _capacityMgr.getAllocatedPoolCapacity(pool, null);\n                if (pool.isShared()) {\n                    _storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_STORAGE_ALLOCATED, disk);\n                } else {\n                    _storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_LOCAL_STORAGE, disk);\n                }\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing storage capacity update\");\n                s_logger.debug(\"Executing capacity updates for public ip and Vlans\");\n            }\n\n            List<DataCenterVO> datacenters = _dcDao.listAll();\n            for (DataCenterVO datacenter : datacenters) {\n                long dcId = datacenter.getId();\n\n                \r\n                \r\n                \r\n                \r\n                \r\n\n                \r\n                if (datacenter.getNetworkType() == NetworkType.Advanced) {\n                    createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_VIRTUAL_NETWORK_PUBLIC_IP, datacenter.getAllocationState());\n                }\n\n                \r\n                createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_DIRECT_ATTACHED_PUBLIC_IP, datacenter.getAllocationState());\n\n                if (datacenter.getNetworkType() == NetworkType.Advanced) {\n                    \r\n                    createOrUpdateVlanCapacity(dcId, datacenter.getAllocationState());\n                }\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done capacity updates for public ip and Vlans\");\n                s_logger.debug(\"Executing capacity updates for private ip\");\n            }\n\n            \r\n            List<HostPodVO> pods = _podDao.listAll();\n            for (HostPodVO pod : pods) {\n                long podId = pod.getId();\n                long dcId = pod.getDataCenterId();\n\n                createOrUpdateIpCapacity(dcId, podId, Capacity.CAPACITY_TYPE_PRIVATE_IP, _configMgr.findPodAllocationState(pod));\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing capacity updates for private ip\");\n                s_logger.debug(\"Done recalculating system capacity\");\n            }\n\n        } catch (Throwable t) {\n            s_logger.error(\"Caught exception in recalculating capacity\", t);\n        }\n    }\n","date":"2018-01-20 05:49:27","endLine":350,"groupId":"23680","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"recalculateCapacity","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/a5/8a4f8b0f91450e931ce96c942160b57ca0b1fa.src","preCode":"    public void recalculateCapacity() {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        try {\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"recalculating system capacity\");\n                s_logger.debug(\"Executing cpu/ram capacity update\");\n            }\n\n            \r\n            \r\n            List<HostVO> hosts = _resourceMgr.listAllNotInMaintenanceHostsInOneZone(Host.Type.Routing, null);\n            if (hosts != null) {\n                for (HostVO host : hosts) {\n                    _capacityMgr.updateCapacityForHost(host);\n                }\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing cpu/ram capacity update\");\n                s_logger.debug(\"Executing storage capacity update\");\n            }\n            \r\n            List<StoragePoolVO> storagePools = _storagePoolDao.listAll();\n            for (StoragePoolVO pool : storagePools) {\n                long disk = _capacityMgr.getAllocatedPoolCapacity(pool, null);\n                if (pool.isShared()) {\n                    _storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_STORAGE_ALLOCATED, disk);\n                } else {\n                    _storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_LOCAL_STORAGE, disk);\n                }\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing storage capacity update\");\n                s_logger.debug(\"Executing capacity updates for public ip and Vlans\");\n            }\n\n            List<DataCenterVO> datacenters = _dcDao.listAll();\n            for (DataCenterVO datacenter : datacenters) {\n                long dcId = datacenter.getId();\n\n                \r\n                \r\n                \r\n                \r\n                \r\n\n                \r\n                if (datacenter.getNetworkType() == NetworkType.Advanced) {\n                    createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_VIRTUAL_NETWORK_PUBLIC_IP, datacenter.getAllocationState());\n                }\n\n                \r\n                createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_DIRECT_ATTACHED_PUBLIC_IP, datacenter.getAllocationState());\n\n                if (datacenter.getNetworkType() == NetworkType.Advanced) {\n                    \r\n                    createOrUpdateVlanCapacity(dcId, datacenter.getAllocationState());\n                }\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done capacity updates for public ip and Vlans\");\n                s_logger.debug(\"Executing capacity updates for private ip\");\n            }\n\n            \r\n            List<HostPodVO> pods = _podDao.listAll();\n            for (HostPodVO pod : pods) {\n                long podId = pod.getId();\n                long dcId = pod.getDataCenterId();\n\n                createOrUpdateIpCapacity(dcId, podId, Capacity.CAPACITY_TYPE_PRIVATE_IP, _configMgr.findPodAllocationState(pod));\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing capacity updates for private ip\");\n                s_logger.debug(\"Done recalculating system capacity\");\n            }\n\n        } catch (Throwable t) {\n            s_logger.error(\"Caught exception in recalculating capacity\", t);\n        }\n    }\n","realPath":"server/src/main/java/com/cloud/alert/AlertManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":261,"status":"N"},{"authorDate":"2020-01-28 13:56:40","commitOrder":5,"curCode":"    public void updateCapacityForHost(final Host host) {\n        \r\n        List<ServiceOfferingVO> offerings = _offeringsDao.listAllIncludingRemoved();\n        Map<Long, ServiceOfferingVO> offeringsMap = new HashMap<Long, ServiceOfferingVO>();\n        for (ServiceOfferingVO offering : offerings) {\n            offeringsMap.put(offering.getId(), offering);\n        }\n\n        long usedCpuCore = 0;\n        long reservedCpuCore = 0;\n        long usedCpu = 0;\n        long usedMemory = 0;\n        long reservedMemory = 0;\n        long reservedCpu = 0;\n        final CapacityState capacityState = (host.getResourceState() == ResourceState.Enabled) ? CapacityState.Enabled : CapacityState.Disabled;\n\n        List<VMInstanceVO> vms = _vmDao.listUpByHostId(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vms.size() + \" VMs on host \" + host.getId());\n        }\n\n        final List<VMInstanceVO> vosMigrating = _vmDao.listVmsMigratingFromHost(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vosMigrating.size() + \" VMs are Migrating from host \" + host.getId());\n        }\n        vms.addAll(vosMigrating);\n\n        ClusterVO cluster = _clusterDao.findById(host.getClusterId());\n        ClusterDetailsVO clusterDetailCpu = _clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n        ClusterDetailsVO clusterDetailRam = _clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n        Float clusterCpuOvercommitRatio = Float.parseFloat(clusterDetailCpu.getValue());\n        Float clusterRamOvercommitRatio = Float.parseFloat(clusterDetailRam.getValue());\n        for (VMInstanceVO vm : vms) {\n            Float cpuOvercommitRatio = 1.0f;\n            Float ramOvercommitRatio = 1.0f;\n            Map<String, String> vmDetails = _userVmDetailsDao.listDetailsKeyPairs(vm.getId());\n            String vmDetailCpu = vmDetails.get(\"cpuOvercommitRatio\");\n            String vmDetailRam = vmDetails.get(\"memoryOvercommitRatio\");\n            if (vmDetailCpu != null) {\n                \r\n                cpuOvercommitRatio = Float.parseFloat(vmDetailCpu);\n                ramOvercommitRatio = Float.parseFloat(vmDetailRam);\n            }\n            ServiceOffering so = offeringsMap.get(vm.getServiceOfferingId());\n            if (so.isDynamic()) {\n                usedMemory +=\n                    ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.memory.name())) * 1024L * 1024L) / ramOvercommitRatio) *\n                        clusterRamOvercommitRatio;\n                if(vmDetails.containsKey(UsageEventVO.DynamicParameters.cpuSpeed.name())) {\n                    usedCpu +=\n                            ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuSpeed.name()))) / cpuOvercommitRatio) *\n                                    clusterCpuOvercommitRatio;\n                } else {\n                    usedCpu +=\n                            ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * so.getSpeed()) / cpuOvercommitRatio) *\n                                    clusterCpuOvercommitRatio;\n                }\n                usedCpuCore += Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name()));\n            } else {\n                usedMemory += ((so.getRamSize() * 1024L * 1024L) / ramOvercommitRatio) * clusterRamOvercommitRatio;\n                usedCpu += ((so.getCpu() * so.getSpeed()) / cpuOvercommitRatio) * clusterCpuOvercommitRatio;\n                usedCpuCore += so.getCpu();\n            }\n        }\n\n        List<VMInstanceVO> vmsByLastHostId = _vmDao.listByLastHostId(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vmsByLastHostId.size() + \" VM, not running on host \" + host.getId());\n        }\n        for (VMInstanceVO vm : vmsByLastHostId) {\n            Float cpuOvercommitRatio = 1.0f;\n            Float ramOvercommitRatio = 1.0f;\n            long secondsSinceLastUpdate = (DateUtil.currentGMTTime().getTime() - vm.getUpdateTime().getTime()) / 1000;\n            if (secondsSinceLastUpdate < _vmCapacityReleaseInterval) {\n                UserVmDetailVO vmDetailCpu = _userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                UserVmDetailVO vmDetailRam = _userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                if (vmDetailCpu != null) {\n                    \r\n                    cpuOvercommitRatio = Float.parseFloat(vmDetailCpu.getValue());\n                    ramOvercommitRatio = Float.parseFloat(vmDetailRam.getValue());\n                }\n                ServiceOffering so = offeringsMap.get(vm.getServiceOfferingId());\n                Map<String, String> vmDetails = _userVmDetailsDao.listDetailsKeyPairs(vm.getId());\n                if (so.isDynamic()) {\n                    reservedMemory +=\n                        ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.memory.name())) * 1024L * 1024L) / ramOvercommitRatio) *\n                            clusterRamOvercommitRatio;\n                    if(vmDetails.containsKey(UsageEventVO.DynamicParameters.cpuSpeed.name())) {\n                        reservedCpu +=\n                                ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuSpeed.name()))) / cpuOvercommitRatio) *\n                                        clusterCpuOvercommitRatio;\n                    } else {\n                        reservedCpu +=\n                                ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * so.getSpeed()) / cpuOvercommitRatio) *\n                                        clusterCpuOvercommitRatio;\n                    }\n                    reservedCpuCore += Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name()));\n                } else {\n                    reservedMemory += ((so.getRamSize() * 1024L * 1024L) / ramOvercommitRatio) * clusterRamOvercommitRatio;\n                    reservedCpu += (so.getCpu() * so.getSpeed() / cpuOvercommitRatio) * clusterCpuOvercommitRatio;\n                    reservedCpuCore += so.getCpu();\n                }\n            } else {\n                \r\n                \r\n                UserVmDetailVO messageSentFlag = _userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.MESSAGE_RESERVED_CAPACITY_FREED_FLAG);\n                if (messageSentFlag == null || !Boolean.valueOf(messageSentFlag.getValue())) {\n                    _messageBus.publish(_name, \"VM_ReservedCapacity_Free\", PublishScope.LOCAL, vm);\n\n                    if (vm.getType() == VirtualMachine.Type.User) {\n                        UserVmVO userVM = _userVMDao.findById(vm.getId());\n                        _userVMDao.loadDetails(userVM);\n                        userVM.setDetail(VmDetailConstants.MESSAGE_RESERVED_CAPACITY_FREED_FLAG, \"true\");\n                        _userVMDao.saveDetails(userVM);\n                    }\n                }\n            }\n        }\n\n        CapacityVO cpuCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_CPU);\n        CapacityVO memCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_MEMORY);\n        CapacityVO cpuCoreCap = _capacityDao.findByHostIdType(host.getId(), CapacityVO.CAPACITY_TYPE_CPU_CORE);\n\n        if (cpuCoreCap != null) {\n            long hostTotalCpuCore = host.getCpus().longValue();\n\n            if (cpuCoreCap.getTotalCapacity() != hostTotalCpuCore) {\n                s_logger.debug(\"Calibrate total cpu for host: \" + host.getId() + \" old total CPU:\"\n                        + cpuCoreCap.getTotalCapacity() + \" new total CPU:\" + hostTotalCpuCore);\n                cpuCoreCap.setTotalCapacity(hostTotalCpuCore);\n\n            }\n\n            if (cpuCoreCap.getUsedCapacity() == usedCpuCore && cpuCoreCap.getReservedCapacity() == reservedCpuCore) {\n                s_logger.debug(\"No need to calibrate cpu capacity, host:\" + host.getId() + \" usedCpuCore: \" + cpuCoreCap.getUsedCapacity()\n                        + \" reservedCpuCore: \" + cpuCoreCap.getReservedCapacity());\n            } else {\n                if (cpuCoreCap.getReservedCapacity() != reservedCpuCore) {\n                    s_logger.debug(\"Calibrate reserved cpu core for host: \" + host.getId() + \" old reservedCpuCore:\"\n                            + cpuCoreCap.getReservedCapacity() + \" new reservedCpuCore:\" + reservedCpuCore);\n                    cpuCoreCap.setReservedCapacity(reservedCpuCore);\n                }\n                if (cpuCoreCap.getUsedCapacity() != usedCpuCore) {\n                    s_logger.debug(\"Calibrate used cpu core for host: \" + host.getId() + \" old usedCpuCore:\"\n                            + cpuCoreCap.getUsedCapacity() + \" new usedCpuCore:\" + usedCpuCore);\n                    cpuCoreCap.setUsedCapacity(usedCpuCore);\n                }\n            }\n            try {\n                _capacityDao.update(cpuCoreCap.getId(), cpuCoreCap);\n            } catch (Exception e) {\n                s_logger.error(\"Caught exception while updating cpucore capacity for the host \" +host.getId(), e);\n            }\n        } else {\n            final long usedCpuCoreFinal = usedCpuCore;\n            final long reservedCpuCoreFinal = reservedCpuCore;\n            Transaction.execute(new TransactionCallbackNoReturn() {\n                @Override\n                public void doInTransactionWithoutResult(TransactionStatus status) {\n                    CapacityVO capacity = new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedCpuCoreFinal, host.getCpus().longValue(),\n                            CapacityVO.CAPACITY_TYPE_CPU_CORE);\n                    capacity.setReservedCapacity(reservedCpuCoreFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n                }\n            });\n        }\n\n        if (cpuCap != null && memCap != null) {\n            if (host.getTotalMemory() != null) {\n                memCap.setTotalCapacity(host.getTotalMemory());\n            }\n            long hostTotalCpu = host.getCpus().longValue() * host.getSpeed().longValue();\n\n            if (cpuCap.getTotalCapacity() != hostTotalCpu) {\n                s_logger.debug(\"Calibrate total cpu for host: \" + host.getId() + \" old total CPU:\" + cpuCap.getTotalCapacity() + \" new total CPU:\" + hostTotalCpu);\n                cpuCap.setTotalCapacity(hostTotalCpu);\n\n            }\n            \r\n            if(capacityState != cpuCap.getCapacityState()){\n                s_logger.debug(\"Calibrate cpu capacity state for host: \" + host.getId() + \" old capacity state:\" + cpuCap.getTotalCapacity() + \" new capacity state:\" + hostTotalCpu);\n                cpuCap.setCapacityState(capacityState);\n            }\n            memCap.setCapacityState(capacityState);\n\n            if (cpuCap.getUsedCapacity() == usedCpu && cpuCap.getReservedCapacity() == reservedCpu) {\n                s_logger.debug(\"No need to calibrate cpu capacity, host:\" + host.getId() + \" usedCpu: \" + cpuCap.getUsedCapacity() + \" reservedCpu: \" +\n                    cpuCap.getReservedCapacity());\n            } else {\n                if (cpuCap.getReservedCapacity() != reservedCpu) {\n                    s_logger.debug(\"Calibrate reserved cpu for host: \" + host.getId() + \" old reservedCpu:\" + cpuCap.getReservedCapacity() + \" new reservedCpu:\" +\n                        reservedCpu);\n                    cpuCap.setReservedCapacity(reservedCpu);\n                }\n                if (cpuCap.getUsedCapacity() != usedCpu) {\n                    s_logger.debug(\"Calibrate used cpu for host: \" + host.getId() + \" old usedCpu:\" + cpuCap.getUsedCapacity() + \" new usedCpu:\" + usedCpu);\n                    cpuCap.setUsedCapacity(usedCpu);\n                }\n            }\n\n            if (memCap.getTotalCapacity() != host.getTotalMemory()) {\n                s_logger.debug(\"Calibrate total memory for host: \" + host.getId() + \" old total memory:\" + memCap.getTotalCapacity() + \" new total memory:\" +\n                    host.getTotalMemory());\n                memCap.setTotalCapacity(host.getTotalMemory());\n\n            }\n            \r\n            if(capacityState != memCap.getCapacityState()){\n                s_logger.debug(\"Calibrate memory capacity state for host: \" + host.getId() + \" old capacity state:\" + memCap.getTotalCapacity() + \" new capacity state:\" + hostTotalCpu);\n                memCap.setCapacityState(capacityState);\n            }\n\n            if (memCap.getUsedCapacity() == usedMemory && memCap.getReservedCapacity() == reservedMemory) {\n                s_logger.debug(\"No need to calibrate memory capacity, host:\" + host.getId() + \" usedMem: \" + memCap.getUsedCapacity() + \" reservedMem: \" +\n                    memCap.getReservedCapacity());\n            } else {\n                if (memCap.getReservedCapacity() != reservedMemory) {\n                    s_logger.debug(\"Calibrate reserved memory for host: \" + host.getId() + \" old reservedMem:\" + memCap.getReservedCapacity() + \" new reservedMem:\" +\n                        reservedMemory);\n                    memCap.setReservedCapacity(reservedMemory);\n                }\n                if (memCap.getUsedCapacity() != usedMemory) {\n                    \r\n\r\n\r\n\r\n\n                    s_logger.debug(\"Calibrate used memory for host: \" + host.getId() + \" old usedMem: \" + memCap.getUsedCapacity() + \" new usedMem: \" + usedMemory);\n                    memCap.setUsedCapacity(usedMemory);\n                }\n            }\n\n            try {\n                _capacityDao.update(cpuCap.getId(), cpuCap);\n                _capacityDao.update(memCap.getId(), memCap);\n            } catch (Exception e) {\n                s_logger.error(\"Caught exception while updating cpu/memory capacity for the host \" + host.getId(), e);\n            }\n        } else {\n            final long usedMemoryFinal = usedMemory;\n            final long reservedMemoryFinal = reservedMemory;\n            final long usedCpuFinal = usedCpu;\n            final long reservedCpuFinal = reservedCpu;\n            Transaction.execute(new TransactionCallbackNoReturn() {\n                @Override\n                public void doInTransactionWithoutResult(TransactionStatus status) {\n                    CapacityVO capacity =\n                        new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedMemoryFinal, host.getTotalMemory(),\n                            Capacity.CAPACITY_TYPE_MEMORY);\n                    capacity.setReservedCapacity(reservedMemoryFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n\n                    capacity =\n                        new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedCpuFinal, host.getCpus().longValue() *\n                            host.getSpeed().longValue(), Capacity.CAPACITY_TYPE_CPU);\n                    capacity.setReservedCapacity(reservedCpuFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n                }\n            });\n\n        }\n\n    }\n","date":"2020-01-28 13:56:40","endLine":888,"groupId":"10980","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"updateCapacityForHost","params":"(finalHosthost)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/b3/f3a625f6765442c06b368ae3b5d4aaf6e9b8b5.src","preCode":"    public void updateCapacityForHost(final Host host) {\n        \r\n        List<ServiceOfferingVO> offerings = _offeringsDao.listAllIncludingRemoved();\n        Map<Long, ServiceOfferingVO> offeringsMap = new HashMap<Long, ServiceOfferingVO>();\n        for (ServiceOfferingVO offering : offerings) {\n            offeringsMap.put(offering.getId(), offering);\n        }\n\n        long usedCpuCore = 0;\n        long reservedCpuCore = 0;\n        long usedCpu = 0;\n        long usedMemory = 0;\n        long reservedMemory = 0;\n        long reservedCpu = 0;\n        final CapacityState capacityState = (host.getResourceState() == ResourceState.Enabled) ? CapacityState.Enabled : CapacityState.Disabled;\n\n        List<VMInstanceVO> vms = _vmDao.listUpByHostId(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vms.size() + \" VMs on host \" + host.getId());\n        }\n\n        ClusterVO cluster = _clusterDao.findById(host.getClusterId());\n        ClusterDetailsVO clusterDetailCpu = _clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n        ClusterDetailsVO clusterDetailRam = _clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n        Float clusterCpuOvercommitRatio = Float.parseFloat(clusterDetailCpu.getValue());\n        Float clusterRamOvercommitRatio = Float.parseFloat(clusterDetailRam.getValue());\n        for (VMInstanceVO vm : vms) {\n            Float cpuOvercommitRatio = 1.0f;\n            Float ramOvercommitRatio = 1.0f;\n            Map<String, String> vmDetails = _userVmDetailsDao.listDetailsKeyPairs(vm.getId());\n            String vmDetailCpu = vmDetails.get(\"cpuOvercommitRatio\");\n            String vmDetailRam = vmDetails.get(\"memoryOvercommitRatio\");\n            if (vmDetailCpu != null) {\n                \r\n                cpuOvercommitRatio = Float.parseFloat(vmDetailCpu);\n                ramOvercommitRatio = Float.parseFloat(vmDetailRam);\n            }\n            ServiceOffering so = offeringsMap.get(vm.getServiceOfferingId());\n            if (so.isDynamic()) {\n                usedMemory +=\n                    ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.memory.name())) * 1024L * 1024L) / ramOvercommitRatio) *\n                        clusterRamOvercommitRatio;\n                if(vmDetails.containsKey(UsageEventVO.DynamicParameters.cpuSpeed.name())) {\n                    usedCpu +=\n                            ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuSpeed.name()))) / cpuOvercommitRatio) *\n                                    clusterCpuOvercommitRatio;\n                } else {\n                    usedCpu +=\n                            ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * so.getSpeed()) / cpuOvercommitRatio) *\n                                    clusterCpuOvercommitRatio;\n                }\n                usedCpuCore += Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name()));\n            } else {\n                usedMemory += ((so.getRamSize() * 1024L * 1024L) / ramOvercommitRatio) * clusterRamOvercommitRatio;\n                usedCpu += ((so.getCpu() * so.getSpeed()) / cpuOvercommitRatio) * clusterCpuOvercommitRatio;\n                usedCpuCore += so.getCpu();\n            }\n        }\n\n        List<VMInstanceVO> vmsByLastHostId = _vmDao.listByLastHostId(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vmsByLastHostId.size() + \" VM, not running on host \" + host.getId());\n        }\n        for (VMInstanceVO vm : vmsByLastHostId) {\n            Float cpuOvercommitRatio = 1.0f;\n            Float ramOvercommitRatio = 1.0f;\n            long secondsSinceLastUpdate = (DateUtil.currentGMTTime().getTime() - vm.getUpdateTime().getTime()) / 1000;\n            if (secondsSinceLastUpdate < _vmCapacityReleaseInterval) {\n                UserVmDetailVO vmDetailCpu = _userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                UserVmDetailVO vmDetailRam = _userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                if (vmDetailCpu != null) {\n                    \r\n                    cpuOvercommitRatio = Float.parseFloat(vmDetailCpu.getValue());\n                    ramOvercommitRatio = Float.parseFloat(vmDetailRam.getValue());\n                }\n                ServiceOffering so = offeringsMap.get(vm.getServiceOfferingId());\n                Map<String, String> vmDetails = _userVmDetailsDao.listDetailsKeyPairs(vm.getId());\n                if (so.isDynamic()) {\n                    reservedMemory +=\n                        ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.memory.name())) * 1024L * 1024L) / ramOvercommitRatio) *\n                            clusterRamOvercommitRatio;\n                    if(vmDetails.containsKey(UsageEventVO.DynamicParameters.cpuSpeed.name())) {\n                        reservedCpu +=\n                                ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuSpeed.name()))) / cpuOvercommitRatio) *\n                                        clusterCpuOvercommitRatio;\n                    } else {\n                        reservedCpu +=\n                                ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * so.getSpeed()) / cpuOvercommitRatio) *\n                                        clusterCpuOvercommitRatio;\n                    }\n                    reservedCpuCore += Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name()));\n                } else {\n                    reservedMemory += ((so.getRamSize() * 1024L * 1024L) / ramOvercommitRatio) * clusterRamOvercommitRatio;\n                    reservedCpu += (so.getCpu() * so.getSpeed() / cpuOvercommitRatio) * clusterCpuOvercommitRatio;\n                    reservedCpuCore += so.getCpu();\n                }\n            } else {\n                \r\n                \r\n                UserVmDetailVO messageSentFlag = _userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.MESSAGE_RESERVED_CAPACITY_FREED_FLAG);\n                if (messageSentFlag == null || !Boolean.valueOf(messageSentFlag.getValue())) {\n                    _messageBus.publish(_name, \"VM_ReservedCapacity_Free\", PublishScope.LOCAL, vm);\n\n                    if (vm.getType() == VirtualMachine.Type.User) {\n                        UserVmVO userVM = _userVMDao.findById(vm.getId());\n                        _userVMDao.loadDetails(userVM);\n                        userVM.setDetail(VmDetailConstants.MESSAGE_RESERVED_CAPACITY_FREED_FLAG, \"true\");\n                        _userVMDao.saveDetails(userVM);\n                    }\n                }\n            }\n        }\n\n        CapacityVO cpuCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_CPU);\n        CapacityVO memCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_MEMORY);\n        CapacityVO cpuCoreCap = _capacityDao.findByHostIdType(host.getId(), CapacityVO.CAPACITY_TYPE_CPU_CORE);\n\n        if (cpuCoreCap != null) {\n            long hostTotalCpuCore = host.getCpus().longValue();\n\n            if (cpuCoreCap.getTotalCapacity() != hostTotalCpuCore) {\n                s_logger.debug(\"Calibrate total cpu for host: \" + host.getId() + \" old total CPU:\"\n                        + cpuCoreCap.getTotalCapacity() + \" new total CPU:\" + hostTotalCpuCore);\n                cpuCoreCap.setTotalCapacity(hostTotalCpuCore);\n\n            }\n\n            if (cpuCoreCap.getUsedCapacity() == usedCpuCore && cpuCoreCap.getReservedCapacity() == reservedCpuCore) {\n                s_logger.debug(\"No need to calibrate cpu capacity, host:\" + host.getId() + \" usedCpuCore: \" + cpuCoreCap.getUsedCapacity()\n                        + \" reservedCpuCore: \" + cpuCoreCap.getReservedCapacity());\n            } else {\n                if (cpuCoreCap.getReservedCapacity() != reservedCpuCore) {\n                    s_logger.debug(\"Calibrate reserved cpu core for host: \" + host.getId() + \" old reservedCpuCore:\"\n                            + cpuCoreCap.getReservedCapacity() + \" new reservedCpuCore:\" + reservedCpuCore);\n                    cpuCoreCap.setReservedCapacity(reservedCpuCore);\n                }\n                if (cpuCoreCap.getUsedCapacity() != usedCpuCore) {\n                    s_logger.debug(\"Calibrate used cpu core for host: \" + host.getId() + \" old usedCpuCore:\"\n                            + cpuCoreCap.getUsedCapacity() + \" new usedCpuCore:\" + usedCpuCore);\n                    cpuCoreCap.setUsedCapacity(usedCpuCore);\n                }\n            }\n            try {\n                _capacityDao.update(cpuCoreCap.getId(), cpuCoreCap);\n            } catch (Exception e) {\n                s_logger.error(\"Caught exception while updating cpucore capacity for the host \" +host.getId(), e);\n            }\n        } else {\n            final long usedCpuCoreFinal = usedCpuCore;\n            final long reservedCpuCoreFinal = reservedCpuCore;\n            Transaction.execute(new TransactionCallbackNoReturn() {\n                @Override\n                public void doInTransactionWithoutResult(TransactionStatus status) {\n                    CapacityVO capacity = new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedCpuCoreFinal, host.getCpus().longValue(),\n                            CapacityVO.CAPACITY_TYPE_CPU_CORE);\n                    capacity.setReservedCapacity(reservedCpuCoreFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n                }\n            });\n        }\n\n        if (cpuCap != null && memCap != null) {\n            if (host.getTotalMemory() != null) {\n                memCap.setTotalCapacity(host.getTotalMemory());\n            }\n            long hostTotalCpu = host.getCpus().longValue() * host.getSpeed().longValue();\n\n            if (cpuCap.getTotalCapacity() != hostTotalCpu) {\n                s_logger.debug(\"Calibrate total cpu for host: \" + host.getId() + \" old total CPU:\" + cpuCap.getTotalCapacity() + \" new total CPU:\" + hostTotalCpu);\n                cpuCap.setTotalCapacity(hostTotalCpu);\n\n            }\n            \r\n            if(capacityState != cpuCap.getCapacityState()){\n                s_logger.debug(\"Calibrate cpu capacity state for host: \" + host.getId() + \" old capacity state:\" + cpuCap.getTotalCapacity() + \" new capacity state:\" + hostTotalCpu);\n                cpuCap.setCapacityState(capacityState);\n            }\n            memCap.setCapacityState(capacityState);\n\n            if (cpuCap.getUsedCapacity() == usedCpu && cpuCap.getReservedCapacity() == reservedCpu) {\n                s_logger.debug(\"No need to calibrate cpu capacity, host:\" + host.getId() + \" usedCpu: \" + cpuCap.getUsedCapacity() + \" reservedCpu: \" +\n                    cpuCap.getReservedCapacity());\n            } else {\n                if (cpuCap.getReservedCapacity() != reservedCpu) {\n                    s_logger.debug(\"Calibrate reserved cpu for host: \" + host.getId() + \" old reservedCpu:\" + cpuCap.getReservedCapacity() + \" new reservedCpu:\" +\n                        reservedCpu);\n                    cpuCap.setReservedCapacity(reservedCpu);\n                }\n                if (cpuCap.getUsedCapacity() != usedCpu) {\n                    s_logger.debug(\"Calibrate used cpu for host: \" + host.getId() + \" old usedCpu:\" + cpuCap.getUsedCapacity() + \" new usedCpu:\" + usedCpu);\n                    cpuCap.setUsedCapacity(usedCpu);\n                }\n            }\n\n            if (memCap.getTotalCapacity() != host.getTotalMemory()) {\n                s_logger.debug(\"Calibrate total memory for host: \" + host.getId() + \" old total memory:\" + memCap.getTotalCapacity() + \" new total memory:\" +\n                    host.getTotalMemory());\n                memCap.setTotalCapacity(host.getTotalMemory());\n\n            }\n            \r\n            if(capacityState != memCap.getCapacityState()){\n                s_logger.debug(\"Calibrate memory capacity state for host: \" + host.getId() + \" old capacity state:\" + memCap.getTotalCapacity() + \" new capacity state:\" + hostTotalCpu);\n                memCap.setCapacityState(capacityState);\n            }\n\n            if (memCap.getUsedCapacity() == usedMemory && memCap.getReservedCapacity() == reservedMemory) {\n                s_logger.debug(\"No need to calibrate memory capacity, host:\" + host.getId() + \" usedMem: \" + memCap.getUsedCapacity() + \" reservedMem: \" +\n                    memCap.getReservedCapacity());\n            } else {\n                if (memCap.getReservedCapacity() != reservedMemory) {\n                    s_logger.debug(\"Calibrate reserved memory for host: \" + host.getId() + \" old reservedMem:\" + memCap.getReservedCapacity() + \" new reservedMem:\" +\n                        reservedMemory);\n                    memCap.setReservedCapacity(reservedMemory);\n                }\n                if (memCap.getUsedCapacity() != usedMemory) {\n                    \r\n\r\n\r\n\r\n\n                    s_logger.debug(\"Calibrate used memory for host: \" + host.getId() + \" old usedMem: \" + memCap.getUsedCapacity() + \" new usedMem: \" + usedMemory);\n                    memCap.setUsedCapacity(usedMemory);\n                }\n            }\n\n            try {\n                _capacityDao.update(cpuCap.getId(), cpuCap);\n                _capacityDao.update(memCap.getId(), memCap);\n            } catch (Exception e) {\n                s_logger.error(\"Caught exception while updating cpu/memory capacity for the host \" + host.getId(), e);\n            }\n        } else {\n            final long usedMemoryFinal = usedMemory;\n            final long reservedMemoryFinal = reservedMemory;\n            final long usedCpuFinal = usedCpu;\n            final long reservedCpuFinal = reservedCpu;\n            Transaction.execute(new TransactionCallbackNoReturn() {\n                @Override\n                public void doInTransactionWithoutResult(TransactionStatus status) {\n                    CapacityVO capacity =\n                        new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedMemoryFinal, host.getTotalMemory(),\n                            Capacity.CAPACITY_TYPE_MEMORY);\n                    capacity.setReservedCapacity(reservedMemoryFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n\n                    capacity =\n                        new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedCpuFinal, host.getCpus().longValue() *\n                            host.getSpeed().longValue(), Capacity.CAPACITY_TYPE_CPU);\n                    capacity.setReservedCapacity(reservedCpuFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n                }\n            });\n\n        }\n\n    }\n","realPath":"server/src/main/java/com/cloud/capacity/CapacityManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":623,"status":"M"}],"commitId":"0cb2db6e1de985f4e2b3923a26fe21c6e86cacbe","commitMessage":"@@@Merge remote-tracking branch 'origin/4.13'\n","date":"2020-01-28 13:56:40","modifiedFileCount":"4","status":"M","submitter":"Rohit Yadav"},{"authorTime":"2020-08-13 18:25:16","codes":[{"authorDate":"2018-01-20 05:49:27","commitOrder":6,"curCode":"    public void recalculateCapacity() {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        try {\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"recalculating system capacity\");\n                s_logger.debug(\"Executing cpu/ram capacity update\");\n            }\n\n            \r\n            \r\n            List<HostVO> hosts = _resourceMgr.listAllNotInMaintenanceHostsInOneZone(Host.Type.Routing, null);\n            if (hosts != null) {\n                for (HostVO host : hosts) {\n                    _capacityMgr.updateCapacityForHost(host);\n                }\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing cpu/ram capacity update\");\n                s_logger.debug(\"Executing storage capacity update\");\n            }\n            \r\n            List<StoragePoolVO> storagePools = _storagePoolDao.listAll();\n            for (StoragePoolVO pool : storagePools) {\n                long disk = _capacityMgr.getAllocatedPoolCapacity(pool, null);\n                if (pool.isShared()) {\n                    _storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_STORAGE_ALLOCATED, disk);\n                } else {\n                    _storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_LOCAL_STORAGE, disk);\n                }\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing storage capacity update\");\n                s_logger.debug(\"Executing capacity updates for public ip and Vlans\");\n            }\n\n            List<DataCenterVO> datacenters = _dcDao.listAll();\n            for (DataCenterVO datacenter : datacenters) {\n                long dcId = datacenter.getId();\n\n                \r\n                \r\n                \r\n                \r\n                \r\n\n                \r\n                if (datacenter.getNetworkType() == NetworkType.Advanced) {\n                    createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_VIRTUAL_NETWORK_PUBLIC_IP, datacenter.getAllocationState());\n                }\n\n                \r\n                createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_DIRECT_ATTACHED_PUBLIC_IP, datacenter.getAllocationState());\n\n                if (datacenter.getNetworkType() == NetworkType.Advanced) {\n                    \r\n                    createOrUpdateVlanCapacity(dcId, datacenter.getAllocationState());\n                }\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done capacity updates for public ip and Vlans\");\n                s_logger.debug(\"Executing capacity updates for private ip\");\n            }\n\n            \r\n            List<HostPodVO> pods = _podDao.listAll();\n            for (HostPodVO pod : pods) {\n                long podId = pod.getId();\n                long dcId = pod.getDataCenterId();\n\n                createOrUpdateIpCapacity(dcId, podId, Capacity.CAPACITY_TYPE_PRIVATE_IP, _configMgr.findPodAllocationState(pod));\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing capacity updates for private ip\");\n                s_logger.debug(\"Done recalculating system capacity\");\n            }\n\n        } catch (Throwable t) {\n            s_logger.error(\"Caught exception in recalculating capacity\", t);\n        }\n    }\n","date":"2018-01-20 05:49:27","endLine":350,"groupId":"23680","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"recalculateCapacity","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/a5/8a4f8b0f91450e931ce96c942160b57ca0b1fa.src","preCode":"    public void recalculateCapacity() {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        try {\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"recalculating system capacity\");\n                s_logger.debug(\"Executing cpu/ram capacity update\");\n            }\n\n            \r\n            \r\n            List<HostVO> hosts = _resourceMgr.listAllNotInMaintenanceHostsInOneZone(Host.Type.Routing, null);\n            if (hosts != null) {\n                for (HostVO host : hosts) {\n                    _capacityMgr.updateCapacityForHost(host);\n                }\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing cpu/ram capacity update\");\n                s_logger.debug(\"Executing storage capacity update\");\n            }\n            \r\n            List<StoragePoolVO> storagePools = _storagePoolDao.listAll();\n            for (StoragePoolVO pool : storagePools) {\n                long disk = _capacityMgr.getAllocatedPoolCapacity(pool, null);\n                if (pool.isShared()) {\n                    _storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_STORAGE_ALLOCATED, disk);\n                } else {\n                    _storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_LOCAL_STORAGE, disk);\n                }\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing storage capacity update\");\n                s_logger.debug(\"Executing capacity updates for public ip and Vlans\");\n            }\n\n            List<DataCenterVO> datacenters = _dcDao.listAll();\n            for (DataCenterVO datacenter : datacenters) {\n                long dcId = datacenter.getId();\n\n                \r\n                \r\n                \r\n                \r\n                \r\n\n                \r\n                if (datacenter.getNetworkType() == NetworkType.Advanced) {\n                    createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_VIRTUAL_NETWORK_PUBLIC_IP, datacenter.getAllocationState());\n                }\n\n                \r\n                createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_DIRECT_ATTACHED_PUBLIC_IP, datacenter.getAllocationState());\n\n                if (datacenter.getNetworkType() == NetworkType.Advanced) {\n                    \r\n                    createOrUpdateVlanCapacity(dcId, datacenter.getAllocationState());\n                }\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done capacity updates for public ip and Vlans\");\n                s_logger.debug(\"Executing capacity updates for private ip\");\n            }\n\n            \r\n            List<HostPodVO> pods = _podDao.listAll();\n            for (HostPodVO pod : pods) {\n                long podId = pod.getId();\n                long dcId = pod.getDataCenterId();\n\n                createOrUpdateIpCapacity(dcId, podId, Capacity.CAPACITY_TYPE_PRIVATE_IP, _configMgr.findPodAllocationState(pod));\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing capacity updates for private ip\");\n                s_logger.debug(\"Done recalculating system capacity\");\n            }\n\n        } catch (Throwable t) {\n            s_logger.error(\"Caught exception in recalculating capacity\", t);\n        }\n    }\n","realPath":"server/src/main/java/com/cloud/alert/AlertManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":261,"status":"N"},{"authorDate":"2020-08-13 18:25:16","commitOrder":6,"curCode":"    public void updateCapacityForHost(final Host host) {\n        \r\n        List<ServiceOfferingVO> offerings = _offeringsDao.listAllIncludingRemoved();\n        Map<Long, ServiceOfferingVO> offeringsMap = new HashMap<Long, ServiceOfferingVO>();\n        for (ServiceOfferingVO offering : offerings) {\n            offeringsMap.put(offering.getId(), offering);\n        }\n\n        long usedCpuCore = 0;\n        long reservedCpuCore = 0;\n        long usedCpu = 0;\n        long usedMemory = 0;\n        long reservedMemory = 0;\n        long reservedCpu = 0;\n        final CapacityState capacityState = (host.getResourceState() == ResourceState.Enabled) ? CapacityState.Enabled : CapacityState.Disabled;\n\n        List<VMInstanceVO> vms = _vmDao.listUpByHostId(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vms.size() + \" VMs on host \" + host.getId());\n        }\n\n        final List<VMInstanceVO> vosMigrating = _vmDao.listVmsMigratingFromHost(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vosMigrating.size() + \" VMs are Migrating from host \" + host.getId());\n        }\n        vms.addAll(vosMigrating);\n\n        ClusterVO cluster = _clusterDao.findById(host.getClusterId());\n        ClusterDetailsVO clusterDetailCpu = _clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n        ClusterDetailsVO clusterDetailRam = _clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n        Float clusterCpuOvercommitRatio = Float.parseFloat(clusterDetailCpu.getValue());\n        Float clusterRamOvercommitRatio = Float.parseFloat(clusterDetailRam.getValue());\n        for (VMInstanceVO vm : vms) {\n            Float cpuOvercommitRatio = 1.0f;\n            Float ramOvercommitRatio = 1.0f;\n            Map<String, String> vmDetails = _userVmDetailsDao.listDetailsKeyPairs(vm.getId());\n            String vmDetailCpu = vmDetails.get(\"cpuOvercommitRatio\");\n            String vmDetailRam = vmDetails.get(\"memoryOvercommitRatio\");\n            if (vmDetailCpu != null) {\n                \r\n                cpuOvercommitRatio = Float.parseFloat(vmDetailCpu);\n                ramOvercommitRatio = Float.parseFloat(vmDetailRam);\n            }\n            ServiceOffering so = offeringsMap.get(vm.getServiceOfferingId());\n            if (so.isDynamic()) {\n                usedMemory +=\n                    ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.memory.name())) * 1024L * 1024L) / ramOvercommitRatio) *\n                        clusterRamOvercommitRatio;\n                if(vmDetails.containsKey(UsageEventVO.DynamicParameters.cpuSpeed.name())) {\n                    usedCpu +=\n                            ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuSpeed.name()))) / cpuOvercommitRatio) *\n                                    clusterCpuOvercommitRatio;\n                } else {\n                    usedCpu +=\n                            ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * so.getSpeed()) / cpuOvercommitRatio) *\n                                    clusterCpuOvercommitRatio;\n                }\n                usedCpuCore += Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name()));\n            } else {\n                usedMemory += ((so.getRamSize() * 1024L * 1024L) / ramOvercommitRatio) * clusterRamOvercommitRatio;\n                usedCpu += ((so.getCpu() * so.getSpeed()) / cpuOvercommitRatio) * clusterCpuOvercommitRatio;\n                usedCpuCore += so.getCpu();\n            }\n        }\n\n        List<VMInstanceVO> vmsByLastHostId = _vmDao.listByLastHostId(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vmsByLastHostId.size() + \" VM, not running on host \" + host.getId());\n        }\n        for (VMInstanceVO vm : vmsByLastHostId) {\n            Float cpuOvercommitRatio = 1.0f;\n            Float ramOvercommitRatio = 1.0f;\n            long secondsSinceLastUpdate = (DateUtil.currentGMTTime().getTime() - vm.getUpdateTime().getTime()) / 1000;\n            if (secondsSinceLastUpdate < _vmCapacityReleaseInterval) {\n                UserVmDetailVO vmDetailCpu = _userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                UserVmDetailVO vmDetailRam = _userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                if (vmDetailCpu != null) {\n                    \r\n                    cpuOvercommitRatio = Float.parseFloat(vmDetailCpu.getValue());\n                    ramOvercommitRatio = Float.parseFloat(vmDetailRam.getValue());\n                }\n                ServiceOffering so = offeringsMap.get(vm.getServiceOfferingId());\n                Map<String, String> vmDetails = _userVmDetailsDao.listDetailsKeyPairs(vm.getId());\n                if (so.isDynamic()) {\n                    reservedMemory +=\n                        ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.memory.name())) * 1024L * 1024L) / ramOvercommitRatio) *\n                            clusterRamOvercommitRatio;\n                    if(vmDetails.containsKey(UsageEventVO.DynamicParameters.cpuSpeed.name())) {\n                        reservedCpu +=\n                                ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuSpeed.name()))) / cpuOvercommitRatio) *\n                                        clusterCpuOvercommitRatio;\n                    } else {\n                        reservedCpu +=\n                                ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * so.getSpeed()) / cpuOvercommitRatio) *\n                                        clusterCpuOvercommitRatio;\n                    }\n                    reservedCpuCore += Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name()));\n                } else {\n                    reservedMemory += ((so.getRamSize() * 1024L * 1024L) / ramOvercommitRatio) * clusterRamOvercommitRatio;\n                    reservedCpu += (so.getCpu() * so.getSpeed() / cpuOvercommitRatio) * clusterCpuOvercommitRatio;\n                    reservedCpuCore += so.getCpu();\n                }\n            } else {\n                \r\n                \r\n                UserVmDetailVO messageSentFlag = _userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.MESSAGE_RESERVED_CAPACITY_FREED_FLAG);\n                if (messageSentFlag == null || !Boolean.valueOf(messageSentFlag.getValue())) {\n                    _messageBus.publish(_name, \"VM_ReservedCapacity_Free\", PublishScope.LOCAL, vm);\n\n                    if (vm.getType() == VirtualMachine.Type.User) {\n                        UserVmVO userVM = _userVMDao.findById(vm.getId());\n                        _userVMDao.loadDetails(userVM);\n                        userVM.setDetail(VmDetailConstants.MESSAGE_RESERVED_CAPACITY_FREED_FLAG, \"true\");\n                        _userVMDao.saveDetails(userVM);\n                    }\n                }\n            }\n        }\n\n        CapacityVO cpuCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_CPU);\n        CapacityVO memCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_MEMORY);\n        CapacityVO cpuCoreCap = _capacityDao.findByHostIdType(host.getId(), CapacityVO.CAPACITY_TYPE_CPU_CORE);\n\n        if (cpuCoreCap != null) {\n            long hostTotalCpuCore = host.getCpus().longValue();\n\n            if (cpuCoreCap.getTotalCapacity() != hostTotalCpuCore) {\n                s_logger.debug(\"Calibrate total cpu for host: \" + host.getId() + \" old total CPU:\"\n                        + cpuCoreCap.getTotalCapacity() + \" new total CPU:\" + hostTotalCpuCore);\n                cpuCoreCap.setTotalCapacity(hostTotalCpuCore);\n\n            }\n\n            if (cpuCoreCap.getUsedCapacity() == usedCpuCore && cpuCoreCap.getReservedCapacity() == reservedCpuCore) {\n                s_logger.debug(\"No need to calibrate cpu capacity, host:\" + host.getId() + \" usedCpuCore: \" + cpuCoreCap.getUsedCapacity()\n                        + \" reservedCpuCore: \" + cpuCoreCap.getReservedCapacity());\n            } else {\n                if (cpuCoreCap.getReservedCapacity() != reservedCpuCore) {\n                    s_logger.debug(\"Calibrate reserved cpu core for host: \" + host.getId() + \" old reservedCpuCore:\"\n                            + cpuCoreCap.getReservedCapacity() + \" new reservedCpuCore:\" + reservedCpuCore);\n                    cpuCoreCap.setReservedCapacity(reservedCpuCore);\n                }\n                if (cpuCoreCap.getUsedCapacity() != usedCpuCore) {\n                    s_logger.debug(\"Calibrate used cpu core for host: \" + host.getId() + \" old usedCpuCore:\"\n                            + cpuCoreCap.getUsedCapacity() + \" new usedCpuCore:\" + usedCpuCore);\n                    cpuCoreCap.setUsedCapacity(usedCpuCore);\n                }\n            }\n            try {\n                _capacityDao.update(cpuCoreCap.getId(), cpuCoreCap);\n            } catch (Exception e) {\n                s_logger.error(\"Caught exception while updating cpucore capacity for the host \" +host.getId(), e);\n            }\n        } else {\n            final long usedCpuCoreFinal = usedCpuCore;\n            final long reservedCpuCoreFinal = reservedCpuCore;\n            Transaction.execute(new TransactionCallbackNoReturn() {\n                @Override\n                public void doInTransactionWithoutResult(TransactionStatus status) {\n                    CapacityVO capacity = new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedCpuCoreFinal, host.getCpus().longValue(),\n                            CapacityVO.CAPACITY_TYPE_CPU_CORE);\n                    capacity.setReservedCapacity(reservedCpuCoreFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n                }\n            });\n        }\n\n        if (cpuCap != null && memCap != null) {\n            if (host.getTotalMemory() != null) {\n                memCap.setTotalCapacity(host.getTotalMemory());\n            }\n            long hostTotalCpu = host.getCpus().longValue() * host.getSpeed().longValue();\n\n            if (cpuCap.getTotalCapacity() != hostTotalCpu) {\n                s_logger.debug(\"Calibrate total cpu for host: \" + host.getId() + \" old total CPU:\" + cpuCap.getTotalCapacity() + \" new total CPU:\" + hostTotalCpu);\n                cpuCap.setTotalCapacity(hostTotalCpu);\n\n            }\n            \r\n            if(capacityState != cpuCap.getCapacityState()){\n                s_logger.debug(\"Calibrate cpu capacity state for host: \" + host.getId() + \" old capacity state:\" + cpuCap.getTotalCapacity() + \" new capacity state:\" + hostTotalCpu);\n                cpuCap.setCapacityState(capacityState);\n            }\n            memCap.setCapacityState(capacityState);\n\n            if (cpuCap.getUsedCapacity() == usedCpu && cpuCap.getReservedCapacity() == reservedCpu) {\n                s_logger.debug(\"No need to calibrate cpu capacity, host:\" + host.getId() + \" usedCpu: \" + cpuCap.getUsedCapacity() + \" reservedCpu: \" +\n                    cpuCap.getReservedCapacity());\n            } else {\n                if (cpuCap.getReservedCapacity() != reservedCpu) {\n                    s_logger.debug(\"Calibrate reserved cpu for host: \" + host.getId() + \" old reservedCpu:\" + cpuCap.getReservedCapacity() + \" new reservedCpu:\" +\n                        reservedCpu);\n                    cpuCap.setReservedCapacity(reservedCpu);\n                }\n                if (cpuCap.getUsedCapacity() != usedCpu) {\n                    s_logger.debug(\"Calibrate used cpu for host: \" + host.getId() + \" old usedCpu:\" + cpuCap.getUsedCapacity() + \" new usedCpu:\" + usedCpu);\n                    cpuCap.setUsedCapacity(usedCpu);\n                }\n            }\n\n            if (memCap.getTotalCapacity() != host.getTotalMemory()) {\n                s_logger.debug(\"Calibrate total memory for host: \" + host.getId() + \" old total memory:\" + toHumanReadableSize(memCap.getTotalCapacity()) + \" new total memory:\" +\n                        toHumanReadableSize(host.getTotalMemory()));\n                memCap.setTotalCapacity(host.getTotalMemory());\n\n            }\n            \r\n            if(capacityState != memCap.getCapacityState()){\n                s_logger.debug(\"Calibrate memory capacity state for host: \" + host.getId() + \" old capacity state:\" + memCap.getTotalCapacity() + \" new capacity state:\" + hostTotalCpu);\n                memCap.setCapacityState(capacityState);\n            }\n\n            if (memCap.getUsedCapacity() == usedMemory && memCap.getReservedCapacity() == reservedMemory) {\n                s_logger.debug(\"No need to calibrate memory capacity, host:\" + host.getId() + \" usedMem: \" + toHumanReadableSize(memCap.getUsedCapacity()) + \" reservedMem: \" +\n                        toHumanReadableSize(memCap.getReservedCapacity()));\n            } else {\n                if (memCap.getReservedCapacity() != reservedMemory) {\n                    s_logger.debug(\"Calibrate reserved memory for host: \" + host.getId() + \" old reservedMem:\" + memCap.getReservedCapacity() + \" new reservedMem:\" +\n                        reservedMemory);\n                    memCap.setReservedCapacity(reservedMemory);\n                }\n                if (memCap.getUsedCapacity() != usedMemory) {\n                    \r\n\r\n\r\n\r\n\n                    s_logger.debug(\"Calibrate used memory for host: \" + host.getId() + \" old usedMem: \" + toHumanReadableSize(memCap.getUsedCapacity()) + \" new usedMem: \" + toHumanReadableSize(usedMemory));\n                    memCap.setUsedCapacity(usedMemory);\n                }\n            }\n\n            try {\n                _capacityDao.update(cpuCap.getId(), cpuCap);\n                _capacityDao.update(memCap.getId(), memCap);\n            } catch (Exception e) {\n                s_logger.error(\"Caught exception while updating cpu/memory capacity for the host \" + host.getId(), e);\n            }\n        } else {\n            final long usedMemoryFinal = usedMemory;\n            final long reservedMemoryFinal = reservedMemory;\n            final long usedCpuFinal = usedCpu;\n            final long reservedCpuFinal = reservedCpu;\n            Transaction.execute(new TransactionCallbackNoReturn() {\n                @Override\n                public void doInTransactionWithoutResult(TransactionStatus status) {\n                    CapacityVO capacity =\n                        new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedMemoryFinal, host.getTotalMemory(),\n                            Capacity.CAPACITY_TYPE_MEMORY);\n                    capacity.setReservedCapacity(reservedMemoryFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n\n                    capacity =\n                        new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedCpuFinal, host.getCpus().longValue() *\n                            host.getSpeed().longValue(), Capacity.CAPACITY_TYPE_CPU);\n                    capacity.setReservedCapacity(reservedCpuFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n                }\n            });\n\n        }\n\n    }\n","date":"2020-08-13 18:25:16","endLine":890,"groupId":"10980","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"updateCapacityForHost","params":"(finalHosthost)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/ce/86add1a08d3e90ec285cd233a4efaaee4cdbec.src","preCode":"    public void updateCapacityForHost(final Host host) {\n        \r\n        List<ServiceOfferingVO> offerings = _offeringsDao.listAllIncludingRemoved();\n        Map<Long, ServiceOfferingVO> offeringsMap = new HashMap<Long, ServiceOfferingVO>();\n        for (ServiceOfferingVO offering : offerings) {\n            offeringsMap.put(offering.getId(), offering);\n        }\n\n        long usedCpuCore = 0;\n        long reservedCpuCore = 0;\n        long usedCpu = 0;\n        long usedMemory = 0;\n        long reservedMemory = 0;\n        long reservedCpu = 0;\n        final CapacityState capacityState = (host.getResourceState() == ResourceState.Enabled) ? CapacityState.Enabled : CapacityState.Disabled;\n\n        List<VMInstanceVO> vms = _vmDao.listUpByHostId(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vms.size() + \" VMs on host \" + host.getId());\n        }\n\n        final List<VMInstanceVO> vosMigrating = _vmDao.listVmsMigratingFromHost(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vosMigrating.size() + \" VMs are Migrating from host \" + host.getId());\n        }\n        vms.addAll(vosMigrating);\n\n        ClusterVO cluster = _clusterDao.findById(host.getClusterId());\n        ClusterDetailsVO clusterDetailCpu = _clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n        ClusterDetailsVO clusterDetailRam = _clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n        Float clusterCpuOvercommitRatio = Float.parseFloat(clusterDetailCpu.getValue());\n        Float clusterRamOvercommitRatio = Float.parseFloat(clusterDetailRam.getValue());\n        for (VMInstanceVO vm : vms) {\n            Float cpuOvercommitRatio = 1.0f;\n            Float ramOvercommitRatio = 1.0f;\n            Map<String, String> vmDetails = _userVmDetailsDao.listDetailsKeyPairs(vm.getId());\n            String vmDetailCpu = vmDetails.get(\"cpuOvercommitRatio\");\n            String vmDetailRam = vmDetails.get(\"memoryOvercommitRatio\");\n            if (vmDetailCpu != null) {\n                \r\n                cpuOvercommitRatio = Float.parseFloat(vmDetailCpu);\n                ramOvercommitRatio = Float.parseFloat(vmDetailRam);\n            }\n            ServiceOffering so = offeringsMap.get(vm.getServiceOfferingId());\n            if (so.isDynamic()) {\n                usedMemory +=\n                    ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.memory.name())) * 1024L * 1024L) / ramOvercommitRatio) *\n                        clusterRamOvercommitRatio;\n                if(vmDetails.containsKey(UsageEventVO.DynamicParameters.cpuSpeed.name())) {\n                    usedCpu +=\n                            ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuSpeed.name()))) / cpuOvercommitRatio) *\n                                    clusterCpuOvercommitRatio;\n                } else {\n                    usedCpu +=\n                            ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * so.getSpeed()) / cpuOvercommitRatio) *\n                                    clusterCpuOvercommitRatio;\n                }\n                usedCpuCore += Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name()));\n            } else {\n                usedMemory += ((so.getRamSize() * 1024L * 1024L) / ramOvercommitRatio) * clusterRamOvercommitRatio;\n                usedCpu += ((so.getCpu() * so.getSpeed()) / cpuOvercommitRatio) * clusterCpuOvercommitRatio;\n                usedCpuCore += so.getCpu();\n            }\n        }\n\n        List<VMInstanceVO> vmsByLastHostId = _vmDao.listByLastHostId(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vmsByLastHostId.size() + \" VM, not running on host \" + host.getId());\n        }\n        for (VMInstanceVO vm : vmsByLastHostId) {\n            Float cpuOvercommitRatio = 1.0f;\n            Float ramOvercommitRatio = 1.0f;\n            long secondsSinceLastUpdate = (DateUtil.currentGMTTime().getTime() - vm.getUpdateTime().getTime()) / 1000;\n            if (secondsSinceLastUpdate < _vmCapacityReleaseInterval) {\n                UserVmDetailVO vmDetailCpu = _userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                UserVmDetailVO vmDetailRam = _userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                if (vmDetailCpu != null) {\n                    \r\n                    cpuOvercommitRatio = Float.parseFloat(vmDetailCpu.getValue());\n                    ramOvercommitRatio = Float.parseFloat(vmDetailRam.getValue());\n                }\n                ServiceOffering so = offeringsMap.get(vm.getServiceOfferingId());\n                Map<String, String> vmDetails = _userVmDetailsDao.listDetailsKeyPairs(vm.getId());\n                if (so.isDynamic()) {\n                    reservedMemory +=\n                        ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.memory.name())) * 1024L * 1024L) / ramOvercommitRatio) *\n                            clusterRamOvercommitRatio;\n                    if(vmDetails.containsKey(UsageEventVO.DynamicParameters.cpuSpeed.name())) {\n                        reservedCpu +=\n                                ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuSpeed.name()))) / cpuOvercommitRatio) *\n                                        clusterCpuOvercommitRatio;\n                    } else {\n                        reservedCpu +=\n                                ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * so.getSpeed()) / cpuOvercommitRatio) *\n                                        clusterCpuOvercommitRatio;\n                    }\n                    reservedCpuCore += Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name()));\n                } else {\n                    reservedMemory += ((so.getRamSize() * 1024L * 1024L) / ramOvercommitRatio) * clusterRamOvercommitRatio;\n                    reservedCpu += (so.getCpu() * so.getSpeed() / cpuOvercommitRatio) * clusterCpuOvercommitRatio;\n                    reservedCpuCore += so.getCpu();\n                }\n            } else {\n                \r\n                \r\n                UserVmDetailVO messageSentFlag = _userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.MESSAGE_RESERVED_CAPACITY_FREED_FLAG);\n                if (messageSentFlag == null || !Boolean.valueOf(messageSentFlag.getValue())) {\n                    _messageBus.publish(_name, \"VM_ReservedCapacity_Free\", PublishScope.LOCAL, vm);\n\n                    if (vm.getType() == VirtualMachine.Type.User) {\n                        UserVmVO userVM = _userVMDao.findById(vm.getId());\n                        _userVMDao.loadDetails(userVM);\n                        userVM.setDetail(VmDetailConstants.MESSAGE_RESERVED_CAPACITY_FREED_FLAG, \"true\");\n                        _userVMDao.saveDetails(userVM);\n                    }\n                }\n            }\n        }\n\n        CapacityVO cpuCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_CPU);\n        CapacityVO memCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_MEMORY);\n        CapacityVO cpuCoreCap = _capacityDao.findByHostIdType(host.getId(), CapacityVO.CAPACITY_TYPE_CPU_CORE);\n\n        if (cpuCoreCap != null) {\n            long hostTotalCpuCore = host.getCpus().longValue();\n\n            if (cpuCoreCap.getTotalCapacity() != hostTotalCpuCore) {\n                s_logger.debug(\"Calibrate total cpu for host: \" + host.getId() + \" old total CPU:\"\n                        + cpuCoreCap.getTotalCapacity() + \" new total CPU:\" + hostTotalCpuCore);\n                cpuCoreCap.setTotalCapacity(hostTotalCpuCore);\n\n            }\n\n            if (cpuCoreCap.getUsedCapacity() == usedCpuCore && cpuCoreCap.getReservedCapacity() == reservedCpuCore) {\n                s_logger.debug(\"No need to calibrate cpu capacity, host:\" + host.getId() + \" usedCpuCore: \" + cpuCoreCap.getUsedCapacity()\n                        + \" reservedCpuCore: \" + cpuCoreCap.getReservedCapacity());\n            } else {\n                if (cpuCoreCap.getReservedCapacity() != reservedCpuCore) {\n                    s_logger.debug(\"Calibrate reserved cpu core for host: \" + host.getId() + \" old reservedCpuCore:\"\n                            + cpuCoreCap.getReservedCapacity() + \" new reservedCpuCore:\" + reservedCpuCore);\n                    cpuCoreCap.setReservedCapacity(reservedCpuCore);\n                }\n                if (cpuCoreCap.getUsedCapacity() != usedCpuCore) {\n                    s_logger.debug(\"Calibrate used cpu core for host: \" + host.getId() + \" old usedCpuCore:\"\n                            + cpuCoreCap.getUsedCapacity() + \" new usedCpuCore:\" + usedCpuCore);\n                    cpuCoreCap.setUsedCapacity(usedCpuCore);\n                }\n            }\n            try {\n                _capacityDao.update(cpuCoreCap.getId(), cpuCoreCap);\n            } catch (Exception e) {\n                s_logger.error(\"Caught exception while updating cpucore capacity for the host \" +host.getId(), e);\n            }\n        } else {\n            final long usedCpuCoreFinal = usedCpuCore;\n            final long reservedCpuCoreFinal = reservedCpuCore;\n            Transaction.execute(new TransactionCallbackNoReturn() {\n                @Override\n                public void doInTransactionWithoutResult(TransactionStatus status) {\n                    CapacityVO capacity = new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedCpuCoreFinal, host.getCpus().longValue(),\n                            CapacityVO.CAPACITY_TYPE_CPU_CORE);\n                    capacity.setReservedCapacity(reservedCpuCoreFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n                }\n            });\n        }\n\n        if (cpuCap != null && memCap != null) {\n            if (host.getTotalMemory() != null) {\n                memCap.setTotalCapacity(host.getTotalMemory());\n            }\n            long hostTotalCpu = host.getCpus().longValue() * host.getSpeed().longValue();\n\n            if (cpuCap.getTotalCapacity() != hostTotalCpu) {\n                s_logger.debug(\"Calibrate total cpu for host: \" + host.getId() + \" old total CPU:\" + cpuCap.getTotalCapacity() + \" new total CPU:\" + hostTotalCpu);\n                cpuCap.setTotalCapacity(hostTotalCpu);\n\n            }\n            \r\n            if(capacityState != cpuCap.getCapacityState()){\n                s_logger.debug(\"Calibrate cpu capacity state for host: \" + host.getId() + \" old capacity state:\" + cpuCap.getTotalCapacity() + \" new capacity state:\" + hostTotalCpu);\n                cpuCap.setCapacityState(capacityState);\n            }\n            memCap.setCapacityState(capacityState);\n\n            if (cpuCap.getUsedCapacity() == usedCpu && cpuCap.getReservedCapacity() == reservedCpu) {\n                s_logger.debug(\"No need to calibrate cpu capacity, host:\" + host.getId() + \" usedCpu: \" + cpuCap.getUsedCapacity() + \" reservedCpu: \" +\n                    cpuCap.getReservedCapacity());\n            } else {\n                if (cpuCap.getReservedCapacity() != reservedCpu) {\n                    s_logger.debug(\"Calibrate reserved cpu for host: \" + host.getId() + \" old reservedCpu:\" + cpuCap.getReservedCapacity() + \" new reservedCpu:\" +\n                        reservedCpu);\n                    cpuCap.setReservedCapacity(reservedCpu);\n                }\n                if (cpuCap.getUsedCapacity() != usedCpu) {\n                    s_logger.debug(\"Calibrate used cpu for host: \" + host.getId() + \" old usedCpu:\" + cpuCap.getUsedCapacity() + \" new usedCpu:\" + usedCpu);\n                    cpuCap.setUsedCapacity(usedCpu);\n                }\n            }\n\n            if (memCap.getTotalCapacity() != host.getTotalMemory()) {\n                s_logger.debug(\"Calibrate total memory for host: \" + host.getId() + \" old total memory:\" + memCap.getTotalCapacity() + \" new total memory:\" +\n                    host.getTotalMemory());\n                memCap.setTotalCapacity(host.getTotalMemory());\n\n            }\n            \r\n            if(capacityState != memCap.getCapacityState()){\n                s_logger.debug(\"Calibrate memory capacity state for host: \" + host.getId() + \" old capacity state:\" + memCap.getTotalCapacity() + \" new capacity state:\" + hostTotalCpu);\n                memCap.setCapacityState(capacityState);\n            }\n\n            if (memCap.getUsedCapacity() == usedMemory && memCap.getReservedCapacity() == reservedMemory) {\n                s_logger.debug(\"No need to calibrate memory capacity, host:\" + host.getId() + \" usedMem: \" + memCap.getUsedCapacity() + \" reservedMem: \" +\n                    memCap.getReservedCapacity());\n            } else {\n                if (memCap.getReservedCapacity() != reservedMemory) {\n                    s_logger.debug(\"Calibrate reserved memory for host: \" + host.getId() + \" old reservedMem:\" + memCap.getReservedCapacity() + \" new reservedMem:\" +\n                        reservedMemory);\n                    memCap.setReservedCapacity(reservedMemory);\n                }\n                if (memCap.getUsedCapacity() != usedMemory) {\n                    \r\n\r\n\r\n\r\n\n                    s_logger.debug(\"Calibrate used memory for host: \" + host.getId() + \" old usedMem: \" + memCap.getUsedCapacity() + \" new usedMem: \" + usedMemory);\n                    memCap.setUsedCapacity(usedMemory);\n                }\n            }\n\n            try {\n                _capacityDao.update(cpuCap.getId(), cpuCap);\n                _capacityDao.update(memCap.getId(), memCap);\n            } catch (Exception e) {\n                s_logger.error(\"Caught exception while updating cpu/memory capacity for the host \" + host.getId(), e);\n            }\n        } else {\n            final long usedMemoryFinal = usedMemory;\n            final long reservedMemoryFinal = reservedMemory;\n            final long usedCpuFinal = usedCpu;\n            final long reservedCpuFinal = reservedCpu;\n            Transaction.execute(new TransactionCallbackNoReturn() {\n                @Override\n                public void doInTransactionWithoutResult(TransactionStatus status) {\n                    CapacityVO capacity =\n                        new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedMemoryFinal, host.getTotalMemory(),\n                            Capacity.CAPACITY_TYPE_MEMORY);\n                    capacity.setReservedCapacity(reservedMemoryFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n\n                    capacity =\n                        new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedCpuFinal, host.getCpus().longValue() *\n                            host.getSpeed().longValue(), Capacity.CAPACITY_TYPE_CPU);\n                    capacity.setReservedCapacity(reservedCpuFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n                }\n            });\n\n        }\n\n    }\n","realPath":"server/src/main/java/com/cloud/capacity/CapacityManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":625,"status":"M"}],"commitId":"b586eb22f1b31f3cab2f2cb1aaeafca4f4646abd","commitMessage":"@@@Human readable sizes in logs (#4207)\n\nThis PR adds outputting human readable byte sizes in the management server logs.  agent logs.  and usage records. A non-dynamic global variable is added (display.human.readable.sizes) to control switching this feature on and off. This setting is sent to the agent on connection and is only read from the database when the management server is started up. The setting is kept in memory by the use of a static field on the NumbersUtil class and is available throughout the codebase.\n\nInstead of seeing things like:\n2020-07-23 15:31:58. 593 DEBUG [c.c.a.t.Request] (AgentManager-Handler-12:null) (logid:) Seq 8-1863645820801253428: Processing: { Ans: .  MgmtId: 52238089807.  via: 8.  Ver: v1.  Flags: 10.  [{\"com.cloud.agent.api.NetworkUsageAnswer\":{\"routerName\":\"r-224-VM\". \"bytesSent\":\"106496\". \"bytesReceived\":\"0\". \"result\":\"true\". \"details\":\"\". \"wait\":\"0\". }}] }\n\nThe KB MB and GB values will be printed out:\n\n2020-07-23 15:31:58. 593 DEBUG [c.c.a.t.Request] (AgentManager-Handler-12:null) (logid:) Seq 8-1863645820801253428: Processing: { Ans: .  MgmtId: 52238089807.  via: 8.  Ver: v1.  Flags: 10.  [{\"com.cloud.agent.api.NetworkUsageAnswer\":{\"routerName\":\"r-224-VM\". \"bytesSent\":\"(104.00 KB) 106496\". \"bytesReceived\":\"(0 bytes) 0\". \"result\":\"true\". \"details\":\"\". \"wait\":\"0\". }}] }\n\nFS: https://cwiki.apache.org/confluence/display/CLOUDSTACK/Human+Readable+Byte+sizes","date":"2020-08-13 18:25:16","modifiedFileCount":"55","status":"M","submitter":"Spaceman1984"},{"authorTime":"2021-02-05 18:32:26","codes":[{"authorDate":"2021-02-05 18:32:26","commitOrder":7,"curCode":"    public void recalculateCapacity() {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        try {\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"recalculating system capacity\");\n                s_logger.debug(\"Executing cpu/ram capacity update\");\n            }\n\n            \r\n            \r\n            List<HostVO> hosts = _resourceMgr.listAllNotInMaintenanceHostsInOneZone(Host.Type.Routing, null);\n            if (hosts != null) {\n                \r\n                List<ServiceOfferingVO> offerings = _offeringsDao.listAllIncludingRemoved();\n                Map<Long, ServiceOfferingVO> offeringsMap = new HashMap<Long, ServiceOfferingVO>();\n                for (ServiceOfferingVO offering : offerings) {\n                    offeringsMap.put(offering.getId(), offering);\n                }\n                for (HostVO host : hosts) {\n                    _capacityMgr.updateCapacityForHost(host, offeringsMap);\n                }\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing cpu/ram capacity update\");\n                s_logger.debug(\"Executing storage capacity update\");\n            }\n            \r\n            List<StoragePoolVO> storagePools = _storagePoolDao.listAll();\n            for (StoragePoolVO pool : storagePools) {\n                long disk = _capacityMgr.getAllocatedPoolCapacity(pool, null);\n                if (pool.isShared()) {\n                    _storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_STORAGE_ALLOCATED, disk);\n                } else {\n                    _storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_LOCAL_STORAGE, disk);\n                }\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing storage capacity update\");\n                s_logger.debug(\"Executing capacity updates for public ip and Vlans\");\n            }\n\n            List<DataCenterVO> datacenters = _dcDao.listAll();\n            for (DataCenterVO datacenter : datacenters) {\n                long dcId = datacenter.getId();\n\n                \r\n                \r\n                \r\n                \r\n                \r\n\n                \r\n                if (datacenter.getNetworkType() == NetworkType.Advanced) {\n                    createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_VIRTUAL_NETWORK_PUBLIC_IP, datacenter.getAllocationState());\n                }\n\n                \r\n                createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_DIRECT_ATTACHED_PUBLIC_IP, datacenter.getAllocationState());\n\n                if (datacenter.getNetworkType() == NetworkType.Advanced) {\n                    \r\n                    createOrUpdateVlanCapacity(dcId, datacenter.getAllocationState());\n                }\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done capacity updates for public ip and Vlans\");\n                s_logger.debug(\"Executing capacity updates for private ip\");\n            }\n\n            \r\n            List<HostPodVO> pods = _podDao.listAll();\n            for (HostPodVO pod : pods) {\n                long podId = pod.getId();\n                long dcId = pod.getDataCenterId();\n\n                createOrUpdateIpCapacity(dcId, podId, Capacity.CAPACITY_TYPE_PRIVATE_IP, _configMgr.findPodAllocationState(pod));\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing capacity updates for private ip\");\n                s_logger.debug(\"Done recalculating system capacity\");\n            }\n\n        } catch (Throwable t) {\n            s_logger.error(\"Caught exception in recalculating capacity\", t);\n        }\n    }\n","date":"2021-02-05 18:32:26","endLine":358,"groupId":"121409","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"recalculateCapacity","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/75/b8cc7f3b4e0beb30016c2dbedbcedc8e6ece65.src","preCode":"    public void recalculateCapacity() {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        try {\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"recalculating system capacity\");\n                s_logger.debug(\"Executing cpu/ram capacity update\");\n            }\n\n            \r\n            \r\n            List<HostVO> hosts = _resourceMgr.listAllNotInMaintenanceHostsInOneZone(Host.Type.Routing, null);\n            if (hosts != null) {\n                for (HostVO host : hosts) {\n                    _capacityMgr.updateCapacityForHost(host);\n                }\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing cpu/ram capacity update\");\n                s_logger.debug(\"Executing storage capacity update\");\n            }\n            \r\n            List<StoragePoolVO> storagePools = _storagePoolDao.listAll();\n            for (StoragePoolVO pool : storagePools) {\n                long disk = _capacityMgr.getAllocatedPoolCapacity(pool, null);\n                if (pool.isShared()) {\n                    _storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_STORAGE_ALLOCATED, disk);\n                } else {\n                    _storageMgr.createCapacityEntry(pool, Capacity.CAPACITY_TYPE_LOCAL_STORAGE, disk);\n                }\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing storage capacity update\");\n                s_logger.debug(\"Executing capacity updates for public ip and Vlans\");\n            }\n\n            List<DataCenterVO> datacenters = _dcDao.listAll();\n            for (DataCenterVO datacenter : datacenters) {\n                long dcId = datacenter.getId();\n\n                \r\n                \r\n                \r\n                \r\n                \r\n\n                \r\n                if (datacenter.getNetworkType() == NetworkType.Advanced) {\n                    createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_VIRTUAL_NETWORK_PUBLIC_IP, datacenter.getAllocationState());\n                }\n\n                \r\n                createOrUpdateIpCapacity(dcId, null, Capacity.CAPACITY_TYPE_DIRECT_ATTACHED_PUBLIC_IP, datacenter.getAllocationState());\n\n                if (datacenter.getNetworkType() == NetworkType.Advanced) {\n                    \r\n                    createOrUpdateVlanCapacity(dcId, datacenter.getAllocationState());\n                }\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done capacity updates for public ip and Vlans\");\n                s_logger.debug(\"Executing capacity updates for private ip\");\n            }\n\n            \r\n            List<HostPodVO> pods = _podDao.listAll();\n            for (HostPodVO pod : pods) {\n                long podId = pod.getId();\n                long dcId = pod.getDataCenterId();\n\n                createOrUpdateIpCapacity(dcId, podId, Capacity.CAPACITY_TYPE_PRIVATE_IP, _configMgr.findPodAllocationState(pod));\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Done executing capacity updates for private ip\");\n                s_logger.debug(\"Done recalculating system capacity\");\n            }\n\n        } catch (Throwable t) {\n            s_logger.error(\"Caught exception in recalculating capacity\", t);\n        }\n    }\n","realPath":"server/src/main/java/com/cloud/alert/AlertManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":263,"status":"M"},{"authorDate":"2021-02-05 18:32:26","commitOrder":7,"curCode":"    public void updateCapacityForHost(final Host host) {\n        \r\n        List<ServiceOfferingVO> offerings = _offeringsDao.listAllIncludingRemoved();\n        Map<Long, ServiceOfferingVO> offeringsMap = new HashMap<Long, ServiceOfferingVO>();\n        for (ServiceOfferingVO offering : offerings) {\n            offeringsMap.put(offering.getId(), offering);\n        }\n        updateCapacityForHost(host, offeringsMap);\n    }\n","date":"2021-02-05 18:32:26","endLine":633,"groupId":"121409","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"updateCapacityForHost","params":"(finalHosthost)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/fb/a24e0a8c7d76a25798c5166144b4629c7fac73.src","preCode":"    public void updateCapacityForHost(final Host host) {\n        \r\n        List<ServiceOfferingVO> offerings = _offeringsDao.listAllIncludingRemoved();\n        Map<Long, ServiceOfferingVO> offeringsMap = new HashMap<Long, ServiceOfferingVO>();\n        for (ServiceOfferingVO offering : offerings) {\n            offeringsMap.put(offering.getId(), offering);\n        }\n\n        long usedCpuCore = 0;\n        long reservedCpuCore = 0;\n        long usedCpu = 0;\n        long usedMemory = 0;\n        long reservedMemory = 0;\n        long reservedCpu = 0;\n        final CapacityState capacityState = (host.getResourceState() == ResourceState.Enabled) ? CapacityState.Enabled : CapacityState.Disabled;\n\n        List<VMInstanceVO> vms = _vmDao.listUpByHostId(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vms.size() + \" VMs on host \" + host.getId());\n        }\n\n        final List<VMInstanceVO> vosMigrating = _vmDao.listVmsMigratingFromHost(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vosMigrating.size() + \" VMs are Migrating from host \" + host.getId());\n        }\n        vms.addAll(vosMigrating);\n\n        ClusterVO cluster = _clusterDao.findById(host.getClusterId());\n        ClusterDetailsVO clusterDetailCpu = _clusterDetailsDao.findDetail(cluster.getId(), \"cpuOvercommitRatio\");\n        ClusterDetailsVO clusterDetailRam = _clusterDetailsDao.findDetail(cluster.getId(), \"memoryOvercommitRatio\");\n        Float clusterCpuOvercommitRatio = Float.parseFloat(clusterDetailCpu.getValue());\n        Float clusterRamOvercommitRatio = Float.parseFloat(clusterDetailRam.getValue());\n        for (VMInstanceVO vm : vms) {\n            Float cpuOvercommitRatio = 1.0f;\n            Float ramOvercommitRatio = 1.0f;\n            Map<String, String> vmDetails = _userVmDetailsDao.listDetailsKeyPairs(vm.getId());\n            String vmDetailCpu = vmDetails.get(\"cpuOvercommitRatio\");\n            String vmDetailRam = vmDetails.get(\"memoryOvercommitRatio\");\n            if (vmDetailCpu != null) {\n                \r\n                cpuOvercommitRatio = Float.parseFloat(vmDetailCpu);\n                ramOvercommitRatio = Float.parseFloat(vmDetailRam);\n            }\n            ServiceOffering so = offeringsMap.get(vm.getServiceOfferingId());\n            if (so.isDynamic()) {\n                usedMemory +=\n                    ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.memory.name())) * 1024L * 1024L) / ramOvercommitRatio) *\n                        clusterRamOvercommitRatio;\n                if(vmDetails.containsKey(UsageEventVO.DynamicParameters.cpuSpeed.name())) {\n                    usedCpu +=\n                            ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuSpeed.name()))) / cpuOvercommitRatio) *\n                                    clusterCpuOvercommitRatio;\n                } else {\n                    usedCpu +=\n                            ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * so.getSpeed()) / cpuOvercommitRatio) *\n                                    clusterCpuOvercommitRatio;\n                }\n                usedCpuCore += Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name()));\n            } else {\n                usedMemory += ((so.getRamSize() * 1024L * 1024L) / ramOvercommitRatio) * clusterRamOvercommitRatio;\n                usedCpu += ((so.getCpu() * so.getSpeed()) / cpuOvercommitRatio) * clusterCpuOvercommitRatio;\n                usedCpuCore += so.getCpu();\n            }\n        }\n\n        List<VMInstanceVO> vmsByLastHostId = _vmDao.listByLastHostId(host.getId());\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Found \" + vmsByLastHostId.size() + \" VM, not running on host \" + host.getId());\n        }\n        for (VMInstanceVO vm : vmsByLastHostId) {\n            Float cpuOvercommitRatio = 1.0f;\n            Float ramOvercommitRatio = 1.0f;\n            long secondsSinceLastUpdate = (DateUtil.currentGMTTime().getTime() - vm.getUpdateTime().getTime()) / 1000;\n            if (secondsSinceLastUpdate < _vmCapacityReleaseInterval) {\n                UserVmDetailVO vmDetailCpu = _userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                UserVmDetailVO vmDetailRam = _userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                if (vmDetailCpu != null) {\n                    \r\n                    cpuOvercommitRatio = Float.parseFloat(vmDetailCpu.getValue());\n                    ramOvercommitRatio = Float.parseFloat(vmDetailRam.getValue());\n                }\n                ServiceOffering so = offeringsMap.get(vm.getServiceOfferingId());\n                Map<String, String> vmDetails = _userVmDetailsDao.listDetailsKeyPairs(vm.getId());\n                if (so.isDynamic()) {\n                    reservedMemory +=\n                        ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.memory.name())) * 1024L * 1024L) / ramOvercommitRatio) *\n                            clusterRamOvercommitRatio;\n                    if(vmDetails.containsKey(UsageEventVO.DynamicParameters.cpuSpeed.name())) {\n                        reservedCpu +=\n                                ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuSpeed.name()))) / cpuOvercommitRatio) *\n                                        clusterCpuOvercommitRatio;\n                    } else {\n                        reservedCpu +=\n                                ((Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name())) * so.getSpeed()) / cpuOvercommitRatio) *\n                                        clusterCpuOvercommitRatio;\n                    }\n                    reservedCpuCore += Integer.parseInt(vmDetails.get(UsageEventVO.DynamicParameters.cpuNumber.name()));\n                } else {\n                    reservedMemory += ((so.getRamSize() * 1024L * 1024L) / ramOvercommitRatio) * clusterRamOvercommitRatio;\n                    reservedCpu += (so.getCpu() * so.getSpeed() / cpuOvercommitRatio) * clusterCpuOvercommitRatio;\n                    reservedCpuCore += so.getCpu();\n                }\n            } else {\n                \r\n                \r\n                UserVmDetailVO messageSentFlag = _userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.MESSAGE_RESERVED_CAPACITY_FREED_FLAG);\n                if (messageSentFlag == null || !Boolean.valueOf(messageSentFlag.getValue())) {\n                    _messageBus.publish(_name, \"VM_ReservedCapacity_Free\", PublishScope.LOCAL, vm);\n\n                    if (vm.getType() == VirtualMachine.Type.User) {\n                        UserVmVO userVM = _userVMDao.findById(vm.getId());\n                        _userVMDao.loadDetails(userVM);\n                        userVM.setDetail(VmDetailConstants.MESSAGE_RESERVED_CAPACITY_FREED_FLAG, \"true\");\n                        _userVMDao.saveDetails(userVM);\n                    }\n                }\n            }\n        }\n\n        CapacityVO cpuCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_CPU);\n        CapacityVO memCap = _capacityDao.findByHostIdType(host.getId(), Capacity.CAPACITY_TYPE_MEMORY);\n        CapacityVO cpuCoreCap = _capacityDao.findByHostIdType(host.getId(), CapacityVO.CAPACITY_TYPE_CPU_CORE);\n\n        if (cpuCoreCap != null) {\n            long hostTotalCpuCore = host.getCpus().longValue();\n\n            if (cpuCoreCap.getTotalCapacity() != hostTotalCpuCore) {\n                s_logger.debug(\"Calibrate total cpu for host: \" + host.getId() + \" old total CPU:\"\n                        + cpuCoreCap.getTotalCapacity() + \" new total CPU:\" + hostTotalCpuCore);\n                cpuCoreCap.setTotalCapacity(hostTotalCpuCore);\n\n            }\n\n            if (cpuCoreCap.getUsedCapacity() == usedCpuCore && cpuCoreCap.getReservedCapacity() == reservedCpuCore) {\n                s_logger.debug(\"No need to calibrate cpu capacity, host:\" + host.getId() + \" usedCpuCore: \" + cpuCoreCap.getUsedCapacity()\n                        + \" reservedCpuCore: \" + cpuCoreCap.getReservedCapacity());\n            } else {\n                if (cpuCoreCap.getReservedCapacity() != reservedCpuCore) {\n                    s_logger.debug(\"Calibrate reserved cpu core for host: \" + host.getId() + \" old reservedCpuCore:\"\n                            + cpuCoreCap.getReservedCapacity() + \" new reservedCpuCore:\" + reservedCpuCore);\n                    cpuCoreCap.setReservedCapacity(reservedCpuCore);\n                }\n                if (cpuCoreCap.getUsedCapacity() != usedCpuCore) {\n                    s_logger.debug(\"Calibrate used cpu core for host: \" + host.getId() + \" old usedCpuCore:\"\n                            + cpuCoreCap.getUsedCapacity() + \" new usedCpuCore:\" + usedCpuCore);\n                    cpuCoreCap.setUsedCapacity(usedCpuCore);\n                }\n            }\n            try {\n                _capacityDao.update(cpuCoreCap.getId(), cpuCoreCap);\n            } catch (Exception e) {\n                s_logger.error(\"Caught exception while updating cpucore capacity for the host \" +host.getId(), e);\n            }\n        } else {\n            final long usedCpuCoreFinal = usedCpuCore;\n            final long reservedCpuCoreFinal = reservedCpuCore;\n            Transaction.execute(new TransactionCallbackNoReturn() {\n                @Override\n                public void doInTransactionWithoutResult(TransactionStatus status) {\n                    CapacityVO capacity = new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedCpuCoreFinal, host.getCpus().longValue(),\n                            CapacityVO.CAPACITY_TYPE_CPU_CORE);\n                    capacity.setReservedCapacity(reservedCpuCoreFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n                }\n            });\n        }\n\n        if (cpuCap != null && memCap != null) {\n            if (host.getTotalMemory() != null) {\n                memCap.setTotalCapacity(host.getTotalMemory());\n            }\n            long hostTotalCpu = host.getCpus().longValue() * host.getSpeed().longValue();\n\n            if (cpuCap.getTotalCapacity() != hostTotalCpu) {\n                s_logger.debug(\"Calibrate total cpu for host: \" + host.getId() + \" old total CPU:\" + cpuCap.getTotalCapacity() + \" new total CPU:\" + hostTotalCpu);\n                cpuCap.setTotalCapacity(hostTotalCpu);\n\n            }\n            \r\n            if(capacityState != cpuCap.getCapacityState()){\n                s_logger.debug(\"Calibrate cpu capacity state for host: \" + host.getId() + \" old capacity state:\" + cpuCap.getTotalCapacity() + \" new capacity state:\" + hostTotalCpu);\n                cpuCap.setCapacityState(capacityState);\n            }\n            memCap.setCapacityState(capacityState);\n\n            if (cpuCap.getUsedCapacity() == usedCpu && cpuCap.getReservedCapacity() == reservedCpu) {\n                s_logger.debug(\"No need to calibrate cpu capacity, host:\" + host.getId() + \" usedCpu: \" + cpuCap.getUsedCapacity() + \" reservedCpu: \" +\n                    cpuCap.getReservedCapacity());\n            } else {\n                if (cpuCap.getReservedCapacity() != reservedCpu) {\n                    s_logger.debug(\"Calibrate reserved cpu for host: \" + host.getId() + \" old reservedCpu:\" + cpuCap.getReservedCapacity() + \" new reservedCpu:\" +\n                        reservedCpu);\n                    cpuCap.setReservedCapacity(reservedCpu);\n                }\n                if (cpuCap.getUsedCapacity() != usedCpu) {\n                    s_logger.debug(\"Calibrate used cpu for host: \" + host.getId() + \" old usedCpu:\" + cpuCap.getUsedCapacity() + \" new usedCpu:\" + usedCpu);\n                    cpuCap.setUsedCapacity(usedCpu);\n                }\n            }\n\n            if (memCap.getTotalCapacity() != host.getTotalMemory()) {\n                s_logger.debug(\"Calibrate total memory for host: \" + host.getId() + \" old total memory:\" + toHumanReadableSize(memCap.getTotalCapacity()) + \" new total memory:\" +\n                        toHumanReadableSize(host.getTotalMemory()));\n                memCap.setTotalCapacity(host.getTotalMemory());\n\n            }\n            \r\n            if(capacityState != memCap.getCapacityState()){\n                s_logger.debug(\"Calibrate memory capacity state for host: \" + host.getId() + \" old capacity state:\" + memCap.getTotalCapacity() + \" new capacity state:\" + hostTotalCpu);\n                memCap.setCapacityState(capacityState);\n            }\n\n            if (memCap.getUsedCapacity() == usedMemory && memCap.getReservedCapacity() == reservedMemory) {\n                s_logger.debug(\"No need to calibrate memory capacity, host:\" + host.getId() + \" usedMem: \" + toHumanReadableSize(memCap.getUsedCapacity()) + \" reservedMem: \" +\n                        toHumanReadableSize(memCap.getReservedCapacity()));\n            } else {\n                if (memCap.getReservedCapacity() != reservedMemory) {\n                    s_logger.debug(\"Calibrate reserved memory for host: \" + host.getId() + \" old reservedMem:\" + memCap.getReservedCapacity() + \" new reservedMem:\" +\n                        reservedMemory);\n                    memCap.setReservedCapacity(reservedMemory);\n                }\n                if (memCap.getUsedCapacity() != usedMemory) {\n                    \r\n\r\n\r\n\r\n\n                    s_logger.debug(\"Calibrate used memory for host: \" + host.getId() + \" old usedMem: \" + toHumanReadableSize(memCap.getUsedCapacity()) + \" new usedMem: \" + toHumanReadableSize(usedMemory));\n                    memCap.setUsedCapacity(usedMemory);\n                }\n            }\n\n            try {\n                _capacityDao.update(cpuCap.getId(), cpuCap);\n                _capacityDao.update(memCap.getId(), memCap);\n            } catch (Exception e) {\n                s_logger.error(\"Caught exception while updating cpu/memory capacity for the host \" + host.getId(), e);\n            }\n        } else {\n            final long usedMemoryFinal = usedMemory;\n            final long reservedMemoryFinal = reservedMemory;\n            final long usedCpuFinal = usedCpu;\n            final long reservedCpuFinal = reservedCpu;\n            Transaction.execute(new TransactionCallbackNoReturn() {\n                @Override\n                public void doInTransactionWithoutResult(TransactionStatus status) {\n                    CapacityVO capacity =\n                        new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedMemoryFinal, host.getTotalMemory(),\n                            Capacity.CAPACITY_TYPE_MEMORY);\n                    capacity.setReservedCapacity(reservedMemoryFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n\n                    capacity =\n                        new CapacityVO(host.getId(), host.getDataCenterId(), host.getPodId(), host.getClusterId(), usedCpuFinal, host.getCpus().longValue() *\n                            host.getSpeed().longValue(), Capacity.CAPACITY_TYPE_CPU);\n                    capacity.setReservedCapacity(reservedCpuFinal);\n                    capacity.setCapacityState(capacityState);\n                    _capacityDao.persist(capacity);\n                }\n            });\n\n        }\n\n    }\n","realPath":"server/src/main/java/com/cloud/capacity/CapacityManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":625,"status":"M"}],"commitId":"ba127dab3e2ebda5994a4d2982d718e14be91d76","commitMessage":"@@@Merge remote-tracking branch 'origin/4.15'\n\nSigned-off-by: Rohit Yadav <rohit.yadav@shapeblue.com>\n","date":"2021-02-05 18:32:26","modifiedFileCount":"5","status":"M","submitter":"Rohit Yadav"}]
