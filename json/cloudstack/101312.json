[{"authorTime":"2019-01-25 20:05:13","codes":[{"authorDate":"2018-04-10 19:49:07","commitOrder":4,"curCode":"    public Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>> listHostsForMigrationOfVM(final Long vmId, final Long startIndex, final Long pageSize,\n            final String keyword) {\n        final Account caller = getCaller();\n        if (!_accountMgr.isRootAdmin(caller.getId())) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Caller is not a root admin, permission denied to migrate the VM\");\n            }\n            throw new PermissionDeniedException(\"No permission to migrate VM, Only Root Admin can migrate a VM!\");\n        }\n\n        final VMInstanceVO vm = _vmInstanceDao.findById(vmId);\n        if (vm == null) {\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the VM with given id\");\n            throw ex;\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not running, cannot migrate the vm\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"VM is not Running, cannot \" + \"migrate the vm with specified id\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        if (_serviceOfferingDetailsDao.findDetail(vm.getServiceOfferingId(), GPU.Keys.pciDevice.toString()) != null) {\n            s_logger.info(\" Live Migration of GPU enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            \r\n            return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>, Integer>(new ArrayList<HostVO>(), new Integer(0)),\n                    new ArrayList<Host>(), new HashMap<Host, Boolean>());\n        }\n\n        if (!vm.getHypervisorType().equals(HypervisorType.XenServer) && !vm.getHypervisorType().equals(HypervisorType.VMware) && !vm.getHypervisorType().equals(HypervisorType.KVM)\n                && !vm.getHypervisorType().equals(HypervisorType.Ovm) && !vm.getHypervisorType().equals(HypervisorType.Hyperv) && !vm.getHypervisorType().equals(HypervisorType.LXC)\n                && !vm.getHypervisorType().equals(HypervisorType.Simulator) && !vm.getHypervisorType().equals(HypervisorType.Ovm3)) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(vm + \" is not XenServer/VMware/KVM/Ovm/Hyperv/Ovm3, cannot migrate this VM.\");\n            }\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for VM migration, we support \" + \"XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        if (vm.getType().equals(VirtualMachine.Type.User) && vm.getHypervisorType().equals(HypervisorType.LXC)) {\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for User VM migration, we support XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        final long srcHostId = vm.getHostId();\n        final Host srcHost = _hostDao.findById(srcHostId);\n        if (srcHost == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the host with id: \" + srcHostId + \" of this VM:\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the host (with specified id) of VM with specified id\");\n            ex.addProxyObject(String.valueOf(srcHostId), \"hostId\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        \r\n        boolean canMigrateWithStorage = false;\n\n        if (vm.getType() == VirtualMachine.Type.User) {\n            final HypervisorCapabilitiesVO capabilities = _hypervisorCapabilitiesDao.findByHypervisorTypeAndVersion(srcHost.getHypervisorType(), srcHost.getHypervisorVersion());\n            if (capabilities != null) {\n                canMigrateWithStorage = capabilities.isStorageMotionSupported();\n            }\n        }\n\n        \r\n        final VirtualMachineProfile vmProfile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        final List<VolumeVO> volumes = _volumeDao.findCreatedByInstance(vmProfile.getId());\n        boolean usesLocal = false;\n        for (final VolumeVO volume : volumes) {\n            final DiskOfferingVO diskOffering = _diskOfferingDao.findById(volume.getDiskOfferingId());\n            final DiskProfile diskProfile = new DiskProfile(volume, diskOffering, vmProfile.getHypervisorType());\n            if (diskProfile.useLocalStorage()) {\n                usesLocal = true;\n                break;\n            }\n        }\n\n        if (!canMigrateWithStorage && usesLocal) {\n            throw new InvalidParameterValueException(\"Unsupported operation, VM uses Local storage, cannot migrate\");\n        }\n\n        final Type hostType = srcHost.getType();\n        Pair<List<HostVO>, Integer> allHostsPair = null;\n        List<HostVO> allHosts = null;\n        final Map<Host, Boolean> requiresStorageMotion = new HashMap<Host, Boolean>();\n        DataCenterDeployment plan = null;\n        if (canMigrateWithStorage) {\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, srcHost.getDataCenterId(), null, null, null, keyword, null, null, srcHost.getHypervisorType(),\n                    srcHost.getHypervisorVersion());\n            allHosts = allHostsPair.first();\n            allHosts.remove(srcHost);\n\n            for (final VolumeVO volume : volumes) {\n                StoragePool storagePool = _poolDao.findById(volume.getPoolId());\n                Long volClusterId = storagePool.getClusterId();\n\n                for (Iterator<HostVO> iterator = allHosts.iterator(); iterator.hasNext();) {\n                    final Host host = iterator.next();\n\n                    if (volClusterId != null) {\n                        if (storagePool.isLocal() || !host.getClusterId().equals(volClusterId) || usesLocal) {\n                            if (storagePool.isManaged()) {\n                                \r\n                                \r\n                                \r\n                                \r\n                                \r\n                                iterator.remove();\n                            } else {\n                                if (hasSuitablePoolsForVolume(volume, host, vmProfile)) {\n                                    requiresStorageMotion.put(host, true);\n                                } else {\n                                    iterator.remove();\n                                }\n                            }\n                        }\n                    } else {\n                        if (storagePool.isManaged()) {\n                            if (srcHost.getClusterId() != host.getClusterId()) {\n                                \r\n                                \r\n                                \r\n                                requiresStorageMotion.put(host, true);\n                            }\n                        }\n                    }\n                }\n            }\n\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), null, null, null, null, null);\n        } else {\n            final Long cluster = srcHost.getClusterId();\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Searching for all hosts in cluster \" + cluster + \" for migrating VM \" + vm);\n            }\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, null, null, cluster, null, keyword, null, null, null, null);\n            \r\n            allHosts = allHostsPair.first();\n            allHosts.remove(srcHost);\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), srcHost.getPodId(), srcHost.getClusterId(), null, null, null);\n        }\n\n        final Pair<List<? extends Host>, Integer> otherHosts = new Pair<List<? extends Host>, Integer>(allHosts, new Integer(allHosts.size()));\n        List<Host> suitableHosts = new ArrayList<Host>();\n        final ExcludeList excludes = new ExcludeList();\n        excludes.addHost(srcHostId);\n\n        \r\n        final long vmGroupCount = _affinityGroupVMMapDao.countAffinityGroupsForVm(vm.getId());\n\n        if (vmGroupCount > 0) {\n            for (final AffinityGroupProcessor processor : _affinityProcessors) {\n                processor.process(vmProfile, plan, excludes);\n            }\n        }\n\n        for (final HostAllocator allocator : hostAllocators) {\n            if (canMigrateWithStorage) {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, allHosts, HostAllocator.RETURN_UPTO_ALL, false);\n            } else {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, HostAllocator.RETURN_UPTO_ALL, false);\n            }\n\n            if (suitableHosts != null && !suitableHosts.isEmpty()) {\n                break;\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            if (suitableHosts.isEmpty()) {\n                s_logger.debug(\"No suitable hosts found\");\n            } else {\n                s_logger.debug(\"Hosts having capacity and suitable for migration: \" + suitableHosts);\n            }\n        }\n\n        return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(otherHosts, suitableHosts, requiresStorageMotion);\n    }\n","date":"2018-04-10 19:49:07","endLine":1304,"groupId":"20252","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"listHostsForMigrationOfVM","params":"(finalLongvmId@finalLongstartIndex@finalLongpageSize@finalStringkeyword)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/3c/ed3d603cca28f7bc905a05a4a6d8eedf9b677b.src","preCode":"    public Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>> listHostsForMigrationOfVM(final Long vmId, final Long startIndex, final Long pageSize,\n            final String keyword) {\n        final Account caller = getCaller();\n        if (!_accountMgr.isRootAdmin(caller.getId())) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Caller is not a root admin, permission denied to migrate the VM\");\n            }\n            throw new PermissionDeniedException(\"No permission to migrate VM, Only Root Admin can migrate a VM!\");\n        }\n\n        final VMInstanceVO vm = _vmInstanceDao.findById(vmId);\n        if (vm == null) {\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the VM with given id\");\n            throw ex;\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not running, cannot migrate the vm\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"VM is not Running, cannot \" + \"migrate the vm with specified id\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        if (_serviceOfferingDetailsDao.findDetail(vm.getServiceOfferingId(), GPU.Keys.pciDevice.toString()) != null) {\n            s_logger.info(\" Live Migration of GPU enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            \r\n            return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>, Integer>(new ArrayList<HostVO>(), new Integer(0)),\n                    new ArrayList<Host>(), new HashMap<Host, Boolean>());\n        }\n\n        if (!vm.getHypervisorType().equals(HypervisorType.XenServer) && !vm.getHypervisorType().equals(HypervisorType.VMware) && !vm.getHypervisorType().equals(HypervisorType.KVM)\n                && !vm.getHypervisorType().equals(HypervisorType.Ovm) && !vm.getHypervisorType().equals(HypervisorType.Hyperv) && !vm.getHypervisorType().equals(HypervisorType.LXC)\n                && !vm.getHypervisorType().equals(HypervisorType.Simulator) && !vm.getHypervisorType().equals(HypervisorType.Ovm3)) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(vm + \" is not XenServer/VMware/KVM/Ovm/Hyperv/Ovm3, cannot migrate this VM.\");\n            }\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for VM migration, we support \" + \"XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        if (vm.getType().equals(VirtualMachine.Type.User) && vm.getHypervisorType().equals(HypervisorType.LXC)) {\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for User VM migration, we support XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        final long srcHostId = vm.getHostId();\n        final Host srcHost = _hostDao.findById(srcHostId);\n        if (srcHost == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the host with id: \" + srcHostId + \" of this VM:\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the host (with specified id) of VM with specified id\");\n            ex.addProxyObject(String.valueOf(srcHostId), \"hostId\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        \r\n        boolean canMigrateWithStorage = false;\n\n        if (vm.getType() == VirtualMachine.Type.User) {\n            final HypervisorCapabilitiesVO capabilities = _hypervisorCapabilitiesDao.findByHypervisorTypeAndVersion(srcHost.getHypervisorType(), srcHost.getHypervisorVersion());\n            if (capabilities != null) {\n                canMigrateWithStorage = capabilities.isStorageMotionSupported();\n            }\n        }\n\n        \r\n        final VirtualMachineProfile vmProfile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        final List<VolumeVO> volumes = _volumeDao.findCreatedByInstance(vmProfile.getId());\n        boolean usesLocal = false;\n        for (final VolumeVO volume : volumes) {\n            final DiskOfferingVO diskOffering = _diskOfferingDao.findById(volume.getDiskOfferingId());\n            final DiskProfile diskProfile = new DiskProfile(volume, diskOffering, vmProfile.getHypervisorType());\n            if (diskProfile.useLocalStorage()) {\n                usesLocal = true;\n                break;\n            }\n        }\n\n        if (!canMigrateWithStorage && usesLocal) {\n            throw new InvalidParameterValueException(\"Unsupported operation, VM uses Local storage, cannot migrate\");\n        }\n\n        final Type hostType = srcHost.getType();\n        Pair<List<HostVO>, Integer> allHostsPair = null;\n        List<HostVO> allHosts = null;\n        final Map<Host, Boolean> requiresStorageMotion = new HashMap<Host, Boolean>();\n        DataCenterDeployment plan = null;\n        if (canMigrateWithStorage) {\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, srcHost.getDataCenterId(), null, null, null, keyword, null, null, srcHost.getHypervisorType(),\n                    srcHost.getHypervisorVersion());\n            allHosts = allHostsPair.first();\n            allHosts.remove(srcHost);\n\n            for (final VolumeVO volume : volumes) {\n                StoragePool storagePool = _poolDao.findById(volume.getPoolId());\n                Long volClusterId = storagePool.getClusterId();\n\n                for (Iterator<HostVO> iterator = allHosts.iterator(); iterator.hasNext();) {\n                    final Host host = iterator.next();\n\n                    if (volClusterId != null) {\n                        if (storagePool.isLocal() || !host.getClusterId().equals(volClusterId) || usesLocal) {\n                            if (storagePool.isManaged()) {\n                                \r\n                                \r\n                                \r\n                                \r\n                                \r\n                                iterator.remove();\n                            } else {\n                                if (hasSuitablePoolsForVolume(volume, host, vmProfile)) {\n                                    requiresStorageMotion.put(host, true);\n                                } else {\n                                    iterator.remove();\n                                }\n                            }\n                        }\n                    } else {\n                        if (storagePool.isManaged()) {\n                            if (srcHost.getClusterId() != host.getClusterId()) {\n                                \r\n                                \r\n                                \r\n                                requiresStorageMotion.put(host, true);\n                            }\n                        }\n                    }\n                }\n            }\n\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), null, null, null, null, null);\n        } else {\n            final Long cluster = srcHost.getClusterId();\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Searching for all hosts in cluster \" + cluster + \" for migrating VM \" + vm);\n            }\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, null, null, cluster, null, keyword, null, null, null, null);\n            \r\n            allHosts = allHostsPair.first();\n            allHosts.remove(srcHost);\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), srcHost.getPodId(), srcHost.getClusterId(), null, null, null);\n        }\n\n        final Pair<List<? extends Host>, Integer> otherHosts = new Pair<List<? extends Host>, Integer>(allHosts, new Integer(allHosts.size()));\n        List<Host> suitableHosts = new ArrayList<Host>();\n        final ExcludeList excludes = new ExcludeList();\n        excludes.addHost(srcHostId);\n\n        \r\n        final long vmGroupCount = _affinityGroupVMMapDao.countAffinityGroupsForVm(vm.getId());\n\n        if (vmGroupCount > 0) {\n            for (final AffinityGroupProcessor processor : _affinityProcessors) {\n                processor.process(vmProfile, plan, excludes);\n            }\n        }\n\n        for (final HostAllocator allocator : hostAllocators) {\n            if (canMigrateWithStorage) {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, allHosts, HostAllocator.RETURN_UPTO_ALL, false);\n            } else {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, HostAllocator.RETURN_UPTO_ALL, false);\n            }\n\n            if (suitableHosts != null && !suitableHosts.isEmpty()) {\n                break;\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            if (suitableHosts.isEmpty()) {\n                s_logger.debug(\"No suitable hosts found\");\n            } else {\n                s_logger.debug(\"Hosts having capacity and suitable for migration: \" + suitableHosts);\n            }\n        }\n\n        return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(otherHosts, suitableHosts, requiresStorageMotion);\n    }\n","realPath":"server/src/main/java/com/cloud/server/ManagementServerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1124,"status":"NB"},{"authorDate":"2019-01-25 20:05:13","commitOrder":4,"curCode":"    private boolean isOnSupportedHypevisorForMigration(VMInstanceVO vm) {\n        return (vm.getHypervisorType().equals(HypervisorType.XenServer) ||\n                vm.getHypervisorType().equals(HypervisorType.VMware) ||\n                vm.getHypervisorType().equals(HypervisorType.KVM) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm) ||\n                vm.getHypervisorType().equals(HypervisorType.Hyperv) ||\n                vm.getHypervisorType().equals(HypervisorType.LXC) ||\n                vm.getHypervisorType().equals(HypervisorType.Simulator) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm3));\n    }\n","date":"2019-01-25 20:05:13","endLine":5248,"groupId":"13593","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"isOnSupportedHypevisorForMigration","params":"(VMInstanceVOvm)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/68/b45e1af7c3b5c442bc0dc09dec1aeb5256a58d.src","preCode":"    private boolean isOnSupportedHypevisorForMigration(VMInstanceVO vm) {\n        return (vm.getHypervisorType().equals(HypervisorType.XenServer) ||\n                vm.getHypervisorType().equals(HypervisorType.VMware) ||\n                vm.getHypervisorType().equals(HypervisorType.KVM) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm) ||\n                vm.getHypervisorType().equals(HypervisorType.Hyperv) ||\n                vm.getHypervisorType().equals(HypervisorType.LXC) ||\n                vm.getHypervisorType().equals(HypervisorType.Simulator) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm3));\n    }\n","realPath":"server/src/main/java/com/cloud/vm/UserVmManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":5239,"status":"B"}],"commitId":"b363fd49f70ac2092ebe6226a72a3d911dc99e1f","commitMessage":"@@@Vmware offline migration (#2848)\n\n* - Offline VM and Volume migration on Vmware hypervisor hosts\n- Also add VM disk consolidation call on successful VM migrations\n\n* Fix indentation of marvin test file and reformat against PEP8\n\n* * Fix few comment typos\n* Refactor debug messages to use String.format() when debug log level is enabled.\n\n* Send list of commands returned by hypervisor Guru instead of explicitly selecting the first one\n\n* Fix unhandled NPE during VM migration\n\n* Revert back to distinct event descriptions for VM to host or storage pool migration\n\n* Reformat test_primary_storage file against PEP-8 and Remove unused imports\n\n* Revert back the deprecation messages in the custom StringUtils class to favour the use of the ApacheUtils\n","date":"2019-01-25 20:05:13","modifiedFileCount":"35","status":"M","submitter":"dahn"},{"authorTime":"2019-01-25 20:05:13","codes":[{"authorDate":"2019-06-25 23:23:09","commitOrder":5,"curCode":"    public Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>> listHostsForMigrationOfVM(final Long vmId, final Long startIndex, final Long pageSize,\n            final String keyword) {\n        final Account caller = getCaller();\n        if (!_accountMgr.isRootAdmin(caller.getId())) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Caller is not a root admin, permission denied to migrate the VM\");\n            }\n            throw new PermissionDeniedException(\"No permission to migrate VM, Only Root Admin can migrate a VM!\");\n        }\n\n        final VMInstanceVO vm = _vmInstanceDao.findById(vmId);\n        if (vm == null) {\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the VM with given id\");\n            throw ex;\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not running, cannot migrate the vm\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"VM is not Running, cannot \" + \"migrate the vm with specified id\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        if (_serviceOfferingDetailsDao.findDetail(vm.getServiceOfferingId(), GPU.Keys.pciDevice.toString()) != null) {\n            s_logger.info(\" Live Migration of GPU enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            \r\n            return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>, Integer>(new ArrayList<HostVO>(), new Integer(0)),\n                    new ArrayList<Host>(), new HashMap<Host, Boolean>());\n        }\n\n        if (!vm.getHypervisorType().equals(HypervisorType.XenServer) && !vm.getHypervisorType().equals(HypervisorType.VMware) && !vm.getHypervisorType().equals(HypervisorType.KVM)\n                && !vm.getHypervisorType().equals(HypervisorType.Ovm) && !vm.getHypervisorType().equals(HypervisorType.Hyperv) && !vm.getHypervisorType().equals(HypervisorType.LXC)\n                && !vm.getHypervisorType().equals(HypervisorType.Simulator) && !vm.getHypervisorType().equals(HypervisorType.Ovm3)) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(vm + \" is not XenServer/VMware/KVM/Ovm/Hyperv/Ovm3, cannot migrate this VM.\");\n            }\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for VM migration, we support \" + \"XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        if (vm.getType().equals(VirtualMachine.Type.User) && vm.getHypervisorType().equals(HypervisorType.LXC)) {\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for User VM migration, we support XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        final long srcHostId = vm.getHostId();\n        final Host srcHost = _hostDao.findById(srcHostId);\n        if (srcHost == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the host with id: \" + srcHostId + \" of this VM:\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the host (with specified id) of VM with specified id\");\n            ex.addProxyObject(String.valueOf(srcHostId), \"hostId\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        \r\n        boolean canMigrateWithStorage = false;\n\n        if (vm.getType() == VirtualMachine.Type.User) {\n            final HypervisorCapabilitiesVO capabilities = _hypervisorCapabilitiesDao.findByHypervisorTypeAndVersion(srcHost.getHypervisorType(), srcHost.getHypervisorVersion());\n            if (capabilities != null) {\n                canMigrateWithStorage = capabilities.isStorageMotionSupported();\n            }\n        }\n\n        \r\n        final VirtualMachineProfile vmProfile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        final List<VolumeVO> volumes = _volumeDao.findCreatedByInstance(vmProfile.getId());\n        boolean usesLocal = false;\n        for (final VolumeVO volume : volumes) {\n            final DiskOfferingVO diskOffering = _diskOfferingDao.findById(volume.getDiskOfferingId());\n            final DiskProfile diskProfile = new DiskProfile(volume, diskOffering, vmProfile.getHypervisorType());\n            if (diskProfile.useLocalStorage()) {\n                usesLocal = true;\n                break;\n            }\n        }\n\n        if (!canMigrateWithStorage && usesLocal) {\n            throw new InvalidParameterValueException(\"Unsupported operation, VM uses Local storage, cannot migrate\");\n        }\n\n        final Type hostType = srcHost.getType();\n        Pair<List<HostVO>, Integer> allHostsPair = null;\n        List<HostVO> allHosts = null;\n        final Map<Host, Boolean> requiresStorageMotion = new HashMap<Host, Boolean>();\n        DataCenterDeployment plan = null;\n        if (canMigrateWithStorage) {\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, srcHost.getDataCenterId(), null, null, null, keyword, null, null, srcHost.getHypervisorType(),\n                    srcHost.getHypervisorVersion());\n            allHosts = allHostsPair.first();\n            allHosts.remove(srcHost);\n\n            for (final VolumeVO volume : volumes) {\n                StoragePool storagePool = _poolDao.findById(volume.getPoolId());\n                Long volClusterId = storagePool.getClusterId();\n\n                for (Iterator<HostVO> iterator = allHosts.iterator(); iterator.hasNext();) {\n                    final Host host = iterator.next();\n\n                    if (volClusterId != null) {\n                        if (storagePool.isLocal() || !host.getClusterId().equals(volClusterId) || usesLocal) {\n                            if (storagePool.isManaged()) {\n                                \r\n                                \r\n                                \r\n                                \r\n                                \r\n                                iterator.remove();\n                            } else {\n                                if (hasSuitablePoolsForVolume(volume, host, vmProfile)) {\n                                    requiresStorageMotion.put(host, true);\n                                } else {\n                                    iterator.remove();\n                                }\n                            }\n                        }\n                    } else {\n                        if (storagePool.isManaged()) {\n                            if (srcHost.getClusterId() != host.getClusterId()) {\n                                \r\n                                \r\n                                \r\n                                requiresStorageMotion.put(host, true);\n                            }\n                        }\n                    }\n                }\n            }\n\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), null, null, null, null, null);\n        } else {\n            final Long cluster = srcHost.getClusterId();\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Searching for all hosts in cluster \" + cluster + \" for migrating VM \" + vm);\n            }\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, null, null, cluster, null, keyword, null, null, null, null);\n            \r\n            allHosts = allHostsPair.first();\n            allHosts.remove(srcHost);\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), srcHost.getPodId(), srcHost.getClusterId(), null, null, null);\n        }\n\n        final Pair<List<? extends Host>, Integer> otherHosts = new Pair<List<? extends Host>, Integer>(allHosts, new Integer(allHosts.size()));\n        List<Host> suitableHosts = new ArrayList<Host>();\n        final ExcludeList excludes = new ExcludeList();\n        excludes.addHost(srcHostId);\n\n        if (dpdkHelper.isVMDpdkEnabled(vm.getId())) {\n            excludeNonDPDKEnabledHosts(plan, excludes);\n        }\n\n        \r\n        final long vmGroupCount = _affinityGroupVMMapDao.countAffinityGroupsForVm(vm.getId());\n\n        if (vmGroupCount > 0) {\n            for (final AffinityGroupProcessor processor : _affinityProcessors) {\n                processor.process(vmProfile, plan, excludes);\n            }\n        }\n\n        for (final HostAllocator allocator : hostAllocators) {\n            if (canMigrateWithStorage) {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, allHosts, HostAllocator.RETURN_UPTO_ALL, false);\n            } else {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, HostAllocator.RETURN_UPTO_ALL, false);\n            }\n\n            if (suitableHosts != null && !suitableHosts.isEmpty()) {\n                break;\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            if (suitableHosts.isEmpty()) {\n                s_logger.debug(\"No suitable hosts found\");\n            } else {\n                s_logger.debug(\"Hosts having capacity and suitable for migration: \" + suitableHosts);\n            }\n        }\n\n        return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(otherHosts, suitableHosts, requiresStorageMotion);\n    }\n","date":"2019-06-25 23:23:09","endLine":1342,"groupId":"20252","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"listHostsForMigrationOfVM","params":"(finalLongvmId@finalLongstartIndex@finalLongpageSize@finalStringkeyword)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/2c/3e71543e3ebb9494406cc1acdc326aed481f2b.src","preCode":"    public Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>> listHostsForMigrationOfVM(final Long vmId, final Long startIndex, final Long pageSize,\n            final String keyword) {\n        final Account caller = getCaller();\n        if (!_accountMgr.isRootAdmin(caller.getId())) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Caller is not a root admin, permission denied to migrate the VM\");\n            }\n            throw new PermissionDeniedException(\"No permission to migrate VM, Only Root Admin can migrate a VM!\");\n        }\n\n        final VMInstanceVO vm = _vmInstanceDao.findById(vmId);\n        if (vm == null) {\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the VM with given id\");\n            throw ex;\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not running, cannot migrate the vm\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"VM is not Running, cannot \" + \"migrate the vm with specified id\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        if (_serviceOfferingDetailsDao.findDetail(vm.getServiceOfferingId(), GPU.Keys.pciDevice.toString()) != null) {\n            s_logger.info(\" Live Migration of GPU enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            \r\n            return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>, Integer>(new ArrayList<HostVO>(), new Integer(0)),\n                    new ArrayList<Host>(), new HashMap<Host, Boolean>());\n        }\n\n        if (!vm.getHypervisorType().equals(HypervisorType.XenServer) && !vm.getHypervisorType().equals(HypervisorType.VMware) && !vm.getHypervisorType().equals(HypervisorType.KVM)\n                && !vm.getHypervisorType().equals(HypervisorType.Ovm) && !vm.getHypervisorType().equals(HypervisorType.Hyperv) && !vm.getHypervisorType().equals(HypervisorType.LXC)\n                && !vm.getHypervisorType().equals(HypervisorType.Simulator) && !vm.getHypervisorType().equals(HypervisorType.Ovm3)) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(vm + \" is not XenServer/VMware/KVM/Ovm/Hyperv/Ovm3, cannot migrate this VM.\");\n            }\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for VM migration, we support \" + \"XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        if (vm.getType().equals(VirtualMachine.Type.User) && vm.getHypervisorType().equals(HypervisorType.LXC)) {\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for User VM migration, we support XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        final long srcHostId = vm.getHostId();\n        final Host srcHost = _hostDao.findById(srcHostId);\n        if (srcHost == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the host with id: \" + srcHostId + \" of this VM:\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the host (with specified id) of VM with specified id\");\n            ex.addProxyObject(String.valueOf(srcHostId), \"hostId\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        \r\n        boolean canMigrateWithStorage = false;\n\n        if (vm.getType() == VirtualMachine.Type.User) {\n            final HypervisorCapabilitiesVO capabilities = _hypervisorCapabilitiesDao.findByHypervisorTypeAndVersion(srcHost.getHypervisorType(), srcHost.getHypervisorVersion());\n            if (capabilities != null) {\n                canMigrateWithStorage = capabilities.isStorageMotionSupported();\n            }\n        }\n\n        \r\n        final VirtualMachineProfile vmProfile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        final List<VolumeVO> volumes = _volumeDao.findCreatedByInstance(vmProfile.getId());\n        boolean usesLocal = false;\n        for (final VolumeVO volume : volumes) {\n            final DiskOfferingVO diskOffering = _diskOfferingDao.findById(volume.getDiskOfferingId());\n            final DiskProfile diskProfile = new DiskProfile(volume, diskOffering, vmProfile.getHypervisorType());\n            if (diskProfile.useLocalStorage()) {\n                usesLocal = true;\n                break;\n            }\n        }\n\n        if (!canMigrateWithStorage && usesLocal) {\n            throw new InvalidParameterValueException(\"Unsupported operation, VM uses Local storage, cannot migrate\");\n        }\n\n        final Type hostType = srcHost.getType();\n        Pair<List<HostVO>, Integer> allHostsPair = null;\n        List<HostVO> allHosts = null;\n        final Map<Host, Boolean> requiresStorageMotion = new HashMap<Host, Boolean>();\n        DataCenterDeployment plan = null;\n        if (canMigrateWithStorage) {\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, srcHost.getDataCenterId(), null, null, null, keyword, null, null, srcHost.getHypervisorType(),\n                    srcHost.getHypervisorVersion());\n            allHosts = allHostsPair.first();\n            allHosts.remove(srcHost);\n\n            for (final VolumeVO volume : volumes) {\n                StoragePool storagePool = _poolDao.findById(volume.getPoolId());\n                Long volClusterId = storagePool.getClusterId();\n\n                for (Iterator<HostVO> iterator = allHosts.iterator(); iterator.hasNext();) {\n                    final Host host = iterator.next();\n\n                    if (volClusterId != null) {\n                        if (storagePool.isLocal() || !host.getClusterId().equals(volClusterId) || usesLocal) {\n                            if (storagePool.isManaged()) {\n                                \r\n                                \r\n                                \r\n                                \r\n                                \r\n                                iterator.remove();\n                            } else {\n                                if (hasSuitablePoolsForVolume(volume, host, vmProfile)) {\n                                    requiresStorageMotion.put(host, true);\n                                } else {\n                                    iterator.remove();\n                                }\n                            }\n                        }\n                    } else {\n                        if (storagePool.isManaged()) {\n                            if (srcHost.getClusterId() != host.getClusterId()) {\n                                \r\n                                \r\n                                \r\n                                requiresStorageMotion.put(host, true);\n                            }\n                        }\n                    }\n                }\n            }\n\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), null, null, null, null, null);\n        } else {\n            final Long cluster = srcHost.getClusterId();\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Searching for all hosts in cluster \" + cluster + \" for migrating VM \" + vm);\n            }\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, null, null, cluster, null, keyword, null, null, null, null);\n            \r\n            allHosts = allHostsPair.first();\n            allHosts.remove(srcHost);\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), srcHost.getPodId(), srcHost.getClusterId(), null, null, null);\n        }\n\n        final Pair<List<? extends Host>, Integer> otherHosts = new Pair<List<? extends Host>, Integer>(allHosts, new Integer(allHosts.size()));\n        List<Host> suitableHosts = new ArrayList<Host>();\n        final ExcludeList excludes = new ExcludeList();\n        excludes.addHost(srcHostId);\n\n        \r\n        final long vmGroupCount = _affinityGroupVMMapDao.countAffinityGroupsForVm(vm.getId());\n\n        if (vmGroupCount > 0) {\n            for (final AffinityGroupProcessor processor : _affinityProcessors) {\n                processor.process(vmProfile, plan, excludes);\n            }\n        }\n\n        for (final HostAllocator allocator : hostAllocators) {\n            if (canMigrateWithStorage) {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, allHosts, HostAllocator.RETURN_UPTO_ALL, false);\n            } else {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, HostAllocator.RETURN_UPTO_ALL, false);\n            }\n\n            if (suitableHosts != null && !suitableHosts.isEmpty()) {\n                break;\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            if (suitableHosts.isEmpty()) {\n                s_logger.debug(\"No suitable hosts found\");\n            } else {\n                s_logger.debug(\"Hosts having capacity and suitable for migration: \" + suitableHosts);\n            }\n        }\n\n        return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(otherHosts, suitableHosts, requiresStorageMotion);\n    }\n","realPath":"server/src/main/java/com/cloud/server/ManagementServerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1158,"status":"M"},{"authorDate":"2019-01-25 20:05:13","commitOrder":5,"curCode":"    private boolean isOnSupportedHypevisorForMigration(VMInstanceVO vm) {\n        return (vm.getHypervisorType().equals(HypervisorType.XenServer) ||\n                vm.getHypervisorType().equals(HypervisorType.VMware) ||\n                vm.getHypervisorType().equals(HypervisorType.KVM) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm) ||\n                vm.getHypervisorType().equals(HypervisorType.Hyperv) ||\n                vm.getHypervisorType().equals(HypervisorType.LXC) ||\n                vm.getHypervisorType().equals(HypervisorType.Simulator) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm3));\n    }\n","date":"2019-01-25 20:05:13","endLine":5248,"groupId":"13593","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"isOnSupportedHypevisorForMigration","params":"(VMInstanceVOvm)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/68/b45e1af7c3b5c442bc0dc09dec1aeb5256a58d.src","preCode":"    private boolean isOnSupportedHypevisorForMigration(VMInstanceVO vm) {\n        return (vm.getHypervisorType().equals(HypervisorType.XenServer) ||\n                vm.getHypervisorType().equals(HypervisorType.VMware) ||\n                vm.getHypervisorType().equals(HypervisorType.KVM) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm) ||\n                vm.getHypervisorType().equals(HypervisorType.Hyperv) ||\n                vm.getHypervisorType().equals(HypervisorType.LXC) ||\n                vm.getHypervisorType().equals(HypervisorType.Simulator) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm3));\n    }\n","realPath":"server/src/main/java/com/cloud/vm/UserVmManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":5239,"status":"N"}],"commitId":"a75444a585b952aeb3e984430238cae9e6be4dc5","commitMessage":"@@@KVM: DPDK live migrations (#3365)\n\n* DPDK live migrations\n\n* Remove DPDK created ports if VM migration fails or prepare migration fails\n\n* Rename DPDK classes lowercase\n","date":"2019-06-25 23:23:09","modifiedFileCount":"19","status":"M","submitter":"Nicolas Vazquez"},{"authorTime":"2019-01-25 20:05:13","codes":[{"authorDate":"2020-02-26 23:18:41","commitOrder":6,"curCode":"    public Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>> listHostsForMigrationOfVM(final Long vmId, final Long startIndex, final Long pageSize,\n            final String keyword) {\n        final Account caller = getCaller();\n        if (!_accountMgr.isRootAdmin(caller.getId())) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Caller is not a root admin, permission denied to migrate the VM\");\n            }\n            throw new PermissionDeniedException(\"No permission to migrate VM, Only Root Admin can migrate a VM!\");\n        }\n\n        final VMInstanceVO vm = _vmInstanceDao.findById(vmId);\n        if (vm == null) {\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the VM with given id\");\n            throw ex;\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not running, cannot migrate the vm\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"VM is not Running, cannot \" + \"migrate the vm with specified id\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        if (_serviceOfferingDetailsDao.findDetail(vm.getServiceOfferingId(), GPU.Keys.pciDevice.toString()) != null) {\n            s_logger.info(\" Live Migration of GPU enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            \r\n            return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>, Integer>(new ArrayList<HostVO>(), new Integer(0)),\n                    new ArrayList<Host>(), new HashMap<Host, Boolean>());\n        }\n\n        if (!vm.getHypervisorType().equals(HypervisorType.XenServer) && !vm.getHypervisorType().equals(HypervisorType.VMware) && !vm.getHypervisorType().equals(HypervisorType.KVM)\n                && !vm.getHypervisorType().equals(HypervisorType.Ovm) && !vm.getHypervisorType().equals(HypervisorType.Hyperv) && !vm.getHypervisorType().equals(HypervisorType.LXC)\n                && !vm.getHypervisorType().equals(HypervisorType.Simulator) && !vm.getHypervisorType().equals(HypervisorType.Ovm3)) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(vm + \" is not XenServer/VMware/KVM/Ovm/Hyperv/Ovm3, cannot migrate this VM.\");\n            }\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for VM migration, we support \" + \"XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        if (vm.getType().equals(VirtualMachine.Type.User) && vm.getHypervisorType().equals(HypervisorType.LXC)) {\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for User VM migration, we support XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        final long srcHostId = vm.getHostId();\n        final Host srcHost = _hostDao.findById(srcHostId);\n        if (srcHost == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the host with id: \" + srcHostId + \" of this VM:\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the host (with specified id) of VM with specified id\");\n            ex.addProxyObject(String.valueOf(srcHostId), \"hostId\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        \r\n        boolean canMigrateWithStorage = false;\n\n        if (vm.getType() == VirtualMachine.Type.User) {\n            final HypervisorCapabilitiesVO capabilities = _hypervisorCapabilitiesDao.findByHypervisorTypeAndVersion(srcHost.getHypervisorType(), srcHost.getHypervisorVersion());\n            if (capabilities != null) {\n                canMigrateWithStorage = capabilities.isStorageMotionSupported();\n            }\n        }\n\n        \r\n        final VirtualMachineProfile vmProfile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        final List<VolumeVO> volumes = _volumeDao.findCreatedByInstance(vmProfile.getId());\n        boolean usesLocal = false;\n        for (final VolumeVO volume : volumes) {\n            final DiskOfferingVO diskOffering = _diskOfferingDao.findById(volume.getDiskOfferingId());\n            final DiskProfile diskProfile = new DiskProfile(volume, diskOffering, vmProfile.getHypervisorType());\n            if (diskProfile.useLocalStorage()) {\n                usesLocal = true;\n                break;\n            }\n        }\n\n        if (!canMigrateWithStorage && usesLocal) {\n            throw new InvalidParameterValueException(\"Unsupported operation, VM uses Local storage, cannot migrate\");\n        }\n\n        final Type hostType = srcHost.getType();\n        Pair<List<HostVO>, Integer> allHostsPair = null;\n        List<HostVO> allHosts = null;\n        final Map<Host, Boolean> requiresStorageMotion = new HashMap<Host, Boolean>();\n        DataCenterDeployment plan = null;\n        if (canMigrateWithStorage) {\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, srcHost.getDataCenterId(), null, null, null, keyword, null, null, srcHost.getHypervisorType(),\n                    srcHost.getHypervisorVersion());\n            allHosts = allHostsPair.first();\n            allHosts.remove(srcHost);\n\n            for (final VolumeVO volume : volumes) {\n                StoragePool storagePool = _poolDao.findById(volume.getPoolId());\n                Long volClusterId = storagePool.getClusterId();\n\n                for (Iterator<HostVO> iterator = allHosts.iterator(); iterator.hasNext();) {\n                    final Host host = iterator.next();\n\n                    if (volClusterId != null) {\n                        if (storagePool.isLocal() || !host.getClusterId().equals(volClusterId) || usesLocal) {\n                            if (storagePool.isManaged()) {\n                                \r\n                                \r\n                                \r\n                                \r\n                                \r\n                                iterator.remove();\n                            } else {\n                                if (hasSuitablePoolsForVolume(volume, host, vmProfile)) {\n                                    requiresStorageMotion.put(host, true);\n                                } else {\n                                    iterator.remove();\n                                }\n                            }\n                        }\n                    } else {\n                        if (storagePool.isManaged()) {\n                            if (srcHost.getClusterId() != host.getClusterId()) {\n                                \r\n                                \r\n                                \r\n                                requiresStorageMotion.put(host, true);\n                            }\n                        }\n                    }\n                }\n            }\n\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), null, null, null, null, null);\n        } else {\n            final Long cluster = srcHost.getClusterId();\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Searching for all hosts in cluster \" + cluster + \" for migrating VM \" + vm);\n            }\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, null, null, cluster, null, keyword, null, null, null, null);\n            \r\n            allHosts = allHostsPair.first();\n            allHosts.remove(srcHost);\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), srcHost.getPodId(), srcHost.getClusterId(), null, null, null);\n        }\n\n        final Pair<List<? extends Host>, Integer> otherHosts = new Pair<List<? extends Host>, Integer>(allHosts, allHostsPair.second());\n        List<Host> suitableHosts = new ArrayList<Host>();\n        final ExcludeList excludes = new ExcludeList();\n        excludes.addHost(srcHostId);\n\n        if (dpdkHelper.isVMDpdkEnabled(vm.getId())) {\n            excludeNonDPDKEnabledHosts(plan, excludes);\n        }\n\n        \r\n        final long vmGroupCount = _affinityGroupVMMapDao.countAffinityGroupsForVm(vm.getId());\n\n        if (vmGroupCount > 0) {\n            for (final AffinityGroupProcessor processor : _affinityProcessors) {\n                processor.process(vmProfile, plan, excludes);\n            }\n        }\n\n        for (final HostAllocator allocator : hostAllocators) {\n            if (canMigrateWithStorage) {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, allHosts, HostAllocator.RETURN_UPTO_ALL, false);\n            } else {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, HostAllocator.RETURN_UPTO_ALL, false);\n            }\n\n            if (suitableHosts != null && !suitableHosts.isEmpty()) {\n                break;\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            if (suitableHosts.isEmpty()) {\n                s_logger.debug(\"No suitable hosts found\");\n            } else {\n                s_logger.debug(\"Hosts having capacity and suitable for migration: \" + suitableHosts);\n            }\n        }\n\n        return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(otherHosts, suitableHosts, requiresStorageMotion);\n    }\n","date":"2020-02-26 23:18:41","endLine":1352,"groupId":"20252","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"listHostsForMigrationOfVM","params":"(finalLongvmId@finalLongstartIndex@finalLongpageSize@finalStringkeyword)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/6b/f4ce3d670d852da5d1749b709af7e117802eda.src","preCode":"    public Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>> listHostsForMigrationOfVM(final Long vmId, final Long startIndex, final Long pageSize,\n            final String keyword) {\n        final Account caller = getCaller();\n        if (!_accountMgr.isRootAdmin(caller.getId())) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Caller is not a root admin, permission denied to migrate the VM\");\n            }\n            throw new PermissionDeniedException(\"No permission to migrate VM, Only Root Admin can migrate a VM!\");\n        }\n\n        final VMInstanceVO vm = _vmInstanceDao.findById(vmId);\n        if (vm == null) {\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the VM with given id\");\n            throw ex;\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not running, cannot migrate the vm\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"VM is not Running, cannot \" + \"migrate the vm with specified id\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        if (_serviceOfferingDetailsDao.findDetail(vm.getServiceOfferingId(), GPU.Keys.pciDevice.toString()) != null) {\n            s_logger.info(\" Live Migration of GPU enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            \r\n            return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>, Integer>(new ArrayList<HostVO>(), new Integer(0)),\n                    new ArrayList<Host>(), new HashMap<Host, Boolean>());\n        }\n\n        if (!vm.getHypervisorType().equals(HypervisorType.XenServer) && !vm.getHypervisorType().equals(HypervisorType.VMware) && !vm.getHypervisorType().equals(HypervisorType.KVM)\n                && !vm.getHypervisorType().equals(HypervisorType.Ovm) && !vm.getHypervisorType().equals(HypervisorType.Hyperv) && !vm.getHypervisorType().equals(HypervisorType.LXC)\n                && !vm.getHypervisorType().equals(HypervisorType.Simulator) && !vm.getHypervisorType().equals(HypervisorType.Ovm3)) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(vm + \" is not XenServer/VMware/KVM/Ovm/Hyperv/Ovm3, cannot migrate this VM.\");\n            }\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for VM migration, we support \" + \"XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        if (vm.getType().equals(VirtualMachine.Type.User) && vm.getHypervisorType().equals(HypervisorType.LXC)) {\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for User VM migration, we support XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        final long srcHostId = vm.getHostId();\n        final Host srcHost = _hostDao.findById(srcHostId);\n        if (srcHost == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the host with id: \" + srcHostId + \" of this VM:\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the host (with specified id) of VM with specified id\");\n            ex.addProxyObject(String.valueOf(srcHostId), \"hostId\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        \r\n        boolean canMigrateWithStorage = false;\n\n        if (vm.getType() == VirtualMachine.Type.User) {\n            final HypervisorCapabilitiesVO capabilities = _hypervisorCapabilitiesDao.findByHypervisorTypeAndVersion(srcHost.getHypervisorType(), srcHost.getHypervisorVersion());\n            if (capabilities != null) {\n                canMigrateWithStorage = capabilities.isStorageMotionSupported();\n            }\n        }\n\n        \r\n        final VirtualMachineProfile vmProfile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        final List<VolumeVO> volumes = _volumeDao.findCreatedByInstance(vmProfile.getId());\n        boolean usesLocal = false;\n        for (final VolumeVO volume : volumes) {\n            final DiskOfferingVO diskOffering = _diskOfferingDao.findById(volume.getDiskOfferingId());\n            final DiskProfile diskProfile = new DiskProfile(volume, diskOffering, vmProfile.getHypervisorType());\n            if (diskProfile.useLocalStorage()) {\n                usesLocal = true;\n                break;\n            }\n        }\n\n        if (!canMigrateWithStorage && usesLocal) {\n            throw new InvalidParameterValueException(\"Unsupported operation, VM uses Local storage, cannot migrate\");\n        }\n\n        final Type hostType = srcHost.getType();\n        Pair<List<HostVO>, Integer> allHostsPair = null;\n        List<HostVO> allHosts = null;\n        final Map<Host, Boolean> requiresStorageMotion = new HashMap<Host, Boolean>();\n        DataCenterDeployment plan = null;\n        if (canMigrateWithStorage) {\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, srcHost.getDataCenterId(), null, null, null, keyword, null, null, srcHost.getHypervisorType(),\n                    srcHost.getHypervisorVersion());\n            allHosts = allHostsPair.first();\n            allHosts.remove(srcHost);\n\n            for (final VolumeVO volume : volumes) {\n                StoragePool storagePool = _poolDao.findById(volume.getPoolId());\n                Long volClusterId = storagePool.getClusterId();\n\n                for (Iterator<HostVO> iterator = allHosts.iterator(); iterator.hasNext();) {\n                    final Host host = iterator.next();\n\n                    if (volClusterId != null) {\n                        if (storagePool.isLocal() || !host.getClusterId().equals(volClusterId) || usesLocal) {\n                            if (storagePool.isManaged()) {\n                                \r\n                                \r\n                                \r\n                                \r\n                                \r\n                                iterator.remove();\n                            } else {\n                                if (hasSuitablePoolsForVolume(volume, host, vmProfile)) {\n                                    requiresStorageMotion.put(host, true);\n                                } else {\n                                    iterator.remove();\n                                }\n                            }\n                        }\n                    } else {\n                        if (storagePool.isManaged()) {\n                            if (srcHost.getClusterId() != host.getClusterId()) {\n                                \r\n                                \r\n                                \r\n                                requiresStorageMotion.put(host, true);\n                            }\n                        }\n                    }\n                }\n            }\n\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), null, null, null, null, null);\n        } else {\n            final Long cluster = srcHost.getClusterId();\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Searching for all hosts in cluster \" + cluster + \" for migrating VM \" + vm);\n            }\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, null, null, cluster, null, keyword, null, null, null, null);\n            \r\n            allHosts = allHostsPair.first();\n            allHosts.remove(srcHost);\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), srcHost.getPodId(), srcHost.getClusterId(), null, null, null);\n        }\n\n        final Pair<List<? extends Host>, Integer> otherHosts = new Pair<List<? extends Host>, Integer>(allHosts, new Integer(allHosts.size()));\n        List<Host> suitableHosts = new ArrayList<Host>();\n        final ExcludeList excludes = new ExcludeList();\n        excludes.addHost(srcHostId);\n\n        if (dpdkHelper.isVMDpdkEnabled(vm.getId())) {\n            excludeNonDPDKEnabledHosts(plan, excludes);\n        }\n\n        \r\n        final long vmGroupCount = _affinityGroupVMMapDao.countAffinityGroupsForVm(vm.getId());\n\n        if (vmGroupCount > 0) {\n            for (final AffinityGroupProcessor processor : _affinityProcessors) {\n                processor.process(vmProfile, plan, excludes);\n            }\n        }\n\n        for (final HostAllocator allocator : hostAllocators) {\n            if (canMigrateWithStorage) {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, allHosts, HostAllocator.RETURN_UPTO_ALL, false);\n            } else {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, HostAllocator.RETURN_UPTO_ALL, false);\n            }\n\n            if (suitableHosts != null && !suitableHosts.isEmpty()) {\n                break;\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            if (suitableHosts.isEmpty()) {\n                s_logger.debug(\"No suitable hosts found\");\n            } else {\n                s_logger.debug(\"Hosts having capacity and suitable for migration: \" + suitableHosts);\n            }\n        }\n\n        return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(otherHosts, suitableHosts, requiresStorageMotion);\n    }\n","realPath":"server/src/main/java/com/cloud/server/ManagementServerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1168,"status":"M"},{"authorDate":"2019-01-25 20:05:13","commitOrder":6,"curCode":"    private boolean isOnSupportedHypevisorForMigration(VMInstanceVO vm) {\n        return (vm.getHypervisorType().equals(HypervisorType.XenServer) ||\n                vm.getHypervisorType().equals(HypervisorType.VMware) ||\n                vm.getHypervisorType().equals(HypervisorType.KVM) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm) ||\n                vm.getHypervisorType().equals(HypervisorType.Hyperv) ||\n                vm.getHypervisorType().equals(HypervisorType.LXC) ||\n                vm.getHypervisorType().equals(HypervisorType.Simulator) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm3));\n    }\n","date":"2019-01-25 20:05:13","endLine":5248,"groupId":"13593","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"isOnSupportedHypevisorForMigration","params":"(VMInstanceVOvm)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/68/b45e1af7c3b5c442bc0dc09dec1aeb5256a58d.src","preCode":"    private boolean isOnSupportedHypevisorForMigration(VMInstanceVO vm) {\n        return (vm.getHypervisorType().equals(HypervisorType.XenServer) ||\n                vm.getHypervisorType().equals(HypervisorType.VMware) ||\n                vm.getHypervisorType().equals(HypervisorType.KVM) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm) ||\n                vm.getHypervisorType().equals(HypervisorType.Hyperv) ||\n                vm.getHypervisorType().equals(HypervisorType.LXC) ||\n                vm.getHypervisorType().equals(HypervisorType.Simulator) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm3));\n    }\n","realPath":"server/src/main/java/com/cloud/vm/UserVmManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":5239,"status":"N"}],"commitId":"a62a10c81439fc0af18ddd604c29b2314ff725cc","commitMessage":"@@@Merge branch '4.13'\n","date":"2020-02-26 23:18:41","modifiedFileCount":"23","status":"M","submitter":"Daan Hoogland"},{"authorTime":"2019-01-25 20:05:13","codes":[{"authorDate":"2020-03-14 03:56:26","commitOrder":7,"curCode":"    public Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>> listHostsForMigrationOfVM(final Long vmId, final Long startIndex, final Long pageSize,\n            final String keyword) {\n        final Account caller = getCaller();\n        if (!_accountMgr.isRootAdmin(caller.getId())) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Caller is not a root admin, permission denied to migrate the VM\");\n            }\n            throw new PermissionDeniedException(\"No permission to migrate VM, Only Root Admin can migrate a VM!\");\n        }\n\n        final VMInstanceVO vm = _vmInstanceDao.findById(vmId);\n        if (vm == null) {\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the VM with given id\");\n            throw ex;\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not running, cannot migrate the vm\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"VM is not Running, cannot \" + \"migrate the vm with specified id\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        UserVmDetailVO userVmDetailVO = _UserVmDetailsDao.findDetail(vm.getId(), ApiConstants.BootType.UEFI.toString());\n        if (userVmDetailVO != null) {\n            s_logger.info(\" Live Migration of UEFI enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            if (\"legacy\".equalsIgnoreCase(userVmDetailVO.getValue()) || \"secure\".equalsIgnoreCase(userVmDetailVO.getValue())) {\n                \r\n                return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>,\n                        Integer>(new ArrayList<HostVO>(), new Integer(0)), new ArrayList<Host>(), new HashMap<Host, Boolean>());\n            }\n        }\n\n        if (_serviceOfferingDetailsDao.findDetail(vm.getServiceOfferingId(), GPU.Keys.pciDevice.toString()) != null) {\n            s_logger.info(\" Live Migration of GPU enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            \r\n            return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>, Integer>(new ArrayList<HostVO>(), new Integer(0)),\n                    new ArrayList<Host>(), new HashMap<Host, Boolean>());\n        }\n\n        if (!vm.getHypervisorType().equals(HypervisorType.XenServer) && !vm.getHypervisorType().equals(HypervisorType.VMware) && !vm.getHypervisorType().equals(HypervisorType.KVM)\n                && !vm.getHypervisorType().equals(HypervisorType.Ovm) && !vm.getHypervisorType().equals(HypervisorType.Hyperv) && !vm.getHypervisorType().equals(HypervisorType.LXC)\n                && !vm.getHypervisorType().equals(HypervisorType.Simulator) && !vm.getHypervisorType().equals(HypervisorType.Ovm3)) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(vm + \" is not XenServer/VMware/KVM/Ovm/Hyperv/Ovm3, cannot migrate this VM.\");\n            }\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for VM migration, we support \" + \"XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        if (vm.getType().equals(VirtualMachine.Type.User) && vm.getHypervisorType().equals(HypervisorType.LXC)) {\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for User VM migration, we support XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        final long srcHostId = vm.getHostId();\n        final Host srcHost = _hostDao.findById(srcHostId);\n        if (srcHost == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the host with id: \" + srcHostId + \" of this VM:\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the host (with specified id) of VM with specified id\");\n            ex.addProxyObject(String.valueOf(srcHostId), \"hostId\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        \r\n        boolean canMigrateWithStorage = false;\n\n        if (vm.getType() == VirtualMachine.Type.User) {\n            final HypervisorCapabilitiesVO capabilities = _hypervisorCapabilitiesDao.findByHypervisorTypeAndVersion(srcHost.getHypervisorType(), srcHost.getHypervisorVersion());\n            if (capabilities != null) {\n                canMigrateWithStorage = capabilities.isStorageMotionSupported();\n            }\n        }\n\n        \r\n        final VirtualMachineProfile vmProfile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        final List<VolumeVO> volumes = _volumeDao.findCreatedByInstance(vmProfile.getId());\n        boolean usesLocal = false;\n        for (final VolumeVO volume : volumes) {\n            final DiskOfferingVO diskOffering = _diskOfferingDao.findById(volume.getDiskOfferingId());\n            final DiskProfile diskProfile = new DiskProfile(volume, diskOffering, vmProfile.getHypervisorType());\n            if (diskProfile.useLocalStorage()) {\n                usesLocal = true;\n                break;\n            }\n        }\n\n        if (!canMigrateWithStorage && usesLocal) {\n            throw new InvalidParameterValueException(\"Unsupported operation, VM uses Local storage, cannot migrate\");\n        }\n\n        final Type hostType = srcHost.getType();\n        Pair<List<HostVO>, Integer> allHostsPair = null;\n        List<HostVO> allHosts = null;\n        final Map<Host, Boolean> requiresStorageMotion = new HashMap<Host, Boolean>();\n        DataCenterDeployment plan = null;\n        if (canMigrateWithStorage) {\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, srcHost.getDataCenterId(), null, null, null, keyword, null, null, srcHost.getHypervisorType(),\n                    srcHost.getHypervisorVersion());\n            allHosts = allHostsPair.first();\n            allHosts.remove(srcHost);\n\n            for (final VolumeVO volume : volumes) {\n                StoragePool storagePool = _poolDao.findById(volume.getPoolId());\n                Long volClusterId = storagePool.getClusterId();\n\n                for (Iterator<HostVO> iterator = allHosts.iterator(); iterator.hasNext();) {\n                    final Host host = iterator.next();\n\n                    if (volClusterId != null) {\n                        if (storagePool.isLocal() || !host.getClusterId().equals(volClusterId) || usesLocal) {\n                            if (storagePool.isManaged()) {\n                                \r\n                                \r\n                                \r\n                                \r\n                                \r\n                                iterator.remove();\n                            } else {\n                                if (hasSuitablePoolsForVolume(volume, host, vmProfile)) {\n                                    requiresStorageMotion.put(host, true);\n                                } else {\n                                    iterator.remove();\n                                }\n                            }\n                        }\n                    } else {\n                        if (storagePool.isManaged()) {\n                            if (srcHost.getClusterId() != host.getClusterId()) {\n                                \r\n                                \r\n                                \r\n                                requiresStorageMotion.put(host, true);\n                            }\n                        }\n                    }\n                }\n            }\n\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), null, null, null, null, null);\n        } else {\n            final Long cluster = srcHost.getClusterId();\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Searching for all hosts in cluster \" + cluster + \" for migrating VM \" + vm);\n            }\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, null, null, cluster, null, keyword, null, null, null, null);\n            \r\n            allHosts = allHostsPair.first();\n            allHosts.remove(srcHost);\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), srcHost.getPodId(), srcHost.getClusterId(), null, null, null);\n        }\n\n        final Pair<List<? extends Host>, Integer> otherHosts = new Pair<List<? extends Host>, Integer>(allHosts, allHostsPair.second());\n        List<Host> suitableHosts = new ArrayList<Host>();\n        final ExcludeList excludes = new ExcludeList();\n        excludes.addHost(srcHostId);\n\n        if (dpdkHelper.isVMDpdkEnabled(vm.getId())) {\n            excludeNonDPDKEnabledHosts(plan, excludes);\n        }\n\n        \r\n        final long vmGroupCount = _affinityGroupVMMapDao.countAffinityGroupsForVm(vm.getId());\n\n        if (vmGroupCount > 0) {\n            for (final AffinityGroupProcessor processor : _affinityProcessors) {\n                processor.process(vmProfile, plan, excludes);\n            }\n        }\n\n        for (final HostAllocator allocator : hostAllocators) {\n            if (canMigrateWithStorage) {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, allHosts, HostAllocator.RETURN_UPTO_ALL, false);\n            } else {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, HostAllocator.RETURN_UPTO_ALL, false);\n            }\n\n            if (suitableHosts != null && !suitableHosts.isEmpty()) {\n                break;\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            if (suitableHosts.isEmpty()) {\n                s_logger.debug(\"No suitable hosts found\");\n            } else {\n                s_logger.debug(\"Hosts having capacity and suitable for migration: \" + suitableHosts);\n            }\n        }\n\n        return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(otherHosts, suitableHosts, requiresStorageMotion);\n    }\n","date":"2020-03-14 03:56:26","endLine":1367,"groupId":"20252","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"listHostsForMigrationOfVM","params":"(finalLongvmId@finalLongstartIndex@finalLongpageSize@finalStringkeyword)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/a3/e9bb6559401320420a9ba367efaff2102825cf.src","preCode":"    public Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>> listHostsForMigrationOfVM(final Long vmId, final Long startIndex, final Long pageSize,\n            final String keyword) {\n        final Account caller = getCaller();\n        if (!_accountMgr.isRootAdmin(caller.getId())) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Caller is not a root admin, permission denied to migrate the VM\");\n            }\n            throw new PermissionDeniedException(\"No permission to migrate VM, Only Root Admin can migrate a VM!\");\n        }\n\n        final VMInstanceVO vm = _vmInstanceDao.findById(vmId);\n        if (vm == null) {\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the VM with given id\");\n            throw ex;\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not running, cannot migrate the vm\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"VM is not Running, cannot \" + \"migrate the vm with specified id\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        if (_serviceOfferingDetailsDao.findDetail(vm.getServiceOfferingId(), GPU.Keys.pciDevice.toString()) != null) {\n            s_logger.info(\" Live Migration of GPU enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            \r\n            return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>, Integer>(new ArrayList<HostVO>(), new Integer(0)),\n                    new ArrayList<Host>(), new HashMap<Host, Boolean>());\n        }\n\n        if (!vm.getHypervisorType().equals(HypervisorType.XenServer) && !vm.getHypervisorType().equals(HypervisorType.VMware) && !vm.getHypervisorType().equals(HypervisorType.KVM)\n                && !vm.getHypervisorType().equals(HypervisorType.Ovm) && !vm.getHypervisorType().equals(HypervisorType.Hyperv) && !vm.getHypervisorType().equals(HypervisorType.LXC)\n                && !vm.getHypervisorType().equals(HypervisorType.Simulator) && !vm.getHypervisorType().equals(HypervisorType.Ovm3)) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(vm + \" is not XenServer/VMware/KVM/Ovm/Hyperv/Ovm3, cannot migrate this VM.\");\n            }\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for VM migration, we support \" + \"XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        if (vm.getType().equals(VirtualMachine.Type.User) && vm.getHypervisorType().equals(HypervisorType.LXC)) {\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for User VM migration, we support XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        final long srcHostId = vm.getHostId();\n        final Host srcHost = _hostDao.findById(srcHostId);\n        if (srcHost == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the host with id: \" + srcHostId + \" of this VM:\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the host (with specified id) of VM with specified id\");\n            ex.addProxyObject(String.valueOf(srcHostId), \"hostId\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        \r\n        boolean canMigrateWithStorage = false;\n\n        if (vm.getType() == VirtualMachine.Type.User) {\n            final HypervisorCapabilitiesVO capabilities = _hypervisorCapabilitiesDao.findByHypervisorTypeAndVersion(srcHost.getHypervisorType(), srcHost.getHypervisorVersion());\n            if (capabilities != null) {\n                canMigrateWithStorage = capabilities.isStorageMotionSupported();\n            }\n        }\n\n        \r\n        final VirtualMachineProfile vmProfile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        final List<VolumeVO> volumes = _volumeDao.findCreatedByInstance(vmProfile.getId());\n        boolean usesLocal = false;\n        for (final VolumeVO volume : volumes) {\n            final DiskOfferingVO diskOffering = _diskOfferingDao.findById(volume.getDiskOfferingId());\n            final DiskProfile diskProfile = new DiskProfile(volume, diskOffering, vmProfile.getHypervisorType());\n            if (diskProfile.useLocalStorage()) {\n                usesLocal = true;\n                break;\n            }\n        }\n\n        if (!canMigrateWithStorage && usesLocal) {\n            throw new InvalidParameterValueException(\"Unsupported operation, VM uses Local storage, cannot migrate\");\n        }\n\n        final Type hostType = srcHost.getType();\n        Pair<List<HostVO>, Integer> allHostsPair = null;\n        List<HostVO> allHosts = null;\n        final Map<Host, Boolean> requiresStorageMotion = new HashMap<Host, Boolean>();\n        DataCenterDeployment plan = null;\n        if (canMigrateWithStorage) {\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, srcHost.getDataCenterId(), null, null, null, keyword, null, null, srcHost.getHypervisorType(),\n                    srcHost.getHypervisorVersion());\n            allHosts = allHostsPair.first();\n            allHosts.remove(srcHost);\n\n            for (final VolumeVO volume : volumes) {\n                StoragePool storagePool = _poolDao.findById(volume.getPoolId());\n                Long volClusterId = storagePool.getClusterId();\n\n                for (Iterator<HostVO> iterator = allHosts.iterator(); iterator.hasNext();) {\n                    final Host host = iterator.next();\n\n                    if (volClusterId != null) {\n                        if (storagePool.isLocal() || !host.getClusterId().equals(volClusterId) || usesLocal) {\n                            if (storagePool.isManaged()) {\n                                \r\n                                \r\n                                \r\n                                \r\n                                \r\n                                iterator.remove();\n                            } else {\n                                if (hasSuitablePoolsForVolume(volume, host, vmProfile)) {\n                                    requiresStorageMotion.put(host, true);\n                                } else {\n                                    iterator.remove();\n                                }\n                            }\n                        }\n                    } else {\n                        if (storagePool.isManaged()) {\n                            if (srcHost.getClusterId() != host.getClusterId()) {\n                                \r\n                                \r\n                                \r\n                                requiresStorageMotion.put(host, true);\n                            }\n                        }\n                    }\n                }\n            }\n\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), null, null, null, null, null);\n        } else {\n            final Long cluster = srcHost.getClusterId();\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Searching for all hosts in cluster \" + cluster + \" for migrating VM \" + vm);\n            }\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, null, null, cluster, null, keyword, null, null, null, null);\n            \r\n            allHosts = allHostsPair.first();\n            allHosts.remove(srcHost);\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), srcHost.getPodId(), srcHost.getClusterId(), null, null, null);\n        }\n\n        final Pair<List<? extends Host>, Integer> otherHosts = new Pair<List<? extends Host>, Integer>(allHosts, allHostsPair.second());\n        List<Host> suitableHosts = new ArrayList<Host>();\n        final ExcludeList excludes = new ExcludeList();\n        excludes.addHost(srcHostId);\n\n        if (dpdkHelper.isVMDpdkEnabled(vm.getId())) {\n            excludeNonDPDKEnabledHosts(plan, excludes);\n        }\n\n        \r\n        final long vmGroupCount = _affinityGroupVMMapDao.countAffinityGroupsForVm(vm.getId());\n\n        if (vmGroupCount > 0) {\n            for (final AffinityGroupProcessor processor : _affinityProcessors) {\n                processor.process(vmProfile, plan, excludes);\n            }\n        }\n\n        for (final HostAllocator allocator : hostAllocators) {\n            if (canMigrateWithStorage) {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, allHosts, HostAllocator.RETURN_UPTO_ALL, false);\n            } else {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, HostAllocator.RETURN_UPTO_ALL, false);\n            }\n\n            if (suitableHosts != null && !suitableHosts.isEmpty()) {\n                break;\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            if (suitableHosts.isEmpty()) {\n                s_logger.debug(\"No suitable hosts found\");\n            } else {\n                s_logger.debug(\"Hosts having capacity and suitable for migration: \" + suitableHosts);\n            }\n        }\n\n        return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(otherHosts, suitableHosts, requiresStorageMotion);\n    }\n","realPath":"server/src/main/java/com/cloud/server/ManagementServerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1173,"status":"M"},{"authorDate":"2019-01-25 20:05:13","commitOrder":7,"curCode":"    private boolean isOnSupportedHypevisorForMigration(VMInstanceVO vm) {\n        return (vm.getHypervisorType().equals(HypervisorType.XenServer) ||\n                vm.getHypervisorType().equals(HypervisorType.VMware) ||\n                vm.getHypervisorType().equals(HypervisorType.KVM) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm) ||\n                vm.getHypervisorType().equals(HypervisorType.Hyperv) ||\n                vm.getHypervisorType().equals(HypervisorType.LXC) ||\n                vm.getHypervisorType().equals(HypervisorType.Simulator) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm3));\n    }\n","date":"2019-01-25 20:05:13","endLine":5248,"groupId":"13593","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"isOnSupportedHypevisorForMigration","params":"(VMInstanceVOvm)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/68/b45e1af7c3b5c442bc0dc09dec1aeb5256a58d.src","preCode":"    private boolean isOnSupportedHypevisorForMigration(VMInstanceVO vm) {\n        return (vm.getHypervisorType().equals(HypervisorType.XenServer) ||\n                vm.getHypervisorType().equals(HypervisorType.VMware) ||\n                vm.getHypervisorType().equals(HypervisorType.KVM) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm) ||\n                vm.getHypervisorType().equals(HypervisorType.Hyperv) ||\n                vm.getHypervisorType().equals(HypervisorType.LXC) ||\n                vm.getHypervisorType().equals(HypervisorType.Simulator) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm3));\n    }\n","realPath":"server/src/main/java/com/cloud/vm/UserVmManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":5239,"status":"N"}],"commitId":"d4b537efa7ed27ef88b735a22493808b61529186","commitMessage":"@@@UEFI Implementation:  Enabled UEFI Support for Guest VM's on Hypervisor KVM. VMware. enabled boot modes [Legacy. Secure] support for UEFI boot with known caveats. (#3638)\n\nCo-authored-by: Pavan Kumar Aravapalli <pavan_aravapalli@accelerite.com>\nCo-authored-by: dahn <daan.hoogland@shapeblue.com>","date":"2020-03-14 03:56:26","modifiedFileCount":"32","status":"M","submitter":"pavanaravapalli"},{"authorTime":"2019-01-25 20:05:13","codes":[{"authorDate":"2020-07-07 15:23:05","commitOrder":8,"curCode":"    public Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>> listHostsForMigrationOfVM(final Long vmId, final Long startIndex, final Long pageSize,\n            final String keyword) {\n        final Account caller = getCaller();\n        if (!_accountMgr.isRootAdmin(caller.getId())) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Caller is not a root admin, permission denied to migrate the VM\");\n            }\n            throw new PermissionDeniedException(\"No permission to migrate VM, Only Root Admin can migrate a VM!\");\n        }\n\n        final VMInstanceVO vm = _vmInstanceDao.findById(vmId);\n        if (vm == null) {\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the VM with given id\");\n            throw ex;\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not running, cannot migrate the vm\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"VM is not Running, cannot \" + \"migrate the vm with specified id\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        UserVmDetailVO userVmDetailVO = _UserVmDetailsDao.findDetail(vm.getId(), ApiConstants.BootType.UEFI.toString());\n        if (userVmDetailVO != null) {\n            s_logger.info(\" Live Migration of UEFI enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            if (\"legacy\".equalsIgnoreCase(userVmDetailVO.getValue()) || \"secure\".equalsIgnoreCase(userVmDetailVO.getValue())) {\n                \r\n                return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>,\n                        Integer>(new ArrayList<HostVO>(), new Integer(0)), new ArrayList<Host>(), new HashMap<Host, Boolean>());\n            }\n        }\n\n        if (_serviceOfferingDetailsDao.findDetail(vm.getServiceOfferingId(), GPU.Keys.pciDevice.toString()) != null) {\n            s_logger.info(\" Live Migration of GPU enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            \r\n            return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>, Integer>(new ArrayList<HostVO>(), new Integer(0)),\n                    new ArrayList<Host>(), new HashMap<Host, Boolean>());\n        }\n\n        if (!vm.getHypervisorType().equals(HypervisorType.XenServer) && !vm.getHypervisorType().equals(HypervisorType.VMware) && !vm.getHypervisorType().equals(HypervisorType.KVM)\n                && !vm.getHypervisorType().equals(HypervisorType.Ovm) && !vm.getHypervisorType().equals(HypervisorType.Hyperv) && !vm.getHypervisorType().equals(HypervisorType.LXC)\n                && !vm.getHypervisorType().equals(HypervisorType.Simulator) && !vm.getHypervisorType().equals(HypervisorType.Ovm3)) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(vm + \" is not XenServer/VMware/KVM/Ovm/Hyperv/Ovm3, cannot migrate this VM.\");\n            }\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for VM migration, we support \" + \"XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        if (vm.getType().equals(VirtualMachine.Type.User) && vm.getHypervisorType().equals(HypervisorType.LXC)) {\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for User VM migration, we support XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        final long srcHostId = vm.getHostId();\n        final Host srcHost = _hostDao.findById(srcHostId);\n        if (srcHost == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the host with id: \" + srcHostId + \" of this VM:\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the host (with specified id) of VM with specified id\");\n            ex.addProxyObject(String.valueOf(srcHostId), \"hostId\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        \r\n        boolean canMigrateWithStorage = false;\n\n        if (vm.getType() == VirtualMachine.Type.User) {\n            final HypervisorCapabilitiesVO capabilities = _hypervisorCapabilitiesDao.findByHypervisorTypeAndVersion(srcHost.getHypervisorType(), srcHost.getHypervisorVersion());\n            if (capabilities != null) {\n                canMigrateWithStorage = capabilities.isStorageMotionSupported();\n            }\n        }\n\n        \r\n        final VirtualMachineProfile vmProfile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        final List<VolumeVO> volumes = _volumeDao.findCreatedByInstance(vmProfile.getId());\n        boolean usesLocal = false;\n        for (final VolumeVO volume : volumes) {\n            final DiskOfferingVO diskOffering = _diskOfferingDao.findById(volume.getDiskOfferingId());\n            final DiskProfile diskProfile = new DiskProfile(volume, diskOffering, vmProfile.getHypervisorType());\n            if (diskProfile.useLocalStorage()) {\n                usesLocal = true;\n                break;\n            }\n        }\n\n        if (!canMigrateWithStorage && usesLocal) {\n            throw new InvalidParameterValueException(\"Unsupported operation, VM uses Local storage, cannot migrate\");\n        }\n\n        final Type hostType = srcHost.getType();\n        Pair<List<HostVO>, Integer> allHostsPair = null;\n        List<HostVO> allHosts = null;\n        final Map<Host, Boolean> requiresStorageMotion = new HashMap<Host, Boolean>();\n        DataCenterDeployment plan = null;\n        if (canMigrateWithStorage) {\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, srcHost.getDataCenterId(), null, null, null, keyword, null, null, srcHost.getHypervisorType(),\n                    srcHost.getHypervisorVersion());\n            allHosts = allHostsPair.first();\n            allHosts.remove(srcHost);\n\n            for (final VolumeVO volume : volumes) {\n                StoragePool storagePool = _poolDao.findById(volume.getPoolId());\n                Long volClusterId = storagePool.getClusterId();\n\n                for (Iterator<HostVO> iterator = allHosts.iterator(); iterator.hasNext();) {\n                    final Host host = iterator.next();\n\n                    if (volClusterId != null) {\n                        if (storagePool.isLocal() || !host.getClusterId().equals(volClusterId) || usesLocal) {\n                            if (storagePool.isManaged()) {\n                                \r\n                                \r\n                                \r\n                                \r\n                                \r\n                                iterator.remove();\n                            } else {\n                                if (hasSuitablePoolsForVolume(volume, host, vmProfile)) {\n                                    requiresStorageMotion.put(host, true);\n                                } else {\n                                    iterator.remove();\n                                }\n                            }\n                        }\n                    } else {\n                        if (storagePool.isManaged()) {\n                            if (srcHost.getClusterId() != host.getClusterId()) {\n                                \r\n                                \r\n                                \r\n                                requiresStorageMotion.put(host, true);\n                            }\n                        }\n                    }\n                }\n            }\n\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), null, null, null, null, null);\n        } else {\n            final Long cluster = srcHost.getClusterId();\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Searching for all hosts in cluster \" + cluster + \" for migrating VM \" + vm);\n            }\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, null, null, cluster, null, keyword, null, null, null, null);\n            \r\n            allHosts = allHostsPair.first();\n            allHosts.remove(srcHost);\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), srcHost.getPodId(), srcHost.getClusterId(), null, null, null);\n        }\n\n        final Pair<List<? extends Host>, Integer> otherHosts = new Pair<List<? extends Host>, Integer>(allHosts, allHostsPair.second());\n        List<Host> suitableHosts = new ArrayList<Host>();\n        final ExcludeList excludes = new ExcludeList();\n        excludes.addHost(srcHostId);\n\n        if (dpdkHelper.isVMDpdkEnabled(vm.getId())) {\n            excludeNonDPDKEnabledHosts(plan, excludes);\n        }\n\n        \r\n        final long vmGroupCount = _affinityGroupVMMapDao.countAffinityGroupsForVm(vm.getId());\n\n        if (vmGroupCount > 0) {\n            for (final AffinityGroupProcessor processor : _affinityProcessors) {\n                processor.process(vmProfile, plan, excludes);\n            }\n        }\n\n        if (vm.getType() == VirtualMachine.Type.User || vm.getType() == VirtualMachine.Type.DomainRouter) {\n            final DataCenterVO dc = _dcDao.findById(srcHost.getDataCenterId());\n            _dpMgr.checkForNonDedicatedResources(vmProfile, dc, excludes);\n        }\n\n        for (final HostAllocator allocator : hostAllocators) {\n            if (canMigrateWithStorage) {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, allHosts, HostAllocator.RETURN_UPTO_ALL, false);\n            } else {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, HostAllocator.RETURN_UPTO_ALL, false);\n            }\n\n            if (suitableHosts != null && !suitableHosts.isEmpty()) {\n                break;\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            if (suitableHosts.isEmpty()) {\n                s_logger.debug(\"No suitable hosts found\");\n            } else {\n                s_logger.debug(\"Hosts having capacity and suitable for migration: \" + suitableHosts);\n            }\n        }\n\n        return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(otherHosts, suitableHosts, requiresStorageMotion);\n    }\n","date":"2020-07-07 15:23:05","endLine":1372,"groupId":"20252","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"listHostsForMigrationOfVM","params":"(finalLongvmId@finalLongstartIndex@finalLongpageSize@finalStringkeyword)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/92/6aca94f7ea6946fd8a98a932be408845fa2d79.src","preCode":"    public Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>> listHostsForMigrationOfVM(final Long vmId, final Long startIndex, final Long pageSize,\n            final String keyword) {\n        final Account caller = getCaller();\n        if (!_accountMgr.isRootAdmin(caller.getId())) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Caller is not a root admin, permission denied to migrate the VM\");\n            }\n            throw new PermissionDeniedException(\"No permission to migrate VM, Only Root Admin can migrate a VM!\");\n        }\n\n        final VMInstanceVO vm = _vmInstanceDao.findById(vmId);\n        if (vm == null) {\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the VM with given id\");\n            throw ex;\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not running, cannot migrate the vm\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"VM is not Running, cannot \" + \"migrate the vm with specified id\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        UserVmDetailVO userVmDetailVO = _UserVmDetailsDao.findDetail(vm.getId(), ApiConstants.BootType.UEFI.toString());\n        if (userVmDetailVO != null) {\n            s_logger.info(\" Live Migration of UEFI enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            if (\"legacy\".equalsIgnoreCase(userVmDetailVO.getValue()) || \"secure\".equalsIgnoreCase(userVmDetailVO.getValue())) {\n                \r\n                return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>,\n                        Integer>(new ArrayList<HostVO>(), new Integer(0)), new ArrayList<Host>(), new HashMap<Host, Boolean>());\n            }\n        }\n\n        if (_serviceOfferingDetailsDao.findDetail(vm.getServiceOfferingId(), GPU.Keys.pciDevice.toString()) != null) {\n            s_logger.info(\" Live Migration of GPU enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            \r\n            return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>, Integer>(new ArrayList<HostVO>(), new Integer(0)),\n                    new ArrayList<Host>(), new HashMap<Host, Boolean>());\n        }\n\n        if (!vm.getHypervisorType().equals(HypervisorType.XenServer) && !vm.getHypervisorType().equals(HypervisorType.VMware) && !vm.getHypervisorType().equals(HypervisorType.KVM)\n                && !vm.getHypervisorType().equals(HypervisorType.Ovm) && !vm.getHypervisorType().equals(HypervisorType.Hyperv) && !vm.getHypervisorType().equals(HypervisorType.LXC)\n                && !vm.getHypervisorType().equals(HypervisorType.Simulator) && !vm.getHypervisorType().equals(HypervisorType.Ovm3)) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(vm + \" is not XenServer/VMware/KVM/Ovm/Hyperv/Ovm3, cannot migrate this VM.\");\n            }\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for VM migration, we support \" + \"XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        if (vm.getType().equals(VirtualMachine.Type.User) && vm.getHypervisorType().equals(HypervisorType.LXC)) {\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for User VM migration, we support XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        final long srcHostId = vm.getHostId();\n        final Host srcHost = _hostDao.findById(srcHostId);\n        if (srcHost == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the host with id: \" + srcHostId + \" of this VM:\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the host (with specified id) of VM with specified id\");\n            ex.addProxyObject(String.valueOf(srcHostId), \"hostId\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        \r\n        boolean canMigrateWithStorage = false;\n\n        if (vm.getType() == VirtualMachine.Type.User) {\n            final HypervisorCapabilitiesVO capabilities = _hypervisorCapabilitiesDao.findByHypervisorTypeAndVersion(srcHost.getHypervisorType(), srcHost.getHypervisorVersion());\n            if (capabilities != null) {\n                canMigrateWithStorage = capabilities.isStorageMotionSupported();\n            }\n        }\n\n        \r\n        final VirtualMachineProfile vmProfile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        final List<VolumeVO> volumes = _volumeDao.findCreatedByInstance(vmProfile.getId());\n        boolean usesLocal = false;\n        for (final VolumeVO volume : volumes) {\n            final DiskOfferingVO diskOffering = _diskOfferingDao.findById(volume.getDiskOfferingId());\n            final DiskProfile diskProfile = new DiskProfile(volume, diskOffering, vmProfile.getHypervisorType());\n            if (diskProfile.useLocalStorage()) {\n                usesLocal = true;\n                break;\n            }\n        }\n\n        if (!canMigrateWithStorage && usesLocal) {\n            throw new InvalidParameterValueException(\"Unsupported operation, VM uses Local storage, cannot migrate\");\n        }\n\n        final Type hostType = srcHost.getType();\n        Pair<List<HostVO>, Integer> allHostsPair = null;\n        List<HostVO> allHosts = null;\n        final Map<Host, Boolean> requiresStorageMotion = new HashMap<Host, Boolean>();\n        DataCenterDeployment plan = null;\n        if (canMigrateWithStorage) {\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, srcHost.getDataCenterId(), null, null, null, keyword, null, null, srcHost.getHypervisorType(),\n                    srcHost.getHypervisorVersion());\n            allHosts = allHostsPair.first();\n            allHosts.remove(srcHost);\n\n            for (final VolumeVO volume : volumes) {\n                StoragePool storagePool = _poolDao.findById(volume.getPoolId());\n                Long volClusterId = storagePool.getClusterId();\n\n                for (Iterator<HostVO> iterator = allHosts.iterator(); iterator.hasNext();) {\n                    final Host host = iterator.next();\n\n                    if (volClusterId != null) {\n                        if (storagePool.isLocal() || !host.getClusterId().equals(volClusterId) || usesLocal) {\n                            if (storagePool.isManaged()) {\n                                \r\n                                \r\n                                \r\n                                \r\n                                \r\n                                iterator.remove();\n                            } else {\n                                if (hasSuitablePoolsForVolume(volume, host, vmProfile)) {\n                                    requiresStorageMotion.put(host, true);\n                                } else {\n                                    iterator.remove();\n                                }\n                            }\n                        }\n                    } else {\n                        if (storagePool.isManaged()) {\n                            if (srcHost.getClusterId() != host.getClusterId()) {\n                                \r\n                                \r\n                                \r\n                                requiresStorageMotion.put(host, true);\n                            }\n                        }\n                    }\n                }\n            }\n\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), null, null, null, null, null);\n        } else {\n            final Long cluster = srcHost.getClusterId();\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Searching for all hosts in cluster \" + cluster + \" for migrating VM \" + vm);\n            }\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, null, null, cluster, null, keyword, null, null, null, null);\n            \r\n            allHosts = allHostsPair.first();\n            allHosts.remove(srcHost);\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), srcHost.getPodId(), srcHost.getClusterId(), null, null, null);\n        }\n\n        final Pair<List<? extends Host>, Integer> otherHosts = new Pair<List<? extends Host>, Integer>(allHosts, allHostsPair.second());\n        List<Host> suitableHosts = new ArrayList<Host>();\n        final ExcludeList excludes = new ExcludeList();\n        excludes.addHost(srcHostId);\n\n        if (dpdkHelper.isVMDpdkEnabled(vm.getId())) {\n            excludeNonDPDKEnabledHosts(plan, excludes);\n        }\n\n        \r\n        final long vmGroupCount = _affinityGroupVMMapDao.countAffinityGroupsForVm(vm.getId());\n\n        if (vmGroupCount > 0) {\n            for (final AffinityGroupProcessor processor : _affinityProcessors) {\n                processor.process(vmProfile, plan, excludes);\n            }\n        }\n\n        for (final HostAllocator allocator : hostAllocators) {\n            if (canMigrateWithStorage) {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, allHosts, HostAllocator.RETURN_UPTO_ALL, false);\n            } else {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, HostAllocator.RETURN_UPTO_ALL, false);\n            }\n\n            if (suitableHosts != null && !suitableHosts.isEmpty()) {\n                break;\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            if (suitableHosts.isEmpty()) {\n                s_logger.debug(\"No suitable hosts found\");\n            } else {\n                s_logger.debug(\"Hosts having capacity and suitable for migration: \" + suitableHosts);\n            }\n        }\n\n        return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(otherHosts, suitableHosts, requiresStorageMotion);\n    }\n","realPath":"server/src/main/java/com/cloud/server/ManagementServerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1173,"status":"M"},{"authorDate":"2019-01-25 20:05:13","commitOrder":8,"curCode":"    private boolean isOnSupportedHypevisorForMigration(VMInstanceVO vm) {\n        return (vm.getHypervisorType().equals(HypervisorType.XenServer) ||\n                vm.getHypervisorType().equals(HypervisorType.VMware) ||\n                vm.getHypervisorType().equals(HypervisorType.KVM) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm) ||\n                vm.getHypervisorType().equals(HypervisorType.Hyperv) ||\n                vm.getHypervisorType().equals(HypervisorType.LXC) ||\n                vm.getHypervisorType().equals(HypervisorType.Simulator) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm3));\n    }\n","date":"2019-01-25 20:05:13","endLine":5248,"groupId":"13593","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"isOnSupportedHypevisorForMigration","params":"(VMInstanceVOvm)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/68/b45e1af7c3b5c442bc0dc09dec1aeb5256a58d.src","preCode":"    private boolean isOnSupportedHypevisorForMigration(VMInstanceVO vm) {\n        return (vm.getHypervisorType().equals(HypervisorType.XenServer) ||\n                vm.getHypervisorType().equals(HypervisorType.VMware) ||\n                vm.getHypervisorType().equals(HypervisorType.KVM) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm) ||\n                vm.getHypervisorType().equals(HypervisorType.Hyperv) ||\n                vm.getHypervisorType().equals(HypervisorType.LXC) ||\n                vm.getHypervisorType().equals(HypervisorType.Simulator) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm3));\n    }\n","realPath":"server/src/main/java/com/cloud/vm/UserVmManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":5239,"status":"N"}],"commitId":"2c82aac5aadcb891f3e7d110f629ffe934d7adf3","commitMessage":"@@@Merge remote-tracking branch 'origin/4.14'\n","date":"2020-07-07 15:23:05","modifiedFileCount":"15","status":"M","submitter":"Rohit Yadav"},{"authorTime":"2019-01-25 20:05:13","codes":[{"authorDate":"2020-10-24 19:08:45","commitOrder":9,"curCode":"    public Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>> listHostsForMigrationOfVM(final Long vmId, final Long startIndex, final Long pageSize,\n            final String keyword) {\n        final Account caller = getCaller();\n        if (!_accountMgr.isRootAdmin(caller.getId())) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Caller is not a root admin, permission denied to migrate the VM\");\n            }\n            throw new PermissionDeniedException(\"No permission to migrate VM, Only Root Admin can migrate a VM!\");\n        }\n\n        final VMInstanceVO vm = _vmInstanceDao.findById(vmId);\n        if (vm == null) {\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the VM with given id\");\n            throw ex;\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not running, cannot migrate the vm\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"VM is not Running, cannot \" + \"migrate the vm with specified id\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        UserVmDetailVO userVmDetailVO = _UserVmDetailsDao.findDetail(vm.getId(), ApiConstants.BootType.UEFI.toString());\n        if (userVmDetailVO != null) {\n            s_logger.info(\" Live Migration of UEFI enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            if (\"legacy\".equalsIgnoreCase(userVmDetailVO.getValue()) || \"secure\".equalsIgnoreCase(userVmDetailVO.getValue())) {\n                \r\n                return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>,\n                        Integer>(new ArrayList<HostVO>(), new Integer(0)), new ArrayList<Host>(), new HashMap<Host, Boolean>());\n            }\n        }\n\n        if (_serviceOfferingDetailsDao.findDetail(vm.getServiceOfferingId(), GPU.Keys.pciDevice.toString()) != null) {\n            s_logger.info(\" Live Migration of GPU enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            \r\n            return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>, Integer>(new ArrayList<HostVO>(), new Integer(0)),\n                    new ArrayList<Host>(), new HashMap<Host, Boolean>());\n        }\n\n        if (!vm.getHypervisorType().equals(HypervisorType.XenServer) && !vm.getHypervisorType().equals(HypervisorType.VMware) && !vm.getHypervisorType().equals(HypervisorType.KVM)\n                && !vm.getHypervisorType().equals(HypervisorType.Ovm) && !vm.getHypervisorType().equals(HypervisorType.Hyperv) && !vm.getHypervisorType().equals(HypervisorType.LXC)\n                && !vm.getHypervisorType().equals(HypervisorType.Simulator) && !vm.getHypervisorType().equals(HypervisorType.Ovm3)) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(vm + \" is not XenServer/VMware/KVM/Ovm/Hyperv/Ovm3, cannot migrate this VM.\");\n            }\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for VM migration, we support \" + \"XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        if (vm.getType().equals(VirtualMachine.Type.User) && vm.getHypervisorType().equals(HypervisorType.LXC)) {\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for User VM migration, we support XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        final long srcHostId = vm.getHostId();\n        final Host srcHost = _hostDao.findById(srcHostId);\n        if (srcHost == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the host with id: \" + srcHostId + \" of this VM:\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the host (with specified id) of VM with specified id\");\n            ex.addProxyObject(String.valueOf(srcHostId), \"hostId\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        \r\n        boolean canMigrateWithStorage = false;\n\n        if (vm.getType() == VirtualMachine.Type.User) {\n            final HypervisorCapabilitiesVO capabilities = _hypervisorCapabilitiesDao.findByHypervisorTypeAndVersion(srcHost.getHypervisorType(), srcHost.getHypervisorVersion());\n            if (capabilities != null) {\n                canMigrateWithStorage = capabilities.isStorageMotionSupported();\n            }\n        }\n\n        \r\n        final VirtualMachineProfile vmProfile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        final List<VolumeVO> volumes = _volumeDao.findCreatedByInstance(vmProfile.getId());\n        boolean usesLocal = false;\n        for (final VolumeVO volume : volumes) {\n            final DiskOfferingVO diskOffering = _diskOfferingDao.findById(volume.getDiskOfferingId());\n            final DiskProfile diskProfile = new DiskProfile(volume, diskOffering, vmProfile.getHypervisorType());\n            if (diskProfile.useLocalStorage()) {\n                usesLocal = true;\n                break;\n            }\n        }\n\n        if (!canMigrateWithStorage && usesLocal) {\n            throw new InvalidParameterValueException(\"Unsupported operation, VM uses Local storage, cannot migrate\");\n        }\n\n        final Type hostType = srcHost.getType();\n        Pair<List<HostVO>, Integer> allHostsPair = null;\n        List<HostVO> allHosts = null;\n        List<HostVO> hostsForMigrationWithStorage = null;\n        final Map<Host, Boolean> requiresStorageMotion = new HashMap<Host, Boolean>();\n        DataCenterDeployment plan = null;\n        if (canMigrateWithStorage) {\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, srcHost.getDataCenterId(), null, null, null, keyword,\n                null, null, srcHost.getHypervisorType(), srcHost.getHypervisorVersion(), srcHost.getId());\n            allHosts = allHostsPair.first();\n            hostsForMigrationWithStorage = new ArrayList<>(allHosts);\n\n            for (final VolumeVO volume : volumes) {\n                StoragePool storagePool = _poolDao.findById(volume.getPoolId());\n                Long volClusterId = storagePool.getClusterId();\n\n                for (Iterator<HostVO> iterator = hostsForMigrationWithStorage.iterator(); iterator.hasNext();) {\n                    final Host host = iterator.next();\n\n                    if (volClusterId != null) {\n                        if (storagePool.isLocal() || !host.getClusterId().equals(volClusterId) || usesLocal) {\n                            if (storagePool.isManaged()) {\n                                \r\n                                \r\n                                \r\n                                \r\n                                \r\n                                iterator.remove();\n                            } else {\n                                if (hasSuitablePoolsForVolume(volume, host, vmProfile)) {\n                                    requiresStorageMotion.put(host, true);\n                                } else {\n                                    iterator.remove();\n                                }\n                            }\n                        }\n                    } else {\n                        if (storagePool.isManaged()) {\n                            if (srcHost.getClusterId() != host.getClusterId()) {\n                                \r\n                                \r\n                                \r\n                                requiresStorageMotion.put(host, true);\n                            }\n                        }\n                    }\n                }\n            }\n\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), null, null, null, null, null);\n        } else {\n            final Long cluster = srcHost.getClusterId();\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Searching for all hosts in cluster \" + cluster + \" for migrating VM \" + vm);\n            }\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, null, null, cluster, null, keyword, null, null, null,\n                null, srcHost.getId());\n            allHosts = allHostsPair.first();\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), srcHost.getPodId(), srcHost.getClusterId(), null, null, null);\n        }\n\n        final Pair<List<? extends Host>, Integer> otherHosts = new Pair<List<? extends Host>, Integer>(allHosts, allHostsPair.second());\n        List<Host> suitableHosts = new ArrayList<Host>();\n        final ExcludeList excludes = new ExcludeList();\n        excludes.addHost(srcHostId);\n\n        if (dpdkHelper.isVMDpdkEnabled(vm.getId())) {\n            excludeNonDPDKEnabledHosts(plan, excludes);\n        }\n\n        \r\n        final long vmGroupCount = _affinityGroupVMMapDao.countAffinityGroupsForVm(vm.getId());\n\n        if (vmGroupCount > 0) {\n            for (final AffinityGroupProcessor processor : _affinityProcessors) {\n                processor.process(vmProfile, plan, excludes);\n            }\n        }\n\n        if (vm.getType() == VirtualMachine.Type.User || vm.getType() == VirtualMachine.Type.DomainRouter) {\n            final DataCenterVO dc = _dcDao.findById(srcHost.getDataCenterId());\n            _dpMgr.checkForNonDedicatedResources(vmProfile, dc, excludes);\n        }\n\n        for (final HostAllocator allocator : hostAllocators) {\n            if (canMigrateWithStorage) {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, hostsForMigrationWithStorage, HostAllocator.RETURN_UPTO_ALL, false);\n            } else {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, HostAllocator.RETURN_UPTO_ALL, false);\n            }\n\n            if (suitableHosts != null && !suitableHosts.isEmpty()) {\n                break;\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            if (suitableHosts.isEmpty()) {\n                s_logger.debug(\"No suitable hosts found\");\n            } else {\n                s_logger.debug(\"Hosts having capacity and suitable for migration: \" + suitableHosts);\n            }\n        }\n\n        return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(otherHosts, suitableHosts, requiresStorageMotion);\n    }\n","date":"2020-10-24 19:08:45","endLine":1380,"groupId":"11724","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"listHostsForMigrationOfVM","params":"(finalLongvmId@finalLongstartIndex@finalLongpageSize@finalStringkeyword)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/bd/5de221ba845aeddfcdb89d2fde2b4ee1709bb6.src","preCode":"    public Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>> listHostsForMigrationOfVM(final Long vmId, final Long startIndex, final Long pageSize,\n            final String keyword) {\n        final Account caller = getCaller();\n        if (!_accountMgr.isRootAdmin(caller.getId())) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Caller is not a root admin, permission denied to migrate the VM\");\n            }\n            throw new PermissionDeniedException(\"No permission to migrate VM, Only Root Admin can migrate a VM!\");\n        }\n\n        final VMInstanceVO vm = _vmInstanceDao.findById(vmId);\n        if (vm == null) {\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the VM with given id\");\n            throw ex;\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not running, cannot migrate the vm\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"VM is not Running, cannot \" + \"migrate the vm with specified id\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        UserVmDetailVO userVmDetailVO = _UserVmDetailsDao.findDetail(vm.getId(), ApiConstants.BootType.UEFI.toString());\n        if (userVmDetailVO != null) {\n            s_logger.info(\" Live Migration of UEFI enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            if (\"legacy\".equalsIgnoreCase(userVmDetailVO.getValue()) || \"secure\".equalsIgnoreCase(userVmDetailVO.getValue())) {\n                \r\n                return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>,\n                        Integer>(new ArrayList<HostVO>(), new Integer(0)), new ArrayList<Host>(), new HashMap<Host, Boolean>());\n            }\n        }\n\n        if (_serviceOfferingDetailsDao.findDetail(vm.getServiceOfferingId(), GPU.Keys.pciDevice.toString()) != null) {\n            s_logger.info(\" Live Migration of GPU enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            \r\n            return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>, Integer>(new ArrayList<HostVO>(), new Integer(0)),\n                    new ArrayList<Host>(), new HashMap<Host, Boolean>());\n        }\n\n        if (!vm.getHypervisorType().equals(HypervisorType.XenServer) && !vm.getHypervisorType().equals(HypervisorType.VMware) && !vm.getHypervisorType().equals(HypervisorType.KVM)\n                && !vm.getHypervisorType().equals(HypervisorType.Ovm) && !vm.getHypervisorType().equals(HypervisorType.Hyperv) && !vm.getHypervisorType().equals(HypervisorType.LXC)\n                && !vm.getHypervisorType().equals(HypervisorType.Simulator) && !vm.getHypervisorType().equals(HypervisorType.Ovm3)) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(vm + \" is not XenServer/VMware/KVM/Ovm/Hyperv/Ovm3, cannot migrate this VM.\");\n            }\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for VM migration, we support \" + \"XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        if (vm.getType().equals(VirtualMachine.Type.User) && vm.getHypervisorType().equals(HypervisorType.LXC)) {\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for User VM migration, we support XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        final long srcHostId = vm.getHostId();\n        final Host srcHost = _hostDao.findById(srcHostId);\n        if (srcHost == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the host with id: \" + srcHostId + \" of this VM:\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the host (with specified id) of VM with specified id\");\n            ex.addProxyObject(String.valueOf(srcHostId), \"hostId\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        \r\n        boolean canMigrateWithStorage = false;\n\n        if (vm.getType() == VirtualMachine.Type.User) {\n            final HypervisorCapabilitiesVO capabilities = _hypervisorCapabilitiesDao.findByHypervisorTypeAndVersion(srcHost.getHypervisorType(), srcHost.getHypervisorVersion());\n            if (capabilities != null) {\n                canMigrateWithStorage = capabilities.isStorageMotionSupported();\n            }\n        }\n\n        \r\n        final VirtualMachineProfile vmProfile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        final List<VolumeVO> volumes = _volumeDao.findCreatedByInstance(vmProfile.getId());\n        boolean usesLocal = false;\n        for (final VolumeVO volume : volumes) {\n            final DiskOfferingVO diskOffering = _diskOfferingDao.findById(volume.getDiskOfferingId());\n            final DiskProfile diskProfile = new DiskProfile(volume, diskOffering, vmProfile.getHypervisorType());\n            if (diskProfile.useLocalStorage()) {\n                usesLocal = true;\n                break;\n            }\n        }\n\n        if (!canMigrateWithStorage && usesLocal) {\n            throw new InvalidParameterValueException(\"Unsupported operation, VM uses Local storage, cannot migrate\");\n        }\n\n        final Type hostType = srcHost.getType();\n        Pair<List<HostVO>, Integer> allHostsPair = null;\n        List<HostVO> allHosts = null;\n        final Map<Host, Boolean> requiresStorageMotion = new HashMap<Host, Boolean>();\n        DataCenterDeployment plan = null;\n        if (canMigrateWithStorage) {\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, srcHost.getDataCenterId(), null, null, null, keyword, null, null, srcHost.getHypervisorType(),\n                    srcHost.getHypervisorVersion());\n            allHosts = allHostsPair.first();\n            allHosts.remove(srcHost);\n\n            for (final VolumeVO volume : volumes) {\n                StoragePool storagePool = _poolDao.findById(volume.getPoolId());\n                Long volClusterId = storagePool.getClusterId();\n\n                for (Iterator<HostVO> iterator = allHosts.iterator(); iterator.hasNext();) {\n                    final Host host = iterator.next();\n\n                    if (volClusterId != null) {\n                        if (storagePool.isLocal() || !host.getClusterId().equals(volClusterId) || usesLocal) {\n                            if (storagePool.isManaged()) {\n                                \r\n                                \r\n                                \r\n                                \r\n                                \r\n                                iterator.remove();\n                            } else {\n                                if (hasSuitablePoolsForVolume(volume, host, vmProfile)) {\n                                    requiresStorageMotion.put(host, true);\n                                } else {\n                                    iterator.remove();\n                                }\n                            }\n                        }\n                    } else {\n                        if (storagePool.isManaged()) {\n                            if (srcHost.getClusterId() != host.getClusterId()) {\n                                \r\n                                \r\n                                \r\n                                requiresStorageMotion.put(host, true);\n                            }\n                        }\n                    }\n                }\n            }\n\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), null, null, null, null, null);\n        } else {\n            final Long cluster = srcHost.getClusterId();\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Searching for all hosts in cluster \" + cluster + \" for migrating VM \" + vm);\n            }\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, null, null, cluster, null, keyword, null, null, null, null);\n            \r\n            allHosts = allHostsPair.first();\n            allHosts.remove(srcHost);\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), srcHost.getPodId(), srcHost.getClusterId(), null, null, null);\n        }\n\n        final Pair<List<? extends Host>, Integer> otherHosts = new Pair<List<? extends Host>, Integer>(allHosts, allHostsPair.second());\n        List<Host> suitableHosts = new ArrayList<Host>();\n        final ExcludeList excludes = new ExcludeList();\n        excludes.addHost(srcHostId);\n\n        if (dpdkHelper.isVMDpdkEnabled(vm.getId())) {\n            excludeNonDPDKEnabledHosts(plan, excludes);\n        }\n\n        \r\n        final long vmGroupCount = _affinityGroupVMMapDao.countAffinityGroupsForVm(vm.getId());\n\n        if (vmGroupCount > 0) {\n            for (final AffinityGroupProcessor processor : _affinityProcessors) {\n                processor.process(vmProfile, plan, excludes);\n            }\n        }\n\n        if (vm.getType() == VirtualMachine.Type.User || vm.getType() == VirtualMachine.Type.DomainRouter) {\n            final DataCenterVO dc = _dcDao.findById(srcHost.getDataCenterId());\n            _dpMgr.checkForNonDedicatedResources(vmProfile, dc, excludes);\n        }\n\n        for (final HostAllocator allocator : hostAllocators) {\n            if (canMigrateWithStorage) {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, allHosts, HostAllocator.RETURN_UPTO_ALL, false);\n            } else {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, HostAllocator.RETURN_UPTO_ALL, false);\n            }\n\n            if (suitableHosts != null && !suitableHosts.isEmpty()) {\n                break;\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            if (suitableHosts.isEmpty()) {\n                s_logger.debug(\"No suitable hosts found\");\n            } else {\n                s_logger.debug(\"Hosts having capacity and suitable for migration: \" + suitableHosts);\n            }\n        }\n\n        return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(otherHosts, suitableHosts, requiresStorageMotion);\n    }\n","realPath":"server/src/main/java/com/cloud/server/ManagementServerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1181,"status":"M"},{"authorDate":"2019-01-25 20:05:13","commitOrder":9,"curCode":"    private boolean isOnSupportedHypevisorForMigration(VMInstanceVO vm) {\n        return (vm.getHypervisorType().equals(HypervisorType.XenServer) ||\n                vm.getHypervisorType().equals(HypervisorType.VMware) ||\n                vm.getHypervisorType().equals(HypervisorType.KVM) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm) ||\n                vm.getHypervisorType().equals(HypervisorType.Hyperv) ||\n                vm.getHypervisorType().equals(HypervisorType.LXC) ||\n                vm.getHypervisorType().equals(HypervisorType.Simulator) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm3));\n    }\n","date":"2019-01-25 20:05:13","endLine":5248,"groupId":"13593","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"isOnSupportedHypevisorForMigration","params":"(VMInstanceVOvm)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/68/b45e1af7c3b5c442bc0dc09dec1aeb5256a58d.src","preCode":"    private boolean isOnSupportedHypevisorForMigration(VMInstanceVO vm) {\n        return (vm.getHypervisorType().equals(HypervisorType.XenServer) ||\n                vm.getHypervisorType().equals(HypervisorType.VMware) ||\n                vm.getHypervisorType().equals(HypervisorType.KVM) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm) ||\n                vm.getHypervisorType().equals(HypervisorType.Hyperv) ||\n                vm.getHypervisorType().equals(HypervisorType.LXC) ||\n                vm.getHypervisorType().equals(HypervisorType.Simulator) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm3));\n    }\n","realPath":"server/src/main/java/com/cloud/vm/UserVmManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":5239,"status":"N"}],"commitId":"81c524e9f393157e00474d1f975d3de4d56da2f5","commitMessage":"@@@Fixing count for findHostsForMigration (#4375)\n\n","date":"2020-10-24 19:08:45","modifiedFileCount":"1","status":"M","submitter":"davidjumani"},{"authorTime":"2019-01-25 20:05:13","codes":[{"authorDate":"2021-02-12 15:11:41","commitOrder":10,"curCode":"    public Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>> listHostsForMigrationOfVM(final Long vmId, final Long startIndex, final Long pageSize,\n            final String keyword) {\n        final Account caller = getCaller();\n        if (!_accountMgr.isRootAdmin(caller.getId())) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Caller is not a root admin, permission denied to migrate the VM\");\n            }\n            throw new PermissionDeniedException(\"No permission to migrate VM, Only Root Admin can migrate a VM!\");\n        }\n\n        final VMInstanceVO vm = _vmInstanceDao.findById(vmId);\n        if (vm == null) {\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the VM with given id\");\n            throw ex;\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not running, cannot migrate the vm\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"VM is not Running, cannot \" + \"migrate the vm with specified id\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        UserVmDetailVO userVmDetailVO = _UserVmDetailsDao.findDetail(vm.getId(), ApiConstants.BootType.UEFI.toString());\n        if (userVmDetailVO != null) {\n            s_logger.info(\" Live Migration of UEFI enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            if (\"legacy\".equalsIgnoreCase(userVmDetailVO.getValue()) || \"secure\".equalsIgnoreCase(userVmDetailVO.getValue())) {\n                \r\n                return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>,\n                        Integer>(new ArrayList<HostVO>(), new Integer(0)), new ArrayList<Host>(), new HashMap<Host, Boolean>());\n            }\n        }\n\n        if (_serviceOfferingDetailsDao.findDetail(vm.getServiceOfferingId(), GPU.Keys.pciDevice.toString()) != null) {\n            s_logger.info(\" Live Migration of GPU enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            \r\n            return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>, Integer>(new ArrayList<HostVO>(), new Integer(0)),\n                    new ArrayList<Host>(), new HashMap<Host, Boolean>());\n        }\n\n        if (!vm.getHypervisorType().equals(HypervisorType.XenServer) && !vm.getHypervisorType().equals(HypervisorType.VMware) && !vm.getHypervisorType().equals(HypervisorType.KVM)\n                && !vm.getHypervisorType().equals(HypervisorType.Ovm) && !vm.getHypervisorType().equals(HypervisorType.Hyperv) && !vm.getHypervisorType().equals(HypervisorType.LXC)\n                && !vm.getHypervisorType().equals(HypervisorType.Simulator) && !vm.getHypervisorType().equals(HypervisorType.Ovm3)) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(vm + \" is not XenServer/VMware/KVM/Ovm/Hyperv/Ovm3, cannot migrate this VM.\");\n            }\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for VM migration, we support \" + \"XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        if (vm.getType().equals(VirtualMachine.Type.User) && vm.getHypervisorType().equals(HypervisorType.LXC)) {\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for User VM migration, we support XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        final long srcHostId = vm.getHostId();\n        final Host srcHost = _hostDao.findById(srcHostId);\n        if (srcHost == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the host with id: \" + srcHostId + \" of this VM:\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the host (with specified id) of VM with specified id\");\n            ex.addProxyObject(String.valueOf(srcHostId), \"hostId\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n        String srcHostVersion = srcHost.getHypervisorVersion();\n        if (HypervisorType.KVM.equals(srcHost.getHypervisorType()) && srcHostVersion == null) {\n            srcHostVersion = \"\";\n        }\n\n        \r\n        boolean canMigrateWithStorage = false;\n\n        if (VirtualMachine.Type.User.equals(vm.getType()) || HypervisorType.VMware.equals(vm.getHypervisorType())) {\n            canMigrateWithStorage = Boolean.TRUE.equals(_hypervisorCapabilitiesDao.isStorageMotionSupported(srcHost.getHypervisorType(), srcHostVersion));\n        }\n\n        \r\n        final VirtualMachineProfile vmProfile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        final List<VolumeVO> volumes = _volumeDao.findCreatedByInstance(vmProfile.getId());\n        boolean usesLocal = false;\n        for (final VolumeVO volume : volumes) {\n            final DiskOfferingVO diskOffering = _diskOfferingDao.findById(volume.getDiskOfferingId());\n            final DiskProfile diskProfile = new DiskProfile(volume, diskOffering, vmProfile.getHypervisorType());\n            if (diskProfile.useLocalStorage()) {\n                usesLocal = true;\n                break;\n            }\n        }\n\n        if (!canMigrateWithStorage && usesLocal) {\n            throw new InvalidParameterValueException(\"Unsupported operation, VM uses Local storage, cannot migrate\");\n        }\n\n        final Type hostType = srcHost.getType();\n        Pair<List<HostVO>, Integer> allHostsPair = null;\n        List<HostVO> allHosts = null;\n        List<HostVO> hostsForMigrationWithStorage = null;\n        final Map<Host, Boolean> requiresStorageMotion = new HashMap<Host, Boolean>();\n        DataCenterDeployment plan = null;\n        if (canMigrateWithStorage) {\n            Long podId = !VirtualMachine.Type.User.equals(vm.getType()) ? srcHost.getPodId() : null;\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, srcHost.getDataCenterId(), podId, null, null, keyword,\n                null, null, srcHost.getHypervisorType(), null, srcHost.getId());\n            allHosts = allHostsPair.first();\n            hostsForMigrationWithStorage = new ArrayList<>(allHosts);\n\n            for (final VolumeVO volume : volumes) {\n                StoragePool storagePool = _poolDao.findById(volume.getPoolId());\n                Long volClusterId = storagePool.getClusterId();\n\n                for (Iterator<HostVO> iterator = hostsForMigrationWithStorage.iterator(); iterator.hasNext();) {\n                    final Host host = iterator.next();\n                    String hostVersion = host.getHypervisorVersion();\n                    if (HypervisorType.KVM.equals(host.getHypervisorType()) && hostVersion == null) {\n                        hostVersion = \"\";\n                    }\n\n                    if (volClusterId != null) {\n                        if (storagePool.isLocal() || !host.getClusterId().equals(volClusterId) || usesLocal) {\n                            if (storagePool.isManaged()) {\n                                \r\n                                \r\n                                \r\n                                \r\n                                \r\n                                iterator.remove();\n                            } else {\n                                boolean hostSupportsStorageMigration = false;\n                                if ((srcHostVersion != null && srcHostVersion.equals(hostVersion)) ||\n                                        Boolean.TRUE.equals(_hypervisorCapabilitiesDao.isStorageMotionSupported(host.getHypervisorType(), hostVersion))) {\n                                    hostSupportsStorageMigration = true;\n                                }\n                                if (hostSupportsStorageMigration && hasSuitablePoolsForVolume(volume, host, vmProfile)) {\n                                    requiresStorageMotion.put(host, true);\n                                } else {\n                                    iterator.remove();\n                                }\n                            }\n                        }\n                    } else {\n                        if (storagePool.isManaged()) {\n                            if (srcHost.getClusterId() != host.getClusterId()) {\n                                \r\n                                \r\n                                \r\n                                requiresStorageMotion.put(host, true);\n                            }\n                        }\n                    }\n                }\n            }\n\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), podId, null, null, null, null);\n        } else {\n            final Long cluster = srcHost.getClusterId();\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Searching for all hosts in cluster \" + cluster + \" for migrating VM \" + vm);\n            }\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, null, null, cluster, null, keyword, null, null, null,\n                null, srcHost.getId());\n            allHosts = allHostsPair.first();\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), srcHost.getPodId(), srcHost.getClusterId(), null, null, null);\n        }\n\n        final Pair<List<? extends Host>, Integer> otherHosts = new Pair<List<? extends Host>, Integer>(allHosts, allHostsPair.second());\n        List<Host> suitableHosts = new ArrayList<Host>();\n        final ExcludeList excludes = new ExcludeList();\n        excludes.addHost(srcHostId);\n\n        if (dpdkHelper.isVMDpdkEnabled(vm.getId())) {\n            excludeNonDPDKEnabledHosts(plan, excludes);\n        }\n\n        \r\n        final long vmGroupCount = _affinityGroupVMMapDao.countAffinityGroupsForVm(vm.getId());\n\n        if (vmGroupCount > 0) {\n            for (final AffinityGroupProcessor processor : _affinityProcessors) {\n                processor.process(vmProfile, plan, excludes);\n            }\n        }\n\n        if (vm.getType() == VirtualMachine.Type.User || vm.getType() == VirtualMachine.Type.DomainRouter) {\n            final DataCenterVO dc = _dcDao.findById(srcHost.getDataCenterId());\n            _dpMgr.checkForNonDedicatedResources(vmProfile, dc, excludes);\n        }\n\n        for (final HostAllocator allocator : hostAllocators) {\n            if (canMigrateWithStorage) {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, hostsForMigrationWithStorage, HostAllocator.RETURN_UPTO_ALL, false);\n            } else {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, HostAllocator.RETURN_UPTO_ALL, false);\n            }\n\n            if (suitableHosts != null && !suitableHosts.isEmpty()) {\n                break;\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            if (suitableHosts.isEmpty()) {\n                s_logger.debug(\"No suitable hosts found\");\n            } else {\n                s_logger.debug(\"Hosts having capacity and suitable for migration: \" + suitableHosts);\n            }\n        }\n\n        return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(otherHosts, suitableHosts, requiresStorageMotion);\n    }\n","date":"2021-02-12 15:11:41","endLine":1404,"groupId":"11724","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"listHostsForMigrationOfVM","params":"(finalLongvmId@finalLongstartIndex@finalLongpageSize@finalStringkeyword)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/99/d922181bbb3e14ca1683df265babfe3931b8c4.src","preCode":"    public Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>> listHostsForMigrationOfVM(final Long vmId, final Long startIndex, final Long pageSize,\n            final String keyword) {\n        final Account caller = getCaller();\n        if (!_accountMgr.isRootAdmin(caller.getId())) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Caller is not a root admin, permission denied to migrate the VM\");\n            }\n            throw new PermissionDeniedException(\"No permission to migrate VM, Only Root Admin can migrate a VM!\");\n        }\n\n        final VMInstanceVO vm = _vmInstanceDao.findById(vmId);\n        if (vm == null) {\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the VM with given id\");\n            throw ex;\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not running, cannot migrate the vm\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"VM is not Running, cannot \" + \"migrate the vm with specified id\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        UserVmDetailVO userVmDetailVO = _UserVmDetailsDao.findDetail(vm.getId(), ApiConstants.BootType.UEFI.toString());\n        if (userVmDetailVO != null) {\n            s_logger.info(\" Live Migration of UEFI enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            if (\"legacy\".equalsIgnoreCase(userVmDetailVO.getValue()) || \"secure\".equalsIgnoreCase(userVmDetailVO.getValue())) {\n                \r\n                return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>,\n                        Integer>(new ArrayList<HostVO>(), new Integer(0)), new ArrayList<Host>(), new HashMap<Host, Boolean>());\n            }\n        }\n\n        if (_serviceOfferingDetailsDao.findDetail(vm.getServiceOfferingId(), GPU.Keys.pciDevice.toString()) != null) {\n            s_logger.info(\" Live Migration of GPU enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            \r\n            return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>, Integer>(new ArrayList<HostVO>(), new Integer(0)),\n                    new ArrayList<Host>(), new HashMap<Host, Boolean>());\n        }\n\n        if (!vm.getHypervisorType().equals(HypervisorType.XenServer) && !vm.getHypervisorType().equals(HypervisorType.VMware) && !vm.getHypervisorType().equals(HypervisorType.KVM)\n                && !vm.getHypervisorType().equals(HypervisorType.Ovm) && !vm.getHypervisorType().equals(HypervisorType.Hyperv) && !vm.getHypervisorType().equals(HypervisorType.LXC)\n                && !vm.getHypervisorType().equals(HypervisorType.Simulator) && !vm.getHypervisorType().equals(HypervisorType.Ovm3)) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(vm + \" is not XenServer/VMware/KVM/Ovm/Hyperv/Ovm3, cannot migrate this VM.\");\n            }\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for VM migration, we support \" + \"XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        if (vm.getType().equals(VirtualMachine.Type.User) && vm.getHypervisorType().equals(HypervisorType.LXC)) {\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for User VM migration, we support XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        final long srcHostId = vm.getHostId();\n        final Host srcHost = _hostDao.findById(srcHostId);\n        if (srcHost == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the host with id: \" + srcHostId + \" of this VM:\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the host (with specified id) of VM with specified id\");\n            ex.addProxyObject(String.valueOf(srcHostId), \"hostId\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        \r\n        boolean canMigrateWithStorage = false;\n\n        if (vm.getType() == VirtualMachine.Type.User) {\n            final HypervisorCapabilitiesVO capabilities = _hypervisorCapabilitiesDao.findByHypervisorTypeAndVersion(srcHost.getHypervisorType(), srcHost.getHypervisorVersion());\n            if (capabilities != null) {\n                canMigrateWithStorage = capabilities.isStorageMotionSupported();\n            }\n        }\n\n        \r\n        final VirtualMachineProfile vmProfile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        final List<VolumeVO> volumes = _volumeDao.findCreatedByInstance(vmProfile.getId());\n        boolean usesLocal = false;\n        for (final VolumeVO volume : volumes) {\n            final DiskOfferingVO diskOffering = _diskOfferingDao.findById(volume.getDiskOfferingId());\n            final DiskProfile diskProfile = new DiskProfile(volume, diskOffering, vmProfile.getHypervisorType());\n            if (diskProfile.useLocalStorage()) {\n                usesLocal = true;\n                break;\n            }\n        }\n\n        if (!canMigrateWithStorage && usesLocal) {\n            throw new InvalidParameterValueException(\"Unsupported operation, VM uses Local storage, cannot migrate\");\n        }\n\n        final Type hostType = srcHost.getType();\n        Pair<List<HostVO>, Integer> allHostsPair = null;\n        List<HostVO> allHosts = null;\n        List<HostVO> hostsForMigrationWithStorage = null;\n        final Map<Host, Boolean> requiresStorageMotion = new HashMap<Host, Boolean>();\n        DataCenterDeployment plan = null;\n        if (canMigrateWithStorage) {\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, srcHost.getDataCenterId(), null, null, null, keyword,\n                null, null, srcHost.getHypervisorType(), srcHost.getHypervisorVersion(), srcHost.getId());\n            allHosts = allHostsPair.first();\n            hostsForMigrationWithStorage = new ArrayList<>(allHosts);\n\n            for (final VolumeVO volume : volumes) {\n                StoragePool storagePool = _poolDao.findById(volume.getPoolId());\n                Long volClusterId = storagePool.getClusterId();\n\n                for (Iterator<HostVO> iterator = hostsForMigrationWithStorage.iterator(); iterator.hasNext();) {\n                    final Host host = iterator.next();\n\n                    if (volClusterId != null) {\n                        if (storagePool.isLocal() || !host.getClusterId().equals(volClusterId) || usesLocal) {\n                            if (storagePool.isManaged()) {\n                                \r\n                                \r\n                                \r\n                                \r\n                                \r\n                                iterator.remove();\n                            } else {\n                                if (hasSuitablePoolsForVolume(volume, host, vmProfile)) {\n                                    requiresStorageMotion.put(host, true);\n                                } else {\n                                    iterator.remove();\n                                }\n                            }\n                        }\n                    } else {\n                        if (storagePool.isManaged()) {\n                            if (srcHost.getClusterId() != host.getClusterId()) {\n                                \r\n                                \r\n                                \r\n                                requiresStorageMotion.put(host, true);\n                            }\n                        }\n                    }\n                }\n            }\n\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), null, null, null, null, null);\n        } else {\n            final Long cluster = srcHost.getClusterId();\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Searching for all hosts in cluster \" + cluster + \" for migrating VM \" + vm);\n            }\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, null, null, cluster, null, keyword, null, null, null,\n                null, srcHost.getId());\n            allHosts = allHostsPair.first();\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), srcHost.getPodId(), srcHost.getClusterId(), null, null, null);\n        }\n\n        final Pair<List<? extends Host>, Integer> otherHosts = new Pair<List<? extends Host>, Integer>(allHosts, allHostsPair.second());\n        List<Host> suitableHosts = new ArrayList<Host>();\n        final ExcludeList excludes = new ExcludeList();\n        excludes.addHost(srcHostId);\n\n        if (dpdkHelper.isVMDpdkEnabled(vm.getId())) {\n            excludeNonDPDKEnabledHosts(plan, excludes);\n        }\n\n        \r\n        final long vmGroupCount = _affinityGroupVMMapDao.countAffinityGroupsForVm(vm.getId());\n\n        if (vmGroupCount > 0) {\n            for (final AffinityGroupProcessor processor : _affinityProcessors) {\n                processor.process(vmProfile, plan, excludes);\n            }\n        }\n\n        if (vm.getType() == VirtualMachine.Type.User || vm.getType() == VirtualMachine.Type.DomainRouter) {\n            final DataCenterVO dc = _dcDao.findById(srcHost.getDataCenterId());\n            _dpMgr.checkForNonDedicatedResources(vmProfile, dc, excludes);\n        }\n\n        for (final HostAllocator allocator : hostAllocators) {\n            if (canMigrateWithStorage) {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, hostsForMigrationWithStorage, HostAllocator.RETURN_UPTO_ALL, false);\n            } else {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, HostAllocator.RETURN_UPTO_ALL, false);\n            }\n\n            if (suitableHosts != null && !suitableHosts.isEmpty()) {\n                break;\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            if (suitableHosts.isEmpty()) {\n                s_logger.debug(\"No suitable hosts found\");\n            } else {\n                s_logger.debug(\"Hosts having capacity and suitable for migration: \" + suitableHosts);\n            }\n        }\n\n        return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(otherHosts, suitableHosts, requiresStorageMotion);\n    }\n","realPath":"server/src/main/java/com/cloud/server/ManagementServerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1194,"status":"M"},{"authorDate":"2019-01-25 20:05:13","commitOrder":10,"curCode":"    private boolean isOnSupportedHypevisorForMigration(VMInstanceVO vm) {\n        return (vm.getHypervisorType().equals(HypervisorType.XenServer) ||\n                vm.getHypervisorType().equals(HypervisorType.VMware) ||\n                vm.getHypervisorType().equals(HypervisorType.KVM) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm) ||\n                vm.getHypervisorType().equals(HypervisorType.Hyperv) ||\n                vm.getHypervisorType().equals(HypervisorType.LXC) ||\n                vm.getHypervisorType().equals(HypervisorType.Simulator) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm3));\n    }\n","date":"2019-01-25 20:05:13","endLine":5248,"groupId":"13593","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"isOnSupportedHypevisorForMigration","params":"(VMInstanceVOvm)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/68/b45e1af7c3b5c442bc0dc09dec1aeb5256a58d.src","preCode":"    private boolean isOnSupportedHypevisorForMigration(VMInstanceVO vm) {\n        return (vm.getHypervisorType().equals(HypervisorType.XenServer) ||\n                vm.getHypervisorType().equals(HypervisorType.VMware) ||\n                vm.getHypervisorType().equals(HypervisorType.KVM) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm) ||\n                vm.getHypervisorType().equals(HypervisorType.Hyperv) ||\n                vm.getHypervisorType().equals(HypervisorType.LXC) ||\n                vm.getHypervisorType().equals(HypervisorType.Simulator) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm3));\n    }\n","realPath":"server/src/main/java/com/cloud/vm/UserVmManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":5239,"status":"N"}],"commitId":"d6e8b53736d92363d0f8689997259769356122de","commitMessage":"@@@vmware: vm migration improvements (#4385)\n\n- Fixes inter-cluster migration of VMs\n- Allows migration of stopped VM with disks attached to different and suitable pools\n- Improves inter-cluster detached volume migration\n- Allows inter-cluster migration (clusters of same Pod) for system VMs.  VRs on VMware\n- Allows storage migration for stopped system VMs.  VRs on VMware within same Pod if StoragePool cluster scopetype\n\nLinked Primate PR: https://github.com/apache/cloudstack-primate/pull/789 [Changes merged in this PR after new UI merge]\nDocumentation PR: https://github.com/apache/cloudstack-documentation/pull/170\n\nSigned-off-by: Abhishek Kumar <abhishek.mrt22@gmail.com>","date":"2021-02-12 15:11:41","modifiedFileCount":"26","status":"M","submitter":"Abhishek Kumar"},{"authorTime":"2019-01-25 20:05:13","codes":[{"authorDate":"2021-02-24 17:28:33","commitOrder":11,"curCode":"    public Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>> listHostsForMigrationOfVM(final Long vmId, final Long startIndex, final Long pageSize,\n            final String keyword) {\n        final Account caller = getCaller();\n        if (!_accountMgr.isRootAdmin(caller.getId())) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Caller is not a root admin, permission denied to migrate the VM\");\n            }\n            throw new PermissionDeniedException(\"No permission to migrate VM, Only Root Admin can migrate a VM!\");\n        }\n\n        final VMInstanceVO vm = _vmInstanceDao.findById(vmId);\n        if (vm == null) {\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the VM with given id\");\n            throw ex;\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not running, cannot migrate the vm\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"VM is not Running, cannot \" + \"migrate the vm with specified id\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        UserVmDetailVO userVmDetailVO = _UserVmDetailsDao.findDetail(vm.getId(), ApiConstants.BootType.UEFI.toString());\n        if (userVmDetailVO != null) {\n            s_logger.info(\" Live Migration of UEFI enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            if (\"legacy\".equalsIgnoreCase(userVmDetailVO.getValue()) || \"secure\".equalsIgnoreCase(userVmDetailVO.getValue())) {\n                \r\n                return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>,\n                        Integer>(new ArrayList<HostVO>(), new Integer(0)), new ArrayList<Host>(), new HashMap<Host, Boolean>());\n            }\n        }\n\n        if (_serviceOfferingDetailsDao.findDetail(vm.getServiceOfferingId(), GPU.Keys.pciDevice.toString()) != null) {\n            s_logger.info(\" Live Migration of GPU enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            \r\n            return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>, Integer>(new ArrayList<HostVO>(), new Integer(0)),\n                    new ArrayList<Host>(), new HashMap<Host, Boolean>());\n        }\n\n        if (!vm.getHypervisorType().equals(HypervisorType.XenServer) && !vm.getHypervisorType().equals(HypervisorType.VMware) && !vm.getHypervisorType().equals(HypervisorType.KVM)\n                && !vm.getHypervisorType().equals(HypervisorType.Ovm) && !vm.getHypervisorType().equals(HypervisorType.Hyperv) && !vm.getHypervisorType().equals(HypervisorType.LXC)\n                && !vm.getHypervisorType().equals(HypervisorType.Simulator) && !vm.getHypervisorType().equals(HypervisorType.Ovm3)) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(vm + \" is not XenServer/VMware/KVM/Ovm/Hyperv/Ovm3, cannot migrate this VM.\");\n            }\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for VM migration, we support \" + \"XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        if (vm.getType().equals(VirtualMachine.Type.User) && vm.getHypervisorType().equals(HypervisorType.LXC)) {\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for User VM migration, we support XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        final long srcHostId = vm.getHostId();\n        final Host srcHost = _hostDao.findById(srcHostId);\n        if (srcHost == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the host with id: \" + srcHostId + \" of this VM:\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the host (with specified id) of VM with specified id\");\n            ex.addProxyObject(String.valueOf(srcHostId), \"hostId\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n        String srcHostVersion = srcHost.getHypervisorVersion();\n        if (HypervisorType.KVM.equals(srcHost.getHypervisorType()) && srcHostVersion == null) {\n            srcHostVersion = \"\";\n        }\n\n        \r\n        boolean canMigrateWithStorage = false;\n\n        if (VirtualMachine.Type.User.equals(vm.getType()) || HypervisorType.VMware.equals(vm.getHypervisorType())) {\n            canMigrateWithStorage = Boolean.TRUE.equals(_hypervisorCapabilitiesDao.isStorageMotionSupported(srcHost.getHypervisorType(), srcHostVersion));\n        }\n\n        \r\n        final VirtualMachineProfile vmProfile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        final List<VolumeVO> volumes = _volumeDao.findCreatedByInstance(vmProfile.getId());\n        boolean usesLocal = false;\n        for (final VolumeVO volume : volumes) {\n            final DiskOfferingVO diskOffering = _diskOfferingDao.findById(volume.getDiskOfferingId());\n            final DiskProfile diskProfile = new DiskProfile(volume, diskOffering, vmProfile.getHypervisorType());\n            if (diskProfile.useLocalStorage()) {\n                usesLocal = true;\n                break;\n            }\n        }\n\n        if (!canMigrateWithStorage && usesLocal) {\n            throw new InvalidParameterValueException(\"Unsupported operation, VM uses Local storage, cannot migrate\");\n        }\n\n        final Type hostType = srcHost.getType();\n        Pair<List<HostVO>, Integer> allHostsPair = null;\n        List<HostVO> allHosts = null;\n        List<HostVO> hostsForMigrationWithStorage = null;\n        final Map<Host, Boolean> requiresStorageMotion = new HashMap<Host, Boolean>();\n        DataCenterDeployment plan = null;\n        if (canMigrateWithStorage) {\n            Long podId = !VirtualMachine.Type.User.equals(vm.getType()) ? srcHost.getPodId() : null;\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, srcHost.getDataCenterId(), podId, null, null, keyword,\n                null, null, srcHost.getHypervisorType(), null, srcHost.getId());\n            allHosts = allHostsPair.first();\n            hostsForMigrationWithStorage = new ArrayList<>(allHosts);\n\n            for (final VolumeVO volume : volumes) {\n                StoragePool storagePool = _poolDao.findById(volume.getPoolId());\n                Long volClusterId = storagePool.getClusterId();\n\n                for (Iterator<HostVO> iterator = hostsForMigrationWithStorage.iterator(); iterator.hasNext();) {\n                    final Host host = iterator.next();\n                    String hostVersion = host.getHypervisorVersion();\n                    if (HypervisorType.KVM.equals(host.getHypervisorType()) && hostVersion == null) {\n                        hostVersion = \"\";\n                    }\n\n                    if (volClusterId != null) {\n                        if (storagePool.isLocal() || !host.getClusterId().equals(volClusterId) || usesLocal) {\n                            if (storagePool.isManaged()) {\n                                \r\n                                \r\n                                \r\n                                \r\n                                \r\n                                iterator.remove();\n                            } else {\n                                boolean hostSupportsStorageMigration = false;\n                                if ((srcHostVersion != null && srcHostVersion.equals(hostVersion)) ||\n                                        Boolean.TRUE.equals(_hypervisorCapabilitiesDao.isStorageMotionSupported(host.getHypervisorType(), hostVersion))) {\n                                    hostSupportsStorageMigration = true;\n                                }\n                                if (hostSupportsStorageMigration && hasSuitablePoolsForVolume(volume, host, vmProfile)) {\n                                    requiresStorageMotion.put(host, true);\n                                } else {\n                                    iterator.remove();\n                                }\n                            }\n                        }\n                    } else {\n                        if (storagePool.isManaged()) {\n                            if (srcHost.getClusterId() != host.getClusterId()) {\n                                if (storagePool.getPoolType() == Storage.StoragePoolType.PowerFlex) {\n                                    \r\n                                    \r\n                                    continue;\n                                }\n                                \r\n                                \r\n                                \r\n                                requiresStorageMotion.put(host, true);\n                            }\n                        }\n                    }\n                }\n            }\n\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), podId, null, null, null, null);\n        } else {\n            final Long cluster = srcHost.getClusterId();\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Searching for all hosts in cluster \" + cluster + \" for migrating VM \" + vm);\n            }\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, null, null, cluster, null, keyword, null, null, null,\n                null, srcHost.getId());\n            allHosts = allHostsPair.first();\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), srcHost.getPodId(), srcHost.getClusterId(), null, null, null);\n        }\n\n        final Pair<List<? extends Host>, Integer> otherHosts = new Pair<List<? extends Host>, Integer>(allHosts, allHostsPair.second());\n        List<Host> suitableHosts = new ArrayList<Host>();\n        final ExcludeList excludes = new ExcludeList();\n        excludes.addHost(srcHostId);\n\n        if (dpdkHelper.isVMDpdkEnabled(vm.getId())) {\n            excludeNonDPDKEnabledHosts(plan, excludes);\n        }\n\n        \r\n        final long vmGroupCount = _affinityGroupVMMapDao.countAffinityGroupsForVm(vm.getId());\n\n        if (vmGroupCount > 0) {\n            for (final AffinityGroupProcessor processor : _affinityProcessors) {\n                processor.process(vmProfile, plan, excludes);\n            }\n        }\n\n        if (vm.getType() == VirtualMachine.Type.User || vm.getType() == VirtualMachine.Type.DomainRouter) {\n            final DataCenterVO dc = _dcDao.findById(srcHost.getDataCenterId());\n            _dpMgr.checkForNonDedicatedResources(vmProfile, dc, excludes);\n        }\n\n        for (final HostAllocator allocator : hostAllocators) {\n            if (canMigrateWithStorage) {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, hostsForMigrationWithStorage, HostAllocator.RETURN_UPTO_ALL, false);\n            } else {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, HostAllocator.RETURN_UPTO_ALL, false);\n            }\n\n            if (suitableHosts != null && !suitableHosts.isEmpty()) {\n                break;\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            if (suitableHosts.isEmpty()) {\n                s_logger.debug(\"No suitable hosts found\");\n            } else {\n                s_logger.debug(\"Hosts having capacity and suitable for migration: \" + suitableHosts);\n            }\n        }\n\n        return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(otherHosts, suitableHosts, requiresStorageMotion);\n    }\n","date":"2021-02-24 17:28:33","endLine":1413,"groupId":"11724","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"listHostsForMigrationOfVM","params":"(finalLongvmId@finalLongstartIndex@finalLongpageSize@finalStringkeyword)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/7c/0cba346e986b6d1ca407775d9a8ff2b56e35bc.src","preCode":"    public Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>> listHostsForMigrationOfVM(final Long vmId, final Long startIndex, final Long pageSize,\n            final String keyword) {\n        final Account caller = getCaller();\n        if (!_accountMgr.isRootAdmin(caller.getId())) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Caller is not a root admin, permission denied to migrate the VM\");\n            }\n            throw new PermissionDeniedException(\"No permission to migrate VM, Only Root Admin can migrate a VM!\");\n        }\n\n        final VMInstanceVO vm = _vmInstanceDao.findById(vmId);\n        if (vm == null) {\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the VM with given id\");\n            throw ex;\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not running, cannot migrate the vm\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"VM is not Running, cannot \" + \"migrate the vm with specified id\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        UserVmDetailVO userVmDetailVO = _UserVmDetailsDao.findDetail(vm.getId(), ApiConstants.BootType.UEFI.toString());\n        if (userVmDetailVO != null) {\n            s_logger.info(\" Live Migration of UEFI enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            if (\"legacy\".equalsIgnoreCase(userVmDetailVO.getValue()) || \"secure\".equalsIgnoreCase(userVmDetailVO.getValue())) {\n                \r\n                return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>,\n                        Integer>(new ArrayList<HostVO>(), new Integer(0)), new ArrayList<Host>(), new HashMap<Host, Boolean>());\n            }\n        }\n\n        if (_serviceOfferingDetailsDao.findDetail(vm.getServiceOfferingId(), GPU.Keys.pciDevice.toString()) != null) {\n            s_logger.info(\" Live Migration of GPU enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            \r\n            return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>, Integer>(new ArrayList<HostVO>(), new Integer(0)),\n                    new ArrayList<Host>(), new HashMap<Host, Boolean>());\n        }\n\n        if (!vm.getHypervisorType().equals(HypervisorType.XenServer) && !vm.getHypervisorType().equals(HypervisorType.VMware) && !vm.getHypervisorType().equals(HypervisorType.KVM)\n                && !vm.getHypervisorType().equals(HypervisorType.Ovm) && !vm.getHypervisorType().equals(HypervisorType.Hyperv) && !vm.getHypervisorType().equals(HypervisorType.LXC)\n                && !vm.getHypervisorType().equals(HypervisorType.Simulator) && !vm.getHypervisorType().equals(HypervisorType.Ovm3)) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(vm + \" is not XenServer/VMware/KVM/Ovm/Hyperv/Ovm3, cannot migrate this VM.\");\n            }\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for VM migration, we support \" + \"XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        if (vm.getType().equals(VirtualMachine.Type.User) && vm.getHypervisorType().equals(HypervisorType.LXC)) {\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for User VM migration, we support XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        final long srcHostId = vm.getHostId();\n        final Host srcHost = _hostDao.findById(srcHostId);\n        if (srcHost == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the host with id: \" + srcHostId + \" of this VM:\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the host (with specified id) of VM with specified id\");\n            ex.addProxyObject(String.valueOf(srcHostId), \"hostId\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n        String srcHostVersion = srcHost.getHypervisorVersion();\n        if (HypervisorType.KVM.equals(srcHost.getHypervisorType()) && srcHostVersion == null) {\n            srcHostVersion = \"\";\n        }\n\n        \r\n        boolean canMigrateWithStorage = false;\n\n        if (VirtualMachine.Type.User.equals(vm.getType()) || HypervisorType.VMware.equals(vm.getHypervisorType())) {\n            canMigrateWithStorage = Boolean.TRUE.equals(_hypervisorCapabilitiesDao.isStorageMotionSupported(srcHost.getHypervisorType(), srcHostVersion));\n        }\n\n        \r\n        final VirtualMachineProfile vmProfile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        final List<VolumeVO> volumes = _volumeDao.findCreatedByInstance(vmProfile.getId());\n        boolean usesLocal = false;\n        for (final VolumeVO volume : volumes) {\n            final DiskOfferingVO diskOffering = _diskOfferingDao.findById(volume.getDiskOfferingId());\n            final DiskProfile diskProfile = new DiskProfile(volume, diskOffering, vmProfile.getHypervisorType());\n            if (diskProfile.useLocalStorage()) {\n                usesLocal = true;\n                break;\n            }\n        }\n\n        if (!canMigrateWithStorage && usesLocal) {\n            throw new InvalidParameterValueException(\"Unsupported operation, VM uses Local storage, cannot migrate\");\n        }\n\n        final Type hostType = srcHost.getType();\n        Pair<List<HostVO>, Integer> allHostsPair = null;\n        List<HostVO> allHosts = null;\n        List<HostVO> hostsForMigrationWithStorage = null;\n        final Map<Host, Boolean> requiresStorageMotion = new HashMap<Host, Boolean>();\n        DataCenterDeployment plan = null;\n        if (canMigrateWithStorage) {\n            Long podId = !VirtualMachine.Type.User.equals(vm.getType()) ? srcHost.getPodId() : null;\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, srcHost.getDataCenterId(), podId, null, null, keyword,\n                null, null, srcHost.getHypervisorType(), null, srcHost.getId());\n            allHosts = allHostsPair.first();\n            hostsForMigrationWithStorage = new ArrayList<>(allHosts);\n\n            for (final VolumeVO volume : volumes) {\n                StoragePool storagePool = _poolDao.findById(volume.getPoolId());\n                Long volClusterId = storagePool.getClusterId();\n\n                for (Iterator<HostVO> iterator = hostsForMigrationWithStorage.iterator(); iterator.hasNext();) {\n                    final Host host = iterator.next();\n                    String hostVersion = host.getHypervisorVersion();\n                    if (HypervisorType.KVM.equals(host.getHypervisorType()) && hostVersion == null) {\n                        hostVersion = \"\";\n                    }\n\n                    if (volClusterId != null) {\n                        if (storagePool.isLocal() || !host.getClusterId().equals(volClusterId) || usesLocal) {\n                            if (storagePool.isManaged()) {\n                                \r\n                                \r\n                                \r\n                                \r\n                                \r\n                                iterator.remove();\n                            } else {\n                                boolean hostSupportsStorageMigration = false;\n                                if ((srcHostVersion != null && srcHostVersion.equals(hostVersion)) ||\n                                        Boolean.TRUE.equals(_hypervisorCapabilitiesDao.isStorageMotionSupported(host.getHypervisorType(), hostVersion))) {\n                                    hostSupportsStorageMigration = true;\n                                }\n                                if (hostSupportsStorageMigration && hasSuitablePoolsForVolume(volume, host, vmProfile)) {\n                                    requiresStorageMotion.put(host, true);\n                                } else {\n                                    iterator.remove();\n                                }\n                            }\n                        }\n                    } else {\n                        if (storagePool.isManaged()) {\n                            if (srcHost.getClusterId() != host.getClusterId()) {\n                                \r\n                                \r\n                                \r\n                                requiresStorageMotion.put(host, true);\n                            }\n                        }\n                    }\n                }\n            }\n\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), podId, null, null, null, null);\n        } else {\n            final Long cluster = srcHost.getClusterId();\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Searching for all hosts in cluster \" + cluster + \" for migrating VM \" + vm);\n            }\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, null, null, cluster, null, keyword, null, null, null,\n                null, srcHost.getId());\n            allHosts = allHostsPair.first();\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), srcHost.getPodId(), srcHost.getClusterId(), null, null, null);\n        }\n\n        final Pair<List<? extends Host>, Integer> otherHosts = new Pair<List<? extends Host>, Integer>(allHosts, allHostsPair.second());\n        List<Host> suitableHosts = new ArrayList<Host>();\n        final ExcludeList excludes = new ExcludeList();\n        excludes.addHost(srcHostId);\n\n        if (dpdkHelper.isVMDpdkEnabled(vm.getId())) {\n            excludeNonDPDKEnabledHosts(plan, excludes);\n        }\n\n        \r\n        final long vmGroupCount = _affinityGroupVMMapDao.countAffinityGroupsForVm(vm.getId());\n\n        if (vmGroupCount > 0) {\n            for (final AffinityGroupProcessor processor : _affinityProcessors) {\n                processor.process(vmProfile, plan, excludes);\n            }\n        }\n\n        if (vm.getType() == VirtualMachine.Type.User || vm.getType() == VirtualMachine.Type.DomainRouter) {\n            final DataCenterVO dc = _dcDao.findById(srcHost.getDataCenterId());\n            _dpMgr.checkForNonDedicatedResources(vmProfile, dc, excludes);\n        }\n\n        for (final HostAllocator allocator : hostAllocators) {\n            if (canMigrateWithStorage) {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, hostsForMigrationWithStorage, HostAllocator.RETURN_UPTO_ALL, false);\n            } else {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, HostAllocator.RETURN_UPTO_ALL, false);\n            }\n\n            if (suitableHosts != null && !suitableHosts.isEmpty()) {\n                break;\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            if (suitableHosts.isEmpty()) {\n                s_logger.debug(\"No suitable hosts found\");\n            } else {\n                s_logger.debug(\"Hosts having capacity and suitable for migration: \" + suitableHosts);\n            }\n        }\n\n        return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(otherHosts, suitableHosts, requiresStorageMotion);\n    }\n","realPath":"server/src/main/java/com/cloud/server/ManagementServerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1198,"status":"M"},{"authorDate":"2019-01-25 20:05:13","commitOrder":11,"curCode":"    private boolean isOnSupportedHypevisorForMigration(VMInstanceVO vm) {\n        return (vm.getHypervisorType().equals(HypervisorType.XenServer) ||\n                vm.getHypervisorType().equals(HypervisorType.VMware) ||\n                vm.getHypervisorType().equals(HypervisorType.KVM) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm) ||\n                vm.getHypervisorType().equals(HypervisorType.Hyperv) ||\n                vm.getHypervisorType().equals(HypervisorType.LXC) ||\n                vm.getHypervisorType().equals(HypervisorType.Simulator) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm3));\n    }\n","date":"2019-01-25 20:05:13","endLine":5248,"groupId":"13593","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"isOnSupportedHypevisorForMigration","params":"(VMInstanceVOvm)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/68/b45e1af7c3b5c442bc0dc09dec1aeb5256a58d.src","preCode":"    private boolean isOnSupportedHypevisorForMigration(VMInstanceVO vm) {\n        return (vm.getHypervisorType().equals(HypervisorType.XenServer) ||\n                vm.getHypervisorType().equals(HypervisorType.VMware) ||\n                vm.getHypervisorType().equals(HypervisorType.KVM) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm) ||\n                vm.getHypervisorType().equals(HypervisorType.Hyperv) ||\n                vm.getHypervisorType().equals(HypervisorType.LXC) ||\n                vm.getHypervisorType().equals(HypervisorType.Simulator) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm3));\n    }\n","realPath":"server/src/main/java/com/cloud/vm/UserVmManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":5239,"status":"N"}],"commitId":"eba186aa40f16911c019bf06cd33d7d0cbbc303b","commitMessage":"@@@storage: New Dell EMC PowerFlex Plugin (formerly ScaleIO.  VxFlexOS) (#4304)\n\nAdded support for PowerFlex/ScaleIO (v3.5 onwards) storage pool as a primary storage in CloudStack (for KVM hypervisor) and enabled VM/Volume operations on that pool (using pool tag).\nPlease find more details in the FS here:\nhttps://cwiki.apache.org/confluence/x/cDl4CQ\n\nDocumentation PR: apache/cloudstack-documentation#169\n\nThis enables support for PowerFlex/ScaleIO (v3.5 onwards) storage pool as a primary storage in CloudStack\n\nOther improvements addressed in addition to PowerFlex/ScaleIO support:\n\n- Added support for config drives in host cache for KVM\n\t=> Changed configuration \"vm.configdrive.primarypool.enabled\" scope from Global to Zone level\n\t=> Introduced new zone level configuration \"vm.configdrive.force.host.cache.use\" (default: false) to force host cache for config drives\n\t=> Introduced new zone level configuration \"vm.configdrive.use.host.cache.on.unsupported.pool\" (default: true) to use host cache for config drives when storage pool doesn't support config drive\n\t=> Added new parameter \"host.cache.location\" (default: /var/cache/cloud) in KVM agent.properties for specifying the host cache path and create config drives on the \"/config\" directory on the host cache path\n\t=> Maintain the config drive location and use it when required on any config drive operation (migrate.  delete)\n\n- Detect virtual size from the template URL while registering direct download qcow2 (of KVM hypervisor) templates\n\n- Updated full deployment destination for preparing the network(s) on VM start\n\n- Propagate the direct download certificates uploaded to the newly added KVM hosts\n\n- Discover the template size for direct download templates using any available host from the zones specified on template registration\n\t=> When zones are not specified while registering template.  template size discovery is performed using any available host.  which is picked up randomly from one of the available zones\n\n- Release the VM resources when VM is sync-ed to Stopped state on PowerReportMissing (after graceful period)\n\n- Retry VM deployment/start when the host cannot grant access to volume/template\n\n- Mark never-used or downloaded templates as Destroyed on deletion.  without sending any DeleteCommand\n\t=> Do not trigger any DeleteCommand for never-used or downloaded templates as these doesn't exist and cannot be deleted from the datastore\n\n- Check the router filesystem is writable or not.  before performing health checks\n\t=> Introduce a new test \"filesystem.writable.test\" to check the filesystem is writable or not\n\t=> The router health checks keeps the config info at \"/var/cache/cloud\" and updates the monitor results at \"/root\" for health checks.  both are different partitions. So.  test at both the locations.\n\t=> Added new script: \"filesystem_writable_check.py\" at /opt/cloud/bin/ to check the filesystem is writable or not\n\n- Fixed NPE issue.  template is null for DATA disks. Copy template to target storage for ROOT disk (with template id).  skip DATA disk(s)\n\n* Addressed some issues for few operations on PowerFlex storage pool.\n\n- Updated migration volume operation to sync the status and wait for migration to complete.\n\n- Updated VM Snapshot naming.  for uniqueness in ScaleIO volume name when more than one volume exists in the VM.\n\n- Added sync lock while spooling managed storage template before volume creation from the template (non-direct download).\n\n- Updated resize volume error message string.\n\n- Blocked the below operations on PowerFlex storage pool:\n  -> Extract Volume\n  -> Create Snapshot for VMSnapshot\n\n* Added the PowerFlex/ScaleIO client connection pool to manage the ScaleIO gateway clients.  which uses a single gateway client per Powerflex/ScaleIO storage pool and renews it when the session token expires.\n\n- The token is valid for 8 hours from the time it was created.  unless there has been no activity for 10 minutes.\n  Reference: https://cpsdocs.dellemc.com/bundle/PF_REST_API_RG/page/GUID-92430F19-9F44-42B6-B898-87D5307AE59B.html\n\nOther fixes included:\n\n- Fail the VM deployment when the host specified in the deployVirtualMachine cmd is not in the right state (i.e. either Resource State is not Enabled or Status is not Up)\n\n- Use the physical file size of the template to check the free space availability on the host.  while downloading the direct download templates.\n\n- Perform basic tests (for connectivity and file system) on router before updating the health check config data\n\t=> Validate the basic tests (connectivity and file system check) on router\n\t=> Cleanup the health check results when router is destroyed\n\n* Updated PowerFlex/ScaleIO storage plugin version to 4.16.0.0\n\n* UI Changes to support storage plugin for PowerFlex/ScaleIO storage pool.\n- PowerFlex pool URL generated from the UI inputs(Gateway.  Username.  Password.  Storage Pool) when adding \"PowerFlex\" Primary Storage\n- Updated protocol to \"custom\" for PowerFlex provider\n- Allow VM Snapshot for stopped VM on KVM hypervisor and PowerFlex/ScaleIO storage pool\n\nand Minor improvements in PowerFlex/ScaleIO storage plugin code\n\n* Added support for PowerFlex/ScaleIO volume migration across different PowerFlex storage instances.\n\n- findStoragePoolsForMigration API returns PowerFlex pool(s) of different instance as suitable pool(s).  for volume(s) on PowerFlex storage pool.\n- Volume(s) with snapshots are not allowed to migrate to different PowerFlex instance.\n- Volume(s) of running VM are not allowed to migrate to other PowerFlex storage pools.\n- Volume migration from PowerFlex pool to Non-PowerFlex pool.  and vice versa are not supported.\n\n* Fixed change service offering smoke tests in test_service_offerings.py.  test_vm_snapshots.py\n\n* Added the PowerFlex/ScaleIO volume/snapshot name to the paths of respective CloudStack resources (Templates.  Volumes.  Snapshots and VM Snapshots)\n\n* Added new response parameter ?supportsStorageSnapshot? (true/false) to volume response.  and Updated UI to hide the async backup option while taking snapshot for volume(s) with storage snapshot support.\n\n* Fix to remove the duplicate zone wide pools listed while finding storage pools for migration\n\n* Updated PowerFlex/ScaleIO volume migration checks and rollback migration on failure\n\n* Fixed the PowerFlex/ScaleIO volume name inconsistency issue in the volume path after migration.  due to rename failure","date":"2021-02-24 17:28:33","modifiedFileCount":"112","status":"M","submitter":"sureshanaparti"},{"authorTime":"2019-01-25 20:05:13","codes":[{"authorDate":"2021-07-15 15:27:13","commitOrder":12,"curCode":"    public Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>> listHostsForMigrationOfVM(final Long vmId, final Long startIndex, final Long pageSize,\n            final String keyword) {\n        final Account caller = getCaller();\n        if (!_accountMgr.isRootAdmin(caller.getId())) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Caller is not a root admin, permission denied to migrate the VM\");\n            }\n            throw new PermissionDeniedException(\"No permission to migrate VM, Only Root Admin can migrate a VM!\");\n        }\n\n        final VMInstanceVO vm = _vmInstanceDao.findById(vmId);\n        if (vm == null) {\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the VM with given id\");\n            throw ex;\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not running, cannot migrate the vm\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"VM is not Running, cannot \" + \"migrate the vm with specified id\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        UserVmDetailVO userVmDetailVO = _UserVmDetailsDao.findDetail(vm.getId(), ApiConstants.BootType.UEFI.toString());\n        if (userVmDetailVO != null) {\n            s_logger.info(\" Live Migration of UEFI enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            if (\"legacy\".equalsIgnoreCase(userVmDetailVO.getValue()) || \"secure\".equalsIgnoreCase(userVmDetailVO.getValue())) {\n                \r\n                return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>,\n                        Integer>(new ArrayList<HostVO>(), new Integer(0)), new ArrayList<Host>(), new HashMap<Host, Boolean>());\n            }\n        }\n\n        if (_serviceOfferingDetailsDao.findDetail(vm.getServiceOfferingId(), GPU.Keys.pciDevice.toString()) != null) {\n            s_logger.info(\" Live Migration of GPU enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            \r\n            return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>, Integer>(new ArrayList<HostVO>(), new Integer(0)),\n                    new ArrayList<Host>(), new HashMap<Host, Boolean>());\n        }\n\n        if (!vm.getHypervisorType().equals(HypervisorType.XenServer) && !vm.getHypervisorType().equals(HypervisorType.VMware) && !vm.getHypervisorType().equals(HypervisorType.KVM)\n                && !vm.getHypervisorType().equals(HypervisorType.Ovm) && !vm.getHypervisorType().equals(HypervisorType.Hyperv) && !vm.getHypervisorType().equals(HypervisorType.LXC)\n                && !vm.getHypervisorType().equals(HypervisorType.Simulator) && !vm.getHypervisorType().equals(HypervisorType.Ovm3)) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(vm + \" is not XenServer/VMware/KVM/Ovm/Hyperv/Ovm3, cannot migrate this VM.\");\n            }\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for VM migration, we support \" + \"XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        if (vm.getType().equals(VirtualMachine.Type.User) && vm.getHypervisorType().equals(HypervisorType.LXC)) {\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for User VM migration, we support XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        final long srcHostId = vm.getHostId();\n        final Host srcHost = _hostDao.findById(srcHostId);\n        if (srcHost == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the host with id: \" + srcHostId + \" of this VM:\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the host (with specified id) of VM with specified id\");\n            ex.addProxyObject(String.valueOf(srcHostId), \"hostId\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n        String srcHostVersion = srcHost.getHypervisorVersion();\n        if (HypervisorType.KVM.equals(srcHost.getHypervisorType()) && srcHostVersion == null) {\n            srcHostVersion = \"\";\n        }\n\n        \r\n        boolean canMigrateWithStorage = false;\n\n        if (VirtualMachine.Type.User.equals(vm.getType()) || HypervisorType.VMware.equals(vm.getHypervisorType())) {\n            canMigrateWithStorage = _hypervisorCapabilitiesDao.isStorageMotionSupported(srcHost.getHypervisorType(), srcHostVersion);\n        }\n\n        \r\n        final VirtualMachineProfile vmProfile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        final List<VolumeVO> volumes = _volumeDao.findCreatedByInstance(vmProfile.getId());\n        boolean usesLocal = false;\n        for (final VolumeVO volume : volumes) {\n            final DiskOfferingVO diskOffering = _diskOfferingDao.findById(volume.getDiskOfferingId());\n            final DiskProfile diskProfile = new DiskProfile(volume, diskOffering, vmProfile.getHypervisorType());\n            if (diskProfile.useLocalStorage()) {\n                usesLocal = true;\n                break;\n            }\n        }\n\n        if (!canMigrateWithStorage && usesLocal) {\n            throw new InvalidParameterValueException(\"Unsupported operation, VM uses Local storage, cannot migrate\");\n        }\n\n        final Type hostType = srcHost.getType();\n        Pair<List<HostVO>, Integer> allHostsPair = null;\n        List<HostVO> allHosts = null;\n        List<HostVO> hostsForMigrationWithStorage = null;\n        final Map<Host, Boolean> requiresStorageMotion = new HashMap<Host, Boolean>();\n        DataCenterDeployment plan = null;\n        if (canMigrateWithStorage) {\n            Long podId = !VirtualMachine.Type.User.equals(vm.getType()) ? srcHost.getPodId() : null;\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, srcHost.getDataCenterId(), podId, null, null, keyword,\n                null, null, srcHost.getHypervisorType(), null, srcHost.getId());\n            allHosts = allHostsPair.first();\n            hostsForMigrationWithStorage = new ArrayList<>(allHosts);\n\n            for (final VolumeVO volume : volumes) {\n                StoragePool storagePool = _poolDao.findById(volume.getPoolId());\n                Long volClusterId = storagePool.getClusterId();\n\n                for (Iterator<HostVO> iterator = hostsForMigrationWithStorage.iterator(); iterator.hasNext();) {\n                    final Host host = iterator.next();\n                    String hostVersion = host.getHypervisorVersion();\n                    if (HypervisorType.KVM.equals(host.getHypervisorType()) && hostVersion == null) {\n                        hostVersion = \"\";\n                    }\n\n                    if (volClusterId != null) {\n                        if (storagePool.isLocal() || !host.getClusterId().equals(volClusterId) || usesLocal) {\n                            if (storagePool.isManaged()) {\n                                \r\n                                \r\n                                \r\n                                \r\n                                \r\n                                iterator.remove();\n                            } else {\n                                boolean hostSupportsStorageMigration = (srcHostVersion != null && srcHostVersion.equals(hostVersion)) ||\n                                        _hypervisorCapabilitiesDao.isStorageMotionSupported(host.getHypervisorType(), hostVersion);\n                                if (hostSupportsStorageMigration && hasSuitablePoolsForVolume(volume, host, vmProfile)) {\n                                    requiresStorageMotion.put(host, true);\n                                } else {\n                                    iterator.remove();\n                                }\n                            }\n                        }\n                    } else {\n                        if (storagePool.isManaged()) {\n                            if (srcHost.getClusterId() != host.getClusterId()) {\n                                if (storagePool.getPoolType() == Storage.StoragePoolType.PowerFlex) {\n                                    \r\n                                    \r\n                                    continue;\n                                }\n                                \r\n                                \r\n                                \r\n                                requiresStorageMotion.put(host, true);\n                            }\n                        }\n                    }\n                }\n            }\n\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), podId, null, null, null, null);\n        } else {\n            final Long cluster = srcHost.getClusterId();\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Searching for all hosts in cluster \" + cluster + \" for migrating VM \" + vm);\n            }\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, null, null, cluster, null, keyword, null, null, null,\n                null, srcHost.getId());\n            allHosts = allHostsPair.first();\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), srcHost.getPodId(), srcHost.getClusterId(), null, null, null);\n        }\n\n        final Pair<List<? extends Host>, Integer> otherHosts = new Pair<List<? extends Host>, Integer>(allHosts, allHostsPair.second());\n        List<Host> suitableHosts = new ArrayList<Host>();\n        final ExcludeList excludes = new ExcludeList();\n        excludes.addHost(srcHostId);\n\n        if (dpdkHelper.isVMDpdkEnabled(vm.getId())) {\n            excludeNonDPDKEnabledHosts(plan, excludes);\n        }\n\n        \r\n        final long vmGroupCount = _affinityGroupVMMapDao.countAffinityGroupsForVm(vm.getId());\n\n        if (vmGroupCount > 0) {\n            for (final AffinityGroupProcessor processor : _affinityProcessors) {\n                processor.process(vmProfile, plan, excludes);\n            }\n        }\n\n        if (vm.getType() == VirtualMachine.Type.User || vm.getType() == VirtualMachine.Type.DomainRouter) {\n            final DataCenterVO dc = _dcDao.findById(srcHost.getDataCenterId());\n            _dpMgr.checkForNonDedicatedResources(vmProfile, dc, excludes);\n        }\n\n        for (final HostAllocator allocator : hostAllocators) {\n            if (canMigrateWithStorage) {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, hostsForMigrationWithStorage, HostAllocator.RETURN_UPTO_ALL, false);\n            } else {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, HostAllocator.RETURN_UPTO_ALL, false);\n            }\n\n            if (suitableHosts != null && !suitableHosts.isEmpty()) {\n                break;\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            if (suitableHosts.isEmpty()) {\n                s_logger.debug(\"No suitable hosts found\");\n            } else {\n                s_logger.debug(\"Hosts having capacity and suitable for migration: \" + suitableHosts);\n            }\n        }\n\n        return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(otherHosts, suitableHosts, requiresStorageMotion);\n    }\n","date":"2021-07-15 15:27:13","endLine":1431,"groupId":"101312","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"listHostsForMigrationOfVM","params":"(finalLongvmId@finalLongstartIndex@finalLongpageSize@finalStringkeyword)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/1d/8c74053b15f84bfad842524dad58b63eb86588.src","preCode":"    public Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>> listHostsForMigrationOfVM(final Long vmId, final Long startIndex, final Long pageSize,\n            final String keyword) {\n        final Account caller = getCaller();\n        if (!_accountMgr.isRootAdmin(caller.getId())) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Caller is not a root admin, permission denied to migrate the VM\");\n            }\n            throw new PermissionDeniedException(\"No permission to migrate VM, Only Root Admin can migrate a VM!\");\n        }\n\n        final VMInstanceVO vm = _vmInstanceDao.findById(vmId);\n        if (vm == null) {\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the VM with given id\");\n            throw ex;\n        }\n\n        if (vm.getState() != State.Running) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is not running, cannot migrate the vm\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"VM is not Running, cannot \" + \"migrate the vm with specified id\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n\n        UserVmDetailVO userVmDetailVO = _UserVmDetailsDao.findDetail(vm.getId(), ApiConstants.BootType.UEFI.toString());\n        if (userVmDetailVO != null) {\n            s_logger.info(\" Live Migration of UEFI enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            if (\"legacy\".equalsIgnoreCase(userVmDetailVO.getValue()) || \"secure\".equalsIgnoreCase(userVmDetailVO.getValue())) {\n                \r\n                return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>,\n                        Integer>(new ArrayList<HostVO>(), new Integer(0)), new ArrayList<Host>(), new HashMap<Host, Boolean>());\n            }\n        }\n\n        if (_serviceOfferingDetailsDao.findDetail(vm.getServiceOfferingId(), GPU.Keys.pciDevice.toString()) != null) {\n            s_logger.info(\" Live Migration of GPU enabled VM : \" + vm.getInstanceName() + \" is not supported\");\n            \r\n            return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(new Pair<List<? extends Host>, Integer>(new ArrayList<HostVO>(), new Integer(0)),\n                    new ArrayList<Host>(), new HashMap<Host, Boolean>());\n        }\n\n        if (!vm.getHypervisorType().equals(HypervisorType.XenServer) && !vm.getHypervisorType().equals(HypervisorType.VMware) && !vm.getHypervisorType().equals(HypervisorType.KVM)\n                && !vm.getHypervisorType().equals(HypervisorType.Ovm) && !vm.getHypervisorType().equals(HypervisorType.Hyperv) && !vm.getHypervisorType().equals(HypervisorType.LXC)\n                && !vm.getHypervisorType().equals(HypervisorType.Simulator) && !vm.getHypervisorType().equals(HypervisorType.Ovm3)) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(vm + \" is not XenServer/VMware/KVM/Ovm/Hyperv/Ovm3, cannot migrate this VM.\");\n            }\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for VM migration, we support \" + \"XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        if (vm.getType().equals(VirtualMachine.Type.User) && vm.getHypervisorType().equals(HypervisorType.LXC)) {\n            throw new InvalidParameterValueException(\"Unsupported Hypervisor Type for User VM migration, we support XenServer/VMware/KVM/Ovm/Hyperv/Ovm3 only\");\n        }\n\n        final long srcHostId = vm.getHostId();\n        final Host srcHost = _hostDao.findById(srcHostId);\n        if (srcHost == null) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to find the host with id: \" + srcHostId + \" of this VM:\" + vm);\n            }\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Unable to find the host (with specified id) of VM with specified id\");\n            ex.addProxyObject(String.valueOf(srcHostId), \"hostId\");\n            ex.addProxyObject(vm.getUuid(), \"vmId\");\n            throw ex;\n        }\n        String srcHostVersion = srcHost.getHypervisorVersion();\n        if (HypervisorType.KVM.equals(srcHost.getHypervisorType()) && srcHostVersion == null) {\n            srcHostVersion = \"\";\n        }\n\n        \r\n        boolean canMigrateWithStorage = false;\n\n        if (VirtualMachine.Type.User.equals(vm.getType()) || HypervisorType.VMware.equals(vm.getHypervisorType())) {\n            canMigrateWithStorage = Boolean.TRUE.equals(_hypervisorCapabilitiesDao.isStorageMotionSupported(srcHost.getHypervisorType(), srcHostVersion));\n        }\n\n        \r\n        final VirtualMachineProfile vmProfile = new VirtualMachineProfileImpl(vm, null, _offeringDao.findById(vm.getId(), vm.getServiceOfferingId()), null, null);\n        final List<VolumeVO> volumes = _volumeDao.findCreatedByInstance(vmProfile.getId());\n        boolean usesLocal = false;\n        for (final VolumeVO volume : volumes) {\n            final DiskOfferingVO diskOffering = _diskOfferingDao.findById(volume.getDiskOfferingId());\n            final DiskProfile diskProfile = new DiskProfile(volume, diskOffering, vmProfile.getHypervisorType());\n            if (diskProfile.useLocalStorage()) {\n                usesLocal = true;\n                break;\n            }\n        }\n\n        if (!canMigrateWithStorage && usesLocal) {\n            throw new InvalidParameterValueException(\"Unsupported operation, VM uses Local storage, cannot migrate\");\n        }\n\n        final Type hostType = srcHost.getType();\n        Pair<List<HostVO>, Integer> allHostsPair = null;\n        List<HostVO> allHosts = null;\n        List<HostVO> hostsForMigrationWithStorage = null;\n        final Map<Host, Boolean> requiresStorageMotion = new HashMap<Host, Boolean>();\n        DataCenterDeployment plan = null;\n        if (canMigrateWithStorage) {\n            Long podId = !VirtualMachine.Type.User.equals(vm.getType()) ? srcHost.getPodId() : null;\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, srcHost.getDataCenterId(), podId, null, null, keyword,\n                null, null, srcHost.getHypervisorType(), null, srcHost.getId());\n            allHosts = allHostsPair.first();\n            hostsForMigrationWithStorage = new ArrayList<>(allHosts);\n\n            for (final VolumeVO volume : volumes) {\n                StoragePool storagePool = _poolDao.findById(volume.getPoolId());\n                Long volClusterId = storagePool.getClusterId();\n\n                for (Iterator<HostVO> iterator = hostsForMigrationWithStorage.iterator(); iterator.hasNext();) {\n                    final Host host = iterator.next();\n                    String hostVersion = host.getHypervisorVersion();\n                    if (HypervisorType.KVM.equals(host.getHypervisorType()) && hostVersion == null) {\n                        hostVersion = \"\";\n                    }\n\n                    if (volClusterId != null) {\n                        if (storagePool.isLocal() || !host.getClusterId().equals(volClusterId) || usesLocal) {\n                            if (storagePool.isManaged()) {\n                                \r\n                                \r\n                                \r\n                                \r\n                                \r\n                                iterator.remove();\n                            } else {\n                                boolean hostSupportsStorageMigration = false;\n                                if ((srcHostVersion != null && srcHostVersion.equals(hostVersion)) ||\n                                        Boolean.TRUE.equals(_hypervisorCapabilitiesDao.isStorageMotionSupported(host.getHypervisorType(), hostVersion))) {\n                                    hostSupportsStorageMigration = true;\n                                }\n                                if (hostSupportsStorageMigration && hasSuitablePoolsForVolume(volume, host, vmProfile)) {\n                                    requiresStorageMotion.put(host, true);\n                                } else {\n                                    iterator.remove();\n                                }\n                            }\n                        }\n                    } else {\n                        if (storagePool.isManaged()) {\n                            if (srcHost.getClusterId() != host.getClusterId()) {\n                                if (storagePool.getPoolType() == Storage.StoragePoolType.PowerFlex) {\n                                    \r\n                                    \r\n                                    continue;\n                                }\n                                \r\n                                \r\n                                \r\n                                requiresStorageMotion.put(host, true);\n                            }\n                        }\n                    }\n                }\n            }\n\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), podId, null, null, null, null);\n        } else {\n            final Long cluster = srcHost.getClusterId();\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Searching for all hosts in cluster \" + cluster + \" for migrating VM \" + vm);\n            }\n            allHostsPair = searchForServers(startIndex, pageSize, null, hostType, null, null, null, cluster, null, keyword, null, null, null,\n                null, srcHost.getId());\n            allHosts = allHostsPair.first();\n            plan = new DataCenterDeployment(srcHost.getDataCenterId(), srcHost.getPodId(), srcHost.getClusterId(), null, null, null);\n        }\n\n        final Pair<List<? extends Host>, Integer> otherHosts = new Pair<List<? extends Host>, Integer>(allHosts, allHostsPair.second());\n        List<Host> suitableHosts = new ArrayList<Host>();\n        final ExcludeList excludes = new ExcludeList();\n        excludes.addHost(srcHostId);\n\n        if (dpdkHelper.isVMDpdkEnabled(vm.getId())) {\n            excludeNonDPDKEnabledHosts(plan, excludes);\n        }\n\n        \r\n        final long vmGroupCount = _affinityGroupVMMapDao.countAffinityGroupsForVm(vm.getId());\n\n        if (vmGroupCount > 0) {\n            for (final AffinityGroupProcessor processor : _affinityProcessors) {\n                processor.process(vmProfile, plan, excludes);\n            }\n        }\n\n        if (vm.getType() == VirtualMachine.Type.User || vm.getType() == VirtualMachine.Type.DomainRouter) {\n            final DataCenterVO dc = _dcDao.findById(srcHost.getDataCenterId());\n            _dpMgr.checkForNonDedicatedResources(vmProfile, dc, excludes);\n        }\n\n        for (final HostAllocator allocator : hostAllocators) {\n            if (canMigrateWithStorage) {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, hostsForMigrationWithStorage, HostAllocator.RETURN_UPTO_ALL, false);\n            } else {\n                suitableHosts = allocator.allocateTo(vmProfile, plan, Host.Type.Routing, excludes, HostAllocator.RETURN_UPTO_ALL, false);\n            }\n\n            if (suitableHosts != null && !suitableHosts.isEmpty()) {\n                break;\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            if (suitableHosts.isEmpty()) {\n                s_logger.debug(\"No suitable hosts found\");\n            } else {\n                s_logger.debug(\"Hosts having capacity and suitable for migration: \" + suitableHosts);\n            }\n        }\n\n        return new Ternary<Pair<List<? extends Host>, Integer>, List<? extends Host>, Map<Host, Boolean>>(otherHosts, suitableHosts, requiresStorageMotion);\n    }\n","realPath":"server/src/main/java/com/cloud/server/ManagementServerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1219,"status":"M"},{"authorDate":"2019-01-25 20:05:13","commitOrder":12,"curCode":"    private boolean isOnSupportedHypevisorForMigration(VMInstanceVO vm) {\n        return (vm.getHypervisorType().equals(HypervisorType.XenServer) ||\n                vm.getHypervisorType().equals(HypervisorType.VMware) ||\n                vm.getHypervisorType().equals(HypervisorType.KVM) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm) ||\n                vm.getHypervisorType().equals(HypervisorType.Hyperv) ||\n                vm.getHypervisorType().equals(HypervisorType.LXC) ||\n                vm.getHypervisorType().equals(HypervisorType.Simulator) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm3));\n    }\n","date":"2019-01-25 20:05:13","endLine":5248,"groupId":"101312","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"isOnSupportedHypevisorForMigration","params":"(VMInstanceVOvm)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/68/b45e1af7c3b5c442bc0dc09dec1aeb5256a58d.src","preCode":"    private boolean isOnSupportedHypevisorForMigration(VMInstanceVO vm) {\n        return (vm.getHypervisorType().equals(HypervisorType.XenServer) ||\n                vm.getHypervisorType().equals(HypervisorType.VMware) ||\n                vm.getHypervisorType().equals(HypervisorType.KVM) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm) ||\n                vm.getHypervisorType().equals(HypervisorType.Hyperv) ||\n                vm.getHypervisorType().equals(HypervisorType.LXC) ||\n                vm.getHypervisorType().equals(HypervisorType.Simulator) ||\n                vm.getHypervisorType().equals(HypervisorType.Ovm3));\n    }\n","realPath":"server/src/main/java/com/cloud/vm/UserVmManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":5239,"status":"N"}],"commitId":"50a16979c5e6eee85d9c127bfde9237fdbeab13d","commitMessage":"@@@refactor: migrate vm with storage (#5030)\n\n* refactor: migrate with storage host capability check\n\nRefactors Boolean HypervisorCapabilitiesDao::isStorageMotionSupported to boolean HypervisorCapabilitiesDao::isStorageMotionSupported for simplifying callers.\nRefactors log messages.\n\nSigned-off-by: Abhishek Kumar <abhishek.mrt22@gmail.com>\n\n* simplify\n\nSigned-off-by: Abhishek Kumar <abhishek.mrt22@gmail.com>\n\n* refactor\n\nSigned-off-by: Abhishek Kumar <abhishek.mrt22@gmail.com>\n\n* changes\n\nSigned-off-by: Abhishek Kumar <abhishek.mrt22@gmail.com>\n\n* review comments addressed\n\nSigned-off-by: Abhishek Kumar <abhishek.mrt22@gmail.com>\n\n* var rename\n\nSigned-off-by: Abhishek Kumar <abhishek.mrt22@gmail.com>","date":"2021-07-15 15:27:13","modifiedFileCount":"9","status":"M","submitter":"Abhishek Kumar"}]
