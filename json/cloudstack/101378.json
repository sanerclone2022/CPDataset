[{"authorTime":"2018-05-17 03:59:17","codes":[{"authorDate":"2018-01-20 05:49:27","commitOrder":2,"curCode":"    public boolean delete(TemplateProfile profile) {\n        boolean success = false;\n\n        VMTemplateVO template = profile.getTemplate();\n        Account account = _accountDao.findByIdIncludingRemoved(template.getAccountId());\n\n        if (profile.getZoneIdList() != null && profile.getZoneIdList().size() > 1)\n            throw new CloudRuntimeException(\"Operation is not supported for more than one zone id at a time\");\n\n        Long zoneId = null;\n        if (profile.getZoneIdList() != null)\n            zoneId = profile.getZoneIdList().get(0);\n\n        \r\n        List<DataStore> imageStores = templateMgr.getImageStoreByTemplate(template.getId(),\n                                            zoneId);\n\n        if (imageStores == null || imageStores.size() == 0) {\n            \r\n            success = true;\n            s_logger.info(\"Unable to find image store still having template: \" + template.getName() + \", so just mark the template removed\");\n        } else {\n            \r\n            for (DataStore store : imageStores) {\n                long storeId = store.getId();\n                List<TemplateDataStoreVO> templateStores = _tmpltStoreDao.listByTemplateStore(template.getId(), storeId);\n                for (TemplateDataStoreVO templateStore : templateStores) {\n                    if (templateStore.getDownloadState() == Status.DOWNLOAD_IN_PROGRESS) {\n                        String errorMsg = \"Please specify a template that is not currently being downloaded.\";\n                        s_logger.debug(\"Template: \" + template.getName() + \" is currently being downloaded to secondary storage host: \" + store.getName() + \"; cant' delete it.\");\n                        throw new CloudRuntimeException(errorMsg);\n                    }\n                }\n            }\n\n            String eventType = \"\";\n            if (template.getFormat().equals(ImageFormat.ISO)) {\n                eventType = EventTypes.EVENT_ISO_DELETE;\n            } else {\n                eventType = EventTypes.EVENT_TEMPLATE_DELETE;\n            }\n\n            for (DataStore imageStore : imageStores) {\n                \r\n                Long sZoneId = ((ImageStoreEntity)imageStore).getDataCenterId();\n                if (sZoneId != null) {\n                    UsageEventUtils.publishUsageEvent(eventType, template.getAccountId(), sZoneId, template.getId(), null, VirtualMachineTemplate.class.getName(),\n                            template.getUuid());\n                }\n\n                boolean dataDiskDeletetionResult = true;\n                List<VMTemplateVO> dataDiskTemplates = templateDao.listByParentTemplatetId(template.getId());\n                if (dataDiskTemplates != null && dataDiskTemplates.size() > 0) {\n                    s_logger.info(\"Template: \" + template.getId() + \" has Datadisk template(s) associated with it. Delete Datadisk templates before deleting the template\");\n                    for (VMTemplateVO dataDiskTemplate : dataDiskTemplates) {\n                        s_logger.info(\"Delete Datadisk template: \" + dataDiskTemplate.getId() + \" from image store: \" + imageStore.getName());\n                        AsyncCallFuture<TemplateApiResult> future = imageService.deleteTemplateAsync(imageFactory.getTemplate(dataDiskTemplate.getId(), imageStore));\n                        try {\n                            TemplateApiResult result = future.get();\n                            dataDiskDeletetionResult = result.isSuccess();\n                            if (!dataDiskDeletetionResult) {\n                                s_logger.warn(\"Failed to delete datadisk template: \" + dataDiskTemplate + \" from image store: \" + imageStore.getName() + \" due to: \"\n                                        + result.getResult());\n                                break;\n                            }\n                            \r\n                            List<VMTemplateZoneVO> templateZones = templateZoneDao.listByZoneTemplate(sZoneId, dataDiskTemplate.getId());\n                            if (templateZones != null) {\n                                for (VMTemplateZoneVO templateZone : templateZones) {\n                                    templateZoneDao.remove(templateZone.getId());\n                                }\n                            }\n                            \r\n                            List<DataStore> iStores = templateMgr.getImageStoreByTemplate(dataDiskTemplate.getId(), null);\n                            if (iStores == null || iStores.size() == 0) {\n                                dataDiskTemplate.setState(VirtualMachineTemplate.State.Inactive);\n                                _tmpltDao.update(dataDiskTemplate.getId(), dataDiskTemplate);\n                            }\n                            \r\n                            _resourceLimitMgr.recalculateResourceCount(dataDiskTemplate.getAccountId(), account.getDomainId(), ResourceType.secondary_storage.getOrdinal());\n                        } catch (Exception e) {\n                            s_logger.debug(\"Delete datadisk template failed\", e);\n                            throw new CloudRuntimeException(\"Delete datadisk template failed\", e);\n                        }\n                    }\n                }\n                \r\n                if (dataDiskDeletetionResult) {\n                    s_logger.info(\"Delete template: \" + template.getId() + \" from image store: \" + imageStore.getName());\n                    AsyncCallFuture<TemplateApiResult> future = imageService.deleteTemplateAsync(imageFactory.getTemplate(template.getId(), imageStore));\n                    try {\n                        TemplateApiResult result = future.get();\n                        success = result.isSuccess();\n                        if (!success) {\n                            s_logger.warn(\"Failed to delete the template: \" + template + \" from the image store: \" + imageStore.getName() + \" due to: \" + result.getResult());\n                            break;\n                        }\n\n                        \r\n                        List<VMTemplateZoneVO> templateZones = templateZoneDao.listByZoneTemplate(sZoneId, template.getId());\n                        if (templateZones != null) {\n                            for (VMTemplateZoneVO templateZone : templateZones) {\n                                templateZoneDao.remove(templateZone.getId());\n                            }\n                        }\n                    } catch (InterruptedException|ExecutionException e) {\n                        s_logger.debug(\"Delete template Failed\", e);\n                        throw new CloudRuntimeException(\"Delete template Failed\", e);\n                    }\n                } else {\n                    s_logger.warn(\"Template: \" + template.getId() + \" won't be deleted from image store: \" + imageStore.getName() + \" because deletion of one of the Datadisk\"\n                            + \" templates that belonged to the template failed\");\n                }\n            }\n\n        }\n        if (success) {\n            if ((imageStores != null && imageStores.size() > 1) && (profile.getZoneIdList() != null)) {\n                \r\n                return success;\n            }\n\n            \r\n            List<TemplateInfo> cacheTmpls = imageFactory.listTemplateOnCache(template.getId());\n            for (TemplateInfo tmplOnCache : cacheTmpls) {\n                s_logger.info(\"Delete template: \" + tmplOnCache.getId() + \" from image cache store: \" + tmplOnCache.getDataStore().getName());\n                tmplOnCache.delete();\n            }\n\n            \r\n            List<DataStore> iStores = templateMgr.getImageStoreByTemplate(template.getId(), null);\n            if (iStores == null || iStores.size() == 0) {\n                \r\n                template.setState(VirtualMachineTemplate.State.Inactive);\n                _tmpltDao.update(template.getId(), template);\n\n                    \r\n                    \r\n                    _resourceLimitMgr.decrementResourceCount(template.getAccountId(), ResourceType.template);\n                    _resourceLimitMgr.recalculateResourceCount(template.getAccountId(), account.getDomainId(), ResourceType.secondary_storage.getOrdinal());\n\n            }\n\n            \r\n            Pair<Class<?>, Long> tmplt = new Pair<Class<?>, Long>(VirtualMachineTemplate.class, template.getId());\n            _messageBus.publish(_name, EntityManager.MESSAGE_REMOVE_ENTITY_EVENT, PublishScope.LOCAL, tmplt);\n\n        }\n        return success;\n\n    }\n","date":"2018-01-20 05:49:27","endLine":585,"groupId":"3987","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"delete","params":"(TemplateProfileprofile)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/bf/a73af6bcd3812f732fab28a19528a4b65c946c.src","preCode":"    public boolean delete(TemplateProfile profile) {\n        boolean success = false;\n\n        VMTemplateVO template = profile.getTemplate();\n        Account account = _accountDao.findByIdIncludingRemoved(template.getAccountId());\n\n        if (profile.getZoneIdList() != null && profile.getZoneIdList().size() > 1)\n            throw new CloudRuntimeException(\"Operation is not supported for more than one zone id at a time\");\n\n        Long zoneId = null;\n        if (profile.getZoneIdList() != null)\n            zoneId = profile.getZoneIdList().get(0);\n\n        \r\n        List<DataStore> imageStores = templateMgr.getImageStoreByTemplate(template.getId(),\n                                            zoneId);\n\n        if (imageStores == null || imageStores.size() == 0) {\n            \r\n            success = true;\n            s_logger.info(\"Unable to find image store still having template: \" + template.getName() + \", so just mark the template removed\");\n        } else {\n            \r\n            for (DataStore store : imageStores) {\n                long storeId = store.getId();\n                List<TemplateDataStoreVO> templateStores = _tmpltStoreDao.listByTemplateStore(template.getId(), storeId);\n                for (TemplateDataStoreVO templateStore : templateStores) {\n                    if (templateStore.getDownloadState() == Status.DOWNLOAD_IN_PROGRESS) {\n                        String errorMsg = \"Please specify a template that is not currently being downloaded.\";\n                        s_logger.debug(\"Template: \" + template.getName() + \" is currently being downloaded to secondary storage host: \" + store.getName() + \"; cant' delete it.\");\n                        throw new CloudRuntimeException(errorMsg);\n                    }\n                }\n            }\n\n            String eventType = \"\";\n            if (template.getFormat().equals(ImageFormat.ISO)) {\n                eventType = EventTypes.EVENT_ISO_DELETE;\n            } else {\n                eventType = EventTypes.EVENT_TEMPLATE_DELETE;\n            }\n\n            for (DataStore imageStore : imageStores) {\n                \r\n                Long sZoneId = ((ImageStoreEntity)imageStore).getDataCenterId();\n                if (sZoneId != null) {\n                    UsageEventUtils.publishUsageEvent(eventType, template.getAccountId(), sZoneId, template.getId(), null, VirtualMachineTemplate.class.getName(),\n                            template.getUuid());\n                }\n\n                boolean dataDiskDeletetionResult = true;\n                List<VMTemplateVO> dataDiskTemplates = templateDao.listByParentTemplatetId(template.getId());\n                if (dataDiskTemplates != null && dataDiskTemplates.size() > 0) {\n                    s_logger.info(\"Template: \" + template.getId() + \" has Datadisk template(s) associated with it. Delete Datadisk templates before deleting the template\");\n                    for (VMTemplateVO dataDiskTemplate : dataDiskTemplates) {\n                        s_logger.info(\"Delete Datadisk template: \" + dataDiskTemplate.getId() + \" from image store: \" + imageStore.getName());\n                        AsyncCallFuture<TemplateApiResult> future = imageService.deleteTemplateAsync(imageFactory.getTemplate(dataDiskTemplate.getId(), imageStore));\n                        try {\n                            TemplateApiResult result = future.get();\n                            dataDiskDeletetionResult = result.isSuccess();\n                            if (!dataDiskDeletetionResult) {\n                                s_logger.warn(\"Failed to delete datadisk template: \" + dataDiskTemplate + \" from image store: \" + imageStore.getName() + \" due to: \"\n                                        + result.getResult());\n                                break;\n                            }\n                            \r\n                            List<VMTemplateZoneVO> templateZones = templateZoneDao.listByZoneTemplate(sZoneId, dataDiskTemplate.getId());\n                            if (templateZones != null) {\n                                for (VMTemplateZoneVO templateZone : templateZones) {\n                                    templateZoneDao.remove(templateZone.getId());\n                                }\n                            }\n                            \r\n                            List<DataStore> iStores = templateMgr.getImageStoreByTemplate(dataDiskTemplate.getId(), null);\n                            if (iStores == null || iStores.size() == 0) {\n                                dataDiskTemplate.setState(VirtualMachineTemplate.State.Inactive);\n                                _tmpltDao.update(dataDiskTemplate.getId(), dataDiskTemplate);\n                            }\n                            \r\n                            _resourceLimitMgr.recalculateResourceCount(dataDiskTemplate.getAccountId(), account.getDomainId(), ResourceType.secondary_storage.getOrdinal());\n                        } catch (Exception e) {\n                            s_logger.debug(\"Delete datadisk template failed\", e);\n                            throw new CloudRuntimeException(\"Delete datadisk template failed\", e);\n                        }\n                    }\n                }\n                \r\n                if (dataDiskDeletetionResult) {\n                    s_logger.info(\"Delete template: \" + template.getId() + \" from image store: \" + imageStore.getName());\n                    AsyncCallFuture<TemplateApiResult> future = imageService.deleteTemplateAsync(imageFactory.getTemplate(template.getId(), imageStore));\n                    try {\n                        TemplateApiResult result = future.get();\n                        success = result.isSuccess();\n                        if (!success) {\n                            s_logger.warn(\"Failed to delete the template: \" + template + \" from the image store: \" + imageStore.getName() + \" due to: \" + result.getResult());\n                            break;\n                        }\n\n                        \r\n                        List<VMTemplateZoneVO> templateZones = templateZoneDao.listByZoneTemplate(sZoneId, template.getId());\n                        if (templateZones != null) {\n                            for (VMTemplateZoneVO templateZone : templateZones) {\n                                templateZoneDao.remove(templateZone.getId());\n                            }\n                        }\n                    } catch (InterruptedException|ExecutionException e) {\n                        s_logger.debug(\"Delete template Failed\", e);\n                        throw new CloudRuntimeException(\"Delete template Failed\", e);\n                    }\n                } else {\n                    s_logger.warn(\"Template: \" + template.getId() + \" won't be deleted from image store: \" + imageStore.getName() + \" because deletion of one of the Datadisk\"\n                            + \" templates that belonged to the template failed\");\n                }\n            }\n\n        }\n        if (success) {\n            if ((imageStores != null && imageStores.size() > 1) && (profile.getZoneIdList() != null)) {\n                \r\n                return success;\n            }\n\n            \r\n            List<TemplateInfo> cacheTmpls = imageFactory.listTemplateOnCache(template.getId());\n            for (TemplateInfo tmplOnCache : cacheTmpls) {\n                s_logger.info(\"Delete template: \" + tmplOnCache.getId() + \" from image cache store: \" + tmplOnCache.getDataStore().getName());\n                tmplOnCache.delete();\n            }\n\n            \r\n            List<DataStore> iStores = templateMgr.getImageStoreByTemplate(template.getId(), null);\n            if (iStores == null || iStores.size() == 0) {\n                \r\n                template.setState(VirtualMachineTemplate.State.Inactive);\n                _tmpltDao.update(template.getId(), template);\n\n                    \r\n                    \r\n                    _resourceLimitMgr.decrementResourceCount(template.getAccountId(), ResourceType.template);\n                    _resourceLimitMgr.recalculateResourceCount(template.getAccountId(), account.getDomainId(), ResourceType.secondary_storage.getOrdinal());\n\n            }\n\n            \r\n            Pair<Class<?>, Long> tmplt = new Pair<Class<?>, Long>(VirtualMachineTemplate.class, template.getId());\n            _messageBus.publish(_name, EntityManager.MESSAGE_REMOVE_ENTITY_EVENT, PublishScope.LOCAL, tmplt);\n\n        }\n        return success;\n\n    }\n","realPath":"server/src/main/java/com/cloud/template/HypervisorTemplateAdapter.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":435,"status":"NB"},{"authorDate":"2018-05-17 03:59:17","commitOrder":2,"curCode":"    protected void cleanVolumesCache(VolumeVO volume) {\n        List<VolumeInfo> cacheVols = volFactory.listVolumeOnCache(volume.getId());\n        if (CollectionUtils.isEmpty(cacheVols)) {\n            return;\n        }\n        for (VolumeInfo volOnCache : cacheVols) {\n            s_logger.info(\"Delete volume from image cache store: \" + volOnCache.getDataStore().getName());\n            volOnCache.delete();\n        }\n    }\n","date":"2018-05-17 03:59:17","endLine":1370,"groupId":"13468","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"cleanVolumesCache","params":"(VolumeVOvolume)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/9b/ff4a17295c79d592774c3f26f2c0bd15ffce71.src","preCode":"    protected void cleanVolumesCache(VolumeVO volume) {\n        List<VolumeInfo> cacheVols = volFactory.listVolumeOnCache(volume.getId());\n        if (CollectionUtils.isEmpty(cacheVols)) {\n            return;\n        }\n        for (VolumeInfo volOnCache : cacheVols) {\n            s_logger.info(\"Delete volume from image cache store: \" + volOnCache.getDataStore().getName());\n            volOnCache.delete();\n        }\n    }\n","realPath":"server/src/main/java/com/cloud/storage/VolumeApiServiceImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1361,"status":"B"}],"commitId":"15eddf3dd664d6c3e722dccaa03fb5adeaf85d49","commitMessage":"@@@Merge forward branch '4.11' PR #2629\n\nFix primary storage count when deleting volumes (#2629)\n","date":"2018-05-17 03:59:17","modifiedFileCount":"7","status":"M","submitter":"Rafael Weing?rtner"},{"authorTime":"2018-05-17 03:59:17","codes":[{"authorDate":"2020-10-26 21:24:14","commitOrder":3,"curCode":"    public boolean delete(TemplateProfile profile) {\n        boolean success = false;\n\n        VMTemplateVO template = profile.getTemplate();\n        Account account = _accountDao.findByIdIncludingRemoved(template.getAccountId());\n\n        if (profile.getZoneIdList() != null && profile.getZoneIdList().size() > 1)\n            throw new CloudRuntimeException(\"Operation is not supported for more than one zone id at a time\");\n\n        Long zoneId = null;\n        if (profile.getZoneIdList() != null)\n            zoneId = profile.getZoneIdList().get(0);\n\n        \r\n        List<DataStore> imageStores = templateMgr.getImageStoreByTemplate(template.getId(),\n                                            zoneId);\n\n        if (imageStores == null || imageStores.size() == 0) {\n            \r\n            success = true;\n            s_logger.info(\"Unable to find image store still having template: \" + template.getName() + \", so just mark the template removed\");\n        } else {\n            \r\n            for (DataStore store : imageStores) {\n                long storeId = store.getId();\n                List<TemplateDataStoreVO> templateStores = _tmpltStoreDao.listByTemplateStore(template.getId(), storeId);\n                for (TemplateDataStoreVO templateStore : templateStores) {\n                    if (templateStore.getDownloadState() == Status.DOWNLOAD_IN_PROGRESS) {\n                        String errorMsg = \"Please specify a template that is not currently being downloaded.\";\n                        s_logger.debug(\"Template: \" + template.getName() + \" is currently being downloaded to secondary storage host: \" + store.getName() + \"; cant' delete it.\");\n                        throw new CloudRuntimeException(errorMsg);\n                    }\n                }\n            }\n\n            String eventType = \"\";\n            if (template.getFormat().equals(ImageFormat.ISO)) {\n                eventType = EventTypes.EVENT_ISO_DELETE;\n            } else {\n                eventType = EventTypes.EVENT_TEMPLATE_DELETE;\n            }\n\n            for (DataStore imageStore : imageStores) {\n                \r\n                Long sZoneId = ((ImageStoreEntity)imageStore).getDataCenterId();\n                if (sZoneId != null) {\n                    UsageEventUtils.publishUsageEvent(eventType, template.getAccountId(), sZoneId, template.getId(), null, VirtualMachineTemplate.class.getName(),\n                            template.getUuid());\n                }\n\n                boolean dataDiskDeletetionResult = true;\n                List<VMTemplateVO> dataDiskTemplates = templateDao.listByParentTemplatetId(template.getId());\n                if (dataDiskTemplates != null && dataDiskTemplates.size() > 0) {\n                    s_logger.info(\"Template: \" + template.getId() + \" has Datadisk template(s) associated with it. Delete Datadisk templates before deleting the template\");\n                    for (VMTemplateVO dataDiskTemplate : dataDiskTemplates) {\n                        s_logger.info(\"Delete Datadisk template: \" + dataDiskTemplate.getId() + \" from image store: \" + imageStore.getName());\n                        AsyncCallFuture<TemplateApiResult> future = imageService.deleteTemplateAsync(imageFactory.getTemplate(dataDiskTemplate.getId(), imageStore));\n                        try {\n                            TemplateApiResult result = future.get();\n                            dataDiskDeletetionResult = result.isSuccess();\n                            if (!dataDiskDeletetionResult) {\n                                s_logger.warn(\"Failed to delete datadisk template: \" + dataDiskTemplate + \" from image store: \" + imageStore.getName() + \" due to: \"\n                                        + result.getResult());\n                                break;\n                            }\n                            \r\n                            List<VMTemplateZoneVO> templateZones = templateZoneDao.listByZoneTemplate(sZoneId, dataDiskTemplate.getId());\n                            if (templateZones != null) {\n                                for (VMTemplateZoneVO templateZone : templateZones) {\n                                    templateZoneDao.remove(templateZone.getId());\n                                }\n                            }\n                            \r\n                            List<DataStore> iStores = templateMgr.getImageStoreByTemplate(dataDiskTemplate.getId(), null);\n                            if (iStores == null || iStores.size() == 0) {\n                                dataDiskTemplate.setState(VirtualMachineTemplate.State.Inactive);\n                                _tmpltDao.update(dataDiskTemplate.getId(), dataDiskTemplate);\n                            }\n                            \r\n                            _resourceLimitMgr.recalculateResourceCount(dataDiskTemplate.getAccountId(), account.getDomainId(), ResourceType.secondary_storage.getOrdinal());\n                        } catch (Exception e) {\n                            s_logger.debug(\"Delete datadisk template failed\", e);\n                            throw new CloudRuntimeException(\"Delete datadisk template failed\", e);\n                        }\n                    }\n                }\n                \r\n                if (dataDiskDeletetionResult) {\n                    s_logger.info(\"Delete template: \" + template.getId() + \" from image store: \" + imageStore.getName());\n                    AsyncCallFuture<TemplateApiResult> future = imageService.deleteTemplateAsync(imageFactory.getTemplate(template.getId(), imageStore));\n                    try {\n                        TemplateApiResult result = future.get();\n                        success = result.isSuccess();\n                        if (!success) {\n                            s_logger.warn(\"Failed to delete the template: \" + template + \" from the image store: \" + imageStore.getName() + \" due to: \" + result.getResult());\n                            break;\n                        }\n\n                        \r\n                        List<VMTemplateZoneVO> templateZones = templateZoneDao.listByZoneTemplate(sZoneId, template.getId());\n                        if (templateZones != null) {\n                            for (VMTemplateZoneVO templateZone : templateZones) {\n                                templateZoneDao.remove(templateZone.getId());\n                            }\n                        }\n                    } catch (InterruptedException|ExecutionException e) {\n                        s_logger.debug(\"Delete template Failed\", e);\n                        throw new CloudRuntimeException(\"Delete template Failed\", e);\n                    }\n                } else {\n                    s_logger.warn(\"Template: \" + template.getId() + \" won't be deleted from image store: \" + imageStore.getName() + \" because deletion of one of the Datadisk\"\n                            + \" templates that belonged to the template failed\");\n                }\n            }\n\n        }\n        if (success) {\n            if ((imageStores != null && imageStores.size() > 1) && (profile.getZoneIdList() != null)) {\n                \r\n                return success;\n            }\n\n            \r\n            List<TemplateInfo> cacheTmpls = imageFactory.listTemplateOnCache(template.getId());\n            for (TemplateInfo tmplOnCache : cacheTmpls) {\n                s_logger.info(\"Delete template: \" + tmplOnCache.getId() + \" from image cache store: \" + tmplOnCache.getDataStore().getName());\n                tmplOnCache.delete();\n            }\n\n            \r\n            List<DataStore> iStores = templateMgr.getImageStoreByTemplate(template.getId(), null);\n            if (iStores == null || iStores.size() == 0) {\n                \r\n                template.setState(VirtualMachineTemplate.State.Inactive);\n                _tmpltDao.update(template.getId(), template);\n\n                    \r\n                    \r\n                    _resourceLimitMgr.decrementResourceCount(template.getAccountId(), ResourceType.template);\n                    _resourceLimitMgr.recalculateResourceCount(template.getAccountId(), account.getDomainId(), ResourceType.secondary_storage.getOrdinal());\n\n            }\n\n            \r\n            Pair<Class<?>, Long> tmplt = new Pair<Class<?>, Long>(VirtualMachineTemplate.class, template.getId());\n            _messageBus.publish(_name, EntityManager.MESSAGE_REMOVE_ENTITY_EVENT, PublishScope.LOCAL, tmplt);\n\n            \r\n            templateDetailsDao.removeDetails(template.getId());\n\n            \r\n            templateDeployAsIsDetailsDao.removeDetails(template.getId());\n\n        }\n        return success;\n\n    }\n","date":"2020-10-26 21:24:14","endLine":610,"groupId":"3987","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"delete","params":"(TemplateProfileprofile)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/c0/80ffd2f25cc980cf71700f95b70e9e0cd36630.src","preCode":"    public boolean delete(TemplateProfile profile) {\n        boolean success = false;\n\n        VMTemplateVO template = profile.getTemplate();\n        Account account = _accountDao.findByIdIncludingRemoved(template.getAccountId());\n\n        if (profile.getZoneIdList() != null && profile.getZoneIdList().size() > 1)\n            throw new CloudRuntimeException(\"Operation is not supported for more than one zone id at a time\");\n\n        Long zoneId = null;\n        if (profile.getZoneIdList() != null)\n            zoneId = profile.getZoneIdList().get(0);\n\n        \r\n        List<DataStore> imageStores = templateMgr.getImageStoreByTemplate(template.getId(),\n                                            zoneId);\n\n        if (imageStores == null || imageStores.size() == 0) {\n            \r\n            success = true;\n            s_logger.info(\"Unable to find image store still having template: \" + template.getName() + \", so just mark the template removed\");\n        } else {\n            \r\n            for (DataStore store : imageStores) {\n                long storeId = store.getId();\n                List<TemplateDataStoreVO> templateStores = _tmpltStoreDao.listByTemplateStore(template.getId(), storeId);\n                for (TemplateDataStoreVO templateStore : templateStores) {\n                    if (templateStore.getDownloadState() == Status.DOWNLOAD_IN_PROGRESS) {\n                        String errorMsg = \"Please specify a template that is not currently being downloaded.\";\n                        s_logger.debug(\"Template: \" + template.getName() + \" is currently being downloaded to secondary storage host: \" + store.getName() + \"; cant' delete it.\");\n                        throw new CloudRuntimeException(errorMsg);\n                    }\n                }\n            }\n\n            String eventType = \"\";\n            if (template.getFormat().equals(ImageFormat.ISO)) {\n                eventType = EventTypes.EVENT_ISO_DELETE;\n            } else {\n                eventType = EventTypes.EVENT_TEMPLATE_DELETE;\n            }\n\n            for (DataStore imageStore : imageStores) {\n                \r\n                Long sZoneId = ((ImageStoreEntity)imageStore).getDataCenterId();\n                if (sZoneId != null) {\n                    UsageEventUtils.publishUsageEvent(eventType, template.getAccountId(), sZoneId, template.getId(), null, VirtualMachineTemplate.class.getName(),\n                            template.getUuid());\n                }\n\n                boolean dataDiskDeletetionResult = true;\n                List<VMTemplateVO> dataDiskTemplates = templateDao.listByParentTemplatetId(template.getId());\n                if (dataDiskTemplates != null && dataDiskTemplates.size() > 0) {\n                    s_logger.info(\"Template: \" + template.getId() + \" has Datadisk template(s) associated with it. Delete Datadisk templates before deleting the template\");\n                    for (VMTemplateVO dataDiskTemplate : dataDiskTemplates) {\n                        s_logger.info(\"Delete Datadisk template: \" + dataDiskTemplate.getId() + \" from image store: \" + imageStore.getName());\n                        AsyncCallFuture<TemplateApiResult> future = imageService.deleteTemplateAsync(imageFactory.getTemplate(dataDiskTemplate.getId(), imageStore));\n                        try {\n                            TemplateApiResult result = future.get();\n                            dataDiskDeletetionResult = result.isSuccess();\n                            if (!dataDiskDeletetionResult) {\n                                s_logger.warn(\"Failed to delete datadisk template: \" + dataDiskTemplate + \" from image store: \" + imageStore.getName() + \" due to: \"\n                                        + result.getResult());\n                                break;\n                            }\n                            \r\n                            List<VMTemplateZoneVO> templateZones = templateZoneDao.listByZoneTemplate(sZoneId, dataDiskTemplate.getId());\n                            if (templateZones != null) {\n                                for (VMTemplateZoneVO templateZone : templateZones) {\n                                    templateZoneDao.remove(templateZone.getId());\n                                }\n                            }\n                            \r\n                            List<DataStore> iStores = templateMgr.getImageStoreByTemplate(dataDiskTemplate.getId(), null);\n                            if (iStores == null || iStores.size() == 0) {\n                                dataDiskTemplate.setState(VirtualMachineTemplate.State.Inactive);\n                                _tmpltDao.update(dataDiskTemplate.getId(), dataDiskTemplate);\n                            }\n                            \r\n                            _resourceLimitMgr.recalculateResourceCount(dataDiskTemplate.getAccountId(), account.getDomainId(), ResourceType.secondary_storage.getOrdinal());\n                        } catch (Exception e) {\n                            s_logger.debug(\"Delete datadisk template failed\", e);\n                            throw new CloudRuntimeException(\"Delete datadisk template failed\", e);\n                        }\n                    }\n                }\n                \r\n                if (dataDiskDeletetionResult) {\n                    s_logger.info(\"Delete template: \" + template.getId() + \" from image store: \" + imageStore.getName());\n                    AsyncCallFuture<TemplateApiResult> future = imageService.deleteTemplateAsync(imageFactory.getTemplate(template.getId(), imageStore));\n                    try {\n                        TemplateApiResult result = future.get();\n                        success = result.isSuccess();\n                        if (!success) {\n                            s_logger.warn(\"Failed to delete the template: \" + template + \" from the image store: \" + imageStore.getName() + \" due to: \" + result.getResult());\n                            break;\n                        }\n\n                        \r\n                        List<VMTemplateZoneVO> templateZones = templateZoneDao.listByZoneTemplate(sZoneId, template.getId());\n                        if (templateZones != null) {\n                            for (VMTemplateZoneVO templateZone : templateZones) {\n                                templateZoneDao.remove(templateZone.getId());\n                            }\n                        }\n                    } catch (InterruptedException|ExecutionException e) {\n                        s_logger.debug(\"Delete template Failed\", e);\n                        throw new CloudRuntimeException(\"Delete template Failed\", e);\n                    }\n                } else {\n                    s_logger.warn(\"Template: \" + template.getId() + \" won't be deleted from image store: \" + imageStore.getName() + \" because deletion of one of the Datadisk\"\n                            + \" templates that belonged to the template failed\");\n                }\n            }\n\n        }\n        if (success) {\n            if ((imageStores != null && imageStores.size() > 1) && (profile.getZoneIdList() != null)) {\n                \r\n                return success;\n            }\n\n            \r\n            List<TemplateInfo> cacheTmpls = imageFactory.listTemplateOnCache(template.getId());\n            for (TemplateInfo tmplOnCache : cacheTmpls) {\n                s_logger.info(\"Delete template: \" + tmplOnCache.getId() + \" from image cache store: \" + tmplOnCache.getDataStore().getName());\n                tmplOnCache.delete();\n            }\n\n            \r\n            List<DataStore> iStores = templateMgr.getImageStoreByTemplate(template.getId(), null);\n            if (iStores == null || iStores.size() == 0) {\n                \r\n                template.setState(VirtualMachineTemplate.State.Inactive);\n                _tmpltDao.update(template.getId(), template);\n\n                    \r\n                    \r\n                    _resourceLimitMgr.decrementResourceCount(template.getAccountId(), ResourceType.template);\n                    _resourceLimitMgr.recalculateResourceCount(template.getAccountId(), account.getDomainId(), ResourceType.secondary_storage.getOrdinal());\n\n            }\n\n            \r\n            Pair<Class<?>, Long> tmplt = new Pair<Class<?>, Long>(VirtualMachineTemplate.class, template.getId());\n            _messageBus.publish(_name, EntityManager.MESSAGE_REMOVE_ENTITY_EVENT, PublishScope.LOCAL, tmplt);\n\n        }\n        return success;\n\n    }\n","realPath":"server/src/main/java/com/cloud/template/HypervisorTemplateAdapter.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":454,"status":"M"},{"authorDate":"2018-05-17 03:59:17","commitOrder":3,"curCode":"    protected void cleanVolumesCache(VolumeVO volume) {\n        List<VolumeInfo> cacheVols = volFactory.listVolumeOnCache(volume.getId());\n        if (CollectionUtils.isEmpty(cacheVols)) {\n            return;\n        }\n        for (VolumeInfo volOnCache : cacheVols) {\n            s_logger.info(\"Delete volume from image cache store: \" + volOnCache.getDataStore().getName());\n            volOnCache.delete();\n        }\n    }\n","date":"2018-05-17 03:59:17","endLine":1370,"groupId":"13468","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"cleanVolumesCache","params":"(VolumeVOvolume)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/9b/ff4a17295c79d592774c3f26f2c0bd15ffce71.src","preCode":"    protected void cleanVolumesCache(VolumeVO volume) {\n        List<VolumeInfo> cacheVols = volFactory.listVolumeOnCache(volume.getId());\n        if (CollectionUtils.isEmpty(cacheVols)) {\n            return;\n        }\n        for (VolumeInfo volOnCache : cacheVols) {\n            s_logger.info(\"Delete volume from image cache store: \" + volOnCache.getDataStore().getName());\n            volOnCache.delete();\n        }\n    }\n","realPath":"server/src/main/java/com/cloud/storage/VolumeApiServiceImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1361,"status":"N"}],"commitId":"1a75872cd484dd387552bae58996a56679fdb51e","commitMessage":"@@@Merge pull request #4307 from shapeblue/ovfprops-and-vsphere-adv-together\n\n[VMware] vSphere advanced capabilities and Full OVF properties support","date":"2020-10-26 21:24:14","modifiedFileCount":"173","status":"M","submitter":"Boris Stoyanov - a.k.a Bobby"},{"authorTime":"2018-05-17 03:59:17","codes":[{"authorDate":"2021-02-24 17:28:33","commitOrder":4,"curCode":"    public boolean delete(TemplateProfile profile) {\n        boolean success = false;\n\n        VMTemplateVO template = profile.getTemplate();\n        Account account = _accountDao.findByIdIncludingRemoved(template.getAccountId());\n\n        if (profile.getZoneIdList() != null && profile.getZoneIdList().size() > 1)\n            throw new CloudRuntimeException(\"Operation is not supported for more than one zone id at a time\");\n\n        Long zoneId = null;\n        if (profile.getZoneIdList() != null)\n            zoneId = profile.getZoneIdList().get(0);\n\n        \r\n        List<DataStore> imageStores = templateMgr.getImageStoreByTemplate(template.getId(),\n                                            zoneId);\n\n        if (imageStores == null || imageStores.size() == 0) {\n            \r\n            success = true;\n            s_logger.info(\"Unable to find image store still having template: \" + template.getName() + \", so just mark the template removed\");\n        } else {\n            \r\n            for (DataStore store : imageStores) {\n                long storeId = store.getId();\n                List<TemplateDataStoreVO> templateStores = _tmpltStoreDao.listByTemplateStore(template.getId(), storeId);\n                for (TemplateDataStoreVO templateStore : templateStores) {\n                    if (templateStore.getDownloadState() == Status.DOWNLOAD_IN_PROGRESS) {\n                        String errorMsg = \"Please specify a template that is not currently being downloaded.\";\n                        s_logger.debug(\"Template: \" + template.getName() + \" is currently being downloaded to secondary storage host: \" + store.getName() + \"; cant' delete it.\");\n                        throw new CloudRuntimeException(errorMsg);\n                    }\n                }\n            }\n\n            String eventType = \"\";\n            if (template.getFormat().equals(ImageFormat.ISO)) {\n                eventType = EventTypes.EVENT_ISO_DELETE;\n            } else {\n                eventType = EventTypes.EVENT_TEMPLATE_DELETE;\n            }\n\n            for (DataStore imageStore : imageStores) {\n                \r\n                Long sZoneId = ((ImageStoreEntity)imageStore).getDataCenterId();\n                if (sZoneId != null) {\n                    UsageEventUtils.publishUsageEvent(eventType, template.getAccountId(), sZoneId, template.getId(), null, VirtualMachineTemplate.class.getName(),\n                            template.getUuid());\n                }\n\n                boolean dataDiskDeletetionResult = true;\n                List<VMTemplateVO> dataDiskTemplates = templateDao.listByParentTemplatetId(template.getId());\n                if (dataDiskTemplates != null && dataDiskTemplates.size() > 0) {\n                    s_logger.info(\"Template: \" + template.getId() + \" has Datadisk template(s) associated with it. Delete Datadisk templates before deleting the template\");\n                    for (VMTemplateVO dataDiskTemplate : dataDiskTemplates) {\n                        s_logger.info(\"Delete Datadisk template: \" + dataDiskTemplate.getId() + \" from image store: \" + imageStore.getName());\n                        AsyncCallFuture<TemplateApiResult> future = imageService.deleteTemplateAsync(imageFactory.getTemplate(dataDiskTemplate.getId(), imageStore));\n                        try {\n                            TemplateApiResult result = future.get();\n                            dataDiskDeletetionResult = result.isSuccess();\n                            if (!dataDiskDeletetionResult) {\n                                s_logger.warn(\"Failed to delete datadisk template: \" + dataDiskTemplate + \" from image store: \" + imageStore.getName() + \" due to: \"\n                                        + result.getResult());\n                                break;\n                            }\n                            \r\n                            List<VMTemplateZoneVO> templateZones = templateZoneDao.listByZoneTemplate(sZoneId, dataDiskTemplate.getId());\n                            if (templateZones != null) {\n                                for (VMTemplateZoneVO templateZone : templateZones) {\n                                    templateZoneDao.remove(templateZone.getId());\n                                }\n                            }\n                            \r\n                            List<DataStore> iStores = templateMgr.getImageStoreByTemplate(dataDiskTemplate.getId(), null);\n                            if (iStores == null || iStores.size() == 0) {\n                                dataDiskTemplate.setState(VirtualMachineTemplate.State.Inactive);\n                                _tmpltDao.update(dataDiskTemplate.getId(), dataDiskTemplate);\n                            }\n                            \r\n                            _resourceLimitMgr.recalculateResourceCount(dataDiskTemplate.getAccountId(), account.getDomainId(), ResourceType.secondary_storage.getOrdinal());\n                        } catch (Exception e) {\n                            s_logger.debug(\"Delete datadisk template failed\", e);\n                            throw new CloudRuntimeException(\"Delete datadisk template failed\", e);\n                        }\n                    }\n                }\n                \r\n                if (dataDiskDeletetionResult) {\n                    s_logger.info(\"Delete template: \" + template.getId() + \" from image store: \" + imageStore.getName());\n                    AsyncCallFuture<TemplateApiResult> future = imageService.deleteTemplateAsync(imageFactory.getTemplate(template.getId(), imageStore));\n                    try {\n                        TemplateApiResult result = future.get();\n                        success = result.isSuccess();\n                        if (!success) {\n                            s_logger.warn(\"Failed to delete the template: \" + template + \" from the image store: \" + imageStore.getName() + \" due to: \" + result.getResult());\n                            break;\n                        }\n\n                        \r\n                        List<VMTemplateZoneVO> templateZones = templateZoneDao.listByZoneTemplate(sZoneId, template.getId());\n                        if (templateZones != null) {\n                            for (VMTemplateZoneVO templateZone : templateZones) {\n                                templateZoneDao.remove(templateZone.getId());\n                            }\n                        }\n                    } catch (InterruptedException|ExecutionException e) {\n                        s_logger.debug(\"Delete template Failed\", e);\n                        throw new CloudRuntimeException(\"Delete template Failed\", e);\n                    }\n                } else {\n                    s_logger.warn(\"Template: \" + template.getId() + \" won't be deleted from image store: \" + imageStore.getName() + \" because deletion of one of the Datadisk\"\n                            + \" templates that belonged to the template failed\");\n                }\n            }\n\n        }\n        if (success) {\n            if ((imageStores != null && imageStores.size() > 1) && (profile.getZoneIdList() != null)) {\n                \r\n                return success;\n            }\n\n            \r\n            List<TemplateInfo> cacheTmpls = imageFactory.listTemplateOnCache(template.getId());\n            for (TemplateInfo tmplOnCache : cacheTmpls) {\n                s_logger.info(\"Delete template: \" + tmplOnCache.getId() + \" from image cache store: \" + tmplOnCache.getDataStore().getName());\n                tmplOnCache.delete();\n            }\n\n            \r\n            List<DataStore> iStores = templateMgr.getImageStoreByTemplate(template.getId(), null);\n            if (iStores == null || iStores.size() == 0) {\n                \r\n                List<VMTemplateZoneVO> templateZones = templateZoneDao.listByTemplateId(template.getId());\n                if (templateZones != null) {\n                    for (VMTemplateZoneVO templateZone : templateZones) {\n                        templateZoneDao.remove(templateZone.getId());\n                    }\n                }\n\n                \r\n                template.setState(VirtualMachineTemplate.State.Inactive);\n                _tmpltDao.update(template.getId(), template);\n\n                    \r\n                    \r\n                    _resourceLimitMgr.decrementResourceCount(template.getAccountId(), ResourceType.template);\n                    _resourceLimitMgr.recalculateResourceCount(template.getAccountId(), account.getDomainId(), ResourceType.secondary_storage.getOrdinal());\n\n            }\n\n            \r\n            Pair<Class<?>, Long> tmplt = new Pair<Class<?>, Long>(VirtualMachineTemplate.class, template.getId());\n            _messageBus.publish(_name, EntityManager.MESSAGE_REMOVE_ENTITY_EVENT, PublishScope.LOCAL, tmplt);\n\n            \r\n            templateDetailsDao.removeDetails(template.getId());\n\n            \r\n            templateDeployAsIsDetailsDao.removeDetails(template.getId());\n\n        }\n        return success;\n    }\n","date":"2021-02-24 17:28:33","endLine":634,"groupId":"3987","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"delete","params":"(TemplateProfileprofile)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/a4/d134032e852f93af59cb81cd80afcd6272b6cb.src","preCode":"    public boolean delete(TemplateProfile profile) {\n        boolean success = false;\n\n        VMTemplateVO template = profile.getTemplate();\n        Account account = _accountDao.findByIdIncludingRemoved(template.getAccountId());\n\n        if (profile.getZoneIdList() != null && profile.getZoneIdList().size() > 1)\n            throw new CloudRuntimeException(\"Operation is not supported for more than one zone id at a time\");\n\n        Long zoneId = null;\n        if (profile.getZoneIdList() != null)\n            zoneId = profile.getZoneIdList().get(0);\n\n        \r\n        List<DataStore> imageStores = templateMgr.getImageStoreByTemplate(template.getId(),\n                                            zoneId);\n\n        if (imageStores == null || imageStores.size() == 0) {\n            \r\n            success = true;\n            s_logger.info(\"Unable to find image store still having template: \" + template.getName() + \", so just mark the template removed\");\n        } else {\n            \r\n            for (DataStore store : imageStores) {\n                long storeId = store.getId();\n                List<TemplateDataStoreVO> templateStores = _tmpltStoreDao.listByTemplateStore(template.getId(), storeId);\n                for (TemplateDataStoreVO templateStore : templateStores) {\n                    if (templateStore.getDownloadState() == Status.DOWNLOAD_IN_PROGRESS) {\n                        String errorMsg = \"Please specify a template that is not currently being downloaded.\";\n                        s_logger.debug(\"Template: \" + template.getName() + \" is currently being downloaded to secondary storage host: \" + store.getName() + \"; cant' delete it.\");\n                        throw new CloudRuntimeException(errorMsg);\n                    }\n                }\n            }\n\n            String eventType = \"\";\n            if (template.getFormat().equals(ImageFormat.ISO)) {\n                eventType = EventTypes.EVENT_ISO_DELETE;\n            } else {\n                eventType = EventTypes.EVENT_TEMPLATE_DELETE;\n            }\n\n            for (DataStore imageStore : imageStores) {\n                \r\n                Long sZoneId = ((ImageStoreEntity)imageStore).getDataCenterId();\n                if (sZoneId != null) {\n                    UsageEventUtils.publishUsageEvent(eventType, template.getAccountId(), sZoneId, template.getId(), null, VirtualMachineTemplate.class.getName(),\n                            template.getUuid());\n                }\n\n                boolean dataDiskDeletetionResult = true;\n                List<VMTemplateVO> dataDiskTemplates = templateDao.listByParentTemplatetId(template.getId());\n                if (dataDiskTemplates != null && dataDiskTemplates.size() > 0) {\n                    s_logger.info(\"Template: \" + template.getId() + \" has Datadisk template(s) associated with it. Delete Datadisk templates before deleting the template\");\n                    for (VMTemplateVO dataDiskTemplate : dataDiskTemplates) {\n                        s_logger.info(\"Delete Datadisk template: \" + dataDiskTemplate.getId() + \" from image store: \" + imageStore.getName());\n                        AsyncCallFuture<TemplateApiResult> future = imageService.deleteTemplateAsync(imageFactory.getTemplate(dataDiskTemplate.getId(), imageStore));\n                        try {\n                            TemplateApiResult result = future.get();\n                            dataDiskDeletetionResult = result.isSuccess();\n                            if (!dataDiskDeletetionResult) {\n                                s_logger.warn(\"Failed to delete datadisk template: \" + dataDiskTemplate + \" from image store: \" + imageStore.getName() + \" due to: \"\n                                        + result.getResult());\n                                break;\n                            }\n                            \r\n                            List<VMTemplateZoneVO> templateZones = templateZoneDao.listByZoneTemplate(sZoneId, dataDiskTemplate.getId());\n                            if (templateZones != null) {\n                                for (VMTemplateZoneVO templateZone : templateZones) {\n                                    templateZoneDao.remove(templateZone.getId());\n                                }\n                            }\n                            \r\n                            List<DataStore> iStores = templateMgr.getImageStoreByTemplate(dataDiskTemplate.getId(), null);\n                            if (iStores == null || iStores.size() == 0) {\n                                dataDiskTemplate.setState(VirtualMachineTemplate.State.Inactive);\n                                _tmpltDao.update(dataDiskTemplate.getId(), dataDiskTemplate);\n                            }\n                            \r\n                            _resourceLimitMgr.recalculateResourceCount(dataDiskTemplate.getAccountId(), account.getDomainId(), ResourceType.secondary_storage.getOrdinal());\n                        } catch (Exception e) {\n                            s_logger.debug(\"Delete datadisk template failed\", e);\n                            throw new CloudRuntimeException(\"Delete datadisk template failed\", e);\n                        }\n                    }\n                }\n                \r\n                if (dataDiskDeletetionResult) {\n                    s_logger.info(\"Delete template: \" + template.getId() + \" from image store: \" + imageStore.getName());\n                    AsyncCallFuture<TemplateApiResult> future = imageService.deleteTemplateAsync(imageFactory.getTemplate(template.getId(), imageStore));\n                    try {\n                        TemplateApiResult result = future.get();\n                        success = result.isSuccess();\n                        if (!success) {\n                            s_logger.warn(\"Failed to delete the template: \" + template + \" from the image store: \" + imageStore.getName() + \" due to: \" + result.getResult());\n                            break;\n                        }\n\n                        \r\n                        List<VMTemplateZoneVO> templateZones = templateZoneDao.listByZoneTemplate(sZoneId, template.getId());\n                        if (templateZones != null) {\n                            for (VMTemplateZoneVO templateZone : templateZones) {\n                                templateZoneDao.remove(templateZone.getId());\n                            }\n                        }\n                    } catch (InterruptedException|ExecutionException e) {\n                        s_logger.debug(\"Delete template Failed\", e);\n                        throw new CloudRuntimeException(\"Delete template Failed\", e);\n                    }\n                } else {\n                    s_logger.warn(\"Template: \" + template.getId() + \" won't be deleted from image store: \" + imageStore.getName() + \" because deletion of one of the Datadisk\"\n                            + \" templates that belonged to the template failed\");\n                }\n            }\n\n        }\n        if (success) {\n            if ((imageStores != null && imageStores.size() > 1) && (profile.getZoneIdList() != null)) {\n                \r\n                return success;\n            }\n\n            \r\n            List<TemplateInfo> cacheTmpls = imageFactory.listTemplateOnCache(template.getId());\n            for (TemplateInfo tmplOnCache : cacheTmpls) {\n                s_logger.info(\"Delete template: \" + tmplOnCache.getId() + \" from image cache store: \" + tmplOnCache.getDataStore().getName());\n                tmplOnCache.delete();\n            }\n\n            \r\n            List<DataStore> iStores = templateMgr.getImageStoreByTemplate(template.getId(), null);\n            if (iStores == null || iStores.size() == 0) {\n                \r\n                template.setState(VirtualMachineTemplate.State.Inactive);\n                _tmpltDao.update(template.getId(), template);\n\n                    \r\n                    \r\n                    _resourceLimitMgr.decrementResourceCount(template.getAccountId(), ResourceType.template);\n                    _resourceLimitMgr.recalculateResourceCount(template.getAccountId(), account.getDomainId(), ResourceType.secondary_storage.getOrdinal());\n\n            }\n\n            \r\n            Pair<Class<?>, Long> tmplt = new Pair<Class<?>, Long>(VirtualMachineTemplate.class, template.getId());\n            _messageBus.publish(_name, EntityManager.MESSAGE_REMOVE_ENTITY_EVENT, PublishScope.LOCAL, tmplt);\n\n            \r\n            templateDetailsDao.removeDetails(template.getId());\n\n            \r\n            templateDeployAsIsDetailsDao.removeDetails(template.getId());\n\n        }\n        return success;\n\n    }\n","realPath":"server/src/main/java/com/cloud/template/HypervisorTemplateAdapter.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":471,"status":"M"},{"authorDate":"2018-05-17 03:59:17","commitOrder":4,"curCode":"    protected void cleanVolumesCache(VolumeVO volume) {\n        List<VolumeInfo> cacheVols = volFactory.listVolumeOnCache(volume.getId());\n        if (CollectionUtils.isEmpty(cacheVols)) {\n            return;\n        }\n        for (VolumeInfo volOnCache : cacheVols) {\n            s_logger.info(\"Delete volume from image cache store: \" + volOnCache.getDataStore().getName());\n            volOnCache.delete();\n        }\n    }\n","date":"2018-05-17 03:59:17","endLine":1370,"groupId":"13468","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"cleanVolumesCache","params":"(VolumeVOvolume)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/9b/ff4a17295c79d592774c3f26f2c0bd15ffce71.src","preCode":"    protected void cleanVolumesCache(VolumeVO volume) {\n        List<VolumeInfo> cacheVols = volFactory.listVolumeOnCache(volume.getId());\n        if (CollectionUtils.isEmpty(cacheVols)) {\n            return;\n        }\n        for (VolumeInfo volOnCache : cacheVols) {\n            s_logger.info(\"Delete volume from image cache store: \" + volOnCache.getDataStore().getName());\n            volOnCache.delete();\n        }\n    }\n","realPath":"server/src/main/java/com/cloud/storage/VolumeApiServiceImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1361,"status":"N"}],"commitId":"eba186aa40f16911c019bf06cd33d7d0cbbc303b","commitMessage":"@@@storage: New Dell EMC PowerFlex Plugin (formerly ScaleIO.  VxFlexOS) (#4304)\n\nAdded support for PowerFlex/ScaleIO (v3.5 onwards) storage pool as a primary storage in CloudStack (for KVM hypervisor) and enabled VM/Volume operations on that pool (using pool tag).\nPlease find more details in the FS here:\nhttps://cwiki.apache.org/confluence/x/cDl4CQ\n\nDocumentation PR: apache/cloudstack-documentation#169\n\nThis enables support for PowerFlex/ScaleIO (v3.5 onwards) storage pool as a primary storage in CloudStack\n\nOther improvements addressed in addition to PowerFlex/ScaleIO support:\n\n- Added support for config drives in host cache for KVM\n\t=> Changed configuration \"vm.configdrive.primarypool.enabled\" scope from Global to Zone level\n\t=> Introduced new zone level configuration \"vm.configdrive.force.host.cache.use\" (default: false) to force host cache for config drives\n\t=> Introduced new zone level configuration \"vm.configdrive.use.host.cache.on.unsupported.pool\" (default: true) to use host cache for config drives when storage pool doesn't support config drive\n\t=> Added new parameter \"host.cache.location\" (default: /var/cache/cloud) in KVM agent.properties for specifying the host cache path and create config drives on the \"/config\" directory on the host cache path\n\t=> Maintain the config drive location and use it when required on any config drive operation (migrate.  delete)\n\n- Detect virtual size from the template URL while registering direct download qcow2 (of KVM hypervisor) templates\n\n- Updated full deployment destination for preparing the network(s) on VM start\n\n- Propagate the direct download certificates uploaded to the newly added KVM hosts\n\n- Discover the template size for direct download templates using any available host from the zones specified on template registration\n\t=> When zones are not specified while registering template.  template size discovery is performed using any available host.  which is picked up randomly from one of the available zones\n\n- Release the VM resources when VM is sync-ed to Stopped state on PowerReportMissing (after graceful period)\n\n- Retry VM deployment/start when the host cannot grant access to volume/template\n\n- Mark never-used or downloaded templates as Destroyed on deletion.  without sending any DeleteCommand\n\t=> Do not trigger any DeleteCommand for never-used or downloaded templates as these doesn't exist and cannot be deleted from the datastore\n\n- Check the router filesystem is writable or not.  before performing health checks\n\t=> Introduce a new test \"filesystem.writable.test\" to check the filesystem is writable or not\n\t=> The router health checks keeps the config info at \"/var/cache/cloud\" and updates the monitor results at \"/root\" for health checks.  both are different partitions. So.  test at both the locations.\n\t=> Added new script: \"filesystem_writable_check.py\" at /opt/cloud/bin/ to check the filesystem is writable or not\n\n- Fixed NPE issue.  template is null for DATA disks. Copy template to target storage for ROOT disk (with template id).  skip DATA disk(s)\n\n* Addressed some issues for few operations on PowerFlex storage pool.\n\n- Updated migration volume operation to sync the status and wait for migration to complete.\n\n- Updated VM Snapshot naming.  for uniqueness in ScaleIO volume name when more than one volume exists in the VM.\n\n- Added sync lock while spooling managed storage template before volume creation from the template (non-direct download).\n\n- Updated resize volume error message string.\n\n- Blocked the below operations on PowerFlex storage pool:\n  -> Extract Volume\n  -> Create Snapshot for VMSnapshot\n\n* Added the PowerFlex/ScaleIO client connection pool to manage the ScaleIO gateway clients.  which uses a single gateway client per Powerflex/ScaleIO storage pool and renews it when the session token expires.\n\n- The token is valid for 8 hours from the time it was created.  unless there has been no activity for 10 minutes.\n  Reference: https://cpsdocs.dellemc.com/bundle/PF_REST_API_RG/page/GUID-92430F19-9F44-42B6-B898-87D5307AE59B.html\n\nOther fixes included:\n\n- Fail the VM deployment when the host specified in the deployVirtualMachine cmd is not in the right state (i.e. either Resource State is not Enabled or Status is not Up)\n\n- Use the physical file size of the template to check the free space availability on the host.  while downloading the direct download templates.\n\n- Perform basic tests (for connectivity and file system) on router before updating the health check config data\n\t=> Validate the basic tests (connectivity and file system check) on router\n\t=> Cleanup the health check results when router is destroyed\n\n* Updated PowerFlex/ScaleIO storage plugin version to 4.16.0.0\n\n* UI Changes to support storage plugin for PowerFlex/ScaleIO storage pool.\n- PowerFlex pool URL generated from the UI inputs(Gateway.  Username.  Password.  Storage Pool) when adding \"PowerFlex\" Primary Storage\n- Updated protocol to \"custom\" for PowerFlex provider\n- Allow VM Snapshot for stopped VM on KVM hypervisor and PowerFlex/ScaleIO storage pool\n\nand Minor improvements in PowerFlex/ScaleIO storage plugin code\n\n* Added support for PowerFlex/ScaleIO volume migration across different PowerFlex storage instances.\n\n- findStoragePoolsForMigration API returns PowerFlex pool(s) of different instance as suitable pool(s).  for volume(s) on PowerFlex storage pool.\n- Volume(s) with snapshots are not allowed to migrate to different PowerFlex instance.\n- Volume(s) of running VM are not allowed to migrate to other PowerFlex storage pools.\n- Volume migration from PowerFlex pool to Non-PowerFlex pool.  and vice versa are not supported.\n\n* Fixed change service offering smoke tests in test_service_offerings.py.  test_vm_snapshots.py\n\n* Added the PowerFlex/ScaleIO volume/snapshot name to the paths of respective CloudStack resources (Templates.  Volumes.  Snapshots and VM Snapshots)\n\n* Added new response parameter ?supportsStorageSnapshot? (true/false) to volume response.  and Updated UI to hide the async backup option while taking snapshot for volume(s) with storage snapshot support.\n\n* Fix to remove the duplicate zone wide pools listed while finding storage pools for migration\n\n* Updated PowerFlex/ScaleIO volume migration checks and rollback migration on failure\n\n* Fixed the PowerFlex/ScaleIO volume name inconsistency issue in the volume path after migration.  due to rename failure","date":"2021-02-24 17:28:33","modifiedFileCount":"112","status":"M","submitter":"sureshanaparti"},{"authorTime":"2018-05-17 03:59:17","codes":[{"authorDate":"2021-03-24 15:16:24","commitOrder":5,"curCode":"    public boolean delete(TemplateProfile profile) {\n        boolean success = false;\n\n        VMTemplateVO template = profile.getTemplate();\n        Account account = _accountDao.findByIdIncludingRemoved(template.getAccountId());\n\n        if (profile.getZoneIdList() != null && profile.getZoneIdList().size() > 1)\n            throw new CloudRuntimeException(\"Operation is not supported for more than one zone id at a time\");\n\n        Long zoneId = null;\n        if (profile.getZoneIdList() != null)\n            zoneId = profile.getZoneIdList().get(0);\n\n        \r\n        List<DataStore> imageStores = templateMgr.getImageStoreByTemplate(template.getId(),\n                                            zoneId);\n\n        if (imageStores == null || imageStores.size() == 0) {\n            \r\n            success = true;\n            s_logger.info(\"Unable to find image store still having template: \" + template.getName() + \", so just mark the template removed\");\n        } else {\n            \r\n            for (DataStore store : imageStores) {\n                long storeId = store.getId();\n                List<TemplateDataStoreVO> templateStores = _tmpltStoreDao.listByTemplateStore(template.getId(), storeId);\n                for (TemplateDataStoreVO templateStore : templateStores) {\n                    if (templateStore.getDownloadState() == Status.DOWNLOAD_IN_PROGRESS) {\n                        String errorMsg = \"Please specify a template that is not currently being downloaded.\";\n                        s_logger.debug(\"Template: \" + template.getName() + \" is currently being downloaded to secondary storage host: \" + store.getName() + \"; cant' delete it.\");\n                        throw new CloudRuntimeException(errorMsg);\n                    }\n                }\n            }\n\n            String eventType = \"\";\n            if (template.getFormat().equals(ImageFormat.ISO)) {\n                eventType = EventTypes.EVENT_ISO_DELETE;\n            } else {\n                eventType = EventTypes.EVENT_TEMPLATE_DELETE;\n            }\n\n            for (DataStore imageStore : imageStores) {\n                \r\n                Long sZoneId = ((ImageStoreEntity)imageStore).getDataCenterId();\n                if (sZoneId != null) {\n                    UsageEventUtils.publishUsageEvent(eventType, template.getAccountId(), sZoneId, template.getId(), null, VirtualMachineTemplate.class.getName(),\n                            template.getUuid());\n                }\n\n                boolean dataDiskDeletetionResult = true;\n                List<VMTemplateVO> dataDiskTemplates = templateDao.listByParentTemplatetId(template.getId());\n                if (dataDiskTemplates != null && dataDiskTemplates.size() > 0) {\n                    s_logger.info(\"Template: \" + template.getId() + \" has Datadisk template(s) associated with it. Delete Datadisk templates before deleting the template\");\n                    for (VMTemplateVO dataDiskTemplate : dataDiskTemplates) {\n                        s_logger.info(\"Delete Datadisk template: \" + dataDiskTemplate.getId() + \" from image store: \" + imageStore.getName());\n                        AsyncCallFuture<TemplateApiResult> future = imageService.deleteTemplateAsync(imageFactory.getTemplate(dataDiskTemplate.getId(), imageStore));\n                        try {\n                            TemplateApiResult result = future.get();\n                            dataDiskDeletetionResult = result.isSuccess();\n                            if (!dataDiskDeletetionResult) {\n                                s_logger.warn(\"Failed to delete datadisk template: \" + dataDiskTemplate + \" from image store: \" + imageStore.getName() + \" due to: \"\n                                        + result.getResult());\n                                break;\n                            }\n                            \r\n                            List<VMTemplateZoneVO> templateZones = templateZoneDao.listByZoneTemplate(sZoneId, dataDiskTemplate.getId());\n                            if (templateZones != null) {\n                                for (VMTemplateZoneVO templateZone : templateZones) {\n                                    templateZoneDao.remove(templateZone.getId());\n                                }\n                            }\n                            \r\n                            List<DataStore> iStores = templateMgr.getImageStoreByTemplate(dataDiskTemplate.getId(), null);\n                            if (iStores == null || iStores.size() == 0) {\n                                dataDiskTemplate.setState(VirtualMachineTemplate.State.Inactive);\n                                _tmpltDao.update(dataDiskTemplate.getId(), dataDiskTemplate);\n                            }\n                            \r\n                            _resourceLimitMgr.recalculateResourceCount(dataDiskTemplate.getAccountId(), account.getDomainId(), ResourceType.secondary_storage.getOrdinal());\n                        } catch (Exception e) {\n                            s_logger.debug(\"Delete datadisk template failed\", e);\n                            throw new CloudRuntimeException(\"Delete datadisk template failed\", e);\n                        }\n                    }\n                }\n                \r\n                if (dataDiskDeletetionResult) {\n                    s_logger.info(\"Delete template: \" + template.getId() + \" from image store: \" + imageStore.getName());\n                    AsyncCallFuture<TemplateApiResult> future = imageService.deleteTemplateAsync(imageFactory.getTemplate(template.getId(), imageStore));\n                    try {\n                        TemplateApiResult result = future.get();\n                        success = result.isSuccess();\n                        if (!success) {\n                            s_logger.warn(\"Failed to delete the template: \" + template + \" from the image store: \" + imageStore.getName() + \" due to: \" + result.getResult());\n                            break;\n                        }\n\n                        \r\n                        List<VMTemplateZoneVO> templateZones = templateZoneDao.listByZoneTemplate(sZoneId, template.getId());\n                        if (templateZones != null) {\n                            for (VMTemplateZoneVO templateZone : templateZones) {\n                                templateZoneDao.remove(templateZone.getId());\n                            }\n                        }\n                    } catch (InterruptedException|ExecutionException e) {\n                        s_logger.debug(\"Delete template Failed\", e);\n                        throw new CloudRuntimeException(\"Delete template Failed\", e);\n                    }\n                } else {\n                    s_logger.warn(\"Template: \" + template.getId() + \" won't be deleted from image store: \" + imageStore.getName() + \" because deletion of one of the Datadisk\"\n                            + \" templates that belonged to the template failed\");\n                }\n            }\n\n        }\n        if (success) {\n            if ((imageStores != null && imageStores.size() > 1) && (profile.getZoneIdList() != null)) {\n                \r\n                return cleanupTemplate(template, success);\n            }\n\n            \r\n            List<TemplateInfo> cacheTmpls = imageFactory.listTemplateOnCache(template.getId());\n            for (TemplateInfo tmplOnCache : cacheTmpls) {\n                s_logger.info(\"Delete template: \" + tmplOnCache.getId() + \" from image cache store: \" + tmplOnCache.getDataStore().getName());\n                tmplOnCache.delete();\n            }\n\n            \r\n            List<DataStore> iStores = templateMgr.getImageStoreByTemplate(template.getId(), null);\n            if (iStores == null || iStores.size() == 0) {\n                \r\n                List<VMTemplateZoneVO> templateZones = templateZoneDao.listByTemplateId(template.getId());\n                if (templateZones != null) {\n                    for (VMTemplateZoneVO templateZone : templateZones) {\n                        templateZoneDao.remove(templateZone.getId());\n                    }\n                }\n\n                \r\n                template.setState(VirtualMachineTemplate.State.Inactive);\n                _tmpltDao.remove(template.getId());\n                _tmpltDao.update(template.getId(), template);\n\n                    \r\n                    \r\n                    _resourceLimitMgr.decrementResourceCount(template.getAccountId(), ResourceType.template);\n                    _resourceLimitMgr.recalculateResourceCount(template.getAccountId(), account.getDomainId(), ResourceType.secondary_storage.getOrdinal());\n\n            }\n\n            \r\n            Pair<Class<?>, Long> tmplt = new Pair<Class<?>, Long>(VirtualMachineTemplate.class, template.getId());\n            _messageBus.publish(_name, EntityManager.MESSAGE_REMOVE_ENTITY_EVENT, PublishScope.LOCAL, tmplt);\n\n            \r\n            templateDetailsDao.removeDetails(template.getId());\n\n            \r\n            templateDeployAsIsDetailsDao.removeDetails(template.getId());\n\n        }\n        return success;\n    }\n","date":"2021-03-24 15:16:24","endLine":656,"groupId":"3987","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"delete","params":"(TemplateProfileprofile)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/ae/d1d87b30611680ea03bd8aae78a1649d572d0f.src","preCode":"    public boolean delete(TemplateProfile profile) {\n        boolean success = false;\n\n        VMTemplateVO template = profile.getTemplate();\n        Account account = _accountDao.findByIdIncludingRemoved(template.getAccountId());\n\n        if (profile.getZoneIdList() != null && profile.getZoneIdList().size() > 1)\n            throw new CloudRuntimeException(\"Operation is not supported for more than one zone id at a time\");\n\n        Long zoneId = null;\n        if (profile.getZoneIdList() != null)\n            zoneId = profile.getZoneIdList().get(0);\n\n        \r\n        List<DataStore> imageStores = templateMgr.getImageStoreByTemplate(template.getId(),\n                                            zoneId);\n\n        if (imageStores == null || imageStores.size() == 0) {\n            \r\n            success = true;\n            s_logger.info(\"Unable to find image store still having template: \" + template.getName() + \", so just mark the template removed\");\n        } else {\n            \r\n            for (DataStore store : imageStores) {\n                long storeId = store.getId();\n                List<TemplateDataStoreVO> templateStores = _tmpltStoreDao.listByTemplateStore(template.getId(), storeId);\n                for (TemplateDataStoreVO templateStore : templateStores) {\n                    if (templateStore.getDownloadState() == Status.DOWNLOAD_IN_PROGRESS) {\n                        String errorMsg = \"Please specify a template that is not currently being downloaded.\";\n                        s_logger.debug(\"Template: \" + template.getName() + \" is currently being downloaded to secondary storage host: \" + store.getName() + \"; cant' delete it.\");\n                        throw new CloudRuntimeException(errorMsg);\n                    }\n                }\n            }\n\n            String eventType = \"\";\n            if (template.getFormat().equals(ImageFormat.ISO)) {\n                eventType = EventTypes.EVENT_ISO_DELETE;\n            } else {\n                eventType = EventTypes.EVENT_TEMPLATE_DELETE;\n            }\n\n            for (DataStore imageStore : imageStores) {\n                \r\n                Long sZoneId = ((ImageStoreEntity)imageStore).getDataCenterId();\n                if (sZoneId != null) {\n                    UsageEventUtils.publishUsageEvent(eventType, template.getAccountId(), sZoneId, template.getId(), null, VirtualMachineTemplate.class.getName(),\n                            template.getUuid());\n                }\n\n                boolean dataDiskDeletetionResult = true;\n                List<VMTemplateVO> dataDiskTemplates = templateDao.listByParentTemplatetId(template.getId());\n                if (dataDiskTemplates != null && dataDiskTemplates.size() > 0) {\n                    s_logger.info(\"Template: \" + template.getId() + \" has Datadisk template(s) associated with it. Delete Datadisk templates before deleting the template\");\n                    for (VMTemplateVO dataDiskTemplate : dataDiskTemplates) {\n                        s_logger.info(\"Delete Datadisk template: \" + dataDiskTemplate.getId() + \" from image store: \" + imageStore.getName());\n                        AsyncCallFuture<TemplateApiResult> future = imageService.deleteTemplateAsync(imageFactory.getTemplate(dataDiskTemplate.getId(), imageStore));\n                        try {\n                            TemplateApiResult result = future.get();\n                            dataDiskDeletetionResult = result.isSuccess();\n                            if (!dataDiskDeletetionResult) {\n                                s_logger.warn(\"Failed to delete datadisk template: \" + dataDiskTemplate + \" from image store: \" + imageStore.getName() + \" due to: \"\n                                        + result.getResult());\n                                break;\n                            }\n                            \r\n                            List<VMTemplateZoneVO> templateZones = templateZoneDao.listByZoneTemplate(sZoneId, dataDiskTemplate.getId());\n                            if (templateZones != null) {\n                                for (VMTemplateZoneVO templateZone : templateZones) {\n                                    templateZoneDao.remove(templateZone.getId());\n                                }\n                            }\n                            \r\n                            List<DataStore> iStores = templateMgr.getImageStoreByTemplate(dataDiskTemplate.getId(), null);\n                            if (iStores == null || iStores.size() == 0) {\n                                dataDiskTemplate.setState(VirtualMachineTemplate.State.Inactive);\n                                _tmpltDao.update(dataDiskTemplate.getId(), dataDiskTemplate);\n                            }\n                            \r\n                            _resourceLimitMgr.recalculateResourceCount(dataDiskTemplate.getAccountId(), account.getDomainId(), ResourceType.secondary_storage.getOrdinal());\n                        } catch (Exception e) {\n                            s_logger.debug(\"Delete datadisk template failed\", e);\n                            throw new CloudRuntimeException(\"Delete datadisk template failed\", e);\n                        }\n                    }\n                }\n                \r\n                if (dataDiskDeletetionResult) {\n                    s_logger.info(\"Delete template: \" + template.getId() + \" from image store: \" + imageStore.getName());\n                    AsyncCallFuture<TemplateApiResult> future = imageService.deleteTemplateAsync(imageFactory.getTemplate(template.getId(), imageStore));\n                    try {\n                        TemplateApiResult result = future.get();\n                        success = result.isSuccess();\n                        if (!success) {\n                            s_logger.warn(\"Failed to delete the template: \" + template + \" from the image store: \" + imageStore.getName() + \" due to: \" + result.getResult());\n                            break;\n                        }\n\n                        \r\n                        List<VMTemplateZoneVO> templateZones = templateZoneDao.listByZoneTemplate(sZoneId, template.getId());\n                        if (templateZones != null) {\n                            for (VMTemplateZoneVO templateZone : templateZones) {\n                                templateZoneDao.remove(templateZone.getId());\n                            }\n                        }\n                    } catch (InterruptedException|ExecutionException e) {\n                        s_logger.debug(\"Delete template Failed\", e);\n                        throw new CloudRuntimeException(\"Delete template Failed\", e);\n                    }\n                } else {\n                    s_logger.warn(\"Template: \" + template.getId() + \" won't be deleted from image store: \" + imageStore.getName() + \" because deletion of one of the Datadisk\"\n                            + \" templates that belonged to the template failed\");\n                }\n            }\n\n        }\n        if (success) {\n            if ((imageStores != null && imageStores.size() > 1) && (profile.getZoneIdList() != null)) {\n                \r\n                return success;\n            }\n\n            \r\n            List<TemplateInfo> cacheTmpls = imageFactory.listTemplateOnCache(template.getId());\n            for (TemplateInfo tmplOnCache : cacheTmpls) {\n                s_logger.info(\"Delete template: \" + tmplOnCache.getId() + \" from image cache store: \" + tmplOnCache.getDataStore().getName());\n                tmplOnCache.delete();\n            }\n\n            \r\n            List<DataStore> iStores = templateMgr.getImageStoreByTemplate(template.getId(), null);\n            if (iStores == null || iStores.size() == 0) {\n                \r\n                List<VMTemplateZoneVO> templateZones = templateZoneDao.listByTemplateId(template.getId());\n                if (templateZones != null) {\n                    for (VMTemplateZoneVO templateZone : templateZones) {\n                        templateZoneDao.remove(templateZone.getId());\n                    }\n                }\n\n                \r\n                template.setState(VirtualMachineTemplate.State.Inactive);\n                _tmpltDao.update(template.getId(), template);\n\n                    \r\n                    \r\n                    _resourceLimitMgr.decrementResourceCount(template.getAccountId(), ResourceType.template);\n                    _resourceLimitMgr.recalculateResourceCount(template.getAccountId(), account.getDomainId(), ResourceType.secondary_storage.getOrdinal());\n\n            }\n\n            \r\n            Pair<Class<?>, Long> tmplt = new Pair<Class<?>, Long>(VirtualMachineTemplate.class, template.getId());\n            _messageBus.publish(_name, EntityManager.MESSAGE_REMOVE_ENTITY_EVENT, PublishScope.LOCAL, tmplt);\n\n            \r\n            templateDetailsDao.removeDetails(template.getId());\n\n            \r\n            templateDeployAsIsDetailsDao.removeDetails(template.getId());\n\n        }\n        return success;\n    }\n","realPath":"server/src/main/java/com/cloud/template/HypervisorTemplateAdapter.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":492,"status":"M"},{"authorDate":"2018-05-17 03:59:17","commitOrder":5,"curCode":"    protected void cleanVolumesCache(VolumeVO volume) {\n        List<VolumeInfo> cacheVols = volFactory.listVolumeOnCache(volume.getId());\n        if (CollectionUtils.isEmpty(cacheVols)) {\n            return;\n        }\n        for (VolumeInfo volOnCache : cacheVols) {\n            s_logger.info(\"Delete volume from image cache store: \" + volOnCache.getDataStore().getName());\n            volOnCache.delete();\n        }\n    }\n","date":"2018-05-17 03:59:17","endLine":1370,"groupId":"13468","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"cleanVolumesCache","params":"(VolumeVOvolume)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/9b/ff4a17295c79d592774c3f26f2c0bd15ffce71.src","preCode":"    protected void cleanVolumesCache(VolumeVO volume) {\n        List<VolumeInfo> cacheVols = volFactory.listVolumeOnCache(volume.getId());\n        if (CollectionUtils.isEmpty(cacheVols)) {\n            return;\n        }\n        for (VolumeInfo volOnCache : cacheVols) {\n            s_logger.info(\"Delete volume from image cache store: \" + volOnCache.getDataStore().getName());\n            volOnCache.delete();\n        }\n    }\n","realPath":"server/src/main/java/com/cloud/storage/VolumeApiServiceImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1361,"status":"N"}],"commitId":"9f730eabfa76e42773114eaf94d57cd33aae6ae0","commitMessage":"@@@Merge remote-tracking branch 'origin/4.15'\n","date":"2021-03-24 15:16:24","modifiedFileCount":"7","status":"M","submitter":"Rohit Yadav"},{"authorTime":"2018-05-17 03:59:17","codes":[{"authorDate":"2021-09-08 12:44:06","commitOrder":6,"curCode":"    public boolean delete(TemplateProfile profile) {\n        boolean success = false;\n\n        VMTemplateVO template = profile.getTemplate();\n        Account account = _accountDao.findByIdIncludingRemoved(template.getAccountId());\n\n        if (profile.getZoneIdList() != null && profile.getZoneIdList().size() > 1)\n            throw new CloudRuntimeException(\"Operation is not supported for more than one zone id at a time\");\n\n        Long zoneId = null;\n        if (profile.getZoneIdList() != null)\n            zoneId = profile.getZoneIdList().get(0);\n\n        \r\n        List<DataStore> imageStores = templateMgr.getImageStoreByTemplate(template.getId(),\n                                            zoneId);\n\n        if (imageStores == null || imageStores.size() == 0) {\n            \r\n            success = true;\n            s_logger.info(\"Unable to find image store still having template: \" + template.getName() + \", so just mark the template removed\");\n        } else {\n            \r\n            for (DataStore store : imageStores) {\n                long storeId = store.getId();\n                List<TemplateDataStoreVO> templateStores = _tmpltStoreDao.listByTemplateStore(template.getId(), storeId);\n                for (TemplateDataStoreVO templateStore : templateStores) {\n                    if (templateStore.getDownloadState() == Status.DOWNLOAD_IN_PROGRESS) {\n                        String errorMsg = \"Please specify a template that is not currently being downloaded.\";\n                        s_logger.debug(\"Template: \" + template.getName() + \" is currently being downloaded to secondary storage host: \" + store.getName() + \"; cant' delete it.\");\n                        throw new CloudRuntimeException(errorMsg);\n                    }\n                }\n            }\n\n            String eventType = \"\";\n            if (template.getFormat().equals(ImageFormat.ISO)) {\n                eventType = EventTypes.EVENT_ISO_DELETE;\n            } else {\n                eventType = EventTypes.EVENT_TEMPLATE_DELETE;\n            }\n\n            for (DataStore imageStore : imageStores) {\n                \r\n                Long sZoneId = ((ImageStoreEntity)imageStore).getDataCenterId();\n                if (sZoneId != null) {\n                    UsageEventUtils.publishUsageEvent(eventType, template.getAccountId(), sZoneId, template.getId(), null, VirtualMachineTemplate.class.getName(),\n                            template.getUuid());\n                }\n\n                boolean dataDiskDeletetionResult = true;\n                List<VMTemplateVO> dataDiskTemplates = templateDao.listByParentTemplatetId(template.getId());\n                if (dataDiskTemplates != null && dataDiskTemplates.size() > 0) {\n                    s_logger.info(\"Template: \" + template.getId() + \" has Datadisk template(s) associated with it. Delete Datadisk templates before deleting the template\");\n                    for (VMTemplateVO dataDiskTemplate : dataDiskTemplates) {\n                        s_logger.info(\"Delete Datadisk template: \" + dataDiskTemplate.getId() + \" from image store: \" + imageStore.getName());\n                        AsyncCallFuture<TemplateApiResult> future = imageService.deleteTemplateAsync(imageFactory.getTemplate(dataDiskTemplate.getId(), imageStore));\n                        try {\n                            TemplateApiResult result = future.get();\n                            dataDiskDeletetionResult = result.isSuccess();\n                            if (!dataDiskDeletetionResult) {\n                                s_logger.warn(\"Failed to delete datadisk template: \" + dataDiskTemplate + \" from image store: \" + imageStore.getName() + \" due to: \"\n                                        + result.getResult());\n                                break;\n                            }\n                            \r\n                            List<VMTemplateZoneVO> templateZones = templateZoneDao.listByZoneTemplate(sZoneId, dataDiskTemplate.getId());\n                            if (templateZones != null) {\n                                for (VMTemplateZoneVO templateZone : templateZones) {\n                                    templateZoneDao.remove(templateZone.getId());\n                                }\n                            }\n                            \r\n                            List<DataStore> iStores = templateMgr.getImageStoreByTemplate(dataDiskTemplate.getId(), null);\n                            if (iStores == null || iStores.size() == 0) {\n                                dataDiskTemplate.setState(VirtualMachineTemplate.State.Inactive);\n                                _tmpltDao.update(dataDiskTemplate.getId(), dataDiskTemplate);\n                            }\n                            \r\n                            _resourceLimitMgr.recalculateResourceCount(dataDiskTemplate.getAccountId(), account.getDomainId(), ResourceType.secondary_storage.getOrdinal());\n                        } catch (Exception e) {\n                            s_logger.debug(\"Delete datadisk template failed\", e);\n                            throw new CloudRuntimeException(\"Delete datadisk template failed\", e);\n                        }\n                    }\n                }\n                \r\n                if (dataDiskDeletetionResult) {\n                    s_logger.info(\"Delete template: \" + template.getId() + \" from image store: \" + imageStore.getName());\n                    AsyncCallFuture<TemplateApiResult> future = imageService.deleteTemplateAsync(imageFactory.getTemplate(template.getId(), imageStore));\n                    try {\n                        TemplateApiResult result = future.get();\n                        success = result.isSuccess();\n                        if (!success) {\n                            s_logger.warn(\"Failed to delete the template: \" + template + \" from the image store: \" + imageStore.getName() + \" due to: \" + result.getResult());\n                            break;\n                        }\n\n                        \r\n                        List<VMTemplateZoneVO> templateZones = templateZoneDao.listByZoneTemplate(sZoneId, template.getId());\n                        if (templateZones != null) {\n                            for (VMTemplateZoneVO templateZone : templateZones) {\n                                templateZoneDao.remove(templateZone.getId());\n                            }\n                        }\n                    } catch (InterruptedException|ExecutionException e) {\n                        s_logger.debug(\"Delete template Failed\", e);\n                        throw new CloudRuntimeException(\"Delete template Failed\", e);\n                    }\n                } else {\n                    s_logger.warn(\"Template: \" + template.getId() + \" won't be deleted from image store: \" + imageStore.getName() + \" because deletion of one of the Datadisk\"\n                            + \" templates that belonged to the template failed\");\n                }\n            }\n\n        }\n        if (success) {\n            if ((imageStores != null && imageStores.size() > 1) && (profile.getZoneIdList() != null)) {\n                \r\n                return cleanupTemplate(template, success);\n            }\n\n            \r\n            List<TemplateInfo> cacheTmpls = imageFactory.listTemplateOnCache(template.getId());\n            for (TemplateInfo tmplOnCache : cacheTmpls) {\n                s_logger.info(\"Delete template: \" + tmplOnCache.getId() + \" from image cache store: \" + tmplOnCache.getDataStore().getName());\n                tmplOnCache.delete();\n            }\n\n            \r\n            List<DataStore> iStores = templateMgr.getImageStoreByTemplate(template.getId(), null);\n            if (iStores == null || iStores.size() == 0) {\n                \r\n                List<VMTemplateZoneVO> templateZones = templateZoneDao.listByTemplateId(template.getId());\n                if (templateZones != null) {\n                    for (VMTemplateZoneVO templateZone : templateZones) {\n                        templateZoneDao.remove(templateZone.getId());\n                    }\n                }\n\n                \r\n                template.setState(VirtualMachineTemplate.State.Inactive);\n                _tmpltDao.remove(template.getId());\n                _tmpltDao.update(template.getId(), template);\n\n                    \r\n                    \r\n                    _resourceLimitMgr.decrementResourceCount(template.getAccountId(), ResourceType.template);\n                    _resourceLimitMgr.recalculateResourceCount(template.getAccountId(), account.getDomainId(), ResourceType.secondary_storage.getOrdinal());\n\n            }\n\n            \r\n            Pair<Class<?>, Long> tmplt = new Pair<Class<?>, Long>(VirtualMachineTemplate.class, template.getId());\n            _messageBus.publish(_name, EntityManager.MESSAGE_REMOVE_ENTITY_EVENT, PublishScope.LOCAL, tmplt);\n\n            \r\n            templateDetailsDao.removeDetails(template.getId());\n\n            \r\n            templateDeployAsIsDetailsDao.removeDetails(template.getId());\n\n            \r\n            AnnotationService.EntityType entityType = template.getFormat().equals(ImageFormat.ISO) ?\n                    AnnotationService.EntityType.ISO : AnnotationService.EntityType.TEMPLATE;\n            annotationDao.removeByEntityType(entityType.name(), template.getUuid());\n\n        }\n        return success;\n    }\n","date":"2021-09-08 12:44:06","endLine":665,"groupId":"101378","id":9,"instanceNumber":1,"isCurCommit":1,"methodName":"delete","params":"(TemplateProfileprofile)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/00/dfee244cc351c6d78b0d0581d6799a0d880911.src","preCode":"    public boolean delete(TemplateProfile profile) {\n        boolean success = false;\n\n        VMTemplateVO template = profile.getTemplate();\n        Account account = _accountDao.findByIdIncludingRemoved(template.getAccountId());\n\n        if (profile.getZoneIdList() != null && profile.getZoneIdList().size() > 1)\n            throw new CloudRuntimeException(\"Operation is not supported for more than one zone id at a time\");\n\n        Long zoneId = null;\n        if (profile.getZoneIdList() != null)\n            zoneId = profile.getZoneIdList().get(0);\n\n        \r\n        List<DataStore> imageStores = templateMgr.getImageStoreByTemplate(template.getId(),\n                                            zoneId);\n\n        if (imageStores == null || imageStores.size() == 0) {\n            \r\n            success = true;\n            s_logger.info(\"Unable to find image store still having template: \" + template.getName() + \", so just mark the template removed\");\n        } else {\n            \r\n            for (DataStore store : imageStores) {\n                long storeId = store.getId();\n                List<TemplateDataStoreVO> templateStores = _tmpltStoreDao.listByTemplateStore(template.getId(), storeId);\n                for (TemplateDataStoreVO templateStore : templateStores) {\n                    if (templateStore.getDownloadState() == Status.DOWNLOAD_IN_PROGRESS) {\n                        String errorMsg = \"Please specify a template that is not currently being downloaded.\";\n                        s_logger.debug(\"Template: \" + template.getName() + \" is currently being downloaded to secondary storage host: \" + store.getName() + \"; cant' delete it.\");\n                        throw new CloudRuntimeException(errorMsg);\n                    }\n                }\n            }\n\n            String eventType = \"\";\n            if (template.getFormat().equals(ImageFormat.ISO)) {\n                eventType = EventTypes.EVENT_ISO_DELETE;\n            } else {\n                eventType = EventTypes.EVENT_TEMPLATE_DELETE;\n            }\n\n            for (DataStore imageStore : imageStores) {\n                \r\n                Long sZoneId = ((ImageStoreEntity)imageStore).getDataCenterId();\n                if (sZoneId != null) {\n                    UsageEventUtils.publishUsageEvent(eventType, template.getAccountId(), sZoneId, template.getId(), null, VirtualMachineTemplate.class.getName(),\n                            template.getUuid());\n                }\n\n                boolean dataDiskDeletetionResult = true;\n                List<VMTemplateVO> dataDiskTemplates = templateDao.listByParentTemplatetId(template.getId());\n                if (dataDiskTemplates != null && dataDiskTemplates.size() > 0) {\n                    s_logger.info(\"Template: \" + template.getId() + \" has Datadisk template(s) associated with it. Delete Datadisk templates before deleting the template\");\n                    for (VMTemplateVO dataDiskTemplate : dataDiskTemplates) {\n                        s_logger.info(\"Delete Datadisk template: \" + dataDiskTemplate.getId() + \" from image store: \" + imageStore.getName());\n                        AsyncCallFuture<TemplateApiResult> future = imageService.deleteTemplateAsync(imageFactory.getTemplate(dataDiskTemplate.getId(), imageStore));\n                        try {\n                            TemplateApiResult result = future.get();\n                            dataDiskDeletetionResult = result.isSuccess();\n                            if (!dataDiskDeletetionResult) {\n                                s_logger.warn(\"Failed to delete datadisk template: \" + dataDiskTemplate + \" from image store: \" + imageStore.getName() + \" due to: \"\n                                        + result.getResult());\n                                break;\n                            }\n                            \r\n                            List<VMTemplateZoneVO> templateZones = templateZoneDao.listByZoneTemplate(sZoneId, dataDiskTemplate.getId());\n                            if (templateZones != null) {\n                                for (VMTemplateZoneVO templateZone : templateZones) {\n                                    templateZoneDao.remove(templateZone.getId());\n                                }\n                            }\n                            \r\n                            List<DataStore> iStores = templateMgr.getImageStoreByTemplate(dataDiskTemplate.getId(), null);\n                            if (iStores == null || iStores.size() == 0) {\n                                dataDiskTemplate.setState(VirtualMachineTemplate.State.Inactive);\n                                _tmpltDao.update(dataDiskTemplate.getId(), dataDiskTemplate);\n                            }\n                            \r\n                            _resourceLimitMgr.recalculateResourceCount(dataDiskTemplate.getAccountId(), account.getDomainId(), ResourceType.secondary_storage.getOrdinal());\n                        } catch (Exception e) {\n                            s_logger.debug(\"Delete datadisk template failed\", e);\n                            throw new CloudRuntimeException(\"Delete datadisk template failed\", e);\n                        }\n                    }\n                }\n                \r\n                if (dataDiskDeletetionResult) {\n                    s_logger.info(\"Delete template: \" + template.getId() + \" from image store: \" + imageStore.getName());\n                    AsyncCallFuture<TemplateApiResult> future = imageService.deleteTemplateAsync(imageFactory.getTemplate(template.getId(), imageStore));\n                    try {\n                        TemplateApiResult result = future.get();\n                        success = result.isSuccess();\n                        if (!success) {\n                            s_logger.warn(\"Failed to delete the template: \" + template + \" from the image store: \" + imageStore.getName() + \" due to: \" + result.getResult());\n                            break;\n                        }\n\n                        \r\n                        List<VMTemplateZoneVO> templateZones = templateZoneDao.listByZoneTemplate(sZoneId, template.getId());\n                        if (templateZones != null) {\n                            for (VMTemplateZoneVO templateZone : templateZones) {\n                                templateZoneDao.remove(templateZone.getId());\n                            }\n                        }\n                    } catch (InterruptedException|ExecutionException e) {\n                        s_logger.debug(\"Delete template Failed\", e);\n                        throw new CloudRuntimeException(\"Delete template Failed\", e);\n                    }\n                } else {\n                    s_logger.warn(\"Template: \" + template.getId() + \" won't be deleted from image store: \" + imageStore.getName() + \" because deletion of one of the Datadisk\"\n                            + \" templates that belonged to the template failed\");\n                }\n            }\n\n        }\n        if (success) {\n            if ((imageStores != null && imageStores.size() > 1) && (profile.getZoneIdList() != null)) {\n                \r\n                return cleanupTemplate(template, success);\n            }\n\n            \r\n            List<TemplateInfo> cacheTmpls = imageFactory.listTemplateOnCache(template.getId());\n            for (TemplateInfo tmplOnCache : cacheTmpls) {\n                s_logger.info(\"Delete template: \" + tmplOnCache.getId() + \" from image cache store: \" + tmplOnCache.getDataStore().getName());\n                tmplOnCache.delete();\n            }\n\n            \r\n            List<DataStore> iStores = templateMgr.getImageStoreByTemplate(template.getId(), null);\n            if (iStores == null || iStores.size() == 0) {\n                \r\n                List<VMTemplateZoneVO> templateZones = templateZoneDao.listByTemplateId(template.getId());\n                if (templateZones != null) {\n                    for (VMTemplateZoneVO templateZone : templateZones) {\n                        templateZoneDao.remove(templateZone.getId());\n                    }\n                }\n\n                \r\n                template.setState(VirtualMachineTemplate.State.Inactive);\n                _tmpltDao.remove(template.getId());\n                _tmpltDao.update(template.getId(), template);\n\n                    \r\n                    \r\n                    _resourceLimitMgr.decrementResourceCount(template.getAccountId(), ResourceType.template);\n                    _resourceLimitMgr.recalculateResourceCount(template.getAccountId(), account.getDomainId(), ResourceType.secondary_storage.getOrdinal());\n\n            }\n\n            \r\n            Pair<Class<?>, Long> tmplt = new Pair<Class<?>, Long>(VirtualMachineTemplate.class, template.getId());\n            _messageBus.publish(_name, EntityManager.MESSAGE_REMOVE_ENTITY_EVENT, PublishScope.LOCAL, tmplt);\n\n            \r\n            templateDetailsDao.removeDetails(template.getId());\n\n            \r\n            templateDeployAsIsDetailsDao.removeDetails(template.getId());\n\n        }\n        return success;\n    }\n","realPath":"server/src/main/java/com/cloud/template/HypervisorTemplateAdapter.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":496,"status":"M"},{"authorDate":"2018-05-17 03:59:17","commitOrder":6,"curCode":"    protected void cleanVolumesCache(VolumeVO volume) {\n        List<VolumeInfo> cacheVols = volFactory.listVolumeOnCache(volume.getId());\n        if (CollectionUtils.isEmpty(cacheVols)) {\n            return;\n        }\n        for (VolumeInfo volOnCache : cacheVols) {\n            s_logger.info(\"Delete volume from image cache store: \" + volOnCache.getDataStore().getName());\n            volOnCache.delete();\n        }\n    }\n","date":"2018-05-17 03:59:17","endLine":1370,"groupId":"101378","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"cleanVolumesCache","params":"(VolumeVOvolume)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/9b/ff4a17295c79d592774c3f26f2c0bd15ffce71.src","preCode":"    protected void cleanVolumesCache(VolumeVO volume) {\n        List<VolumeInfo> cacheVols = volFactory.listVolumeOnCache(volume.getId());\n        if (CollectionUtils.isEmpty(cacheVols)) {\n            return;\n        }\n        for (VolumeInfo volOnCache : cacheVols) {\n            s_logger.info(\"Delete volume from image cache store: \" + volOnCache.getDataStore().getName());\n            volOnCache.delete();\n        }\n    }\n","realPath":"server/src/main/java/com/cloud/storage/VolumeApiServiceImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1361,"status":"N"}],"commitId":"413d10dd8106af9b3c369c1a393fbcca5e7217ce","commitMessage":"@@@server: Extend the Annotations framework (#5103)\n\n* Extend addAnnotation and listAnnotations APIs\n\n* Allow users to add.  list and remove comments\n\n* Add adminsonly UI and allow admins or owners to remove comments\n\n* New annotations tab\n\n* In progress: new comments section\n\n* Address review comments\n\n* Fix\n\n* Fix annotationfilter and comments section\n\n* Add keyword and delete action\n\n* Fix and rename annotations tab\n\n* Update annotation visibility API and update comments table accordingly\n\n* Allow users seeing all the comments for their owned resources\n\n* Extend comments for volumes and snapshots\n\n* Extend comments to multiple entities\n\n* Add uuid to ssh keypairs\n\n* SSH keypair UI refactor\n\n* Extend comments to the infrastructure entities\n\n* Add missing entities\n\n* Fix upgrade version for ssh keypairs\n\n* Fix typo on DB upgrade schema\n\n* Fix annotations table columns when there is no data\n\n* Extend the list view of items showing they if they have comments\n\n* Remove extra test\n\n* Add annotation permissions\n\n* Address review comments\n\n* Extend marvin tests for annotations\n\n* updating ui stuff\n\n* addition to toggle visibility\n\n* Fix pagination on comments section\n\n* Extend to kubernetes clusters\n\n* Fixes after last review\n\n* Change default value for adminsonly column\n\n* Remove the required field for the annotationfilter parameter\n\n* Small fixes on visibility and other fixes\n\n* Cleanup to reduce files changed\n\n* Rollback extra line\n\n* Address review comments\n\n* Fix cleanup error on smoke test\n\n* Fix sending incorrect parameter to checkPermissions method\n\n* Add check domain access for the calling account for domain networks\n\n* Fix only display annotations icon if there are comments the user can see\n\n* Simply change the Save button label to Submit\n\n* Change order of the Tools menu to provent users getting 404 error on clicking the text instead of expanding\n\n* Remove comments when removing entities\n\n* Address review comments on marvin tests\n\n* Allow users to list annotations for an entity ID\n\n* Allow users to see all comments for allowed entities\n\n* Fix search filters\n\n* Remove username from search filter\n\n* Add pagination to the annotations tab\n\n* Display username for user comments\n\n* Fix add permissions for domain and resource admins\n\n* Fix for domain admins\n\n* Trivial but important UI fix\n\n* Replace pagination for annotations tab\n\n* Add confirmation for delete comment\n\n* Lint warnings\n\n* Fix reduced list as domain admin\n\n* Fix display remove comment button for non admins\n\n* Improve display remove action button\n\n* Remove unused parameter on groupShow\n\n* Include a clock icon to the all comments filter except for root admin\n\n* Move cleanup SQL to the correct file after rebasing main\n\nCo-authored-by: davidjumani <dj.davidjumani1994@gmail.com>","date":"2021-09-08 12:44:06","modifiedFileCount":"109","status":"M","submitter":"Nicolas Vazquez"}]
