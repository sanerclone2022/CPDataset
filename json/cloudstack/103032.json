[{"authorTime":"2021-07-17 09:37:42","codes":[{"authorDate":"2021-07-17 09:37:42","commitOrder":2,"curCode":"    private String cloneVMforVvols(VmwareContext context, VmwareHypervisorHost hyperHost, TemplateObjectTO template,\n                                   VirtualMachineMO vmTemplate, VolumeObjectTO volume, DatacenterMO dcMo, DatastoreMO dsMo) throws Exception {\n        ManagedObjectReference morDatastore = dsMo.getMor();\n        ManagedObjectReference morPool = hyperHost.getHyperHostOwnerResourcePool();\n        ManagedObjectReference morCluster = hyperHost.getHyperHostCluster();\n        if (template.getSize() != null) {\n            _fullCloneFlag = volume.getSize() > template.getSize() ? true : _fullCloneFlag;\n        }\n        String vmName = volume.getVmName();\n        if (volume.getVolumeType() == Volume.Type.DATADISK)\n            vmName = volume.getName();\n        if (!_fullCloneFlag) {\n            if (_diskProvisioningStrictness && volume.getProvisioningType() != ProvisioningType.THIN) {\n                throw new CloudRuntimeException(\"Unable to create linked clones with strict disk provisioning enabled\");\n            }\n            createVMLinkedClone(vmTemplate, dcMo, vmName, morDatastore, morPool);\n        } else {\n            createVMFullClone(vmTemplate, dcMo, dsMo, vmName, morDatastore, morPool, volume.getProvisioningType());\n        }\n\n        VirtualMachineMO vmMo = new ClusterMO(context, morCluster).findVmOnHyperHost(vmName);\n        assert (vmMo != null);\n        String vmdkFileBaseName = vmMo.getVmdkFileBaseNames().get(0);\n        if (volume.getVolumeType() == Volume.Type.DATADISK) {\n            s_logger.info(\"detach disks from volume-wrapper VM \" + vmName);\n            vmMo.detachAllDisks();\n            vmMo.destroy();\n        }\n        return vmdkFileBaseName;\n    }\n","date":"2021-07-17 09:37:42","endLine":936,"groupId":"17590","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"cloneVMforVvols","params":"(VmwareContextcontext@VmwareHypervisorHosthyperHost@TemplateObjectTOtemplate@VirtualMachineMOvmTemplate@VolumeObjectTOvolume@DatacenterMOdcMo@DatastoreMOdsMo)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/78/84a03f7a2800291aa3ab6f5e04d1c94b574717.src","preCode":"    private String cloneVMforVvols(VmwareContext context, VmwareHypervisorHost hyperHost, TemplateObjectTO template,\n                                   VirtualMachineMO vmTemplate, VolumeObjectTO volume, DatacenterMO dcMo, DatastoreMO dsMo) throws Exception {\n        ManagedObjectReference morDatastore = dsMo.getMor();\n        ManagedObjectReference morPool = hyperHost.getHyperHostOwnerResourcePool();\n        ManagedObjectReference morCluster = hyperHost.getHyperHostCluster();\n        if (template.getSize() != null) {\n            _fullCloneFlag = volume.getSize() > template.getSize() ? true : _fullCloneFlag;\n        }\n        String vmName = volume.getVmName();\n        if (volume.getVolumeType() == Volume.Type.DATADISK)\n            vmName = volume.getName();\n        if (!_fullCloneFlag) {\n            if (_diskProvisioningStrictness && volume.getProvisioningType() != ProvisioningType.THIN) {\n                throw new CloudRuntimeException(\"Unable to create linked clones with strict disk provisioning enabled\");\n            }\n            createVMLinkedClone(vmTemplate, dcMo, vmName, morDatastore, morPool);\n        } else {\n            createVMFullClone(vmTemplate, dcMo, dsMo, vmName, morDatastore, morPool, volume.getProvisioningType());\n        }\n\n        VirtualMachineMO vmMo = new ClusterMO(context, morCluster).findVmOnHyperHost(vmName);\n        assert (vmMo != null);\n        String vmdkFileBaseName = vmMo.getVmdkFileBaseNames().get(0);\n        if (volume.getVolumeType() == Volume.Type.DATADISK) {\n            s_logger.info(\"detach disks from volume-wrapper VM \" + vmName);\n            vmMo.detachAllDisks();\n            vmMo.destroy();\n        }\n        return vmdkFileBaseName;\n    }\n","realPath":"plugins/hypervisors/vmware/src/main/java/com/cloud/storage/resource/VmwareStorageProcessor.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":907,"status":"MB"},{"authorDate":"2021-07-17 09:37:42","commitOrder":2,"curCode":"    private String createVMAndFolderWithVMName(VmwareContext context, VmwareHypervisorHost hyperHost, TemplateObjectTO template,\n                                               VirtualMachineMO vmTemplate, VolumeObjectTO volume, DatacenterMO dcMo, DatastoreMO dsMo,\n                                               String searchExcludedFolders) throws Exception {\n        String vmdkName = volume.getName();\n        try {\n            ManagedObjectReference morDatastore = dsMo.getMor();\n            ManagedObjectReference morPool = hyperHost.getHyperHostOwnerResourcePool();\n            ManagedObjectReference morCluster = hyperHost.getHyperHostCluster();\n            if (template.getSize() != null) {\n                _fullCloneFlag = volume.getSize() > template.getSize() ? true : _fullCloneFlag;\n            }\n            if (!_fullCloneFlag) {\n                if (_diskProvisioningStrictness && volume.getProvisioningType() != ProvisioningType.THIN) {\n                    throw new CloudRuntimeException(\"Unable to create linked clones with strict disk provisioning enabled\");\n                }\n                createVMLinkedClone(vmTemplate, dcMo, vmdkName, morDatastore, morPool);\n            } else {\n                createVMFullClone(vmTemplate, dcMo, dsMo, vmdkName, morDatastore, morPool, volume.getProvisioningType());\n            }\n\n            VirtualMachineMO vmMo = new ClusterMO(context, morCluster).findVmOnHyperHost(vmdkName);\n            assert (vmMo != null);\n\n            String vmdkFileBaseName = vmMo.getVmdkFileBaseNames().get(0);\n            s_logger.info(\"Move volume out of volume-wrapper VM \" + vmdkFileBaseName);\n            String[] vmwareLayoutFilePair = VmwareStorageLayoutHelper.getVmdkFilePairDatastorePath(dsMo, vmdkName, vmdkFileBaseName, VmwareStorageLayoutType.VMWARE, !_fullCloneFlag);\n            String[] legacyCloudStackLayoutFilePair = VmwareStorageLayoutHelper.getVmdkFilePairDatastorePath(dsMo, vmdkName, vmdkFileBaseName, VmwareStorageLayoutType.CLOUDSTACK_LEGACY, !_fullCloneFlag);\n\n            for (int i = 0; i < vmwareLayoutFilePair.length; i++) {\n                dsMo.moveDatastoreFile(vmwareLayoutFilePair[i], dcMo.getMor(), dsMo.getMor(), legacyCloudStackLayoutFilePair[i], dcMo.getMor(), true);\n            }\n\n            s_logger.info(\"detach disks from volume-wrapper VM \" + vmdkName);\n            vmMo.detachAllDisks();\n\n            s_logger.info(\"destroy volume-wrapper VM \" + vmdkName);\n            vmMo.destroy();\n\n            String srcFile = dsMo.getDatastorePath(vmdkName, true);\n\n            dsMo.deleteFile(srcFile, dcMo.getMor(), true, searchExcludedFolders);\n\n            if (dsMo.folderExists(String.format(\"[%s]\", dsMo.getName()), vmdkName)) {\n                dsMo.deleteFolder(srcFile, dcMo.getMor());\n            }\n\n            \r\n            VirtualMachineMO restoreVmMo = dcMo.findVm(volume.getVmName());\n            if (restoreVmMo != null) {\n                String vmNameInVcenter = restoreVmMo.getName(); \r\n                if (dsMo.folderExists(String.format(\"[%s]\", dsMo.getName()), vmNameInVcenter)) {\n                    VmwareStorageLayoutHelper.syncVolumeToVmDefaultFolder(dcMo, vmNameInVcenter, dsMo, vmdkFileBaseName, searchExcludedFolders);\n                }\n            }\n\n            return vmdkFileBaseName;\n        } finally {\n            \r\n            VirtualMachineMO vmdknamedVM = dcMo.findVm(vmdkName);\n            if (vmdknamedVM != null) {\n                vmdknamedVM.destroy();\n            }\n        }\n    }\n","date":"2021-07-17 09:37:42","endLine":1001,"groupId":"17587","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"createVMAndFolderWithVMName","params":"(VmwareContextcontext@VmwareHypervisorHosthyperHost@TemplateObjectTOtemplate@VirtualMachineMOvmTemplate@VolumeObjectTOvolume@DatacenterMOdcMo@DatastoreMOdsMo@StringsearchExcludedFolders)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/78/84a03f7a2800291aa3ab6f5e04d1c94b574717.src","preCode":"    private String createVMAndFolderWithVMName(VmwareContext context, VmwareHypervisorHost hyperHost, TemplateObjectTO template,\n                                               VirtualMachineMO vmTemplate, VolumeObjectTO volume, DatacenterMO dcMo, DatastoreMO dsMo,\n                                               String searchExcludedFolders) throws Exception {\n        String vmdkName = volume.getName();\n        try {\n            ManagedObjectReference morDatastore = dsMo.getMor();\n            ManagedObjectReference morPool = hyperHost.getHyperHostOwnerResourcePool();\n            ManagedObjectReference morCluster = hyperHost.getHyperHostCluster();\n            if (template.getSize() != null) {\n                _fullCloneFlag = volume.getSize() > template.getSize() ? true : _fullCloneFlag;\n            }\n            if (!_fullCloneFlag) {\n                if (_diskProvisioningStrictness && volume.getProvisioningType() != ProvisioningType.THIN) {\n                    throw new CloudRuntimeException(\"Unable to create linked clones with strict disk provisioning enabled\");\n                }\n                createVMLinkedClone(vmTemplate, dcMo, vmdkName, morDatastore, morPool);\n            } else {\n                createVMFullClone(vmTemplate, dcMo, dsMo, vmdkName, morDatastore, morPool, volume.getProvisioningType());\n            }\n\n            VirtualMachineMO vmMo = new ClusterMO(context, morCluster).findVmOnHyperHost(vmdkName);\n            assert (vmMo != null);\n\n            String vmdkFileBaseName = vmMo.getVmdkFileBaseNames().get(0);\n            s_logger.info(\"Move volume out of volume-wrapper VM \" + vmdkFileBaseName);\n            String[] vmwareLayoutFilePair = VmwareStorageLayoutHelper.getVmdkFilePairDatastorePath(dsMo, vmdkName, vmdkFileBaseName, VmwareStorageLayoutType.VMWARE, !_fullCloneFlag);\n            String[] legacyCloudStackLayoutFilePair = VmwareStorageLayoutHelper.getVmdkFilePairDatastorePath(dsMo, vmdkName, vmdkFileBaseName, VmwareStorageLayoutType.CLOUDSTACK_LEGACY, !_fullCloneFlag);\n\n            for (int i = 0; i < vmwareLayoutFilePair.length; i++) {\n                dsMo.moveDatastoreFile(vmwareLayoutFilePair[i], dcMo.getMor(), dsMo.getMor(), legacyCloudStackLayoutFilePair[i], dcMo.getMor(), true);\n            }\n\n            s_logger.info(\"detach disks from volume-wrapper VM \" + vmdkName);\n            vmMo.detachAllDisks();\n\n            s_logger.info(\"destroy volume-wrapper VM \" + vmdkName);\n            vmMo.destroy();\n\n            String srcFile = dsMo.getDatastorePath(vmdkName, true);\n\n            dsMo.deleteFile(srcFile, dcMo.getMor(), true, searchExcludedFolders);\n\n            if (dsMo.folderExists(String.format(\"[%s]\", dsMo.getName()), vmdkName)) {\n                dsMo.deleteFolder(srcFile, dcMo.getMor());\n            }\n\n            \r\n            VirtualMachineMO restoreVmMo = dcMo.findVm(volume.getVmName());\n            if (restoreVmMo != null) {\n                String vmNameInVcenter = restoreVmMo.getName(); \r\n                if (dsMo.folderExists(String.format(\"[%s]\", dsMo.getName()), vmNameInVcenter)) {\n                    VmwareStorageLayoutHelper.syncVolumeToVmDefaultFolder(dcMo, vmNameInVcenter, dsMo, vmdkFileBaseName, searchExcludedFolders);\n                }\n            }\n\n            return vmdkFileBaseName;\n        } finally {\n            \r\n            VirtualMachineMO vmdknamedVM = dcMo.findVm(vmdkName);\n            if (vmdknamedVM != null) {\n                vmdknamedVM.destroy();\n            }\n        }\n    }\n","realPath":"plugins/hypervisors/vmware/src/main/java/com/cloud/storage/resource/VmwareStorageProcessor.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":938,"status":"B"}],"commitId":"96c9c5a5e2251174da7da881ab1d0f8e1f323aac","commitMessage":"@@@Added disk provisioning type support for VMWare (#4640)\n\n* Added disk provisioning type support for VMWare\n\n* Review changes\n\n* Fixed unit test\n\n* Review changes\n\n* Added missing licenses\n\n* Review changes\n\n* Update StoragePoolInfo.java\n\nRemoved white space\n\n* Review change - Getting disk provisioning strictness setting using the zone id and not the pool id\n\n* Delete __init__.py\n\n* Merge fix\n\n* Fixed failing test\n\n* Added comment about parameters\n\n* Added error log when update fails\n\n* Added exception when using API\n\n* Ordering storage pool selection to prefer thick disk capable pools if available\n\n* Removed unused parameter\n\n* Reordering changes\n\n* Returning storage pool details after update\n\n* Removed multiple pool update.  updated marvin test.  removed duplicate enum\n\n* Removed comment\n\n* Removed unused import\n\n* Removed for loop\n\n* Added missing return statements for failed checks\n\n* Class name change\n\n* Null pointer\n\n* Added more info when a deployment fails\n\n* Null pointer\n\n* Update api/src/main/java/org/apache/cloudstack/api/BaseListCmd.java\n\nCo-authored-by: dahn <daan.hoogland@gmail.com>\n\n* Small bug fix on API response and added missing bracket\n\n* Removed datastore cluster code\n\n* Removed unused imports.  added missing signature\n\n* Removed duplicate config key\n\n* Revert \"Added more info when a deployment fails\"\n\nThis reverts commit 2486db78dca8e034d8ad2386174dfb11004ce654.\n\nCo-authored-by: dahn <daan.hoogland@gmail.com>","date":"2021-07-17 09:37:42","modifiedFileCount":"23","status":"M","submitter":"Spaceman1984"},{"authorTime":"2021-09-02 18:43:33","codes":[{"authorDate":"2021-09-02 18:43:33","commitOrder":3,"curCode":"    private String cloneVMforVvols(VmwareContext context, VmwareHypervisorHost hyperHost, TemplateObjectTO template,\n                                   VirtualMachineMO vmTemplate, VolumeObjectTO volume, DatacenterMO dcMo, DatastoreMO dsMo) throws Exception {\n        ManagedObjectReference morDatastore = dsMo.getMor();\n        ManagedObjectReference morPool = hyperHost.getHyperHostOwnerResourcePool();\n        ManagedObjectReference morCluster = hyperHost.getHyperHostCluster();\n        if (template.getSize() != null) {\n            _fullCloneFlag = volume.getSize() > template.getSize() ? true : _fullCloneFlag;\n        }\n        String vmName = volume.getVmName();\n        if (volume.getVolumeType() == Volume.Type.DATADISK)\n            vmName = volume.getName();\n        if (!_fullCloneFlag) {\n            if (_diskProvisioningStrictness && volume.getProvisioningType() != ProvisioningType.THIN) {\n                throw new CloudRuntimeException(\"Unable to create linked clones with strict disk provisioning enabled\");\n            }\n            createVMLinkedClone(vmTemplate, dcMo, vmName, morDatastore, morPool);\n        } else {\n            createVMFullClone(vmTemplate, dcMo, dsMo, vmName, morDatastore, morPool, volume.getProvisioningType());\n        }\n\n        VirtualMachineMO vmMo = new ClusterMO(context, morCluster).findVmOnHyperHost(vmName);\n        assert (vmMo != null);\n        String vmdkFileBaseName = vmMo.getVmdkFileBaseNames().get(0);\n        if (volume.getVolumeType() == Volume.Type.DATADISK) {\n            s_logger.info(\"detach disks from volume-wrapper VM \" + vmName);\n            vmMo.detachAllDisksAndDestroy();\n        }\n        return vmdkFileBaseName;\n    }\n","date":"2021-09-02 18:43:33","endLine":933,"groupId":"103032","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"cloneVMforVvols","params":"(VmwareContextcontext@VmwareHypervisorHosthyperHost@TemplateObjectTOtemplate@VirtualMachineMOvmTemplate@VolumeObjectTOvolume@DatacenterMOdcMo@DatastoreMOdsMo)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/81/0f355662ad1cc9201a5d818e6a8e758c76960b.src","preCode":"    private String cloneVMforVvols(VmwareContext context, VmwareHypervisorHost hyperHost, TemplateObjectTO template,\n                                   VirtualMachineMO vmTemplate, VolumeObjectTO volume, DatacenterMO dcMo, DatastoreMO dsMo) throws Exception {\n        ManagedObjectReference morDatastore = dsMo.getMor();\n        ManagedObjectReference morPool = hyperHost.getHyperHostOwnerResourcePool();\n        ManagedObjectReference morCluster = hyperHost.getHyperHostCluster();\n        if (template.getSize() != null) {\n            _fullCloneFlag = volume.getSize() > template.getSize() ? true : _fullCloneFlag;\n        }\n        String vmName = volume.getVmName();\n        if (volume.getVolumeType() == Volume.Type.DATADISK)\n            vmName = volume.getName();\n        if (!_fullCloneFlag) {\n            if (_diskProvisioningStrictness && volume.getProvisioningType() != ProvisioningType.THIN) {\n                throw new CloudRuntimeException(\"Unable to create linked clones with strict disk provisioning enabled\");\n            }\n            createVMLinkedClone(vmTemplate, dcMo, vmName, morDatastore, morPool);\n        } else {\n            createVMFullClone(vmTemplate, dcMo, dsMo, vmName, morDatastore, morPool, volume.getProvisioningType());\n        }\n\n        VirtualMachineMO vmMo = new ClusterMO(context, morCluster).findVmOnHyperHost(vmName);\n        assert (vmMo != null);\n        String vmdkFileBaseName = vmMo.getVmdkFileBaseNames().get(0);\n        if (volume.getVolumeType() == Volume.Type.DATADISK) {\n            s_logger.info(\"detach disks from volume-wrapper VM \" + vmName);\n            vmMo.detachAllDisks();\n            vmMo.destroy();\n        }\n        return vmdkFileBaseName;\n    }\n","realPath":"plugins/hypervisors/vmware/src/main/java/com/cloud/storage/resource/VmwareStorageProcessor.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":905,"status":"M"},{"authorDate":"2021-09-02 18:43:33","commitOrder":3,"curCode":"    private String createVMAndFolderWithVMName(VmwareContext context, VmwareHypervisorHost hyperHost, TemplateObjectTO template,\n                                               VirtualMachineMO vmTemplate, VolumeObjectTO volume, DatacenterMO dcMo, DatastoreMO dsMo,\n                                               String searchExcludedFolders) throws Exception {\n        String vmdkName = volume.getName();\n        try {\n            ManagedObjectReference morDatastore = dsMo.getMor();\n            ManagedObjectReference morPool = hyperHost.getHyperHostOwnerResourcePool();\n            ManagedObjectReference morCluster = hyperHost.getHyperHostCluster();\n            if (template.getSize() != null) {\n                _fullCloneFlag = volume.getSize() > template.getSize() ? true : _fullCloneFlag;\n            }\n            if (!_fullCloneFlag) {\n                if (_diskProvisioningStrictness && volume.getProvisioningType() != ProvisioningType.THIN) {\n                    throw new CloudRuntimeException(\"Unable to create linked clones with strict disk provisioning enabled\");\n                }\n                createVMLinkedClone(vmTemplate, dcMo, vmdkName, morDatastore, morPool);\n            } else {\n                createVMFullClone(vmTemplate, dcMo, dsMo, vmdkName, morDatastore, morPool, volume.getProvisioningType());\n            }\n\n            VirtualMachineMO vmMo = new ClusterMO(context, morCluster).findVmOnHyperHost(vmdkName);\n            assert (vmMo != null);\n\n            String vmdkFileBaseName = vmMo.getVmdkFileBaseNames().get(0);\n            s_logger.info(\"Move volume out of volume-wrapper VM \" + vmdkFileBaseName);\n            String[] vmwareLayoutFilePair = VmwareStorageLayoutHelper.getVmdkFilePairDatastorePath(dsMo, vmdkName, vmdkFileBaseName, VmwareStorageLayoutType.VMWARE, !_fullCloneFlag);\n            String[] legacyCloudStackLayoutFilePair = VmwareStorageLayoutHelper.getVmdkFilePairDatastorePath(dsMo, vmdkName, vmdkFileBaseName, VmwareStorageLayoutType.CLOUDSTACK_LEGACY, !_fullCloneFlag);\n\n            for (int i = 0; i < vmwareLayoutFilePair.length; i++) {\n                dsMo.moveDatastoreFile(vmwareLayoutFilePair[i], dcMo.getMor(), dsMo.getMor(), legacyCloudStackLayoutFilePair[i], dcMo.getMor(), true);\n            }\n\n            s_logger.info(\"detach disks from volume-wrapper VM and destroy\" + vmdkName);\n            vmMo.detachAllDisksAndDestroy();\n\n            String srcFile = dsMo.getDatastorePath(vmdkName, true);\n\n            dsMo.deleteFile(srcFile, dcMo.getMor(), true, searchExcludedFolders);\n\n            if (dsMo.folderExists(String.format(\"[%s]\", dsMo.getName()), vmdkName)) {\n                dsMo.deleteFolder(srcFile, dcMo.getMor());\n            }\n\n            \r\n            VirtualMachineMO restoreVmMo = dcMo.findVm(volume.getVmName());\n            if (restoreVmMo != null) {\n                String vmNameInVcenter = restoreVmMo.getName(); \r\n                if (dsMo.folderExists(String.format(\"[%s]\", dsMo.getName()), vmNameInVcenter)) {\n                    VmwareStorageLayoutHelper.syncVolumeToVmDefaultFolder(dcMo, vmNameInVcenter, dsMo, vmdkFileBaseName, searchExcludedFolders);\n                }\n            }\n\n            return vmdkFileBaseName;\n        } finally {\n            \r\n            VirtualMachineMO vmdknamedVM = dcMo.findVm(vmdkName);\n            if (vmdknamedVM != null) {\n                vmdknamedVM.destroy();\n            }\n        }\n    }\n","date":"2021-09-02 18:43:33","endLine":995,"groupId":"103032","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"createVMAndFolderWithVMName","params":"(VmwareContextcontext@VmwareHypervisorHosthyperHost@TemplateObjectTOtemplate@VirtualMachineMOvmTemplate@VolumeObjectTOvolume@DatacenterMOdcMo@DatastoreMOdsMo@StringsearchExcludedFolders)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/81/0f355662ad1cc9201a5d818e6a8e758c76960b.src","preCode":"    private String createVMAndFolderWithVMName(VmwareContext context, VmwareHypervisorHost hyperHost, TemplateObjectTO template,\n                                               VirtualMachineMO vmTemplate, VolumeObjectTO volume, DatacenterMO dcMo, DatastoreMO dsMo,\n                                               String searchExcludedFolders) throws Exception {\n        String vmdkName = volume.getName();\n        try {\n            ManagedObjectReference morDatastore = dsMo.getMor();\n            ManagedObjectReference morPool = hyperHost.getHyperHostOwnerResourcePool();\n            ManagedObjectReference morCluster = hyperHost.getHyperHostCluster();\n            if (template.getSize() != null) {\n                _fullCloneFlag = volume.getSize() > template.getSize() ? true : _fullCloneFlag;\n            }\n            if (!_fullCloneFlag) {\n                if (_diskProvisioningStrictness && volume.getProvisioningType() != ProvisioningType.THIN) {\n                    throw new CloudRuntimeException(\"Unable to create linked clones with strict disk provisioning enabled\");\n                }\n                createVMLinkedClone(vmTemplate, dcMo, vmdkName, morDatastore, morPool);\n            } else {\n                createVMFullClone(vmTemplate, dcMo, dsMo, vmdkName, morDatastore, morPool, volume.getProvisioningType());\n            }\n\n            VirtualMachineMO vmMo = new ClusterMO(context, morCluster).findVmOnHyperHost(vmdkName);\n            assert (vmMo != null);\n\n            String vmdkFileBaseName = vmMo.getVmdkFileBaseNames().get(0);\n            s_logger.info(\"Move volume out of volume-wrapper VM \" + vmdkFileBaseName);\n            String[] vmwareLayoutFilePair = VmwareStorageLayoutHelper.getVmdkFilePairDatastorePath(dsMo, vmdkName, vmdkFileBaseName, VmwareStorageLayoutType.VMWARE, !_fullCloneFlag);\n            String[] legacyCloudStackLayoutFilePair = VmwareStorageLayoutHelper.getVmdkFilePairDatastorePath(dsMo, vmdkName, vmdkFileBaseName, VmwareStorageLayoutType.CLOUDSTACK_LEGACY, !_fullCloneFlag);\n\n            for (int i = 0; i < vmwareLayoutFilePair.length; i++) {\n                dsMo.moveDatastoreFile(vmwareLayoutFilePair[i], dcMo.getMor(), dsMo.getMor(), legacyCloudStackLayoutFilePair[i], dcMo.getMor(), true);\n            }\n\n            s_logger.info(\"detach disks from volume-wrapper VM \" + vmdkName);\n            vmMo.detachAllDisks();\n\n            s_logger.info(\"destroy volume-wrapper VM \" + vmdkName);\n            vmMo.destroy();\n\n            String srcFile = dsMo.getDatastorePath(vmdkName, true);\n\n            dsMo.deleteFile(srcFile, dcMo.getMor(), true, searchExcludedFolders);\n\n            if (dsMo.folderExists(String.format(\"[%s]\", dsMo.getName()), vmdkName)) {\n                dsMo.deleteFolder(srcFile, dcMo.getMor());\n            }\n\n            \r\n            VirtualMachineMO restoreVmMo = dcMo.findVm(volume.getVmName());\n            if (restoreVmMo != null) {\n                String vmNameInVcenter = restoreVmMo.getName(); \r\n                if (dsMo.folderExists(String.format(\"[%s]\", dsMo.getName()), vmNameInVcenter)) {\n                    VmwareStorageLayoutHelper.syncVolumeToVmDefaultFolder(dcMo, vmNameInVcenter, dsMo, vmdkFileBaseName, searchExcludedFolders);\n                }\n            }\n\n            return vmdkFileBaseName;\n        } finally {\n            \r\n            VirtualMachineMO vmdknamedVM = dcMo.findVm(vmdkName);\n            if (vmdknamedVM != null) {\n                vmdknamedVM.destroy();\n            }\n        }\n    }\n","realPath":"plugins/hypervisors/vmware/src/main/java/com/cloud/storage/resource/VmwareStorageProcessor.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":935,"status":"M"}],"commitId":"56f4da6dce8aefc106c4697d9fbbfe47755336ca","commitMessage":"@@@Merge remote-tracking branch 'apache/4.15' into main\n","date":"2021-09-02 18:43:33","modifiedFileCount":"15","status":"M","submitter":"Abhishek Kumar"}]
