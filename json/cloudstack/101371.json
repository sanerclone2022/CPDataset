[{"authorTime":"2018-03-08 05:23:15","codes":[{"authorDate":"2018-11-30 21:27:31","commitOrder":3,"curCode":"    private void validateVolumes(List<VolumeVO> volumes) {\n\n        for (VolumeVO volume : volumes) {\n            if (!(volume.getVolumeType() == Volume.Type.ROOT || volume.getVolumeType() == Volume.Type.DATADISK)) {\n                throw new InvalidParameterValueException(\"Please specify volume of type \" + Volume.Type.DATADISK.toString() + \" or \" + Volume.Type.ROOT.toString());\n            }\n        }\n    }\n","date":"2018-11-30 21:27:31","endLine":6577,"groupId":"7004","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"validateVolumes","params":"(List<VolumeVO>volumes)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/eb/de735ef7c02e3214a2fa041af98b1ec148ff4a.src","preCode":"    private void validateVolumes(List<VolumeVO> volumes) {\n\n        for (VolumeVO volume : volumes) {\n            if (!(volume.getVolumeType() == Volume.Type.ROOT || volume.getVolumeType() == Volume.Type.DATADISK)) {\n                throw new InvalidParameterValueException(\"Please specify volume of type \" + Volume.Type.DATADISK.toString() + \" or \" + Volume.Type.ROOT.toString());\n            }\n        }\n    }\n","realPath":"server/src/main/java/com/cloud/vm/UserVmManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":6570,"status":"B"},{"authorDate":"2018-03-08 05:23:15","commitOrder":3,"curCode":"    public Volume detachVolumeFromVM(DetachVolumeCmd cmmd) {\n        Account caller = CallContext.current().getCallingAccount();\n        if ((cmmd.getId() == null && cmmd.getDeviceId() == null && cmmd.getVirtualMachineId() == null)\n                || (cmmd.getId() != null && (cmmd.getDeviceId() != null || cmmd.getVirtualMachineId() != null))\n                || (cmmd.getId() == null && (cmmd.getDeviceId() == null || cmmd.getVirtualMachineId() == null))) {\n            throw new InvalidParameterValueException(\"Please provide either a volume id, or a tuple(device id, instance id)\");\n        }\n\n        Long volumeId = cmmd.getId();\n        VolumeVO volume = null;\n\n        if (volumeId != null) {\n            volume = _volsDao.findById(volumeId);\n        } else {\n            volume = _volsDao.findByInstanceAndDeviceId(cmmd.getVirtualMachineId(), cmmd.getDeviceId()).get(0);\n        }\n\n        \r\n        if (volume == null) {\n            throw new InvalidParameterValueException(\"Unable to find volume with ID: \" + volumeId);\n        }\n\n        Long vmId = null;\n\n        if (cmmd.getVirtualMachineId() == null) {\n            vmId = volume.getInstanceId();\n        } else {\n            vmId = cmmd.getVirtualMachineId();\n        }\n\n        \r\n        _accountMgr.checkAccess(caller, null, true, volume);\n\n        \r\n        if (vmId == null) {\n            throw new InvalidParameterValueException(\"The specified volume is not attached to a VM.\");\n        }\n\n        \r\n        UserVmVO vm = _userVmDao.findById(vmId);\n        if (vm.getState() != State.Running && vm.getState() != State.Stopped && vm.getState() != State.Destroyed) {\n            throw new InvalidParameterValueException(\"Please specify a VM that is either running or stopped.\");\n        }\n\n        \r\n        if (!(volume.getVolumeType() == Volume.Type.ROOT || volume.getVolumeType() == Volume.Type.DATADISK)) {\n            throw new InvalidParameterValueException(\"Please specify volume of type \" + Volume.Type.DATADISK.toString() + \" or \" + Volume.Type.ROOT.toString());\n        }\n\n        \r\n        if (volume.getVolumeType() == Volume.Type.ROOT) {\n            validateRootVolumeDetachAttach(volume, vm);\n        }\n\n        \r\n        List<VMSnapshotVO> vmSnapshots = _vmSnapshotDao.findByVm(vmId);\n        if (vmSnapshots.size() > 0) {\n            throw new InvalidParameterValueException(\"Unable to detach volume, please specify a VM that does not have VM snapshots\");\n        }\n\n        AsyncJobExecutionContext asyncExecutionContext = AsyncJobExecutionContext.getCurrentExecutionContext();\n        if (asyncExecutionContext != null) {\n            AsyncJob job = asyncExecutionContext.getJob();\n\n            if (s_logger.isInfoEnabled()) {\n                s_logger.info(\"Trying to attaching volume \" + volumeId + \"to vm instance:\" + vm.getId() + \", update async job-\" + job.getId() + \" progress status\");\n            }\n\n            _jobMgr.updateAsyncJobAttachment(job.getId(), \"Volume\", volumeId);\n        }\n\n        AsyncJobExecutionContext jobContext = AsyncJobExecutionContext.getCurrentExecutionContext();\n        if (jobContext.isJobDispatchedBy(VmWorkConstants.VM_WORK_JOB_DISPATCHER)) {\n            \r\n            VmWorkJobVO placeHolder = null;\n            placeHolder = createPlaceHolderWork(vmId);\n            try {\n                return orchestrateDetachVolumeFromVM(vmId, volumeId);\n            } finally {\n                _workJobDao.expunge(placeHolder.getId());\n            }\n        } else {\n            Outcome<Volume> outcome = detachVolumeFromVmThroughJobQueue(vmId, volumeId);\n\n            Volume vol = null;\n            try {\n                outcome.get();\n            } catch (InterruptedException e) {\n                throw new RuntimeException(\"Operation is interrupted\", e);\n            } catch (java.util.concurrent.ExecutionException e) {\n                throw new RuntimeException(\"Execution excetion\", e);\n            }\n\n            Object jobResult = _jobMgr.unmarshallResultObject(outcome.getJob());\n            if (jobResult != null) {\n                if (jobResult instanceof ConcurrentOperationException) {\n                    throw (ConcurrentOperationException)jobResult;\n                } else if (jobResult instanceof RuntimeException) {\n                    throw (RuntimeException)jobResult;\n                } else if (jobResult instanceof Throwable) {\n                    throw new RuntimeException(\"Unexpected exception\", (Throwable)jobResult);\n                } else if (jobResult instanceof Long) {\n                    vol = _volsDao.findById((Long) jobResult);\n                }\n            }\n            return vol;\n        }\n    }\n","date":"2018-03-08 05:23:15","endLine":1803,"groupId":"7004","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"detachVolumeFromVM","params":"(DetachVolumeCmdcmmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/2a/c317c660f92cd8faf2e626aa2c6ec95a6b3a4b.src","preCode":"    public Volume detachVolumeFromVM(DetachVolumeCmd cmmd) {\n        Account caller = CallContext.current().getCallingAccount();\n        if ((cmmd.getId() == null && cmmd.getDeviceId() == null && cmmd.getVirtualMachineId() == null)\n                || (cmmd.getId() != null && (cmmd.getDeviceId() != null || cmmd.getVirtualMachineId() != null))\n                || (cmmd.getId() == null && (cmmd.getDeviceId() == null || cmmd.getVirtualMachineId() == null))) {\n            throw new InvalidParameterValueException(\"Please provide either a volume id, or a tuple(device id, instance id)\");\n        }\n\n        Long volumeId = cmmd.getId();\n        VolumeVO volume = null;\n\n        if (volumeId != null) {\n            volume = _volsDao.findById(volumeId);\n        } else {\n            volume = _volsDao.findByInstanceAndDeviceId(cmmd.getVirtualMachineId(), cmmd.getDeviceId()).get(0);\n        }\n\n        \r\n        if (volume == null) {\n            throw new InvalidParameterValueException(\"Unable to find volume with ID: \" + volumeId);\n        }\n\n        Long vmId = null;\n\n        if (cmmd.getVirtualMachineId() == null) {\n            vmId = volume.getInstanceId();\n        } else {\n            vmId = cmmd.getVirtualMachineId();\n        }\n\n        \r\n        _accountMgr.checkAccess(caller, null, true, volume);\n\n        \r\n        if (vmId == null) {\n            throw new InvalidParameterValueException(\"The specified volume is not attached to a VM.\");\n        }\n\n        \r\n        UserVmVO vm = _userVmDao.findById(vmId);\n        if (vm.getState() != State.Running && vm.getState() != State.Stopped && vm.getState() != State.Destroyed) {\n            throw new InvalidParameterValueException(\"Please specify a VM that is either running or stopped.\");\n        }\n\n        \r\n        if (!(volume.getVolumeType() == Volume.Type.ROOT || volume.getVolumeType() == Volume.Type.DATADISK)) {\n            throw new InvalidParameterValueException(\"Please specify volume of type \" + Volume.Type.DATADISK.toString() + \" or \" + Volume.Type.ROOT.toString());\n        }\n\n        \r\n        if (volume.getVolumeType() == Volume.Type.ROOT) {\n            validateRootVolumeDetachAttach(volume, vm);\n        }\n\n        \r\n        List<VMSnapshotVO> vmSnapshots = _vmSnapshotDao.findByVm(vmId);\n        if (vmSnapshots.size() > 0) {\n            throw new InvalidParameterValueException(\"Unable to detach volume, please specify a VM that does not have VM snapshots\");\n        }\n\n        AsyncJobExecutionContext asyncExecutionContext = AsyncJobExecutionContext.getCurrentExecutionContext();\n        if (asyncExecutionContext != null) {\n            AsyncJob job = asyncExecutionContext.getJob();\n\n            if (s_logger.isInfoEnabled()) {\n                s_logger.info(\"Trying to attaching volume \" + volumeId + \"to vm instance:\" + vm.getId() + \", update async job-\" + job.getId() + \" progress status\");\n            }\n\n            _jobMgr.updateAsyncJobAttachment(job.getId(), \"Volume\", volumeId);\n        }\n\n        AsyncJobExecutionContext jobContext = AsyncJobExecutionContext.getCurrentExecutionContext();\n        if (jobContext.isJobDispatchedBy(VmWorkConstants.VM_WORK_JOB_DISPATCHER)) {\n            \r\n            VmWorkJobVO placeHolder = null;\n            placeHolder = createPlaceHolderWork(vmId);\n            try {\n                return orchestrateDetachVolumeFromVM(vmId, volumeId);\n            } finally {\n                _workJobDao.expunge(placeHolder.getId());\n            }\n        } else {\n            Outcome<Volume> outcome = detachVolumeFromVmThroughJobQueue(vmId, volumeId);\n\n            Volume vol = null;\n            try {\n                outcome.get();\n            } catch (InterruptedException e) {\n                throw new RuntimeException(\"Operation is interrupted\", e);\n            } catch (java.util.concurrent.ExecutionException e) {\n                throw new RuntimeException(\"Execution excetion\", e);\n            }\n\n            Object jobResult = _jobMgr.unmarshallResultObject(outcome.getJob());\n            if (jobResult != null) {\n                if (jobResult instanceof ConcurrentOperationException) {\n                    throw (ConcurrentOperationException)jobResult;\n                } else if (jobResult instanceof RuntimeException) {\n                    throw (RuntimeException)jobResult;\n                } else if (jobResult instanceof Throwable) {\n                    throw new RuntimeException(\"Unexpected exception\", (Throwable)jobResult);\n                } else if (jobResult instanceof Long) {\n                    vol = _volsDao.findById((Long) jobResult);\n                }\n            }\n            return vol;\n        }\n    }\n","realPath":"server/src/main/java/com/cloud/storage/VolumeApiServiceImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1696,"status":"NB"}],"commitId":"525ddfb7171ec44a1938324f3f62134f3cf13fdd","commitMessage":"@@@Destroyvm also removes volumes (#2793)\n\n* Allow user to detach and delete volumes when destroyinh VMs\n\n* Minor code refactoring\n","date":"2018-11-30 21:27:31","modifiedFileCount":"5","status":"M","submitter":"Henko"},{"authorTime":"2020-03-03 20:27:58","codes":[{"authorDate":"2018-11-30 21:27:31","commitOrder":4,"curCode":"    private void validateVolumes(List<VolumeVO> volumes) {\n\n        for (VolumeVO volume : volumes) {\n            if (!(volume.getVolumeType() == Volume.Type.ROOT || volume.getVolumeType() == Volume.Type.DATADISK)) {\n                throw new InvalidParameterValueException(\"Please specify volume of type \" + Volume.Type.DATADISK.toString() + \" or \" + Volume.Type.ROOT.toString());\n            }\n        }\n    }\n","date":"2018-11-30 21:27:31","endLine":6577,"groupId":"101371","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"validateVolumes","params":"(List<VolumeVO>volumes)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/eb/de735ef7c02e3214a2fa041af98b1ec148ff4a.src","preCode":"    private void validateVolumes(List<VolumeVO> volumes) {\n\n        for (VolumeVO volume : volumes) {\n            if (!(volume.getVolumeType() == Volume.Type.ROOT || volume.getVolumeType() == Volume.Type.DATADISK)) {\n                throw new InvalidParameterValueException(\"Please specify volume of type \" + Volume.Type.DATADISK.toString() + \" or \" + Volume.Type.ROOT.toString());\n            }\n        }\n    }\n","realPath":"server/src/main/java/com/cloud/vm/UserVmManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":6570,"status":"N"},{"authorDate":"2020-03-03 20:27:58","commitOrder":4,"curCode":"    public Volume detachVolumeFromVM(DetachVolumeCmd cmmd) {\n        Account caller = CallContext.current().getCallingAccount();\n        if ((cmmd.getId() == null && cmmd.getDeviceId() == null && cmmd.getVirtualMachineId() == null) || (cmmd.getId() != null && (cmmd.getDeviceId() != null || cmmd.getVirtualMachineId() != null))\n                || (cmmd.getId() == null && (cmmd.getDeviceId() == null || cmmd.getVirtualMachineId() == null))) {\n            throw new InvalidParameterValueException(\"Please provide either a volume id, or a tuple(device id, instance id)\");\n        }\n\n        Long volumeId = cmmd.getId();\n        VolumeVO volume = null;\n\n        if (volumeId != null) {\n            volume = _volsDao.findById(volumeId);\n        } else {\n            volume = _volsDao.findByInstanceAndDeviceId(cmmd.getVirtualMachineId(), cmmd.getDeviceId()).get(0);\n        }\n\n        \r\n        if (volume == null) {\n            throw new InvalidParameterValueException(\"Unable to find volume with ID: \" + volumeId);\n        }\n\n        Long vmId = null;\n\n        if (cmmd.getVirtualMachineId() == null) {\n            vmId = volume.getInstanceId();\n        } else {\n            vmId = cmmd.getVirtualMachineId();\n        }\n\n        \r\n        _accountMgr.checkAccess(caller, null, true, volume);\n\n        \r\n        if (vmId == null) {\n            throw new InvalidParameterValueException(\"The specified volume is not attached to a VM.\");\n        }\n\n        \r\n        UserVmVO vm = _userVmDao.findById(vmId);\n        if (vm.getState() != State.Running && vm.getState() != State.Stopped && vm.getState() != State.Destroyed) {\n            throw new InvalidParameterValueException(\"Please specify a VM that is either running or stopped.\");\n        }\n\n        \r\n        if (!(volume.getVolumeType() == Volume.Type.ROOT || volume.getVolumeType() == Volume.Type.DATADISK)) {\n            throw new InvalidParameterValueException(\"Please specify volume of type \" + Volume.Type.DATADISK.toString() + \" or \" + Volume.Type.ROOT.toString());\n        }\n\n        \r\n        if (volume.getVolumeType() == Volume.Type.ROOT) {\n            validateRootVolumeDetachAttach(volume, vm);\n        }\n\n        \r\n        List<VMSnapshotVO> vmSnapshots = _vmSnapshotDao.findByVm(vmId);\n        if (vmSnapshots.size() > 0) {\n            throw new InvalidParameterValueException(\"Unable to detach volume, please specify a VM that does not have VM snapshots\");\n        }\n\n        if (vm.getBackupOfferingId() != null || vm.getBackupVolumeList().size() > 0) {\n            throw new InvalidParameterValueException(\"Unable to detach volume, cannot detach volume from a VM that has backups. First remove the VM from the backup offering.\");\n        }\n\n        AsyncJobExecutionContext asyncExecutionContext = AsyncJobExecutionContext.getCurrentExecutionContext();\n        if (asyncExecutionContext != null) {\n            AsyncJob job = asyncExecutionContext.getJob();\n\n            if (s_logger.isInfoEnabled()) {\n                s_logger.info(\"Trying to attaching volume \" + volumeId + \"to vm instance:\" + vm.getId() + \", update async job-\" + job.getId() + \" progress status\");\n            }\n\n            _jobMgr.updateAsyncJobAttachment(job.getId(), \"Volume\", volumeId);\n        }\n\n        AsyncJobExecutionContext jobContext = AsyncJobExecutionContext.getCurrentExecutionContext();\n        if (jobContext.isJobDispatchedBy(VmWorkConstants.VM_WORK_JOB_DISPATCHER)) {\n            \r\n            VmWorkJobVO placeHolder = null;\n            placeHolder = createPlaceHolderWork(vmId);\n            try {\n                return orchestrateDetachVolumeFromVM(vmId, volumeId);\n            } finally {\n                _workJobDao.expunge(placeHolder.getId());\n            }\n        } else {\n            Outcome<Volume> outcome = detachVolumeFromVmThroughJobQueue(vmId, volumeId);\n\n            Volume vol = null;\n            try {\n                outcome.get();\n            } catch (InterruptedException e) {\n                throw new RuntimeException(\"Operation is interrupted\", e);\n            } catch (java.util.concurrent.ExecutionException e) {\n                throw new RuntimeException(\"Execution excetion\", e);\n            }\n\n            Object jobResult = _jobMgr.unmarshallResultObject(outcome.getJob());\n            if (jobResult != null) {\n                if (jobResult instanceof ConcurrentOperationException) {\n                    throw (ConcurrentOperationException)jobResult;\n                } else if (jobResult instanceof RuntimeException) {\n                    throw (RuntimeException)jobResult;\n                } else if (jobResult instanceof Throwable) {\n                    throw new RuntimeException(\"Unexpected exception\", (Throwable)jobResult);\n                } else if (jobResult instanceof Long) {\n                    vol = _volsDao.findById((Long)jobResult);\n                }\n            }\n            return vol;\n        }\n    }\n","date":"2020-03-03 20:27:58","endLine":1936,"groupId":"101371","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"detachVolumeFromVM","params":"(DetachVolumeCmdcmmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/88/af6e9aa854ec828c74cc00fe7a05bb42e7b477.src","preCode":"    public Volume detachVolumeFromVM(DetachVolumeCmd cmmd) {\n        Account caller = CallContext.current().getCallingAccount();\n        if ((cmmd.getId() == null && cmmd.getDeviceId() == null && cmmd.getVirtualMachineId() == null) || (cmmd.getId() != null && (cmmd.getDeviceId() != null || cmmd.getVirtualMachineId() != null))\n                || (cmmd.getId() == null && (cmmd.getDeviceId() == null || cmmd.getVirtualMachineId() == null))) {\n            throw new InvalidParameterValueException(\"Please provide either a volume id, or a tuple(device id, instance id)\");\n        }\n\n        Long volumeId = cmmd.getId();\n        VolumeVO volume = null;\n\n        if (volumeId != null) {\n            volume = _volsDao.findById(volumeId);\n        } else {\n            volume = _volsDao.findByInstanceAndDeviceId(cmmd.getVirtualMachineId(), cmmd.getDeviceId()).get(0);\n        }\n\n        \r\n        if (volume == null) {\n            throw new InvalidParameterValueException(\"Unable to find volume with ID: \" + volumeId);\n        }\n\n        Long vmId = null;\n\n        if (cmmd.getVirtualMachineId() == null) {\n            vmId = volume.getInstanceId();\n        } else {\n            vmId = cmmd.getVirtualMachineId();\n        }\n\n        \r\n        _accountMgr.checkAccess(caller, null, true, volume);\n\n        \r\n        if (vmId == null) {\n            throw new InvalidParameterValueException(\"The specified volume is not attached to a VM.\");\n        }\n\n        \r\n        UserVmVO vm = _userVmDao.findById(vmId);\n        if (vm.getState() != State.Running && vm.getState() != State.Stopped && vm.getState() != State.Destroyed) {\n            throw new InvalidParameterValueException(\"Please specify a VM that is either running or stopped.\");\n        }\n\n        \r\n        if (!(volume.getVolumeType() == Volume.Type.ROOT || volume.getVolumeType() == Volume.Type.DATADISK)) {\n            throw new InvalidParameterValueException(\"Please specify volume of type \" + Volume.Type.DATADISK.toString() + \" or \" + Volume.Type.ROOT.toString());\n        }\n\n        \r\n        if (volume.getVolumeType() == Volume.Type.ROOT) {\n            validateRootVolumeDetachAttach(volume, vm);\n        }\n\n        \r\n        List<VMSnapshotVO> vmSnapshots = _vmSnapshotDao.findByVm(vmId);\n        if (vmSnapshots.size() > 0) {\n            throw new InvalidParameterValueException(\"Unable to detach volume, please specify a VM that does not have VM snapshots\");\n        }\n\n        AsyncJobExecutionContext asyncExecutionContext = AsyncJobExecutionContext.getCurrentExecutionContext();\n        if (asyncExecutionContext != null) {\n            AsyncJob job = asyncExecutionContext.getJob();\n\n            if (s_logger.isInfoEnabled()) {\n                s_logger.info(\"Trying to attaching volume \" + volumeId + \"to vm instance:\" + vm.getId() + \", update async job-\" + job.getId() + \" progress status\");\n            }\n\n            _jobMgr.updateAsyncJobAttachment(job.getId(), \"Volume\", volumeId);\n        }\n\n        AsyncJobExecutionContext jobContext = AsyncJobExecutionContext.getCurrentExecutionContext();\n        if (jobContext.isJobDispatchedBy(VmWorkConstants.VM_WORK_JOB_DISPATCHER)) {\n            \r\n            VmWorkJobVO placeHolder = null;\n            placeHolder = createPlaceHolderWork(vmId);\n            try {\n                return orchestrateDetachVolumeFromVM(vmId, volumeId);\n            } finally {\n                _workJobDao.expunge(placeHolder.getId());\n            }\n        } else {\n            Outcome<Volume> outcome = detachVolumeFromVmThroughJobQueue(vmId, volumeId);\n\n            Volume vol = null;\n            try {\n                outcome.get();\n            } catch (InterruptedException e) {\n                throw new RuntimeException(\"Operation is interrupted\", e);\n            } catch (java.util.concurrent.ExecutionException e) {\n                throw new RuntimeException(\"Execution excetion\", e);\n            }\n\n            Object jobResult = _jobMgr.unmarshallResultObject(outcome.getJob());\n            if (jobResult != null) {\n                if (jobResult instanceof ConcurrentOperationException) {\n                    throw (ConcurrentOperationException)jobResult;\n                } else if (jobResult instanceof RuntimeException) {\n                    throw (RuntimeException)jobResult;\n                } else if (jobResult instanceof Throwable) {\n                    throw new RuntimeException(\"Unexpected exception\", (Throwable)jobResult);\n                } else if (jobResult instanceof Long) {\n                    vol = _volsDao.findById((Long)jobResult);\n                }\n            }\n            return vol;\n        }\n    }\n","realPath":"server/src/main/java/com/cloud/storage/VolumeApiServiceImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1826,"status":"M"}],"commitId":"318924d801a6bb0f7d3f77e1a5a432267a3db359","commitMessage":"@@@CloudStack Backup & Recovery Framework (#3553)\n\n","date":"2020-03-03 20:27:58","modifiedFileCount":"47","status":"M","submitter":"Rohit Yadav"}]
