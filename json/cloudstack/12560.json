[{"authorTime":"2019-06-25 23:23:09","codes":[{"authorDate":"2019-06-25 23:23:09","commitOrder":5,"curCode":"    public void orchestrateStart(final String vmUuid, final Map<VirtualMachineProfile.Param, Object> params, final DeploymentPlan planToDeploy, final DeploymentPlanner planner)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {\n\n        final CallContext cctxt = CallContext.current();\n        final Account account = cctxt.getCallingAccount();\n        final User caller = cctxt.getCallingUser();\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final Ternary<VMInstanceVO, ReservationContext, ItWorkVO> start = changeToStartState(vmGuru, vm, caller, account);\n        if (start == null) {\n            return;\n        }\n\n        vm = start.first();\n        final ReservationContext ctx = start.second();\n        ItWorkVO work = start.third();\n\n        VMInstanceVO startedVm = null;\n        final ServiceOfferingVO offering = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());\n        final VirtualMachineTemplate template = _entityMgr.findByIdIncludingRemoved(VirtualMachineTemplate.class, vm.getTemplateId());\n\n        DataCenterDeployment plan = new DataCenterDeployment(vm.getDataCenterId(), vm.getPodIdToDeployIn(), null, null, null, null, ctx);\n        if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"advanceStart: DeploymentPlan is provided, using dcId:\" + planToDeploy.getDataCenterId() + \", podId: \" + planToDeploy.getPodId() +\n                        \", clusterId: \" + planToDeploy.getClusterId() + \", hostId: \" + planToDeploy.getHostId() + \", poolId: \" + planToDeploy.getPoolId());\n            }\n            plan =\n                    new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(), planToDeploy.getHostId(),\n                            planToDeploy.getPoolId(), planToDeploy.getPhysicalNetworkId(), ctx);\n        }\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        boolean canRetry = true;\n        ExcludeList avoids = null;\n        try {\n            final Journal journal = start.second().getJournal();\n\n            if (planToDeploy != null) {\n                avoids = planToDeploy.getAvoids();\n            }\n            if (avoids == null) {\n                avoids = new ExcludeList();\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Deploy avoids pods: \" + avoids.getPodsToAvoid() + \", clusters: \" + avoids.getClustersToAvoid() + \", hosts: \" + avoids.getHostsToAvoid());\n            }\n\n            boolean planChangedByVolume = false;\n            boolean reuseVolume = true;\n            final DataCenterDeployment originalPlan = plan;\n\n            int retry = StartRetry.value();\n            while (retry-- != 0) { \r\n\n                if (reuseVolume) {\n                    \r\n                    final List<VolumeVO> vols = _volsDao.findReadyRootVolumesByInstance(vm.getId());\n                    for (final VolumeVO vol : vols) {\n                        \r\n                        \r\n                        \r\n                        final Long volTemplateId = vol.getTemplateId();\n                        if (volTemplateId != null && volTemplateId.longValue() != template.getId()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(vol + \" of \" + vm + \" is READY, but template ids don't match, let the planner reassign a new pool\");\n                            }\n                            continue;\n                        }\n\n                        final StoragePool pool = (StoragePool)dataStoreMgr.getPrimaryDataStore(vol.getPoolId());\n                        if (!pool.isInMaintenance()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Root volume is ready, need to place VM in volume's cluster\");\n                            }\n                            final long rootVolDcId = pool.getDataCenterId();\n                            final Long rootVolPodId = pool.getPodId();\n                            final Long rootVolClusterId = pool.getClusterId();\n                            if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n                                final Long clusterIdSpecified = planToDeploy.getClusterId();\n                                if (clusterIdSpecified != null && rootVolClusterId != null) {\n                                    if (rootVolClusterId.longValue() != clusterIdSpecified.longValue()) {\n                                        \r\n                                        \r\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"Cannot satisfy the deployment plan passed in since the ready Root volume is in different cluster. volume's cluster: \" +\n                                                    rootVolClusterId + \", cluster specified: \" + clusterIdSpecified);\n                                        }\n                                        throw new ResourceUnavailableException(\n                                                \"Root volume is ready in different cluster, Deployment plan provided cannot be satisfied, unable to create a deployment for \" +\n                                                        vm, Cluster.class, clusterIdSpecified);\n                                    }\n                                }\n                                plan =\n                                        new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(),\n                                                planToDeploy.getHostId(), vol.getPoolId(), null, ctx);\n                            } else {\n                                plan = new DataCenterDeployment(rootVolDcId, rootVolPodId, rootVolClusterId, null, vol.getPoolId(), null, ctx);\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(vol + \" is READY, changing deployment plan to use this pool's dcId: \" + rootVolDcId + \" , podId: \" + rootVolPodId +\n                                            \" , and clusterId: \" + rootVolClusterId);\n                                }\n                                planChangedByVolume = true;\n                            }\n                        }\n                    }\n                }\n\n                final Account owner = _entityMgr.findById(Account.class, vm.getAccountId());\n                final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vm, template, offering, owner, params);\n                DeployDestination dest = null;\n                try {\n                    dest = _dpMgr.planDeployment(vmProfile, plan, avoids, planner);\n                } catch (final AffinityConflictException e2) {\n                    s_logger.warn(\"Unable to create deployment, affinity rules associted to the VM conflict\", e2);\n                    throw new CloudRuntimeException(\"Unable to create deployment, affinity rules associted to the VM conflict\");\n\n                }\n\n                if (dest == null) {\n                    if (planChangedByVolume) {\n                        plan = originalPlan;\n                        planChangedByVolume = false;\n                        \r\n                        reuseVolume = false;\n                        continue;\n                    }\n                    throw new InsufficientServerCapacityException(\"Unable to create a deployment for \" + vmProfile, DataCenter.class, plan.getDataCenterId(),\n                            areAffinityGroupsAssociated(vmProfile));\n                }\n\n                if (dest != null) {\n                    avoids.addHost(dest.getHost().getId());\n                    journal.record(\"Deployment found \", vmProfile, dest);\n                }\n\n                long destHostId = dest.getHost().getId();\n                vm.setPodIdToDeployIn(dest.getPod().getId());\n                final Long cluster_id = dest.getCluster().getId();\n                final ClusterDetailsVO cluster_detail_cpu = _clusterDetailsDao.findDetail(cluster_id, \"cpuOvercommitRatio\");\n                final ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, \"memoryOvercommitRatio\");\n                \r\n                if (userVmDetailsDao.findDetail(vm.getId(), \"cpuOvercommitRatio\") == null &&\n                        (Float.parseFloat(cluster_detail_cpu.getValue()) > 1f || Float.parseFloat(cluster_detail_ram.getValue()) > 1f)) {\n                    userVmDetailsDao.addDetail(vm.getId(), \"cpuOvercommitRatio\", cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), \"memoryOvercommitRatio\", cluster_detail_ram.getValue(), true);\n                } else if (userVmDetailsDao.findDetail(vm.getId(), \"cpuOvercommitRatio\") != null) {\n                    userVmDetailsDao.addDetail(vm.getId(), \"cpuOvercommitRatio\", cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), \"memoryOvercommitRatio\", cluster_detail_ram.getValue(), true);\n                }\n\n                vmProfile.setCpuOvercommitRatio(Float.parseFloat(cluster_detail_cpu.getValue()));\n                vmProfile.setMemoryOvercommitRatio(Float.parseFloat(cluster_detail_ram.getValue()));\n                StartAnswer startAnswer = null;\n\n                try {\n                    if (!changeState(vm, Event.OperationRetry, destHostId, work, Step.Prepare)) {\n                        throw new ConcurrentOperationException(\"Unable to update the state of the Virtual Machine \"+vm.getUuid()+\" oldstate: \"+vm.getState()+ \"Event :\"+Event.OperationRetry);\n                    }\n                } catch (final NoTransitionException e1) {\n                    throw new ConcurrentOperationException(e1.getMessage());\n                }\n\n                try {\n                    _networkMgr.prepare(vmProfile, new DeployDestination(dest.getDataCenter(), dest.getPod(), null, null, dest.getStorageForDisks()), ctx);\n                    if (vm.getHypervisorType() != HypervisorType.BareMetal) {\n                        volumeMgr.prepare(vmProfile, dest);\n                    }\n\n                    \r\n                    if (!reuseVolume) {\n                        reuseVolume = true;\n                    }\n\n                    Commands cmds = null;\n                    vmGuru.finalizeVirtualMachineProfile(vmProfile, dest, ctx);\n\n                    final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);\n\n                    handlePath(vmTO.getDisks(), vm.getHypervisorType());\n\n                    cmds = new Commands(Command.OnError.Stop);\n\n                    cmds.addCommand(new StartCommand(vmTO, dest.getHost(), getExecuteInSequence(vm.getHypervisorType())));\n\n                    vmGuru.finalizeDeployment(cmds, vmProfile, dest, ctx);\n\n                    work = _workDao.findById(work.getId());\n                    if (work == null || work.getStep() != Step.Prepare) {\n                        throw new ConcurrentOperationException(\"Work steps have been changed: \" + work);\n                    }\n\n                    _workDao.updateStep(work, Step.Starting);\n\n                    _agentMgr.send(destHostId, cmds);\n\n                    _workDao.updateStep(work, Step.Started);\n\n                    startAnswer = cmds.getAnswer(StartAnswer.class);\n                    if (startAnswer != null && startAnswer.getResult()) {\n                        handlePath(vmTO.getDisks(), startAnswer.getIqnToData());\n\n                        final String host_guid = startAnswer.getHost_guid();\n\n                        if (host_guid != null) {\n                            final HostVO finalHost = _resourceMgr.findHostByGuid(host_guid);\n                            if (finalHost == null) {\n                                throw new CloudRuntimeException(\"Host Guid \" + host_guid + \" doesn't exist in DB, something went wrong while processing start answer: \"+startAnswer);\n                            }\n                            destHostId = finalHost.getId();\n                        }\n                        if (vmGuru.finalizeStart(vmProfile, destHostId, cmds, ctx)) {\n                            syncDiskChainChange(startAnswer);\n\n                            if (!changeState(vm, Event.OperationSucceeded, destHostId, work, Step.Done)) {\n                                s_logger.error(\"Unable to transition to a new state. VM uuid: \"+vm.getUuid()+    \"VM oldstate:\"+vm.getState()+\"Event:\"+Event.OperationSucceeded);\n                                throw new ConcurrentOperationException(\"Failed to deploy VM\"+ vm.getUuid());\n                            }\n\n                            \r\n                            final GPUDeviceTO gpuDevice = startAnswer.getVirtualMachine().getGpuDevice();\n                            if (gpuDevice != null) {\n                                _resourceMgr.updateGPUDetails(destHostId, gpuDevice.getGroupDetails());\n                            }\n\n                            \r\n                            \r\n                            \r\n                            if (userVmDetailsDao.findDetail(vm.getId(), \"deployvm\") != null) {\n                                userVmDetailsDao.removeDetail(vm.getId(), \"deployvm\");\n                            }\n\n                            startedVm = vm;\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Start completed for VM \" + vm);\n                            }\n                            final Host vmHost = _hostDao.findById(destHostId);\n                            if (vmHost != null && (VirtualMachine.Type.ConsoleProxy.equals(vm.getType()) ||\n                                    VirtualMachine.Type.SecondaryStorageVm.equals(vm.getType())) && caManager.canProvisionCertificates()) {\n                                final Map<String, String> sshAccessDetails = _networkMgr.getSystemVMAccessDetails(vm);\n                                for (int retries = 3; retries > 0; retries--) {\n                                    try {\n                                        setupAgentSecurity(vmHost, sshAccessDetails, vm);\n                                        return;\n                                    } catch (final Exception e) {\n                                        s_logger.error(\"Retrying after catching exception while trying to secure agent for systemvm id=\" + vm.getId(), e);\n                                    }\n                                }\n                                throw new CloudRuntimeException(\"Failed to setup and secure agent for systemvm id=\" + vm.getId());\n                            }\n                            return;\n                        } else {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.info(\"The guru did not like the answers so stopping \" + vm);\n                            }\n                            StopCommand stopCmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n                            stopCmd.setControlIp(getControlNicIpForVM(vm));\n                            final StopCommand cmd = stopCmd;\n                            final Answer answer = _agentMgr.easySend(destHostId, cmd);\n                            if (answer != null && answer instanceof StopAnswer) {\n                                final StopAnswer stopAns = (StopAnswer)answer;\n                                if (vm.getType() == VirtualMachine.Type.User) {\n                                    final String platform = stopAns.getPlatform();\n                                    if (platform != null) {\n                                        final Map<String,String> vmmetadata = new HashMap<String,String>();\n                                        vmmetadata.put(vm.getInstanceName(), platform);\n                                        syncVMMetaData(vmmetadata);\n                                    }\n                                }\n                            }\n\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.warn(\"Unable to stop \" + vm + \" due to \" + (answer != null ? answer.getDetails() : \"no answers\"));\n                                _haMgr.scheduleStop(vm, destHostId, WorkType.ForceStop);\n                                throw new ExecutionException(\"Unable to stop this VM, \"+vm.getUuid()+\" so we are unable to retry the start operation\");\n                            }\n                            throw new ExecutionException(\"Unable to start  VM:\"+vm.getUuid()+\" due to error in finalizeStart, not retrying\");\n                        }\n                    }\n                    s_logger.info(\"Unable to start VM on \" + dest.getHost() + \" due to \" + (startAnswer == null ? \" no start answer\" : startAnswer.getDetails()));\n                    if (startAnswer != null && startAnswer.getContextParam(\"stopRetry\") != null) {\n                        break;\n                    }\n\n                } catch (OperationTimedoutException e) {\n                    s_logger.debug(\"Unable to send the start command to host \" + dest.getHost()+\" failed to start VM: \"+vm.getUuid());\n                    if (e.isActive()) {\n                        _haMgr.scheduleStop(vm, destHostId, WorkType.CheckStop);\n                    }\n                    canRetry = false;\n                    throw new AgentUnavailableException(\"Unable to start \" + vm.getHostName(), destHostId, e);\n                } catch (final ResourceUnavailableException e) {\n                    s_logger.info(\"Unable to contact resource.\", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected ResourceUnavailableException : \" + e.getScope().getName(), e);\n                            throw e;\n                        }\n                    }\n                } catch (final InsufficientCapacityException e) {\n                    s_logger.info(\"Insufficient capacity \", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected InsufficientCapacityException : \" + e.getScope().getName(), e);\n                        }\n                    }\n                } catch (final ExecutionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final NoTransitionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } finally {\n                    if (startedVm == null && canRetry) {\n                        final Step prevStep = work.getStep();\n                        _workDao.updateStep(work, Step.Release);\n                        \r\n                        if ((prevStep == Step.Started || prevStep == Step.Starting) && startAnswer != null && startAnswer.getResult()) {  \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, false);\n                        } else {\n                            \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, true);\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (startedVm == null) {\n                if (canRetry) {\n                    try {\n                        changeState(vm, Event.OperationFailed, null, work, Step.Done);\n                    } catch (final NoTransitionException e) {\n                        throw new ConcurrentOperationException(e.getMessage());\n                    }\n                }\n            }\n\n            if (planToDeploy != null) {\n                planToDeploy.setAvoids(avoids);\n            }\n        }\n\n        if (startedVm == null) {\n            throw new CloudRuntimeException(\"Unable to start instance '\" + vm.getHostName() + \"' (\" + vm.getUuid() + \"), see management server log for details\");\n        }\n    }\n","date":"2019-06-25 23:23:09","endLine":1284,"groupId":"22280","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"orchestrateStart","params":"(finalStringvmUuid@finalMap<VirtualMachineProfile.Param@Object>params@finalDeploymentPlanplanToDeploy@finalDeploymentPlannerplanner)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/79/5705345962a468ec5b626e71be73e2c2815950.src","preCode":"    public void orchestrateStart(final String vmUuid, final Map<VirtualMachineProfile.Param, Object> params, final DeploymentPlan planToDeploy, final DeploymentPlanner planner)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {\n\n        final CallContext cctxt = CallContext.current();\n        final Account account = cctxt.getCallingAccount();\n        final User caller = cctxt.getCallingUser();\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final Ternary<VMInstanceVO, ReservationContext, ItWorkVO> start = changeToStartState(vmGuru, vm, caller, account);\n        if (start == null) {\n            return;\n        }\n\n        vm = start.first();\n        final ReservationContext ctx = start.second();\n        ItWorkVO work = start.third();\n\n        VMInstanceVO startedVm = null;\n        final ServiceOfferingVO offering = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());\n        final VirtualMachineTemplate template = _entityMgr.findByIdIncludingRemoved(VirtualMachineTemplate.class, vm.getTemplateId());\n\n        DataCenterDeployment plan = new DataCenterDeployment(vm.getDataCenterId(), vm.getPodIdToDeployIn(), null, null, null, null, ctx);\n        if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"advanceStart: DeploymentPlan is provided, using dcId:\" + planToDeploy.getDataCenterId() + \", podId: \" + planToDeploy.getPodId() +\n                        \", clusterId: \" + planToDeploy.getClusterId() + \", hostId: \" + planToDeploy.getHostId() + \", poolId: \" + planToDeploy.getPoolId());\n            }\n            plan =\n                    new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(), planToDeploy.getHostId(),\n                            planToDeploy.getPoolId(), planToDeploy.getPhysicalNetworkId(), ctx);\n        }\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        boolean canRetry = true;\n        ExcludeList avoids = null;\n        try {\n            final Journal journal = start.second().getJournal();\n\n            if (planToDeploy != null) {\n                avoids = planToDeploy.getAvoids();\n            }\n            if (avoids == null) {\n                avoids = new ExcludeList();\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Deploy avoids pods: \" + avoids.getPodsToAvoid() + \", clusters: \" + avoids.getClustersToAvoid() + \", hosts: \" + avoids.getHostsToAvoid());\n            }\n\n            boolean planChangedByVolume = false;\n            boolean reuseVolume = true;\n            final DataCenterDeployment originalPlan = plan;\n\n            int retry = StartRetry.value();\n            while (retry-- != 0) { \r\n\n                if (reuseVolume) {\n                    \r\n                    final List<VolumeVO> vols = _volsDao.findReadyRootVolumesByInstance(vm.getId());\n                    for (final VolumeVO vol : vols) {\n                        \r\n                        \r\n                        \r\n                        final Long volTemplateId = vol.getTemplateId();\n                        if (volTemplateId != null && volTemplateId.longValue() != template.getId()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(vol + \" of \" + vm + \" is READY, but template ids don't match, let the planner reassign a new pool\");\n                            }\n                            continue;\n                        }\n\n                        final StoragePool pool = (StoragePool)dataStoreMgr.getPrimaryDataStore(vol.getPoolId());\n                        if (!pool.isInMaintenance()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Root volume is ready, need to place VM in volume's cluster\");\n                            }\n                            final long rootVolDcId = pool.getDataCenterId();\n                            final Long rootVolPodId = pool.getPodId();\n                            final Long rootVolClusterId = pool.getClusterId();\n                            if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n                                final Long clusterIdSpecified = planToDeploy.getClusterId();\n                                if (clusterIdSpecified != null && rootVolClusterId != null) {\n                                    if (rootVolClusterId.longValue() != clusterIdSpecified.longValue()) {\n                                        \r\n                                        \r\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"Cannot satisfy the deployment plan passed in since the ready Root volume is in different cluster. volume's cluster: \" +\n                                                    rootVolClusterId + \", cluster specified: \" + clusterIdSpecified);\n                                        }\n                                        throw new ResourceUnavailableException(\n                                                \"Root volume is ready in different cluster, Deployment plan provided cannot be satisfied, unable to create a deployment for \" +\n                                                        vm, Cluster.class, clusterIdSpecified);\n                                    }\n                                }\n                                plan =\n                                        new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(),\n                                                planToDeploy.getHostId(), vol.getPoolId(), null, ctx);\n                            } else {\n                                plan = new DataCenterDeployment(rootVolDcId, rootVolPodId, rootVolClusterId, null, vol.getPoolId(), null, ctx);\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(vol + \" is READY, changing deployment plan to use this pool's dcId: \" + rootVolDcId + \" , podId: \" + rootVolPodId +\n                                            \" , and clusterId: \" + rootVolClusterId);\n                                }\n                                planChangedByVolume = true;\n                            }\n                        }\n                    }\n                }\n\n                final Account owner = _entityMgr.findById(Account.class, vm.getAccountId());\n                final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vm, template, offering, owner, params);\n                DeployDestination dest = null;\n                try {\n                    dest = _dpMgr.planDeployment(vmProfile, plan, avoids, planner);\n                } catch (final AffinityConflictException e2) {\n                    s_logger.warn(\"Unable to create deployment, affinity rules associted to the VM conflict\", e2);\n                    throw new CloudRuntimeException(\"Unable to create deployment, affinity rules associted to the VM conflict\");\n\n                }\n\n                if (dest == null) {\n                    if (planChangedByVolume) {\n                        plan = originalPlan;\n                        planChangedByVolume = false;\n                        \r\n                        reuseVolume = false;\n                        continue;\n                    }\n                    throw new InsufficientServerCapacityException(\"Unable to create a deployment for \" + vmProfile, DataCenter.class, plan.getDataCenterId(),\n                            areAffinityGroupsAssociated(vmProfile));\n                }\n\n                if (dest != null) {\n                    avoids.addHost(dest.getHost().getId());\n                    journal.record(\"Deployment found \", vmProfile, dest);\n                }\n\n                long destHostId = dest.getHost().getId();\n                vm.setPodIdToDeployIn(dest.getPod().getId());\n                final Long cluster_id = dest.getCluster().getId();\n                final ClusterDetailsVO cluster_detail_cpu = _clusterDetailsDao.findDetail(cluster_id, \"cpuOvercommitRatio\");\n                final ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, \"memoryOvercommitRatio\");\n                \r\n                if (userVmDetailsDao.findDetail(vm.getId(), \"cpuOvercommitRatio\") == null &&\n                        (Float.parseFloat(cluster_detail_cpu.getValue()) > 1f || Float.parseFloat(cluster_detail_ram.getValue()) > 1f)) {\n                    userVmDetailsDao.addDetail(vm.getId(), \"cpuOvercommitRatio\", cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), \"memoryOvercommitRatio\", cluster_detail_ram.getValue(), true);\n                } else if (userVmDetailsDao.findDetail(vm.getId(), \"cpuOvercommitRatio\") != null) {\n                    userVmDetailsDao.addDetail(vm.getId(), \"cpuOvercommitRatio\", cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), \"memoryOvercommitRatio\", cluster_detail_ram.getValue(), true);\n                }\n\n                vmProfile.setCpuOvercommitRatio(Float.parseFloat(cluster_detail_cpu.getValue()));\n                vmProfile.setMemoryOvercommitRatio(Float.parseFloat(cluster_detail_ram.getValue()));\n                StartAnswer startAnswer = null;\n\n                try {\n                    if (!changeState(vm, Event.OperationRetry, destHostId, work, Step.Prepare)) {\n                        throw new ConcurrentOperationException(\"Unable to update the state of the Virtual Machine \"+vm.getUuid()+\" oldstate: \"+vm.getState()+ \"Event :\"+Event.OperationRetry);\n                    }\n                } catch (final NoTransitionException e1) {\n                    throw new ConcurrentOperationException(e1.getMessage());\n                }\n\n                try {\n                    _networkMgr.prepare(vmProfile, new DeployDestination(dest.getDataCenter(), dest.getPod(), null, null, dest.getStorageForDisks()), ctx);\n                    if (vm.getHypervisorType() != HypervisorType.BareMetal) {\n                        volumeMgr.prepare(vmProfile, dest);\n                    }\n\n                    \r\n                    if (!reuseVolume) {\n                        reuseVolume = true;\n                    }\n\n                    Commands cmds = null;\n                    vmGuru.finalizeVirtualMachineProfile(vmProfile, dest, ctx);\n\n                    final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);\n\n                    handlePath(vmTO.getDisks(), vm.getHypervisorType());\n\n                    cmds = new Commands(Command.OnError.Stop);\n\n                    cmds.addCommand(new StartCommand(vmTO, dest.getHost(), getExecuteInSequence(vm.getHypervisorType())));\n\n                    vmGuru.finalizeDeployment(cmds, vmProfile, dest, ctx);\n\n                    work = _workDao.findById(work.getId());\n                    if (work == null || work.getStep() != Step.Prepare) {\n                        throw new ConcurrentOperationException(\"Work steps have been changed: \" + work);\n                    }\n\n                    _workDao.updateStep(work, Step.Starting);\n\n                    _agentMgr.send(destHostId, cmds);\n\n                    _workDao.updateStep(work, Step.Started);\n\n                    startAnswer = cmds.getAnswer(StartAnswer.class);\n                    if (startAnswer != null && startAnswer.getResult()) {\n                        handlePath(vmTO.getDisks(), startAnswer.getIqnToData());\n\n                        final String host_guid = startAnswer.getHost_guid();\n\n                        if (host_guid != null) {\n                            final HostVO finalHost = _resourceMgr.findHostByGuid(host_guid);\n                            if (finalHost == null) {\n                                throw new CloudRuntimeException(\"Host Guid \" + host_guid + \" doesn't exist in DB, something went wrong while processing start answer: \"+startAnswer);\n                            }\n                            destHostId = finalHost.getId();\n                        }\n                        if (vmGuru.finalizeStart(vmProfile, destHostId, cmds, ctx)) {\n                            syncDiskChainChange(startAnswer);\n\n                            if (!changeState(vm, Event.OperationSucceeded, destHostId, work, Step.Done)) {\n                                s_logger.error(\"Unable to transition to a new state. VM uuid: \"+vm.getUuid()+    \"VM oldstate:\"+vm.getState()+\"Event:\"+Event.OperationSucceeded);\n                                throw new ConcurrentOperationException(\"Failed to deploy VM\"+ vm.getUuid());\n                            }\n\n                            \r\n                            final GPUDeviceTO gpuDevice = startAnswer.getVirtualMachine().getGpuDevice();\n                            if (gpuDevice != null) {\n                                _resourceMgr.updateGPUDetails(destHostId, gpuDevice.getGroupDetails());\n                            }\n\n                            \r\n                            \r\n                            \r\n                            if (userVmDetailsDao.findDetail(vm.getId(), \"deployvm\") != null) {\n                                userVmDetailsDao.removeDetail(vm.getId(), \"deployvm\");\n                            }\n\n                            startedVm = vm;\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Start completed for VM \" + vm);\n                            }\n                            final Host vmHost = _hostDao.findById(destHostId);\n                            if (vmHost != null && (VirtualMachine.Type.ConsoleProxy.equals(vm.getType()) ||\n                                    VirtualMachine.Type.SecondaryStorageVm.equals(vm.getType())) && caManager.canProvisionCertificates()) {\n                                final Map<String, String> sshAccessDetails = _networkMgr.getSystemVMAccessDetails(vm);\n                                for (int retries = 3; retries > 0; retries--) {\n                                    try {\n                                        setupAgentSecurity(vmHost, sshAccessDetails, vm);\n                                        return;\n                                    } catch (final Exception e) {\n                                        s_logger.error(\"Retrying after catching exception while trying to secure agent for systemvm id=\" + vm.getId(), e);\n                                    }\n                                }\n                                throw new CloudRuntimeException(\"Failed to setup and secure agent for systemvm id=\" + vm.getId());\n                            }\n                            return;\n                        } else {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.info(\"The guru did not like the answers so stopping \" + vm);\n                            }\n                            StopCommand stopCmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n                            stopCmd.setControlIp(getControlNicIpForVM(vm));\n                            final StopCommand cmd = stopCmd;\n                            final Answer answer = _agentMgr.easySend(destHostId, cmd);\n                            if (answer != null && answer instanceof StopAnswer) {\n                                final StopAnswer stopAns = (StopAnswer)answer;\n                                if (vm.getType() == VirtualMachine.Type.User) {\n                                    final String platform = stopAns.getPlatform();\n                                    if (platform != null) {\n                                        final Map<String,String> vmmetadata = new HashMap<String,String>();\n                                        vmmetadata.put(vm.getInstanceName(), platform);\n                                        syncVMMetaData(vmmetadata);\n                                    }\n                                }\n                            }\n\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.warn(\"Unable to stop \" + vm + \" due to \" + (answer != null ? answer.getDetails() : \"no answers\"));\n                                _haMgr.scheduleStop(vm, destHostId, WorkType.ForceStop);\n                                throw new ExecutionException(\"Unable to stop this VM, \"+vm.getUuid()+\" so we are unable to retry the start operation\");\n                            }\n                            throw new ExecutionException(\"Unable to start  VM:\"+vm.getUuid()+\" due to error in finalizeStart, not retrying\");\n                        }\n                    }\n                    s_logger.info(\"Unable to start VM on \" + dest.getHost() + \" due to \" + (startAnswer == null ? \" no start answer\" : startAnswer.getDetails()));\n                    if (startAnswer != null && startAnswer.getContextParam(\"stopRetry\") != null) {\n                        break;\n                    }\n\n                } catch (OperationTimedoutException e) {\n                    s_logger.debug(\"Unable to send the start command to host \" + dest.getHost()+\" failed to start VM: \"+vm.getUuid());\n                    if (e.isActive()) {\n                        _haMgr.scheduleStop(vm, destHostId, WorkType.CheckStop);\n                    }\n                    canRetry = false;\n                    throw new AgentUnavailableException(\"Unable to start \" + vm.getHostName(), destHostId, e);\n                } catch (final ResourceUnavailableException e) {\n                    s_logger.info(\"Unable to contact resource.\", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected ResourceUnavailableException : \" + e.getScope().getName(), e);\n                            throw e;\n                        }\n                    }\n                } catch (final InsufficientCapacityException e) {\n                    s_logger.info(\"Insufficient capacity \", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected InsufficientCapacityException : \" + e.getScope().getName(), e);\n                        }\n                    }\n                } catch (final ExecutionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final NoTransitionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } finally {\n                    if (startedVm == null && canRetry) {\n                        final Step prevStep = work.getStep();\n                        _workDao.updateStep(work, Step.Release);\n                        \r\n                        if ((prevStep == Step.Started || prevStep == Step.Starting) && startAnswer != null && startAnswer.getResult()) {  \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, false);\n                        } else {\n                            \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, true);\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (startedVm == null) {\n                if (canRetry) {\n                    try {\n                        changeState(vm, Event.OperationFailed, null, work, Step.Done);\n                    } catch (final NoTransitionException e) {\n                        throw new ConcurrentOperationException(e.getMessage());\n                    }\n                }\n            }\n\n            if (planToDeploy != null) {\n                planToDeploy.setAvoids(avoids);\n            }\n        }\n\n        if (startedVm == null) {\n            throw new CloudRuntimeException(\"Unable to start instance '\" + vm.getHostName() + \"' (\" + vm.getUuid() + \"), see management server log for details\");\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":931,"status":"MB"},{"authorDate":"2019-06-25 23:23:09","commitOrder":5,"curCode":"    public Command cleanup(final VirtualMachine vm, Map<String, DpdkTO> dpdkInterfaceMapping) {\n        StopCommand cmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n        cmd.setControlIp(getControlNicIpForVM(vm));\n        if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n            cmd.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n        }\n        return cmd;\n    }\n","date":"2019-06-25 23:23:09","endLine":3112,"groupId":"25415","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"cleanup","params":"(finalVirtualMachinevm@Map<String@DpdkTO>dpdkInterfaceMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/79/5705345962a468ec5b626e71be73e2c2815950.src","preCode":"    public Command cleanup(final VirtualMachine vm, Map<String, DpdkTO> dpdkInterfaceMapping) {\n        StopCommand cmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n        cmd.setControlIp(getControlNicIpForVM(vm));\n        if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n            cmd.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n        }\n        return cmd;\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":3105,"status":"B"}],"commitId":"a75444a585b952aeb3e984430238cae9e6be4dc5","commitMessage":"@@@KVM: DPDK live migrations (#3365)\n\n* DPDK live migrations\n\n* Remove DPDK created ports if VM migration fails or prepare migration fails\n\n* Rename DPDK classes lowercase\n","date":"2019-06-25 23:23:09","modifiedFileCount":"19","status":"M","submitter":"Nicolas Vazquez"},{"authorTime":"2019-06-25 23:23:09","codes":[{"authorDate":"2019-06-27 11:44:47","commitOrder":6,"curCode":"    public void orchestrateStart(final String vmUuid, final Map<VirtualMachineProfile.Param, Object> params, final DeploymentPlan planToDeploy, final DeploymentPlanner planner)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {\n\n        final CallContext cctxt = CallContext.current();\n        final Account account = cctxt.getCallingAccount();\n        final User caller = cctxt.getCallingUser();\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final Ternary<VMInstanceVO, ReservationContext, ItWorkVO> start = changeToStartState(vmGuru, vm, caller, account);\n        if (start == null) {\n            return;\n        }\n\n        vm = start.first();\n        final ReservationContext ctx = start.second();\n        ItWorkVO work = start.third();\n\n        VMInstanceVO startedVm = null;\n        final ServiceOfferingVO offering = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());\n        final VirtualMachineTemplate template = _entityMgr.findByIdIncludingRemoved(VirtualMachineTemplate.class, vm.getTemplateId());\n\n        DataCenterDeployment plan = new DataCenterDeployment(vm.getDataCenterId(), vm.getPodIdToDeployIn(), null, null, null, null, ctx);\n        if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"advanceStart: DeploymentPlan is provided, using dcId:\" + planToDeploy.getDataCenterId() + \", podId: \" + planToDeploy.getPodId() +\n                        \", clusterId: \" + planToDeploy.getClusterId() + \", hostId: \" + planToDeploy.getHostId() + \", poolId: \" + planToDeploy.getPoolId());\n            }\n            plan =\n                    new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(), planToDeploy.getHostId(),\n                            planToDeploy.getPoolId(), planToDeploy.getPhysicalNetworkId(), ctx);\n        }\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        boolean canRetry = true;\n        ExcludeList avoids = null;\n        try {\n            final Journal journal = start.second().getJournal();\n\n            if (planToDeploy != null) {\n                avoids = planToDeploy.getAvoids();\n            }\n            if (avoids == null) {\n                avoids = new ExcludeList();\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Deploy avoids pods: \" + avoids.getPodsToAvoid() + \", clusters: \" + avoids.getClustersToAvoid() + \", hosts: \" + avoids.getHostsToAvoid());\n            }\n\n            boolean planChangedByVolume = false;\n            boolean reuseVolume = true;\n            final DataCenterDeployment originalPlan = plan;\n\n            int retry = StartRetry.value();\n            while (retry-- != 0) { \r\n\n                if (reuseVolume) {\n                    \r\n                    final List<VolumeVO> vols = _volsDao.findReadyRootVolumesByInstance(vm.getId());\n                    for (final VolumeVO vol : vols) {\n                        \r\n                        \r\n                        \r\n                        final Long volTemplateId = vol.getTemplateId();\n                        if (volTemplateId != null && volTemplateId.longValue() != template.getId()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(vol + \" of \" + vm + \" is READY, but template ids don't match, let the planner reassign a new pool\");\n                            }\n                            continue;\n                        }\n\n                        final StoragePool pool = (StoragePool)dataStoreMgr.getPrimaryDataStore(vol.getPoolId());\n                        if (!pool.isInMaintenance()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Root volume is ready, need to place VM in volume's cluster\");\n                            }\n                            final long rootVolDcId = pool.getDataCenterId();\n                            final Long rootVolPodId = pool.getPodId();\n                            final Long rootVolClusterId = pool.getClusterId();\n                            if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n                                final Long clusterIdSpecified = planToDeploy.getClusterId();\n                                if (clusterIdSpecified != null && rootVolClusterId != null) {\n                                    if (rootVolClusterId.longValue() != clusterIdSpecified.longValue()) {\n                                        \r\n                                        \r\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"Cannot satisfy the deployment plan passed in since the ready Root volume is in different cluster. volume's cluster: \" +\n                                                    rootVolClusterId + \", cluster specified: \" + clusterIdSpecified);\n                                        }\n                                        throw new ResourceUnavailableException(\n                                                \"Root volume is ready in different cluster, Deployment plan provided cannot be satisfied, unable to create a deployment for \" +\n                                                        vm, Cluster.class, clusterIdSpecified);\n                                    }\n                                }\n                                plan =\n                                        new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(),\n                                                planToDeploy.getHostId(), vol.getPoolId(), null, ctx);\n                            } else {\n                                plan = new DataCenterDeployment(rootVolDcId, rootVolPodId, rootVolClusterId, null, vol.getPoolId(), null, ctx);\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(vol + \" is READY, changing deployment plan to use this pool's dcId: \" + rootVolDcId + \" , podId: \" + rootVolPodId +\n                                            \" , and clusterId: \" + rootVolClusterId);\n                                }\n                                planChangedByVolume = true;\n                            }\n                        }\n                    }\n                }\n\n                final Account owner = _entityMgr.findById(Account.class, vm.getAccountId());\n                final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vm, template, offering, owner, params);\n                DeployDestination dest = null;\n                try {\n                    dest = _dpMgr.planDeployment(vmProfile, plan, avoids, planner);\n                } catch (final AffinityConflictException e2) {\n                    s_logger.warn(\"Unable to create deployment, affinity rules associted to the VM conflict\", e2);\n                    throw new CloudRuntimeException(\"Unable to create deployment, affinity rules associted to the VM conflict\");\n\n                }\n\n                if (dest == null) {\n                    if (planChangedByVolume) {\n                        plan = originalPlan;\n                        planChangedByVolume = false;\n                        \r\n                        reuseVolume = false;\n                        continue;\n                    }\n                    throw new InsufficientServerCapacityException(\"Unable to create a deployment for \" + vmProfile, DataCenter.class, plan.getDataCenterId(),\n                            areAffinityGroupsAssociated(vmProfile));\n                }\n\n                if (dest != null) {\n                    avoids.addHost(dest.getHost().getId());\n                    journal.record(\"Deployment found \", vmProfile, dest);\n                }\n\n                long destHostId = dest.getHost().getId();\n                vm.setPodIdToDeployIn(dest.getPod().getId());\n                final Long cluster_id = dest.getCluster().getId();\n                final ClusterDetailsVO cluster_detail_cpu = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                final ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                \r\n                if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) == null &&\n                        (Float.parseFloat(cluster_detail_cpu.getValue()) > 1f || Float.parseFloat(cluster_detail_ram.getValue()) > 1f)) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                } else if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) != null) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                }\n\n                vmProfile.setCpuOvercommitRatio(Float.parseFloat(cluster_detail_cpu.getValue()));\n                vmProfile.setMemoryOvercommitRatio(Float.parseFloat(cluster_detail_ram.getValue()));\n                StartAnswer startAnswer = null;\n\n                try {\n                    if (!changeState(vm, Event.OperationRetry, destHostId, work, Step.Prepare)) {\n                        throw new ConcurrentOperationException(\"Unable to update the state of the Virtual Machine \"+vm.getUuid()+\" oldstate: \"+vm.getState()+ \"Event :\"+Event.OperationRetry);\n                    }\n                } catch (final NoTransitionException e1) {\n                    throw new ConcurrentOperationException(e1.getMessage());\n                }\n\n                try {\n                    _networkMgr.prepare(vmProfile, new DeployDestination(dest.getDataCenter(), dest.getPod(), null, null, dest.getStorageForDisks()), ctx);\n                    if (vm.getHypervisorType() != HypervisorType.BareMetal) {\n                        volumeMgr.prepare(vmProfile, dest);\n                    }\n\n                    \r\n                    if (!reuseVolume) {\n                        reuseVolume = true;\n                    }\n\n                    Commands cmds = null;\n                    vmGuru.finalizeVirtualMachineProfile(vmProfile, dest, ctx);\n\n                    final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);\n\n                    handlePath(vmTO.getDisks(), vm.getHypervisorType());\n\n                    cmds = new Commands(Command.OnError.Stop);\n\n                    cmds.addCommand(new StartCommand(vmTO, dest.getHost(), getExecuteInSequence(vm.getHypervisorType())));\n\n                    vmGuru.finalizeDeployment(cmds, vmProfile, dest, ctx);\n\n                    work = _workDao.findById(work.getId());\n                    if (work == null || work.getStep() != Step.Prepare) {\n                        throw new ConcurrentOperationException(\"Work steps have been changed: \" + work);\n                    }\n\n                    _workDao.updateStep(work, Step.Starting);\n\n                    _agentMgr.send(destHostId, cmds);\n\n                    _workDao.updateStep(work, Step.Started);\n\n                    startAnswer = cmds.getAnswer(StartAnswer.class);\n                    if (startAnswer != null && startAnswer.getResult()) {\n                        handlePath(vmTO.getDisks(), startAnswer.getIqnToData());\n\n                        final String host_guid = startAnswer.getHost_guid();\n\n                        if (host_guid != null) {\n                            final HostVO finalHost = _resourceMgr.findHostByGuid(host_guid);\n                            if (finalHost == null) {\n                                throw new CloudRuntimeException(\"Host Guid \" + host_guid + \" doesn't exist in DB, something went wrong while processing start answer: \"+startAnswer);\n                            }\n                            destHostId = finalHost.getId();\n                        }\n                        if (vmGuru.finalizeStart(vmProfile, destHostId, cmds, ctx)) {\n                            syncDiskChainChange(startAnswer);\n\n                            if (!changeState(vm, Event.OperationSucceeded, destHostId, work, Step.Done)) {\n                                s_logger.error(\"Unable to transition to a new state. VM uuid: \"+vm.getUuid()+    \"VM oldstate:\"+vm.getState()+\"Event:\"+Event.OperationSucceeded);\n                                throw new ConcurrentOperationException(\"Failed to deploy VM\"+ vm.getUuid());\n                            }\n\n                            \r\n                            final GPUDeviceTO gpuDevice = startAnswer.getVirtualMachine().getGpuDevice();\n                            if (gpuDevice != null) {\n                                _resourceMgr.updateGPUDetails(destHostId, gpuDevice.getGroupDetails());\n                            }\n\n                            \r\n                            \r\n                            \r\n                            if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.DEPLOY_VM) != null) {\n                                userVmDetailsDao.removeDetail(vm.getId(), VmDetailConstants.DEPLOY_VM);\n                            }\n\n                            startedVm = vm;\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Start completed for VM \" + vm);\n                            }\n                            final Host vmHost = _hostDao.findById(destHostId);\n                            if (vmHost != null && (VirtualMachine.Type.ConsoleProxy.equals(vm.getType()) ||\n                                    VirtualMachine.Type.SecondaryStorageVm.equals(vm.getType())) && caManager.canProvisionCertificates()) {\n                                final Map<String, String> sshAccessDetails = _networkMgr.getSystemVMAccessDetails(vm);\n                                for (int retries = 3; retries > 0; retries--) {\n                                    try {\n                                        setupAgentSecurity(vmHost, sshAccessDetails, vm);\n                                        return;\n                                    } catch (final Exception e) {\n                                        s_logger.error(\"Retrying after catching exception while trying to secure agent for systemvm id=\" + vm.getId(), e);\n                                    }\n                                }\n                                throw new CloudRuntimeException(\"Failed to setup and secure agent for systemvm id=\" + vm.getId());\n                            }\n                            return;\n                        } else {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.info(\"The guru did not like the answers so stopping \" + vm);\n                            }\n                            StopCommand stopCmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n                            stopCmd.setControlIp(getControlNicIpForVM(vm));\n                            final StopCommand cmd = stopCmd;\n                            final Answer answer = _agentMgr.easySend(destHostId, cmd);\n                            if (answer != null && answer instanceof StopAnswer) {\n                                final StopAnswer stopAns = (StopAnswer)answer;\n                                if (vm.getType() == VirtualMachine.Type.User) {\n                                    final String platform = stopAns.getPlatform();\n                                    if (platform != null) {\n                                        final Map<String,String> vmmetadata = new HashMap<String,String>();\n                                        vmmetadata.put(vm.getInstanceName(), platform);\n                                        syncVMMetaData(vmmetadata);\n                                    }\n                                }\n                            }\n\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.warn(\"Unable to stop \" + vm + \" due to \" + (answer != null ? answer.getDetails() : \"no answers\"));\n                                _haMgr.scheduleStop(vm, destHostId, WorkType.ForceStop);\n                                throw new ExecutionException(\"Unable to stop this VM, \"+vm.getUuid()+\" so we are unable to retry the start operation\");\n                            }\n                            throw new ExecutionException(\"Unable to start  VM:\"+vm.getUuid()+\" due to error in finalizeStart, not retrying\");\n                        }\n                    }\n                    s_logger.info(\"Unable to start VM on \" + dest.getHost() + \" due to \" + (startAnswer == null ? \" no start answer\" : startAnswer.getDetails()));\n                    if (startAnswer != null && startAnswer.getContextParam(\"stopRetry\") != null) {\n                        break;\n                    }\n\n                } catch (OperationTimedoutException e) {\n                    s_logger.debug(\"Unable to send the start command to host \" + dest.getHost()+\" failed to start VM: \"+vm.getUuid());\n                    if (e.isActive()) {\n                        _haMgr.scheduleStop(vm, destHostId, WorkType.CheckStop);\n                    }\n                    canRetry = false;\n                    throw new AgentUnavailableException(\"Unable to start \" + vm.getHostName(), destHostId, e);\n                } catch (final ResourceUnavailableException e) {\n                    s_logger.info(\"Unable to contact resource.\", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected ResourceUnavailableException : \" + e.getScope().getName(), e);\n                            throw e;\n                        }\n                    }\n                } catch (final InsufficientCapacityException e) {\n                    s_logger.info(\"Insufficient capacity \", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected InsufficientCapacityException : \" + e.getScope().getName(), e);\n                        }\n                    }\n                } catch (final ExecutionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final NoTransitionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } finally {\n                    if (startedVm == null && canRetry) {\n                        final Step prevStep = work.getStep();\n                        _workDao.updateStep(work, Step.Release);\n                        \r\n                        if ((prevStep == Step.Started || prevStep == Step.Starting) && startAnswer != null && startAnswer.getResult()) {  \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, false);\n                        } else {\n                            \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, true);\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (startedVm == null) {\n                if (canRetry) {\n                    try {\n                        changeState(vm, Event.OperationFailed, null, work, Step.Done);\n                    } catch (final NoTransitionException e) {\n                        throw new ConcurrentOperationException(e.getMessage());\n                    }\n                }\n            }\n\n            if (planToDeploy != null) {\n                planToDeploy.setAvoids(avoids);\n            }\n        }\n\n        if (startedVm == null) {\n            throw new CloudRuntimeException(\"Unable to start instance '\" + vm.getHostName() + \"' (\" + vm.getUuid() + \"), see management server log for details\");\n        }\n    }\n","date":"2019-06-27 11:44:47","endLine":1284,"groupId":"20272","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"orchestrateStart","params":"(finalStringvmUuid@finalMap<VirtualMachineProfile.Param@Object>params@finalDeploymentPlanplanToDeploy@finalDeploymentPlannerplanner)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/1c/c925b3ccf5f1528ab33aee35abece569772798.src","preCode":"    public void orchestrateStart(final String vmUuid, final Map<VirtualMachineProfile.Param, Object> params, final DeploymentPlan planToDeploy, final DeploymentPlanner planner)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {\n\n        final CallContext cctxt = CallContext.current();\n        final Account account = cctxt.getCallingAccount();\n        final User caller = cctxt.getCallingUser();\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final Ternary<VMInstanceVO, ReservationContext, ItWorkVO> start = changeToStartState(vmGuru, vm, caller, account);\n        if (start == null) {\n            return;\n        }\n\n        vm = start.first();\n        final ReservationContext ctx = start.second();\n        ItWorkVO work = start.third();\n\n        VMInstanceVO startedVm = null;\n        final ServiceOfferingVO offering = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());\n        final VirtualMachineTemplate template = _entityMgr.findByIdIncludingRemoved(VirtualMachineTemplate.class, vm.getTemplateId());\n\n        DataCenterDeployment plan = new DataCenterDeployment(vm.getDataCenterId(), vm.getPodIdToDeployIn(), null, null, null, null, ctx);\n        if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"advanceStart: DeploymentPlan is provided, using dcId:\" + planToDeploy.getDataCenterId() + \", podId: \" + planToDeploy.getPodId() +\n                        \", clusterId: \" + planToDeploy.getClusterId() + \", hostId: \" + planToDeploy.getHostId() + \", poolId: \" + planToDeploy.getPoolId());\n            }\n            plan =\n                    new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(), planToDeploy.getHostId(),\n                            planToDeploy.getPoolId(), planToDeploy.getPhysicalNetworkId(), ctx);\n        }\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        boolean canRetry = true;\n        ExcludeList avoids = null;\n        try {\n            final Journal journal = start.second().getJournal();\n\n            if (planToDeploy != null) {\n                avoids = planToDeploy.getAvoids();\n            }\n            if (avoids == null) {\n                avoids = new ExcludeList();\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Deploy avoids pods: \" + avoids.getPodsToAvoid() + \", clusters: \" + avoids.getClustersToAvoid() + \", hosts: \" + avoids.getHostsToAvoid());\n            }\n\n            boolean planChangedByVolume = false;\n            boolean reuseVolume = true;\n            final DataCenterDeployment originalPlan = plan;\n\n            int retry = StartRetry.value();\n            while (retry-- != 0) { \r\n\n                if (reuseVolume) {\n                    \r\n                    final List<VolumeVO> vols = _volsDao.findReadyRootVolumesByInstance(vm.getId());\n                    for (final VolumeVO vol : vols) {\n                        \r\n                        \r\n                        \r\n                        final Long volTemplateId = vol.getTemplateId();\n                        if (volTemplateId != null && volTemplateId.longValue() != template.getId()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(vol + \" of \" + vm + \" is READY, but template ids don't match, let the planner reassign a new pool\");\n                            }\n                            continue;\n                        }\n\n                        final StoragePool pool = (StoragePool)dataStoreMgr.getPrimaryDataStore(vol.getPoolId());\n                        if (!pool.isInMaintenance()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Root volume is ready, need to place VM in volume's cluster\");\n                            }\n                            final long rootVolDcId = pool.getDataCenterId();\n                            final Long rootVolPodId = pool.getPodId();\n                            final Long rootVolClusterId = pool.getClusterId();\n                            if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n                                final Long clusterIdSpecified = planToDeploy.getClusterId();\n                                if (clusterIdSpecified != null && rootVolClusterId != null) {\n                                    if (rootVolClusterId.longValue() != clusterIdSpecified.longValue()) {\n                                        \r\n                                        \r\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"Cannot satisfy the deployment plan passed in since the ready Root volume is in different cluster. volume's cluster: \" +\n                                                    rootVolClusterId + \", cluster specified: \" + clusterIdSpecified);\n                                        }\n                                        throw new ResourceUnavailableException(\n                                                \"Root volume is ready in different cluster, Deployment plan provided cannot be satisfied, unable to create a deployment for \" +\n                                                        vm, Cluster.class, clusterIdSpecified);\n                                    }\n                                }\n                                plan =\n                                        new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(),\n                                                planToDeploy.getHostId(), vol.getPoolId(), null, ctx);\n                            } else {\n                                plan = new DataCenterDeployment(rootVolDcId, rootVolPodId, rootVolClusterId, null, vol.getPoolId(), null, ctx);\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(vol + \" is READY, changing deployment plan to use this pool's dcId: \" + rootVolDcId + \" , podId: \" + rootVolPodId +\n                                            \" , and clusterId: \" + rootVolClusterId);\n                                }\n                                planChangedByVolume = true;\n                            }\n                        }\n                    }\n                }\n\n                final Account owner = _entityMgr.findById(Account.class, vm.getAccountId());\n                final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vm, template, offering, owner, params);\n                DeployDestination dest = null;\n                try {\n                    dest = _dpMgr.planDeployment(vmProfile, plan, avoids, planner);\n                } catch (final AffinityConflictException e2) {\n                    s_logger.warn(\"Unable to create deployment, affinity rules associted to the VM conflict\", e2);\n                    throw new CloudRuntimeException(\"Unable to create deployment, affinity rules associted to the VM conflict\");\n\n                }\n\n                if (dest == null) {\n                    if (planChangedByVolume) {\n                        plan = originalPlan;\n                        planChangedByVolume = false;\n                        \r\n                        reuseVolume = false;\n                        continue;\n                    }\n                    throw new InsufficientServerCapacityException(\"Unable to create a deployment for \" + vmProfile, DataCenter.class, plan.getDataCenterId(),\n                            areAffinityGroupsAssociated(vmProfile));\n                }\n\n                if (dest != null) {\n                    avoids.addHost(dest.getHost().getId());\n                    journal.record(\"Deployment found \", vmProfile, dest);\n                }\n\n                long destHostId = dest.getHost().getId();\n                vm.setPodIdToDeployIn(dest.getPod().getId());\n                final Long cluster_id = dest.getCluster().getId();\n                final ClusterDetailsVO cluster_detail_cpu = _clusterDetailsDao.findDetail(cluster_id, \"cpuOvercommitRatio\");\n                final ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, \"memoryOvercommitRatio\");\n                \r\n                if (userVmDetailsDao.findDetail(vm.getId(), \"cpuOvercommitRatio\") == null &&\n                        (Float.parseFloat(cluster_detail_cpu.getValue()) > 1f || Float.parseFloat(cluster_detail_ram.getValue()) > 1f)) {\n                    userVmDetailsDao.addDetail(vm.getId(), \"cpuOvercommitRatio\", cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), \"memoryOvercommitRatio\", cluster_detail_ram.getValue(), true);\n                } else if (userVmDetailsDao.findDetail(vm.getId(), \"cpuOvercommitRatio\") != null) {\n                    userVmDetailsDao.addDetail(vm.getId(), \"cpuOvercommitRatio\", cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), \"memoryOvercommitRatio\", cluster_detail_ram.getValue(), true);\n                }\n\n                vmProfile.setCpuOvercommitRatio(Float.parseFloat(cluster_detail_cpu.getValue()));\n                vmProfile.setMemoryOvercommitRatio(Float.parseFloat(cluster_detail_ram.getValue()));\n                StartAnswer startAnswer = null;\n\n                try {\n                    if (!changeState(vm, Event.OperationRetry, destHostId, work, Step.Prepare)) {\n                        throw new ConcurrentOperationException(\"Unable to update the state of the Virtual Machine \"+vm.getUuid()+\" oldstate: \"+vm.getState()+ \"Event :\"+Event.OperationRetry);\n                    }\n                } catch (final NoTransitionException e1) {\n                    throw new ConcurrentOperationException(e1.getMessage());\n                }\n\n                try {\n                    _networkMgr.prepare(vmProfile, new DeployDestination(dest.getDataCenter(), dest.getPod(), null, null, dest.getStorageForDisks()), ctx);\n                    if (vm.getHypervisorType() != HypervisorType.BareMetal) {\n                        volumeMgr.prepare(vmProfile, dest);\n                    }\n\n                    \r\n                    if (!reuseVolume) {\n                        reuseVolume = true;\n                    }\n\n                    Commands cmds = null;\n                    vmGuru.finalizeVirtualMachineProfile(vmProfile, dest, ctx);\n\n                    final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);\n\n                    handlePath(vmTO.getDisks(), vm.getHypervisorType());\n\n                    cmds = new Commands(Command.OnError.Stop);\n\n                    cmds.addCommand(new StartCommand(vmTO, dest.getHost(), getExecuteInSequence(vm.getHypervisorType())));\n\n                    vmGuru.finalizeDeployment(cmds, vmProfile, dest, ctx);\n\n                    work = _workDao.findById(work.getId());\n                    if (work == null || work.getStep() != Step.Prepare) {\n                        throw new ConcurrentOperationException(\"Work steps have been changed: \" + work);\n                    }\n\n                    _workDao.updateStep(work, Step.Starting);\n\n                    _agentMgr.send(destHostId, cmds);\n\n                    _workDao.updateStep(work, Step.Started);\n\n                    startAnswer = cmds.getAnswer(StartAnswer.class);\n                    if (startAnswer != null && startAnswer.getResult()) {\n                        handlePath(vmTO.getDisks(), startAnswer.getIqnToData());\n\n                        final String host_guid = startAnswer.getHost_guid();\n\n                        if (host_guid != null) {\n                            final HostVO finalHost = _resourceMgr.findHostByGuid(host_guid);\n                            if (finalHost == null) {\n                                throw new CloudRuntimeException(\"Host Guid \" + host_guid + \" doesn't exist in DB, something went wrong while processing start answer: \"+startAnswer);\n                            }\n                            destHostId = finalHost.getId();\n                        }\n                        if (vmGuru.finalizeStart(vmProfile, destHostId, cmds, ctx)) {\n                            syncDiskChainChange(startAnswer);\n\n                            if (!changeState(vm, Event.OperationSucceeded, destHostId, work, Step.Done)) {\n                                s_logger.error(\"Unable to transition to a new state. VM uuid: \"+vm.getUuid()+    \"VM oldstate:\"+vm.getState()+\"Event:\"+Event.OperationSucceeded);\n                                throw new ConcurrentOperationException(\"Failed to deploy VM\"+ vm.getUuid());\n                            }\n\n                            \r\n                            final GPUDeviceTO gpuDevice = startAnswer.getVirtualMachine().getGpuDevice();\n                            if (gpuDevice != null) {\n                                _resourceMgr.updateGPUDetails(destHostId, gpuDevice.getGroupDetails());\n                            }\n\n                            \r\n                            \r\n                            \r\n                            if (userVmDetailsDao.findDetail(vm.getId(), \"deployvm\") != null) {\n                                userVmDetailsDao.removeDetail(vm.getId(), \"deployvm\");\n                            }\n\n                            startedVm = vm;\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Start completed for VM \" + vm);\n                            }\n                            final Host vmHost = _hostDao.findById(destHostId);\n                            if (vmHost != null && (VirtualMachine.Type.ConsoleProxy.equals(vm.getType()) ||\n                                    VirtualMachine.Type.SecondaryStorageVm.equals(vm.getType())) && caManager.canProvisionCertificates()) {\n                                final Map<String, String> sshAccessDetails = _networkMgr.getSystemVMAccessDetails(vm);\n                                for (int retries = 3; retries > 0; retries--) {\n                                    try {\n                                        setupAgentSecurity(vmHost, sshAccessDetails, vm);\n                                        return;\n                                    } catch (final Exception e) {\n                                        s_logger.error(\"Retrying after catching exception while trying to secure agent for systemvm id=\" + vm.getId(), e);\n                                    }\n                                }\n                                throw new CloudRuntimeException(\"Failed to setup and secure agent for systemvm id=\" + vm.getId());\n                            }\n                            return;\n                        } else {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.info(\"The guru did not like the answers so stopping \" + vm);\n                            }\n                            StopCommand stopCmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n                            stopCmd.setControlIp(getControlNicIpForVM(vm));\n                            final StopCommand cmd = stopCmd;\n                            final Answer answer = _agentMgr.easySend(destHostId, cmd);\n                            if (answer != null && answer instanceof StopAnswer) {\n                                final StopAnswer stopAns = (StopAnswer)answer;\n                                if (vm.getType() == VirtualMachine.Type.User) {\n                                    final String platform = stopAns.getPlatform();\n                                    if (platform != null) {\n                                        final Map<String,String> vmmetadata = new HashMap<String,String>();\n                                        vmmetadata.put(vm.getInstanceName(), platform);\n                                        syncVMMetaData(vmmetadata);\n                                    }\n                                }\n                            }\n\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.warn(\"Unable to stop \" + vm + \" due to \" + (answer != null ? answer.getDetails() : \"no answers\"));\n                                _haMgr.scheduleStop(vm, destHostId, WorkType.ForceStop);\n                                throw new ExecutionException(\"Unable to stop this VM, \"+vm.getUuid()+\" so we are unable to retry the start operation\");\n                            }\n                            throw new ExecutionException(\"Unable to start  VM:\"+vm.getUuid()+\" due to error in finalizeStart, not retrying\");\n                        }\n                    }\n                    s_logger.info(\"Unable to start VM on \" + dest.getHost() + \" due to \" + (startAnswer == null ? \" no start answer\" : startAnswer.getDetails()));\n                    if (startAnswer != null && startAnswer.getContextParam(\"stopRetry\") != null) {\n                        break;\n                    }\n\n                } catch (OperationTimedoutException e) {\n                    s_logger.debug(\"Unable to send the start command to host \" + dest.getHost()+\" failed to start VM: \"+vm.getUuid());\n                    if (e.isActive()) {\n                        _haMgr.scheduleStop(vm, destHostId, WorkType.CheckStop);\n                    }\n                    canRetry = false;\n                    throw new AgentUnavailableException(\"Unable to start \" + vm.getHostName(), destHostId, e);\n                } catch (final ResourceUnavailableException e) {\n                    s_logger.info(\"Unable to contact resource.\", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected ResourceUnavailableException : \" + e.getScope().getName(), e);\n                            throw e;\n                        }\n                    }\n                } catch (final InsufficientCapacityException e) {\n                    s_logger.info(\"Insufficient capacity \", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected InsufficientCapacityException : \" + e.getScope().getName(), e);\n                        }\n                    }\n                } catch (final ExecutionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final NoTransitionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } finally {\n                    if (startedVm == null && canRetry) {\n                        final Step prevStep = work.getStep();\n                        _workDao.updateStep(work, Step.Release);\n                        \r\n                        if ((prevStep == Step.Started || prevStep == Step.Starting) && startAnswer != null && startAnswer.getResult()) {  \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, false);\n                        } else {\n                            \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, true);\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (startedVm == null) {\n                if (canRetry) {\n                    try {\n                        changeState(vm, Event.OperationFailed, null, work, Step.Done);\n                    } catch (final NoTransitionException e) {\n                        throw new ConcurrentOperationException(e.getMessage());\n                    }\n                }\n            }\n\n            if (planToDeploy != null) {\n                planToDeploy.setAvoids(avoids);\n            }\n        }\n\n        if (startedVm == null) {\n            throw new CloudRuntimeException(\"Unable to start instance '\" + vm.getHostName() + \"' (\" + vm.getUuid() + \"), see management server log for details\");\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":931,"status":"M"},{"authorDate":"2019-06-25 23:23:09","commitOrder":6,"curCode":"    public Command cleanup(final VirtualMachine vm, Map<String, DpdkTO> dpdkInterfaceMapping) {\n        StopCommand cmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n        cmd.setControlIp(getControlNicIpForVM(vm));\n        if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n            cmd.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n        }\n        return cmd;\n    }\n","date":"2019-06-25 23:23:09","endLine":3112,"groupId":"25415","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"cleanup","params":"(finalVirtualMachinevm@Map<String@DpdkTO>dpdkInterfaceMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/79/5705345962a468ec5b626e71be73e2c2815950.src","preCode":"    public Command cleanup(final VirtualMachine vm, Map<String, DpdkTO> dpdkInterfaceMapping) {\n        StopCommand cmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n        cmd.setControlIp(getControlNicIpForVM(vm));\n        if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n            cmd.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n        }\n        return cmd;\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":3105,"status":"N"}],"commitId":"9f4f2c5348af93eeb790fbf4908cdde4f0b7806a","commitMessage":"@@@api: instance and template details are free text (#3240)\n\nProblem: Users don't know what keys/values to enter for template and VM details.\nRoot Cause: The feature does not exist that can list possible details and options.\nSolution: Based on the possible VM and template details handled by the\ncodebase.  those details were refactored and a list API is introduced\nthat can return users those details along with possible values. When\nusers add details now.  they will be presented with a list of key details\nand their possible options if any.\n\nSigned-off-by: Rohit Yadav <rohit.yadav@shapeblue.com>","date":"2019-06-27 11:44:47","modifiedFileCount":"16","status":"M","submitter":"Rohit Yadav"},{"authorTime":"2019-06-25 23:23:09","codes":[{"authorDate":"2020-01-09 00:53:45","commitOrder":7,"curCode":"    public void orchestrateStart(final String vmUuid, final Map<VirtualMachineProfile.Param, Object> params, final DeploymentPlan planToDeploy, final DeploymentPlanner planner)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {\n\n        final CallContext cctxt = CallContext.current();\n        final Account account = cctxt.getCallingAccount();\n        final User caller = cctxt.getCallingUser();\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final Ternary<VMInstanceVO, ReservationContext, ItWorkVO> start = changeToStartState(vmGuru, vm, caller, account);\n        if (start == null) {\n            return;\n        }\n\n        vm = start.first();\n        final ReservationContext ctx = start.second();\n        ItWorkVO work = start.third();\n\n        VMInstanceVO startedVm = null;\n        final ServiceOfferingVO offering = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());\n        final VirtualMachineTemplate template = _entityMgr.findByIdIncludingRemoved(VirtualMachineTemplate.class, vm.getTemplateId());\n\n        DataCenterDeployment plan = new DataCenterDeployment(vm.getDataCenterId(), vm.getPodIdToDeployIn(), null, null, null, null, ctx);\n        if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"advanceStart: DeploymentPlan is provided, using dcId:\" + planToDeploy.getDataCenterId() + \", podId: \" + planToDeploy.getPodId() +\n                        \", clusterId: \" + planToDeploy.getClusterId() + \", hostId: \" + planToDeploy.getHostId() + \", poolId: \" + planToDeploy.getPoolId());\n            }\n            plan =\n                    new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(), planToDeploy.getHostId(),\n                            planToDeploy.getPoolId(), planToDeploy.getPhysicalNetworkId(), ctx);\n        }\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        boolean canRetry = true;\n        ExcludeList avoids = null;\n        try {\n            final Journal journal = start.second().getJournal();\n\n            if (planToDeploy != null) {\n                avoids = planToDeploy.getAvoids();\n            }\n            if (avoids == null) {\n                avoids = new ExcludeList();\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Deploy avoids pods: \" + avoids.getPodsToAvoid() + \", clusters: \" + avoids.getClustersToAvoid() + \", hosts: \" + avoids.getHostsToAvoid());\n            }\n\n            boolean planChangedByVolume = false;\n            boolean reuseVolume = true;\n            final DataCenterDeployment originalPlan = plan;\n\n            int retry = StartRetry.value();\n            while (retry-- != 0) { \r\n\n                if (reuseVolume) {\n                    \r\n                    final List<VolumeVO> vols = _volsDao.findReadyRootVolumesByInstance(vm.getId());\n                    for (final VolumeVO vol : vols) {\n                        \r\n                        \r\n                        \r\n                        final Long volTemplateId = vol.getTemplateId();\n                        if (volTemplateId != null && volTemplateId.longValue() != template.getId()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(vol + \" of \" + vm + \" is READY, but template ids don't match, let the planner reassign a new pool\");\n                            }\n                            continue;\n                        }\n\n                        final StoragePool pool = (StoragePool)dataStoreMgr.getPrimaryDataStore(vol.getPoolId());\n                        if (!pool.isInMaintenance()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Root volume is ready, need to place VM in volume's cluster\");\n                            }\n                            final long rootVolDcId = pool.getDataCenterId();\n                            final Long rootVolPodId = pool.getPodId();\n                            final Long rootVolClusterId = pool.getClusterId();\n                            if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n                                final Long clusterIdSpecified = planToDeploy.getClusterId();\n                                if (clusterIdSpecified != null && rootVolClusterId != null) {\n                                    if (rootVolClusterId.longValue() != clusterIdSpecified.longValue()) {\n                                        \r\n                                        \r\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"Cannot satisfy the deployment plan passed in since the ready Root volume is in different cluster. volume's cluster: \" +\n                                                    rootVolClusterId + \", cluster specified: \" + clusterIdSpecified);\n                                        }\n                                        throw new ResourceUnavailableException(\n                                                \"Root volume is ready in different cluster, Deployment plan provided cannot be satisfied, unable to create a deployment for \" +\n                                                        vm, Cluster.class, clusterIdSpecified);\n                                    }\n                                }\n                                plan =\n                                        new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(),\n                                                planToDeploy.getHostId(), vol.getPoolId(), null, ctx);\n                            } else {\n                                plan = new DataCenterDeployment(rootVolDcId, rootVolPodId, rootVolClusterId, null, vol.getPoolId(), null, ctx);\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(vol + \" is READY, changing deployment plan to use this pool's dcId: \" + rootVolDcId + \" , podId: \" + rootVolPodId +\n                                            \" , and clusterId: \" + rootVolClusterId);\n                                }\n                                planChangedByVolume = true;\n                            }\n                        }\n                    }\n                }\n\n                final Account owner = _entityMgr.findById(Account.class, vm.getAccountId());\n                final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vm, template, offering, owner, params);\n                DeployDestination dest = null;\n                try {\n                    dest = _dpMgr.planDeployment(vmProfile, plan, avoids, planner);\n                } catch (final AffinityConflictException e2) {\n                    s_logger.warn(\"Unable to create deployment, affinity rules associted to the VM conflict\", e2);\n                    throw new CloudRuntimeException(\"Unable to create deployment, affinity rules associted to the VM conflict\");\n\n                }\n\n                if (dest == null) {\n                    if (planChangedByVolume) {\n                        plan = originalPlan;\n                        planChangedByVolume = false;\n                        \r\n                        reuseVolume = false;\n                        continue;\n                    }\n                    throw new InsufficientServerCapacityException(\"Unable to create a deployment for \" + vmProfile, DataCenter.class, plan.getDataCenterId(),\n                            areAffinityGroupsAssociated(vmProfile));\n                }\n\n                if (dest != null) {\n                    avoids.addHost(dest.getHost().getId());\n                    journal.record(\"Deployment found \", vmProfile, dest);\n                }\n\n                long destHostId = dest.getHost().getId();\n                vm.setPodIdToDeployIn(dest.getPod().getId());\n                final Long cluster_id = dest.getCluster().getId();\n                final ClusterDetailsVO cluster_detail_cpu = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                final ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                \r\n                if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) == null &&\n                        (Float.parseFloat(cluster_detail_cpu.getValue()) > 1f || Float.parseFloat(cluster_detail_ram.getValue()) > 1f)) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                } else if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) != null) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                }\n\n                vmProfile.setCpuOvercommitRatio(Float.parseFloat(cluster_detail_cpu.getValue()));\n                vmProfile.setMemoryOvercommitRatio(Float.parseFloat(cluster_detail_ram.getValue()));\n                StartAnswer startAnswer = null;\n\n                try {\n                    if (!changeState(vm, Event.OperationRetry, destHostId, work, Step.Prepare)) {\n                        throw new ConcurrentOperationException(\"Unable to update the state of the Virtual Machine \"+vm.getUuid()+\" oldstate: \"+vm.getState()+ \"Event :\"+Event.OperationRetry);\n                    }\n                } catch (final NoTransitionException e1) {\n                    throw new ConcurrentOperationException(e1.getMessage());\n                }\n\n                try {\n                    _networkMgr.prepare(vmProfile, new DeployDestination(dest.getDataCenter(), dest.getPod(), null, null, dest.getStorageForDisks()), ctx);\n                    if (vm.getHypervisorType() != HypervisorType.BareMetal) {\n                        volumeMgr.prepare(vmProfile, dest);\n                    }\n\n                    \r\n                    if (!reuseVolume) {\n                        reuseVolume = true;\n                    }\n\n                    Commands cmds = null;\n                    vmGuru.finalizeVirtualMachineProfile(vmProfile, dest, ctx);\n\n                    final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);\n\n                    handlePath(vmTO.getDisks(), vm.getHypervisorType());\n\n                    cmds = new Commands(Command.OnError.Stop);\n\n                    cmds.addCommand(new StartCommand(vmTO, dest.getHost(), getExecuteInSequence(vm.getHypervisorType())));\n\n                    vmGuru.finalizeDeployment(cmds, vmProfile, dest, ctx);\n\n                    \r\n                    addExtraConfig(vmTO);\n\n                    work = _workDao.findById(work.getId());\n                    if (work == null || work.getStep() != Step.Prepare) {\n                        throw new ConcurrentOperationException(\"Work steps have been changed: \" + work);\n                    }\n\n                    _workDao.updateStep(work, Step.Starting);\n\n                    _agentMgr.send(destHostId, cmds);\n\n                    _workDao.updateStep(work, Step.Started);\n\n                    startAnswer = cmds.getAnswer(StartAnswer.class);\n                    if (startAnswer != null && startAnswer.getResult()) {\n                        handlePath(vmTO.getDisks(), startAnswer.getIqnToData());\n\n                        final String host_guid = startAnswer.getHost_guid();\n\n                        if (host_guid != null) {\n                            final HostVO finalHost = _resourceMgr.findHostByGuid(host_guid);\n                            if (finalHost == null) {\n                                throw new CloudRuntimeException(\"Host Guid \" + host_guid + \" doesn't exist in DB, something went wrong while processing start answer: \"+startAnswer);\n                            }\n                            destHostId = finalHost.getId();\n                        }\n                        if (vmGuru.finalizeStart(vmProfile, destHostId, cmds, ctx)) {\n                            syncDiskChainChange(startAnswer);\n\n                            if (!changeState(vm, Event.OperationSucceeded, destHostId, work, Step.Done)) {\n                                s_logger.error(\"Unable to transition to a new state. VM uuid: \"+vm.getUuid()+    \"VM oldstate:\"+vm.getState()+\"Event:\"+Event.OperationSucceeded);\n                                throw new ConcurrentOperationException(\"Failed to deploy VM\"+ vm.getUuid());\n                            }\n\n                            \r\n                            final GPUDeviceTO gpuDevice = startAnswer.getVirtualMachine().getGpuDevice();\n                            if (gpuDevice != null) {\n                                _resourceMgr.updateGPUDetails(destHostId, gpuDevice.getGroupDetails());\n                            }\n\n                            \r\n                            \r\n                            \r\n                            if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.DEPLOY_VM) != null) {\n                                userVmDetailsDao.removeDetail(vm.getId(), VmDetailConstants.DEPLOY_VM);\n                            }\n\n                            startedVm = vm;\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Start completed for VM \" + vm);\n                            }\n                            final Host vmHost = _hostDao.findById(destHostId);\n                            if (vmHost != null && (VirtualMachine.Type.ConsoleProxy.equals(vm.getType()) ||\n                                    VirtualMachine.Type.SecondaryStorageVm.equals(vm.getType())) && caManager.canProvisionCertificates()) {\n                                final Map<String, String> sshAccessDetails = _networkMgr.getSystemVMAccessDetails(vm);\n                                for (int retries = 3; retries > 0; retries--) {\n                                    try {\n                                        setupAgentSecurity(vmHost, sshAccessDetails, vm);\n                                        return;\n                                    } catch (final Exception e) {\n                                        s_logger.error(\"Retrying after catching exception while trying to secure agent for systemvm id=\" + vm.getId(), e);\n                                    }\n                                }\n                                throw new CloudRuntimeException(\"Failed to setup and secure agent for systemvm id=\" + vm.getId());\n                            }\n                            return;\n                        } else {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.info(\"The guru did not like the answers so stopping \" + vm);\n                            }\n                            StopCommand stopCmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n                            stopCmd.setControlIp(getControlNicIpForVM(vm));\n                            final StopCommand cmd = stopCmd;\n                            final Answer answer = _agentMgr.easySend(destHostId, cmd);\n                            if (answer != null && answer instanceof StopAnswer) {\n                                final StopAnswer stopAns = (StopAnswer)answer;\n                                if (vm.getType() == VirtualMachine.Type.User) {\n                                    final String platform = stopAns.getPlatform();\n                                    if (platform != null) {\n                                        final Map<String,String> vmmetadata = new HashMap<String,String>();\n                                        vmmetadata.put(vm.getInstanceName(), platform);\n                                        syncVMMetaData(vmmetadata);\n                                    }\n                                }\n                            }\n\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.warn(\"Unable to stop \" + vm + \" due to \" + (answer != null ? answer.getDetails() : \"no answers\"));\n                                _haMgr.scheduleStop(vm, destHostId, WorkType.ForceStop);\n                                throw new ExecutionException(\"Unable to stop this VM, \"+vm.getUuid()+\" so we are unable to retry the start operation\");\n                            }\n                            throw new ExecutionException(\"Unable to start  VM:\"+vm.getUuid()+\" due to error in finalizeStart, not retrying\");\n                        }\n                    }\n                    s_logger.info(\"Unable to start VM on \" + dest.getHost() + \" due to \" + (startAnswer == null ? \" no start answer\" : startAnswer.getDetails()));\n                    if (startAnswer != null && startAnswer.getContextParam(\"stopRetry\") != null) {\n                        break;\n                    }\n\n                } catch (OperationTimedoutException e) {\n                    s_logger.debug(\"Unable to send the start command to host \" + dest.getHost()+\" failed to start VM: \"+vm.getUuid());\n                    if (e.isActive()) {\n                        _haMgr.scheduleStop(vm, destHostId, WorkType.CheckStop);\n                    }\n                    canRetry = false;\n                    throw new AgentUnavailableException(\"Unable to start \" + vm.getHostName(), destHostId, e);\n                } catch (final ResourceUnavailableException e) {\n                    s_logger.info(\"Unable to contact resource.\", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected ResourceUnavailableException : \" + e.getScope().getName(), e);\n                            throw e;\n                        }\n                    }\n                } catch (final InsufficientCapacityException e) {\n                    s_logger.info(\"Insufficient capacity \", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected InsufficientCapacityException : \" + e.getScope().getName(), e);\n                        }\n                    }\n                } catch (final ExecutionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final NoTransitionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } finally {\n                    if (startedVm == null && canRetry) {\n                        final Step prevStep = work.getStep();\n                        _workDao.updateStep(work, Step.Release);\n                        \r\n                        if ((prevStep == Step.Started || prevStep == Step.Starting) && startAnswer != null && startAnswer.getResult()) {  \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, false);\n                        } else {\n                            \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, true);\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (startedVm == null) {\n                if (canRetry) {\n                    try {\n                        changeState(vm, Event.OperationFailed, null, work, Step.Done);\n                    } catch (final NoTransitionException e) {\n                        throw new ConcurrentOperationException(e.getMessage());\n                    }\n                }\n            }\n\n            if (planToDeploy != null) {\n                planToDeploy.setAvoids(avoids);\n            }\n        }\n\n        if (startedVm == null) {\n            throw new CloudRuntimeException(\"Unable to start instance '\" + vm.getHostName() + \"' (\" + vm.getUuid() + \"), see management server log for details\");\n        }\n    }\n","date":"2020-01-09 00:53:45","endLine":1292,"groupId":"22263","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"orchestrateStart","params":"(finalStringvmUuid@finalMap<VirtualMachineProfile.Param@Object>params@finalDeploymentPlanplanToDeploy@finalDeploymentPlannerplanner)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/b5/4d548156e2cb757ccb76fbefbeed259e5f71ae.src","preCode":"    public void orchestrateStart(final String vmUuid, final Map<VirtualMachineProfile.Param, Object> params, final DeploymentPlan planToDeploy, final DeploymentPlanner planner)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {\n\n        final CallContext cctxt = CallContext.current();\n        final Account account = cctxt.getCallingAccount();\n        final User caller = cctxt.getCallingUser();\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final Ternary<VMInstanceVO, ReservationContext, ItWorkVO> start = changeToStartState(vmGuru, vm, caller, account);\n        if (start == null) {\n            return;\n        }\n\n        vm = start.first();\n        final ReservationContext ctx = start.second();\n        ItWorkVO work = start.third();\n\n        VMInstanceVO startedVm = null;\n        final ServiceOfferingVO offering = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());\n        final VirtualMachineTemplate template = _entityMgr.findByIdIncludingRemoved(VirtualMachineTemplate.class, vm.getTemplateId());\n\n        DataCenterDeployment plan = new DataCenterDeployment(vm.getDataCenterId(), vm.getPodIdToDeployIn(), null, null, null, null, ctx);\n        if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"advanceStart: DeploymentPlan is provided, using dcId:\" + planToDeploy.getDataCenterId() + \", podId: \" + planToDeploy.getPodId() +\n                        \", clusterId: \" + planToDeploy.getClusterId() + \", hostId: \" + planToDeploy.getHostId() + \", poolId: \" + planToDeploy.getPoolId());\n            }\n            plan =\n                    new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(), planToDeploy.getHostId(),\n                            planToDeploy.getPoolId(), planToDeploy.getPhysicalNetworkId(), ctx);\n        }\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        boolean canRetry = true;\n        ExcludeList avoids = null;\n        try {\n            final Journal journal = start.second().getJournal();\n\n            if (planToDeploy != null) {\n                avoids = planToDeploy.getAvoids();\n            }\n            if (avoids == null) {\n                avoids = new ExcludeList();\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Deploy avoids pods: \" + avoids.getPodsToAvoid() + \", clusters: \" + avoids.getClustersToAvoid() + \", hosts: \" + avoids.getHostsToAvoid());\n            }\n\n            boolean planChangedByVolume = false;\n            boolean reuseVolume = true;\n            final DataCenterDeployment originalPlan = plan;\n\n            int retry = StartRetry.value();\n            while (retry-- != 0) { \r\n\n                if (reuseVolume) {\n                    \r\n                    final List<VolumeVO> vols = _volsDao.findReadyRootVolumesByInstance(vm.getId());\n                    for (final VolumeVO vol : vols) {\n                        \r\n                        \r\n                        \r\n                        final Long volTemplateId = vol.getTemplateId();\n                        if (volTemplateId != null && volTemplateId.longValue() != template.getId()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(vol + \" of \" + vm + \" is READY, but template ids don't match, let the planner reassign a new pool\");\n                            }\n                            continue;\n                        }\n\n                        final StoragePool pool = (StoragePool)dataStoreMgr.getPrimaryDataStore(vol.getPoolId());\n                        if (!pool.isInMaintenance()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Root volume is ready, need to place VM in volume's cluster\");\n                            }\n                            final long rootVolDcId = pool.getDataCenterId();\n                            final Long rootVolPodId = pool.getPodId();\n                            final Long rootVolClusterId = pool.getClusterId();\n                            if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n                                final Long clusterIdSpecified = planToDeploy.getClusterId();\n                                if (clusterIdSpecified != null && rootVolClusterId != null) {\n                                    if (rootVolClusterId.longValue() != clusterIdSpecified.longValue()) {\n                                        \r\n                                        \r\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"Cannot satisfy the deployment plan passed in since the ready Root volume is in different cluster. volume's cluster: \" +\n                                                    rootVolClusterId + \", cluster specified: \" + clusterIdSpecified);\n                                        }\n                                        throw new ResourceUnavailableException(\n                                                \"Root volume is ready in different cluster, Deployment plan provided cannot be satisfied, unable to create a deployment for \" +\n                                                        vm, Cluster.class, clusterIdSpecified);\n                                    }\n                                }\n                                plan =\n                                        new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(),\n                                                planToDeploy.getHostId(), vol.getPoolId(), null, ctx);\n                            } else {\n                                plan = new DataCenterDeployment(rootVolDcId, rootVolPodId, rootVolClusterId, null, vol.getPoolId(), null, ctx);\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(vol + \" is READY, changing deployment plan to use this pool's dcId: \" + rootVolDcId + \" , podId: \" + rootVolPodId +\n                                            \" , and clusterId: \" + rootVolClusterId);\n                                }\n                                planChangedByVolume = true;\n                            }\n                        }\n                    }\n                }\n\n                final Account owner = _entityMgr.findById(Account.class, vm.getAccountId());\n                final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vm, template, offering, owner, params);\n                DeployDestination dest = null;\n                try {\n                    dest = _dpMgr.planDeployment(vmProfile, plan, avoids, planner);\n                } catch (final AffinityConflictException e2) {\n                    s_logger.warn(\"Unable to create deployment, affinity rules associted to the VM conflict\", e2);\n                    throw new CloudRuntimeException(\"Unable to create deployment, affinity rules associted to the VM conflict\");\n\n                }\n\n                if (dest == null) {\n                    if (planChangedByVolume) {\n                        plan = originalPlan;\n                        planChangedByVolume = false;\n                        \r\n                        reuseVolume = false;\n                        continue;\n                    }\n                    throw new InsufficientServerCapacityException(\"Unable to create a deployment for \" + vmProfile, DataCenter.class, plan.getDataCenterId(),\n                            areAffinityGroupsAssociated(vmProfile));\n                }\n\n                if (dest != null) {\n                    avoids.addHost(dest.getHost().getId());\n                    journal.record(\"Deployment found \", vmProfile, dest);\n                }\n\n                long destHostId = dest.getHost().getId();\n                vm.setPodIdToDeployIn(dest.getPod().getId());\n                final Long cluster_id = dest.getCluster().getId();\n                final ClusterDetailsVO cluster_detail_cpu = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                final ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                \r\n                if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) == null &&\n                        (Float.parseFloat(cluster_detail_cpu.getValue()) > 1f || Float.parseFloat(cluster_detail_ram.getValue()) > 1f)) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                } else if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) != null) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                }\n\n                vmProfile.setCpuOvercommitRatio(Float.parseFloat(cluster_detail_cpu.getValue()));\n                vmProfile.setMemoryOvercommitRatio(Float.parseFloat(cluster_detail_ram.getValue()));\n                StartAnswer startAnswer = null;\n\n                try {\n                    if (!changeState(vm, Event.OperationRetry, destHostId, work, Step.Prepare)) {\n                        throw new ConcurrentOperationException(\"Unable to update the state of the Virtual Machine \"+vm.getUuid()+\" oldstate: \"+vm.getState()+ \"Event :\"+Event.OperationRetry);\n                    }\n                } catch (final NoTransitionException e1) {\n                    throw new ConcurrentOperationException(e1.getMessage());\n                }\n\n                try {\n                    _networkMgr.prepare(vmProfile, new DeployDestination(dest.getDataCenter(), dest.getPod(), null, null, dest.getStorageForDisks()), ctx);\n                    if (vm.getHypervisorType() != HypervisorType.BareMetal) {\n                        volumeMgr.prepare(vmProfile, dest);\n                    }\n\n                    \r\n                    if (!reuseVolume) {\n                        reuseVolume = true;\n                    }\n\n                    Commands cmds = null;\n                    vmGuru.finalizeVirtualMachineProfile(vmProfile, dest, ctx);\n\n                    final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);\n\n                    handlePath(vmTO.getDisks(), vm.getHypervisorType());\n\n                    cmds = new Commands(Command.OnError.Stop);\n\n                    cmds.addCommand(new StartCommand(vmTO, dest.getHost(), getExecuteInSequence(vm.getHypervisorType())));\n\n                    vmGuru.finalizeDeployment(cmds, vmProfile, dest, ctx);\n\n                    work = _workDao.findById(work.getId());\n                    if (work == null || work.getStep() != Step.Prepare) {\n                        throw new ConcurrentOperationException(\"Work steps have been changed: \" + work);\n                    }\n\n                    _workDao.updateStep(work, Step.Starting);\n\n                    _agentMgr.send(destHostId, cmds);\n\n                    _workDao.updateStep(work, Step.Started);\n\n                    startAnswer = cmds.getAnswer(StartAnswer.class);\n                    if (startAnswer != null && startAnswer.getResult()) {\n                        handlePath(vmTO.getDisks(), startAnswer.getIqnToData());\n\n                        final String host_guid = startAnswer.getHost_guid();\n\n                        if (host_guid != null) {\n                            final HostVO finalHost = _resourceMgr.findHostByGuid(host_guid);\n                            if (finalHost == null) {\n                                throw new CloudRuntimeException(\"Host Guid \" + host_guid + \" doesn't exist in DB, something went wrong while processing start answer: \"+startAnswer);\n                            }\n                            destHostId = finalHost.getId();\n                        }\n                        if (vmGuru.finalizeStart(vmProfile, destHostId, cmds, ctx)) {\n                            syncDiskChainChange(startAnswer);\n\n                            if (!changeState(vm, Event.OperationSucceeded, destHostId, work, Step.Done)) {\n                                s_logger.error(\"Unable to transition to a new state. VM uuid: \"+vm.getUuid()+    \"VM oldstate:\"+vm.getState()+\"Event:\"+Event.OperationSucceeded);\n                                throw new ConcurrentOperationException(\"Failed to deploy VM\"+ vm.getUuid());\n                            }\n\n                            \r\n                            final GPUDeviceTO gpuDevice = startAnswer.getVirtualMachine().getGpuDevice();\n                            if (gpuDevice != null) {\n                                _resourceMgr.updateGPUDetails(destHostId, gpuDevice.getGroupDetails());\n                            }\n\n                            \r\n                            \r\n                            \r\n                            if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.DEPLOY_VM) != null) {\n                                userVmDetailsDao.removeDetail(vm.getId(), VmDetailConstants.DEPLOY_VM);\n                            }\n\n                            startedVm = vm;\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Start completed for VM \" + vm);\n                            }\n                            final Host vmHost = _hostDao.findById(destHostId);\n                            if (vmHost != null && (VirtualMachine.Type.ConsoleProxy.equals(vm.getType()) ||\n                                    VirtualMachine.Type.SecondaryStorageVm.equals(vm.getType())) && caManager.canProvisionCertificates()) {\n                                final Map<String, String> sshAccessDetails = _networkMgr.getSystemVMAccessDetails(vm);\n                                for (int retries = 3; retries > 0; retries--) {\n                                    try {\n                                        setupAgentSecurity(vmHost, sshAccessDetails, vm);\n                                        return;\n                                    } catch (final Exception e) {\n                                        s_logger.error(\"Retrying after catching exception while trying to secure agent for systemvm id=\" + vm.getId(), e);\n                                    }\n                                }\n                                throw new CloudRuntimeException(\"Failed to setup and secure agent for systemvm id=\" + vm.getId());\n                            }\n                            return;\n                        } else {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.info(\"The guru did not like the answers so stopping \" + vm);\n                            }\n                            StopCommand stopCmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n                            stopCmd.setControlIp(getControlNicIpForVM(vm));\n                            final StopCommand cmd = stopCmd;\n                            final Answer answer = _agentMgr.easySend(destHostId, cmd);\n                            if (answer != null && answer instanceof StopAnswer) {\n                                final StopAnswer stopAns = (StopAnswer)answer;\n                                if (vm.getType() == VirtualMachine.Type.User) {\n                                    final String platform = stopAns.getPlatform();\n                                    if (platform != null) {\n                                        final Map<String,String> vmmetadata = new HashMap<String,String>();\n                                        vmmetadata.put(vm.getInstanceName(), platform);\n                                        syncVMMetaData(vmmetadata);\n                                    }\n                                }\n                            }\n\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.warn(\"Unable to stop \" + vm + \" due to \" + (answer != null ? answer.getDetails() : \"no answers\"));\n                                _haMgr.scheduleStop(vm, destHostId, WorkType.ForceStop);\n                                throw new ExecutionException(\"Unable to stop this VM, \"+vm.getUuid()+\" so we are unable to retry the start operation\");\n                            }\n                            throw new ExecutionException(\"Unable to start  VM:\"+vm.getUuid()+\" due to error in finalizeStart, not retrying\");\n                        }\n                    }\n                    s_logger.info(\"Unable to start VM on \" + dest.getHost() + \" due to \" + (startAnswer == null ? \" no start answer\" : startAnswer.getDetails()));\n                    if (startAnswer != null && startAnswer.getContextParam(\"stopRetry\") != null) {\n                        break;\n                    }\n\n                } catch (OperationTimedoutException e) {\n                    s_logger.debug(\"Unable to send the start command to host \" + dest.getHost()+\" failed to start VM: \"+vm.getUuid());\n                    if (e.isActive()) {\n                        _haMgr.scheduleStop(vm, destHostId, WorkType.CheckStop);\n                    }\n                    canRetry = false;\n                    throw new AgentUnavailableException(\"Unable to start \" + vm.getHostName(), destHostId, e);\n                } catch (final ResourceUnavailableException e) {\n                    s_logger.info(\"Unable to contact resource.\", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected ResourceUnavailableException : \" + e.getScope().getName(), e);\n                            throw e;\n                        }\n                    }\n                } catch (final InsufficientCapacityException e) {\n                    s_logger.info(\"Insufficient capacity \", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected InsufficientCapacityException : \" + e.getScope().getName(), e);\n                        }\n                    }\n                } catch (final ExecutionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final NoTransitionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } finally {\n                    if (startedVm == null && canRetry) {\n                        final Step prevStep = work.getStep();\n                        _workDao.updateStep(work, Step.Release);\n                        \r\n                        if ((prevStep == Step.Started || prevStep == Step.Starting) && startAnswer != null && startAnswer.getResult()) {  \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, false);\n                        } else {\n                            \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, true);\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (startedVm == null) {\n                if (canRetry) {\n                    try {\n                        changeState(vm, Event.OperationFailed, null, work, Step.Done);\n                    } catch (final NoTransitionException e) {\n                        throw new ConcurrentOperationException(e.getMessage());\n                    }\n                }\n            }\n\n            if (planToDeploy != null) {\n                planToDeploy.setAvoids(avoids);\n            }\n        }\n\n        if (startedVm == null) {\n            throw new CloudRuntimeException(\"Unable to start instance '\" + vm.getHostName() + \"' (\" + vm.getUuid() + \"), see management server log for details\");\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":936,"status":"M"},{"authorDate":"2019-06-25 23:23:09","commitOrder":7,"curCode":"    public Command cleanup(final VirtualMachine vm, Map<String, DpdkTO> dpdkInterfaceMapping) {\n        StopCommand cmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n        cmd.setControlIp(getControlNicIpForVM(vm));\n        if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n            cmd.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n        }\n        return cmd;\n    }\n","date":"2019-06-25 23:23:09","endLine":3112,"groupId":"25415","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"cleanup","params":"(finalVirtualMachinevm@Map<String@DpdkTO>dpdkInterfaceMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/79/5705345962a468ec5b626e71be73e2c2815950.src","preCode":"    public Command cleanup(final VirtualMachine vm, Map<String, DpdkTO> dpdkInterfaceMapping) {\n        StopCommand cmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n        cmd.setControlIp(getControlNicIpForVM(vm));\n        if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n            cmd.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n        }\n        return cmd;\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":3105,"status":"N"}],"commitId":"70fcf755f7acaed8e0193c998b6361eb0e3121bb","commitMessage":"@@@Allow additional configuration metadata to VMs (#3510)\n\n* Suqash commits to a single commit and rebase against master\n\nUpdate marvin tests to use white list\n\n* * Fix marvin test failure\n* Add new marvin negative tests cases\n* Remove hard-coded hypervisor types in marvin tests\n\n* Fix build error after rebase and add hugepagesless\n\n* Fix readability of python code\n\n* Fix failing test\n\n* Adding cleanup of vms for negative tests\n\n* Bug fixes - change config checks properly and block extraconfig in details\n\n* Trim to compare the keys\n\n* CR comments\n\n* Don't skip extraconfig without exception\n\nCo-authored-by: Boris Stoyanov - a.k.a Bobby <bss.stoyanov@gmail.com>\n","date":"2020-01-09 00:53:45","modifiedFileCount":"7","status":"M","submitter":"Anurag Awasthi"},{"authorTime":"2019-06-25 23:23:09","codes":[{"authorDate":"2020-01-30 17:36:50","commitOrder":8,"curCode":"    public void orchestrateStart(final String vmUuid, final Map<VirtualMachineProfile.Param, Object> params, final DeploymentPlan planToDeploy, final DeploymentPlanner planner)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {\n\n        final CallContext cctxt = CallContext.current();\n        final Account account = cctxt.getCallingAccount();\n        final User caller = cctxt.getCallingUser();\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final Ternary<VMInstanceVO, ReservationContext, ItWorkVO> start = changeToStartState(vmGuru, vm, caller, account);\n        if (start == null) {\n            return;\n        }\n\n        vm = start.first();\n        final ReservationContext ctx = start.second();\n        ItWorkVO work = start.third();\n\n        VMInstanceVO startedVm = null;\n        final ServiceOfferingVO offering = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());\n        final VirtualMachineTemplate template = _entityMgr.findByIdIncludingRemoved(VirtualMachineTemplate.class, vm.getTemplateId());\n\n        DataCenterDeployment plan = new DataCenterDeployment(vm.getDataCenterId(), vm.getPodIdToDeployIn(), null, null, null, null, ctx);\n        if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"advanceStart: DeploymentPlan is provided, using dcId:\" + planToDeploy.getDataCenterId() + \", podId: \" + planToDeploy.getPodId() +\n                        \", clusterId: \" + planToDeploy.getClusterId() + \", hostId: \" + planToDeploy.getHostId() + \", poolId: \" + planToDeploy.getPoolId());\n            }\n            plan =\n                    new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(), planToDeploy.getHostId(),\n                            planToDeploy.getPoolId(), planToDeploy.getPhysicalNetworkId(), ctx);\n        }\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        \r\n        final Account owner = _entityMgr.findById(Account.class, vm.getAccountId());\n        if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n            resourceCountIncrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n        }\n\n        boolean canRetry = true;\n        ExcludeList avoids = null;\n        try {\n            final Journal journal = start.second().getJournal();\n\n            if (planToDeploy != null) {\n                avoids = planToDeploy.getAvoids();\n            }\n            if (avoids == null) {\n                avoids = new ExcludeList();\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Deploy avoids pods: \" + avoids.getPodsToAvoid() + \", clusters: \" + avoids.getClustersToAvoid() + \", hosts: \" + avoids.getHostsToAvoid());\n            }\n\n            boolean planChangedByVolume = false;\n            boolean reuseVolume = true;\n            final DataCenterDeployment originalPlan = plan;\n\n            int retry = StartRetry.value();\n            while (retry-- != 0) { \r\n\n                if (reuseVolume) {\n                    \r\n                    final List<VolumeVO> vols = _volsDao.findReadyRootVolumesByInstance(vm.getId());\n                    for (final VolumeVO vol : vols) {\n                        \r\n                        \r\n                        \r\n                        final Long volTemplateId = vol.getTemplateId();\n                        if (volTemplateId != null && volTemplateId.longValue() != template.getId()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(vol + \" of \" + vm + \" is READY, but template ids don't match, let the planner reassign a new pool\");\n                            }\n                            continue;\n                        }\n\n                        final StoragePool pool = (StoragePool)dataStoreMgr.getPrimaryDataStore(vol.getPoolId());\n                        if (!pool.isInMaintenance()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Root volume is ready, need to place VM in volume's cluster\");\n                            }\n                            final long rootVolDcId = pool.getDataCenterId();\n                            final Long rootVolPodId = pool.getPodId();\n                            final Long rootVolClusterId = pool.getClusterId();\n                            if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n                                final Long clusterIdSpecified = planToDeploy.getClusterId();\n                                if (clusterIdSpecified != null && rootVolClusterId != null) {\n                                    if (rootVolClusterId.longValue() != clusterIdSpecified.longValue()) {\n                                        \r\n                                        \r\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"Cannot satisfy the deployment plan passed in since the ready Root volume is in different cluster. volume's cluster: \" +\n                                                    rootVolClusterId + \", cluster specified: \" + clusterIdSpecified);\n                                        }\n                                        throw new ResourceUnavailableException(\n                                                \"Root volume is ready in different cluster, Deployment plan provided cannot be satisfied, unable to create a deployment for \" +\n                                                        vm, Cluster.class, clusterIdSpecified);\n                                    }\n                                }\n                                plan =\n                                        new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(),\n                                                planToDeploy.getHostId(), vol.getPoolId(), null, ctx);\n                            } else {\n                                plan = new DataCenterDeployment(rootVolDcId, rootVolPodId, rootVolClusterId, null, vol.getPoolId(), null, ctx);\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(vol + \" is READY, changing deployment plan to use this pool's dcId: \" + rootVolDcId + \" , podId: \" + rootVolPodId +\n                                            \" , and clusterId: \" + rootVolClusterId);\n                                }\n                                planChangedByVolume = true;\n                            }\n                        }\n                    }\n                }\n\n                final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vm, template, offering, owner, params);\n                DeployDestination dest = null;\n                try {\n                    dest = _dpMgr.planDeployment(vmProfile, plan, avoids, planner);\n                } catch (final AffinityConflictException e2) {\n                    s_logger.warn(\"Unable to create deployment, affinity rules associted to the VM conflict\", e2);\n                    throw new CloudRuntimeException(\"Unable to create deployment, affinity rules associted to the VM conflict\");\n\n                }\n\n                if (dest == null) {\n                    if (planChangedByVolume) {\n                        plan = originalPlan;\n                        planChangedByVolume = false;\n                        \r\n                        reuseVolume = false;\n                        continue;\n                    }\n                    throw new InsufficientServerCapacityException(\"Unable to create a deployment for \" + vmProfile, DataCenter.class, plan.getDataCenterId(),\n                            areAffinityGroupsAssociated(vmProfile));\n                }\n\n                if (dest != null) {\n                    avoids.addHost(dest.getHost().getId());\n                    journal.record(\"Deployment found \", vmProfile, dest);\n                }\n\n                long destHostId = dest.getHost().getId();\n                vm.setPodIdToDeployIn(dest.getPod().getId());\n                final Long cluster_id = dest.getCluster().getId();\n                final ClusterDetailsVO cluster_detail_cpu = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                final ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                \r\n                if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) == null &&\n                        (Float.parseFloat(cluster_detail_cpu.getValue()) > 1f || Float.parseFloat(cluster_detail_ram.getValue()) > 1f)) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                } else if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) != null) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                }\n\n                vmProfile.setCpuOvercommitRatio(Float.parseFloat(cluster_detail_cpu.getValue()));\n                vmProfile.setMemoryOvercommitRatio(Float.parseFloat(cluster_detail_ram.getValue()));\n                StartAnswer startAnswer = null;\n\n                try {\n                    if (!changeState(vm, Event.OperationRetry, destHostId, work, Step.Prepare)) {\n                        throw new ConcurrentOperationException(\"Unable to update the state of the Virtual Machine \"+vm.getUuid()+\" oldstate: \"+vm.getState()+ \"Event :\"+Event.OperationRetry);\n                    }\n                } catch (final NoTransitionException e1) {\n                    throw new ConcurrentOperationException(e1.getMessage());\n                }\n\n                try {\n                    _networkMgr.prepare(vmProfile, new DeployDestination(dest.getDataCenter(), dest.getPod(), null, null, dest.getStorageForDisks()), ctx);\n                    if (vm.getHypervisorType() != HypervisorType.BareMetal) {\n                        volumeMgr.prepare(vmProfile, dest);\n                    }\n\n                    \r\n                    if (!reuseVolume) {\n                        reuseVolume = true;\n                    }\n\n                    Commands cmds = null;\n                    vmGuru.finalizeVirtualMachineProfile(vmProfile, dest, ctx);\n\n                    final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);\n\n                    handlePath(vmTO.getDisks(), vm.getHypervisorType());\n\n                    cmds = new Commands(Command.OnError.Stop);\n\n                    cmds.addCommand(new StartCommand(vmTO, dest.getHost(), getExecuteInSequence(vm.getHypervisorType())));\n\n                    vmGuru.finalizeDeployment(cmds, vmProfile, dest, ctx);\n\n                    \r\n                    addExtraConfig(vmTO);\n\n                    work = _workDao.findById(work.getId());\n                    if (work == null || work.getStep() != Step.Prepare) {\n                        throw new ConcurrentOperationException(\"Work steps have been changed: \" + work);\n                    }\n\n                    _workDao.updateStep(work, Step.Starting);\n\n                    _agentMgr.send(destHostId, cmds);\n\n                    _workDao.updateStep(work, Step.Started);\n\n                    startAnswer = cmds.getAnswer(StartAnswer.class);\n                    if (startAnswer != null && startAnswer.getResult()) {\n                        handlePath(vmTO.getDisks(), startAnswer.getIqnToData());\n\n                        final String host_guid = startAnswer.getHost_guid();\n\n                        if (host_guid != null) {\n                            final HostVO finalHost = _resourceMgr.findHostByGuid(host_guid);\n                            if (finalHost == null) {\n                                throw new CloudRuntimeException(\"Host Guid \" + host_guid + \" doesn't exist in DB, something went wrong while processing start answer: \"+startAnswer);\n                            }\n                            destHostId = finalHost.getId();\n                        }\n                        if (vmGuru.finalizeStart(vmProfile, destHostId, cmds, ctx)) {\n                            syncDiskChainChange(startAnswer);\n\n                            if (!changeState(vm, Event.OperationSucceeded, destHostId, work, Step.Done)) {\n                                s_logger.error(\"Unable to transition to a new state. VM uuid: \"+vm.getUuid()+    \"VM oldstate:\"+vm.getState()+\"Event:\"+Event.OperationSucceeded);\n                                throw new ConcurrentOperationException(\"Failed to deploy VM\"+ vm.getUuid());\n                            }\n\n                            \r\n                            final GPUDeviceTO gpuDevice = startAnswer.getVirtualMachine().getGpuDevice();\n                            if (gpuDevice != null) {\n                                _resourceMgr.updateGPUDetails(destHostId, gpuDevice.getGroupDetails());\n                            }\n\n                            \r\n                            \r\n                            \r\n                            if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.DEPLOY_VM) != null) {\n                                userVmDetailsDao.removeDetail(vm.getId(), VmDetailConstants.DEPLOY_VM);\n                            }\n\n                            startedVm = vm;\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Start completed for VM \" + vm);\n                            }\n                            final Host vmHost = _hostDao.findById(destHostId);\n                            if (vmHost != null && (VirtualMachine.Type.ConsoleProxy.equals(vm.getType()) ||\n                                    VirtualMachine.Type.SecondaryStorageVm.equals(vm.getType())) && caManager.canProvisionCertificates()) {\n                                final Map<String, String> sshAccessDetails = _networkMgr.getSystemVMAccessDetails(vm);\n                                for (int retries = 3; retries > 0; retries--) {\n                                    try {\n                                        setupAgentSecurity(vmHost, sshAccessDetails, vm);\n                                        return;\n                                    } catch (final Exception e) {\n                                        s_logger.error(\"Retrying after catching exception while trying to secure agent for systemvm id=\" + vm.getId(), e);\n                                    }\n                                }\n                                throw new CloudRuntimeException(\"Failed to setup and secure agent for systemvm id=\" + vm.getId());\n                            }\n                            return;\n                        } else {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.info(\"The guru did not like the answers so stopping \" + vm);\n                            }\n                            StopCommand stopCmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n                            stopCmd.setControlIp(getControlNicIpForVM(vm));\n                            final StopCommand cmd = stopCmd;\n                            final Answer answer = _agentMgr.easySend(destHostId, cmd);\n                            if (answer != null && answer instanceof StopAnswer) {\n                                final StopAnswer stopAns = (StopAnswer)answer;\n                                if (vm.getType() == VirtualMachine.Type.User) {\n                                    final String platform = stopAns.getPlatform();\n                                    if (platform != null) {\n                                        final Map<String,String> vmmetadata = new HashMap<String,String>();\n                                        vmmetadata.put(vm.getInstanceName(), platform);\n                                        syncVMMetaData(vmmetadata);\n                                    }\n                                }\n                            }\n\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.warn(\"Unable to stop \" + vm + \" due to \" + (answer != null ? answer.getDetails() : \"no answers\"));\n                                _haMgr.scheduleStop(vm, destHostId, WorkType.ForceStop);\n                                throw new ExecutionException(\"Unable to stop this VM, \"+vm.getUuid()+\" so we are unable to retry the start operation\");\n                            }\n                            throw new ExecutionException(\"Unable to start  VM:\"+vm.getUuid()+\" due to error in finalizeStart, not retrying\");\n                        }\n                    }\n                    s_logger.info(\"Unable to start VM on \" + dest.getHost() + \" due to \" + (startAnswer == null ? \" no start answer\" : startAnswer.getDetails()));\n                    if (startAnswer != null && startAnswer.getContextParam(\"stopRetry\") != null) {\n                        break;\n                    }\n\n                } catch (OperationTimedoutException e) {\n                    s_logger.debug(\"Unable to send the start command to host \" + dest.getHost()+\" failed to start VM: \"+vm.getUuid());\n                    if (e.isActive()) {\n                        _haMgr.scheduleStop(vm, destHostId, WorkType.CheckStop);\n                    }\n                    canRetry = false;\n                    throw new AgentUnavailableException(\"Unable to start \" + vm.getHostName(), destHostId, e);\n                } catch (final ResourceUnavailableException e) {\n                    s_logger.info(\"Unable to contact resource.\", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected ResourceUnavailableException : \" + e.getScope().getName(), e);\n                            throw e;\n                        }\n                    }\n                } catch (final InsufficientCapacityException e) {\n                    s_logger.info(\"Insufficient capacity \", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected InsufficientCapacityException : \" + e.getScope().getName(), e);\n                        }\n                    }\n                } catch (final ExecutionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final NoTransitionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } finally {\n                    if (startedVm == null && canRetry) {\n                        final Step prevStep = work.getStep();\n                        _workDao.updateStep(work, Step.Release);\n                        \r\n                        if ((prevStep == Step.Started || prevStep == Step.Starting) && startAnswer != null && startAnswer.getResult()) {  \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, false);\n                        } else {\n                            \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, true);\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (startedVm == null) {\n                if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n                    resourceCountDecrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n                }\n                if (canRetry) {\n                    try {\n                        changeState(vm, Event.OperationFailed, null, work, Step.Done);\n                    } catch (final NoTransitionException e) {\n                        throw new ConcurrentOperationException(e.getMessage());\n                    }\n                }\n            }\n\n            if (planToDeploy != null) {\n                planToDeploy.setAvoids(avoids);\n            }\n        }\n\n        if (startedVm == null) {\n            throw new CloudRuntimeException(\"Unable to start instance '\" + vm.getHostName() + \"' (\" + vm.getUuid() + \"), see management server log for details\");\n        }\n    }\n","date":"2020-01-30 17:36:50","endLine":1304,"groupId":"1093","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"orchestrateStart","params":"(finalStringvmUuid@finalMap<VirtualMachineProfile.Param@Object>params@finalDeploymentPlanplanToDeploy@finalDeploymentPlannerplanner)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/fe/dd3a38b5dc5139ef60e83436e6e4ee575e0e6c.src","preCode":"    public void orchestrateStart(final String vmUuid, final Map<VirtualMachineProfile.Param, Object> params, final DeploymentPlan planToDeploy, final DeploymentPlanner planner)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {\n\n        final CallContext cctxt = CallContext.current();\n        final Account account = cctxt.getCallingAccount();\n        final User caller = cctxt.getCallingUser();\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final Ternary<VMInstanceVO, ReservationContext, ItWorkVO> start = changeToStartState(vmGuru, vm, caller, account);\n        if (start == null) {\n            return;\n        }\n\n        vm = start.first();\n        final ReservationContext ctx = start.second();\n        ItWorkVO work = start.third();\n\n        VMInstanceVO startedVm = null;\n        final ServiceOfferingVO offering = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());\n        final VirtualMachineTemplate template = _entityMgr.findByIdIncludingRemoved(VirtualMachineTemplate.class, vm.getTemplateId());\n\n        DataCenterDeployment plan = new DataCenterDeployment(vm.getDataCenterId(), vm.getPodIdToDeployIn(), null, null, null, null, ctx);\n        if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"advanceStart: DeploymentPlan is provided, using dcId:\" + planToDeploy.getDataCenterId() + \", podId: \" + planToDeploy.getPodId() +\n                        \", clusterId: \" + planToDeploy.getClusterId() + \", hostId: \" + planToDeploy.getHostId() + \", poolId: \" + planToDeploy.getPoolId());\n            }\n            plan =\n                    new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(), planToDeploy.getHostId(),\n                            planToDeploy.getPoolId(), planToDeploy.getPhysicalNetworkId(), ctx);\n        }\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        boolean canRetry = true;\n        ExcludeList avoids = null;\n        try {\n            final Journal journal = start.second().getJournal();\n\n            if (planToDeploy != null) {\n                avoids = planToDeploy.getAvoids();\n            }\n            if (avoids == null) {\n                avoids = new ExcludeList();\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Deploy avoids pods: \" + avoids.getPodsToAvoid() + \", clusters: \" + avoids.getClustersToAvoid() + \", hosts: \" + avoids.getHostsToAvoid());\n            }\n\n            boolean planChangedByVolume = false;\n            boolean reuseVolume = true;\n            final DataCenterDeployment originalPlan = plan;\n\n            int retry = StartRetry.value();\n            while (retry-- != 0) { \r\n\n                if (reuseVolume) {\n                    \r\n                    final List<VolumeVO> vols = _volsDao.findReadyRootVolumesByInstance(vm.getId());\n                    for (final VolumeVO vol : vols) {\n                        \r\n                        \r\n                        \r\n                        final Long volTemplateId = vol.getTemplateId();\n                        if (volTemplateId != null && volTemplateId.longValue() != template.getId()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(vol + \" of \" + vm + \" is READY, but template ids don't match, let the planner reassign a new pool\");\n                            }\n                            continue;\n                        }\n\n                        final StoragePool pool = (StoragePool)dataStoreMgr.getPrimaryDataStore(vol.getPoolId());\n                        if (!pool.isInMaintenance()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Root volume is ready, need to place VM in volume's cluster\");\n                            }\n                            final long rootVolDcId = pool.getDataCenterId();\n                            final Long rootVolPodId = pool.getPodId();\n                            final Long rootVolClusterId = pool.getClusterId();\n                            if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n                                final Long clusterIdSpecified = planToDeploy.getClusterId();\n                                if (clusterIdSpecified != null && rootVolClusterId != null) {\n                                    if (rootVolClusterId.longValue() != clusterIdSpecified.longValue()) {\n                                        \r\n                                        \r\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"Cannot satisfy the deployment plan passed in since the ready Root volume is in different cluster. volume's cluster: \" +\n                                                    rootVolClusterId + \", cluster specified: \" + clusterIdSpecified);\n                                        }\n                                        throw new ResourceUnavailableException(\n                                                \"Root volume is ready in different cluster, Deployment plan provided cannot be satisfied, unable to create a deployment for \" +\n                                                        vm, Cluster.class, clusterIdSpecified);\n                                    }\n                                }\n                                plan =\n                                        new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(),\n                                                planToDeploy.getHostId(), vol.getPoolId(), null, ctx);\n                            } else {\n                                plan = new DataCenterDeployment(rootVolDcId, rootVolPodId, rootVolClusterId, null, vol.getPoolId(), null, ctx);\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(vol + \" is READY, changing deployment plan to use this pool's dcId: \" + rootVolDcId + \" , podId: \" + rootVolPodId +\n                                            \" , and clusterId: \" + rootVolClusterId);\n                                }\n                                planChangedByVolume = true;\n                            }\n                        }\n                    }\n                }\n\n                final Account owner = _entityMgr.findById(Account.class, vm.getAccountId());\n                final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vm, template, offering, owner, params);\n                DeployDestination dest = null;\n                try {\n                    dest = _dpMgr.planDeployment(vmProfile, plan, avoids, planner);\n                } catch (final AffinityConflictException e2) {\n                    s_logger.warn(\"Unable to create deployment, affinity rules associted to the VM conflict\", e2);\n                    throw new CloudRuntimeException(\"Unable to create deployment, affinity rules associted to the VM conflict\");\n\n                }\n\n                if (dest == null) {\n                    if (planChangedByVolume) {\n                        plan = originalPlan;\n                        planChangedByVolume = false;\n                        \r\n                        reuseVolume = false;\n                        continue;\n                    }\n                    throw new InsufficientServerCapacityException(\"Unable to create a deployment for \" + vmProfile, DataCenter.class, plan.getDataCenterId(),\n                            areAffinityGroupsAssociated(vmProfile));\n                }\n\n                if (dest != null) {\n                    avoids.addHost(dest.getHost().getId());\n                    journal.record(\"Deployment found \", vmProfile, dest);\n                }\n\n                long destHostId = dest.getHost().getId();\n                vm.setPodIdToDeployIn(dest.getPod().getId());\n                final Long cluster_id = dest.getCluster().getId();\n                final ClusterDetailsVO cluster_detail_cpu = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                final ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                \r\n                if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) == null &&\n                        (Float.parseFloat(cluster_detail_cpu.getValue()) > 1f || Float.parseFloat(cluster_detail_ram.getValue()) > 1f)) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                } else if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) != null) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                }\n\n                vmProfile.setCpuOvercommitRatio(Float.parseFloat(cluster_detail_cpu.getValue()));\n                vmProfile.setMemoryOvercommitRatio(Float.parseFloat(cluster_detail_ram.getValue()));\n                StartAnswer startAnswer = null;\n\n                try {\n                    if (!changeState(vm, Event.OperationRetry, destHostId, work, Step.Prepare)) {\n                        throw new ConcurrentOperationException(\"Unable to update the state of the Virtual Machine \"+vm.getUuid()+\" oldstate: \"+vm.getState()+ \"Event :\"+Event.OperationRetry);\n                    }\n                } catch (final NoTransitionException e1) {\n                    throw new ConcurrentOperationException(e1.getMessage());\n                }\n\n                try {\n                    _networkMgr.prepare(vmProfile, new DeployDestination(dest.getDataCenter(), dest.getPod(), null, null, dest.getStorageForDisks()), ctx);\n                    if (vm.getHypervisorType() != HypervisorType.BareMetal) {\n                        volumeMgr.prepare(vmProfile, dest);\n                    }\n\n                    \r\n                    if (!reuseVolume) {\n                        reuseVolume = true;\n                    }\n\n                    Commands cmds = null;\n                    vmGuru.finalizeVirtualMachineProfile(vmProfile, dest, ctx);\n\n                    final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);\n\n                    handlePath(vmTO.getDisks(), vm.getHypervisorType());\n\n                    cmds = new Commands(Command.OnError.Stop);\n\n                    cmds.addCommand(new StartCommand(vmTO, dest.getHost(), getExecuteInSequence(vm.getHypervisorType())));\n\n                    vmGuru.finalizeDeployment(cmds, vmProfile, dest, ctx);\n\n                    \r\n                    addExtraConfig(vmTO);\n\n                    work = _workDao.findById(work.getId());\n                    if (work == null || work.getStep() != Step.Prepare) {\n                        throw new ConcurrentOperationException(\"Work steps have been changed: \" + work);\n                    }\n\n                    _workDao.updateStep(work, Step.Starting);\n\n                    _agentMgr.send(destHostId, cmds);\n\n                    _workDao.updateStep(work, Step.Started);\n\n                    startAnswer = cmds.getAnswer(StartAnswer.class);\n                    if (startAnswer != null && startAnswer.getResult()) {\n                        handlePath(vmTO.getDisks(), startAnswer.getIqnToData());\n\n                        final String host_guid = startAnswer.getHost_guid();\n\n                        if (host_guid != null) {\n                            final HostVO finalHost = _resourceMgr.findHostByGuid(host_guid);\n                            if (finalHost == null) {\n                                throw new CloudRuntimeException(\"Host Guid \" + host_guid + \" doesn't exist in DB, something went wrong while processing start answer: \"+startAnswer);\n                            }\n                            destHostId = finalHost.getId();\n                        }\n                        if (vmGuru.finalizeStart(vmProfile, destHostId, cmds, ctx)) {\n                            syncDiskChainChange(startAnswer);\n\n                            if (!changeState(vm, Event.OperationSucceeded, destHostId, work, Step.Done)) {\n                                s_logger.error(\"Unable to transition to a new state. VM uuid: \"+vm.getUuid()+    \"VM oldstate:\"+vm.getState()+\"Event:\"+Event.OperationSucceeded);\n                                throw new ConcurrentOperationException(\"Failed to deploy VM\"+ vm.getUuid());\n                            }\n\n                            \r\n                            final GPUDeviceTO gpuDevice = startAnswer.getVirtualMachine().getGpuDevice();\n                            if (gpuDevice != null) {\n                                _resourceMgr.updateGPUDetails(destHostId, gpuDevice.getGroupDetails());\n                            }\n\n                            \r\n                            \r\n                            \r\n                            if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.DEPLOY_VM) != null) {\n                                userVmDetailsDao.removeDetail(vm.getId(), VmDetailConstants.DEPLOY_VM);\n                            }\n\n                            startedVm = vm;\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Start completed for VM \" + vm);\n                            }\n                            final Host vmHost = _hostDao.findById(destHostId);\n                            if (vmHost != null && (VirtualMachine.Type.ConsoleProxy.equals(vm.getType()) ||\n                                    VirtualMachine.Type.SecondaryStorageVm.equals(vm.getType())) && caManager.canProvisionCertificates()) {\n                                final Map<String, String> sshAccessDetails = _networkMgr.getSystemVMAccessDetails(vm);\n                                for (int retries = 3; retries > 0; retries--) {\n                                    try {\n                                        setupAgentSecurity(vmHost, sshAccessDetails, vm);\n                                        return;\n                                    } catch (final Exception e) {\n                                        s_logger.error(\"Retrying after catching exception while trying to secure agent for systemvm id=\" + vm.getId(), e);\n                                    }\n                                }\n                                throw new CloudRuntimeException(\"Failed to setup and secure agent for systemvm id=\" + vm.getId());\n                            }\n                            return;\n                        } else {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.info(\"The guru did not like the answers so stopping \" + vm);\n                            }\n                            StopCommand stopCmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n                            stopCmd.setControlIp(getControlNicIpForVM(vm));\n                            final StopCommand cmd = stopCmd;\n                            final Answer answer = _agentMgr.easySend(destHostId, cmd);\n                            if (answer != null && answer instanceof StopAnswer) {\n                                final StopAnswer stopAns = (StopAnswer)answer;\n                                if (vm.getType() == VirtualMachine.Type.User) {\n                                    final String platform = stopAns.getPlatform();\n                                    if (platform != null) {\n                                        final Map<String,String> vmmetadata = new HashMap<String,String>();\n                                        vmmetadata.put(vm.getInstanceName(), platform);\n                                        syncVMMetaData(vmmetadata);\n                                    }\n                                }\n                            }\n\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.warn(\"Unable to stop \" + vm + \" due to \" + (answer != null ? answer.getDetails() : \"no answers\"));\n                                _haMgr.scheduleStop(vm, destHostId, WorkType.ForceStop);\n                                throw new ExecutionException(\"Unable to stop this VM, \"+vm.getUuid()+\" so we are unable to retry the start operation\");\n                            }\n                            throw new ExecutionException(\"Unable to start  VM:\"+vm.getUuid()+\" due to error in finalizeStart, not retrying\");\n                        }\n                    }\n                    s_logger.info(\"Unable to start VM on \" + dest.getHost() + \" due to \" + (startAnswer == null ? \" no start answer\" : startAnswer.getDetails()));\n                    if (startAnswer != null && startAnswer.getContextParam(\"stopRetry\") != null) {\n                        break;\n                    }\n\n                } catch (OperationTimedoutException e) {\n                    s_logger.debug(\"Unable to send the start command to host \" + dest.getHost()+\" failed to start VM: \"+vm.getUuid());\n                    if (e.isActive()) {\n                        _haMgr.scheduleStop(vm, destHostId, WorkType.CheckStop);\n                    }\n                    canRetry = false;\n                    throw new AgentUnavailableException(\"Unable to start \" + vm.getHostName(), destHostId, e);\n                } catch (final ResourceUnavailableException e) {\n                    s_logger.info(\"Unable to contact resource.\", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected ResourceUnavailableException : \" + e.getScope().getName(), e);\n                            throw e;\n                        }\n                    }\n                } catch (final InsufficientCapacityException e) {\n                    s_logger.info(\"Insufficient capacity \", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected InsufficientCapacityException : \" + e.getScope().getName(), e);\n                        }\n                    }\n                } catch (final ExecutionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final NoTransitionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } finally {\n                    if (startedVm == null && canRetry) {\n                        final Step prevStep = work.getStep();\n                        _workDao.updateStep(work, Step.Release);\n                        \r\n                        if ((prevStep == Step.Started || prevStep == Step.Starting) && startAnswer != null && startAnswer.getResult()) {  \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, false);\n                        } else {\n                            \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, true);\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (startedVm == null) {\n                if (canRetry) {\n                    try {\n                        changeState(vm, Event.OperationFailed, null, work, Step.Done);\n                    } catch (final NoTransitionException e) {\n                        throw new ConcurrentOperationException(e.getMessage());\n                    }\n                }\n            }\n\n            if (planToDeploy != null) {\n                planToDeploy.setAvoids(avoids);\n            }\n        }\n\n        if (startedVm == null) {\n            throw new CloudRuntimeException(\"Unable to start instance '\" + vm.getHostName() + \"' (\" + vm.getUuid() + \"), see management server log for details\");\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":940,"status":"M"},{"authorDate":"2019-06-25 23:23:09","commitOrder":8,"curCode":"    public Command cleanup(final VirtualMachine vm, Map<String, DpdkTO> dpdkInterfaceMapping) {\n        StopCommand cmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n        cmd.setControlIp(getControlNicIpForVM(vm));\n        if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n            cmd.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n        }\n        return cmd;\n    }\n","date":"2019-06-25 23:23:09","endLine":3112,"groupId":"25415","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"cleanup","params":"(finalVirtualMachinevm@Map<String@DpdkTO>dpdkInterfaceMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/79/5705345962a468ec5b626e71be73e2c2815950.src","preCode":"    public Command cleanup(final VirtualMachine vm, Map<String, DpdkTO> dpdkInterfaceMapping) {\n        StopCommand cmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n        cmd.setControlIp(getControlNicIpForVM(vm));\n        if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n            cmd.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n        }\n        return cmd;\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":3105,"status":"N"}],"commitId":"ac581d1546750a6ffc49ebab180e1b80bec4319e","commitMessage":"@@@New feature: Resource count (CPU/RAM) take only running vms into calculation (#3760)\n\n* marvin: check resource count of more types\n\n* New feature: add flag resource.count.running.vms.only to count resource consumption of only running vms\n\nStopped VMs do not use CPU/RAM actually.\nA new global configuration resource.count.running.vms.only is added to determine whether resource (cpu/memory) of only running vms (including Starting/Stopping) will be taken into calculation of resource consumption.\n\n* Add integration test for resource count of only running vms\n","date":"2020-01-30 17:36:50","modifiedFileCount":"11","status":"M","submitter":"Wei Zhou"},{"authorTime":"2019-06-25 23:23:09","codes":[{"authorDate":"2020-03-14 03:56:26","commitOrder":9,"curCode":"    public void orchestrateStart(final String vmUuid, final Map<VirtualMachineProfile.Param, Object> params, final DeploymentPlan planToDeploy, final DeploymentPlanner planner)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {\n\n        final CallContext cctxt = CallContext.current();\n        final Account account = cctxt.getCallingAccount();\n        final User caller = cctxt.getCallingUser();\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final Ternary<VMInstanceVO, ReservationContext, ItWorkVO> start = changeToStartState(vmGuru, vm, caller, account);\n        if (start == null) {\n            return;\n        }\n\n        vm = start.first();\n        final ReservationContext ctx = start.second();\n        ItWorkVO work = start.third();\n\n        VMInstanceVO startedVm = null;\n        final ServiceOfferingVO offering = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());\n        final VirtualMachineTemplate template = _entityMgr.findByIdIncludingRemoved(VirtualMachineTemplate.class, vm.getTemplateId());\n\n        DataCenterDeployment plan = new DataCenterDeployment(vm.getDataCenterId(), vm.getPodIdToDeployIn(), null, null, null, null, ctx);\n        if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"advanceStart: DeploymentPlan is provided, using dcId:\" + planToDeploy.getDataCenterId() + \", podId: \" + planToDeploy.getPodId() +\n                        \", clusterId: \" + planToDeploy.getClusterId() + \", hostId: \" + planToDeploy.getHostId() + \", poolId: \" + planToDeploy.getPoolId());\n            }\n            plan =\n                    new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(), planToDeploy.getHostId(),\n                            planToDeploy.getPoolId(), planToDeploy.getPhysicalNetworkId(), ctx);\n        }\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        \r\n        final Account owner = _entityMgr.findById(Account.class, vm.getAccountId());\n        if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n            resourceCountIncrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n        }\n\n        boolean canRetry = true;\n        ExcludeList avoids = null;\n        try {\n            final Journal journal = start.second().getJournal();\n\n            if (planToDeploy != null) {\n                avoids = planToDeploy.getAvoids();\n            }\n            if (avoids == null) {\n                avoids = new ExcludeList();\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Deploy avoids pods: \" + avoids.getPodsToAvoid() + \", clusters: \" + avoids.getClustersToAvoid() + \", hosts: \" + avoids.getHostsToAvoid());\n            }\n\n            boolean planChangedByVolume = false;\n            boolean reuseVolume = true;\n            final DataCenterDeployment originalPlan = plan;\n\n            int retry = StartRetry.value();\n            while (retry-- != 0) { \r\n\n                if (reuseVolume) {\n                    \r\n                    final List<VolumeVO> vols = _volsDao.findReadyRootVolumesByInstance(vm.getId());\n                    for (final VolumeVO vol : vols) {\n                        \r\n                        \r\n                        \r\n                        final Long volTemplateId = vol.getTemplateId();\n                        if (volTemplateId != null && volTemplateId.longValue() != template.getId()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(vol + \" of \" + vm + \" is READY, but template ids don't match, let the planner reassign a new pool\");\n                            }\n                            continue;\n                        }\n\n                        final StoragePool pool = (StoragePool)dataStoreMgr.getPrimaryDataStore(vol.getPoolId());\n                        if (!pool.isInMaintenance()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Root volume is ready, need to place VM in volume's cluster\");\n                            }\n                            final long rootVolDcId = pool.getDataCenterId();\n                            final Long rootVolPodId = pool.getPodId();\n                            final Long rootVolClusterId = pool.getClusterId();\n                            if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n                                final Long clusterIdSpecified = planToDeploy.getClusterId();\n                                if (clusterIdSpecified != null && rootVolClusterId != null) {\n                                    if (rootVolClusterId.longValue() != clusterIdSpecified.longValue()) {\n                                        \r\n                                        \r\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"Cannot satisfy the deployment plan passed in since the ready Root volume is in different cluster. volume's cluster: \" +\n                                                    rootVolClusterId + \", cluster specified: \" + clusterIdSpecified);\n                                        }\n                                        throw new ResourceUnavailableException(\n                                                \"Root volume is ready in different cluster, Deployment plan provided cannot be satisfied, unable to create a deployment for \" +\n                                                        vm, Cluster.class, clusterIdSpecified);\n                                    }\n                                }\n                                plan =\n                                        new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(),\n                                                planToDeploy.getHostId(), vol.getPoolId(), null, ctx);\n                            } else {\n                                plan = new DataCenterDeployment(rootVolDcId, rootVolPodId, rootVolClusterId, null, vol.getPoolId(), null, ctx);\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(vol + \" is READY, changing deployment plan to use this pool's dcId: \" + rootVolDcId + \" , podId: \" + rootVolPodId +\n                                            \" , and clusterId: \" + rootVolClusterId);\n                                }\n                                planChangedByVolume = true;\n                            }\n                        }\n                    }\n                }\n\n                final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vm, template, offering, owner, params);\n                s_logger.info(\" Uefi params \" + \"UefiFlag: \" + params.get(VirtualMachineProfile.Param.UefiFlag)\n                        + \" Boot Type: \" + params.get(VirtualMachineProfile.Param.BootType)\n                        + \" Boot Mode: \" + params.get(VirtualMachineProfile.Param.BootMode)\n                );\n                DeployDestination dest = null;\n                try {\n                    dest = _dpMgr.planDeployment(vmProfile, plan, avoids, planner);\n                } catch (final AffinityConflictException e2) {\n                    s_logger.warn(\"Unable to create deployment, affinity rules associted to the VM conflict\", e2);\n                    throw new CloudRuntimeException(\"Unable to create deployment, affinity rules associted to the VM conflict\");\n\n                }\n\n                if (dest == null) {\n                    if (planChangedByVolume) {\n                        plan = originalPlan;\n                        planChangedByVolume = false;\n                        \r\n                        reuseVolume = false;\n                        continue;\n                    }\n                    throw new InsufficientServerCapacityException(\"Unable to create a deployment for \" + vmProfile, DataCenter.class, plan.getDataCenterId(),\n                            areAffinityGroupsAssociated(vmProfile));\n                }\n\n                if (dest != null) {\n                    avoids.addHost(dest.getHost().getId());\n                    journal.record(\"Deployment found \", vmProfile, dest);\n                }\n\n                long destHostId = dest.getHost().getId();\n                vm.setPodIdToDeployIn(dest.getPod().getId());\n                final Long cluster_id = dest.getCluster().getId();\n                final ClusterDetailsVO cluster_detail_cpu = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                final ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                \r\n                if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) == null &&\n                        (Float.parseFloat(cluster_detail_cpu.getValue()) > 1f || Float.parseFloat(cluster_detail_ram.getValue()) > 1f)) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                } else if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) != null) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                }\n\n                vmProfile.setCpuOvercommitRatio(Float.parseFloat(cluster_detail_cpu.getValue()));\n                vmProfile.setMemoryOvercommitRatio(Float.parseFloat(cluster_detail_ram.getValue()));\n                StartAnswer startAnswer = null;\n\n                try {\n                    if (!changeState(vm, Event.OperationRetry, destHostId, work, Step.Prepare)) {\n                        throw new ConcurrentOperationException(\"Unable to update the state of the Virtual Machine \"+vm.getUuid()+\" oldstate: \"+vm.getState()+ \"Event :\"+Event.OperationRetry);\n                    }\n                } catch (final NoTransitionException e1) {\n                    throw new ConcurrentOperationException(e1.getMessage());\n                }\n\n                try {\n                    _networkMgr.prepare(vmProfile, new DeployDestination(dest.getDataCenter(), dest.getPod(), null, null, dest.getStorageForDisks()), ctx);\n                    if (vm.getHypervisorType() != HypervisorType.BareMetal) {\n                        volumeMgr.prepare(vmProfile, dest);\n                    }\n\n                    \r\n                    if (!reuseVolume) {\n                        reuseVolume = true;\n                    }\n\n                    Commands cmds = null;\n                    vmGuru.finalizeVirtualMachineProfile(vmProfile, dest, ctx);\n\n                    final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);\n\n                    handlePath(vmTO.getDisks(), vm.getHypervisorType());\n\n                    cmds = new Commands(Command.OnError.Stop);\n\n                    cmds.addCommand(new StartCommand(vmTO, dest.getHost(), getExecuteInSequence(vm.getHypervisorType())));\n\n                    vmGuru.finalizeDeployment(cmds, vmProfile, dest, ctx);\n\n                    \r\n                    addExtraConfig(vmTO);\n\n                    work = _workDao.findById(work.getId());\n                    if (work == null || work.getStep() != Step.Prepare) {\n                        throw new ConcurrentOperationException(\"Work steps have been changed: \" + work);\n                    }\n\n                    _workDao.updateStep(work, Step.Starting);\n\n                    _agentMgr.send(destHostId, cmds);\n\n                    _workDao.updateStep(work, Step.Started);\n\n                    startAnswer = cmds.getAnswer(StartAnswer.class);\n                    if (startAnswer != null && startAnswer.getResult()) {\n                        handlePath(vmTO.getDisks(), startAnswer.getIqnToData());\n\n                        final String host_guid = startAnswer.getHost_guid();\n\n                        if (host_guid != null) {\n                            final HostVO finalHost = _resourceMgr.findHostByGuid(host_guid);\n                            if (finalHost == null) {\n                                throw new CloudRuntimeException(\"Host Guid \" + host_guid + \" doesn't exist in DB, something went wrong while processing start answer: \"+startAnswer);\n                            }\n                            destHostId = finalHost.getId();\n                        }\n                        if (vmGuru.finalizeStart(vmProfile, destHostId, cmds, ctx)) {\n                            syncDiskChainChange(startAnswer);\n\n                            if (!changeState(vm, Event.OperationSucceeded, destHostId, work, Step.Done)) {\n                                s_logger.error(\"Unable to transition to a new state. VM uuid: \"+vm.getUuid()+    \"VM oldstate:\"+vm.getState()+\"Event:\"+Event.OperationSucceeded);\n                                throw new ConcurrentOperationException(\"Failed to deploy VM\"+ vm.getUuid());\n                            }\n\n                            \r\n                            final GPUDeviceTO gpuDevice = startAnswer.getVirtualMachine().getGpuDevice();\n                            if (gpuDevice != null) {\n                                _resourceMgr.updateGPUDetails(destHostId, gpuDevice.getGroupDetails());\n                            }\n\n                            \r\n                            \r\n                            \r\n                            if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.DEPLOY_VM) != null) {\n                                userVmDetailsDao.removeDetail(vm.getId(), VmDetailConstants.DEPLOY_VM);\n                            }\n\n                            startedVm = vm;\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Start completed for VM \" + vm);\n                            }\n                            final Host vmHost = _hostDao.findById(destHostId);\n                            if (vmHost != null && (VirtualMachine.Type.ConsoleProxy.equals(vm.getType()) ||\n                                    VirtualMachine.Type.SecondaryStorageVm.equals(vm.getType())) && caManager.canProvisionCertificates()) {\n                                final Map<String, String> sshAccessDetails = _networkMgr.getSystemVMAccessDetails(vm);\n                                for (int retries = 3; retries > 0; retries--) {\n                                    try {\n                                        setupAgentSecurity(vmHost, sshAccessDetails, vm);\n                                        return;\n                                    } catch (final Exception e) {\n                                        s_logger.error(\"Retrying after catching exception while trying to secure agent for systemvm id=\" + vm.getId(), e);\n                                    }\n                                }\n                                throw new CloudRuntimeException(\"Failed to setup and secure agent for systemvm id=\" + vm.getId());\n                            }\n                            return;\n                        } else {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.info(\"The guru did not like the answers so stopping \" + vm);\n                            }\n                            StopCommand stopCmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n                            stopCmd.setControlIp(getControlNicIpForVM(vm));\n                            final StopCommand cmd = stopCmd;\n                            final Answer answer = _agentMgr.easySend(destHostId, cmd);\n                            if (answer != null && answer instanceof StopAnswer) {\n                                final StopAnswer stopAns = (StopAnswer)answer;\n                                if (vm.getType() == VirtualMachine.Type.User) {\n                                    final String platform = stopAns.getPlatform();\n                                    if (platform != null) {\n                                        final Map<String,String> vmmetadata = new HashMap<String,String>();\n                                        vmmetadata.put(vm.getInstanceName(), platform);\n                                        syncVMMetaData(vmmetadata);\n                                    }\n                                }\n                            }\n\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.warn(\"Unable to stop \" + vm + \" due to \" + (answer != null ? answer.getDetails() : \"no answers\"));\n                                _haMgr.scheduleStop(vm, destHostId, WorkType.ForceStop);\n                                throw new ExecutionException(\"Unable to stop this VM, \"+vm.getUuid()+\" so we are unable to retry the start operation\");\n                            }\n                            throw new ExecutionException(\"Unable to start  VM:\"+vm.getUuid()+\" due to error in finalizeStart, not retrying\");\n                        }\n                    }\n                    s_logger.info(\"Unable to start VM on \" + dest.getHost() + \" due to \" + (startAnswer == null ? \" no start answer\" : startAnswer.getDetails()));\n                    if (startAnswer != null && startAnswer.getContextParam(\"stopRetry\") != null) {\n                        break;\n                    }\n\n                } catch (OperationTimedoutException e) {\n                    s_logger.debug(\"Unable to send the start command to host \" + dest.getHost()+\" failed to start VM: \"+vm.getUuid());\n                    if (e.isActive()) {\n                        _haMgr.scheduleStop(vm, destHostId, WorkType.CheckStop);\n                    }\n                    canRetry = false;\n                    throw new AgentUnavailableException(\"Unable to start \" + vm.getHostName(), destHostId, e);\n                } catch (final ResourceUnavailableException e) {\n                    s_logger.info(\"Unable to contact resource.\", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected ResourceUnavailableException : \" + e.getScope().getName(), e);\n                            throw e;\n                        }\n                    }\n                } catch (final InsufficientCapacityException e) {\n                    s_logger.info(\"Insufficient capacity \", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected InsufficientCapacityException : \" + e.getScope().getName(), e);\n                        }\n                    }\n                } catch (final ExecutionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final NoTransitionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } finally {\n                    if (startedVm == null && canRetry) {\n                        final Step prevStep = work.getStep();\n                        _workDao.updateStep(work, Step.Release);\n                        \r\n                        if ((prevStep == Step.Started || prevStep == Step.Starting) && startAnswer != null && startAnswer.getResult()) {  \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, false);\n                        } else {\n                            \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, true);\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (startedVm == null) {\n                if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n                    resourceCountDecrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n                }\n                if (canRetry) {\n                    try {\n                        changeState(vm, Event.OperationFailed, null, work, Step.Done);\n                    } catch (final NoTransitionException e) {\n                        throw new ConcurrentOperationException(e.getMessage());\n                    }\n                }\n            }\n\n            if (planToDeploy != null) {\n                planToDeploy.setAvoids(avoids);\n            }\n        }\n\n        if (startedVm == null) {\n            throw new CloudRuntimeException(\"Unable to start instance '\" + vm.getHostName() + \"' (\" + vm.getUuid() + \"), see management server log for details\");\n        }\n    }\n","date":"2020-03-14 03:56:26","endLine":1316,"groupId":"12069","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"orchestrateStart","params":"(finalStringvmUuid@finalMap<VirtualMachineProfile.Param@Object>params@finalDeploymentPlanplanToDeploy@finalDeploymentPlannerplanner)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/88/17efbeaedc41890c3ebed5cb5ae3adb295142a.src","preCode":"    public void orchestrateStart(final String vmUuid, final Map<VirtualMachineProfile.Param, Object> params, final DeploymentPlan planToDeploy, final DeploymentPlanner planner)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {\n\n        final CallContext cctxt = CallContext.current();\n        final Account account = cctxt.getCallingAccount();\n        final User caller = cctxt.getCallingUser();\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final Ternary<VMInstanceVO, ReservationContext, ItWorkVO> start = changeToStartState(vmGuru, vm, caller, account);\n        if (start == null) {\n            return;\n        }\n\n        vm = start.first();\n        final ReservationContext ctx = start.second();\n        ItWorkVO work = start.third();\n\n        VMInstanceVO startedVm = null;\n        final ServiceOfferingVO offering = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());\n        final VirtualMachineTemplate template = _entityMgr.findByIdIncludingRemoved(VirtualMachineTemplate.class, vm.getTemplateId());\n\n        DataCenterDeployment plan = new DataCenterDeployment(vm.getDataCenterId(), vm.getPodIdToDeployIn(), null, null, null, null, ctx);\n        if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"advanceStart: DeploymentPlan is provided, using dcId:\" + planToDeploy.getDataCenterId() + \", podId: \" + planToDeploy.getPodId() +\n                        \", clusterId: \" + planToDeploy.getClusterId() + \", hostId: \" + planToDeploy.getHostId() + \", poolId: \" + planToDeploy.getPoolId());\n            }\n            plan =\n                    new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(), planToDeploy.getHostId(),\n                            planToDeploy.getPoolId(), planToDeploy.getPhysicalNetworkId(), ctx);\n        }\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        \r\n        final Account owner = _entityMgr.findById(Account.class, vm.getAccountId());\n        if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n            resourceCountIncrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n        }\n\n        boolean canRetry = true;\n        ExcludeList avoids = null;\n        try {\n            final Journal journal = start.second().getJournal();\n\n            if (planToDeploy != null) {\n                avoids = planToDeploy.getAvoids();\n            }\n            if (avoids == null) {\n                avoids = new ExcludeList();\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Deploy avoids pods: \" + avoids.getPodsToAvoid() + \", clusters: \" + avoids.getClustersToAvoid() + \", hosts: \" + avoids.getHostsToAvoid());\n            }\n\n            boolean planChangedByVolume = false;\n            boolean reuseVolume = true;\n            final DataCenterDeployment originalPlan = plan;\n\n            int retry = StartRetry.value();\n            while (retry-- != 0) { \r\n\n                if (reuseVolume) {\n                    \r\n                    final List<VolumeVO> vols = _volsDao.findReadyRootVolumesByInstance(vm.getId());\n                    for (final VolumeVO vol : vols) {\n                        \r\n                        \r\n                        \r\n                        final Long volTemplateId = vol.getTemplateId();\n                        if (volTemplateId != null && volTemplateId.longValue() != template.getId()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(vol + \" of \" + vm + \" is READY, but template ids don't match, let the planner reassign a new pool\");\n                            }\n                            continue;\n                        }\n\n                        final StoragePool pool = (StoragePool)dataStoreMgr.getPrimaryDataStore(vol.getPoolId());\n                        if (!pool.isInMaintenance()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Root volume is ready, need to place VM in volume's cluster\");\n                            }\n                            final long rootVolDcId = pool.getDataCenterId();\n                            final Long rootVolPodId = pool.getPodId();\n                            final Long rootVolClusterId = pool.getClusterId();\n                            if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n                                final Long clusterIdSpecified = planToDeploy.getClusterId();\n                                if (clusterIdSpecified != null && rootVolClusterId != null) {\n                                    if (rootVolClusterId.longValue() != clusterIdSpecified.longValue()) {\n                                        \r\n                                        \r\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"Cannot satisfy the deployment plan passed in since the ready Root volume is in different cluster. volume's cluster: \" +\n                                                    rootVolClusterId + \", cluster specified: \" + clusterIdSpecified);\n                                        }\n                                        throw new ResourceUnavailableException(\n                                                \"Root volume is ready in different cluster, Deployment plan provided cannot be satisfied, unable to create a deployment for \" +\n                                                        vm, Cluster.class, clusterIdSpecified);\n                                    }\n                                }\n                                plan =\n                                        new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(),\n                                                planToDeploy.getHostId(), vol.getPoolId(), null, ctx);\n                            } else {\n                                plan = new DataCenterDeployment(rootVolDcId, rootVolPodId, rootVolClusterId, null, vol.getPoolId(), null, ctx);\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(vol + \" is READY, changing deployment plan to use this pool's dcId: \" + rootVolDcId + \" , podId: \" + rootVolPodId +\n                                            \" , and clusterId: \" + rootVolClusterId);\n                                }\n                                planChangedByVolume = true;\n                            }\n                        }\n                    }\n                }\n\n                final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vm, template, offering, owner, params);\n                DeployDestination dest = null;\n                try {\n                    dest = _dpMgr.planDeployment(vmProfile, plan, avoids, planner);\n                } catch (final AffinityConflictException e2) {\n                    s_logger.warn(\"Unable to create deployment, affinity rules associted to the VM conflict\", e2);\n                    throw new CloudRuntimeException(\"Unable to create deployment, affinity rules associted to the VM conflict\");\n\n                }\n\n                if (dest == null) {\n                    if (planChangedByVolume) {\n                        plan = originalPlan;\n                        planChangedByVolume = false;\n                        \r\n                        reuseVolume = false;\n                        continue;\n                    }\n                    throw new InsufficientServerCapacityException(\"Unable to create a deployment for \" + vmProfile, DataCenter.class, plan.getDataCenterId(),\n                            areAffinityGroupsAssociated(vmProfile));\n                }\n\n                if (dest != null) {\n                    avoids.addHost(dest.getHost().getId());\n                    journal.record(\"Deployment found \", vmProfile, dest);\n                }\n\n                long destHostId = dest.getHost().getId();\n                vm.setPodIdToDeployIn(dest.getPod().getId());\n                final Long cluster_id = dest.getCluster().getId();\n                final ClusterDetailsVO cluster_detail_cpu = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                final ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                \r\n                if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) == null &&\n                        (Float.parseFloat(cluster_detail_cpu.getValue()) > 1f || Float.parseFloat(cluster_detail_ram.getValue()) > 1f)) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                } else if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) != null) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                }\n\n                vmProfile.setCpuOvercommitRatio(Float.parseFloat(cluster_detail_cpu.getValue()));\n                vmProfile.setMemoryOvercommitRatio(Float.parseFloat(cluster_detail_ram.getValue()));\n                StartAnswer startAnswer = null;\n\n                try {\n                    if (!changeState(vm, Event.OperationRetry, destHostId, work, Step.Prepare)) {\n                        throw new ConcurrentOperationException(\"Unable to update the state of the Virtual Machine \"+vm.getUuid()+\" oldstate: \"+vm.getState()+ \"Event :\"+Event.OperationRetry);\n                    }\n                } catch (final NoTransitionException e1) {\n                    throw new ConcurrentOperationException(e1.getMessage());\n                }\n\n                try {\n                    _networkMgr.prepare(vmProfile, new DeployDestination(dest.getDataCenter(), dest.getPod(), null, null, dest.getStorageForDisks()), ctx);\n                    if (vm.getHypervisorType() != HypervisorType.BareMetal) {\n                        volumeMgr.prepare(vmProfile, dest);\n                    }\n\n                    \r\n                    if (!reuseVolume) {\n                        reuseVolume = true;\n                    }\n\n                    Commands cmds = null;\n                    vmGuru.finalizeVirtualMachineProfile(vmProfile, dest, ctx);\n\n                    final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);\n\n                    handlePath(vmTO.getDisks(), vm.getHypervisorType());\n\n                    cmds = new Commands(Command.OnError.Stop);\n\n                    cmds.addCommand(new StartCommand(vmTO, dest.getHost(), getExecuteInSequence(vm.getHypervisorType())));\n\n                    vmGuru.finalizeDeployment(cmds, vmProfile, dest, ctx);\n\n                    \r\n                    addExtraConfig(vmTO);\n\n                    work = _workDao.findById(work.getId());\n                    if (work == null || work.getStep() != Step.Prepare) {\n                        throw new ConcurrentOperationException(\"Work steps have been changed: \" + work);\n                    }\n\n                    _workDao.updateStep(work, Step.Starting);\n\n                    _agentMgr.send(destHostId, cmds);\n\n                    _workDao.updateStep(work, Step.Started);\n\n                    startAnswer = cmds.getAnswer(StartAnswer.class);\n                    if (startAnswer != null && startAnswer.getResult()) {\n                        handlePath(vmTO.getDisks(), startAnswer.getIqnToData());\n\n                        final String host_guid = startAnswer.getHost_guid();\n\n                        if (host_guid != null) {\n                            final HostVO finalHost = _resourceMgr.findHostByGuid(host_guid);\n                            if (finalHost == null) {\n                                throw new CloudRuntimeException(\"Host Guid \" + host_guid + \" doesn't exist in DB, something went wrong while processing start answer: \"+startAnswer);\n                            }\n                            destHostId = finalHost.getId();\n                        }\n                        if (vmGuru.finalizeStart(vmProfile, destHostId, cmds, ctx)) {\n                            syncDiskChainChange(startAnswer);\n\n                            if (!changeState(vm, Event.OperationSucceeded, destHostId, work, Step.Done)) {\n                                s_logger.error(\"Unable to transition to a new state. VM uuid: \"+vm.getUuid()+    \"VM oldstate:\"+vm.getState()+\"Event:\"+Event.OperationSucceeded);\n                                throw new ConcurrentOperationException(\"Failed to deploy VM\"+ vm.getUuid());\n                            }\n\n                            \r\n                            final GPUDeviceTO gpuDevice = startAnswer.getVirtualMachine().getGpuDevice();\n                            if (gpuDevice != null) {\n                                _resourceMgr.updateGPUDetails(destHostId, gpuDevice.getGroupDetails());\n                            }\n\n                            \r\n                            \r\n                            \r\n                            if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.DEPLOY_VM) != null) {\n                                userVmDetailsDao.removeDetail(vm.getId(), VmDetailConstants.DEPLOY_VM);\n                            }\n\n                            startedVm = vm;\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Start completed for VM \" + vm);\n                            }\n                            final Host vmHost = _hostDao.findById(destHostId);\n                            if (vmHost != null && (VirtualMachine.Type.ConsoleProxy.equals(vm.getType()) ||\n                                    VirtualMachine.Type.SecondaryStorageVm.equals(vm.getType())) && caManager.canProvisionCertificates()) {\n                                final Map<String, String> sshAccessDetails = _networkMgr.getSystemVMAccessDetails(vm);\n                                for (int retries = 3; retries > 0; retries--) {\n                                    try {\n                                        setupAgentSecurity(vmHost, sshAccessDetails, vm);\n                                        return;\n                                    } catch (final Exception e) {\n                                        s_logger.error(\"Retrying after catching exception while trying to secure agent for systemvm id=\" + vm.getId(), e);\n                                    }\n                                }\n                                throw new CloudRuntimeException(\"Failed to setup and secure agent for systemvm id=\" + vm.getId());\n                            }\n                            return;\n                        } else {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.info(\"The guru did not like the answers so stopping \" + vm);\n                            }\n                            StopCommand stopCmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n                            stopCmd.setControlIp(getControlNicIpForVM(vm));\n                            final StopCommand cmd = stopCmd;\n                            final Answer answer = _agentMgr.easySend(destHostId, cmd);\n                            if (answer != null && answer instanceof StopAnswer) {\n                                final StopAnswer stopAns = (StopAnswer)answer;\n                                if (vm.getType() == VirtualMachine.Type.User) {\n                                    final String platform = stopAns.getPlatform();\n                                    if (platform != null) {\n                                        final Map<String,String> vmmetadata = new HashMap<String,String>();\n                                        vmmetadata.put(vm.getInstanceName(), platform);\n                                        syncVMMetaData(vmmetadata);\n                                    }\n                                }\n                            }\n\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.warn(\"Unable to stop \" + vm + \" due to \" + (answer != null ? answer.getDetails() : \"no answers\"));\n                                _haMgr.scheduleStop(vm, destHostId, WorkType.ForceStop);\n                                throw new ExecutionException(\"Unable to stop this VM, \"+vm.getUuid()+\" so we are unable to retry the start operation\");\n                            }\n                            throw new ExecutionException(\"Unable to start  VM:\"+vm.getUuid()+\" due to error in finalizeStart, not retrying\");\n                        }\n                    }\n                    s_logger.info(\"Unable to start VM on \" + dest.getHost() + \" due to \" + (startAnswer == null ? \" no start answer\" : startAnswer.getDetails()));\n                    if (startAnswer != null && startAnswer.getContextParam(\"stopRetry\") != null) {\n                        break;\n                    }\n\n                } catch (OperationTimedoutException e) {\n                    s_logger.debug(\"Unable to send the start command to host \" + dest.getHost()+\" failed to start VM: \"+vm.getUuid());\n                    if (e.isActive()) {\n                        _haMgr.scheduleStop(vm, destHostId, WorkType.CheckStop);\n                    }\n                    canRetry = false;\n                    throw new AgentUnavailableException(\"Unable to start \" + vm.getHostName(), destHostId, e);\n                } catch (final ResourceUnavailableException e) {\n                    s_logger.info(\"Unable to contact resource.\", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected ResourceUnavailableException : \" + e.getScope().getName(), e);\n                            throw e;\n                        }\n                    }\n                } catch (final InsufficientCapacityException e) {\n                    s_logger.info(\"Insufficient capacity \", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected InsufficientCapacityException : \" + e.getScope().getName(), e);\n                        }\n                    }\n                } catch (final ExecutionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final NoTransitionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } finally {\n                    if (startedVm == null && canRetry) {\n                        final Step prevStep = work.getStep();\n                        _workDao.updateStep(work, Step.Release);\n                        \r\n                        if ((prevStep == Step.Started || prevStep == Step.Starting) && startAnswer != null && startAnswer.getResult()) {  \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, false);\n                        } else {\n                            \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, true);\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (startedVm == null) {\n                if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n                    resourceCountDecrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n                }\n                if (canRetry) {\n                    try {\n                        changeState(vm, Event.OperationFailed, null, work, Step.Done);\n                    } catch (final NoTransitionException e) {\n                        throw new ConcurrentOperationException(e.getMessage());\n                    }\n                }\n            }\n\n            if (planToDeploy != null) {\n                planToDeploy.setAvoids(avoids);\n            }\n        }\n\n        if (startedVm == null) {\n            throw new CloudRuntimeException(\"Unable to start instance '\" + vm.getHostName() + \"' (\" + vm.getUuid() + \"), see management server log for details\");\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":948,"status":"M"},{"authorDate":"2019-06-25 23:23:09","commitOrder":9,"curCode":"    public Command cleanup(final VirtualMachine vm, Map<String, DpdkTO> dpdkInterfaceMapping) {\n        StopCommand cmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n        cmd.setControlIp(getControlNicIpForVM(vm));\n        if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n            cmd.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n        }\n        return cmd;\n    }\n","date":"2019-06-25 23:23:09","endLine":3112,"groupId":"25415","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"cleanup","params":"(finalVirtualMachinevm@Map<String@DpdkTO>dpdkInterfaceMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/79/5705345962a468ec5b626e71be73e2c2815950.src","preCode":"    public Command cleanup(final VirtualMachine vm, Map<String, DpdkTO> dpdkInterfaceMapping) {\n        StopCommand cmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n        cmd.setControlIp(getControlNicIpForVM(vm));\n        if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n            cmd.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n        }\n        return cmd;\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":3105,"status":"N"}],"commitId":"d4b537efa7ed27ef88b735a22493808b61529186","commitMessage":"@@@UEFI Implementation:  Enabled UEFI Support for Guest VM's on Hypervisor KVM. VMware. enabled boot modes [Legacy. Secure] support for UEFI boot with known caveats. (#3638)\n\nCo-authored-by: Pavan Kumar Aravapalli <pavan_aravapalli@accelerite.com>\nCo-authored-by: dahn <daan.hoogland@shapeblue.com>","date":"2020-03-14 03:56:26","modifiedFileCount":"32","status":"M","submitter":"pavanaravapalli"},{"authorTime":"2019-06-25 23:23:09","codes":[{"authorDate":"2020-06-11 19:47:20","commitOrder":10,"curCode":"    public void orchestrateStart(final String vmUuid, final Map<VirtualMachineProfile.Param, Object> params, final DeploymentPlan planToDeploy, final DeploymentPlanner planner)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {\n\n        final CallContext cctxt = CallContext.current();\n        final Account account = cctxt.getCallingAccount();\n        final User caller = cctxt.getCallingUser();\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final Ternary<VMInstanceVO, ReservationContext, ItWorkVO> start = changeToStartState(vmGuru, vm, caller, account);\n        if (start == null) {\n            return;\n        }\n\n        vm = start.first();\n        final ReservationContext ctx = start.second();\n        ItWorkVO work = start.third();\n\n        VMInstanceVO startedVm = null;\n        final ServiceOfferingVO offering = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());\n        final VirtualMachineTemplate template = _entityMgr.findByIdIncludingRemoved(VirtualMachineTemplate.class, vm.getTemplateId());\n\n        DataCenterDeployment plan = new DataCenterDeployment(vm.getDataCenterId(), vm.getPodIdToDeployIn(), null, null, null, null, ctx);\n        if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"advanceStart: DeploymentPlan is provided, using dcId:\" + planToDeploy.getDataCenterId() + \", podId: \" + planToDeploy.getPodId() +\n                        \", clusterId: \" + planToDeploy.getClusterId() + \", hostId: \" + planToDeploy.getHostId() + \", poolId: \" + planToDeploy.getPoolId());\n            }\n            plan =\n                    new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(), planToDeploy.getHostId(),\n                            planToDeploy.getPoolId(), planToDeploy.getPhysicalNetworkId(), ctx);\n        }\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        \r\n        final Account owner = _entityMgr.findById(Account.class, vm.getAccountId());\n        if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n            resourceCountIncrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n        }\n\n        boolean canRetry = true;\n        ExcludeList avoids = null;\n        try {\n            final Journal journal = start.second().getJournal();\n\n            if (planToDeploy != null) {\n                avoids = planToDeploy.getAvoids();\n            }\n            if (avoids == null) {\n                avoids = new ExcludeList();\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Deploy avoids pods: \" + avoids.getPodsToAvoid() + \", clusters: \" + avoids.getClustersToAvoid() + \", hosts: \" + avoids.getHostsToAvoid());\n            }\n\n            boolean planChangedByVolume = false;\n            boolean reuseVolume = true;\n            final DataCenterDeployment originalPlan = plan;\n\n            int retry = StartRetry.value();\n            while (retry-- != 0) { \r\n\n                if (reuseVolume) {\n                    \r\n                    final List<VolumeVO> vols = _volsDao.findReadyRootVolumesByInstance(vm.getId());\n                    for (final VolumeVO vol : vols) {\n                        \r\n                        \r\n                        \r\n                        final Long volTemplateId = vol.getTemplateId();\n                        if (volTemplateId != null && volTemplateId.longValue() != template.getId()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(vol + \" of \" + vm + \" is READY, but template ids don't match, let the planner reassign a new pool\");\n                            }\n                            continue;\n                        }\n\n                        final StoragePool pool = (StoragePool)dataStoreMgr.getPrimaryDataStore(vol.getPoolId());\n                        if (!pool.isInMaintenance()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Root volume is ready, need to place VM in volume's cluster\");\n                            }\n                            final long rootVolDcId = pool.getDataCenterId();\n                            final Long rootVolPodId = pool.getPodId();\n                            final Long rootVolClusterId = pool.getClusterId();\n                            if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n                                final Long clusterIdSpecified = planToDeploy.getClusterId();\n                                if (clusterIdSpecified != null && rootVolClusterId != null) {\n                                    if (rootVolClusterId.longValue() != clusterIdSpecified.longValue()) {\n                                        \r\n                                        \r\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"Cannot satisfy the deployment plan passed in since the ready Root volume is in different cluster. volume's cluster: \" +\n                                                    rootVolClusterId + \", cluster specified: \" + clusterIdSpecified);\n                                        }\n                                        throw new ResourceUnavailableException(\n                                                \"Root volume is ready in different cluster, Deployment plan provided cannot be satisfied, unable to create a deployment for \" +\n                                                        vm, Cluster.class, clusterIdSpecified);\n                                    }\n                                }\n                                plan =\n                                        new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(),\n                                                planToDeploy.getHostId(), vol.getPoolId(), null, ctx);\n                            } else {\n                                plan = new DataCenterDeployment(rootVolDcId, rootVolPodId, rootVolClusterId, null, vol.getPoolId(), null, ctx);\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(vol + \" is READY, changing deployment plan to use this pool's dcId: \" + rootVolDcId + \" , podId: \" + rootVolPodId +\n                                            \" , and clusterId: \" + rootVolClusterId);\n                                }\n                                planChangedByVolume = true;\n                            }\n                        }\n                    }\n                }\n\n                final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vm, template, offering, owner, params);\n                logBootModeParameters(params);\n                DeployDestination dest = null;\n                try {\n                    dest = _dpMgr.planDeployment(vmProfile, plan, avoids, planner);\n                } catch (final AffinityConflictException e2) {\n                    s_logger.warn(\"Unable to create deployment, affinity rules associted to the VM conflict\", e2);\n                    throw new CloudRuntimeException(\"Unable to create deployment, affinity rules associted to the VM conflict\");\n\n                }\n\n                if (dest == null) {\n                    if (planChangedByVolume) {\n                        plan = originalPlan;\n                        planChangedByVolume = false;\n                        \r\n                        reuseVolume = false;\n                        continue;\n                    }\n                    throw new InsufficientServerCapacityException(\"Unable to create a deployment for \" + vmProfile, DataCenter.class, plan.getDataCenterId(),\n                            areAffinityGroupsAssociated(vmProfile));\n                }\n\n                if (dest != null) {\n                    avoids.addHost(dest.getHost().getId());\n                    journal.record(\"Deployment found \", vmProfile, dest);\n                }\n\n                long destHostId = dest.getHost().getId();\n                vm.setPodIdToDeployIn(dest.getPod().getId());\n                final Long cluster_id = dest.getCluster().getId();\n                final ClusterDetailsVO cluster_detail_cpu = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                final ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                \r\n                if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) == null &&\n                        (Float.parseFloat(cluster_detail_cpu.getValue()) > 1f || Float.parseFloat(cluster_detail_ram.getValue()) > 1f)) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                } else if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) != null) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                }\n\n                vmProfile.setCpuOvercommitRatio(Float.parseFloat(cluster_detail_cpu.getValue()));\n                vmProfile.setMemoryOvercommitRatio(Float.parseFloat(cluster_detail_ram.getValue()));\n                StartAnswer startAnswer = null;\n\n                try {\n                    if (!changeState(vm, Event.OperationRetry, destHostId, work, Step.Prepare)) {\n                        throw new ConcurrentOperationException(\"Unable to update the state of the Virtual Machine \"+vm.getUuid()+\" oldstate: \"+vm.getState()+ \"Event :\"+Event.OperationRetry);\n                    }\n                } catch (final NoTransitionException e1) {\n                    throw new ConcurrentOperationException(e1.getMessage());\n                }\n\n                try {\n                    _networkMgr.prepare(vmProfile, new DeployDestination(dest.getDataCenter(), dest.getPod(), null, null, dest.getStorageForDisks()), ctx);\n                    if (vm.getHypervisorType() != HypervisorType.BareMetal) {\n                        volumeMgr.prepare(vmProfile, dest);\n                    }\n\n                    \r\n                    if (!reuseVolume) {\n                        reuseVolume = true;\n                    }\n\n                    Commands cmds = null;\n                    vmGuru.finalizeVirtualMachineProfile(vmProfile, dest, ctx);\n\n                    final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);\n\n                    checkAndSetEnterSetupMode(vmTO, params);\n\n                    handlePath(vmTO.getDisks(), vm.getHypervisorType());\n\n                    cmds = new Commands(Command.OnError.Stop);\n\n                    cmds.addCommand(new StartCommand(vmTO, dest.getHost(), getExecuteInSequence(vm.getHypervisorType())));\n\n                    vmGuru.finalizeDeployment(cmds, vmProfile, dest, ctx);\n\n                    \r\n                    addExtraConfig(vmTO);\n\n                    work = _workDao.findById(work.getId());\n                    if (work == null || work.getStep() != Step.Prepare) {\n                        throw new ConcurrentOperationException(\"Work steps have been changed: \" + work);\n                    }\n\n                    _workDao.updateStep(work, Step.Starting);\n\n                    _agentMgr.send(destHostId, cmds);\n\n                    _workDao.updateStep(work, Step.Started);\n\n                    startAnswer = cmds.getAnswer(StartAnswer.class);\n                    if (startAnswer != null && startAnswer.getResult()) {\n                        handlePath(vmTO.getDisks(), startAnswer.getIqnToData());\n\n                        final String host_guid = startAnswer.getHost_guid();\n\n                        if (host_guid != null) {\n                            final HostVO finalHost = _resourceMgr.findHostByGuid(host_guid);\n                            if (finalHost == null) {\n                                throw new CloudRuntimeException(\"Host Guid \" + host_guid + \" doesn't exist in DB, something went wrong while processing start answer: \"+startAnswer);\n                            }\n                            destHostId = finalHost.getId();\n                        }\n                        if (vmGuru.finalizeStart(vmProfile, destHostId, cmds, ctx)) {\n                            syncDiskChainChange(startAnswer);\n\n                            if (!changeState(vm, Event.OperationSucceeded, destHostId, work, Step.Done)) {\n                                s_logger.error(\"Unable to transition to a new state. VM uuid: \"+vm.getUuid()+    \"VM oldstate:\"+vm.getState()+\"Event:\"+Event.OperationSucceeded);\n                                throw new ConcurrentOperationException(\"Failed to deploy VM\"+ vm.getUuid());\n                            }\n\n                            \r\n                            final GPUDeviceTO gpuDevice = startAnswer.getVirtualMachine().getGpuDevice();\n                            if (gpuDevice != null) {\n                                _resourceMgr.updateGPUDetails(destHostId, gpuDevice.getGroupDetails());\n                            }\n\n                            \r\n                            \r\n                            \r\n                            if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.DEPLOY_VM) != null) {\n                                userVmDetailsDao.removeDetail(vm.getId(), VmDetailConstants.DEPLOY_VM);\n                            }\n\n                            startedVm = vm;\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Start completed for VM \" + vm);\n                            }\n                            final Host vmHost = _hostDao.findById(destHostId);\n                            if (vmHost != null && (VirtualMachine.Type.ConsoleProxy.equals(vm.getType()) ||\n                                    VirtualMachine.Type.SecondaryStorageVm.equals(vm.getType())) && caManager.canProvisionCertificates()) {\n                                final Map<String, String> sshAccessDetails = _networkMgr.getSystemVMAccessDetails(vm);\n                                for (int retries = 3; retries > 0; retries--) {\n                                    try {\n                                        setupAgentSecurity(vmHost, sshAccessDetails, vm);\n                                        return;\n                                    } catch (final Exception e) {\n                                        s_logger.error(\"Retrying after catching exception while trying to secure agent for systemvm id=\" + vm.getId(), e);\n                                    }\n                                }\n                                throw new CloudRuntimeException(\"Failed to setup and secure agent for systemvm id=\" + vm.getId());\n                            }\n                            return;\n                        } else {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.info(\"The guru did not like the answers so stopping \" + vm);\n                            }\n                            StopCommand stopCmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n                            stopCmd.setControlIp(getControlNicIpForVM(vm));\n                            final StopCommand cmd = stopCmd;\n                            final Answer answer = _agentMgr.easySend(destHostId, cmd);\n                            if (answer != null && answer instanceof StopAnswer) {\n                                final StopAnswer stopAns = (StopAnswer)answer;\n                                if (vm.getType() == VirtualMachine.Type.User) {\n                                    final String platform = stopAns.getPlatform();\n                                    if (platform != null) {\n                                        final Map<String,String> vmmetadata = new HashMap<String,String>();\n                                        vmmetadata.put(vm.getInstanceName(), platform);\n                                        syncVMMetaData(vmmetadata);\n                                    }\n                                }\n                            }\n\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.warn(\"Unable to stop \" + vm + \" due to \" + (answer != null ? answer.getDetails() : \"no answers\"));\n                                _haMgr.scheduleStop(vm, destHostId, WorkType.ForceStop);\n                                throw new ExecutionException(\"Unable to stop this VM, \"+vm.getUuid()+\" so we are unable to retry the start operation\");\n                            }\n                            throw new ExecutionException(\"Unable to start  VM:\"+vm.getUuid()+\" due to error in finalizeStart, not retrying\");\n                        }\n                    }\n                    s_logger.info(\"Unable to start VM on \" + dest.getHost() + \" due to \" + (startAnswer == null ? \" no start answer\" : startAnswer.getDetails()));\n                    if (startAnswer != null && startAnswer.getContextParam(\"stopRetry\") != null) {\n                        break;\n                    }\n\n                } catch (OperationTimedoutException e) {\n                    s_logger.debug(\"Unable to send the start command to host \" + dest.getHost()+\" failed to start VM: \"+vm.getUuid());\n                    if (e.isActive()) {\n                        _haMgr.scheduleStop(vm, destHostId, WorkType.CheckStop);\n                    }\n                    canRetry = false;\n                    throw new AgentUnavailableException(\"Unable to start \" + vm.getHostName(), destHostId, e);\n                } catch (final ResourceUnavailableException e) {\n                    s_logger.info(\"Unable to contact resource.\", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected ResourceUnavailableException : \" + e.getScope().getName(), e);\n                            throw e;\n                        }\n                    }\n                } catch (final InsufficientCapacityException e) {\n                    s_logger.info(\"Insufficient capacity \", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected InsufficientCapacityException : \" + e.getScope().getName(), e);\n                        }\n                    }\n                } catch (final ExecutionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final NoTransitionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } finally {\n                    if (startedVm == null && canRetry) {\n                        final Step prevStep = work.getStep();\n                        _workDao.updateStep(work, Step.Release);\n                        \r\n                        if ((prevStep == Step.Started || prevStep == Step.Starting) && startAnswer != null && startAnswer.getResult()) {  \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, false);\n                        } else {\n                            \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, true);\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (startedVm == null) {\n                if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n                    resourceCountDecrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n                }\n                if (canRetry) {\n                    try {\n                        changeState(vm, Event.OperationFailed, null, work, Step.Done);\n                    } catch (final NoTransitionException e) {\n                        throw new ConcurrentOperationException(e.getMessage());\n                    }\n                }\n            }\n\n            if (planToDeploy != null) {\n                planToDeploy.setAvoids(avoids);\n            }\n        }\n\n        if (startedVm == null) {\n            throw new CloudRuntimeException(\"Unable to start instance '\" + vm.getHostName() + \"' (\" + vm.getUuid() + \"), see management server log for details\");\n        }\n    }\n","date":"2020-06-11 19:47:20","endLine":1325,"groupId":"21762","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"orchestrateStart","params":"(finalStringvmUuid@finalMap<VirtualMachineProfile.Param@Object>params@finalDeploymentPlanplanToDeploy@finalDeploymentPlannerplanner)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/a2/9002bf81e4fdbf7bddca34db1c6c13aa4d3306.src","preCode":"    public void orchestrateStart(final String vmUuid, final Map<VirtualMachineProfile.Param, Object> params, final DeploymentPlan planToDeploy, final DeploymentPlanner planner)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {\n\n        final CallContext cctxt = CallContext.current();\n        final Account account = cctxt.getCallingAccount();\n        final User caller = cctxt.getCallingUser();\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final Ternary<VMInstanceVO, ReservationContext, ItWorkVO> start = changeToStartState(vmGuru, vm, caller, account);\n        if (start == null) {\n            return;\n        }\n\n        vm = start.first();\n        final ReservationContext ctx = start.second();\n        ItWorkVO work = start.third();\n\n        VMInstanceVO startedVm = null;\n        final ServiceOfferingVO offering = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());\n        final VirtualMachineTemplate template = _entityMgr.findByIdIncludingRemoved(VirtualMachineTemplate.class, vm.getTemplateId());\n\n        DataCenterDeployment plan = new DataCenterDeployment(vm.getDataCenterId(), vm.getPodIdToDeployIn(), null, null, null, null, ctx);\n        if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"advanceStart: DeploymentPlan is provided, using dcId:\" + planToDeploy.getDataCenterId() + \", podId: \" + planToDeploy.getPodId() +\n                        \", clusterId: \" + planToDeploy.getClusterId() + \", hostId: \" + planToDeploy.getHostId() + \", poolId: \" + planToDeploy.getPoolId());\n            }\n            plan =\n                    new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(), planToDeploy.getHostId(),\n                            planToDeploy.getPoolId(), planToDeploy.getPhysicalNetworkId(), ctx);\n        }\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        \r\n        final Account owner = _entityMgr.findById(Account.class, vm.getAccountId());\n        if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n            resourceCountIncrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n        }\n\n        boolean canRetry = true;\n        ExcludeList avoids = null;\n        try {\n            final Journal journal = start.second().getJournal();\n\n            if (planToDeploy != null) {\n                avoids = planToDeploy.getAvoids();\n            }\n            if (avoids == null) {\n                avoids = new ExcludeList();\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Deploy avoids pods: \" + avoids.getPodsToAvoid() + \", clusters: \" + avoids.getClustersToAvoid() + \", hosts: \" + avoids.getHostsToAvoid());\n            }\n\n            boolean planChangedByVolume = false;\n            boolean reuseVolume = true;\n            final DataCenterDeployment originalPlan = plan;\n\n            int retry = StartRetry.value();\n            while (retry-- != 0) { \r\n\n                if (reuseVolume) {\n                    \r\n                    final List<VolumeVO> vols = _volsDao.findReadyRootVolumesByInstance(vm.getId());\n                    for (final VolumeVO vol : vols) {\n                        \r\n                        \r\n                        \r\n                        final Long volTemplateId = vol.getTemplateId();\n                        if (volTemplateId != null && volTemplateId.longValue() != template.getId()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(vol + \" of \" + vm + \" is READY, but template ids don't match, let the planner reassign a new pool\");\n                            }\n                            continue;\n                        }\n\n                        final StoragePool pool = (StoragePool)dataStoreMgr.getPrimaryDataStore(vol.getPoolId());\n                        if (!pool.isInMaintenance()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Root volume is ready, need to place VM in volume's cluster\");\n                            }\n                            final long rootVolDcId = pool.getDataCenterId();\n                            final Long rootVolPodId = pool.getPodId();\n                            final Long rootVolClusterId = pool.getClusterId();\n                            if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n                                final Long clusterIdSpecified = planToDeploy.getClusterId();\n                                if (clusterIdSpecified != null && rootVolClusterId != null) {\n                                    if (rootVolClusterId.longValue() != clusterIdSpecified.longValue()) {\n                                        \r\n                                        \r\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"Cannot satisfy the deployment plan passed in since the ready Root volume is in different cluster. volume's cluster: \" +\n                                                    rootVolClusterId + \", cluster specified: \" + clusterIdSpecified);\n                                        }\n                                        throw new ResourceUnavailableException(\n                                                \"Root volume is ready in different cluster, Deployment plan provided cannot be satisfied, unable to create a deployment for \" +\n                                                        vm, Cluster.class, clusterIdSpecified);\n                                    }\n                                }\n                                plan =\n                                        new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(),\n                                                planToDeploy.getHostId(), vol.getPoolId(), null, ctx);\n                            } else {\n                                plan = new DataCenterDeployment(rootVolDcId, rootVolPodId, rootVolClusterId, null, vol.getPoolId(), null, ctx);\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(vol + \" is READY, changing deployment plan to use this pool's dcId: \" + rootVolDcId + \" , podId: \" + rootVolPodId +\n                                            \" , and clusterId: \" + rootVolClusterId);\n                                }\n                                planChangedByVolume = true;\n                            }\n                        }\n                    }\n                }\n\n                final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vm, template, offering, owner, params);\n                s_logger.info(\" Uefi params \" + \"UefiFlag: \" + params.get(VirtualMachineProfile.Param.UefiFlag)\n                        + \" Boot Type: \" + params.get(VirtualMachineProfile.Param.BootType)\n                        + \" Boot Mode: \" + params.get(VirtualMachineProfile.Param.BootMode)\n                );\n                DeployDestination dest = null;\n                try {\n                    dest = _dpMgr.planDeployment(vmProfile, plan, avoids, planner);\n                } catch (final AffinityConflictException e2) {\n                    s_logger.warn(\"Unable to create deployment, affinity rules associted to the VM conflict\", e2);\n                    throw new CloudRuntimeException(\"Unable to create deployment, affinity rules associted to the VM conflict\");\n\n                }\n\n                if (dest == null) {\n                    if (planChangedByVolume) {\n                        plan = originalPlan;\n                        planChangedByVolume = false;\n                        \r\n                        reuseVolume = false;\n                        continue;\n                    }\n                    throw new InsufficientServerCapacityException(\"Unable to create a deployment for \" + vmProfile, DataCenter.class, plan.getDataCenterId(),\n                            areAffinityGroupsAssociated(vmProfile));\n                }\n\n                if (dest != null) {\n                    avoids.addHost(dest.getHost().getId());\n                    journal.record(\"Deployment found \", vmProfile, dest);\n                }\n\n                long destHostId = dest.getHost().getId();\n                vm.setPodIdToDeployIn(dest.getPod().getId());\n                final Long cluster_id = dest.getCluster().getId();\n                final ClusterDetailsVO cluster_detail_cpu = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                final ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                \r\n                if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) == null &&\n                        (Float.parseFloat(cluster_detail_cpu.getValue()) > 1f || Float.parseFloat(cluster_detail_ram.getValue()) > 1f)) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                } else if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) != null) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                }\n\n                vmProfile.setCpuOvercommitRatio(Float.parseFloat(cluster_detail_cpu.getValue()));\n                vmProfile.setMemoryOvercommitRatio(Float.parseFloat(cluster_detail_ram.getValue()));\n                StartAnswer startAnswer = null;\n\n                try {\n                    if (!changeState(vm, Event.OperationRetry, destHostId, work, Step.Prepare)) {\n                        throw new ConcurrentOperationException(\"Unable to update the state of the Virtual Machine \"+vm.getUuid()+\" oldstate: \"+vm.getState()+ \"Event :\"+Event.OperationRetry);\n                    }\n                } catch (final NoTransitionException e1) {\n                    throw new ConcurrentOperationException(e1.getMessage());\n                }\n\n                try {\n                    _networkMgr.prepare(vmProfile, new DeployDestination(dest.getDataCenter(), dest.getPod(), null, null, dest.getStorageForDisks()), ctx);\n                    if (vm.getHypervisorType() != HypervisorType.BareMetal) {\n                        volumeMgr.prepare(vmProfile, dest);\n                    }\n\n                    \r\n                    if (!reuseVolume) {\n                        reuseVolume = true;\n                    }\n\n                    Commands cmds = null;\n                    vmGuru.finalizeVirtualMachineProfile(vmProfile, dest, ctx);\n\n                    final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);\n\n                    handlePath(vmTO.getDisks(), vm.getHypervisorType());\n\n                    cmds = new Commands(Command.OnError.Stop);\n\n                    cmds.addCommand(new StartCommand(vmTO, dest.getHost(), getExecuteInSequence(vm.getHypervisorType())));\n\n                    vmGuru.finalizeDeployment(cmds, vmProfile, dest, ctx);\n\n                    \r\n                    addExtraConfig(vmTO);\n\n                    work = _workDao.findById(work.getId());\n                    if (work == null || work.getStep() != Step.Prepare) {\n                        throw new ConcurrentOperationException(\"Work steps have been changed: \" + work);\n                    }\n\n                    _workDao.updateStep(work, Step.Starting);\n\n                    _agentMgr.send(destHostId, cmds);\n\n                    _workDao.updateStep(work, Step.Started);\n\n                    startAnswer = cmds.getAnswer(StartAnswer.class);\n                    if (startAnswer != null && startAnswer.getResult()) {\n                        handlePath(vmTO.getDisks(), startAnswer.getIqnToData());\n\n                        final String host_guid = startAnswer.getHost_guid();\n\n                        if (host_guid != null) {\n                            final HostVO finalHost = _resourceMgr.findHostByGuid(host_guid);\n                            if (finalHost == null) {\n                                throw new CloudRuntimeException(\"Host Guid \" + host_guid + \" doesn't exist in DB, something went wrong while processing start answer: \"+startAnswer);\n                            }\n                            destHostId = finalHost.getId();\n                        }\n                        if (vmGuru.finalizeStart(vmProfile, destHostId, cmds, ctx)) {\n                            syncDiskChainChange(startAnswer);\n\n                            if (!changeState(vm, Event.OperationSucceeded, destHostId, work, Step.Done)) {\n                                s_logger.error(\"Unable to transition to a new state. VM uuid: \"+vm.getUuid()+    \"VM oldstate:\"+vm.getState()+\"Event:\"+Event.OperationSucceeded);\n                                throw new ConcurrentOperationException(\"Failed to deploy VM\"+ vm.getUuid());\n                            }\n\n                            \r\n                            final GPUDeviceTO gpuDevice = startAnswer.getVirtualMachine().getGpuDevice();\n                            if (gpuDevice != null) {\n                                _resourceMgr.updateGPUDetails(destHostId, gpuDevice.getGroupDetails());\n                            }\n\n                            \r\n                            \r\n                            \r\n                            if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.DEPLOY_VM) != null) {\n                                userVmDetailsDao.removeDetail(vm.getId(), VmDetailConstants.DEPLOY_VM);\n                            }\n\n                            startedVm = vm;\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Start completed for VM \" + vm);\n                            }\n                            final Host vmHost = _hostDao.findById(destHostId);\n                            if (vmHost != null && (VirtualMachine.Type.ConsoleProxy.equals(vm.getType()) ||\n                                    VirtualMachine.Type.SecondaryStorageVm.equals(vm.getType())) && caManager.canProvisionCertificates()) {\n                                final Map<String, String> sshAccessDetails = _networkMgr.getSystemVMAccessDetails(vm);\n                                for (int retries = 3; retries > 0; retries--) {\n                                    try {\n                                        setupAgentSecurity(vmHost, sshAccessDetails, vm);\n                                        return;\n                                    } catch (final Exception e) {\n                                        s_logger.error(\"Retrying after catching exception while trying to secure agent for systemvm id=\" + vm.getId(), e);\n                                    }\n                                }\n                                throw new CloudRuntimeException(\"Failed to setup and secure agent for systemvm id=\" + vm.getId());\n                            }\n                            return;\n                        } else {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.info(\"The guru did not like the answers so stopping \" + vm);\n                            }\n                            StopCommand stopCmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n                            stopCmd.setControlIp(getControlNicIpForVM(vm));\n                            final StopCommand cmd = stopCmd;\n                            final Answer answer = _agentMgr.easySend(destHostId, cmd);\n                            if (answer != null && answer instanceof StopAnswer) {\n                                final StopAnswer stopAns = (StopAnswer)answer;\n                                if (vm.getType() == VirtualMachine.Type.User) {\n                                    final String platform = stopAns.getPlatform();\n                                    if (platform != null) {\n                                        final Map<String,String> vmmetadata = new HashMap<String,String>();\n                                        vmmetadata.put(vm.getInstanceName(), platform);\n                                        syncVMMetaData(vmmetadata);\n                                    }\n                                }\n                            }\n\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.warn(\"Unable to stop \" + vm + \" due to \" + (answer != null ? answer.getDetails() : \"no answers\"));\n                                _haMgr.scheduleStop(vm, destHostId, WorkType.ForceStop);\n                                throw new ExecutionException(\"Unable to stop this VM, \"+vm.getUuid()+\" so we are unable to retry the start operation\");\n                            }\n                            throw new ExecutionException(\"Unable to start  VM:\"+vm.getUuid()+\" due to error in finalizeStart, not retrying\");\n                        }\n                    }\n                    s_logger.info(\"Unable to start VM on \" + dest.getHost() + \" due to \" + (startAnswer == null ? \" no start answer\" : startAnswer.getDetails()));\n                    if (startAnswer != null && startAnswer.getContextParam(\"stopRetry\") != null) {\n                        break;\n                    }\n\n                } catch (OperationTimedoutException e) {\n                    s_logger.debug(\"Unable to send the start command to host \" + dest.getHost()+\" failed to start VM: \"+vm.getUuid());\n                    if (e.isActive()) {\n                        _haMgr.scheduleStop(vm, destHostId, WorkType.CheckStop);\n                    }\n                    canRetry = false;\n                    throw new AgentUnavailableException(\"Unable to start \" + vm.getHostName(), destHostId, e);\n                } catch (final ResourceUnavailableException e) {\n                    s_logger.info(\"Unable to contact resource.\", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected ResourceUnavailableException : \" + e.getScope().getName(), e);\n                            throw e;\n                        }\n                    }\n                } catch (final InsufficientCapacityException e) {\n                    s_logger.info(\"Insufficient capacity \", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected InsufficientCapacityException : \" + e.getScope().getName(), e);\n                        }\n                    }\n                } catch (final ExecutionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final NoTransitionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } finally {\n                    if (startedVm == null && canRetry) {\n                        final Step prevStep = work.getStep();\n                        _workDao.updateStep(work, Step.Release);\n                        \r\n                        if ((prevStep == Step.Started || prevStep == Step.Starting) && startAnswer != null && startAnswer.getResult()) {  \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, false);\n                        } else {\n                            \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, true);\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (startedVm == null) {\n                if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n                    resourceCountDecrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n                }\n                if (canRetry) {\n                    try {\n                        changeState(vm, Event.OperationFailed, null, work, Step.Done);\n                    } catch (final NoTransitionException e) {\n                        throw new ConcurrentOperationException(e.getMessage());\n                    }\n                }\n            }\n\n            if (planToDeploy != null) {\n                planToDeploy.setAvoids(avoids);\n            }\n        }\n\n        if (startedVm == null) {\n            throw new CloudRuntimeException(\"Unable to start instance '\" + vm.getHostName() + \"' (\" + vm.getUuid() + \"), see management server log for details\");\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":958,"status":"M"},{"authorDate":"2019-06-25 23:23:09","commitOrder":10,"curCode":"    public Command cleanup(final VirtualMachine vm, Map<String, DpdkTO> dpdkInterfaceMapping) {\n        StopCommand cmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n        cmd.setControlIp(getControlNicIpForVM(vm));\n        if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n            cmd.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n        }\n        return cmd;\n    }\n","date":"2019-06-25 23:23:09","endLine":3112,"groupId":"25415","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"cleanup","params":"(finalVirtualMachinevm@Map<String@DpdkTO>dpdkInterfaceMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/79/5705345962a468ec5b626e71be73e2c2815950.src","preCode":"    public Command cleanup(final VirtualMachine vm, Map<String, DpdkTO> dpdkInterfaceMapping) {\n        StopCommand cmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n        cmd.setControlIp(getControlNicIpForVM(vm));\n        if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n            cmd.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n        }\n        return cmd;\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":3105,"status":"N"}],"commitId":"0795cd430b46f2001cbb902d705dd130c6f5dd7d","commitMessage":"@@@Boot into hardware setup menu on Vmware (#4021)\n\n","date":"2020-06-11 19:47:20","modifiedFileCount":"11","status":"M","submitter":"dahn"},{"authorTime":"2019-06-25 23:23:09","codes":[{"authorDate":"2020-08-05 17:16:13","commitOrder":11,"curCode":"    public void orchestrateStart(final String vmUuid, final Map<VirtualMachineProfile.Param, Object> params, final DeploymentPlan planToDeploy, final DeploymentPlanner planner)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {\n\n        final CallContext cctxt = CallContext.current();\n        final Account account = cctxt.getCallingAccount();\n        final User caller = cctxt.getCallingUser();\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final Ternary<VMInstanceVO, ReservationContext, ItWorkVO> start = changeToStartState(vmGuru, vm, caller, account);\n        if (start == null) {\n            return;\n        }\n\n        vm = start.first();\n        final ReservationContext ctx = start.second();\n        ItWorkVO work = start.third();\n\n        VMInstanceVO startedVm = null;\n        final ServiceOfferingVO offering = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());\n        final VirtualMachineTemplate template = _entityMgr.findByIdIncludingRemoved(VirtualMachineTemplate.class, vm.getTemplateId());\n\n        DataCenterDeployment plan = new DataCenterDeployment(vm.getDataCenterId(), vm.getPodIdToDeployIn(), null, null, null, null, ctx);\n        if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"advanceStart: DeploymentPlan is provided, using dcId:\" + planToDeploy.getDataCenterId() + \", podId: \" + planToDeploy.getPodId() +\n                        \", clusterId: \" + planToDeploy.getClusterId() + \", hostId: \" + planToDeploy.getHostId() + \", poolId: \" + planToDeploy.getPoolId());\n            }\n            plan =\n                    new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(), planToDeploy.getHostId(),\n                            planToDeploy.getPoolId(), planToDeploy.getPhysicalNetworkId(), ctx);\n        }\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        \r\n        final Account owner = _entityMgr.findById(Account.class, vm.getAccountId());\n        if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n            resourceCountIncrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n        }\n\n        boolean canRetry = true;\n        ExcludeList avoids = null;\n        try {\n            final Journal journal = start.second().getJournal();\n\n            if (planToDeploy != null) {\n                avoids = planToDeploy.getAvoids();\n            }\n            if (avoids == null) {\n                avoids = new ExcludeList();\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Deploy avoids pods: \" + avoids.getPodsToAvoid() + \", clusters: \" + avoids.getClustersToAvoid() + \", hosts: \" + avoids.getHostsToAvoid());\n            }\n\n            boolean planChangedByVolume = false;\n            boolean reuseVolume = true;\n            final DataCenterDeployment originalPlan = plan;\n\n            int retry = StartRetry.value();\n            while (retry-- != 0) { \r\n\n                if (reuseVolume) {\n                    \r\n                    final List<VolumeVO> vols = _volsDao.findReadyRootVolumesByInstance(vm.getId());\n                    for (final VolumeVO vol : vols) {\n                        \r\n                        \r\n                        \r\n                        final Long volTemplateId = vol.getTemplateId();\n                        if (volTemplateId != null && volTemplateId.longValue() != template.getId()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(vol + \" of \" + vm + \" is READY, but template ids don't match, let the planner reassign a new pool\");\n                            }\n                            continue;\n                        }\n\n                        final StoragePool pool = (StoragePool)dataStoreMgr.getPrimaryDataStore(vol.getPoolId());\n                        if (!pool.isInMaintenance()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Root volume is ready, need to place VM in volume's cluster\");\n                            }\n                            final long rootVolDcId = pool.getDataCenterId();\n                            final Long rootVolPodId = pool.getPodId();\n                            final Long rootVolClusterId = pool.getClusterId();\n                            if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n                                final Long clusterIdSpecified = planToDeploy.getClusterId();\n                                if (clusterIdSpecified != null && rootVolClusterId != null) {\n                                    if (rootVolClusterId.longValue() != clusterIdSpecified.longValue()) {\n                                        \r\n                                        \r\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"Cannot satisfy the deployment plan passed in since the ready Root volume is in different cluster. volume's cluster: \" +\n                                                    rootVolClusterId + \", cluster specified: \" + clusterIdSpecified);\n                                        }\n                                        throw new ResourceUnavailableException(\n                                                \"Root volume is ready in different cluster, Deployment plan provided cannot be satisfied, unable to create a deployment for \" +\n                                                        vm, Cluster.class, clusterIdSpecified);\n                                    }\n                                }\n                                plan =\n                                        new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(),\n                                                planToDeploy.getHostId(), vol.getPoolId(), null, ctx);\n                            } else {\n                                plan = new DataCenterDeployment(rootVolDcId, rootVolPodId, rootVolClusterId, null, vol.getPoolId(), null, ctx);\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(vol + \" is READY, changing deployment plan to use this pool's dcId: \" + rootVolDcId + \" , podId: \" + rootVolPodId +\n                                            \" , and clusterId: \" + rootVolClusterId);\n                                }\n                                planChangedByVolume = true;\n                            }\n                        }\n                    }\n                }\n\n                final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vm, template, offering, owner, params);\n                logBootModeParameters(params);\n                DeployDestination dest = null;\n                try {\n                    dest = _dpMgr.planDeployment(vmProfile, plan, avoids, planner);\n                } catch (final AffinityConflictException e2) {\n                    s_logger.warn(\"Unable to create deployment, affinity rules associted to the VM conflict\", e2);\n                    throw new CloudRuntimeException(\"Unable to create deployment, affinity rules associted to the VM conflict\");\n                }\n\n                if (dest == null) {\n                    if (planChangedByVolume) {\n                        plan = originalPlan;\n                        planChangedByVolume = false;\n                        \r\n                        reuseVolume = false;\n                        continue;\n                    }\n                    throw new InsufficientServerCapacityException(\"Unable to create a deployment for \" + vmProfile, DataCenter.class, plan.getDataCenterId(),\n                            areAffinityGroupsAssociated(vmProfile));\n                }\n\n                if (dest != null) {\n                    avoids.addHost(dest.getHost().getId());\n                    journal.record(\"Deployment found \", vmProfile, dest);\n                }\n\n                long destHostId = dest.getHost().getId();\n                vm.setPodIdToDeployIn(dest.getPod().getId());\n                final Long cluster_id = dest.getCluster().getId();\n                final ClusterDetailsVO cluster_detail_cpu = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                final ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                \r\n                if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) == null &&\n                        (Float.parseFloat(cluster_detail_cpu.getValue()) > 1f || Float.parseFloat(cluster_detail_ram.getValue()) > 1f)) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                } else if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) != null) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                }\n\n                vmProfile.setCpuOvercommitRatio(Float.parseFloat(cluster_detail_cpu.getValue()));\n                vmProfile.setMemoryOvercommitRatio(Float.parseFloat(cluster_detail_ram.getValue()));\n                StartAnswer startAnswer = null;\n\n                try {\n                    if (!changeState(vm, Event.OperationRetry, destHostId, work, Step.Prepare)) {\n                        throw new ConcurrentOperationException(\"Unable to update the state of the Virtual Machine \"+vm.getUuid()+\" oldstate: \"+vm.getState()+ \"Event :\"+Event.OperationRetry);\n                    }\n                } catch (final NoTransitionException e1) {\n                    throw new ConcurrentOperationException(e1.getMessage());\n                }\n\n                try {\n                    resetVmNicsDeviceId(vm.getId());\n                    _networkMgr.prepare(vmProfile, new DeployDestination(dest.getDataCenter(), dest.getPod(), null, null, dest.getStorageForDisks()), ctx);\n                    if (vm.getHypervisorType() != HypervisorType.BareMetal) {\n                        volumeMgr.prepare(vmProfile, dest);\n                    }\n\n                    \r\n                    if (!reuseVolume) {\n                        reuseVolume = true;\n                    }\n\n                    Commands cmds = null;\n                    vmGuru.finalizeVirtualMachineProfile(vmProfile, dest, ctx);\n\n                    final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);\n\n                    checkAndSetEnterSetupMode(vmTO, params);\n\n                    handlePath(vmTO.getDisks(), vm.getHypervisorType());\n\n                    cmds = new Commands(Command.OnError.Stop);\n\n                    cmds.addCommand(new StartCommand(vmTO, dest.getHost(), getExecuteInSequence(vm.getHypervisorType())));\n\n                    vmGuru.finalizeDeployment(cmds, vmProfile, dest, ctx);\n\n                    \r\n                    addExtraConfig(vmTO);\n\n                    work = _workDao.findById(work.getId());\n                    if (work == null || work.getStep() != Step.Prepare) {\n                        throw new ConcurrentOperationException(\"Work steps have been changed: \" + work);\n                    }\n\n                    _workDao.updateStep(work, Step.Starting);\n\n                    _agentMgr.send(destHostId, cmds);\n\n                    _workDao.updateStep(work, Step.Started);\n\n                    startAnswer = cmds.getAnswer(StartAnswer.class);\n                    if (startAnswer != null && startAnswer.getResult()) {\n                        handlePath(vmTO.getDisks(), startAnswer.getIqnToData());\n\n                        final String host_guid = startAnswer.getHost_guid();\n\n                        if (host_guid != null) {\n                            final HostVO finalHost = _resourceMgr.findHostByGuid(host_guid);\n                            if (finalHost == null) {\n                                throw new CloudRuntimeException(\"Host Guid \" + host_guid + \" doesn't exist in DB, something went wrong while processing start answer: \"+startAnswer);\n                            }\n                            destHostId = finalHost.getId();\n                        }\n                        if (vmGuru.finalizeStart(vmProfile, destHostId, cmds, ctx)) {\n                            syncDiskChainChange(startAnswer);\n\n                            if (!changeState(vm, Event.OperationSucceeded, destHostId, work, Step.Done)) {\n                                s_logger.error(\"Unable to transition to a new state. VM uuid: \"+vm.getUuid()+    \"VM oldstate:\"+vm.getState()+\"Event:\"+Event.OperationSucceeded);\n                                throw new ConcurrentOperationException(\"Failed to deploy VM\"+ vm.getUuid());\n                            }\n\n                            \r\n                            final GPUDeviceTO gpuDevice = startAnswer.getVirtualMachine().getGpuDevice();\n                            if (gpuDevice != null) {\n                                _resourceMgr.updateGPUDetails(destHostId, gpuDevice.getGroupDetails());\n                            }\n\n                            \r\n                            \r\n                            \r\n                            if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.DEPLOY_VM) != null) {\n                                userVmDetailsDao.removeDetail(vm.getId(), VmDetailConstants.DEPLOY_VM);\n                            }\n\n                            startedVm = vm;\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Start completed for VM \" + vm);\n                            }\n                            final Host vmHost = _hostDao.findById(destHostId);\n                            if (vmHost != null && (VirtualMachine.Type.ConsoleProxy.equals(vm.getType()) ||\n                                    VirtualMachine.Type.SecondaryStorageVm.equals(vm.getType())) && caManager.canProvisionCertificates()) {\n                                final Map<String, String> sshAccessDetails = _networkMgr.getSystemVMAccessDetails(vm);\n                                for (int retries = 3; retries > 0; retries--) {\n                                    try {\n                                        setupAgentSecurity(vmHost, sshAccessDetails, vm);\n                                        return;\n                                    } catch (final Exception e) {\n                                        s_logger.error(\"Retrying after catching exception while trying to secure agent for systemvm id=\" + vm.getId(), e);\n                                    }\n                                }\n                                throw new CloudRuntimeException(\"Failed to setup and secure agent for systemvm id=\" + vm.getId());\n                            }\n                            return;\n                        } else {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.info(\"The guru did not like the answers so stopping \" + vm);\n                            }\n                            StopCommand stopCmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n                            stopCmd.setControlIp(getControlNicIpForVM(vm));\n                            final StopCommand cmd = stopCmd;\n                            final Answer answer = _agentMgr.easySend(destHostId, cmd);\n                            if (answer != null && answer instanceof StopAnswer) {\n                                final StopAnswer stopAns = (StopAnswer)answer;\n                                if (vm.getType() == VirtualMachine.Type.User) {\n                                    final String platform = stopAns.getPlatform();\n                                    if (platform != null) {\n                                        final Map<String,String> vmmetadata = new HashMap<String,String>();\n                                        vmmetadata.put(vm.getInstanceName(), platform);\n                                        syncVMMetaData(vmmetadata);\n                                    }\n                                }\n                            }\n\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.warn(\"Unable to stop \" + vm + \" due to \" + (answer != null ? answer.getDetails() : \"no answers\"));\n                                _haMgr.scheduleStop(vm, destHostId, WorkType.ForceStop);\n                                throw new ExecutionException(\"Unable to stop this VM, \"+vm.getUuid()+\" so we are unable to retry the start operation\");\n                            }\n                            throw new ExecutionException(\"Unable to start  VM:\"+vm.getUuid()+\" due to error in finalizeStart, not retrying\");\n                        }\n                    }\n                    s_logger.info(\"Unable to start VM on \" + dest.getHost() + \" due to \" + (startAnswer == null ? \" no start answer\" : startAnswer.getDetails()));\n                    if (startAnswer != null && startAnswer.getContextParam(\"stopRetry\") != null) {\n                        break;\n                    }\n\n                } catch (OperationTimedoutException e) {\n                    s_logger.debug(\"Unable to send the start command to host \" + dest.getHost()+\" failed to start VM: \"+vm.getUuid());\n                    if (e.isActive()) {\n                        _haMgr.scheduleStop(vm, destHostId, WorkType.CheckStop);\n                    }\n                    canRetry = false;\n                    throw new AgentUnavailableException(\"Unable to start \" + vm.getHostName(), destHostId, e);\n                } catch (final ResourceUnavailableException e) {\n                    s_logger.info(\"Unable to contact resource.\", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected ResourceUnavailableException : \" + e.getScope().getName(), e);\n                            throw e;\n                        }\n                    }\n                } catch (final InsufficientCapacityException e) {\n                    s_logger.info(\"Insufficient capacity \", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected InsufficientCapacityException : \" + e.getScope().getName(), e);\n                        }\n                    }\n                } catch (final ExecutionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final NoTransitionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } finally {\n                    if (startedVm == null && canRetry) {\n                        final Step prevStep = work.getStep();\n                        _workDao.updateStep(work, Step.Release);\n                        \r\n                        if ((prevStep == Step.Started || prevStep == Step.Starting) && startAnswer != null && startAnswer.getResult()) {  \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, false);\n                        } else {\n                            \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, true);\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (startedVm == null) {\n                if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n                    resourceCountDecrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n                }\n                if (canRetry) {\n                    try {\n                        changeState(vm, Event.OperationFailed, null, work, Step.Done);\n                    } catch (final NoTransitionException e) {\n                        throw new ConcurrentOperationException(e.getMessage());\n                    }\n                }\n            }\n\n            if (planToDeploy != null) {\n                planToDeploy.setAvoids(avoids);\n            }\n        }\n\n        if (startedVm == null) {\n            throw new CloudRuntimeException(\"Unable to start instance '\" + vm.getHostName() + \"' (\" + vm.getUuid() + \"), see management server log for details\");\n        }\n    }\n","date":"2020-08-05 17:16:13","endLine":1331,"groupId":"21762","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"orchestrateStart","params":"(finalStringvmUuid@finalMap<VirtualMachineProfile.Param@Object>params@finalDeploymentPlanplanToDeploy@finalDeploymentPlannerplanner)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/71/c89f6ef69f6c6e12a11e207cb196512c64bd67.src","preCode":"    public void orchestrateStart(final String vmUuid, final Map<VirtualMachineProfile.Param, Object> params, final DeploymentPlan planToDeploy, final DeploymentPlanner planner)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {\n\n        final CallContext cctxt = CallContext.current();\n        final Account account = cctxt.getCallingAccount();\n        final User caller = cctxt.getCallingUser();\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final Ternary<VMInstanceVO, ReservationContext, ItWorkVO> start = changeToStartState(vmGuru, vm, caller, account);\n        if (start == null) {\n            return;\n        }\n\n        vm = start.first();\n        final ReservationContext ctx = start.second();\n        ItWorkVO work = start.third();\n\n        VMInstanceVO startedVm = null;\n        final ServiceOfferingVO offering = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());\n        final VirtualMachineTemplate template = _entityMgr.findByIdIncludingRemoved(VirtualMachineTemplate.class, vm.getTemplateId());\n\n        DataCenterDeployment plan = new DataCenterDeployment(vm.getDataCenterId(), vm.getPodIdToDeployIn(), null, null, null, null, ctx);\n        if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"advanceStart: DeploymentPlan is provided, using dcId:\" + planToDeploy.getDataCenterId() + \", podId: \" + planToDeploy.getPodId() +\n                        \", clusterId: \" + planToDeploy.getClusterId() + \", hostId: \" + planToDeploy.getHostId() + \", poolId: \" + planToDeploy.getPoolId());\n            }\n            plan =\n                    new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(), planToDeploy.getHostId(),\n                            planToDeploy.getPoolId(), planToDeploy.getPhysicalNetworkId(), ctx);\n        }\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        \r\n        final Account owner = _entityMgr.findById(Account.class, vm.getAccountId());\n        if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n            resourceCountIncrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n        }\n\n        boolean canRetry = true;\n        ExcludeList avoids = null;\n        try {\n            final Journal journal = start.second().getJournal();\n\n            if (planToDeploy != null) {\n                avoids = planToDeploy.getAvoids();\n            }\n            if (avoids == null) {\n                avoids = new ExcludeList();\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Deploy avoids pods: \" + avoids.getPodsToAvoid() + \", clusters: \" + avoids.getClustersToAvoid() + \", hosts: \" + avoids.getHostsToAvoid());\n            }\n\n            boolean planChangedByVolume = false;\n            boolean reuseVolume = true;\n            final DataCenterDeployment originalPlan = plan;\n\n            int retry = StartRetry.value();\n            while (retry-- != 0) { \r\n\n                if (reuseVolume) {\n                    \r\n                    final List<VolumeVO> vols = _volsDao.findReadyRootVolumesByInstance(vm.getId());\n                    for (final VolumeVO vol : vols) {\n                        \r\n                        \r\n                        \r\n                        final Long volTemplateId = vol.getTemplateId();\n                        if (volTemplateId != null && volTemplateId.longValue() != template.getId()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(vol + \" of \" + vm + \" is READY, but template ids don't match, let the planner reassign a new pool\");\n                            }\n                            continue;\n                        }\n\n                        final StoragePool pool = (StoragePool)dataStoreMgr.getPrimaryDataStore(vol.getPoolId());\n                        if (!pool.isInMaintenance()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Root volume is ready, need to place VM in volume's cluster\");\n                            }\n                            final long rootVolDcId = pool.getDataCenterId();\n                            final Long rootVolPodId = pool.getPodId();\n                            final Long rootVolClusterId = pool.getClusterId();\n                            if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n                                final Long clusterIdSpecified = planToDeploy.getClusterId();\n                                if (clusterIdSpecified != null && rootVolClusterId != null) {\n                                    if (rootVolClusterId.longValue() != clusterIdSpecified.longValue()) {\n                                        \r\n                                        \r\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"Cannot satisfy the deployment plan passed in since the ready Root volume is in different cluster. volume's cluster: \" +\n                                                    rootVolClusterId + \", cluster specified: \" + clusterIdSpecified);\n                                        }\n                                        throw new ResourceUnavailableException(\n                                                \"Root volume is ready in different cluster, Deployment plan provided cannot be satisfied, unable to create a deployment for \" +\n                                                        vm, Cluster.class, clusterIdSpecified);\n                                    }\n                                }\n                                plan =\n                                        new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(),\n                                                planToDeploy.getHostId(), vol.getPoolId(), null, ctx);\n                            } else {\n                                plan = new DataCenterDeployment(rootVolDcId, rootVolPodId, rootVolClusterId, null, vol.getPoolId(), null, ctx);\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(vol + \" is READY, changing deployment plan to use this pool's dcId: \" + rootVolDcId + \" , podId: \" + rootVolPodId +\n                                            \" , and clusterId: \" + rootVolClusterId);\n                                }\n                                planChangedByVolume = true;\n                            }\n                        }\n                    }\n                }\n\n                final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vm, template, offering, owner, params);\n                logBootModeParameters(params);\n                DeployDestination dest = null;\n                try {\n                    dest = _dpMgr.planDeployment(vmProfile, plan, avoids, planner);\n                } catch (final AffinityConflictException e2) {\n                    s_logger.warn(\"Unable to create deployment, affinity rules associted to the VM conflict\", e2);\n                    throw new CloudRuntimeException(\"Unable to create deployment, affinity rules associted to the VM conflict\");\n                }\n\n                if (dest == null) {\n                    if (planChangedByVolume) {\n                        plan = originalPlan;\n                        planChangedByVolume = false;\n                        \r\n                        reuseVolume = false;\n                        continue;\n                    }\n                    throw new InsufficientServerCapacityException(\"Unable to create a deployment for \" + vmProfile, DataCenter.class, plan.getDataCenterId(),\n                            areAffinityGroupsAssociated(vmProfile));\n                }\n\n                if (dest != null) {\n                    avoids.addHost(dest.getHost().getId());\n                    journal.record(\"Deployment found \", vmProfile, dest);\n                }\n\n                long destHostId = dest.getHost().getId();\n                vm.setPodIdToDeployIn(dest.getPod().getId());\n                final Long cluster_id = dest.getCluster().getId();\n                final ClusterDetailsVO cluster_detail_cpu = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                final ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                \r\n                if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) == null &&\n                        (Float.parseFloat(cluster_detail_cpu.getValue()) > 1f || Float.parseFloat(cluster_detail_ram.getValue()) > 1f)) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                } else if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) != null) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                }\n\n                vmProfile.setCpuOvercommitRatio(Float.parseFloat(cluster_detail_cpu.getValue()));\n                vmProfile.setMemoryOvercommitRatio(Float.parseFloat(cluster_detail_ram.getValue()));\n                StartAnswer startAnswer = null;\n\n                try {\n                    if (!changeState(vm, Event.OperationRetry, destHostId, work, Step.Prepare)) {\n                        throw new ConcurrentOperationException(\"Unable to update the state of the Virtual Machine \"+vm.getUuid()+\" oldstate: \"+vm.getState()+ \"Event :\"+Event.OperationRetry);\n                    }\n                } catch (final NoTransitionException e1) {\n                    throw new ConcurrentOperationException(e1.getMessage());\n                }\n\n                try {\n                    _networkMgr.prepare(vmProfile, new DeployDestination(dest.getDataCenter(), dest.getPod(), null, null, dest.getStorageForDisks()), ctx);\n                    if (vm.getHypervisorType() != HypervisorType.BareMetal) {\n                        volumeMgr.prepare(vmProfile, dest);\n                    }\n\n                    \r\n                    if (!reuseVolume) {\n                        reuseVolume = true;\n                    }\n\n                    Commands cmds = null;\n                    vmGuru.finalizeVirtualMachineProfile(vmProfile, dest, ctx);\n\n                    final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);\n\n                    checkAndSetEnterSetupMode(vmTO, params);\n\n                    handlePath(vmTO.getDisks(), vm.getHypervisorType());\n\n                    cmds = new Commands(Command.OnError.Stop);\n\n                    cmds.addCommand(new StartCommand(vmTO, dest.getHost(), getExecuteInSequence(vm.getHypervisorType())));\n\n                    vmGuru.finalizeDeployment(cmds, vmProfile, dest, ctx);\n\n                    \r\n                    addExtraConfig(vmTO);\n\n                    work = _workDao.findById(work.getId());\n                    if (work == null || work.getStep() != Step.Prepare) {\n                        throw new ConcurrentOperationException(\"Work steps have been changed: \" + work);\n                    }\n\n                    _workDao.updateStep(work, Step.Starting);\n\n                    _agentMgr.send(destHostId, cmds);\n\n                    _workDao.updateStep(work, Step.Started);\n\n                    startAnswer = cmds.getAnswer(StartAnswer.class);\n                    if (startAnswer != null && startAnswer.getResult()) {\n                        handlePath(vmTO.getDisks(), startAnswer.getIqnToData());\n\n                        final String host_guid = startAnswer.getHost_guid();\n\n                        if (host_guid != null) {\n                            final HostVO finalHost = _resourceMgr.findHostByGuid(host_guid);\n                            if (finalHost == null) {\n                                throw new CloudRuntimeException(\"Host Guid \" + host_guid + \" doesn't exist in DB, something went wrong while processing start answer: \"+startAnswer);\n                            }\n                            destHostId = finalHost.getId();\n                        }\n                        if (vmGuru.finalizeStart(vmProfile, destHostId, cmds, ctx)) {\n                            syncDiskChainChange(startAnswer);\n\n                            if (!changeState(vm, Event.OperationSucceeded, destHostId, work, Step.Done)) {\n                                s_logger.error(\"Unable to transition to a new state. VM uuid: \"+vm.getUuid()+    \"VM oldstate:\"+vm.getState()+\"Event:\"+Event.OperationSucceeded);\n                                throw new ConcurrentOperationException(\"Failed to deploy VM\"+ vm.getUuid());\n                            }\n\n                            \r\n                            final GPUDeviceTO gpuDevice = startAnswer.getVirtualMachine().getGpuDevice();\n                            if (gpuDevice != null) {\n                                _resourceMgr.updateGPUDetails(destHostId, gpuDevice.getGroupDetails());\n                            }\n\n                            \r\n                            \r\n                            \r\n                            if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.DEPLOY_VM) != null) {\n                                userVmDetailsDao.removeDetail(vm.getId(), VmDetailConstants.DEPLOY_VM);\n                            }\n\n                            startedVm = vm;\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Start completed for VM \" + vm);\n                            }\n                            final Host vmHost = _hostDao.findById(destHostId);\n                            if (vmHost != null && (VirtualMachine.Type.ConsoleProxy.equals(vm.getType()) ||\n                                    VirtualMachine.Type.SecondaryStorageVm.equals(vm.getType())) && caManager.canProvisionCertificates()) {\n                                final Map<String, String> sshAccessDetails = _networkMgr.getSystemVMAccessDetails(vm);\n                                for (int retries = 3; retries > 0; retries--) {\n                                    try {\n                                        setupAgentSecurity(vmHost, sshAccessDetails, vm);\n                                        return;\n                                    } catch (final Exception e) {\n                                        s_logger.error(\"Retrying after catching exception while trying to secure agent for systemvm id=\" + vm.getId(), e);\n                                    }\n                                }\n                                throw new CloudRuntimeException(\"Failed to setup and secure agent for systemvm id=\" + vm.getId());\n                            }\n                            return;\n                        } else {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.info(\"The guru did not like the answers so stopping \" + vm);\n                            }\n                            StopCommand stopCmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n                            stopCmd.setControlIp(getControlNicIpForVM(vm));\n                            final StopCommand cmd = stopCmd;\n                            final Answer answer = _agentMgr.easySend(destHostId, cmd);\n                            if (answer != null && answer instanceof StopAnswer) {\n                                final StopAnswer stopAns = (StopAnswer)answer;\n                                if (vm.getType() == VirtualMachine.Type.User) {\n                                    final String platform = stopAns.getPlatform();\n                                    if (platform != null) {\n                                        final Map<String,String> vmmetadata = new HashMap<String,String>();\n                                        vmmetadata.put(vm.getInstanceName(), platform);\n                                        syncVMMetaData(vmmetadata);\n                                    }\n                                }\n                            }\n\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.warn(\"Unable to stop \" + vm + \" due to \" + (answer != null ? answer.getDetails() : \"no answers\"));\n                                _haMgr.scheduleStop(vm, destHostId, WorkType.ForceStop);\n                                throw new ExecutionException(\"Unable to stop this VM, \"+vm.getUuid()+\" so we are unable to retry the start operation\");\n                            }\n                            throw new ExecutionException(\"Unable to start  VM:\"+vm.getUuid()+\" due to error in finalizeStart, not retrying\");\n                        }\n                    }\n                    s_logger.info(\"Unable to start VM on \" + dest.getHost() + \" due to \" + (startAnswer == null ? \" no start answer\" : startAnswer.getDetails()));\n                    if (startAnswer != null && startAnswer.getContextParam(\"stopRetry\") != null) {\n                        break;\n                    }\n\n                } catch (OperationTimedoutException e) {\n                    s_logger.debug(\"Unable to send the start command to host \" + dest.getHost()+\" failed to start VM: \"+vm.getUuid());\n                    if (e.isActive()) {\n                        _haMgr.scheduleStop(vm, destHostId, WorkType.CheckStop);\n                    }\n                    canRetry = false;\n                    throw new AgentUnavailableException(\"Unable to start \" + vm.getHostName(), destHostId, e);\n                } catch (final ResourceUnavailableException e) {\n                    s_logger.info(\"Unable to contact resource.\", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected ResourceUnavailableException : \" + e.getScope().getName(), e);\n                            throw e;\n                        }\n                    }\n                } catch (final InsufficientCapacityException e) {\n                    s_logger.info(\"Insufficient capacity \", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected InsufficientCapacityException : \" + e.getScope().getName(), e);\n                        }\n                    }\n                } catch (final ExecutionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final NoTransitionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } finally {\n                    if (startedVm == null && canRetry) {\n                        final Step prevStep = work.getStep();\n                        _workDao.updateStep(work, Step.Release);\n                        \r\n                        if ((prevStep == Step.Started || prevStep == Step.Starting) && startAnswer != null && startAnswer.getResult()) {  \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, false);\n                        } else {\n                            \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, true);\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (startedVm == null) {\n                if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n                    resourceCountDecrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n                }\n                if (canRetry) {\n                    try {\n                        changeState(vm, Event.OperationFailed, null, work, Step.Done);\n                    } catch (final NoTransitionException e) {\n                        throw new ConcurrentOperationException(e.getMessage());\n                    }\n                }\n            }\n\n            if (planToDeploy != null) {\n                planToDeploy.setAvoids(avoids);\n            }\n        }\n\n        if (startedVm == null) {\n            throw new CloudRuntimeException(\"Unable to start instance '\" + vm.getHostName() + \"' (\" + vm.getUuid() + \"), see management server log for details\");\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":964,"status":"M"},{"authorDate":"2019-06-25 23:23:09","commitOrder":11,"curCode":"    public Command cleanup(final VirtualMachine vm, Map<String, DpdkTO> dpdkInterfaceMapping) {\n        StopCommand cmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n        cmd.setControlIp(getControlNicIpForVM(vm));\n        if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n            cmd.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n        }\n        return cmd;\n    }\n","date":"2019-06-25 23:23:09","endLine":3112,"groupId":"25415","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"cleanup","params":"(finalVirtualMachinevm@Map<String@DpdkTO>dpdkInterfaceMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/79/5705345962a468ec5b626e71be73e2c2815950.src","preCode":"    public Command cleanup(final VirtualMachine vm, Map<String, DpdkTO> dpdkInterfaceMapping) {\n        StopCommand cmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n        cmd.setControlIp(getControlNicIpForVM(vm));\n        if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n            cmd.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n        }\n        return cmd;\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":3105,"status":"N"}],"commitId":"db665fa8dfa5e83a198e6c40d95495135dad879d","commitMessage":"@@@Merge remote-tracking branch 'origin/4.14'\n\n Conflicts:\n\tengine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java\n\nSigned-off-by: Rohit Yadav <rohit.yadav@shapeblue.com>\n","date":"2020-08-05 17:16:13","modifiedFileCount":"5","status":"M","submitter":"Rohit Yadav"},{"authorTime":"2019-06-25 23:23:09","codes":[{"authorDate":"2020-10-26 21:24:14","commitOrder":12,"curCode":"    public void orchestrateStart(final String vmUuid, final Map<VirtualMachineProfile.Param, Object> params, final DeploymentPlan planToDeploy, final DeploymentPlanner planner)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {\n\n        final CallContext cctxt = CallContext.current();\n        final Account account = cctxt.getCallingAccount();\n        final User caller = cctxt.getCallingUser();\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final Ternary<VMInstanceVO, ReservationContext, ItWorkVO> start = changeToStartState(vmGuru, vm, caller, account);\n        if (start == null) {\n            return;\n        }\n\n        vm = start.first();\n        final ReservationContext ctx = start.second();\n        ItWorkVO work = start.third();\n\n        VMInstanceVO startedVm = null;\n        final ServiceOfferingVO offering = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());\n        final VirtualMachineTemplate template = _entityMgr.findByIdIncludingRemoved(VirtualMachineTemplate.class, vm.getTemplateId());\n\n        DataCenterDeployment plan = new DataCenterDeployment(vm.getDataCenterId(), vm.getPodIdToDeployIn(), null, null, null, null, ctx);\n        if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"advanceStart: DeploymentPlan is provided, using dcId:\" + planToDeploy.getDataCenterId() + \", podId: \" + planToDeploy.getPodId() +\n                        \", clusterId: \" + planToDeploy.getClusterId() + \", hostId: \" + planToDeploy.getHostId() + \", poolId: \" + planToDeploy.getPoolId());\n            }\n            plan =\n                    new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(), planToDeploy.getHostId(),\n                            planToDeploy.getPoolId(), planToDeploy.getPhysicalNetworkId(), ctx);\n        }\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        \r\n        final Account owner = _entityMgr.findById(Account.class, vm.getAccountId());\n        if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n            resourceCountIncrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n        }\n\n        boolean canRetry = true;\n        ExcludeList avoids = null;\n        try {\n            final Journal journal = start.second().getJournal();\n\n            if (planToDeploy != null) {\n                avoids = planToDeploy.getAvoids();\n            }\n            if (avoids == null) {\n                avoids = new ExcludeList();\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Deploy avoids pods: \" + avoids.getPodsToAvoid() + \", clusters: \" + avoids.getClustersToAvoid() + \", hosts: \" + avoids.getHostsToAvoid());\n            }\n\n            boolean planChangedByVolume = false;\n            boolean reuseVolume = true;\n            final DataCenterDeployment originalPlan = plan;\n\n            int retry = StartRetry.value();\n            while (retry-- != 0) { \r\n\n                if (reuseVolume) {\n                    \r\n                    final List<VolumeVO> vols = _volsDao.findReadyRootVolumesByInstance(vm.getId());\n                    for (final VolumeVO vol : vols) {\n                        \r\n                        \r\n                        \r\n                        final Long volTemplateId = vol.getTemplateId();\n                        if (volTemplateId != null && volTemplateId.longValue() != template.getId()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(vol + \" of \" + vm + \" is READY, but template ids don't match, let the planner reassign a new pool\");\n                            }\n                            continue;\n                        }\n\n                        final StoragePool pool = (StoragePool)dataStoreMgr.getPrimaryDataStore(vol.getPoolId());\n                        if (!pool.isInMaintenance()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Root volume is ready, need to place VM in volume's cluster\");\n                            }\n                            final long rootVolDcId = pool.getDataCenterId();\n                            final Long rootVolPodId = pool.getPodId();\n                            final Long rootVolClusterId = pool.getClusterId();\n                            if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n                                final Long clusterIdSpecified = planToDeploy.getClusterId();\n                                if (clusterIdSpecified != null && rootVolClusterId != null) {\n                                    if (rootVolClusterId.longValue() != clusterIdSpecified.longValue()) {\n                                        \r\n                                        \r\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"Cannot satisfy the deployment plan passed in since the ready Root volume is in different cluster. volume's cluster: \" +\n                                                    rootVolClusterId + \", cluster specified: \" + clusterIdSpecified);\n                                        }\n                                        throw new ResourceUnavailableException(\n                                                \"Root volume is ready in different cluster, Deployment plan provided cannot be satisfied, unable to create a deployment for \" +\n                                                        vm, Cluster.class, clusterIdSpecified);\n                                    }\n                                }\n                                plan =\n                                        new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(),\n                                                planToDeploy.getHostId(), vol.getPoolId(), null, ctx);\n                            } else {\n                                plan = new DataCenterDeployment(rootVolDcId, rootVolPodId, rootVolClusterId, null, vol.getPoolId(), null, ctx);\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(vol + \" is READY, changing deployment plan to use this pool's dcId: \" + rootVolDcId + \" , podId: \" + rootVolPodId +\n                                            \" , and clusterId: \" + rootVolClusterId);\n                                }\n                                planChangedByVolume = true;\n                            }\n                        }\n                    }\n                }\n\n                final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vm, template, offering, owner, params);\n                logBootModeParameters(params);\n                DeployDestination dest = null;\n                try {\n                    dest = _dpMgr.planDeployment(vmProfile, plan, avoids, planner);\n                } catch (final AffinityConflictException e2) {\n                    s_logger.warn(\"Unable to create deployment, affinity rules associted to the VM conflict\", e2);\n                    throw new CloudRuntimeException(\"Unable to create deployment, affinity rules associted to the VM conflict\");\n                }\n\n                if (dest == null) {\n                    if (planChangedByVolume) {\n                        plan = originalPlan;\n                        planChangedByVolume = false;\n                        \r\n                        reuseVolume = false;\n                        continue;\n                    }\n                    throw new InsufficientServerCapacityException(\"Unable to create a deployment for \" + vmProfile, DataCenter.class, plan.getDataCenterId(),\n                            areAffinityGroupsAssociated(vmProfile));\n                }\n\n                if (dest != null) {\n                    avoids.addHost(dest.getHost().getId());\n                    if (!template.isDeployAsIs()) {\n                        journal.record(\"Deployment found \", vmProfile, dest);\n                    }\n                }\n\n                long destHostId = dest.getHost().getId();\n                vm.setPodIdToDeployIn(dest.getPod().getId());\n                final Long cluster_id = dest.getCluster().getId();\n                final ClusterDetailsVO cluster_detail_cpu = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                final ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                \r\n                if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) == null &&\n                        (Float.parseFloat(cluster_detail_cpu.getValue()) > 1f || Float.parseFloat(cluster_detail_ram.getValue()) > 1f)) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                } else if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) != null) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                }\n\n                vmProfile.setCpuOvercommitRatio(Float.parseFloat(cluster_detail_cpu.getValue()));\n                vmProfile.setMemoryOvercommitRatio(Float.parseFloat(cluster_detail_ram.getValue()));\n                StartAnswer startAnswer = null;\n\n                try {\n                    if (!changeState(vm, Event.OperationRetry, destHostId, work, Step.Prepare)) {\n                        throw new ConcurrentOperationException(\"Unable to update the state of the Virtual Machine \"+vm.getUuid()+\" oldstate: \"+vm.getState()+ \"Event :\"+Event.OperationRetry);\n                    }\n                } catch (final NoTransitionException e1) {\n                    throw new ConcurrentOperationException(e1.getMessage());\n                }\n\n                try {\n                    resetVmNicsDeviceId(vm.getId());\n                    _networkMgr.prepare(vmProfile, new DeployDestination(dest.getDataCenter(), dest.getPod(), null, null, dest.getStorageForDisks(), dest.isDisplayStorage()), ctx);\n                    if (vm.getHypervisorType() != HypervisorType.BareMetal) {\n                        volumeMgr.prepare(vmProfile, dest);\n                    }\n\n                    \r\n                    if (!reuseVolume) {\n                        reuseVolume = true;\n                    }\n\n                    Commands cmds = null;\n                    vmGuru.finalizeVirtualMachineProfile(vmProfile, dest, ctx);\n\n                    final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);\n\n                    checkAndSetEnterSetupMode(vmTO, params);\n\n                    handlePath(vmTO.getDisks(), vm.getHypervisorType());\n\n                    cmds = new Commands(Command.OnError.Stop);\n\n                    cmds.addCommand(new StartCommand(vmTO, dest.getHost(), getExecuteInSequence(vm.getHypervisorType())));\n\n                    vmGuru.finalizeDeployment(cmds, vmProfile, dest, ctx);\n\n                    \r\n                    addExtraConfig(vmTO);\n\n                    work = _workDao.findById(work.getId());\n                    if (work == null || work.getStep() != Step.Prepare) {\n                        throw new ConcurrentOperationException(\"Work steps have been changed: \" + work);\n                    }\n\n                    _workDao.updateStep(work, Step.Starting);\n\n                    _agentMgr.send(destHostId, cmds);\n\n                    _workDao.updateStep(work, Step.Started);\n\n                    startAnswer = cmds.getAnswer(StartAnswer.class);\n                    if (startAnswer != null && startAnswer.getResult()) {\n                        handlePath(vmTO.getDisks(), startAnswer.getIqnToData());\n\n                        final String host_guid = startAnswer.getHost_guid();\n\n                        if (host_guid != null) {\n                            final HostVO finalHost = _resourceMgr.findHostByGuid(host_guid);\n                            if (finalHost == null) {\n                                throw new CloudRuntimeException(\"Host Guid \" + host_guid + \" doesn't exist in DB, something went wrong while processing start answer: \"+startAnswer);\n                            }\n                            destHostId = finalHost.getId();\n                        }\n                        if (vmGuru.finalizeStart(vmProfile, destHostId, cmds, ctx)) {\n                            syncDiskChainChange(startAnswer);\n\n                            if (!changeState(vm, Event.OperationSucceeded, destHostId, work, Step.Done)) {\n                                s_logger.error(\"Unable to transition to a new state. VM uuid: \"+vm.getUuid()+    \"VM oldstate:\"+vm.getState()+\"Event:\"+Event.OperationSucceeded);\n                                throw new ConcurrentOperationException(\"Failed to deploy VM\"+ vm.getUuid());\n                            }\n\n                            \r\n                            final GPUDeviceTO gpuDevice = startAnswer.getVirtualMachine().getGpuDevice();\n                            if (gpuDevice != null) {\n                                _resourceMgr.updateGPUDetails(destHostId, gpuDevice.getGroupDetails());\n                            }\n\n                            \r\n                            \r\n                            \r\n                            if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.DEPLOY_VM) != null) {\n                                userVmDetailsDao.removeDetail(vm.getId(), VmDetailConstants.DEPLOY_VM);\n                            }\n\n                            startedVm = vm;\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Start completed for VM \" + vm);\n                            }\n                            final Host vmHost = _hostDao.findById(destHostId);\n                            if (vmHost != null && (VirtualMachine.Type.ConsoleProxy.equals(vm.getType()) ||\n                                    VirtualMachine.Type.SecondaryStorageVm.equals(vm.getType())) && caManager.canProvisionCertificates()) {\n                                final Map<String, String> sshAccessDetails = _networkMgr.getSystemVMAccessDetails(vm);\n                                for (int retries = 3; retries > 0; retries--) {\n                                    try {\n                                        setupAgentSecurity(vmHost, sshAccessDetails, vm);\n                                        return;\n                                    } catch (final Exception e) {\n                                        s_logger.error(\"Retrying after catching exception while trying to secure agent for systemvm id=\" + vm.getId(), e);\n                                    }\n                                }\n                                throw new CloudRuntimeException(\"Failed to setup and secure agent for systemvm id=\" + vm.getId());\n                            }\n                            return;\n                        } else {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.info(\"The guru did not like the answers so stopping \" + vm);\n                            }\n                            StopCommand stopCmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n                            stopCmd.setControlIp(getControlNicIpForVM(vm));\n                            final StopCommand cmd = stopCmd;\n                            final Answer answer = _agentMgr.easySend(destHostId, cmd);\n                            if (answer != null && answer instanceof StopAnswer) {\n                                final StopAnswer stopAns = (StopAnswer)answer;\n                                if (vm.getType() == VirtualMachine.Type.User) {\n                                    final String platform = stopAns.getPlatform();\n                                    if (platform != null) {\n                                        final Map<String,String> vmmetadata = new HashMap<String,String>();\n                                        vmmetadata.put(vm.getInstanceName(), platform);\n                                        syncVMMetaData(vmmetadata);\n                                    }\n                                }\n                            }\n\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.warn(\"Unable to stop \" + vm + \" due to \" + (answer != null ? answer.getDetails() : \"no answers\"));\n                                _haMgr.scheduleStop(vm, destHostId, WorkType.ForceStop);\n                                throw new ExecutionException(\"Unable to stop this VM, \"+vm.getUuid()+\" so we are unable to retry the start operation\");\n                            }\n                            throw new ExecutionException(\"Unable to start  VM:\"+vm.getUuid()+\" due to error in finalizeStart, not retrying\");\n                        }\n                    }\n                    s_logger.info(\"Unable to start VM on \" + dest.getHost() + \" due to \" + (startAnswer == null ? \" no start answer\" : startAnswer.getDetails()));\n                    if (startAnswer != null && startAnswer.getContextParam(\"stopRetry\") != null) {\n                        break;\n                    }\n\n                } catch (OperationTimedoutException e) {\n                    s_logger.debug(\"Unable to send the start command to host \" + dest.getHost()+\" failed to start VM: \"+vm.getUuid());\n                    if (e.isActive()) {\n                        _haMgr.scheduleStop(vm, destHostId, WorkType.CheckStop);\n                    }\n                    canRetry = false;\n                    throw new AgentUnavailableException(\"Unable to start \" + vm.getHostName(), destHostId, e);\n                } catch (final ResourceUnavailableException e) {\n                    s_logger.info(\"Unable to contact resource.\", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected ResourceUnavailableException : \" + e.getScope().getName(), e);\n                            throw e;\n                        }\n                    }\n                } catch (final InsufficientCapacityException e) {\n                    s_logger.info(\"Insufficient capacity \", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected InsufficientCapacityException : \" + e.getScope().getName(), e);\n                        }\n                    }\n                } catch (final ExecutionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final NoTransitionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } finally {\n                    if (startedVm == null && canRetry) {\n                        final Step prevStep = work.getStep();\n                        _workDao.updateStep(work, Step.Release);\n                        \r\n                        if ((prevStep == Step.Started || prevStep == Step.Starting) && startAnswer != null && startAnswer.getResult()) {  \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, false);\n                        } else {\n                            \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, true);\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (startedVm == null) {\n                if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n                    resourceCountDecrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n                }\n                if (canRetry) {\n                    try {\n                        changeState(vm, Event.OperationFailed, null, work, Step.Done);\n                    } catch (final NoTransitionException e) {\n                        throw new ConcurrentOperationException(e.getMessage());\n                    }\n                }\n            }\n\n            if (planToDeploy != null) {\n                planToDeploy.setAvoids(avoids);\n            }\n        }\n\n        if (startedVm == null) {\n            throw new CloudRuntimeException(\"Unable to start instance '\" + vm.getHostName() + \"' (\" + vm.getUuid() + \"), see management server log for details\");\n        }\n    }\n","date":"2020-10-26 21:24:14","endLine":1342,"groupId":"4255","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"orchestrateStart","params":"(finalStringvmUuid@finalMap<VirtualMachineProfile.Param@Object>params@finalDeploymentPlanplanToDeploy@finalDeploymentPlannerplanner)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/8e/9ec450b1ed7b3b97645bd472313fd926bfc998.src","preCode":"    public void orchestrateStart(final String vmUuid, final Map<VirtualMachineProfile.Param, Object> params, final DeploymentPlan planToDeploy, final DeploymentPlanner planner)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {\n\n        final CallContext cctxt = CallContext.current();\n        final Account account = cctxt.getCallingAccount();\n        final User caller = cctxt.getCallingUser();\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final Ternary<VMInstanceVO, ReservationContext, ItWorkVO> start = changeToStartState(vmGuru, vm, caller, account);\n        if (start == null) {\n            return;\n        }\n\n        vm = start.first();\n        final ReservationContext ctx = start.second();\n        ItWorkVO work = start.third();\n\n        VMInstanceVO startedVm = null;\n        final ServiceOfferingVO offering = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());\n        final VirtualMachineTemplate template = _entityMgr.findByIdIncludingRemoved(VirtualMachineTemplate.class, vm.getTemplateId());\n\n        DataCenterDeployment plan = new DataCenterDeployment(vm.getDataCenterId(), vm.getPodIdToDeployIn(), null, null, null, null, ctx);\n        if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"advanceStart: DeploymentPlan is provided, using dcId:\" + planToDeploy.getDataCenterId() + \", podId: \" + planToDeploy.getPodId() +\n                        \", clusterId: \" + planToDeploy.getClusterId() + \", hostId: \" + planToDeploy.getHostId() + \", poolId: \" + planToDeploy.getPoolId());\n            }\n            plan =\n                    new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(), planToDeploy.getHostId(),\n                            planToDeploy.getPoolId(), planToDeploy.getPhysicalNetworkId(), ctx);\n        }\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        \r\n        final Account owner = _entityMgr.findById(Account.class, vm.getAccountId());\n        if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n            resourceCountIncrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n        }\n\n        boolean canRetry = true;\n        ExcludeList avoids = null;\n        try {\n            final Journal journal = start.second().getJournal();\n\n            if (planToDeploy != null) {\n                avoids = planToDeploy.getAvoids();\n            }\n            if (avoids == null) {\n                avoids = new ExcludeList();\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Deploy avoids pods: \" + avoids.getPodsToAvoid() + \", clusters: \" + avoids.getClustersToAvoid() + \", hosts: \" + avoids.getHostsToAvoid());\n            }\n\n            boolean planChangedByVolume = false;\n            boolean reuseVolume = true;\n            final DataCenterDeployment originalPlan = plan;\n\n            int retry = StartRetry.value();\n            while (retry-- != 0) { \r\n\n                if (reuseVolume) {\n                    \r\n                    final List<VolumeVO> vols = _volsDao.findReadyRootVolumesByInstance(vm.getId());\n                    for (final VolumeVO vol : vols) {\n                        \r\n                        \r\n                        \r\n                        final Long volTemplateId = vol.getTemplateId();\n                        if (volTemplateId != null && volTemplateId.longValue() != template.getId()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(vol + \" of \" + vm + \" is READY, but template ids don't match, let the planner reassign a new pool\");\n                            }\n                            continue;\n                        }\n\n                        final StoragePool pool = (StoragePool)dataStoreMgr.getPrimaryDataStore(vol.getPoolId());\n                        if (!pool.isInMaintenance()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Root volume is ready, need to place VM in volume's cluster\");\n                            }\n                            final long rootVolDcId = pool.getDataCenterId();\n                            final Long rootVolPodId = pool.getPodId();\n                            final Long rootVolClusterId = pool.getClusterId();\n                            if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n                                final Long clusterIdSpecified = planToDeploy.getClusterId();\n                                if (clusterIdSpecified != null && rootVolClusterId != null) {\n                                    if (rootVolClusterId.longValue() != clusterIdSpecified.longValue()) {\n                                        \r\n                                        \r\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"Cannot satisfy the deployment plan passed in since the ready Root volume is in different cluster. volume's cluster: \" +\n                                                    rootVolClusterId + \", cluster specified: \" + clusterIdSpecified);\n                                        }\n                                        throw new ResourceUnavailableException(\n                                                \"Root volume is ready in different cluster, Deployment plan provided cannot be satisfied, unable to create a deployment for \" +\n                                                        vm, Cluster.class, clusterIdSpecified);\n                                    }\n                                }\n                                plan =\n                                        new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(),\n                                                planToDeploy.getHostId(), vol.getPoolId(), null, ctx);\n                            } else {\n                                plan = new DataCenterDeployment(rootVolDcId, rootVolPodId, rootVolClusterId, null, vol.getPoolId(), null, ctx);\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(vol + \" is READY, changing deployment plan to use this pool's dcId: \" + rootVolDcId + \" , podId: \" + rootVolPodId +\n                                            \" , and clusterId: \" + rootVolClusterId);\n                                }\n                                planChangedByVolume = true;\n                            }\n                        }\n                    }\n                }\n\n                final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vm, template, offering, owner, params);\n                logBootModeParameters(params);\n                DeployDestination dest = null;\n                try {\n                    dest = _dpMgr.planDeployment(vmProfile, plan, avoids, planner);\n                } catch (final AffinityConflictException e2) {\n                    s_logger.warn(\"Unable to create deployment, affinity rules associted to the VM conflict\", e2);\n                    throw new CloudRuntimeException(\"Unable to create deployment, affinity rules associted to the VM conflict\");\n                }\n\n                if (dest == null) {\n                    if (planChangedByVolume) {\n                        plan = originalPlan;\n                        planChangedByVolume = false;\n                        \r\n                        reuseVolume = false;\n                        continue;\n                    }\n                    throw new InsufficientServerCapacityException(\"Unable to create a deployment for \" + vmProfile, DataCenter.class, plan.getDataCenterId(),\n                            areAffinityGroupsAssociated(vmProfile));\n                }\n\n                if (dest != null) {\n                    avoids.addHost(dest.getHost().getId());\n                    journal.record(\"Deployment found \", vmProfile, dest);\n                }\n\n                long destHostId = dest.getHost().getId();\n                vm.setPodIdToDeployIn(dest.getPod().getId());\n                final Long cluster_id = dest.getCluster().getId();\n                final ClusterDetailsVO cluster_detail_cpu = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                final ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                \r\n                if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) == null &&\n                        (Float.parseFloat(cluster_detail_cpu.getValue()) > 1f || Float.parseFloat(cluster_detail_ram.getValue()) > 1f)) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                } else if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) != null) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                }\n\n                vmProfile.setCpuOvercommitRatio(Float.parseFloat(cluster_detail_cpu.getValue()));\n                vmProfile.setMemoryOvercommitRatio(Float.parseFloat(cluster_detail_ram.getValue()));\n                StartAnswer startAnswer = null;\n\n                try {\n                    if (!changeState(vm, Event.OperationRetry, destHostId, work, Step.Prepare)) {\n                        throw new ConcurrentOperationException(\"Unable to update the state of the Virtual Machine \"+vm.getUuid()+\" oldstate: \"+vm.getState()+ \"Event :\"+Event.OperationRetry);\n                    }\n                } catch (final NoTransitionException e1) {\n                    throw new ConcurrentOperationException(e1.getMessage());\n                }\n\n                try {\n                    resetVmNicsDeviceId(vm.getId());\n                    _networkMgr.prepare(vmProfile, new DeployDestination(dest.getDataCenter(), dest.getPod(), null, null, dest.getStorageForDisks()), ctx);\n                    if (vm.getHypervisorType() != HypervisorType.BareMetal) {\n                        volumeMgr.prepare(vmProfile, dest);\n                    }\n\n                    \r\n                    if (!reuseVolume) {\n                        reuseVolume = true;\n                    }\n\n                    Commands cmds = null;\n                    vmGuru.finalizeVirtualMachineProfile(vmProfile, dest, ctx);\n\n                    final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);\n\n                    checkAndSetEnterSetupMode(vmTO, params);\n\n                    handlePath(vmTO.getDisks(), vm.getHypervisorType());\n\n                    cmds = new Commands(Command.OnError.Stop);\n\n                    cmds.addCommand(new StartCommand(vmTO, dest.getHost(), getExecuteInSequence(vm.getHypervisorType())));\n\n                    vmGuru.finalizeDeployment(cmds, vmProfile, dest, ctx);\n\n                    \r\n                    addExtraConfig(vmTO);\n\n                    work = _workDao.findById(work.getId());\n                    if (work == null || work.getStep() != Step.Prepare) {\n                        throw new ConcurrentOperationException(\"Work steps have been changed: \" + work);\n                    }\n\n                    _workDao.updateStep(work, Step.Starting);\n\n                    _agentMgr.send(destHostId, cmds);\n\n                    _workDao.updateStep(work, Step.Started);\n\n                    startAnswer = cmds.getAnswer(StartAnswer.class);\n                    if (startAnswer != null && startAnswer.getResult()) {\n                        handlePath(vmTO.getDisks(), startAnswer.getIqnToData());\n\n                        final String host_guid = startAnswer.getHost_guid();\n\n                        if (host_guid != null) {\n                            final HostVO finalHost = _resourceMgr.findHostByGuid(host_guid);\n                            if (finalHost == null) {\n                                throw new CloudRuntimeException(\"Host Guid \" + host_guid + \" doesn't exist in DB, something went wrong while processing start answer: \"+startAnswer);\n                            }\n                            destHostId = finalHost.getId();\n                        }\n                        if (vmGuru.finalizeStart(vmProfile, destHostId, cmds, ctx)) {\n                            syncDiskChainChange(startAnswer);\n\n                            if (!changeState(vm, Event.OperationSucceeded, destHostId, work, Step.Done)) {\n                                s_logger.error(\"Unable to transition to a new state. VM uuid: \"+vm.getUuid()+    \"VM oldstate:\"+vm.getState()+\"Event:\"+Event.OperationSucceeded);\n                                throw new ConcurrentOperationException(\"Failed to deploy VM\"+ vm.getUuid());\n                            }\n\n                            \r\n                            final GPUDeviceTO gpuDevice = startAnswer.getVirtualMachine().getGpuDevice();\n                            if (gpuDevice != null) {\n                                _resourceMgr.updateGPUDetails(destHostId, gpuDevice.getGroupDetails());\n                            }\n\n                            \r\n                            \r\n                            \r\n                            if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.DEPLOY_VM) != null) {\n                                userVmDetailsDao.removeDetail(vm.getId(), VmDetailConstants.DEPLOY_VM);\n                            }\n\n                            startedVm = vm;\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Start completed for VM \" + vm);\n                            }\n                            final Host vmHost = _hostDao.findById(destHostId);\n                            if (vmHost != null && (VirtualMachine.Type.ConsoleProxy.equals(vm.getType()) ||\n                                    VirtualMachine.Type.SecondaryStorageVm.equals(vm.getType())) && caManager.canProvisionCertificates()) {\n                                final Map<String, String> sshAccessDetails = _networkMgr.getSystemVMAccessDetails(vm);\n                                for (int retries = 3; retries > 0; retries--) {\n                                    try {\n                                        setupAgentSecurity(vmHost, sshAccessDetails, vm);\n                                        return;\n                                    } catch (final Exception e) {\n                                        s_logger.error(\"Retrying after catching exception while trying to secure agent for systemvm id=\" + vm.getId(), e);\n                                    }\n                                }\n                                throw new CloudRuntimeException(\"Failed to setup and secure agent for systemvm id=\" + vm.getId());\n                            }\n                            return;\n                        } else {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.info(\"The guru did not like the answers so stopping \" + vm);\n                            }\n                            StopCommand stopCmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n                            stopCmd.setControlIp(getControlNicIpForVM(vm));\n                            final StopCommand cmd = stopCmd;\n                            final Answer answer = _agentMgr.easySend(destHostId, cmd);\n                            if (answer != null && answer instanceof StopAnswer) {\n                                final StopAnswer stopAns = (StopAnswer)answer;\n                                if (vm.getType() == VirtualMachine.Type.User) {\n                                    final String platform = stopAns.getPlatform();\n                                    if (platform != null) {\n                                        final Map<String,String> vmmetadata = new HashMap<String,String>();\n                                        vmmetadata.put(vm.getInstanceName(), platform);\n                                        syncVMMetaData(vmmetadata);\n                                    }\n                                }\n                            }\n\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.warn(\"Unable to stop \" + vm + \" due to \" + (answer != null ? answer.getDetails() : \"no answers\"));\n                                _haMgr.scheduleStop(vm, destHostId, WorkType.ForceStop);\n                                throw new ExecutionException(\"Unable to stop this VM, \"+vm.getUuid()+\" so we are unable to retry the start operation\");\n                            }\n                            throw new ExecutionException(\"Unable to start  VM:\"+vm.getUuid()+\" due to error in finalizeStart, not retrying\");\n                        }\n                    }\n                    s_logger.info(\"Unable to start VM on \" + dest.getHost() + \" due to \" + (startAnswer == null ? \" no start answer\" : startAnswer.getDetails()));\n                    if (startAnswer != null && startAnswer.getContextParam(\"stopRetry\") != null) {\n                        break;\n                    }\n\n                } catch (OperationTimedoutException e) {\n                    s_logger.debug(\"Unable to send the start command to host \" + dest.getHost()+\" failed to start VM: \"+vm.getUuid());\n                    if (e.isActive()) {\n                        _haMgr.scheduleStop(vm, destHostId, WorkType.CheckStop);\n                    }\n                    canRetry = false;\n                    throw new AgentUnavailableException(\"Unable to start \" + vm.getHostName(), destHostId, e);\n                } catch (final ResourceUnavailableException e) {\n                    s_logger.info(\"Unable to contact resource.\", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected ResourceUnavailableException : \" + e.getScope().getName(), e);\n                            throw e;\n                        }\n                    }\n                } catch (final InsufficientCapacityException e) {\n                    s_logger.info(\"Insufficient capacity \", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected InsufficientCapacityException : \" + e.getScope().getName(), e);\n                        }\n                    }\n                } catch (final ExecutionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final NoTransitionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } finally {\n                    if (startedVm == null && canRetry) {\n                        final Step prevStep = work.getStep();\n                        _workDao.updateStep(work, Step.Release);\n                        \r\n                        if ((prevStep == Step.Started || prevStep == Step.Starting) && startAnswer != null && startAnswer.getResult()) {  \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, false);\n                        } else {\n                            \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, true);\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (startedVm == null) {\n                if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n                    resourceCountDecrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n                }\n                if (canRetry) {\n                    try {\n                        changeState(vm, Event.OperationFailed, null, work, Step.Done);\n                    } catch (final NoTransitionException e) {\n                        throw new ConcurrentOperationException(e.getMessage());\n                    }\n                }\n            }\n\n            if (planToDeploy != null) {\n                planToDeploy.setAvoids(avoids);\n            }\n        }\n\n        if (startedVm == null) {\n            throw new CloudRuntimeException(\"Unable to start instance '\" + vm.getHostName() + \"' (\" + vm.getUuid() + \"), see management server log for details\");\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":973,"status":"M"},{"authorDate":"2019-06-25 23:23:09","commitOrder":12,"curCode":"    public Command cleanup(final VirtualMachine vm, Map<String, DpdkTO> dpdkInterfaceMapping) {\n        StopCommand cmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n        cmd.setControlIp(getControlNicIpForVM(vm));\n        if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n            cmd.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n        }\n        return cmd;\n    }\n","date":"2019-06-25 23:23:09","endLine":3112,"groupId":"25415","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"cleanup","params":"(finalVirtualMachinevm@Map<String@DpdkTO>dpdkInterfaceMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/79/5705345962a468ec5b626e71be73e2c2815950.src","preCode":"    public Command cleanup(final VirtualMachine vm, Map<String, DpdkTO> dpdkInterfaceMapping) {\n        StopCommand cmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n        cmd.setControlIp(getControlNicIpForVM(vm));\n        if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n            cmd.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n        }\n        return cmd;\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":3105,"status":"N"}],"commitId":"1a75872cd484dd387552bae58996a56679fdb51e","commitMessage":"@@@Merge pull request #4307 from shapeblue/ovfprops-and-vsphere-adv-together\n\n[VMware] vSphere advanced capabilities and Full OVF properties support","date":"2020-10-26 21:24:14","modifiedFileCount":"173","status":"M","submitter":"Boris Stoyanov - a.k.a Bobby"},{"authorTime":"2019-06-25 23:23:09","codes":[{"authorDate":"2021-02-24 17:28:33","commitOrder":13,"curCode":"    public void orchestrateStart(final String vmUuid, final Map<VirtualMachineProfile.Param, Object> params, final DeploymentPlan planToDeploy, final DeploymentPlanner planner)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {\n\n        final CallContext cctxt = CallContext.current();\n        final Account account = cctxt.getCallingAccount();\n        final User caller = cctxt.getCallingUser();\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final Ternary<VMInstanceVO, ReservationContext, ItWorkVO> start = changeToStartState(vmGuru, vm, caller, account);\n        if (start == null) {\n            return;\n        }\n\n        vm = start.first();\n        final ReservationContext ctx = start.second();\n        ItWorkVO work = start.third();\n\n        VMInstanceVO startedVm = null;\n        final ServiceOfferingVO offering = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());\n        final VirtualMachineTemplate template = _entityMgr.findByIdIncludingRemoved(VirtualMachineTemplate.class, vm.getTemplateId());\n\n        DataCenterDeployment plan = new DataCenterDeployment(vm.getDataCenterId(), vm.getPodIdToDeployIn(), null, null, null, null, ctx);\n        if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"advanceStart: DeploymentPlan is provided, using dcId:\" + planToDeploy.getDataCenterId() + \", podId: \" + planToDeploy.getPodId() +\n                        \", clusterId: \" + planToDeploy.getClusterId() + \", hostId: \" + planToDeploy.getHostId() + \", poolId: \" + planToDeploy.getPoolId());\n            }\n            plan =\n                    new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(), planToDeploy.getHostId(),\n                            planToDeploy.getPoolId(), planToDeploy.getPhysicalNetworkId(), ctx);\n        }\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        \r\n        final Account owner = _entityMgr.findById(Account.class, vm.getAccountId());\n        if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n            resourceCountIncrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n        }\n\n        boolean canRetry = true;\n        ExcludeList avoids = null;\n        try {\n            final Journal journal = start.second().getJournal();\n\n            if (planToDeploy != null) {\n                avoids = planToDeploy.getAvoids();\n            }\n            if (avoids == null) {\n                avoids = new ExcludeList();\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Deploy avoids pods: \" + avoids.getPodsToAvoid() + \", clusters: \" + avoids.getClustersToAvoid() + \", hosts: \" + avoids.getHostsToAvoid());\n            }\n\n            boolean planChangedByVolume = false;\n            boolean reuseVolume = true;\n            final DataCenterDeployment originalPlan = plan;\n\n            int retry = StartRetry.value();\n            while (retry-- != 0) { \r\n                s_logger.debug(\"VM start attempt #\" + (StartRetry.value() - retry));\n\n                if (reuseVolume) {\n                    \r\n                    final List<VolumeVO> vols = _volsDao.findReadyRootVolumesByInstance(vm.getId());\n                    for (final VolumeVO vol : vols) {\n                        \r\n                        \r\n                        \r\n                        final Long volTemplateId = vol.getTemplateId();\n                        if (volTemplateId != null && volTemplateId.longValue() != template.getId()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(vol + \" of \" + vm + \" is READY, but template ids don't match, let the planner reassign a new pool\");\n                            }\n                            continue;\n                        }\n\n                        final StoragePool pool = (StoragePool)dataStoreMgr.getPrimaryDataStore(vol.getPoolId());\n                        if (!pool.isInMaintenance()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Root volume is ready, need to place VM in volume's cluster\");\n                            }\n                            final long rootVolDcId = pool.getDataCenterId();\n                            final Long rootVolPodId = pool.getPodId();\n                            final Long rootVolClusterId = pool.getClusterId();\n                            if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n                                final Long clusterIdSpecified = planToDeploy.getClusterId();\n                                if (clusterIdSpecified != null && rootVolClusterId != null) {\n                                    if (rootVolClusterId.longValue() != clusterIdSpecified.longValue()) {\n                                        \r\n                                        \r\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"Cannot satisfy the deployment plan passed in since the ready Root volume is in different cluster. volume's cluster: \" +\n                                                    rootVolClusterId + \", cluster specified: \" + clusterIdSpecified);\n                                        }\n                                        throw new ResourceUnavailableException(\n                                                \"Root volume is ready in different cluster, Deployment plan provided cannot be satisfied, unable to create a deployment for \" +\n                                                        vm, Cluster.class, clusterIdSpecified);\n                                    }\n                                }\n                                plan =\n                                        new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(),\n                                                planToDeploy.getHostId(), vol.getPoolId(), null, ctx);\n                            } else {\n                                plan = new DataCenterDeployment(rootVolDcId, rootVolPodId, rootVolClusterId, null, vol.getPoolId(), null, ctx);\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(vol + \" is READY, changing deployment plan to use this pool's dcId: \" + rootVolDcId + \" , podId: \" + rootVolPodId +\n                                            \" , and clusterId: \" + rootVolClusterId);\n                                }\n                                planChangedByVolume = true;\n                            }\n                        }\n                    }\n                }\n\n                final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vm, template, offering, owner, params);\n                logBootModeParameters(params);\n                DeployDestination dest = null;\n                try {\n                    dest = _dpMgr.planDeployment(vmProfile, plan, avoids, planner);\n                } catch (final AffinityConflictException e2) {\n                    s_logger.warn(\"Unable to create deployment, affinity rules associted to the VM conflict\", e2);\n                    throw new CloudRuntimeException(\"Unable to create deployment, affinity rules associted to the VM conflict\");\n                }\n\n                if (dest == null) {\n                    if (planChangedByVolume) {\n                        plan = originalPlan;\n                        planChangedByVolume = false;\n                        \r\n                        reuseVolume = false;\n                        continue;\n                    }\n                    throw new InsufficientServerCapacityException(\"Unable to create a deployment for \" + vmProfile, DataCenter.class, plan.getDataCenterId(),\n                            areAffinityGroupsAssociated(vmProfile));\n                }\n\n                if (dest != null) {\n                    avoids.addHost(dest.getHost().getId());\n                    if (!template.isDeployAsIs()) {\n                        journal.record(\"Deployment found - Attempt #\" + (StartRetry.value() - retry), vmProfile, dest);\n                    }\n                }\n\n                long destHostId = dest.getHost().getId();\n                vm.setPodIdToDeployIn(dest.getPod().getId());\n                final Long cluster_id = dest.getCluster().getId();\n                final ClusterDetailsVO cluster_detail_cpu = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                final ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                \r\n                if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) == null &&\n                        (Float.parseFloat(cluster_detail_cpu.getValue()) > 1f || Float.parseFloat(cluster_detail_ram.getValue()) > 1f)) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                } else if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) != null) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                }\n\n                vmProfile.setCpuOvercommitRatio(Float.parseFloat(cluster_detail_cpu.getValue()));\n                vmProfile.setMemoryOvercommitRatio(Float.parseFloat(cluster_detail_ram.getValue()));\n                StartAnswer startAnswer = null;\n\n                try {\n                    if (!changeState(vm, Event.OperationRetry, destHostId, work, Step.Prepare)) {\n                        throw new ConcurrentOperationException(\"Unable to update the state of the Virtual Machine \"+vm.getUuid()+\" oldstate: \"+vm.getState()+ \"Event :\"+Event.OperationRetry);\n                    }\n                } catch (final NoTransitionException e1) {\n                    throw new ConcurrentOperationException(e1.getMessage());\n                }\n\n                try {\n                    resetVmNicsDeviceId(vm.getId());\n                    _networkMgr.prepare(vmProfile, dest, ctx);\n                    if (vm.getHypervisorType() != HypervisorType.BareMetal) {\n                        volumeMgr.prepare(vmProfile, dest);\n                    }\n\n                    \r\n                    if (!reuseVolume) {\n                        reuseVolume = true;\n                    }\n\n                    Commands cmds = null;\n                    vmGuru.finalizeVirtualMachineProfile(vmProfile, dest, ctx);\n\n                    final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);\n\n                    checkAndSetEnterSetupMode(vmTO, params);\n\n                    handlePath(vmTO.getDisks(), vm.getHypervisorType());\n\n                    cmds = new Commands(Command.OnError.Stop);\n\n                    cmds.addCommand(new StartCommand(vmTO, dest.getHost(), getExecuteInSequence(vm.getHypervisorType())));\n\n                    vmGuru.finalizeDeployment(cmds, vmProfile, dest, ctx);\n\n                    \r\n                    addExtraConfig(vmTO);\n\n                    work = _workDao.findById(work.getId());\n                    if (work == null || work.getStep() != Step.Prepare) {\n                        throw new ConcurrentOperationException(\"Work steps have been changed: \" + work);\n                    }\n\n                    _workDao.updateStep(work, Step.Starting);\n\n                    _agentMgr.send(destHostId, cmds);\n\n                    _workDao.updateStep(work, Step.Started);\n\n                    startAnswer = cmds.getAnswer(StartAnswer.class);\n                    if (startAnswer != null && startAnswer.getResult()) {\n                        handlePath(vmTO.getDisks(), startAnswer.getIqnToData());\n\n                        final String host_guid = startAnswer.getHost_guid();\n\n                        if (host_guid != null) {\n                            final HostVO finalHost = _resourceMgr.findHostByGuid(host_guid);\n                            if (finalHost == null) {\n                                throw new CloudRuntimeException(\"Host Guid \" + host_guid + \" doesn't exist in DB, something went wrong while processing start answer: \"+startAnswer);\n                            }\n                            destHostId = finalHost.getId();\n                        }\n                        if (vmGuru.finalizeStart(vmProfile, destHostId, cmds, ctx)) {\n                            syncDiskChainChange(startAnswer);\n\n                            if (!changeState(vm, Event.OperationSucceeded, destHostId, work, Step.Done)) {\n                                s_logger.error(\"Unable to transition to a new state. VM uuid: \"+vm.getUuid()+    \"VM oldstate:\"+vm.getState()+\"Event:\"+Event.OperationSucceeded);\n                                throw new ConcurrentOperationException(\"Failed to deploy VM\"+ vm.getUuid());\n                            }\n\n                            \r\n                            final GPUDeviceTO gpuDevice = startAnswer.getVirtualMachine().getGpuDevice();\n                            if (gpuDevice != null) {\n                                _resourceMgr.updateGPUDetails(destHostId, gpuDevice.getGroupDetails());\n                            }\n\n                            \r\n                            \r\n                            \r\n                            if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.DEPLOY_VM) != null) {\n                                userVmDetailsDao.removeDetail(vm.getId(), VmDetailConstants.DEPLOY_VM);\n                            }\n\n                            startedVm = vm;\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Start completed for VM \" + vm);\n                            }\n                            final Host vmHost = _hostDao.findById(destHostId);\n                            if (vmHost != null && (VirtualMachine.Type.ConsoleProxy.equals(vm.getType()) ||\n                                    VirtualMachine.Type.SecondaryStorageVm.equals(vm.getType())) && caManager.canProvisionCertificates()) {\n                                final Map<String, String> sshAccessDetails = _networkMgr.getSystemVMAccessDetails(vm);\n                                for (int retries = 3; retries > 0; retries--) {\n                                    try {\n                                        setupAgentSecurity(vmHost, sshAccessDetails, vm);\n                                        return;\n                                    } catch (final Exception e) {\n                                        s_logger.error(\"Retrying after catching exception while trying to secure agent for systemvm id=\" + vm.getId(), e);\n                                    }\n                                }\n                                throw new CloudRuntimeException(\"Failed to setup and secure agent for systemvm id=\" + vm.getId());\n                            }\n                            return;\n                        } else {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.info(\"The guru did not like the answers so stopping \" + vm);\n                            }\n                            StopCommand stopCmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n                            stopCmd.setControlIp(getControlNicIpForVM(vm));\n                            final StopCommand cmd = stopCmd;\n                            final Answer answer = _agentMgr.easySend(destHostId, cmd);\n                            if (answer != null && answer instanceof StopAnswer) {\n                                final StopAnswer stopAns = (StopAnswer)answer;\n                                if (vm.getType() == VirtualMachine.Type.User) {\n                                    final String platform = stopAns.getPlatform();\n                                    if (platform != null) {\n                                        final Map<String,String> vmmetadata = new HashMap<String,String>();\n                                        vmmetadata.put(vm.getInstanceName(), platform);\n                                        syncVMMetaData(vmmetadata);\n                                    }\n                                }\n                            }\n\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.warn(\"Unable to stop \" + vm + \" due to \" + (answer != null ? answer.getDetails() : \"no answers\"));\n                                _haMgr.scheduleStop(vm, destHostId, WorkType.ForceStop);\n                                throw new ExecutionException(\"Unable to stop this VM, \"+vm.getUuid()+\" so we are unable to retry the start operation\");\n                            }\n                            throw new ExecutionException(\"Unable to start  VM:\"+vm.getUuid()+\" due to error in finalizeStart, not retrying\");\n                        }\n                    }\n                    s_logger.info(\"Unable to start VM on \" + dest.getHost() + \" due to \" + (startAnswer == null ? \" no start answer\" : startAnswer.getDetails()));\n                    if (startAnswer != null && startAnswer.getContextParam(\"stopRetry\") != null) {\n                        break;\n                    }\n\n                } catch (OperationTimedoutException e) {\n                    s_logger.debug(\"Unable to send the start command to host \" + dest.getHost()+\" failed to start VM: \"+vm.getUuid());\n                    if (e.isActive()) {\n                        _haMgr.scheduleStop(vm, destHostId, WorkType.CheckStop);\n                    }\n                    canRetry = false;\n                    throw new AgentUnavailableException(\"Unable to start \" + vm.getHostName(), destHostId, e);\n                } catch (final ResourceUnavailableException e) {\n                    s_logger.info(\"Unable to contact resource.\", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected ResourceUnavailableException : \" + e.getScope().getName(), e);\n                            throw e;\n                        }\n                    }\n                } catch (final InsufficientCapacityException e) {\n                    s_logger.info(\"Insufficient capacity \", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected InsufficientCapacityException : \" + e.getScope().getName(), e);\n                        }\n                    }\n                } catch (final ExecutionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final NoTransitionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final StorageAccessException e) {\n                    s_logger.warn(\"Unable to access storage on host\", e);\n                } finally {\n                    if (startedVm == null && canRetry) {\n                        final Step prevStep = work.getStep();\n                        _workDao.updateStep(work, Step.Release);\n                        \r\n                        if ((prevStep == Step.Started || prevStep == Step.Starting) && startAnswer != null && startAnswer.getResult()) {  \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, false);\n                        } else {\n                            \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, true);\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (startedVm == null) {\n                if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n                    resourceCountDecrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n                }\n                if (canRetry) {\n                    try {\n                        changeState(vm, Event.OperationFailed, null, work, Step.Done);\n                    } catch (final NoTransitionException e) {\n                        throw new ConcurrentOperationException(e.getMessage());\n                    }\n                }\n            }\n\n            if (planToDeploy != null) {\n                planToDeploy.setAvoids(avoids);\n            }\n        }\n\n        if (startedVm == null) {\n            throw new CloudRuntimeException(\"Unable to start instance '\" + vm.getHostName() + \"' (\" + vm.getUuid() + \"), see management server log for details\");\n        }\n    }\n","date":"2021-02-24 17:28:33","endLine":1347,"groupId":"18193","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"orchestrateStart","params":"(finalStringvmUuid@finalMap<VirtualMachineProfile.Param@Object>params@finalDeploymentPlanplanToDeploy@finalDeploymentPlannerplanner)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/df/ec0b1de77881a5a59a098404ec19de1ccca48e.src","preCode":"    public void orchestrateStart(final String vmUuid, final Map<VirtualMachineProfile.Param, Object> params, final DeploymentPlan planToDeploy, final DeploymentPlanner planner)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {\n\n        final CallContext cctxt = CallContext.current();\n        final Account account = cctxt.getCallingAccount();\n        final User caller = cctxt.getCallingUser();\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final Ternary<VMInstanceVO, ReservationContext, ItWorkVO> start = changeToStartState(vmGuru, vm, caller, account);\n        if (start == null) {\n            return;\n        }\n\n        vm = start.first();\n        final ReservationContext ctx = start.second();\n        ItWorkVO work = start.third();\n\n        VMInstanceVO startedVm = null;\n        final ServiceOfferingVO offering = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());\n        final VirtualMachineTemplate template = _entityMgr.findByIdIncludingRemoved(VirtualMachineTemplate.class, vm.getTemplateId());\n\n        DataCenterDeployment plan = new DataCenterDeployment(vm.getDataCenterId(), vm.getPodIdToDeployIn(), null, null, null, null, ctx);\n        if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"advanceStart: DeploymentPlan is provided, using dcId:\" + planToDeploy.getDataCenterId() + \", podId: \" + planToDeploy.getPodId() +\n                        \", clusterId: \" + planToDeploy.getClusterId() + \", hostId: \" + planToDeploy.getHostId() + \", poolId: \" + planToDeploy.getPoolId());\n            }\n            plan =\n                    new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(), planToDeploy.getHostId(),\n                            planToDeploy.getPoolId(), planToDeploy.getPhysicalNetworkId(), ctx);\n        }\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        \r\n        final Account owner = _entityMgr.findById(Account.class, vm.getAccountId());\n        if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n            resourceCountIncrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n        }\n\n        boolean canRetry = true;\n        ExcludeList avoids = null;\n        try {\n            final Journal journal = start.second().getJournal();\n\n            if (planToDeploy != null) {\n                avoids = planToDeploy.getAvoids();\n            }\n            if (avoids == null) {\n                avoids = new ExcludeList();\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Deploy avoids pods: \" + avoids.getPodsToAvoid() + \", clusters: \" + avoids.getClustersToAvoid() + \", hosts: \" + avoids.getHostsToAvoid());\n            }\n\n            boolean planChangedByVolume = false;\n            boolean reuseVolume = true;\n            final DataCenterDeployment originalPlan = plan;\n\n            int retry = StartRetry.value();\n            while (retry-- != 0) { \r\n\n                if (reuseVolume) {\n                    \r\n                    final List<VolumeVO> vols = _volsDao.findReadyRootVolumesByInstance(vm.getId());\n                    for (final VolumeVO vol : vols) {\n                        \r\n                        \r\n                        \r\n                        final Long volTemplateId = vol.getTemplateId();\n                        if (volTemplateId != null && volTemplateId.longValue() != template.getId()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(vol + \" of \" + vm + \" is READY, but template ids don't match, let the planner reassign a new pool\");\n                            }\n                            continue;\n                        }\n\n                        final StoragePool pool = (StoragePool)dataStoreMgr.getPrimaryDataStore(vol.getPoolId());\n                        if (!pool.isInMaintenance()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Root volume is ready, need to place VM in volume's cluster\");\n                            }\n                            final long rootVolDcId = pool.getDataCenterId();\n                            final Long rootVolPodId = pool.getPodId();\n                            final Long rootVolClusterId = pool.getClusterId();\n                            if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n                                final Long clusterIdSpecified = planToDeploy.getClusterId();\n                                if (clusterIdSpecified != null && rootVolClusterId != null) {\n                                    if (rootVolClusterId.longValue() != clusterIdSpecified.longValue()) {\n                                        \r\n                                        \r\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"Cannot satisfy the deployment plan passed in since the ready Root volume is in different cluster. volume's cluster: \" +\n                                                    rootVolClusterId + \", cluster specified: \" + clusterIdSpecified);\n                                        }\n                                        throw new ResourceUnavailableException(\n                                                \"Root volume is ready in different cluster, Deployment plan provided cannot be satisfied, unable to create a deployment for \" +\n                                                        vm, Cluster.class, clusterIdSpecified);\n                                    }\n                                }\n                                plan =\n                                        new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(),\n                                                planToDeploy.getHostId(), vol.getPoolId(), null, ctx);\n                            } else {\n                                plan = new DataCenterDeployment(rootVolDcId, rootVolPodId, rootVolClusterId, null, vol.getPoolId(), null, ctx);\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(vol + \" is READY, changing deployment plan to use this pool's dcId: \" + rootVolDcId + \" , podId: \" + rootVolPodId +\n                                            \" , and clusterId: \" + rootVolClusterId);\n                                }\n                                planChangedByVolume = true;\n                            }\n                        }\n                    }\n                }\n\n                final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vm, template, offering, owner, params);\n                logBootModeParameters(params);\n                DeployDestination dest = null;\n                try {\n                    dest = _dpMgr.planDeployment(vmProfile, plan, avoids, planner);\n                } catch (final AffinityConflictException e2) {\n                    s_logger.warn(\"Unable to create deployment, affinity rules associted to the VM conflict\", e2);\n                    throw new CloudRuntimeException(\"Unable to create deployment, affinity rules associted to the VM conflict\");\n                }\n\n                if (dest == null) {\n                    if (planChangedByVolume) {\n                        plan = originalPlan;\n                        planChangedByVolume = false;\n                        \r\n                        reuseVolume = false;\n                        continue;\n                    }\n                    throw new InsufficientServerCapacityException(\"Unable to create a deployment for \" + vmProfile, DataCenter.class, plan.getDataCenterId(),\n                            areAffinityGroupsAssociated(vmProfile));\n                }\n\n                if (dest != null) {\n                    avoids.addHost(dest.getHost().getId());\n                    if (!template.isDeployAsIs()) {\n                        journal.record(\"Deployment found \", vmProfile, dest);\n                    }\n                }\n\n                long destHostId = dest.getHost().getId();\n                vm.setPodIdToDeployIn(dest.getPod().getId());\n                final Long cluster_id = dest.getCluster().getId();\n                final ClusterDetailsVO cluster_detail_cpu = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                final ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                \r\n                if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) == null &&\n                        (Float.parseFloat(cluster_detail_cpu.getValue()) > 1f || Float.parseFloat(cluster_detail_ram.getValue()) > 1f)) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                } else if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) != null) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                }\n\n                vmProfile.setCpuOvercommitRatio(Float.parseFloat(cluster_detail_cpu.getValue()));\n                vmProfile.setMemoryOvercommitRatio(Float.parseFloat(cluster_detail_ram.getValue()));\n                StartAnswer startAnswer = null;\n\n                try {\n                    if (!changeState(vm, Event.OperationRetry, destHostId, work, Step.Prepare)) {\n                        throw new ConcurrentOperationException(\"Unable to update the state of the Virtual Machine \"+vm.getUuid()+\" oldstate: \"+vm.getState()+ \"Event :\"+Event.OperationRetry);\n                    }\n                } catch (final NoTransitionException e1) {\n                    throw new ConcurrentOperationException(e1.getMessage());\n                }\n\n                try {\n                    resetVmNicsDeviceId(vm.getId());\n                    _networkMgr.prepare(vmProfile, new DeployDestination(dest.getDataCenter(), dest.getPod(), null, null, dest.getStorageForDisks(), dest.isDisplayStorage()), ctx);\n                    if (vm.getHypervisorType() != HypervisorType.BareMetal) {\n                        volumeMgr.prepare(vmProfile, dest);\n                    }\n\n                    \r\n                    if (!reuseVolume) {\n                        reuseVolume = true;\n                    }\n\n                    Commands cmds = null;\n                    vmGuru.finalizeVirtualMachineProfile(vmProfile, dest, ctx);\n\n                    final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);\n\n                    checkAndSetEnterSetupMode(vmTO, params);\n\n                    handlePath(vmTO.getDisks(), vm.getHypervisorType());\n\n                    cmds = new Commands(Command.OnError.Stop);\n\n                    cmds.addCommand(new StartCommand(vmTO, dest.getHost(), getExecuteInSequence(vm.getHypervisorType())));\n\n                    vmGuru.finalizeDeployment(cmds, vmProfile, dest, ctx);\n\n                    \r\n                    addExtraConfig(vmTO);\n\n                    work = _workDao.findById(work.getId());\n                    if (work == null || work.getStep() != Step.Prepare) {\n                        throw new ConcurrentOperationException(\"Work steps have been changed: \" + work);\n                    }\n\n                    _workDao.updateStep(work, Step.Starting);\n\n                    _agentMgr.send(destHostId, cmds);\n\n                    _workDao.updateStep(work, Step.Started);\n\n                    startAnswer = cmds.getAnswer(StartAnswer.class);\n                    if (startAnswer != null && startAnswer.getResult()) {\n                        handlePath(vmTO.getDisks(), startAnswer.getIqnToData());\n\n                        final String host_guid = startAnswer.getHost_guid();\n\n                        if (host_guid != null) {\n                            final HostVO finalHost = _resourceMgr.findHostByGuid(host_guid);\n                            if (finalHost == null) {\n                                throw new CloudRuntimeException(\"Host Guid \" + host_guid + \" doesn't exist in DB, something went wrong while processing start answer: \"+startAnswer);\n                            }\n                            destHostId = finalHost.getId();\n                        }\n                        if (vmGuru.finalizeStart(vmProfile, destHostId, cmds, ctx)) {\n                            syncDiskChainChange(startAnswer);\n\n                            if (!changeState(vm, Event.OperationSucceeded, destHostId, work, Step.Done)) {\n                                s_logger.error(\"Unable to transition to a new state. VM uuid: \"+vm.getUuid()+    \"VM oldstate:\"+vm.getState()+\"Event:\"+Event.OperationSucceeded);\n                                throw new ConcurrentOperationException(\"Failed to deploy VM\"+ vm.getUuid());\n                            }\n\n                            \r\n                            final GPUDeviceTO gpuDevice = startAnswer.getVirtualMachine().getGpuDevice();\n                            if (gpuDevice != null) {\n                                _resourceMgr.updateGPUDetails(destHostId, gpuDevice.getGroupDetails());\n                            }\n\n                            \r\n                            \r\n                            \r\n                            if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.DEPLOY_VM) != null) {\n                                userVmDetailsDao.removeDetail(vm.getId(), VmDetailConstants.DEPLOY_VM);\n                            }\n\n                            startedVm = vm;\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Start completed for VM \" + vm);\n                            }\n                            final Host vmHost = _hostDao.findById(destHostId);\n                            if (vmHost != null && (VirtualMachine.Type.ConsoleProxy.equals(vm.getType()) ||\n                                    VirtualMachine.Type.SecondaryStorageVm.equals(vm.getType())) && caManager.canProvisionCertificates()) {\n                                final Map<String, String> sshAccessDetails = _networkMgr.getSystemVMAccessDetails(vm);\n                                for (int retries = 3; retries > 0; retries--) {\n                                    try {\n                                        setupAgentSecurity(vmHost, sshAccessDetails, vm);\n                                        return;\n                                    } catch (final Exception e) {\n                                        s_logger.error(\"Retrying after catching exception while trying to secure agent for systemvm id=\" + vm.getId(), e);\n                                    }\n                                }\n                                throw new CloudRuntimeException(\"Failed to setup and secure agent for systemvm id=\" + vm.getId());\n                            }\n                            return;\n                        } else {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.info(\"The guru did not like the answers so stopping \" + vm);\n                            }\n                            StopCommand stopCmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n                            stopCmd.setControlIp(getControlNicIpForVM(vm));\n                            final StopCommand cmd = stopCmd;\n                            final Answer answer = _agentMgr.easySend(destHostId, cmd);\n                            if (answer != null && answer instanceof StopAnswer) {\n                                final StopAnswer stopAns = (StopAnswer)answer;\n                                if (vm.getType() == VirtualMachine.Type.User) {\n                                    final String platform = stopAns.getPlatform();\n                                    if (platform != null) {\n                                        final Map<String,String> vmmetadata = new HashMap<String,String>();\n                                        vmmetadata.put(vm.getInstanceName(), platform);\n                                        syncVMMetaData(vmmetadata);\n                                    }\n                                }\n                            }\n\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.warn(\"Unable to stop \" + vm + \" due to \" + (answer != null ? answer.getDetails() : \"no answers\"));\n                                _haMgr.scheduleStop(vm, destHostId, WorkType.ForceStop);\n                                throw new ExecutionException(\"Unable to stop this VM, \"+vm.getUuid()+\" so we are unable to retry the start operation\");\n                            }\n                            throw new ExecutionException(\"Unable to start  VM:\"+vm.getUuid()+\" due to error in finalizeStart, not retrying\");\n                        }\n                    }\n                    s_logger.info(\"Unable to start VM on \" + dest.getHost() + \" due to \" + (startAnswer == null ? \" no start answer\" : startAnswer.getDetails()));\n                    if (startAnswer != null && startAnswer.getContextParam(\"stopRetry\") != null) {\n                        break;\n                    }\n\n                } catch (OperationTimedoutException e) {\n                    s_logger.debug(\"Unable to send the start command to host \" + dest.getHost()+\" failed to start VM: \"+vm.getUuid());\n                    if (e.isActive()) {\n                        _haMgr.scheduleStop(vm, destHostId, WorkType.CheckStop);\n                    }\n                    canRetry = false;\n                    throw new AgentUnavailableException(\"Unable to start \" + vm.getHostName(), destHostId, e);\n                } catch (final ResourceUnavailableException e) {\n                    s_logger.info(\"Unable to contact resource.\", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected ResourceUnavailableException : \" + e.getScope().getName(), e);\n                            throw e;\n                        }\n                    }\n                } catch (final InsufficientCapacityException e) {\n                    s_logger.info(\"Insufficient capacity \", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected InsufficientCapacityException : \" + e.getScope().getName(), e);\n                        }\n                    }\n                } catch (final ExecutionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final NoTransitionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } finally {\n                    if (startedVm == null && canRetry) {\n                        final Step prevStep = work.getStep();\n                        _workDao.updateStep(work, Step.Release);\n                        \r\n                        if ((prevStep == Step.Started || prevStep == Step.Starting) && startAnswer != null && startAnswer.getResult()) {  \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, false);\n                        } else {\n                            \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, true);\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (startedVm == null) {\n                if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n                    resourceCountDecrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n                }\n                if (canRetry) {\n                    try {\n                        changeState(vm, Event.OperationFailed, null, work, Step.Done);\n                    } catch (final NoTransitionException e) {\n                        throw new ConcurrentOperationException(e.getMessage());\n                    }\n                }\n            }\n\n            if (planToDeploy != null) {\n                planToDeploy.setAvoids(avoids);\n            }\n        }\n\n        if (startedVm == null) {\n            throw new CloudRuntimeException(\"Unable to start instance '\" + vm.getHostName() + \"' (\" + vm.getUuid() + \"), see management server log for details\");\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":975,"status":"M"},{"authorDate":"2019-06-25 23:23:09","commitOrder":13,"curCode":"    public Command cleanup(final VirtualMachine vm, Map<String, DpdkTO> dpdkInterfaceMapping) {\n        StopCommand cmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n        cmd.setControlIp(getControlNicIpForVM(vm));\n        if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n            cmd.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n        }\n        return cmd;\n    }\n","date":"2019-06-25 23:23:09","endLine":3112,"groupId":"25415","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"cleanup","params":"(finalVirtualMachinevm@Map<String@DpdkTO>dpdkInterfaceMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/79/5705345962a468ec5b626e71be73e2c2815950.src","preCode":"    public Command cleanup(final VirtualMachine vm, Map<String, DpdkTO> dpdkInterfaceMapping) {\n        StopCommand cmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n        cmd.setControlIp(getControlNicIpForVM(vm));\n        if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n            cmd.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n        }\n        return cmd;\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":3105,"status":"N"}],"commitId":"eba186aa40f16911c019bf06cd33d7d0cbbc303b","commitMessage":"@@@storage: New Dell EMC PowerFlex Plugin (formerly ScaleIO.  VxFlexOS) (#4304)\n\nAdded support for PowerFlex/ScaleIO (v3.5 onwards) storage pool as a primary storage in CloudStack (for KVM hypervisor) and enabled VM/Volume operations on that pool (using pool tag).\nPlease find more details in the FS here:\nhttps://cwiki.apache.org/confluence/x/cDl4CQ\n\nDocumentation PR: apache/cloudstack-documentation#169\n\nThis enables support for PowerFlex/ScaleIO (v3.5 onwards) storage pool as a primary storage in CloudStack\n\nOther improvements addressed in addition to PowerFlex/ScaleIO support:\n\n- Added support for config drives in host cache for KVM\n\t=> Changed configuration \"vm.configdrive.primarypool.enabled\" scope from Global to Zone level\n\t=> Introduced new zone level configuration \"vm.configdrive.force.host.cache.use\" (default: false) to force host cache for config drives\n\t=> Introduced new zone level configuration \"vm.configdrive.use.host.cache.on.unsupported.pool\" (default: true) to use host cache for config drives when storage pool doesn't support config drive\n\t=> Added new parameter \"host.cache.location\" (default: /var/cache/cloud) in KVM agent.properties for specifying the host cache path and create config drives on the \"/config\" directory on the host cache path\n\t=> Maintain the config drive location and use it when required on any config drive operation (migrate.  delete)\n\n- Detect virtual size from the template URL while registering direct download qcow2 (of KVM hypervisor) templates\n\n- Updated full deployment destination for preparing the network(s) on VM start\n\n- Propagate the direct download certificates uploaded to the newly added KVM hosts\n\n- Discover the template size for direct download templates using any available host from the zones specified on template registration\n\t=> When zones are not specified while registering template.  template size discovery is performed using any available host.  which is picked up randomly from one of the available zones\n\n- Release the VM resources when VM is sync-ed to Stopped state on PowerReportMissing (after graceful period)\n\n- Retry VM deployment/start when the host cannot grant access to volume/template\n\n- Mark never-used or downloaded templates as Destroyed on deletion.  without sending any DeleteCommand\n\t=> Do not trigger any DeleteCommand for never-used or downloaded templates as these doesn't exist and cannot be deleted from the datastore\n\n- Check the router filesystem is writable or not.  before performing health checks\n\t=> Introduce a new test \"filesystem.writable.test\" to check the filesystem is writable or not\n\t=> The router health checks keeps the config info at \"/var/cache/cloud\" and updates the monitor results at \"/root\" for health checks.  both are different partitions. So.  test at both the locations.\n\t=> Added new script: \"filesystem_writable_check.py\" at /opt/cloud/bin/ to check the filesystem is writable or not\n\n- Fixed NPE issue.  template is null for DATA disks. Copy template to target storage for ROOT disk (with template id).  skip DATA disk(s)\n\n* Addressed some issues for few operations on PowerFlex storage pool.\n\n- Updated migration volume operation to sync the status and wait for migration to complete.\n\n- Updated VM Snapshot naming.  for uniqueness in ScaleIO volume name when more than one volume exists in the VM.\n\n- Added sync lock while spooling managed storage template before volume creation from the template (non-direct download).\n\n- Updated resize volume error message string.\n\n- Blocked the below operations on PowerFlex storage pool:\n  -> Extract Volume\n  -> Create Snapshot for VMSnapshot\n\n* Added the PowerFlex/ScaleIO client connection pool to manage the ScaleIO gateway clients.  which uses a single gateway client per Powerflex/ScaleIO storage pool and renews it when the session token expires.\n\n- The token is valid for 8 hours from the time it was created.  unless there has been no activity for 10 minutes.\n  Reference: https://cpsdocs.dellemc.com/bundle/PF_REST_API_RG/page/GUID-92430F19-9F44-42B6-B898-87D5307AE59B.html\n\nOther fixes included:\n\n- Fail the VM deployment when the host specified in the deployVirtualMachine cmd is not in the right state (i.e. either Resource State is not Enabled or Status is not Up)\n\n- Use the physical file size of the template to check the free space availability on the host.  while downloading the direct download templates.\n\n- Perform basic tests (for connectivity and file system) on router before updating the health check config data\n\t=> Validate the basic tests (connectivity and file system check) on router\n\t=> Cleanup the health check results when router is destroyed\n\n* Updated PowerFlex/ScaleIO storage plugin version to 4.16.0.0\n\n* UI Changes to support storage plugin for PowerFlex/ScaleIO storage pool.\n- PowerFlex pool URL generated from the UI inputs(Gateway.  Username.  Password.  Storage Pool) when adding \"PowerFlex\" Primary Storage\n- Updated protocol to \"custom\" for PowerFlex provider\n- Allow VM Snapshot for stopped VM on KVM hypervisor and PowerFlex/ScaleIO storage pool\n\nand Minor improvements in PowerFlex/ScaleIO storage plugin code\n\n* Added support for PowerFlex/ScaleIO volume migration across different PowerFlex storage instances.\n\n- findStoragePoolsForMigration API returns PowerFlex pool(s) of different instance as suitable pool(s).  for volume(s) on PowerFlex storage pool.\n- Volume(s) with snapshots are not allowed to migrate to different PowerFlex instance.\n- Volume(s) of running VM are not allowed to migrate to other PowerFlex storage pools.\n- Volume migration from PowerFlex pool to Non-PowerFlex pool.  and vice versa are not supported.\n\n* Fixed change service offering smoke tests in test_service_offerings.py.  test_vm_snapshots.py\n\n* Added the PowerFlex/ScaleIO volume/snapshot name to the paths of respective CloudStack resources (Templates.  Volumes.  Snapshots and VM Snapshots)\n\n* Added new response parameter ?supportsStorageSnapshot? (true/false) to volume response.  and Updated UI to hide the async backup option while taking snapshot for volume(s) with storage snapshot support.\n\n* Fix to remove the duplicate zone wide pools listed while finding storage pools for migration\n\n* Updated PowerFlex/ScaleIO volume migration checks and rollback migration on failure\n\n* Fixed the PowerFlex/ScaleIO volume name inconsistency issue in the volume path after migration.  due to rename failure","date":"2021-02-24 17:28:33","modifiedFileCount":"112","status":"M","submitter":"sureshanaparti"},{"authorTime":"2021-04-05 17:07:11","codes":[{"authorDate":"2021-04-05 17:07:11","commitOrder":14,"curCode":"    public void orchestrateStart(final String vmUuid, final Map<VirtualMachineProfile.Param, Object> params, final DeploymentPlan planToDeploy, final DeploymentPlanner planner)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {\n\n        final CallContext cctxt = CallContext.current();\n        final Account account = cctxt.getCallingAccount();\n        final User caller = cctxt.getCallingUser();\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final Ternary<VMInstanceVO, ReservationContext, ItWorkVO> start = changeToStartState(vmGuru, vm, caller, account);\n        if (start == null) {\n            return;\n        }\n\n        vm = start.first();\n        final ReservationContext ctx = start.second();\n        ItWorkVO work = start.third();\n\n        VMInstanceVO startedVm = null;\n        final ServiceOfferingVO offering = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());\n        final VirtualMachineTemplate template = _entityMgr.findByIdIncludingRemoved(VirtualMachineTemplate.class, vm.getTemplateId());\n\n        DataCenterDeployment plan = new DataCenterDeployment(vm.getDataCenterId(), vm.getPodIdToDeployIn(), null, null, null, null, ctx);\n        if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"advanceStart: DeploymentPlan is provided, using dcId:\" + planToDeploy.getDataCenterId() + \", podId: \" + planToDeploy.getPodId() +\n                        \", clusterId: \" + planToDeploy.getClusterId() + \", hostId: \" + planToDeploy.getHostId() + \", poolId: \" + planToDeploy.getPoolId());\n            }\n            plan =\n                    new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(), planToDeploy.getHostId(),\n                            planToDeploy.getPoolId(), planToDeploy.getPhysicalNetworkId(), ctx);\n        }\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        \r\n        final Account owner = _entityMgr.findById(Account.class, vm.getAccountId());\n        if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n            resourceCountIncrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n        }\n\n        boolean canRetry = true;\n        ExcludeList avoids = null;\n        try {\n            final Journal journal = start.second().getJournal();\n\n            if (planToDeploy != null) {\n                avoids = planToDeploy.getAvoids();\n            }\n            if (avoids == null) {\n                avoids = new ExcludeList();\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Deploy avoids pods: \" + avoids.getPodsToAvoid() + \", clusters: \" + avoids.getClustersToAvoid() + \", hosts: \" + avoids.getHostsToAvoid());\n            }\n\n            boolean planChangedByVolume = false;\n            boolean reuseVolume = true;\n            final DataCenterDeployment originalPlan = plan;\n\n            int retry = StartRetry.value();\n            while (retry-- != 0) { \r\n                s_logger.debug(\"VM start attempt #\" + (StartRetry.value() - retry));\n\n                if (reuseVolume) {\n                    \r\n                    final List<VolumeVO> vols = _volsDao.findReadyRootVolumesByInstance(vm.getId());\n                    for (final VolumeVO vol : vols) {\n                        \r\n                        \r\n                        \r\n                        final Long volTemplateId = vol.getTemplateId();\n                        if (volTemplateId != null && volTemplateId.longValue() != template.getId()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(vol + \" of \" + vm + \" is READY, but template ids don't match, let the planner reassign a new pool\");\n                            }\n                            continue;\n                        }\n\n                        final StoragePool pool = (StoragePool)dataStoreMgr.getPrimaryDataStore(vol.getPoolId());\n                        if (!pool.isInMaintenance()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Root volume is ready, need to place VM in volume's cluster\");\n                            }\n                            final long rootVolDcId = pool.getDataCenterId();\n                            final Long rootVolPodId = pool.getPodId();\n                            final Long rootVolClusterId = pool.getClusterId();\n                            if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n                                final Long clusterIdSpecified = planToDeploy.getClusterId();\n                                if (clusterIdSpecified != null && rootVolClusterId != null) {\n                                    if (rootVolClusterId.longValue() != clusterIdSpecified.longValue()) {\n                                        \r\n                                        \r\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"Cannot satisfy the deployment plan passed in since the ready Root volume is in different cluster. volume's cluster: \" +\n                                                    rootVolClusterId + \", cluster specified: \" + clusterIdSpecified);\n                                        }\n                                        throw new ResourceUnavailableException(\n                                                \"Root volume is ready in different cluster, Deployment plan provided cannot be satisfied, unable to create a deployment for \" +\n                                                        vm, Cluster.class, clusterIdSpecified);\n                                    }\n                                }\n                                plan =\n                                        new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(),\n                                                planToDeploy.getHostId(), vol.getPoolId(), null, ctx);\n                            } else {\n                                plan = new DataCenterDeployment(rootVolDcId, rootVolPodId, rootVolClusterId, null, vol.getPoolId(), null, ctx);\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(vol + \" is READY, changing deployment plan to use this pool's dcId: \" + rootVolDcId + \" , podId: \" + rootVolPodId +\n                                            \" , and clusterId: \" + rootVolClusterId);\n                                }\n                                planChangedByVolume = true;\n                            }\n                        }\n                    }\n                }\n\n                final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vm, template, offering, owner, params);\n                logBootModeParameters(params);\n                DeployDestination dest = null;\n                try {\n                    dest = _dpMgr.planDeployment(vmProfile, plan, avoids, planner);\n                } catch (final AffinityConflictException e2) {\n                    s_logger.warn(\"Unable to create deployment, affinity rules associted to the VM conflict\", e2);\n                    throw new CloudRuntimeException(\"Unable to create deployment, affinity rules associted to the VM conflict\");\n                }\n\n                if (dest == null) {\n                    if (planChangedByVolume) {\n                        plan = originalPlan;\n                        planChangedByVolume = false;\n                        \r\n                        reuseVolume = false;\n                        continue;\n                    }\n                    throw new InsufficientServerCapacityException(\"Unable to create a deployment for \" + vmProfile, DataCenter.class, plan.getDataCenterId(),\n                            areAffinityGroupsAssociated(vmProfile));\n                }\n\n                if (dest != null) {\n                    avoids.addHost(dest.getHost().getId());\n                    if (!template.isDeployAsIs()) {\n                        journal.record(\"Deployment found - Attempt #\" + (StartRetry.value() - retry), vmProfile, dest);\n                    }\n                }\n\n                long destHostId = dest.getHost().getId();\n                vm.setPodIdToDeployIn(dest.getPod().getId());\n                final Long cluster_id = dest.getCluster().getId();\n                final ClusterDetailsVO cluster_detail_cpu = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                final ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                \r\n                if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) == null &&\n                        (Float.parseFloat(cluster_detail_cpu.getValue()) > 1f || Float.parseFloat(cluster_detail_ram.getValue()) > 1f)) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                } else if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) != null) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                }\n\n                vmProfile.setCpuOvercommitRatio(Float.parseFloat(cluster_detail_cpu.getValue()));\n                vmProfile.setMemoryOvercommitRatio(Float.parseFloat(cluster_detail_ram.getValue()));\n                StartAnswer startAnswer = null;\n\n                try {\n                    if (!changeState(vm, Event.OperationRetry, destHostId, work, Step.Prepare)) {\n                        throw new ConcurrentOperationException(\"Unable to update the state of the Virtual Machine \"+vm.getUuid()+\" oldstate: \"+vm.getState()+ \"Event :\"+Event.OperationRetry);\n                    }\n                } catch (final NoTransitionException e1) {\n                    throw new ConcurrentOperationException(e1.getMessage());\n                }\n\n                try {\n                    resetVmNicsDeviceId(vm.getId());\n                    _networkMgr.prepare(vmProfile, dest, ctx);\n                    if (vm.getHypervisorType() != HypervisorType.BareMetal) {\n                        volumeMgr.prepare(vmProfile, dest);\n                    }\n\n                    \r\n                    if (!reuseVolume) {\n                        reuseVolume = true;\n                    }\n\n                    Commands cmds = null;\n                    vmGuru.finalizeVirtualMachineProfile(vmProfile, dest, ctx);\n\n                    final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);\n\n                    checkAndSetEnterSetupMode(vmTO, params);\n\n                    handlePath(vmTO.getDisks(), vm.getHypervisorType());\n\n                    cmds = new Commands(Command.OnError.Stop);\n\n                    cmds.addCommand(new StartCommand(vmTO, dest.getHost(), getExecuteInSequence(vm.getHypervisorType())));\n\n                    vmGuru.finalizeDeployment(cmds, vmProfile, dest, ctx);\n\n                    \r\n                    addExtraConfig(vmTO);\n\n                    work = _workDao.findById(work.getId());\n                    if (work == null || work.getStep() != Step.Prepare) {\n                        throw new ConcurrentOperationException(\"Work steps have been changed: \" + work);\n                    }\n\n                    _workDao.updateStep(work, Step.Starting);\n\n                    _agentMgr.send(destHostId, cmds);\n\n                    _workDao.updateStep(work, Step.Started);\n\n                    startAnswer = cmds.getAnswer(StartAnswer.class);\n                    if (startAnswer != null && startAnswer.getResult()) {\n                        handlePath(vmTO.getDisks(), startAnswer.getIqnToData());\n\n                        final String host_guid = startAnswer.getHost_guid();\n\n                        if (host_guid != null) {\n                            final HostVO finalHost = _resourceMgr.findHostByGuid(host_guid);\n                            if (finalHost == null) {\n                                throw new CloudRuntimeException(\"Host Guid \" + host_guid + \" doesn't exist in DB, something went wrong while processing start answer: \"+startAnswer);\n                            }\n                            destHostId = finalHost.getId();\n                        }\n                        if (vmGuru.finalizeStart(vmProfile, destHostId, cmds, ctx)) {\n                            syncDiskChainChange(startAnswer);\n\n                            if (!changeState(vm, Event.OperationSucceeded, destHostId, work, Step.Done)) {\n                                s_logger.error(\"Unable to transition to a new state. VM uuid: \"+vm.getUuid()+    \"VM oldstate:\"+vm.getState()+\"Event:\"+Event.OperationSucceeded);\n                                throw new ConcurrentOperationException(\"Failed to deploy VM\"+ vm.getUuid());\n                            }\n\n                            \r\n                            final GPUDeviceTO gpuDevice = startAnswer.getVirtualMachine().getGpuDevice();\n                            if (gpuDevice != null) {\n                                _resourceMgr.updateGPUDetails(destHostId, gpuDevice.getGroupDetails());\n                            }\n\n                            \r\n                            \r\n                            \r\n                            if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.DEPLOY_VM) != null) {\n                                userVmDetailsDao.removeDetail(vm.getId(), VmDetailConstants.DEPLOY_VM);\n                            }\n\n                            startedVm = vm;\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Start completed for VM \" + vm);\n                            }\n                            final Host vmHost = _hostDao.findById(destHostId);\n                            if (vmHost != null && (VirtualMachine.Type.ConsoleProxy.equals(vm.getType()) ||\n                                    VirtualMachine.Type.SecondaryStorageVm.equals(vm.getType())) && caManager.canProvisionCertificates()) {\n                                final Map<String, String> sshAccessDetails = _networkMgr.getSystemVMAccessDetails(vm);\n                                for (int retries = 3; retries > 0; retries--) {\n                                    try {\n                                        setupAgentSecurity(vmHost, sshAccessDetails, vm);\n                                        return;\n                                    } catch (final Exception e) {\n                                        s_logger.error(\"Retrying after catching exception while trying to secure agent for systemvm id=\" + vm.getId(), e);\n                                    }\n                                }\n                                throw new CloudRuntimeException(\"Failed to setup and secure agent for systemvm id=\" + vm.getId());\n                            }\n                            return;\n                        } else {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.info(\"The guru did not like the answers so stopping \" + vm);\n                            }\n                            StopCommand stopCmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n                            stopCmd.setControlIp(getControlNicIpForVM(vm));\n                            Map<String, Boolean> vlanToPersistenceMap = getVlanToPersistenceMapForVM(vm.getId());\n                            if (MapUtils.isNotEmpty(vlanToPersistenceMap)) {\n                                stopCmd.setVlanToPersistenceMap(vlanToPersistenceMap);\n                            }\n                            final StopCommand cmd = stopCmd;\n                            final Answer answer = _agentMgr.easySend(destHostId, cmd);\n                            if (answer != null && answer instanceof StopAnswer) {\n                                final StopAnswer stopAns = (StopAnswer)answer;\n                                if (vm.getType() == VirtualMachine.Type.User) {\n                                    final String platform = stopAns.getPlatform();\n                                    if (platform != null) {\n                                        final Map<String,String> vmmetadata = new HashMap<String,String>();\n                                        vmmetadata.put(vm.getInstanceName(), platform);\n                                        syncVMMetaData(vmmetadata);\n                                    }\n                                }\n                            }\n\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.warn(\"Unable to stop \" + vm + \" due to \" + (answer != null ? answer.getDetails() : \"no answers\"));\n                                _haMgr.scheduleStop(vm, destHostId, WorkType.ForceStop);\n                                throw new ExecutionException(\"Unable to stop this VM, \"+vm.getUuid()+\" so we are unable to retry the start operation\");\n                            }\n                            throw new ExecutionException(\"Unable to start  VM:\"+vm.getUuid()+\" due to error in finalizeStart, not retrying\");\n                        }\n                    }\n                    s_logger.info(\"Unable to start VM on \" + dest.getHost() + \" due to \" + (startAnswer == null ? \" no start answer\" : startAnswer.getDetails()));\n                    if (startAnswer != null && startAnswer.getContextParam(\"stopRetry\") != null) {\n                        break;\n                    }\n\n                } catch (OperationTimedoutException e) {\n                    s_logger.debug(\"Unable to send the start command to host \" + dest.getHost()+\" failed to start VM: \"+vm.getUuid());\n                    if (e.isActive()) {\n                        _haMgr.scheduleStop(vm, destHostId, WorkType.CheckStop);\n                    }\n                    canRetry = false;\n                    throw new AgentUnavailableException(\"Unable to start \" + vm.getHostName(), destHostId, e);\n                } catch (final ResourceUnavailableException e) {\n                    s_logger.info(\"Unable to contact resource.\", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected ResourceUnavailableException : \" + e.getScope().getName(), e);\n                            throw e;\n                        }\n                    }\n                } catch (final InsufficientCapacityException e) {\n                    s_logger.info(\"Insufficient capacity \", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected InsufficientCapacityException : \" + e.getScope().getName(), e);\n                        }\n                    }\n                } catch (final ExecutionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final NoTransitionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final StorageAccessException e) {\n                    s_logger.warn(\"Unable to access storage on host\", e);\n                } finally {\n                    if (startedVm == null && canRetry) {\n                        final Step prevStep = work.getStep();\n                        _workDao.updateStep(work, Step.Release);\n                        \r\n                        if ((prevStep == Step.Started || prevStep == Step.Starting) && startAnswer != null && startAnswer.getResult()) {  \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, false);\n                        } else {\n                            \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, true);\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (startedVm == null) {\n                if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n                    resourceCountDecrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n                }\n                if (canRetry) {\n                    try {\n                        changeState(vm, Event.OperationFailed, null, work, Step.Done);\n                    } catch (final NoTransitionException e) {\n                        throw new ConcurrentOperationException(e.getMessage());\n                    }\n                }\n            }\n\n            if (planToDeploy != null) {\n                planToDeploy.setAvoids(avoids);\n            }\n        }\n\n        if (startedVm == null) {\n            throw new CloudRuntimeException(\"Unable to start instance '\" + vm.getHostName() + \"' (\" + vm.getUuid() + \"), see management server log for details\");\n        }\n    }\n","date":"2021-04-05 17:07:11","endLine":1364,"groupId":"18193","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"orchestrateStart","params":"(finalStringvmUuid@finalMap<VirtualMachineProfile.Param@Object>params@finalDeploymentPlanplanToDeploy@finalDeploymentPlannerplanner)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/1e/92c3ed5be7e6ac76091149b4cc4fcfba874141.src","preCode":"    public void orchestrateStart(final String vmUuid, final Map<VirtualMachineProfile.Param, Object> params, final DeploymentPlan planToDeploy, final DeploymentPlanner planner)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {\n\n        final CallContext cctxt = CallContext.current();\n        final Account account = cctxt.getCallingAccount();\n        final User caller = cctxt.getCallingUser();\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final Ternary<VMInstanceVO, ReservationContext, ItWorkVO> start = changeToStartState(vmGuru, vm, caller, account);\n        if (start == null) {\n            return;\n        }\n\n        vm = start.first();\n        final ReservationContext ctx = start.second();\n        ItWorkVO work = start.third();\n\n        VMInstanceVO startedVm = null;\n        final ServiceOfferingVO offering = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());\n        final VirtualMachineTemplate template = _entityMgr.findByIdIncludingRemoved(VirtualMachineTemplate.class, vm.getTemplateId());\n\n        DataCenterDeployment plan = new DataCenterDeployment(vm.getDataCenterId(), vm.getPodIdToDeployIn(), null, null, null, null, ctx);\n        if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"advanceStart: DeploymentPlan is provided, using dcId:\" + planToDeploy.getDataCenterId() + \", podId: \" + planToDeploy.getPodId() +\n                        \", clusterId: \" + planToDeploy.getClusterId() + \", hostId: \" + planToDeploy.getHostId() + \", poolId: \" + planToDeploy.getPoolId());\n            }\n            plan =\n                    new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(), planToDeploy.getHostId(),\n                            planToDeploy.getPoolId(), planToDeploy.getPhysicalNetworkId(), ctx);\n        }\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        \r\n        final Account owner = _entityMgr.findById(Account.class, vm.getAccountId());\n        if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n            resourceCountIncrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n        }\n\n        boolean canRetry = true;\n        ExcludeList avoids = null;\n        try {\n            final Journal journal = start.second().getJournal();\n\n            if (planToDeploy != null) {\n                avoids = planToDeploy.getAvoids();\n            }\n            if (avoids == null) {\n                avoids = new ExcludeList();\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Deploy avoids pods: \" + avoids.getPodsToAvoid() + \", clusters: \" + avoids.getClustersToAvoid() + \", hosts: \" + avoids.getHostsToAvoid());\n            }\n\n            boolean planChangedByVolume = false;\n            boolean reuseVolume = true;\n            final DataCenterDeployment originalPlan = plan;\n\n            int retry = StartRetry.value();\n            while (retry-- != 0) { \r\n                s_logger.debug(\"VM start attempt #\" + (StartRetry.value() - retry));\n\n                if (reuseVolume) {\n                    \r\n                    final List<VolumeVO> vols = _volsDao.findReadyRootVolumesByInstance(vm.getId());\n                    for (final VolumeVO vol : vols) {\n                        \r\n                        \r\n                        \r\n                        final Long volTemplateId = vol.getTemplateId();\n                        if (volTemplateId != null && volTemplateId.longValue() != template.getId()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(vol + \" of \" + vm + \" is READY, but template ids don't match, let the planner reassign a new pool\");\n                            }\n                            continue;\n                        }\n\n                        final StoragePool pool = (StoragePool)dataStoreMgr.getPrimaryDataStore(vol.getPoolId());\n                        if (!pool.isInMaintenance()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Root volume is ready, need to place VM in volume's cluster\");\n                            }\n                            final long rootVolDcId = pool.getDataCenterId();\n                            final Long rootVolPodId = pool.getPodId();\n                            final Long rootVolClusterId = pool.getClusterId();\n                            if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n                                final Long clusterIdSpecified = planToDeploy.getClusterId();\n                                if (clusterIdSpecified != null && rootVolClusterId != null) {\n                                    if (rootVolClusterId.longValue() != clusterIdSpecified.longValue()) {\n                                        \r\n                                        \r\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"Cannot satisfy the deployment plan passed in since the ready Root volume is in different cluster. volume's cluster: \" +\n                                                    rootVolClusterId + \", cluster specified: \" + clusterIdSpecified);\n                                        }\n                                        throw new ResourceUnavailableException(\n                                                \"Root volume is ready in different cluster, Deployment plan provided cannot be satisfied, unable to create a deployment for \" +\n                                                        vm, Cluster.class, clusterIdSpecified);\n                                    }\n                                }\n                                plan =\n                                        new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(),\n                                                planToDeploy.getHostId(), vol.getPoolId(), null, ctx);\n                            } else {\n                                plan = new DataCenterDeployment(rootVolDcId, rootVolPodId, rootVolClusterId, null, vol.getPoolId(), null, ctx);\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(vol + \" is READY, changing deployment plan to use this pool's dcId: \" + rootVolDcId + \" , podId: \" + rootVolPodId +\n                                            \" , and clusterId: \" + rootVolClusterId);\n                                }\n                                planChangedByVolume = true;\n                            }\n                        }\n                    }\n                }\n\n                final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vm, template, offering, owner, params);\n                logBootModeParameters(params);\n                DeployDestination dest = null;\n                try {\n                    dest = _dpMgr.planDeployment(vmProfile, plan, avoids, planner);\n                } catch (final AffinityConflictException e2) {\n                    s_logger.warn(\"Unable to create deployment, affinity rules associted to the VM conflict\", e2);\n                    throw new CloudRuntimeException(\"Unable to create deployment, affinity rules associted to the VM conflict\");\n                }\n\n                if (dest == null) {\n                    if (planChangedByVolume) {\n                        plan = originalPlan;\n                        planChangedByVolume = false;\n                        \r\n                        reuseVolume = false;\n                        continue;\n                    }\n                    throw new InsufficientServerCapacityException(\"Unable to create a deployment for \" + vmProfile, DataCenter.class, plan.getDataCenterId(),\n                            areAffinityGroupsAssociated(vmProfile));\n                }\n\n                if (dest != null) {\n                    avoids.addHost(dest.getHost().getId());\n                    if (!template.isDeployAsIs()) {\n                        journal.record(\"Deployment found - Attempt #\" + (StartRetry.value() - retry), vmProfile, dest);\n                    }\n                }\n\n                long destHostId = dest.getHost().getId();\n                vm.setPodIdToDeployIn(dest.getPod().getId());\n                final Long cluster_id = dest.getCluster().getId();\n                final ClusterDetailsVO cluster_detail_cpu = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                final ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                \r\n                if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) == null &&\n                        (Float.parseFloat(cluster_detail_cpu.getValue()) > 1f || Float.parseFloat(cluster_detail_ram.getValue()) > 1f)) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                } else if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) != null) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                }\n\n                vmProfile.setCpuOvercommitRatio(Float.parseFloat(cluster_detail_cpu.getValue()));\n                vmProfile.setMemoryOvercommitRatio(Float.parseFloat(cluster_detail_ram.getValue()));\n                StartAnswer startAnswer = null;\n\n                try {\n                    if (!changeState(vm, Event.OperationRetry, destHostId, work, Step.Prepare)) {\n                        throw new ConcurrentOperationException(\"Unable to update the state of the Virtual Machine \"+vm.getUuid()+\" oldstate: \"+vm.getState()+ \"Event :\"+Event.OperationRetry);\n                    }\n                } catch (final NoTransitionException e1) {\n                    throw new ConcurrentOperationException(e1.getMessage());\n                }\n\n                try {\n                    resetVmNicsDeviceId(vm.getId());\n                    _networkMgr.prepare(vmProfile, dest, ctx);\n                    if (vm.getHypervisorType() != HypervisorType.BareMetal) {\n                        volumeMgr.prepare(vmProfile, dest);\n                    }\n\n                    \r\n                    if (!reuseVolume) {\n                        reuseVolume = true;\n                    }\n\n                    Commands cmds = null;\n                    vmGuru.finalizeVirtualMachineProfile(vmProfile, dest, ctx);\n\n                    final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);\n\n                    checkAndSetEnterSetupMode(vmTO, params);\n\n                    handlePath(vmTO.getDisks(), vm.getHypervisorType());\n\n                    cmds = new Commands(Command.OnError.Stop);\n\n                    cmds.addCommand(new StartCommand(vmTO, dest.getHost(), getExecuteInSequence(vm.getHypervisorType())));\n\n                    vmGuru.finalizeDeployment(cmds, vmProfile, dest, ctx);\n\n                    \r\n                    addExtraConfig(vmTO);\n\n                    work = _workDao.findById(work.getId());\n                    if (work == null || work.getStep() != Step.Prepare) {\n                        throw new ConcurrentOperationException(\"Work steps have been changed: \" + work);\n                    }\n\n                    _workDao.updateStep(work, Step.Starting);\n\n                    _agentMgr.send(destHostId, cmds);\n\n                    _workDao.updateStep(work, Step.Started);\n\n                    startAnswer = cmds.getAnswer(StartAnswer.class);\n                    if (startAnswer != null && startAnswer.getResult()) {\n                        handlePath(vmTO.getDisks(), startAnswer.getIqnToData());\n\n                        final String host_guid = startAnswer.getHost_guid();\n\n                        if (host_guid != null) {\n                            final HostVO finalHost = _resourceMgr.findHostByGuid(host_guid);\n                            if (finalHost == null) {\n                                throw new CloudRuntimeException(\"Host Guid \" + host_guid + \" doesn't exist in DB, something went wrong while processing start answer: \"+startAnswer);\n                            }\n                            destHostId = finalHost.getId();\n                        }\n                        if (vmGuru.finalizeStart(vmProfile, destHostId, cmds, ctx)) {\n                            syncDiskChainChange(startAnswer);\n\n                            if (!changeState(vm, Event.OperationSucceeded, destHostId, work, Step.Done)) {\n                                s_logger.error(\"Unable to transition to a new state. VM uuid: \"+vm.getUuid()+    \"VM oldstate:\"+vm.getState()+\"Event:\"+Event.OperationSucceeded);\n                                throw new ConcurrentOperationException(\"Failed to deploy VM\"+ vm.getUuid());\n                            }\n\n                            \r\n                            final GPUDeviceTO gpuDevice = startAnswer.getVirtualMachine().getGpuDevice();\n                            if (gpuDevice != null) {\n                                _resourceMgr.updateGPUDetails(destHostId, gpuDevice.getGroupDetails());\n                            }\n\n                            \r\n                            \r\n                            \r\n                            if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.DEPLOY_VM) != null) {\n                                userVmDetailsDao.removeDetail(vm.getId(), VmDetailConstants.DEPLOY_VM);\n                            }\n\n                            startedVm = vm;\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Start completed for VM \" + vm);\n                            }\n                            final Host vmHost = _hostDao.findById(destHostId);\n                            if (vmHost != null && (VirtualMachine.Type.ConsoleProxy.equals(vm.getType()) ||\n                                    VirtualMachine.Type.SecondaryStorageVm.equals(vm.getType())) && caManager.canProvisionCertificates()) {\n                                final Map<String, String> sshAccessDetails = _networkMgr.getSystemVMAccessDetails(vm);\n                                for (int retries = 3; retries > 0; retries--) {\n                                    try {\n                                        setupAgentSecurity(vmHost, sshAccessDetails, vm);\n                                        return;\n                                    } catch (final Exception e) {\n                                        s_logger.error(\"Retrying after catching exception while trying to secure agent for systemvm id=\" + vm.getId(), e);\n                                    }\n                                }\n                                throw new CloudRuntimeException(\"Failed to setup and secure agent for systemvm id=\" + vm.getId());\n                            }\n                            return;\n                        } else {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.info(\"The guru did not like the answers so stopping \" + vm);\n                            }\n                            StopCommand stopCmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n                            stopCmd.setControlIp(getControlNicIpForVM(vm));\n                            final StopCommand cmd = stopCmd;\n                            final Answer answer = _agentMgr.easySend(destHostId, cmd);\n                            if (answer != null && answer instanceof StopAnswer) {\n                                final StopAnswer stopAns = (StopAnswer)answer;\n                                if (vm.getType() == VirtualMachine.Type.User) {\n                                    final String platform = stopAns.getPlatform();\n                                    if (platform != null) {\n                                        final Map<String,String> vmmetadata = new HashMap<String,String>();\n                                        vmmetadata.put(vm.getInstanceName(), platform);\n                                        syncVMMetaData(vmmetadata);\n                                    }\n                                }\n                            }\n\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.warn(\"Unable to stop \" + vm + \" due to \" + (answer != null ? answer.getDetails() : \"no answers\"));\n                                _haMgr.scheduleStop(vm, destHostId, WorkType.ForceStop);\n                                throw new ExecutionException(\"Unable to stop this VM, \"+vm.getUuid()+\" so we are unable to retry the start operation\");\n                            }\n                            throw new ExecutionException(\"Unable to start  VM:\"+vm.getUuid()+\" due to error in finalizeStart, not retrying\");\n                        }\n                    }\n                    s_logger.info(\"Unable to start VM on \" + dest.getHost() + \" due to \" + (startAnswer == null ? \" no start answer\" : startAnswer.getDetails()));\n                    if (startAnswer != null && startAnswer.getContextParam(\"stopRetry\") != null) {\n                        break;\n                    }\n\n                } catch (OperationTimedoutException e) {\n                    s_logger.debug(\"Unable to send the start command to host \" + dest.getHost()+\" failed to start VM: \"+vm.getUuid());\n                    if (e.isActive()) {\n                        _haMgr.scheduleStop(vm, destHostId, WorkType.CheckStop);\n                    }\n                    canRetry = false;\n                    throw new AgentUnavailableException(\"Unable to start \" + vm.getHostName(), destHostId, e);\n                } catch (final ResourceUnavailableException e) {\n                    s_logger.info(\"Unable to contact resource.\", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected ResourceUnavailableException : \" + e.getScope().getName(), e);\n                            throw e;\n                        }\n                    }\n                } catch (final InsufficientCapacityException e) {\n                    s_logger.info(\"Insufficient capacity \", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected InsufficientCapacityException : \" + e.getScope().getName(), e);\n                        }\n                    }\n                } catch (final ExecutionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final NoTransitionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final StorageAccessException e) {\n                    s_logger.warn(\"Unable to access storage on host\", e);\n                } finally {\n                    if (startedVm == null && canRetry) {\n                        final Step prevStep = work.getStep();\n                        _workDao.updateStep(work, Step.Release);\n                        \r\n                        if ((prevStep == Step.Started || prevStep == Step.Starting) && startAnswer != null && startAnswer.getResult()) {  \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, false);\n                        } else {\n                            \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, true);\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (startedVm == null) {\n                if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n                    resourceCountDecrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n                }\n                if (canRetry) {\n                    try {\n                        changeState(vm, Event.OperationFailed, null, work, Step.Done);\n                    } catch (final NoTransitionException e) {\n                        throw new ConcurrentOperationException(e.getMessage());\n                    }\n                }\n            }\n\n            if (planToDeploy != null) {\n                planToDeploy.setAvoids(avoids);\n            }\n        }\n\n        if (startedVm == null) {\n            throw new CloudRuntimeException(\"Unable to start instance '\" + vm.getHostName() + \"' (\" + vm.getUuid() + \"), see management server log for details\");\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":988,"status":"M"},{"authorDate":"2021-04-05 17:07:11","commitOrder":14,"curCode":"    public Command cleanup(final VirtualMachine vm, Map<String, DpdkTO> dpdkInterfaceMapping) {\n        StopCommand cmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n        cmd.setControlIp(getControlNicIpForVM(vm));\n        if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n            cmd.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n        }\n        Map<String, Boolean> vlanToPersistenceMap = getVlanToPersistenceMapForVM(vm.getId());\n        if (MapUtils.isNotEmpty(vlanToPersistenceMap)) {\n            cmd.setVlanToPersistenceMap(vlanToPersistenceMap);\n        }\n        return cmd;\n    }\n","date":"2021-04-05 17:07:11","endLine":3620,"groupId":"25415","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"cleanup","params":"(finalVirtualMachinevm@Map<String@DpdkTO>dpdkInterfaceMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/1e/92c3ed5be7e6ac76091149b4cc4fcfba874141.src","preCode":"    public Command cleanup(final VirtualMachine vm, Map<String, DpdkTO> dpdkInterfaceMapping) {\n        StopCommand cmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n        cmd.setControlIp(getControlNicIpForVM(vm));\n        if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n            cmd.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n        }\n        return cmd;\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":3609,"status":"M"}],"commitId":"0dbeb262e4f483e06ca335aadcee9664cf7f35c4","commitMessage":"@@@server: Support for persistence mode in L2 networks (#4561)\n\nThis PR aims at introducing persistence mode in L2 networks and enhancing the behavior in Isolated networks\nDoc PR apache/cloudstack-documentation#183\n\nCo-authored-by: Pearl Dsilva <pearl.dsilva@shapeblue.com>","date":"2021-04-05 17:07:11","modifiedFileCount":"27","status":"M","submitter":"Pearl Dsilva"},{"authorTime":"2021-04-05 17:07:11","codes":[{"authorDate":"2021-09-24 12:21:16","commitOrder":15,"curCode":"    public void orchestrateStart(final String vmUuid, final Map<VirtualMachineProfile.Param, Object> params, final DeploymentPlan planToDeploy, final DeploymentPlanner planner)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {\n\n        final CallContext cctxt = CallContext.current();\n        final Account account = cctxt.getCallingAccount();\n        final User caller = cctxt.getCallingUser();\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final Ternary<VMInstanceVO, ReservationContext, ItWorkVO> start = changeToStartState(vmGuru, vm, caller, account);\n        if (start == null) {\n            return;\n        }\n\n        vm = start.first();\n        final ReservationContext ctx = start.second();\n        ItWorkVO work = start.third();\n\n        VMInstanceVO startedVm = null;\n        final ServiceOfferingVO offering = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());\n        final VirtualMachineTemplate template = _entityMgr.findByIdIncludingRemoved(VirtualMachineTemplate.class, vm.getTemplateId());\n\n        DataCenterDeployment plan = new DataCenterDeployment(vm.getDataCenterId(), vm.getPodIdToDeployIn(), null, null, null, null, ctx);\n        if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"advanceStart: DeploymentPlan is provided, using dcId:\" + planToDeploy.getDataCenterId() + \", podId: \" + planToDeploy.getPodId() +\n                        \", clusterId: \" + planToDeploy.getClusterId() + \", hostId: \" + planToDeploy.getHostId() + \", poolId: \" + planToDeploy.getPoolId());\n            }\n            plan =\n                    new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(), planToDeploy.getHostId(),\n                            planToDeploy.getPoolId(), planToDeploy.getPhysicalNetworkId(), ctx);\n        }\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        \r\n        final Account owner = _entityMgr.findById(Account.class, vm.getAccountId());\n        if (VirtualMachine.Type.User.equals(vm.type) && ResourceCountRunningVMsonly.value()) {\n            resourceCountIncrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n        }\n\n        boolean canRetry = true;\n        ExcludeList avoids = null;\n        try {\n            final Journal journal = start.second().getJournal();\n\n            if (planToDeploy != null) {\n                avoids = planToDeploy.getAvoids();\n            }\n            if (avoids == null) {\n                avoids = new ExcludeList();\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Deploy avoids pods: \" + avoids.getPodsToAvoid() + \", clusters: \" + avoids.getClustersToAvoid() + \", hosts: \" + avoids.getHostsToAvoid());\n            }\n\n            boolean planChangedByVolume = false;\n            boolean reuseVolume = true;\n            final DataCenterDeployment originalPlan = plan;\n\n            int retry = StartRetry.value();\n            while (retry-- != 0) { \r\n                s_logger.debug(\"VM start attempt #\" + (StartRetry.value() - retry));\n\n                if (reuseVolume) {\n                    \r\n                    final List<VolumeVO> vols = _volsDao.findReadyRootVolumesByInstance(vm.getId());\n                    for (final VolumeVO vol : vols) {\n                        \r\n                        \r\n                        \r\n                        final Long volTemplateId = vol.getTemplateId();\n                        if (volTemplateId != null && volTemplateId.longValue() != template.getId()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(vol + \" of \" + vm + \" is READY, but template ids don't match, let the planner reassign a new pool\");\n                            }\n                            continue;\n                        }\n\n                        final StoragePool pool = (StoragePool)dataStoreMgr.getPrimaryDataStore(vol.getPoolId());\n                        if (!pool.isInMaintenance()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Root volume is ready, need to place VM in volume's cluster\");\n                            }\n                            final long rootVolDcId = pool.getDataCenterId();\n                            final Long rootVolPodId = pool.getPodId();\n                            final Long rootVolClusterId = pool.getClusterId();\n                            if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n                                final Long clusterIdSpecified = planToDeploy.getClusterId();\n                                if (clusterIdSpecified != null && rootVolClusterId != null) {\n                                    if (rootVolClusterId.longValue() != clusterIdSpecified.longValue()) {\n                                        \r\n                                        \r\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"Cannot satisfy the deployment plan passed in since the ready Root volume is in different cluster. volume's cluster: \" +\n                                                    rootVolClusterId + \", cluster specified: \" + clusterIdSpecified);\n                                        }\n                                        throw new ResourceUnavailableException(\n                                                \"Root volume is ready in different cluster, Deployment plan provided cannot be satisfied, unable to create a deployment for \" +\n                                                        vm, Cluster.class, clusterIdSpecified);\n                                    }\n                                }\n                                plan =\n                                        new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(),\n                                                planToDeploy.getHostId(), vol.getPoolId(), null, ctx);\n                            } else {\n                                plan = new DataCenterDeployment(rootVolDcId, rootVolPodId, rootVolClusterId, null, vol.getPoolId(), null, ctx);\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(vol + \" is READY, changing deployment plan to use this pool's dcId: \" + rootVolDcId + \" , podId: \" + rootVolPodId +\n                                            \" , and clusterId: \" + rootVolClusterId);\n                                }\n                                planChangedByVolume = true;\n                            }\n                        }\n                    }\n                }\n\n                final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vm, template, offering, owner, params);\n                logBootModeParameters(params);\n                DeployDestination dest = null;\n                try {\n                    dest = _dpMgr.planDeployment(vmProfile, plan, avoids, planner);\n                } catch (final AffinityConflictException e2) {\n                    s_logger.warn(\"Unable to create deployment, affinity rules associted to the VM conflict\", e2);\n                    throw new CloudRuntimeException(\"Unable to create deployment, affinity rules associted to the VM conflict\");\n                }\n\n                if (dest == null) {\n                    if (planChangedByVolume) {\n                        plan = originalPlan;\n                        planChangedByVolume = false;\n                        \r\n                        reuseVolume = false;\n                        continue;\n                    }\n                    throw new InsufficientServerCapacityException(\"Unable to create a deployment for \" + vmProfile, DataCenter.class, plan.getDataCenterId(),\n                            areAffinityGroupsAssociated(vmProfile));\n                }\n\n                if (dest != null) {\n                    avoids.addHost(dest.getHost().getId());\n                    if (!template.isDeployAsIs()) {\n                        journal.record(\"Deployment found - Attempt #\" + (StartRetry.value() - retry), vmProfile, dest);\n                    }\n                }\n\n                long destHostId = dest.getHost().getId();\n                vm.setPodIdToDeployIn(dest.getPod().getId());\n                final Long cluster_id = dest.getCluster().getId();\n                final ClusterDetailsVO cluster_detail_cpu = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                final ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                \r\n                if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) == null &&\n                        (Float.parseFloat(cluster_detail_cpu.getValue()) > 1f || Float.parseFloat(cluster_detail_ram.getValue()) > 1f)) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                } else if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) != null) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                }\n\n                vmProfile.setCpuOvercommitRatio(Float.parseFloat(cluster_detail_cpu.getValue()));\n                vmProfile.setMemoryOvercommitRatio(Float.parseFloat(cluster_detail_ram.getValue()));\n                StartAnswer startAnswer = null;\n\n                try {\n                    if (!changeState(vm, Event.OperationRetry, destHostId, work, Step.Prepare)) {\n                        throw new ConcurrentOperationException(\"Unable to update the state of the Virtual Machine \"+vm.getUuid()+\" oldstate: \"+vm.getState()+ \"Event :\"+Event.OperationRetry);\n                    }\n                } catch (final NoTransitionException e1) {\n                    throw new ConcurrentOperationException(e1.getMessage());\n                }\n\n                try {\n                    resetVmNicsDeviceId(vm.getId());\n                    _networkMgr.prepare(vmProfile, dest, ctx);\n                    if (vm.getHypervisorType() != HypervisorType.BareMetal) {\n                        volumeMgr.prepare(vmProfile, dest);\n                    }\n\n                    \r\n                    if (!reuseVolume) {\n                        reuseVolume = true;\n                    }\n\n                    Commands cmds = null;\n                    vmGuru.finalizeVirtualMachineProfile(vmProfile, dest, ctx);\n\n                    final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);\n\n                    checkAndSetEnterSetupMode(vmTO, params);\n\n                    handlePath(vmTO.getDisks(), vm.getHypervisorType());\n\n                    cmds = new Commands(Command.OnError.Stop);\n\n                    cmds.addCommand(new StartCommand(vmTO, dest.getHost(), getExecuteInSequence(vm.getHypervisorType())));\n\n                    vmGuru.finalizeDeployment(cmds, vmProfile, dest, ctx);\n\n                    \r\n                    addExtraConfig(vmTO);\n\n                    work = _workDao.findById(work.getId());\n                    if (work == null || work.getStep() != Step.Prepare) {\n                        throw new ConcurrentOperationException(\"Work steps have been changed: \" + work);\n                    }\n\n                    _workDao.updateStep(work, Step.Starting);\n\n                    _agentMgr.send(destHostId, cmds);\n\n                    _workDao.updateStep(work, Step.Started);\n\n                    startAnswer = cmds.getAnswer(StartAnswer.class);\n                    if (startAnswer != null && startAnswer.getResult()) {\n                        handlePath(vmTO.getDisks(), startAnswer.getIqnToData());\n\n                        final String host_guid = startAnswer.getHost_guid();\n\n                        if (host_guid != null) {\n                            final HostVO finalHost = _resourceMgr.findHostByGuid(host_guid);\n                            if (finalHost == null) {\n                                throw new CloudRuntimeException(\"Host Guid \" + host_guid + \" doesn't exist in DB, something went wrong while processing start answer: \"+startAnswer);\n                            }\n                            destHostId = finalHost.getId();\n                        }\n                        if (vmGuru.finalizeStart(vmProfile, destHostId, cmds, ctx)) {\n                            syncDiskChainChange(startAnswer);\n\n                            if (!changeState(vm, Event.OperationSucceeded, destHostId, work, Step.Done)) {\n                                s_logger.error(\"Unable to transition to a new state. VM uuid: \"+vm.getUuid()+    \"VM oldstate:\"+vm.getState()+\"Event:\"+Event.OperationSucceeded);\n                                throw new ConcurrentOperationException(\"Failed to deploy VM\"+ vm.getUuid());\n                            }\n\n                            \r\n                            final GPUDeviceTO gpuDevice = startAnswer.getVirtualMachine().getGpuDevice();\n                            if (gpuDevice != null) {\n                                _resourceMgr.updateGPUDetails(destHostId, gpuDevice.getGroupDetails());\n                            }\n\n                            \r\n                            \r\n                            \r\n                            if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.DEPLOY_VM) != null) {\n                                userVmDetailsDao.removeDetail(vm.getId(), VmDetailConstants.DEPLOY_VM);\n                            }\n\n                            startedVm = vm;\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Start completed for VM \" + vm);\n                            }\n                            final Host vmHost = _hostDao.findById(destHostId);\n                            if (vmHost != null && (VirtualMachine.Type.ConsoleProxy.equals(vm.getType()) ||\n                                    VirtualMachine.Type.SecondaryStorageVm.equals(vm.getType())) && caManager.canProvisionCertificates()) {\n                                final Map<String, String> sshAccessDetails = _networkMgr.getSystemVMAccessDetails(vm);\n                                for (int retries = 3; retries > 0; retries--) {\n                                    try {\n                                        setupAgentSecurity(vmHost, sshAccessDetails, vm);\n                                        return;\n                                    } catch (final Exception e) {\n                                        s_logger.error(\"Retrying after catching exception while trying to secure agent for systemvm id=\" + vm.getId(), e);\n                                    }\n                                }\n                                throw new CloudRuntimeException(\"Failed to setup and secure agent for systemvm id=\" + vm.getId());\n                            }\n                            return;\n                        } else {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.info(\"The guru did not like the answers so stopping \" + vm);\n                            }\n                            StopCommand stopCmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n                            stopCmd.setControlIp(getControlNicIpForVM(vm));\n                            Map<String, Boolean> vlanToPersistenceMap = getVlanToPersistenceMapForVM(vm.getId());\n                            if (MapUtils.isNotEmpty(vlanToPersistenceMap)) {\n                                stopCmd.setVlanToPersistenceMap(vlanToPersistenceMap);\n                            }\n                            final StopCommand cmd = stopCmd;\n                            final Answer answer = _agentMgr.easySend(destHostId, cmd);\n                            if (answer != null && answer instanceof StopAnswer) {\n                                final StopAnswer stopAns = (StopAnswer)answer;\n                                if (vm.getType() == VirtualMachine.Type.User) {\n                                    final String platform = stopAns.getPlatform();\n                                    if (platform != null) {\n                                        final Map<String,String> vmmetadata = new HashMap<String,String>();\n                                        vmmetadata.put(vm.getInstanceName(), platform);\n                                        syncVMMetaData(vmmetadata);\n                                    }\n                                }\n                            }\n\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.warn(\"Unable to stop \" + vm + \" due to \" + (answer != null ? answer.getDetails() : \"no answers\"));\n                                _haMgr.scheduleStop(vm, destHostId, WorkType.ForceStop);\n                                throw new ExecutionException(\"Unable to stop this VM, \"+vm.getUuid()+\" so we are unable to retry the start operation\");\n                            }\n                            throw new ExecutionException(\"Unable to start  VM:\"+vm.getUuid()+\" due to error in finalizeStart, not retrying\");\n                        }\n                    }\n                    s_logger.info(\"Unable to start VM on \" + dest.getHost() + \" due to \" + (startAnswer == null ? \" no start answer\" : startAnswer.getDetails()));\n                    if (startAnswer != null && startAnswer.getContextParam(\"stopRetry\") != null) {\n                        break;\n                    }\n\n                } catch (OperationTimedoutException e) {\n                    s_logger.debug(\"Unable to send the start command to host \" + dest.getHost()+\" failed to start VM: \"+vm.getUuid());\n                    if (e.isActive()) {\n                        _haMgr.scheduleStop(vm, destHostId, WorkType.CheckStop);\n                    }\n                    canRetry = false;\n                    throw new AgentUnavailableException(\"Unable to start \" + vm.getHostName(), destHostId, e);\n                } catch (final ResourceUnavailableException e) {\n                    s_logger.info(\"Unable to contact resource.\", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected ResourceUnavailableException : \" + e.getScope().getName(), e);\n                            throw e;\n                        }\n                    }\n                } catch (final InsufficientCapacityException e) {\n                    s_logger.info(\"Insufficient capacity \", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected InsufficientCapacityException : \" + e.getScope().getName(), e);\n                        }\n                    }\n                } catch (final ExecutionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final NoTransitionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final StorageAccessException e) {\n                    s_logger.warn(\"Unable to access storage on host\", e);\n                } finally {\n                    if (startedVm == null && canRetry) {\n                        final Step prevStep = work.getStep();\n                        _workDao.updateStep(work, Step.Release);\n                        \r\n                        if ((prevStep == Step.Started || prevStep == Step.Starting) && startAnswer != null && startAnswer.getResult()) {  \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, false);\n                        } else {\n                            \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, true);\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (startedVm == null) {\n                if (VirtualMachine.Type.User.equals(vm.type) && ResourceCountRunningVMsonly.value()) {\n                    resourceCountDecrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n                }\n                if (canRetry) {\n                    try {\n                        changeState(vm, Event.OperationFailed, null, work, Step.Done);\n                    } catch (final NoTransitionException e) {\n                        throw new ConcurrentOperationException(e.getMessage());\n                    }\n                }\n            }\n\n            if (planToDeploy != null) {\n                planToDeploy.setAvoids(avoids);\n            }\n        }\n\n        if (startedVm == null) {\n            throw new CloudRuntimeException(\"Unable to start instance '\" + vm.getHostName() + \"' (\" + vm.getUuid() + \"), see management server log for details\");\n        }\n    }\n","date":"2021-09-24 12:21:16","endLine":1390,"groupId":"12560","id":21,"instanceNumber":1,"isCurCommit":1,"methodName":"orchestrateStart","params":"(finalStringvmUuid@finalMap<VirtualMachineProfile.Param@Object>params@finalDeploymentPlanplanToDeploy@finalDeploymentPlannerplanner)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/85/4d5a2107d971b30544da1b90c0f512c77ac99f.src","preCode":"    public void orchestrateStart(final String vmUuid, final Map<VirtualMachineProfile.Param, Object> params, final DeploymentPlan planToDeploy, final DeploymentPlanner planner)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {\n\n        final CallContext cctxt = CallContext.current();\n        final Account account = cctxt.getCallingAccount();\n        final User caller = cctxt.getCallingUser();\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final Ternary<VMInstanceVO, ReservationContext, ItWorkVO> start = changeToStartState(vmGuru, vm, caller, account);\n        if (start == null) {\n            return;\n        }\n\n        vm = start.first();\n        final ReservationContext ctx = start.second();\n        ItWorkVO work = start.third();\n\n        VMInstanceVO startedVm = null;\n        final ServiceOfferingVO offering = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());\n        final VirtualMachineTemplate template = _entityMgr.findByIdIncludingRemoved(VirtualMachineTemplate.class, vm.getTemplateId());\n\n        DataCenterDeployment plan = new DataCenterDeployment(vm.getDataCenterId(), vm.getPodIdToDeployIn(), null, null, null, null, ctx);\n        if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"advanceStart: DeploymentPlan is provided, using dcId:\" + planToDeploy.getDataCenterId() + \", podId: \" + planToDeploy.getPodId() +\n                        \", clusterId: \" + planToDeploy.getClusterId() + \", hostId: \" + planToDeploy.getHostId() + \", poolId: \" + planToDeploy.getPoolId());\n            }\n            plan =\n                    new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(), planToDeploy.getHostId(),\n                            planToDeploy.getPoolId(), planToDeploy.getPhysicalNetworkId(), ctx);\n        }\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        \r\n        final Account owner = _entityMgr.findById(Account.class, vm.getAccountId());\n        if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n            resourceCountIncrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n        }\n\n        boolean canRetry = true;\n        ExcludeList avoids = null;\n        try {\n            final Journal journal = start.second().getJournal();\n\n            if (planToDeploy != null) {\n                avoids = planToDeploy.getAvoids();\n            }\n            if (avoids == null) {\n                avoids = new ExcludeList();\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Deploy avoids pods: \" + avoids.getPodsToAvoid() + \", clusters: \" + avoids.getClustersToAvoid() + \", hosts: \" + avoids.getHostsToAvoid());\n            }\n\n            boolean planChangedByVolume = false;\n            boolean reuseVolume = true;\n            final DataCenterDeployment originalPlan = plan;\n\n            int retry = StartRetry.value();\n            while (retry-- != 0) { \r\n                s_logger.debug(\"VM start attempt #\" + (StartRetry.value() - retry));\n\n                if (reuseVolume) {\n                    \r\n                    final List<VolumeVO> vols = _volsDao.findReadyRootVolumesByInstance(vm.getId());\n                    for (final VolumeVO vol : vols) {\n                        \r\n                        \r\n                        \r\n                        final Long volTemplateId = vol.getTemplateId();\n                        if (volTemplateId != null && volTemplateId.longValue() != template.getId()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(vol + \" of \" + vm + \" is READY, but template ids don't match, let the planner reassign a new pool\");\n                            }\n                            continue;\n                        }\n\n                        final StoragePool pool = (StoragePool)dataStoreMgr.getPrimaryDataStore(vol.getPoolId());\n                        if (!pool.isInMaintenance()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Root volume is ready, need to place VM in volume's cluster\");\n                            }\n                            final long rootVolDcId = pool.getDataCenterId();\n                            final Long rootVolPodId = pool.getPodId();\n                            final Long rootVolClusterId = pool.getClusterId();\n                            if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n                                final Long clusterIdSpecified = planToDeploy.getClusterId();\n                                if (clusterIdSpecified != null && rootVolClusterId != null) {\n                                    if (rootVolClusterId.longValue() != clusterIdSpecified.longValue()) {\n                                        \r\n                                        \r\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"Cannot satisfy the deployment plan passed in since the ready Root volume is in different cluster. volume's cluster: \" +\n                                                    rootVolClusterId + \", cluster specified: \" + clusterIdSpecified);\n                                        }\n                                        throw new ResourceUnavailableException(\n                                                \"Root volume is ready in different cluster, Deployment plan provided cannot be satisfied, unable to create a deployment for \" +\n                                                        vm, Cluster.class, clusterIdSpecified);\n                                    }\n                                }\n                                plan =\n                                        new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(),\n                                                planToDeploy.getHostId(), vol.getPoolId(), null, ctx);\n                            } else {\n                                plan = new DataCenterDeployment(rootVolDcId, rootVolPodId, rootVolClusterId, null, vol.getPoolId(), null, ctx);\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(vol + \" is READY, changing deployment plan to use this pool's dcId: \" + rootVolDcId + \" , podId: \" + rootVolPodId +\n                                            \" , and clusterId: \" + rootVolClusterId);\n                                }\n                                planChangedByVolume = true;\n                            }\n                        }\n                    }\n                }\n\n                final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vm, template, offering, owner, params);\n                logBootModeParameters(params);\n                DeployDestination dest = null;\n                try {\n                    dest = _dpMgr.planDeployment(vmProfile, plan, avoids, planner);\n                } catch (final AffinityConflictException e2) {\n                    s_logger.warn(\"Unable to create deployment, affinity rules associted to the VM conflict\", e2);\n                    throw new CloudRuntimeException(\"Unable to create deployment, affinity rules associted to the VM conflict\");\n                }\n\n                if (dest == null) {\n                    if (planChangedByVolume) {\n                        plan = originalPlan;\n                        planChangedByVolume = false;\n                        \r\n                        reuseVolume = false;\n                        continue;\n                    }\n                    throw new InsufficientServerCapacityException(\"Unable to create a deployment for \" + vmProfile, DataCenter.class, plan.getDataCenterId(),\n                            areAffinityGroupsAssociated(vmProfile));\n                }\n\n                if (dest != null) {\n                    avoids.addHost(dest.getHost().getId());\n                    if (!template.isDeployAsIs()) {\n                        journal.record(\"Deployment found - Attempt #\" + (StartRetry.value() - retry), vmProfile, dest);\n                    }\n                }\n\n                long destHostId = dest.getHost().getId();\n                vm.setPodIdToDeployIn(dest.getPod().getId());\n                final Long cluster_id = dest.getCluster().getId();\n                final ClusterDetailsVO cluster_detail_cpu = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                final ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                \r\n                if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) == null &&\n                        (Float.parseFloat(cluster_detail_cpu.getValue()) > 1f || Float.parseFloat(cluster_detail_ram.getValue()) > 1f)) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                } else if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) != null) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                }\n\n                vmProfile.setCpuOvercommitRatio(Float.parseFloat(cluster_detail_cpu.getValue()));\n                vmProfile.setMemoryOvercommitRatio(Float.parseFloat(cluster_detail_ram.getValue()));\n                StartAnswer startAnswer = null;\n\n                try {\n                    if (!changeState(vm, Event.OperationRetry, destHostId, work, Step.Prepare)) {\n                        throw new ConcurrentOperationException(\"Unable to update the state of the Virtual Machine \"+vm.getUuid()+\" oldstate: \"+vm.getState()+ \"Event :\"+Event.OperationRetry);\n                    }\n                } catch (final NoTransitionException e1) {\n                    throw new ConcurrentOperationException(e1.getMessage());\n                }\n\n                try {\n                    resetVmNicsDeviceId(vm.getId());\n                    _networkMgr.prepare(vmProfile, dest, ctx);\n                    if (vm.getHypervisorType() != HypervisorType.BareMetal) {\n                        volumeMgr.prepare(vmProfile, dest);\n                    }\n\n                    \r\n                    if (!reuseVolume) {\n                        reuseVolume = true;\n                    }\n\n                    Commands cmds = null;\n                    vmGuru.finalizeVirtualMachineProfile(vmProfile, dest, ctx);\n\n                    final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);\n\n                    checkAndSetEnterSetupMode(vmTO, params);\n\n                    handlePath(vmTO.getDisks(), vm.getHypervisorType());\n\n                    cmds = new Commands(Command.OnError.Stop);\n\n                    cmds.addCommand(new StartCommand(vmTO, dest.getHost(), getExecuteInSequence(vm.getHypervisorType())));\n\n                    vmGuru.finalizeDeployment(cmds, vmProfile, dest, ctx);\n\n                    \r\n                    addExtraConfig(vmTO);\n\n                    work = _workDao.findById(work.getId());\n                    if (work == null || work.getStep() != Step.Prepare) {\n                        throw new ConcurrentOperationException(\"Work steps have been changed: \" + work);\n                    }\n\n                    _workDao.updateStep(work, Step.Starting);\n\n                    _agentMgr.send(destHostId, cmds);\n\n                    _workDao.updateStep(work, Step.Started);\n\n                    startAnswer = cmds.getAnswer(StartAnswer.class);\n                    if (startAnswer != null && startAnswer.getResult()) {\n                        handlePath(vmTO.getDisks(), startAnswer.getIqnToData());\n\n                        final String host_guid = startAnswer.getHost_guid();\n\n                        if (host_guid != null) {\n                            final HostVO finalHost = _resourceMgr.findHostByGuid(host_guid);\n                            if (finalHost == null) {\n                                throw new CloudRuntimeException(\"Host Guid \" + host_guid + \" doesn't exist in DB, something went wrong while processing start answer: \"+startAnswer);\n                            }\n                            destHostId = finalHost.getId();\n                        }\n                        if (vmGuru.finalizeStart(vmProfile, destHostId, cmds, ctx)) {\n                            syncDiskChainChange(startAnswer);\n\n                            if (!changeState(vm, Event.OperationSucceeded, destHostId, work, Step.Done)) {\n                                s_logger.error(\"Unable to transition to a new state. VM uuid: \"+vm.getUuid()+    \"VM oldstate:\"+vm.getState()+\"Event:\"+Event.OperationSucceeded);\n                                throw new ConcurrentOperationException(\"Failed to deploy VM\"+ vm.getUuid());\n                            }\n\n                            \r\n                            final GPUDeviceTO gpuDevice = startAnswer.getVirtualMachine().getGpuDevice();\n                            if (gpuDevice != null) {\n                                _resourceMgr.updateGPUDetails(destHostId, gpuDevice.getGroupDetails());\n                            }\n\n                            \r\n                            \r\n                            \r\n                            if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.DEPLOY_VM) != null) {\n                                userVmDetailsDao.removeDetail(vm.getId(), VmDetailConstants.DEPLOY_VM);\n                            }\n\n                            startedVm = vm;\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Start completed for VM \" + vm);\n                            }\n                            final Host vmHost = _hostDao.findById(destHostId);\n                            if (vmHost != null && (VirtualMachine.Type.ConsoleProxy.equals(vm.getType()) ||\n                                    VirtualMachine.Type.SecondaryStorageVm.equals(vm.getType())) && caManager.canProvisionCertificates()) {\n                                final Map<String, String> sshAccessDetails = _networkMgr.getSystemVMAccessDetails(vm);\n                                for (int retries = 3; retries > 0; retries--) {\n                                    try {\n                                        setupAgentSecurity(vmHost, sshAccessDetails, vm);\n                                        return;\n                                    } catch (final Exception e) {\n                                        s_logger.error(\"Retrying after catching exception while trying to secure agent for systemvm id=\" + vm.getId(), e);\n                                    }\n                                }\n                                throw new CloudRuntimeException(\"Failed to setup and secure agent for systemvm id=\" + vm.getId());\n                            }\n                            return;\n                        } else {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.info(\"The guru did not like the answers so stopping \" + vm);\n                            }\n                            StopCommand stopCmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n                            stopCmd.setControlIp(getControlNicIpForVM(vm));\n                            Map<String, Boolean> vlanToPersistenceMap = getVlanToPersistenceMapForVM(vm.getId());\n                            if (MapUtils.isNotEmpty(vlanToPersistenceMap)) {\n                                stopCmd.setVlanToPersistenceMap(vlanToPersistenceMap);\n                            }\n                            final StopCommand cmd = stopCmd;\n                            final Answer answer = _agentMgr.easySend(destHostId, cmd);\n                            if (answer != null && answer instanceof StopAnswer) {\n                                final StopAnswer stopAns = (StopAnswer)answer;\n                                if (vm.getType() == VirtualMachine.Type.User) {\n                                    final String platform = stopAns.getPlatform();\n                                    if (platform != null) {\n                                        final Map<String,String> vmmetadata = new HashMap<String,String>();\n                                        vmmetadata.put(vm.getInstanceName(), platform);\n                                        syncVMMetaData(vmmetadata);\n                                    }\n                                }\n                            }\n\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.warn(\"Unable to stop \" + vm + \" due to \" + (answer != null ? answer.getDetails() : \"no answers\"));\n                                _haMgr.scheduleStop(vm, destHostId, WorkType.ForceStop);\n                                throw new ExecutionException(\"Unable to stop this VM, \"+vm.getUuid()+\" so we are unable to retry the start operation\");\n                            }\n                            throw new ExecutionException(\"Unable to start  VM:\"+vm.getUuid()+\" due to error in finalizeStart, not retrying\");\n                        }\n                    }\n                    s_logger.info(\"Unable to start VM on \" + dest.getHost() + \" due to \" + (startAnswer == null ? \" no start answer\" : startAnswer.getDetails()));\n                    if (startAnswer != null && startAnswer.getContextParam(\"stopRetry\") != null) {\n                        break;\n                    }\n\n                } catch (OperationTimedoutException e) {\n                    s_logger.debug(\"Unable to send the start command to host \" + dest.getHost()+\" failed to start VM: \"+vm.getUuid());\n                    if (e.isActive()) {\n                        _haMgr.scheduleStop(vm, destHostId, WorkType.CheckStop);\n                    }\n                    canRetry = false;\n                    throw new AgentUnavailableException(\"Unable to start \" + vm.getHostName(), destHostId, e);\n                } catch (final ResourceUnavailableException e) {\n                    s_logger.info(\"Unable to contact resource.\", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected ResourceUnavailableException : \" + e.getScope().getName(), e);\n                            throw e;\n                        }\n                    }\n                } catch (final InsufficientCapacityException e) {\n                    s_logger.info(\"Insufficient capacity \", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected InsufficientCapacityException : \" + e.getScope().getName(), e);\n                        }\n                    }\n                } catch (final ExecutionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final NoTransitionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final StorageAccessException e) {\n                    s_logger.warn(\"Unable to access storage on host\", e);\n                } finally {\n                    if (startedVm == null && canRetry) {\n                        final Step prevStep = work.getStep();\n                        _workDao.updateStep(work, Step.Release);\n                        \r\n                        if ((prevStep == Step.Started || prevStep == Step.Starting) && startAnswer != null && startAnswer.getResult()) {  \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, false);\n                        } else {\n                            \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, true);\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (startedVm == null) {\n                if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n                    resourceCountDecrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n                }\n                if (canRetry) {\n                    try {\n                        changeState(vm, Event.OperationFailed, null, work, Step.Done);\n                    } catch (final NoTransitionException e) {\n                        throw new ConcurrentOperationException(e.getMessage());\n                    }\n                }\n            }\n\n            if (planToDeploy != null) {\n                planToDeploy.setAvoids(avoids);\n            }\n        }\n\n        if (startedVm == null) {\n            throw new CloudRuntimeException(\"Unable to start instance '\" + vm.getHostName() + \"' (\" + vm.getUuid() + \"), see management server log for details\");\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1014,"status":"M"},{"authorDate":"2021-04-05 17:07:11","commitOrder":15,"curCode":"    public Command cleanup(final VirtualMachine vm, Map<String, DpdkTO> dpdkInterfaceMapping) {\n        StopCommand cmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n        cmd.setControlIp(getControlNicIpForVM(vm));\n        if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n            cmd.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n        }\n        Map<String, Boolean> vlanToPersistenceMap = getVlanToPersistenceMapForVM(vm.getId());\n        if (MapUtils.isNotEmpty(vlanToPersistenceMap)) {\n            cmd.setVlanToPersistenceMap(vlanToPersistenceMap);\n        }\n        return cmd;\n    }\n","date":"2021-04-05 17:07:11","endLine":3620,"groupId":"12560","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"cleanup","params":"(finalVirtualMachinevm@Map<String@DpdkTO>dpdkInterfaceMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/1e/92c3ed5be7e6ac76091149b4cc4fcfba874141.src","preCode":"    public Command cleanup(final VirtualMachine vm, Map<String, DpdkTO> dpdkInterfaceMapping) {\n        StopCommand cmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n        cmd.setControlIp(getControlNicIpForVM(vm));\n        if (MapUtils.isNotEmpty(dpdkInterfaceMapping)) {\n            cmd.setDpdkInterfaceMapping(dpdkInterfaceMapping);\n        }\n        Map<String, Boolean> vlanToPersistenceMap = getVlanToPersistenceMapForVM(vm.getId());\n        if (MapUtils.isNotEmpty(vlanToPersistenceMap)) {\n            cmd.setVlanToPersistenceMap(vlanToPersistenceMap);\n        }\n        return cmd;\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":3609,"status":"N"}],"commitId":"74bb80687d4cea1288a964d12b43108117cb5744","commitMessage":"@@@resource limit: Fix resource limit check on VM start (#5428)\n\n* resource limit: Fix resource limit check on VM start\n\n* add check to validate if cpu/memory are within limits for custom offering + exception handling\n\n* unit tests\n\nCo-authored-by: utchoang <hoangnm@unitech.vn>","date":"2021-09-24 12:21:16","modifiedFileCount":"6","status":"M","submitter":"Pearl Dsilva"}]
