[{"authorTime":"2021-04-05 17:07:11","codes":[{"authorDate":"2021-04-05 17:07:11","commitOrder":14,"curCode":"    public void orchestrateStart(final String vmUuid, final Map<VirtualMachineProfile.Param, Object> params, final DeploymentPlan planToDeploy, final DeploymentPlanner planner)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {\n\n        final CallContext cctxt = CallContext.current();\n        final Account account = cctxt.getCallingAccount();\n        final User caller = cctxt.getCallingUser();\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final Ternary<VMInstanceVO, ReservationContext, ItWorkVO> start = changeToStartState(vmGuru, vm, caller, account);\n        if (start == null) {\n            return;\n        }\n\n        vm = start.first();\n        final ReservationContext ctx = start.second();\n        ItWorkVO work = start.third();\n\n        VMInstanceVO startedVm = null;\n        final ServiceOfferingVO offering = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());\n        final VirtualMachineTemplate template = _entityMgr.findByIdIncludingRemoved(VirtualMachineTemplate.class, vm.getTemplateId());\n\n        DataCenterDeployment plan = new DataCenterDeployment(vm.getDataCenterId(), vm.getPodIdToDeployIn(), null, null, null, null, ctx);\n        if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"advanceStart: DeploymentPlan is provided, using dcId:\" + planToDeploy.getDataCenterId() + \", podId: \" + planToDeploy.getPodId() +\n                        \", clusterId: \" + planToDeploy.getClusterId() + \", hostId: \" + planToDeploy.getHostId() + \", poolId: \" + planToDeploy.getPoolId());\n            }\n            plan =\n                    new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(), planToDeploy.getHostId(),\n                            planToDeploy.getPoolId(), planToDeploy.getPhysicalNetworkId(), ctx);\n        }\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        \r\n        final Account owner = _entityMgr.findById(Account.class, vm.getAccountId());\n        if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n            resourceCountIncrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n        }\n\n        boolean canRetry = true;\n        ExcludeList avoids = null;\n        try {\n            final Journal journal = start.second().getJournal();\n\n            if (planToDeploy != null) {\n                avoids = planToDeploy.getAvoids();\n            }\n            if (avoids == null) {\n                avoids = new ExcludeList();\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Deploy avoids pods: \" + avoids.getPodsToAvoid() + \", clusters: \" + avoids.getClustersToAvoid() + \", hosts: \" + avoids.getHostsToAvoid());\n            }\n\n            boolean planChangedByVolume = false;\n            boolean reuseVolume = true;\n            final DataCenterDeployment originalPlan = plan;\n\n            int retry = StartRetry.value();\n            while (retry-- != 0) { \r\n                s_logger.debug(\"VM start attempt #\" + (StartRetry.value() - retry));\n\n                if (reuseVolume) {\n                    \r\n                    final List<VolumeVO> vols = _volsDao.findReadyRootVolumesByInstance(vm.getId());\n                    for (final VolumeVO vol : vols) {\n                        \r\n                        \r\n                        \r\n                        final Long volTemplateId = vol.getTemplateId();\n                        if (volTemplateId != null && volTemplateId.longValue() != template.getId()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(vol + \" of \" + vm + \" is READY, but template ids don't match, let the planner reassign a new pool\");\n                            }\n                            continue;\n                        }\n\n                        final StoragePool pool = (StoragePool)dataStoreMgr.getPrimaryDataStore(vol.getPoolId());\n                        if (!pool.isInMaintenance()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Root volume is ready, need to place VM in volume's cluster\");\n                            }\n                            final long rootVolDcId = pool.getDataCenterId();\n                            final Long rootVolPodId = pool.getPodId();\n                            final Long rootVolClusterId = pool.getClusterId();\n                            if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n                                final Long clusterIdSpecified = planToDeploy.getClusterId();\n                                if (clusterIdSpecified != null && rootVolClusterId != null) {\n                                    if (rootVolClusterId.longValue() != clusterIdSpecified.longValue()) {\n                                        \r\n                                        \r\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"Cannot satisfy the deployment plan passed in since the ready Root volume is in different cluster. volume's cluster: \" +\n                                                    rootVolClusterId + \", cluster specified: \" + clusterIdSpecified);\n                                        }\n                                        throw new ResourceUnavailableException(\n                                                \"Root volume is ready in different cluster, Deployment plan provided cannot be satisfied, unable to create a deployment for \" +\n                                                        vm, Cluster.class, clusterIdSpecified);\n                                    }\n                                }\n                                plan =\n                                        new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(),\n                                                planToDeploy.getHostId(), vol.getPoolId(), null, ctx);\n                            } else {\n                                plan = new DataCenterDeployment(rootVolDcId, rootVolPodId, rootVolClusterId, null, vol.getPoolId(), null, ctx);\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(vol + \" is READY, changing deployment plan to use this pool's dcId: \" + rootVolDcId + \" , podId: \" + rootVolPodId +\n                                            \" , and clusterId: \" + rootVolClusterId);\n                                }\n                                planChangedByVolume = true;\n                            }\n                        }\n                    }\n                }\n\n                final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vm, template, offering, owner, params);\n                logBootModeParameters(params);\n                DeployDestination dest = null;\n                try {\n                    dest = _dpMgr.planDeployment(vmProfile, plan, avoids, planner);\n                } catch (final AffinityConflictException e2) {\n                    s_logger.warn(\"Unable to create deployment, affinity rules associted to the VM conflict\", e2);\n                    throw new CloudRuntimeException(\"Unable to create deployment, affinity rules associted to the VM conflict\");\n                }\n\n                if (dest == null) {\n                    if (planChangedByVolume) {\n                        plan = originalPlan;\n                        planChangedByVolume = false;\n                        \r\n                        reuseVolume = false;\n                        continue;\n                    }\n                    throw new InsufficientServerCapacityException(\"Unable to create a deployment for \" + vmProfile, DataCenter.class, plan.getDataCenterId(),\n                            areAffinityGroupsAssociated(vmProfile));\n                }\n\n                if (dest != null) {\n                    avoids.addHost(dest.getHost().getId());\n                    if (!template.isDeployAsIs()) {\n                        journal.record(\"Deployment found - Attempt #\" + (StartRetry.value() - retry), vmProfile, dest);\n                    }\n                }\n\n                long destHostId = dest.getHost().getId();\n                vm.setPodIdToDeployIn(dest.getPod().getId());\n                final Long cluster_id = dest.getCluster().getId();\n                final ClusterDetailsVO cluster_detail_cpu = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                final ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                \r\n                if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) == null &&\n                        (Float.parseFloat(cluster_detail_cpu.getValue()) > 1f || Float.parseFloat(cluster_detail_ram.getValue()) > 1f)) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                } else if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) != null) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                }\n\n                vmProfile.setCpuOvercommitRatio(Float.parseFloat(cluster_detail_cpu.getValue()));\n                vmProfile.setMemoryOvercommitRatio(Float.parseFloat(cluster_detail_ram.getValue()));\n                StartAnswer startAnswer = null;\n\n                try {\n                    if (!changeState(vm, Event.OperationRetry, destHostId, work, Step.Prepare)) {\n                        throw new ConcurrentOperationException(\"Unable to update the state of the Virtual Machine \"+vm.getUuid()+\" oldstate: \"+vm.getState()+ \"Event :\"+Event.OperationRetry);\n                    }\n                } catch (final NoTransitionException e1) {\n                    throw new ConcurrentOperationException(e1.getMessage());\n                }\n\n                try {\n                    resetVmNicsDeviceId(vm.getId());\n                    _networkMgr.prepare(vmProfile, dest, ctx);\n                    if (vm.getHypervisorType() != HypervisorType.BareMetal) {\n                        volumeMgr.prepare(vmProfile, dest);\n                    }\n\n                    \r\n                    if (!reuseVolume) {\n                        reuseVolume = true;\n                    }\n\n                    Commands cmds = null;\n                    vmGuru.finalizeVirtualMachineProfile(vmProfile, dest, ctx);\n\n                    final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);\n\n                    checkAndSetEnterSetupMode(vmTO, params);\n\n                    handlePath(vmTO.getDisks(), vm.getHypervisorType());\n\n                    cmds = new Commands(Command.OnError.Stop);\n\n                    cmds.addCommand(new StartCommand(vmTO, dest.getHost(), getExecuteInSequence(vm.getHypervisorType())));\n\n                    vmGuru.finalizeDeployment(cmds, vmProfile, dest, ctx);\n\n                    \r\n                    addExtraConfig(vmTO);\n\n                    work = _workDao.findById(work.getId());\n                    if (work == null || work.getStep() != Step.Prepare) {\n                        throw new ConcurrentOperationException(\"Work steps have been changed: \" + work);\n                    }\n\n                    _workDao.updateStep(work, Step.Starting);\n\n                    _agentMgr.send(destHostId, cmds);\n\n                    _workDao.updateStep(work, Step.Started);\n\n                    startAnswer = cmds.getAnswer(StartAnswer.class);\n                    if (startAnswer != null && startAnswer.getResult()) {\n                        handlePath(vmTO.getDisks(), startAnswer.getIqnToData());\n\n                        final String host_guid = startAnswer.getHost_guid();\n\n                        if (host_guid != null) {\n                            final HostVO finalHost = _resourceMgr.findHostByGuid(host_guid);\n                            if (finalHost == null) {\n                                throw new CloudRuntimeException(\"Host Guid \" + host_guid + \" doesn't exist in DB, something went wrong while processing start answer: \"+startAnswer);\n                            }\n                            destHostId = finalHost.getId();\n                        }\n                        if (vmGuru.finalizeStart(vmProfile, destHostId, cmds, ctx)) {\n                            syncDiskChainChange(startAnswer);\n\n                            if (!changeState(vm, Event.OperationSucceeded, destHostId, work, Step.Done)) {\n                                s_logger.error(\"Unable to transition to a new state. VM uuid: \"+vm.getUuid()+    \"VM oldstate:\"+vm.getState()+\"Event:\"+Event.OperationSucceeded);\n                                throw new ConcurrentOperationException(\"Failed to deploy VM\"+ vm.getUuid());\n                            }\n\n                            \r\n                            final GPUDeviceTO gpuDevice = startAnswer.getVirtualMachine().getGpuDevice();\n                            if (gpuDevice != null) {\n                                _resourceMgr.updateGPUDetails(destHostId, gpuDevice.getGroupDetails());\n                            }\n\n                            \r\n                            \r\n                            \r\n                            if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.DEPLOY_VM) != null) {\n                                userVmDetailsDao.removeDetail(vm.getId(), VmDetailConstants.DEPLOY_VM);\n                            }\n\n                            startedVm = vm;\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Start completed for VM \" + vm);\n                            }\n                            final Host vmHost = _hostDao.findById(destHostId);\n                            if (vmHost != null && (VirtualMachine.Type.ConsoleProxy.equals(vm.getType()) ||\n                                    VirtualMachine.Type.SecondaryStorageVm.equals(vm.getType())) && caManager.canProvisionCertificates()) {\n                                final Map<String, String> sshAccessDetails = _networkMgr.getSystemVMAccessDetails(vm);\n                                for (int retries = 3; retries > 0; retries--) {\n                                    try {\n                                        setupAgentSecurity(vmHost, sshAccessDetails, vm);\n                                        return;\n                                    } catch (final Exception e) {\n                                        s_logger.error(\"Retrying after catching exception while trying to secure agent for systemvm id=\" + vm.getId(), e);\n                                    }\n                                }\n                                throw new CloudRuntimeException(\"Failed to setup and secure agent for systemvm id=\" + vm.getId());\n                            }\n                            return;\n                        } else {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.info(\"The guru did not like the answers so stopping \" + vm);\n                            }\n                            StopCommand stopCmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n                            stopCmd.setControlIp(getControlNicIpForVM(vm));\n                            Map<String, Boolean> vlanToPersistenceMap = getVlanToPersistenceMapForVM(vm.getId());\n                            if (MapUtils.isNotEmpty(vlanToPersistenceMap)) {\n                                stopCmd.setVlanToPersistenceMap(vlanToPersistenceMap);\n                            }\n                            final StopCommand cmd = stopCmd;\n                            final Answer answer = _agentMgr.easySend(destHostId, cmd);\n                            if (answer != null && answer instanceof StopAnswer) {\n                                final StopAnswer stopAns = (StopAnswer)answer;\n                                if (vm.getType() == VirtualMachine.Type.User) {\n                                    final String platform = stopAns.getPlatform();\n                                    if (platform != null) {\n                                        final Map<String,String> vmmetadata = new HashMap<String,String>();\n                                        vmmetadata.put(vm.getInstanceName(), platform);\n                                        syncVMMetaData(vmmetadata);\n                                    }\n                                }\n                            }\n\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.warn(\"Unable to stop \" + vm + \" due to \" + (answer != null ? answer.getDetails() : \"no answers\"));\n                                _haMgr.scheduleStop(vm, destHostId, WorkType.ForceStop);\n                                throw new ExecutionException(\"Unable to stop this VM, \"+vm.getUuid()+\" so we are unable to retry the start operation\");\n                            }\n                            throw new ExecutionException(\"Unable to start  VM:\"+vm.getUuid()+\" due to error in finalizeStart, not retrying\");\n                        }\n                    }\n                    s_logger.info(\"Unable to start VM on \" + dest.getHost() + \" due to \" + (startAnswer == null ? \" no start answer\" : startAnswer.getDetails()));\n                    if (startAnswer != null && startAnswer.getContextParam(\"stopRetry\") != null) {\n                        break;\n                    }\n\n                } catch (OperationTimedoutException e) {\n                    s_logger.debug(\"Unable to send the start command to host \" + dest.getHost()+\" failed to start VM: \"+vm.getUuid());\n                    if (e.isActive()) {\n                        _haMgr.scheduleStop(vm, destHostId, WorkType.CheckStop);\n                    }\n                    canRetry = false;\n                    throw new AgentUnavailableException(\"Unable to start \" + vm.getHostName(), destHostId, e);\n                } catch (final ResourceUnavailableException e) {\n                    s_logger.info(\"Unable to contact resource.\", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected ResourceUnavailableException : \" + e.getScope().getName(), e);\n                            throw e;\n                        }\n                    }\n                } catch (final InsufficientCapacityException e) {\n                    s_logger.info(\"Insufficient capacity \", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected InsufficientCapacityException : \" + e.getScope().getName(), e);\n                        }\n                    }\n                } catch (final ExecutionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final NoTransitionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final StorageAccessException e) {\n                    s_logger.warn(\"Unable to access storage on host\", e);\n                } finally {\n                    if (startedVm == null && canRetry) {\n                        final Step prevStep = work.getStep();\n                        _workDao.updateStep(work, Step.Release);\n                        \r\n                        if ((prevStep == Step.Started || prevStep == Step.Starting) && startAnswer != null && startAnswer.getResult()) {  \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, false);\n                        } else {\n                            \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, true);\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (startedVm == null) {\n                if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n                    resourceCountDecrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n                }\n                if (canRetry) {\n                    try {\n                        changeState(vm, Event.OperationFailed, null, work, Step.Done);\n                    } catch (final NoTransitionException e) {\n                        throw new ConcurrentOperationException(e.getMessage());\n                    }\n                }\n            }\n\n            if (planToDeploy != null) {\n                planToDeploy.setAvoids(avoids);\n            }\n        }\n\n        if (startedVm == null) {\n            throw new CloudRuntimeException(\"Unable to start instance '\" + vm.getHostName() + \"' (\" + vm.getUuid() + \"), see management server log for details\");\n        }\n    }\n","date":"2021-04-05 17:07:11","endLine":1364,"groupId":"18193","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"orchestrateStart","params":"(finalStringvmUuid@finalMap<VirtualMachineProfile.Param@Object>params@finalDeploymentPlanplanToDeploy@finalDeploymentPlannerplanner)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/1e/92c3ed5be7e6ac76091149b4cc4fcfba874141.src","preCode":"    public void orchestrateStart(final String vmUuid, final Map<VirtualMachineProfile.Param, Object> params, final DeploymentPlan planToDeploy, final DeploymentPlanner planner)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {\n\n        final CallContext cctxt = CallContext.current();\n        final Account account = cctxt.getCallingAccount();\n        final User caller = cctxt.getCallingUser();\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final Ternary<VMInstanceVO, ReservationContext, ItWorkVO> start = changeToStartState(vmGuru, vm, caller, account);\n        if (start == null) {\n            return;\n        }\n\n        vm = start.first();\n        final ReservationContext ctx = start.second();\n        ItWorkVO work = start.third();\n\n        VMInstanceVO startedVm = null;\n        final ServiceOfferingVO offering = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());\n        final VirtualMachineTemplate template = _entityMgr.findByIdIncludingRemoved(VirtualMachineTemplate.class, vm.getTemplateId());\n\n        DataCenterDeployment plan = new DataCenterDeployment(vm.getDataCenterId(), vm.getPodIdToDeployIn(), null, null, null, null, ctx);\n        if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"advanceStart: DeploymentPlan is provided, using dcId:\" + planToDeploy.getDataCenterId() + \", podId: \" + planToDeploy.getPodId() +\n                        \", clusterId: \" + planToDeploy.getClusterId() + \", hostId: \" + planToDeploy.getHostId() + \", poolId: \" + planToDeploy.getPoolId());\n            }\n            plan =\n                    new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(), planToDeploy.getHostId(),\n                            planToDeploy.getPoolId(), planToDeploy.getPhysicalNetworkId(), ctx);\n        }\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        \r\n        final Account owner = _entityMgr.findById(Account.class, vm.getAccountId());\n        if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n            resourceCountIncrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n        }\n\n        boolean canRetry = true;\n        ExcludeList avoids = null;\n        try {\n            final Journal journal = start.second().getJournal();\n\n            if (planToDeploy != null) {\n                avoids = planToDeploy.getAvoids();\n            }\n            if (avoids == null) {\n                avoids = new ExcludeList();\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Deploy avoids pods: \" + avoids.getPodsToAvoid() + \", clusters: \" + avoids.getClustersToAvoid() + \", hosts: \" + avoids.getHostsToAvoid());\n            }\n\n            boolean planChangedByVolume = false;\n            boolean reuseVolume = true;\n            final DataCenterDeployment originalPlan = plan;\n\n            int retry = StartRetry.value();\n            while (retry-- != 0) { \r\n                s_logger.debug(\"VM start attempt #\" + (StartRetry.value() - retry));\n\n                if (reuseVolume) {\n                    \r\n                    final List<VolumeVO> vols = _volsDao.findReadyRootVolumesByInstance(vm.getId());\n                    for (final VolumeVO vol : vols) {\n                        \r\n                        \r\n                        \r\n                        final Long volTemplateId = vol.getTemplateId();\n                        if (volTemplateId != null && volTemplateId.longValue() != template.getId()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(vol + \" of \" + vm + \" is READY, but template ids don't match, let the planner reassign a new pool\");\n                            }\n                            continue;\n                        }\n\n                        final StoragePool pool = (StoragePool)dataStoreMgr.getPrimaryDataStore(vol.getPoolId());\n                        if (!pool.isInMaintenance()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Root volume is ready, need to place VM in volume's cluster\");\n                            }\n                            final long rootVolDcId = pool.getDataCenterId();\n                            final Long rootVolPodId = pool.getPodId();\n                            final Long rootVolClusterId = pool.getClusterId();\n                            if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n                                final Long clusterIdSpecified = planToDeploy.getClusterId();\n                                if (clusterIdSpecified != null && rootVolClusterId != null) {\n                                    if (rootVolClusterId.longValue() != clusterIdSpecified.longValue()) {\n                                        \r\n                                        \r\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"Cannot satisfy the deployment plan passed in since the ready Root volume is in different cluster. volume's cluster: \" +\n                                                    rootVolClusterId + \", cluster specified: \" + clusterIdSpecified);\n                                        }\n                                        throw new ResourceUnavailableException(\n                                                \"Root volume is ready in different cluster, Deployment plan provided cannot be satisfied, unable to create a deployment for \" +\n                                                        vm, Cluster.class, clusterIdSpecified);\n                                    }\n                                }\n                                plan =\n                                        new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(),\n                                                planToDeploy.getHostId(), vol.getPoolId(), null, ctx);\n                            } else {\n                                plan = new DataCenterDeployment(rootVolDcId, rootVolPodId, rootVolClusterId, null, vol.getPoolId(), null, ctx);\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(vol + \" is READY, changing deployment plan to use this pool's dcId: \" + rootVolDcId + \" , podId: \" + rootVolPodId +\n                                            \" , and clusterId: \" + rootVolClusterId);\n                                }\n                                planChangedByVolume = true;\n                            }\n                        }\n                    }\n                }\n\n                final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vm, template, offering, owner, params);\n                logBootModeParameters(params);\n                DeployDestination dest = null;\n                try {\n                    dest = _dpMgr.planDeployment(vmProfile, plan, avoids, planner);\n                } catch (final AffinityConflictException e2) {\n                    s_logger.warn(\"Unable to create deployment, affinity rules associted to the VM conflict\", e2);\n                    throw new CloudRuntimeException(\"Unable to create deployment, affinity rules associted to the VM conflict\");\n                }\n\n                if (dest == null) {\n                    if (planChangedByVolume) {\n                        plan = originalPlan;\n                        planChangedByVolume = false;\n                        \r\n                        reuseVolume = false;\n                        continue;\n                    }\n                    throw new InsufficientServerCapacityException(\"Unable to create a deployment for \" + vmProfile, DataCenter.class, plan.getDataCenterId(),\n                            areAffinityGroupsAssociated(vmProfile));\n                }\n\n                if (dest != null) {\n                    avoids.addHost(dest.getHost().getId());\n                    if (!template.isDeployAsIs()) {\n                        journal.record(\"Deployment found - Attempt #\" + (StartRetry.value() - retry), vmProfile, dest);\n                    }\n                }\n\n                long destHostId = dest.getHost().getId();\n                vm.setPodIdToDeployIn(dest.getPod().getId());\n                final Long cluster_id = dest.getCluster().getId();\n                final ClusterDetailsVO cluster_detail_cpu = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                final ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                \r\n                if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) == null &&\n                        (Float.parseFloat(cluster_detail_cpu.getValue()) > 1f || Float.parseFloat(cluster_detail_ram.getValue()) > 1f)) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                } else if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) != null) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                }\n\n                vmProfile.setCpuOvercommitRatio(Float.parseFloat(cluster_detail_cpu.getValue()));\n                vmProfile.setMemoryOvercommitRatio(Float.parseFloat(cluster_detail_ram.getValue()));\n                StartAnswer startAnswer = null;\n\n                try {\n                    if (!changeState(vm, Event.OperationRetry, destHostId, work, Step.Prepare)) {\n                        throw new ConcurrentOperationException(\"Unable to update the state of the Virtual Machine \"+vm.getUuid()+\" oldstate: \"+vm.getState()+ \"Event :\"+Event.OperationRetry);\n                    }\n                } catch (final NoTransitionException e1) {\n                    throw new ConcurrentOperationException(e1.getMessage());\n                }\n\n                try {\n                    resetVmNicsDeviceId(vm.getId());\n                    _networkMgr.prepare(vmProfile, dest, ctx);\n                    if (vm.getHypervisorType() != HypervisorType.BareMetal) {\n                        volumeMgr.prepare(vmProfile, dest);\n                    }\n\n                    \r\n                    if (!reuseVolume) {\n                        reuseVolume = true;\n                    }\n\n                    Commands cmds = null;\n                    vmGuru.finalizeVirtualMachineProfile(vmProfile, dest, ctx);\n\n                    final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);\n\n                    checkAndSetEnterSetupMode(vmTO, params);\n\n                    handlePath(vmTO.getDisks(), vm.getHypervisorType());\n\n                    cmds = new Commands(Command.OnError.Stop);\n\n                    cmds.addCommand(new StartCommand(vmTO, dest.getHost(), getExecuteInSequence(vm.getHypervisorType())));\n\n                    vmGuru.finalizeDeployment(cmds, vmProfile, dest, ctx);\n\n                    \r\n                    addExtraConfig(vmTO);\n\n                    work = _workDao.findById(work.getId());\n                    if (work == null || work.getStep() != Step.Prepare) {\n                        throw new ConcurrentOperationException(\"Work steps have been changed: \" + work);\n                    }\n\n                    _workDao.updateStep(work, Step.Starting);\n\n                    _agentMgr.send(destHostId, cmds);\n\n                    _workDao.updateStep(work, Step.Started);\n\n                    startAnswer = cmds.getAnswer(StartAnswer.class);\n                    if (startAnswer != null && startAnswer.getResult()) {\n                        handlePath(vmTO.getDisks(), startAnswer.getIqnToData());\n\n                        final String host_guid = startAnswer.getHost_guid();\n\n                        if (host_guid != null) {\n                            final HostVO finalHost = _resourceMgr.findHostByGuid(host_guid);\n                            if (finalHost == null) {\n                                throw new CloudRuntimeException(\"Host Guid \" + host_guid + \" doesn't exist in DB, something went wrong while processing start answer: \"+startAnswer);\n                            }\n                            destHostId = finalHost.getId();\n                        }\n                        if (vmGuru.finalizeStart(vmProfile, destHostId, cmds, ctx)) {\n                            syncDiskChainChange(startAnswer);\n\n                            if (!changeState(vm, Event.OperationSucceeded, destHostId, work, Step.Done)) {\n                                s_logger.error(\"Unable to transition to a new state. VM uuid: \"+vm.getUuid()+    \"VM oldstate:\"+vm.getState()+\"Event:\"+Event.OperationSucceeded);\n                                throw new ConcurrentOperationException(\"Failed to deploy VM\"+ vm.getUuid());\n                            }\n\n                            \r\n                            final GPUDeviceTO gpuDevice = startAnswer.getVirtualMachine().getGpuDevice();\n                            if (gpuDevice != null) {\n                                _resourceMgr.updateGPUDetails(destHostId, gpuDevice.getGroupDetails());\n                            }\n\n                            \r\n                            \r\n                            \r\n                            if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.DEPLOY_VM) != null) {\n                                userVmDetailsDao.removeDetail(vm.getId(), VmDetailConstants.DEPLOY_VM);\n                            }\n\n                            startedVm = vm;\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Start completed for VM \" + vm);\n                            }\n                            final Host vmHost = _hostDao.findById(destHostId);\n                            if (vmHost != null && (VirtualMachine.Type.ConsoleProxy.equals(vm.getType()) ||\n                                    VirtualMachine.Type.SecondaryStorageVm.equals(vm.getType())) && caManager.canProvisionCertificates()) {\n                                final Map<String, String> sshAccessDetails = _networkMgr.getSystemVMAccessDetails(vm);\n                                for (int retries = 3; retries > 0; retries--) {\n                                    try {\n                                        setupAgentSecurity(vmHost, sshAccessDetails, vm);\n                                        return;\n                                    } catch (final Exception e) {\n                                        s_logger.error(\"Retrying after catching exception while trying to secure agent for systemvm id=\" + vm.getId(), e);\n                                    }\n                                }\n                                throw new CloudRuntimeException(\"Failed to setup and secure agent for systemvm id=\" + vm.getId());\n                            }\n                            return;\n                        } else {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.info(\"The guru did not like the answers so stopping \" + vm);\n                            }\n                            StopCommand stopCmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n                            stopCmd.setControlIp(getControlNicIpForVM(vm));\n                            Map<String, Boolean> vlanToPersistenceMap = getVlanToPersistenceMapForVM(vm.getId());\n                            if (MapUtils.isNotEmpty(vlanToPersistenceMap)) {\n                                stopCmd.setVlanToPersistenceMap(vlanToPersistenceMap);\n                            }\n                            final StopCommand cmd = stopCmd;\n                            final Answer answer = _agentMgr.easySend(destHostId, cmd);\n                            if (answer != null && answer instanceof StopAnswer) {\n                                final StopAnswer stopAns = (StopAnswer)answer;\n                                if (vm.getType() == VirtualMachine.Type.User) {\n                                    final String platform = stopAns.getPlatform();\n                                    if (platform != null) {\n                                        final Map<String,String> vmmetadata = new HashMap<String,String>();\n                                        vmmetadata.put(vm.getInstanceName(), platform);\n                                        syncVMMetaData(vmmetadata);\n                                    }\n                                }\n                            }\n\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.warn(\"Unable to stop \" + vm + \" due to \" + (answer != null ? answer.getDetails() : \"no answers\"));\n                                _haMgr.scheduleStop(vm, destHostId, WorkType.ForceStop);\n                                throw new ExecutionException(\"Unable to stop this VM, \"+vm.getUuid()+\" so we are unable to retry the start operation\");\n                            }\n                            throw new ExecutionException(\"Unable to start  VM:\"+vm.getUuid()+\" due to error in finalizeStart, not retrying\");\n                        }\n                    }\n                    s_logger.info(\"Unable to start VM on \" + dest.getHost() + \" due to \" + (startAnswer == null ? \" no start answer\" : startAnswer.getDetails()));\n                    if (startAnswer != null && startAnswer.getContextParam(\"stopRetry\") != null) {\n                        break;\n                    }\n\n                } catch (OperationTimedoutException e) {\n                    s_logger.debug(\"Unable to send the start command to host \" + dest.getHost()+\" failed to start VM: \"+vm.getUuid());\n                    if (e.isActive()) {\n                        _haMgr.scheduleStop(vm, destHostId, WorkType.CheckStop);\n                    }\n                    canRetry = false;\n                    throw new AgentUnavailableException(\"Unable to start \" + vm.getHostName(), destHostId, e);\n                } catch (final ResourceUnavailableException e) {\n                    s_logger.info(\"Unable to contact resource.\", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected ResourceUnavailableException : \" + e.getScope().getName(), e);\n                            throw e;\n                        }\n                    }\n                } catch (final InsufficientCapacityException e) {\n                    s_logger.info(\"Insufficient capacity \", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected InsufficientCapacityException : \" + e.getScope().getName(), e);\n                        }\n                    }\n                } catch (final ExecutionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final NoTransitionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final StorageAccessException e) {\n                    s_logger.warn(\"Unable to access storage on host\", e);\n                } finally {\n                    if (startedVm == null && canRetry) {\n                        final Step prevStep = work.getStep();\n                        _workDao.updateStep(work, Step.Release);\n                        \r\n                        if ((prevStep == Step.Started || prevStep == Step.Starting) && startAnswer != null && startAnswer.getResult()) {  \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, false);\n                        } else {\n                            \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, true);\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (startedVm == null) {\n                if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n                    resourceCountDecrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n                }\n                if (canRetry) {\n                    try {\n                        changeState(vm, Event.OperationFailed, null, work, Step.Done);\n                    } catch (final NoTransitionException e) {\n                        throw new ConcurrentOperationException(e.getMessage());\n                    }\n                }\n            }\n\n            if (planToDeploy != null) {\n                planToDeploy.setAvoids(avoids);\n            }\n        }\n\n        if (startedVm == null) {\n            throw new CloudRuntimeException(\"Unable to start instance '\" + vm.getHostName() + \"' (\" + vm.getUuid() + \"), see management server log for details\");\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":988,"status":"MB"},{"authorDate":"2021-04-05 17:07:11","commitOrder":14,"curCode":"    public Command cleanup(final String vmName) {\n        VirtualMachine vm = _vmDao.findVMByInstanceName(vmName);\n\n        StopCommand cmd = new StopCommand(vmName, getExecuteInSequence(null), false);\n        cmd.setControlIp(getControlNicIpForVM(vm));\n        Map<String, Boolean> vlanToPersistenceMap = getVlanToPersistenceMapForVM(vm.getId());\n        if (MapUtils.isNotEmpty(vlanToPersistenceMap)) {\n            cmd.setVlanToPersistenceMap(vlanToPersistenceMap);\n        }\n        return cmd;\n    }\n","date":"2021-04-05 17:07:11","endLine":3642,"groupId":"25418","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"cleanup","params":"(finalStringvmName)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/1e/92c3ed5be7e6ac76091149b4cc4fcfba874141.src","preCode":"    public Command cleanup(final String vmName) {\n        VirtualMachine vm = _vmDao.findVMByInstanceName(vmName);\n\n        StopCommand cmd = new StopCommand(vmName, getExecuteInSequence(null), false);\n        cmd.setControlIp(getControlNicIpForVM(vm));\n        Map<String, Boolean> vlanToPersistenceMap = getVlanToPersistenceMapForVM(vm.getId());\n        if (MapUtils.isNotEmpty(vlanToPersistenceMap)) {\n            cmd.setVlanToPersistenceMap(vlanToPersistenceMap);\n        }\n        return cmd;\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":3632,"status":"B"}],"commitId":"0dbeb262e4f483e06ca335aadcee9664cf7f35c4","commitMessage":"@@@server: Support for persistence mode in L2 networks (#4561)\n\nThis PR aims at introducing persistence mode in L2 networks and enhancing the behavior in Isolated networks\nDoc PR apache/cloudstack-documentation#183\n\nCo-authored-by: Pearl Dsilva <pearl.dsilva@shapeblue.com>","date":"2021-04-05 17:07:11","modifiedFileCount":"27","status":"M","submitter":"Pearl Dsilva"},{"authorTime":"2021-04-05 17:07:11","codes":[{"authorDate":"2021-09-24 12:21:16","commitOrder":15,"curCode":"    public void orchestrateStart(final String vmUuid, final Map<VirtualMachineProfile.Param, Object> params, final DeploymentPlan planToDeploy, final DeploymentPlanner planner)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {\n\n        final CallContext cctxt = CallContext.current();\n        final Account account = cctxt.getCallingAccount();\n        final User caller = cctxt.getCallingUser();\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final Ternary<VMInstanceVO, ReservationContext, ItWorkVO> start = changeToStartState(vmGuru, vm, caller, account);\n        if (start == null) {\n            return;\n        }\n\n        vm = start.first();\n        final ReservationContext ctx = start.second();\n        ItWorkVO work = start.third();\n\n        VMInstanceVO startedVm = null;\n        final ServiceOfferingVO offering = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());\n        final VirtualMachineTemplate template = _entityMgr.findByIdIncludingRemoved(VirtualMachineTemplate.class, vm.getTemplateId());\n\n        DataCenterDeployment plan = new DataCenterDeployment(vm.getDataCenterId(), vm.getPodIdToDeployIn(), null, null, null, null, ctx);\n        if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"advanceStart: DeploymentPlan is provided, using dcId:\" + planToDeploy.getDataCenterId() + \", podId: \" + planToDeploy.getPodId() +\n                        \", clusterId: \" + planToDeploy.getClusterId() + \", hostId: \" + planToDeploy.getHostId() + \", poolId: \" + planToDeploy.getPoolId());\n            }\n            plan =\n                    new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(), planToDeploy.getHostId(),\n                            planToDeploy.getPoolId(), planToDeploy.getPhysicalNetworkId(), ctx);\n        }\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        \r\n        final Account owner = _entityMgr.findById(Account.class, vm.getAccountId());\n        if (VirtualMachine.Type.User.equals(vm.type) && ResourceCountRunningVMsonly.value()) {\n            resourceCountIncrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n        }\n\n        boolean canRetry = true;\n        ExcludeList avoids = null;\n        try {\n            final Journal journal = start.second().getJournal();\n\n            if (planToDeploy != null) {\n                avoids = planToDeploy.getAvoids();\n            }\n            if (avoids == null) {\n                avoids = new ExcludeList();\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Deploy avoids pods: \" + avoids.getPodsToAvoid() + \", clusters: \" + avoids.getClustersToAvoid() + \", hosts: \" + avoids.getHostsToAvoid());\n            }\n\n            boolean planChangedByVolume = false;\n            boolean reuseVolume = true;\n            final DataCenterDeployment originalPlan = plan;\n\n            int retry = StartRetry.value();\n            while (retry-- != 0) { \r\n                s_logger.debug(\"VM start attempt #\" + (StartRetry.value() - retry));\n\n                if (reuseVolume) {\n                    \r\n                    final List<VolumeVO> vols = _volsDao.findReadyRootVolumesByInstance(vm.getId());\n                    for (final VolumeVO vol : vols) {\n                        \r\n                        \r\n                        \r\n                        final Long volTemplateId = vol.getTemplateId();\n                        if (volTemplateId != null && volTemplateId.longValue() != template.getId()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(vol + \" of \" + vm + \" is READY, but template ids don't match, let the planner reassign a new pool\");\n                            }\n                            continue;\n                        }\n\n                        final StoragePool pool = (StoragePool)dataStoreMgr.getPrimaryDataStore(vol.getPoolId());\n                        if (!pool.isInMaintenance()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Root volume is ready, need to place VM in volume's cluster\");\n                            }\n                            final long rootVolDcId = pool.getDataCenterId();\n                            final Long rootVolPodId = pool.getPodId();\n                            final Long rootVolClusterId = pool.getClusterId();\n                            if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n                                final Long clusterIdSpecified = planToDeploy.getClusterId();\n                                if (clusterIdSpecified != null && rootVolClusterId != null) {\n                                    if (rootVolClusterId.longValue() != clusterIdSpecified.longValue()) {\n                                        \r\n                                        \r\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"Cannot satisfy the deployment plan passed in since the ready Root volume is in different cluster. volume's cluster: \" +\n                                                    rootVolClusterId + \", cluster specified: \" + clusterIdSpecified);\n                                        }\n                                        throw new ResourceUnavailableException(\n                                                \"Root volume is ready in different cluster, Deployment plan provided cannot be satisfied, unable to create a deployment for \" +\n                                                        vm, Cluster.class, clusterIdSpecified);\n                                    }\n                                }\n                                plan =\n                                        new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(),\n                                                planToDeploy.getHostId(), vol.getPoolId(), null, ctx);\n                            } else {\n                                plan = new DataCenterDeployment(rootVolDcId, rootVolPodId, rootVolClusterId, null, vol.getPoolId(), null, ctx);\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(vol + \" is READY, changing deployment plan to use this pool's dcId: \" + rootVolDcId + \" , podId: \" + rootVolPodId +\n                                            \" , and clusterId: \" + rootVolClusterId);\n                                }\n                                planChangedByVolume = true;\n                            }\n                        }\n                    }\n                }\n\n                final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vm, template, offering, owner, params);\n                logBootModeParameters(params);\n                DeployDestination dest = null;\n                try {\n                    dest = _dpMgr.planDeployment(vmProfile, plan, avoids, planner);\n                } catch (final AffinityConflictException e2) {\n                    s_logger.warn(\"Unable to create deployment, affinity rules associted to the VM conflict\", e2);\n                    throw new CloudRuntimeException(\"Unable to create deployment, affinity rules associted to the VM conflict\");\n                }\n\n                if (dest == null) {\n                    if (planChangedByVolume) {\n                        plan = originalPlan;\n                        planChangedByVolume = false;\n                        \r\n                        reuseVolume = false;\n                        continue;\n                    }\n                    throw new InsufficientServerCapacityException(\"Unable to create a deployment for \" + vmProfile, DataCenter.class, plan.getDataCenterId(),\n                            areAffinityGroupsAssociated(vmProfile));\n                }\n\n                if (dest != null) {\n                    avoids.addHost(dest.getHost().getId());\n                    if (!template.isDeployAsIs()) {\n                        journal.record(\"Deployment found - Attempt #\" + (StartRetry.value() - retry), vmProfile, dest);\n                    }\n                }\n\n                long destHostId = dest.getHost().getId();\n                vm.setPodIdToDeployIn(dest.getPod().getId());\n                final Long cluster_id = dest.getCluster().getId();\n                final ClusterDetailsVO cluster_detail_cpu = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                final ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                \r\n                if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) == null &&\n                        (Float.parseFloat(cluster_detail_cpu.getValue()) > 1f || Float.parseFloat(cluster_detail_ram.getValue()) > 1f)) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                } else if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) != null) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                }\n\n                vmProfile.setCpuOvercommitRatio(Float.parseFloat(cluster_detail_cpu.getValue()));\n                vmProfile.setMemoryOvercommitRatio(Float.parseFloat(cluster_detail_ram.getValue()));\n                StartAnswer startAnswer = null;\n\n                try {\n                    if (!changeState(vm, Event.OperationRetry, destHostId, work, Step.Prepare)) {\n                        throw new ConcurrentOperationException(\"Unable to update the state of the Virtual Machine \"+vm.getUuid()+\" oldstate: \"+vm.getState()+ \"Event :\"+Event.OperationRetry);\n                    }\n                } catch (final NoTransitionException e1) {\n                    throw new ConcurrentOperationException(e1.getMessage());\n                }\n\n                try {\n                    resetVmNicsDeviceId(vm.getId());\n                    _networkMgr.prepare(vmProfile, dest, ctx);\n                    if (vm.getHypervisorType() != HypervisorType.BareMetal) {\n                        volumeMgr.prepare(vmProfile, dest);\n                    }\n\n                    \r\n                    if (!reuseVolume) {\n                        reuseVolume = true;\n                    }\n\n                    Commands cmds = null;\n                    vmGuru.finalizeVirtualMachineProfile(vmProfile, dest, ctx);\n\n                    final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);\n\n                    checkAndSetEnterSetupMode(vmTO, params);\n\n                    handlePath(vmTO.getDisks(), vm.getHypervisorType());\n\n                    cmds = new Commands(Command.OnError.Stop);\n\n                    cmds.addCommand(new StartCommand(vmTO, dest.getHost(), getExecuteInSequence(vm.getHypervisorType())));\n\n                    vmGuru.finalizeDeployment(cmds, vmProfile, dest, ctx);\n\n                    \r\n                    addExtraConfig(vmTO);\n\n                    work = _workDao.findById(work.getId());\n                    if (work == null || work.getStep() != Step.Prepare) {\n                        throw new ConcurrentOperationException(\"Work steps have been changed: \" + work);\n                    }\n\n                    _workDao.updateStep(work, Step.Starting);\n\n                    _agentMgr.send(destHostId, cmds);\n\n                    _workDao.updateStep(work, Step.Started);\n\n                    startAnswer = cmds.getAnswer(StartAnswer.class);\n                    if (startAnswer != null && startAnswer.getResult()) {\n                        handlePath(vmTO.getDisks(), startAnswer.getIqnToData());\n\n                        final String host_guid = startAnswer.getHost_guid();\n\n                        if (host_guid != null) {\n                            final HostVO finalHost = _resourceMgr.findHostByGuid(host_guid);\n                            if (finalHost == null) {\n                                throw new CloudRuntimeException(\"Host Guid \" + host_guid + \" doesn't exist in DB, something went wrong while processing start answer: \"+startAnswer);\n                            }\n                            destHostId = finalHost.getId();\n                        }\n                        if (vmGuru.finalizeStart(vmProfile, destHostId, cmds, ctx)) {\n                            syncDiskChainChange(startAnswer);\n\n                            if (!changeState(vm, Event.OperationSucceeded, destHostId, work, Step.Done)) {\n                                s_logger.error(\"Unable to transition to a new state. VM uuid: \"+vm.getUuid()+    \"VM oldstate:\"+vm.getState()+\"Event:\"+Event.OperationSucceeded);\n                                throw new ConcurrentOperationException(\"Failed to deploy VM\"+ vm.getUuid());\n                            }\n\n                            \r\n                            final GPUDeviceTO gpuDevice = startAnswer.getVirtualMachine().getGpuDevice();\n                            if (gpuDevice != null) {\n                                _resourceMgr.updateGPUDetails(destHostId, gpuDevice.getGroupDetails());\n                            }\n\n                            \r\n                            \r\n                            \r\n                            if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.DEPLOY_VM) != null) {\n                                userVmDetailsDao.removeDetail(vm.getId(), VmDetailConstants.DEPLOY_VM);\n                            }\n\n                            startedVm = vm;\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Start completed for VM \" + vm);\n                            }\n                            final Host vmHost = _hostDao.findById(destHostId);\n                            if (vmHost != null && (VirtualMachine.Type.ConsoleProxy.equals(vm.getType()) ||\n                                    VirtualMachine.Type.SecondaryStorageVm.equals(vm.getType())) && caManager.canProvisionCertificates()) {\n                                final Map<String, String> sshAccessDetails = _networkMgr.getSystemVMAccessDetails(vm);\n                                for (int retries = 3; retries > 0; retries--) {\n                                    try {\n                                        setupAgentSecurity(vmHost, sshAccessDetails, vm);\n                                        return;\n                                    } catch (final Exception e) {\n                                        s_logger.error(\"Retrying after catching exception while trying to secure agent for systemvm id=\" + vm.getId(), e);\n                                    }\n                                }\n                                throw new CloudRuntimeException(\"Failed to setup and secure agent for systemvm id=\" + vm.getId());\n                            }\n                            return;\n                        } else {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.info(\"The guru did not like the answers so stopping \" + vm);\n                            }\n                            StopCommand stopCmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n                            stopCmd.setControlIp(getControlNicIpForVM(vm));\n                            Map<String, Boolean> vlanToPersistenceMap = getVlanToPersistenceMapForVM(vm.getId());\n                            if (MapUtils.isNotEmpty(vlanToPersistenceMap)) {\n                                stopCmd.setVlanToPersistenceMap(vlanToPersistenceMap);\n                            }\n                            final StopCommand cmd = stopCmd;\n                            final Answer answer = _agentMgr.easySend(destHostId, cmd);\n                            if (answer != null && answer instanceof StopAnswer) {\n                                final StopAnswer stopAns = (StopAnswer)answer;\n                                if (vm.getType() == VirtualMachine.Type.User) {\n                                    final String platform = stopAns.getPlatform();\n                                    if (platform != null) {\n                                        final Map<String,String> vmmetadata = new HashMap<String,String>();\n                                        vmmetadata.put(vm.getInstanceName(), platform);\n                                        syncVMMetaData(vmmetadata);\n                                    }\n                                }\n                            }\n\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.warn(\"Unable to stop \" + vm + \" due to \" + (answer != null ? answer.getDetails() : \"no answers\"));\n                                _haMgr.scheduleStop(vm, destHostId, WorkType.ForceStop);\n                                throw new ExecutionException(\"Unable to stop this VM, \"+vm.getUuid()+\" so we are unable to retry the start operation\");\n                            }\n                            throw new ExecutionException(\"Unable to start  VM:\"+vm.getUuid()+\" due to error in finalizeStart, not retrying\");\n                        }\n                    }\n                    s_logger.info(\"Unable to start VM on \" + dest.getHost() + \" due to \" + (startAnswer == null ? \" no start answer\" : startAnswer.getDetails()));\n                    if (startAnswer != null && startAnswer.getContextParam(\"stopRetry\") != null) {\n                        break;\n                    }\n\n                } catch (OperationTimedoutException e) {\n                    s_logger.debug(\"Unable to send the start command to host \" + dest.getHost()+\" failed to start VM: \"+vm.getUuid());\n                    if (e.isActive()) {\n                        _haMgr.scheduleStop(vm, destHostId, WorkType.CheckStop);\n                    }\n                    canRetry = false;\n                    throw new AgentUnavailableException(\"Unable to start \" + vm.getHostName(), destHostId, e);\n                } catch (final ResourceUnavailableException e) {\n                    s_logger.info(\"Unable to contact resource.\", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected ResourceUnavailableException : \" + e.getScope().getName(), e);\n                            throw e;\n                        }\n                    }\n                } catch (final InsufficientCapacityException e) {\n                    s_logger.info(\"Insufficient capacity \", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected InsufficientCapacityException : \" + e.getScope().getName(), e);\n                        }\n                    }\n                } catch (final ExecutionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final NoTransitionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final StorageAccessException e) {\n                    s_logger.warn(\"Unable to access storage on host\", e);\n                } finally {\n                    if (startedVm == null && canRetry) {\n                        final Step prevStep = work.getStep();\n                        _workDao.updateStep(work, Step.Release);\n                        \r\n                        if ((prevStep == Step.Started || prevStep == Step.Starting) && startAnswer != null && startAnswer.getResult()) {  \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, false);\n                        } else {\n                            \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, true);\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (startedVm == null) {\n                if (VirtualMachine.Type.User.equals(vm.type) && ResourceCountRunningVMsonly.value()) {\n                    resourceCountDecrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n                }\n                if (canRetry) {\n                    try {\n                        changeState(vm, Event.OperationFailed, null, work, Step.Done);\n                    } catch (final NoTransitionException e) {\n                        throw new ConcurrentOperationException(e.getMessage());\n                    }\n                }\n            }\n\n            if (planToDeploy != null) {\n                planToDeploy.setAvoids(avoids);\n            }\n        }\n\n        if (startedVm == null) {\n            throw new CloudRuntimeException(\"Unable to start instance '\" + vm.getHostName() + \"' (\" + vm.getUuid() + \"), see management server log for details\");\n        }\n    }\n","date":"2021-09-24 12:21:16","endLine":1390,"groupId":"12561","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"orchestrateStart","params":"(finalStringvmUuid@finalMap<VirtualMachineProfile.Param@Object>params@finalDeploymentPlanplanToDeploy@finalDeploymentPlannerplanner)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/85/4d5a2107d971b30544da1b90c0f512c77ac99f.src","preCode":"    public void orchestrateStart(final String vmUuid, final Map<VirtualMachineProfile.Param, Object> params, final DeploymentPlan planToDeploy, final DeploymentPlanner planner)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException {\n\n        final CallContext cctxt = CallContext.current();\n        final Account account = cctxt.getCallingAccount();\n        final User caller = cctxt.getCallingUser();\n\n        VMInstanceVO vm = _vmDao.findByUuid(vmUuid);\n\n        final VirtualMachineGuru vmGuru = getVmGuru(vm);\n\n        final Ternary<VMInstanceVO, ReservationContext, ItWorkVO> start = changeToStartState(vmGuru, vm, caller, account);\n        if (start == null) {\n            return;\n        }\n\n        vm = start.first();\n        final ReservationContext ctx = start.second();\n        ItWorkVO work = start.third();\n\n        VMInstanceVO startedVm = null;\n        final ServiceOfferingVO offering = _offeringDao.findById(vm.getId(), vm.getServiceOfferingId());\n        final VirtualMachineTemplate template = _entityMgr.findByIdIncludingRemoved(VirtualMachineTemplate.class, vm.getTemplateId());\n\n        DataCenterDeployment plan = new DataCenterDeployment(vm.getDataCenterId(), vm.getPodIdToDeployIn(), null, null, null, null, ctx);\n        if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"advanceStart: DeploymentPlan is provided, using dcId:\" + planToDeploy.getDataCenterId() + \", podId: \" + planToDeploy.getPodId() +\n                        \", clusterId: \" + planToDeploy.getClusterId() + \", hostId: \" + planToDeploy.getHostId() + \", poolId: \" + planToDeploy.getPoolId());\n            }\n            plan =\n                    new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(), planToDeploy.getHostId(),\n                            planToDeploy.getPoolId(), planToDeploy.getPhysicalNetworkId(), ctx);\n        }\n\n        final HypervisorGuru hvGuru = _hvGuruMgr.getGuru(vm.getHypervisorType());\n\n        \r\n        final Account owner = _entityMgr.findById(Account.class, vm.getAccountId());\n        if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n            resourceCountIncrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n        }\n\n        boolean canRetry = true;\n        ExcludeList avoids = null;\n        try {\n            final Journal journal = start.second().getJournal();\n\n            if (planToDeploy != null) {\n                avoids = planToDeploy.getAvoids();\n            }\n            if (avoids == null) {\n                avoids = new ExcludeList();\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Deploy avoids pods: \" + avoids.getPodsToAvoid() + \", clusters: \" + avoids.getClustersToAvoid() + \", hosts: \" + avoids.getHostsToAvoid());\n            }\n\n            boolean planChangedByVolume = false;\n            boolean reuseVolume = true;\n            final DataCenterDeployment originalPlan = plan;\n\n            int retry = StartRetry.value();\n            while (retry-- != 0) { \r\n                s_logger.debug(\"VM start attempt #\" + (StartRetry.value() - retry));\n\n                if (reuseVolume) {\n                    \r\n                    final List<VolumeVO> vols = _volsDao.findReadyRootVolumesByInstance(vm.getId());\n                    for (final VolumeVO vol : vols) {\n                        \r\n                        \r\n                        \r\n                        final Long volTemplateId = vol.getTemplateId();\n                        if (volTemplateId != null && volTemplateId.longValue() != template.getId()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(vol + \" of \" + vm + \" is READY, but template ids don't match, let the planner reassign a new pool\");\n                            }\n                            continue;\n                        }\n\n                        final StoragePool pool = (StoragePool)dataStoreMgr.getPrimaryDataStore(vol.getPoolId());\n                        if (!pool.isInMaintenance()) {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Root volume is ready, need to place VM in volume's cluster\");\n                            }\n                            final long rootVolDcId = pool.getDataCenterId();\n                            final Long rootVolPodId = pool.getPodId();\n                            final Long rootVolClusterId = pool.getClusterId();\n                            if (planToDeploy != null && planToDeploy.getDataCenterId() != 0) {\n                                final Long clusterIdSpecified = planToDeploy.getClusterId();\n                                if (clusterIdSpecified != null && rootVolClusterId != null) {\n                                    if (rootVolClusterId.longValue() != clusterIdSpecified.longValue()) {\n                                        \r\n                                        \r\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"Cannot satisfy the deployment plan passed in since the ready Root volume is in different cluster. volume's cluster: \" +\n                                                    rootVolClusterId + \", cluster specified: \" + clusterIdSpecified);\n                                        }\n                                        throw new ResourceUnavailableException(\n                                                \"Root volume is ready in different cluster, Deployment plan provided cannot be satisfied, unable to create a deployment for \" +\n                                                        vm, Cluster.class, clusterIdSpecified);\n                                    }\n                                }\n                                plan =\n                                        new DataCenterDeployment(planToDeploy.getDataCenterId(), planToDeploy.getPodId(), planToDeploy.getClusterId(),\n                                                planToDeploy.getHostId(), vol.getPoolId(), null, ctx);\n                            } else {\n                                plan = new DataCenterDeployment(rootVolDcId, rootVolPodId, rootVolClusterId, null, vol.getPoolId(), null, ctx);\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(vol + \" is READY, changing deployment plan to use this pool's dcId: \" + rootVolDcId + \" , podId: \" + rootVolPodId +\n                                            \" , and clusterId: \" + rootVolClusterId);\n                                }\n                                planChangedByVolume = true;\n                            }\n                        }\n                    }\n                }\n\n                final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vm, template, offering, owner, params);\n                logBootModeParameters(params);\n                DeployDestination dest = null;\n                try {\n                    dest = _dpMgr.planDeployment(vmProfile, plan, avoids, planner);\n                } catch (final AffinityConflictException e2) {\n                    s_logger.warn(\"Unable to create deployment, affinity rules associted to the VM conflict\", e2);\n                    throw new CloudRuntimeException(\"Unable to create deployment, affinity rules associted to the VM conflict\");\n                }\n\n                if (dest == null) {\n                    if (planChangedByVolume) {\n                        plan = originalPlan;\n                        planChangedByVolume = false;\n                        \r\n                        reuseVolume = false;\n                        continue;\n                    }\n                    throw new InsufficientServerCapacityException(\"Unable to create a deployment for \" + vmProfile, DataCenter.class, plan.getDataCenterId(),\n                            areAffinityGroupsAssociated(vmProfile));\n                }\n\n                if (dest != null) {\n                    avoids.addHost(dest.getHost().getId());\n                    if (!template.isDeployAsIs()) {\n                        journal.record(\"Deployment found - Attempt #\" + (StartRetry.value() - retry), vmProfile, dest);\n                    }\n                }\n\n                long destHostId = dest.getHost().getId();\n                vm.setPodIdToDeployIn(dest.getPod().getId());\n                final Long cluster_id = dest.getCluster().getId();\n                final ClusterDetailsVO cluster_detail_cpu = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.CPU_OVER_COMMIT_RATIO);\n                final ClusterDetailsVO cluster_detail_ram = _clusterDetailsDao.findDetail(cluster_id, VmDetailConstants.MEMORY_OVER_COMMIT_RATIO);\n                \r\n                if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) == null &&\n                        (Float.parseFloat(cluster_detail_cpu.getValue()) > 1f || Float.parseFloat(cluster_detail_ram.getValue()) > 1f)) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                } else if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO) != null) {\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.CPU_OVER_COMMIT_RATIO, cluster_detail_cpu.getValue(), true);\n                    userVmDetailsDao.addDetail(vm.getId(), VmDetailConstants.MEMORY_OVER_COMMIT_RATIO, cluster_detail_ram.getValue(), true);\n                }\n\n                vmProfile.setCpuOvercommitRatio(Float.parseFloat(cluster_detail_cpu.getValue()));\n                vmProfile.setMemoryOvercommitRatio(Float.parseFloat(cluster_detail_ram.getValue()));\n                StartAnswer startAnswer = null;\n\n                try {\n                    if (!changeState(vm, Event.OperationRetry, destHostId, work, Step.Prepare)) {\n                        throw new ConcurrentOperationException(\"Unable to update the state of the Virtual Machine \"+vm.getUuid()+\" oldstate: \"+vm.getState()+ \"Event :\"+Event.OperationRetry);\n                    }\n                } catch (final NoTransitionException e1) {\n                    throw new ConcurrentOperationException(e1.getMessage());\n                }\n\n                try {\n                    resetVmNicsDeviceId(vm.getId());\n                    _networkMgr.prepare(vmProfile, dest, ctx);\n                    if (vm.getHypervisorType() != HypervisorType.BareMetal) {\n                        volumeMgr.prepare(vmProfile, dest);\n                    }\n\n                    \r\n                    if (!reuseVolume) {\n                        reuseVolume = true;\n                    }\n\n                    Commands cmds = null;\n                    vmGuru.finalizeVirtualMachineProfile(vmProfile, dest, ctx);\n\n                    final VirtualMachineTO vmTO = hvGuru.implement(vmProfile);\n\n                    checkAndSetEnterSetupMode(vmTO, params);\n\n                    handlePath(vmTO.getDisks(), vm.getHypervisorType());\n\n                    cmds = new Commands(Command.OnError.Stop);\n\n                    cmds.addCommand(new StartCommand(vmTO, dest.getHost(), getExecuteInSequence(vm.getHypervisorType())));\n\n                    vmGuru.finalizeDeployment(cmds, vmProfile, dest, ctx);\n\n                    \r\n                    addExtraConfig(vmTO);\n\n                    work = _workDao.findById(work.getId());\n                    if (work == null || work.getStep() != Step.Prepare) {\n                        throw new ConcurrentOperationException(\"Work steps have been changed: \" + work);\n                    }\n\n                    _workDao.updateStep(work, Step.Starting);\n\n                    _agentMgr.send(destHostId, cmds);\n\n                    _workDao.updateStep(work, Step.Started);\n\n                    startAnswer = cmds.getAnswer(StartAnswer.class);\n                    if (startAnswer != null && startAnswer.getResult()) {\n                        handlePath(vmTO.getDisks(), startAnswer.getIqnToData());\n\n                        final String host_guid = startAnswer.getHost_guid();\n\n                        if (host_guid != null) {\n                            final HostVO finalHost = _resourceMgr.findHostByGuid(host_guid);\n                            if (finalHost == null) {\n                                throw new CloudRuntimeException(\"Host Guid \" + host_guid + \" doesn't exist in DB, something went wrong while processing start answer: \"+startAnswer);\n                            }\n                            destHostId = finalHost.getId();\n                        }\n                        if (vmGuru.finalizeStart(vmProfile, destHostId, cmds, ctx)) {\n                            syncDiskChainChange(startAnswer);\n\n                            if (!changeState(vm, Event.OperationSucceeded, destHostId, work, Step.Done)) {\n                                s_logger.error(\"Unable to transition to a new state. VM uuid: \"+vm.getUuid()+    \"VM oldstate:\"+vm.getState()+\"Event:\"+Event.OperationSucceeded);\n                                throw new ConcurrentOperationException(\"Failed to deploy VM\"+ vm.getUuid());\n                            }\n\n                            \r\n                            final GPUDeviceTO gpuDevice = startAnswer.getVirtualMachine().getGpuDevice();\n                            if (gpuDevice != null) {\n                                _resourceMgr.updateGPUDetails(destHostId, gpuDevice.getGroupDetails());\n                            }\n\n                            \r\n                            \r\n                            \r\n                            if (userVmDetailsDao.findDetail(vm.getId(), VmDetailConstants.DEPLOY_VM) != null) {\n                                userVmDetailsDao.removeDetail(vm.getId(), VmDetailConstants.DEPLOY_VM);\n                            }\n\n                            startedVm = vm;\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Start completed for VM \" + vm);\n                            }\n                            final Host vmHost = _hostDao.findById(destHostId);\n                            if (vmHost != null && (VirtualMachine.Type.ConsoleProxy.equals(vm.getType()) ||\n                                    VirtualMachine.Type.SecondaryStorageVm.equals(vm.getType())) && caManager.canProvisionCertificates()) {\n                                final Map<String, String> sshAccessDetails = _networkMgr.getSystemVMAccessDetails(vm);\n                                for (int retries = 3; retries > 0; retries--) {\n                                    try {\n                                        setupAgentSecurity(vmHost, sshAccessDetails, vm);\n                                        return;\n                                    } catch (final Exception e) {\n                                        s_logger.error(\"Retrying after catching exception while trying to secure agent for systemvm id=\" + vm.getId(), e);\n                                    }\n                                }\n                                throw new CloudRuntimeException(\"Failed to setup and secure agent for systemvm id=\" + vm.getId());\n                            }\n                            return;\n                        } else {\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.info(\"The guru did not like the answers so stopping \" + vm);\n                            }\n                            StopCommand stopCmd = new StopCommand(vm, getExecuteInSequence(vm.getHypervisorType()), false);\n                            stopCmd.setControlIp(getControlNicIpForVM(vm));\n                            Map<String, Boolean> vlanToPersistenceMap = getVlanToPersistenceMapForVM(vm.getId());\n                            if (MapUtils.isNotEmpty(vlanToPersistenceMap)) {\n                                stopCmd.setVlanToPersistenceMap(vlanToPersistenceMap);\n                            }\n                            final StopCommand cmd = stopCmd;\n                            final Answer answer = _agentMgr.easySend(destHostId, cmd);\n                            if (answer != null && answer instanceof StopAnswer) {\n                                final StopAnswer stopAns = (StopAnswer)answer;\n                                if (vm.getType() == VirtualMachine.Type.User) {\n                                    final String platform = stopAns.getPlatform();\n                                    if (platform != null) {\n                                        final Map<String,String> vmmetadata = new HashMap<String,String>();\n                                        vmmetadata.put(vm.getInstanceName(), platform);\n                                        syncVMMetaData(vmmetadata);\n                                    }\n                                }\n                            }\n\n                            if (answer == null || !answer.getResult()) {\n                                s_logger.warn(\"Unable to stop \" + vm + \" due to \" + (answer != null ? answer.getDetails() : \"no answers\"));\n                                _haMgr.scheduleStop(vm, destHostId, WorkType.ForceStop);\n                                throw new ExecutionException(\"Unable to stop this VM, \"+vm.getUuid()+\" so we are unable to retry the start operation\");\n                            }\n                            throw new ExecutionException(\"Unable to start  VM:\"+vm.getUuid()+\" due to error in finalizeStart, not retrying\");\n                        }\n                    }\n                    s_logger.info(\"Unable to start VM on \" + dest.getHost() + \" due to \" + (startAnswer == null ? \" no start answer\" : startAnswer.getDetails()));\n                    if (startAnswer != null && startAnswer.getContextParam(\"stopRetry\") != null) {\n                        break;\n                    }\n\n                } catch (OperationTimedoutException e) {\n                    s_logger.debug(\"Unable to send the start command to host \" + dest.getHost()+\" failed to start VM: \"+vm.getUuid());\n                    if (e.isActive()) {\n                        _haMgr.scheduleStop(vm, destHostId, WorkType.CheckStop);\n                    }\n                    canRetry = false;\n                    throw new AgentUnavailableException(\"Unable to start \" + vm.getHostName(), destHostId, e);\n                } catch (final ResourceUnavailableException e) {\n                    s_logger.info(\"Unable to contact resource.\", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected ResourceUnavailableException : \" + e.getScope().getName(), e);\n                            throw e;\n                        }\n                    }\n                } catch (final InsufficientCapacityException e) {\n                    s_logger.info(\"Insufficient capacity \", e);\n                    if (!avoids.add(e)) {\n                        if (e.getScope() == Volume.class || e.getScope() == Nic.class) {\n                            throw e;\n                        } else {\n                            s_logger.warn(\"unexpected InsufficientCapacityException : \" + e.getScope().getName(), e);\n                        }\n                    }\n                } catch (final ExecutionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final NoTransitionException e) {\n                    s_logger.error(\"Failed to start instance \" + vm, e);\n                    throw new AgentUnavailableException(\"Unable to start instance due to \" + e.getMessage(), destHostId, e);\n                } catch (final StorageAccessException e) {\n                    s_logger.warn(\"Unable to access storage on host\", e);\n                } finally {\n                    if (startedVm == null && canRetry) {\n                        final Step prevStep = work.getStep();\n                        _workDao.updateStep(work, Step.Release);\n                        \r\n                        if ((prevStep == Step.Started || prevStep == Step.Starting) && startAnswer != null && startAnswer.getResult()) {  \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, false);\n                        } else {\n                            \r\n                            cleanup(vmGuru, vmProfile, work, Event.OperationFailed, true);\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (startedVm == null) {\n                if (VirtualMachine.Type.User.equals(vm.type) && ResoureCountRunningVMsonly.value()) {\n                    resourceCountDecrement(owner.getAccountId(),new Long(offering.getCpu()), new Long(offering.getRamSize()));\n                }\n                if (canRetry) {\n                    try {\n                        changeState(vm, Event.OperationFailed, null, work, Step.Done);\n                    } catch (final NoTransitionException e) {\n                        throw new ConcurrentOperationException(e.getMessage());\n                    }\n                }\n            }\n\n            if (planToDeploy != null) {\n                planToDeploy.setAvoids(avoids);\n            }\n        }\n\n        if (startedVm == null) {\n            throw new CloudRuntimeException(\"Unable to start instance '\" + vm.getHostName() + \"' (\" + vm.getUuid() + \"), see management server log for details\");\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1014,"status":"M"},{"authorDate":"2021-04-05 17:07:11","commitOrder":15,"curCode":"    public Command cleanup(final String vmName) {\n        VirtualMachine vm = _vmDao.findVMByInstanceName(vmName);\n\n        StopCommand cmd = new StopCommand(vmName, getExecuteInSequence(null), false);\n        cmd.setControlIp(getControlNicIpForVM(vm));\n        Map<String, Boolean> vlanToPersistenceMap = getVlanToPersistenceMapForVM(vm.getId());\n        if (MapUtils.isNotEmpty(vlanToPersistenceMap)) {\n            cmd.setVlanToPersistenceMap(vlanToPersistenceMap);\n        }\n        return cmd;\n    }\n","date":"2021-04-05 17:07:11","endLine":3642,"groupId":"12561","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"cleanup","params":"(finalStringvmName)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/1e/92c3ed5be7e6ac76091149b4cc4fcfba874141.src","preCode":"    public Command cleanup(final String vmName) {\n        VirtualMachine vm = _vmDao.findVMByInstanceName(vmName);\n\n        StopCommand cmd = new StopCommand(vmName, getExecuteInSequence(null), false);\n        cmd.setControlIp(getControlNicIpForVM(vm));\n        Map<String, Boolean> vlanToPersistenceMap = getVlanToPersistenceMapForVM(vm.getId());\n        if (MapUtils.isNotEmpty(vlanToPersistenceMap)) {\n            cmd.setVlanToPersistenceMap(vlanToPersistenceMap);\n        }\n        return cmd;\n    }\n","realPath":"engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":3632,"status":"N"}],"commitId":"74bb80687d4cea1288a964d12b43108117cb5744","commitMessage":"@@@resource limit: Fix resource limit check on VM start (#5428)\n\n* resource limit: Fix resource limit check on VM start\n\n* add check to validate if cpu/memory are within limits for custom offering + exception handling\n\n* unit tests\n\nCo-authored-by: utchoang <hoangnm@unitech.vn>","date":"2021-09-24 12:21:16","modifiedFileCount":"6","status":"M","submitter":"Pearl Dsilva"}]
