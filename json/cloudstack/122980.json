[{"authorTime":"2021-04-30 00:20:40","codes":[{"authorDate":"2021-04-30 00:20:40","commitOrder":13,"curCode":"    protected StartAnswer execute(StartCommand cmd) {\n        if (s_logger.isInfoEnabled()) {\n            s_logger.info(\"Executing resource StartCommand: \" + getHumanReadableBytesJson(_gson.toJson(cmd)));\n        }\n\n        VirtualMachineTO vmSpec = cmd.getVirtualMachine();\n        boolean vmAlreadyExistsInVcenter = false;\n\n        String existingVmName = null;\n        VirtualMachineFileInfo existingVmFileInfo = null;\n        VirtualMachineFileLayoutEx existingVmFileLayout = null;\n        List<DatastoreMO> existingDatastores = new ArrayList<DatastoreMO>();\n        String diskStoragePolicyId = null;\n        String vmStoragePolicyId = null;\n        VirtualMachineDefinedProfileSpec diskProfileSpec = null;\n        VirtualMachineDefinedProfileSpec vmProfileSpec = null;\n\n\n        DeployAsIsInfoTO deployAsIsInfo = vmSpec.getDeployAsIsInfo();\n        boolean deployAsIs = deployAsIsInfo != null;\n\n        Pair<String, String> names = composeVmNames(vmSpec);\n        String vmInternalCSName = names.first();\n        String vmNameOnVcenter = names.second();\n        DiskTO rootDiskTO = null;\n        String bootMode = getBootModeFromVmSpec(vmSpec, deployAsIs);\n        Pair<String, String> controllerInfo = getControllerInfoFromVmSpec(vmSpec);\n\n        Boolean systemVm = vmSpec.getType().isUsedBySystem();\n        \r\n        VmwareContext context = getServiceContext();\n        DatacenterMO dcMo = null;\n        try {\n            VmwareManager mgr = context.getStockObject(VmwareManager.CONTEXT_STOCK_NAME);\n\n            VmwareHypervisorHost hyperHost = getHyperHost(context);\n            dcMo = new DatacenterMO(hyperHost.getContext(), hyperHost.getHyperHostDatacenter());\n\n            \r\n            VirtualMachineMO vmInVcenter = dcMo.checkIfVmAlreadyExistsInVcenter(vmNameOnVcenter, vmInternalCSName);\n            if (vmInVcenter != null) {\n                vmAlreadyExistsInVcenter = true;\n                String msg = \"VM with name: \" + vmNameOnVcenter + \" already exists in vCenter.\";\n                s_logger.error(msg);\n                throw new Exception(msg);\n            }\n\n            DiskTO[] specDisks = vmSpec.getDisks();\n            String guestOsId = getGuestOsIdFromVmSpec(vmSpec, deployAsIs);\n            DiskTO[] disks = validateDisks(vmSpec.getDisks());\n            assert (disks.length > 0);\n            NicTO[] nics = vmSpec.getNics();\n\n            HashMap<String, Pair<ManagedObjectReference, DatastoreMO>> dataStoresDetails = inferDatastoreDetailsFromDiskInfo(hyperHost, context, disks, cmd);\n            if ((dataStoresDetails == null) || (dataStoresDetails.isEmpty())) {\n                String msg = \"Unable to locate datastore details of the volumes to be attached\";\n                s_logger.error(msg);\n                throw new Exception(msg);\n            }\n\n            VirtualMachineDiskInfoBuilder diskInfoBuilder = null;\n            VirtualDevice[] nicDevices = null;\n            VirtualMachineMO vmMo = hyperHost.findVmOnHyperHost(vmInternalCSName);\n            DiskControllerType systemVmScsiControllerType = DiskControllerType.lsilogic;\n            int firstScsiControllerBusNum = 0;\n            int numScsiControllerForSystemVm = 1;\n            boolean hasSnapshot = false;\n\n            List<Pair<Integer, ManagedObjectReference>> diskDatastores = null;\n            if (vmMo != null) {\n                s_logger.info(\"VM \" + vmInternalCSName + \" already exists, tear down devices for reconfiguration\");\n                if (getVmPowerState(vmMo) != PowerState.PowerOff)\n                    vmMo.safePowerOff(_shutdownWaitMs);\n\n                \r\n                diskDatastores = vmMo.getAllDiskDatastores();\n                diskInfoBuilder = vmMo.getDiskInfoBuilder();\n                hasSnapshot = vmMo.hasSnapshot();\n                nicDevices = vmMo.getNicDevices();\n\n                tearDownVmDevices(vmMo, hasSnapshot, deployAsIs);\n                ensureDiskControllersInternal(vmMo, systemVm, controllerInfo, systemVmScsiControllerType,\n                        numScsiControllerForSystemVm, firstScsiControllerBusNum, deployAsIs);\n            } else {\n                ManagedObjectReference morDc = hyperHost.getHyperHostDatacenter();\n                assert (morDc != null);\n\n                vmMo = hyperHost.findVmOnPeerHyperHost(vmInternalCSName);\n                if (vmMo != null) {\n                    if (s_logger.isInfoEnabled()) {\n                        s_logger.info(\"Found vm \" + vmInternalCSName + \" at other host, relocate to \" + hyperHost.getHyperHostName());\n                    }\n\n                    takeVmFromOtherHyperHost(hyperHost, vmInternalCSName);\n\n                    if (getVmPowerState(vmMo) != PowerState.PowerOff)\n                        vmMo.safePowerOff(_shutdownWaitMs);\n\n                    diskInfoBuilder = vmMo.getDiskInfoBuilder();\n                    hasSnapshot = vmMo.hasSnapshot();\n                    diskDatastores = vmMo.getAllDiskDatastores();\n\n                    tearDownVmDevices(vmMo, hasSnapshot, deployAsIs);\n                    ensureDiskControllersInternal(vmMo, systemVm, controllerInfo, systemVmScsiControllerType,\n                            numScsiControllerForSystemVm, firstScsiControllerBusNum, deployAsIs);\n                } else {\n                    \r\n                    VirtualMachineMO existingVmInDc = dcMo.findVm(vmInternalCSName);\n                    if (existingVmInDc != null) {\n                        s_logger.debug(\"Found VM: \" + vmInternalCSName + \" on a host in a different cluster. Unregistering the exisitng VM.\");\n                        existingVmName = existingVmInDc.getName();\n                        existingVmFileInfo = existingVmInDc.getFileInfo();\n                        existingVmFileLayout = existingVmInDc.getFileLayout();\n                        existingDatastores = existingVmInDc.getAllDatastores();\n                        existingVmInDc.unregisterVm();\n                    }\n\n                    if (deployAsIs) {\n                        vmMo = hyperHost.findVmOnHyperHost(vmInternalCSName);\n                        if (vmMo == null) {\n                            s_logger.info(\"Cloned deploy-as-is VM \" + vmInternalCSName + \" is not in this host, relocating it\");\n                            vmMo = takeVmFromOtherHyperHost(hyperHost, vmInternalCSName);\n                        }\n                    } else {\n                        DiskTO rootDisk = null;\n                        for (DiskTO vol : disks) {\n                            if (vol.getType() == Volume.Type.ROOT) {\n                                rootDisk = vol;\n                            }\n                        }\n                        Pair<ManagedObjectReference, DatastoreMO> rootDiskDataStoreDetails = getDatastoreThatDiskIsOn(dataStoresDetails, rootDisk);\n                        assert (vmSpec.getMinSpeed() != null) && (rootDiskDataStoreDetails != null);\n                        DatastoreMO dsRootVolumeIsOn = rootDiskDataStoreDetails.second();\n                        if (dsRootVolumeIsOn == null) {\n                                String msg = \"Unable to locate datastore details of root volume\";\n                                s_logger.error(msg);\n                                throw new Exception(msg);\n                            }\n                        if (rootDisk.getDetails().get(DiskTO.PROTOCOL_TYPE) != null && rootDisk.getDetails().get(DiskTO.PROTOCOL_TYPE).equalsIgnoreCase(\"DatastoreCluster\")) {\n                            if (diskInfoBuilder != null) {\n                                DatastoreMO diskDatastoreMofromVM = getDataStoreWhereDiskExists(hyperHost, context, diskInfoBuilder, rootDisk, diskDatastores);\n                                if (diskDatastoreMofromVM != null) {\n                                    String actualPoolUuid = diskDatastoreMofromVM.getCustomFieldValue(CustomFieldConstants.CLOUD_UUID);\n                                    if (!actualPoolUuid.equalsIgnoreCase(rootDisk.getData().getDataStore().getUuid())) {\n                                        dsRootVolumeIsOn = diskDatastoreMofromVM;\n                                    }\n                                }\n                            }\n                        }\n\n                        boolean vmFolderExists = dsRootVolumeIsOn.folderExists(String.format(\"[%s]\", dsRootVolumeIsOn.getName()), vmNameOnVcenter);                        String vmxFileFullPath = dsRootVolumeIsOn.searchFileInSubFolders(vmNameOnVcenter + \".vmx\", false, VmwareManager.s_vmwareSearchExcludeFolder.value());\n                        if (vmFolderExists && vmxFileFullPath != null) { \r\n                            registerVm(vmNameOnVcenter, dsRootVolumeIsOn);\n                            vmMo = hyperHost.findVmOnHyperHost(vmInternalCSName);\n                            if (vmMo != null) {\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(\"Found registered vm \" + vmInternalCSName + \" at host \" + hyperHost.getHyperHostName());\n                                }\n                            }\n                            tearDownVm(vmMo);\n                        } else if (!hyperHost.createBlankVm(vmNameOnVcenter, vmInternalCSName, vmSpec.getCpus(), vmSpec.getMaxSpeed().intValue(), getReservedCpuMHZ(vmSpec),\n                                vmSpec.getLimitCpuUse(), (int) (vmSpec.getMaxRam() / ResourceType.bytesToMiB), getReservedMemoryMb(vmSpec), guestOsId, rootDiskDataStoreDetails.first(), false,\n                                controllerInfo, systemVm)) {\n                            throw new Exception(\"Failed to create VM. vmName: \" + vmInternalCSName);\n                        }\n                    }\n                }\n\n                vmMo = hyperHost.findVmOnHyperHost(vmInternalCSName);\n                if (vmMo == null) {\n                    throw new Exception(\"Failed to find the newly create or relocated VM. vmName: \" + vmInternalCSName);\n                }\n            }\n            if (deployAsIs) {\n                s_logger.info(\"Mapping VM disks to spec disks and tearing down datadisks (if any)\");\n                mapSpecDisksToClonedDisksAndTearDownDatadisks(vmMo, vmInternalCSName, specDisks);\n            }\n\n            int disksChanges = getDisksChangesNumberFromDisksSpec(disks, deployAsIs);\n            int totalChangeDevices = disksChanges + nics.length;\n            if (deployAsIsInfo != null && deployAsIsInfo.getProperties() != null) {\n                totalChangeDevices++;\n            }\n\n            DiskTO volIso = null;\n            if (vmSpec.getType() != VirtualMachine.Type.User) {\n                \r\n                totalChangeDevices++;\n            } else {\n                volIso = getIsoDiskTO(disks);\n                if (volIso == null && !deployAsIs) {\n                    totalChangeDevices++;\n                }\n            }\n\n            VirtualMachineConfigSpec vmConfigSpec = new VirtualMachineConfigSpec();\n\n            int i = 0;\n            int ideUnitNumber = !deployAsIs ? 0 : vmMo.getNextIDEDeviceNumber();\n            int scsiUnitNumber = !deployAsIs ? 0 : vmMo.getNextScsiDiskDeviceNumber();\n            int ideControllerKey = vmMo.getIDEDeviceControllerKey();\n            int scsiControllerKey = vmMo.getScsiDeviceControllerKeyNoException();\n            VirtualDeviceConfigSpec[] deviceConfigSpecArray = new VirtualDeviceConfigSpec[totalChangeDevices];\n            DiskTO[] sortedDisks = sortVolumesByDeviceId(disks);\n\n            VmwareHelper.setBasicVmConfig(vmConfigSpec, vmSpec.getCpus(), vmSpec.getMaxSpeed(), getReservedCpuMHZ(vmSpec), (int) (vmSpec.getMaxRam() / (1024 * 1024)),\n                    getReservedMemoryMb(vmSpec), guestOsId, vmSpec.getLimitCpuUse(), deployAsIs);\n\n            \r\n            int numCoresPerSocket = 1;\n            String coresPerSocket = vmSpec.getDetails().get(VmDetailConstants.CPU_CORE_PER_SOCKET);\n            if (coresPerSocket != null) {\n                String apiVersion = HypervisorHostHelper.getVcenterApiVersion(vmMo.getContext());\n                \r\n                if (apiVersion.compareTo(\"5.0\") >= 0) {\n                    numCoresPerSocket = NumbersUtil.parseInt(coresPerSocket, 1);\n                    vmConfigSpec.setNumCoresPerSocket(numCoresPerSocket);\n                }\n            }\n\n            \r\n            vmConfigSpec.setMemoryHotAddEnabled(vmMo.isMemoryHotAddSupported(guestOsId));\n\n            String hostApiVersion = ((HostMO) hyperHost).getHostAboutInfo().getApiVersion();\n            if (numCoresPerSocket > 1 && hostApiVersion.compareTo(\"5.0\") < 0) {\n                s_logger.warn(\"Dynamic scaling of CPU is not supported for Virtual Machines with multi-core vCPUs in case of ESXi hosts 4.1 and prior. Hence CpuHotAdd will not be\"\n                        + \" enabled for Virtual Machine: \" + vmInternalCSName);\n                vmConfigSpec.setCpuHotAddEnabled(false);\n            } else {\n                vmConfigSpec.setCpuHotAddEnabled(vmMo.isCpuHotAddSupported(guestOsId));\n            }\n\n            configNestedHVSupport(vmMo, vmSpec, vmConfigSpec);\n\n            \r\n            \r\n            \r\n\n            \r\n            if (vmSpec.getType() != VirtualMachine.Type.User) {\n                \r\n                Pair<String, Long> secStoreUrlAndId = mgr.getSecondaryStorageStoreUrlAndId(Long.parseLong(_dcId));\n                String secStoreUrl = secStoreUrlAndId.first();\n                Long secStoreId = secStoreUrlAndId.second();\n                if (secStoreUrl == null) {\n                    String msg = \"secondary storage for dc \" + _dcId + \" is not ready yet?\";\n                    throw new Exception(msg);\n                }\n                mgr.prepareSecondaryStorageStore(secStoreUrl, secStoreId);\n\n                ManagedObjectReference morSecDs = prepareSecondaryDatastoreOnHost(secStoreUrl);\n                if (morSecDs == null) {\n                    String msg = \"Failed to prepare secondary storage on host, secondary store url: \" + secStoreUrl;\n                    throw new Exception(msg);\n                }\n                DatastoreMO secDsMo = new DatastoreMO(hyperHost.getContext(), morSecDs);\n\n                deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n                Pair<VirtualDevice, Boolean> isoInfo = VmwareHelper.prepareIsoDevice(vmMo,\n                        String.format(\"[%s] systemvm/%s\", secDsMo.getName(), mgr.getSystemVMIsoFileNameOnDatastore()), secDsMo.getMor(), true, true, ideUnitNumber++, i + 1);\n                deviceConfigSpecArray[i].setDevice(isoInfo.first());\n                if (isoInfo.second()) {\n                    if (s_logger.isDebugEnabled())\n                        s_logger.debug(\"Prepare ISO volume at new device \" + _gson.toJson(isoInfo.first()));\n                    deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n                } else {\n                    if (s_logger.isDebugEnabled())\n                        s_logger.debug(\"Prepare ISO volume at existing device \" + _gson.toJson(isoInfo.first()));\n                    deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.EDIT);\n                }\n                i++;\n            } else if (!deployAsIs) {\n                \r\n                if (volIso != null) {\n                    for (DiskTO vol : disks) {\n                        if (vol.getType() == Volume.Type.ISO) {\n                            configureIso(hyperHost, vmMo, vol, deviceConfigSpecArray, ideUnitNumber++, i);\n                            i++;\n                        }\n                    }\n                } else {\n                    deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n                    Pair<VirtualDevice, Boolean> isoInfo = VmwareHelper.prepareIsoDevice(vmMo, null, null, true, true, ideUnitNumber++, i + 1);\n                    deviceConfigSpecArray[i].setDevice(isoInfo.first());\n                    if (isoInfo.second()) {\n                        if (s_logger.isDebugEnabled())\n                            s_logger.debug(\"Prepare ISO volume at existing device \" + _gson.toJson(isoInfo.first()));\n\n                        deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n                    } else {\n                        if (s_logger.isDebugEnabled())\n                            s_logger.debug(\"Prepare ISO volume at existing device \" + _gson.toJson(isoInfo.first()));\n\n                        deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.EDIT);\n                    }\n                    i++;\n                }\n            }\n\n            int controllerKey;\n\n            \r\n            \r\n            \r\n            if (multipleIsosAtached(sortedDisks) && deployAsIs) {\n                sortedDisks = getDisks(sortedDisks);\n            }\n\n            for (DiskTO vol : sortedDisks) {\n                if (vol.getType() == Volume.Type.ISO) {\n                    if (deployAsIs) {\n                        configureIso(hyperHost, vmMo, vol, deviceConfigSpecArray, ideUnitNumber++, i);\n                        i++;\n                    }\n                    continue;\n                }\n\n                if (deployAsIs && vol.getType() == Volume.Type.ROOT) {\n                    rootDiskTO = vol;\n                    resizeRootDiskOnVMStart(vmMo, rootDiskTO, hyperHost, context);\n                    continue;\n                }\n\n                VirtualMachineDiskInfo matchingExistingDisk = getMatchingExistingDisk(diskInfoBuilder, vol, hyperHost, context);\n                controllerKey = getDiskController(matchingExistingDisk, vol, vmSpec, ideControllerKey, scsiControllerKey);\n                String diskController = getDiskController(vmMo, matchingExistingDisk, vol, controllerInfo);\n\n                if (DiskControllerType.getType(diskController) == DiskControllerType.osdefault) {\n                    diskController = vmMo.getRecommendedDiskController(null);\n                }\n                if (DiskControllerType.getType(diskController) == DiskControllerType.ide) {\n                    controllerKey = vmMo.getIDEControllerKey(ideUnitNumber);\n                    if (vol.getType() == Volume.Type.DATADISK) {\n                        \r\n                        \r\n                        if (vmMo.getNumberOfVirtualDisks() > 3) {\n                            throw new CloudRuntimeException(\"Found more than 3 virtual disks attached to this VM [\" + vmMo.getVmName() + \"]. Unable to implement the disks over \"\n                                    + diskController + \" controller, as maximum number of devices supported over IDE controller is 4 includeing CDROM device.\");\n                        }\n                    }\n                } else {\n                    if (VmwareHelper.isReservedScsiDeviceNumber(scsiUnitNumber)) {\n                        scsiUnitNumber++;\n                    }\n\n                    controllerKey = vmMo.getScsiDiskControllerKeyNoException(diskController, scsiUnitNumber);\n                    if (controllerKey == -1) {\n                        \r\n                        \r\n                        Ternary<Integer, Integer, DiskControllerType> vmScsiControllerInfo = vmMo.getScsiControllerInfo();\n                        DiskControllerType existingControllerType = vmScsiControllerInfo.third();\n                        controllerKey = vmMo.getScsiDiskControllerKeyNoException(existingControllerType.toString(), scsiUnitNumber);\n                    }\n                }\n                if (!hasSnapshot) {\n                    deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n\n                    VolumeObjectTO volumeTO = (VolumeObjectTO) vol.getData();\n                    DataStoreTO primaryStore = volumeTO.getDataStore();\n                    Map<String, String> details = vol.getDetails();\n                    boolean managed = false;\n                    String iScsiName = null;\n\n                    if (details != null) {\n                        managed = Boolean.parseBoolean(details.get(DiskTO.MANAGED));\n                        iScsiName = details.get(DiskTO.IQN);\n                    }\n\n                    String primaryStoreUuid = primaryStore.getUuid();\n                    \r\n                    String datastoreName = managed ? VmwareResource.getDatastoreName(iScsiName) : primaryStoreUuid;\n                    Pair<ManagedObjectReference, DatastoreMO> volumeDsDetails = dataStoresDetails.get(datastoreName);\n\n                    assert (volumeDsDetails != null);\n                    if (volumeDsDetails == null) {\n                        throw new Exception(\"Primary datastore \" + primaryStore.getUuid() + \" is not mounted on host.\");\n                    }\n\n                    if (vol.getDetails().get(DiskTO.PROTOCOL_TYPE) != null && vol.getDetails().get(DiskTO.PROTOCOL_TYPE).equalsIgnoreCase(\"DatastoreCluster\")) {\n                        if (diskInfoBuilder != null && matchingExistingDisk != null) {\n                            String[] diskChain = matchingExistingDisk.getDiskChain();\n                            if (diskChain != null && diskChain.length > 0) {\n                                DatastoreFile file = new DatastoreFile(diskChain[0]);\n                                if (!file.getFileBaseName().equalsIgnoreCase(volumeTO.getPath())) {\n                                    if (s_logger.isInfoEnabled())\n                                        s_logger.info(\"Detected disk-chain top file change on volume: \" + volumeTO.getId() + \" \" + volumeTO.getPath() + \" -> \" + file.getFileBaseName());\n                                    volumeTO.setPath(file.getFileBaseName());\n                                }\n                            }\n                            DatastoreMO diskDatastoreMofromVM = getDataStoreWhereDiskExists(hyperHost, context, diskInfoBuilder, vol, diskDatastores);\n                            if (diskDatastoreMofromVM != null) {\n                                String actualPoolUuid = diskDatastoreMofromVM.getCustomFieldValue(CustomFieldConstants.CLOUD_UUID);\n                                if (actualPoolUuid != null && !actualPoolUuid.equalsIgnoreCase(primaryStore.getUuid())) {\n                                    volumeDsDetails = new Pair<>(diskDatastoreMofromVM.getMor(), diskDatastoreMofromVM);\n                                    if (s_logger.isInfoEnabled())\n                                        s_logger.info(\"Detected datastore uuid change on volume: \" + volumeTO.getId() + \" \" + primaryStore.getUuid() + \" -> \" + actualPoolUuid);\n                                    ((PrimaryDataStoreTO)primaryStore).setUuid(actualPoolUuid);\n                                }\n                            }\n                        }\n                    }\n\n                    String[] diskChain = syncDiskChain(dcMo, vmMo, vol, matchingExistingDisk, volumeDsDetails.second());\n\n                    int deviceNumber = -1;\n                    if (controllerKey == vmMo.getIDEControllerKey(ideUnitNumber)) {\n                        deviceNumber = ideUnitNumber % VmwareHelper.MAX_ALLOWED_DEVICES_IDE_CONTROLLER;\n                        ideUnitNumber++;\n                    } else {\n                        deviceNumber = scsiUnitNumber % VmwareHelper.MAX_ALLOWED_DEVICES_SCSI_CONTROLLER;\n                        scsiUnitNumber++;\n                    }\n\n                    VirtualDevice device = VmwareHelper.prepareDiskDevice(vmMo, null, controllerKey, diskChain, volumeDsDetails.first(), deviceNumber, i + 1);\n\n                    diskStoragePolicyId = volumeTO.getvSphereStoragePolicyId();\n                    if (!StringUtils.isEmpty(diskStoragePolicyId)) {\n                        PbmProfileManagerMO profMgrMo = new PbmProfileManagerMO(context);\n                        diskProfileSpec = profMgrMo.getProfileSpec(diskStoragePolicyId);\n                        deviceConfigSpecArray[i].getProfile().add(diskProfileSpec);\n                        if (s_logger.isDebugEnabled()) {\n                            s_logger.debug(String.format(\"Adding vSphere storage profile: %s to virtual disk [%s]\", diskStoragePolicyId, _gson.toJson(device)));\n                        }\n                    }\n                    if (vol.getType() == Volume.Type.ROOT) {\n                        rootDiskTO = vol;\n                        vmStoragePolicyId = diskStoragePolicyId;\n                        vmProfileSpec = diskProfileSpec;\n                    }\n                    deviceConfigSpecArray[i].setDevice(device);\n                    deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n\n                    if (s_logger.isDebugEnabled())\n                        s_logger.debug(\"Prepare volume at new device \" + _gson.toJson(device));\n\n                    i++;\n                } else {\n                    if (controllerKey == vmMo.getIDEControllerKey(ideUnitNumber))\n                        ideUnitNumber++;\n                    else\n                        scsiUnitNumber++;\n                }\n            }\n\n            \r\n            \r\n            \r\n            if (StringUtils.isNotBlank(guestOsId) && guestOsId.startsWith(\"darwin\")) { \r\n                VirtualDevice[] devices = vmMo.getMatchedDevices(new Class<?>[]{VirtualUSBController.class});\n                if (devices.length == 0) {\n                    s_logger.debug(\"No USB Controller device on VM Start. Add USB Controller device for Mac OS VM \" + vmInternalCSName);\n\n                    \r\n                    VirtualDevice usbControllerDevice = VmwareHelper.prepareUSBControllerDevice();\n                    deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n                    deviceConfigSpecArray[i].setDevice(usbControllerDevice);\n                    deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n\n                    if (s_logger.isDebugEnabled())\n                        s_logger.debug(\"Prepare USB controller at new device \" + _gson.toJson(deviceConfigSpecArray[i]));\n\n                    i++;\n                } else {\n                    s_logger.debug(\"USB Controller device exists on VM Start for Mac OS VM \" + vmInternalCSName);\n                }\n            }\n\n            \r\n            \r\n            \r\n            VirtualDevice nic;\n            int nicMask = 0;\n            int nicCount = 0;\n\n            if (vmSpec.getType() == VirtualMachine.Type.DomainRouter) {\n                int extraPublicNics = mgr.getRouterExtraPublicNics();\n                if (extraPublicNics > 0 && vmSpec.getDetails().containsKey(\"PeerRouterInstanceName\")) {\n                    \r\n                    String peerRouterInstanceName = vmSpec.getDetails().get(\"PeerRouterInstanceName\");\n\n                    VirtualMachineMO peerVmMo = hyperHost.findVmOnHyperHost(peerRouterInstanceName);\n                    if (peerVmMo == null) {\n                        peerVmMo = hyperHost.findVmOnPeerHyperHost(peerRouterInstanceName);\n                    }\n\n                    if (peerVmMo != null) {\n                        String oldMacSequence = generateMacSequence(nics);\n\n                        for (int nicIndex = nics.length - extraPublicNics; nicIndex < nics.length; nicIndex++) {\n                            VirtualDevice nicDevice = peerVmMo.getNicDeviceByIndex(nics[nicIndex].getDeviceId());\n                            if (nicDevice != null) {\n                                String mac = ((VirtualEthernetCard) nicDevice).getMacAddress();\n                                if (mac != null) {\n                                    s_logger.info(\"Use same MAC as previous RvR, the MAC is \" + mac + \" for extra NIC with device id: \" + nics[nicIndex].getDeviceId());\n                                    nics[nicIndex].setMac(mac);\n                                }\n                            }\n                        }\n\n                        if (!StringUtils.isBlank(vmSpec.getBootArgs())) {\n                            String newMacSequence = generateMacSequence(nics);\n                            vmSpec.setBootArgs(replaceNicsMacSequenceInBootArgs(oldMacSequence, newMacSequence, vmSpec));\n                        }\n                    }\n                }\n            }\n\n            VirtualEthernetCardType nicDeviceType;\n\n            NiciraNvpApiVersion.logNiciraApiVersion();\n\n            Map<String, String> nicUuidToDvSwitchUuid = new HashMap<String, String>();\n            for (NicTO nicTo : sortNicsByDeviceId(nics)) {\n                s_logger.info(\"Prepare NIC device based on NicTO: \" + _gson.toJson(nicTo));\n\n                String adapterTypeStr = deployAsIs ?\n                        mapAdapterType(deployAsIsInfo.getNicAdapterMap().get(nicTo.getDeviceId())) :\n                        vmSpec.getDetails().get(VmDetailConstants.NIC_ADAPTER);\n                nicDeviceType = VirtualEthernetCardType.valueOf(adapterTypeStr);\n\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"VM \" + vmInternalCSName + \" will be started with NIC device type: \" + nicDeviceType + \" on NIC device \" + nicTo.getDeviceId());\n                }\n                boolean configureVServiceInNexus = (nicTo.getType() == TrafficType.Guest) && (vmSpec.getDetails().containsKey(\"ConfigureVServiceInNexus\"));\n                VirtualMachine.Type vmType = cmd.getVirtualMachine().getType();\n                Pair<ManagedObjectReference, String> networkInfo = prepareNetworkFromNicInfo(vmMo.getRunningHost(), nicTo, configureVServiceInNexus, vmType);\n                if ((nicTo.getBroadcastType() != BroadcastDomainType.Lswitch)\n                        || (nicTo.getBroadcastType() == BroadcastDomainType.Lswitch && NiciraNvpApiVersion.isApiVersionLowerThan(\"4.2\"))) {\n                    if (VmwareHelper.isDvPortGroup(networkInfo.first())) {\n                        String dvSwitchUuid;\n                        ManagedObjectReference dcMor = hyperHost.getHyperHostDatacenter();\n                        DatacenterMO dataCenterMo = new DatacenterMO(context, dcMor);\n                        ManagedObjectReference dvsMor = dataCenterMo.getDvSwitchMor(networkInfo.first());\n                        dvSwitchUuid = dataCenterMo.getDvSwitchUuid(dvsMor);\n                        s_logger.info(\"Preparing NIC device on dvSwitch : \" + dvSwitchUuid);\n                        nic = VmwareHelper.prepareDvNicDevice(vmMo, networkInfo.first(), nicDeviceType, networkInfo.second(), dvSwitchUuid,\n                                nicTo.getMac(), i + 1, true, true);\n                        if (nicTo.getUuid() != null) {\n                            nicUuidToDvSwitchUuid.put(nicTo.getUuid(), dvSwitchUuid);\n                        }\n                    } else {\n                        s_logger.info(\"Preparing NIC device on network \" + networkInfo.second());\n                        nic = VmwareHelper.prepareNicDevice(vmMo, networkInfo.first(), nicDeviceType, networkInfo.second(),\n                                nicTo.getMac(), i + 1, true, true);\n                    }\n                } else {\n                    \r\n                    nic = VmwareHelper.prepareNicOpaque(vmMo, nicDeviceType, networkInfo.second(),\n                            nicTo.getMac(), i + 1, true, true);\n                }\n\n                deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n                deviceConfigSpecArray[i].setDevice(nic);\n                deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n\n                if (s_logger.isDebugEnabled())\n                    s_logger.debug(\"Prepare NIC at new device \" + _gson.toJson(deviceConfigSpecArray[i]));\n\n                \r\n                if (nicCount < 3)\n                    nicMask |= (1 << nicCount);\n\n                i++;\n                nicCount++;\n            }\n\n            for (int j = 0; j < i; j++)\n                vmConfigSpec.getDeviceChange().add(deviceConfigSpecArray[j]);\n\n            \r\n            \r\n            \r\n\n            \r\n            ArrayList<OptionValue> extraOptions = new ArrayList<OptionValue>();\n            configBasicExtraOption(extraOptions, vmSpec);\n\n            if (deployAsIs) {\n                setDeployAsIsProperties(vmMo, deployAsIsInfo, vmConfigSpec, hyperHost);\n            }\n\n            configNvpExtraOption(extraOptions, vmSpec, nicUuidToDvSwitchUuid);\n            configCustomExtraOption(extraOptions, vmSpec);\n\n            \r\n            VirtualMachine.Type vmType = cmd.getVirtualMachine().getType();\n            if (vmType.equals(VirtualMachine.Type.NetScalerVm)) {\n                NicTO mgmtNic = vmSpec.getNics()[0];\n                OptionValue option = new OptionValue();\n                option.setKey(\"machine.id\");\n                option.setValue(\"ip=\" + mgmtNic.getIp() + \"&netmask=\" + mgmtNic.getNetmask() + \"&gateway=\" + mgmtNic.getGateway());\n                extraOptions.add(option);\n            }\n\n            configureVNC(vmSpec, extraOptions, vmConfigSpec, hyperHost, vmInternalCSName);\n\n            \r\n            configureVideoCard(vmMo, vmSpec, vmConfigSpec);\n\n            setBootOptions(vmSpec, bootMode, vmConfigSpec);\n\n            if (!StringUtils.isEmpty(vmStoragePolicyId)) {\n                vmConfigSpec.getVmProfile().add(vmProfileSpec);\n                if (s_logger.isTraceEnabled()) {\n                    s_logger.trace(String.format(\"Configuring the VM %s with storage policy: %s\", vmInternalCSName, vmStoragePolicyId));\n                }\n            }\n            \r\n            \r\n            \r\n            if (!vmMo.configureVm(vmConfigSpec)) {\n                throw new Exception(\"Failed to configure VM before start. vmName: \" + vmInternalCSName);\n            }\n\n            if (vmSpec.getType() == VirtualMachine.Type.DomainRouter) {\n                hyperHost.setRestartPriorityForVM(vmMo, DasVmPriority.HIGH.value());\n            }\n\n            \r\n            final Map<String, String> vmDetails = cmd.getVirtualMachine().getDetails();\n            if (!deployAsIs && rootDiskTO != null && !hasSnapshot && (vmDetails != null && vmDetails.containsKey(ApiConstants.ROOT_DISK_SIZE))) {\n                resizeRootDiskOnVMStart(vmMo, rootDiskTO, hyperHost, context);\n            }\n\n            \r\n            \r\n            \r\n\n            vmMo.setCustomFieldValue(CustomFieldConstants.CLOUD_NIC_MASK, String.valueOf(nicMask));\n            postNvpConfigBeforeStart(vmMo, vmSpec);\n\n            Map<String, Map<String, String>> iqnToData = new HashMap<>();\n\n            postDiskConfigBeforeStart(vmMo, vmSpec, sortedDisks, ideControllerKey, scsiControllerKey, iqnToData, hyperHost, context);\n\n            \r\n            \r\n            \r\n            if (!vmMo.powerOn()) {\n                throw new Exception(\"Failed to start VM. vmName: \" + vmInternalCSName + \" with hostname \" + vmNameOnVcenter);\n            }\n\n            StartAnswer startAnswer = new StartAnswer(cmd);\n\n            startAnswer.setIqnToData(iqnToData);\n\n            \r\n            if (existingVmName != null && existingVmFileLayout != null) {\n                List<String> vmDatastoreNames = new ArrayList<String>();\n                for (DatastoreMO vmDatastore : vmMo.getAllDatastores()) {\n                    vmDatastoreNames.add(vmDatastore.getName());\n                }\n                \r\n                List<String> skipDatastores = new ArrayList<String>();\n                for (DatastoreMO existingDatastore : existingDatastores) {\n                    if (vmDatastoreNames.contains(existingDatastore.getName())) {\n                        skipDatastores.add(existingDatastore.getName());\n                    }\n                }\n                deleteUnregisteredVmFiles(existingVmFileLayout, dcMo, true, skipDatastores);\n            }\n\n            return startAnswer;\n        } catch (Throwable e) {\n            if (e instanceof RemoteException) {\n                s_logger.warn(\"Encounter remote exception to vCenter, invalidate VMware session context\");\n                invalidateServiceContext();\n            }\n\n            String msg = \"StartCommand failed due to \" + VmwareHelper.getExceptionMessage(e);\n            s_logger.warn(msg, e);\n            StartAnswer startAnswer = new StartAnswer(cmd, msg);\n            if (vmAlreadyExistsInVcenter) {\n                startAnswer.setContextParam(\"stopRetry\", \"true\");\n            }\n\n            \r\n            if (existingVmName != null && existingVmFileInfo != null) {\n                s_logger.debug(\"Since VM start failed, registering back an existing VM: \" + existingVmName + \" that was unregistered\");\n                try {\n                    DatastoreFile fileInDatastore = new DatastoreFile(existingVmFileInfo.getVmPathName());\n                    DatastoreMO existingVmDsMo = new DatastoreMO(dcMo.getContext(), dcMo.findDatastore(fileInDatastore.getDatastoreName()));\n                    registerVm(existingVmName, existingVmDsMo);\n                } catch (Exception ex) {\n                    String message = \"Failed to register an existing VM: \" + existingVmName + \" due to \" + VmwareHelper.getExceptionMessage(ex);\n                    s_logger.warn(message, ex);\n                }\n            }\n\n            return startAnswer;\n        } finally {\n        }\n    }\n","date":"2021-04-30 00:20:40","endLine":2457,"groupId":"6083","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"execute","params":"(StartCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/20/35cc736ade3abdc2efce433dd904fa383c5f6a.src","preCode":"    protected StartAnswer execute(StartCommand cmd) {\n        if (s_logger.isInfoEnabled()) {\n            s_logger.info(\"Executing resource StartCommand: \" + getHumanReadableBytesJson(_gson.toJson(cmd)));\n        }\n\n        VirtualMachineTO vmSpec = cmd.getVirtualMachine();\n        boolean vmAlreadyExistsInVcenter = false;\n\n        String existingVmName = null;\n        VirtualMachineFileInfo existingVmFileInfo = null;\n        VirtualMachineFileLayoutEx existingVmFileLayout = null;\n        List<DatastoreMO> existingDatastores = new ArrayList<DatastoreMO>();\n        String diskStoragePolicyId = null;\n        String vmStoragePolicyId = null;\n        VirtualMachineDefinedProfileSpec diskProfileSpec = null;\n        VirtualMachineDefinedProfileSpec vmProfileSpec = null;\n\n\n        DeployAsIsInfoTO deployAsIsInfo = vmSpec.getDeployAsIsInfo();\n        boolean deployAsIs = deployAsIsInfo != null;\n\n        Pair<String, String> names = composeVmNames(vmSpec);\n        String vmInternalCSName = names.first();\n        String vmNameOnVcenter = names.second();\n        DiskTO rootDiskTO = null;\n        String bootMode = getBootModeFromVmSpec(vmSpec, deployAsIs);\n        Pair<String, String> controllerInfo = getControllerInfoFromVmSpec(vmSpec);\n\n        Boolean systemVm = vmSpec.getType().isUsedBySystem();\n        \r\n        VmwareContext context = getServiceContext();\n        DatacenterMO dcMo = null;\n        try {\n            VmwareManager mgr = context.getStockObject(VmwareManager.CONTEXT_STOCK_NAME);\n\n            VmwareHypervisorHost hyperHost = getHyperHost(context);\n            dcMo = new DatacenterMO(hyperHost.getContext(), hyperHost.getHyperHostDatacenter());\n\n            \r\n            VirtualMachineMO vmInVcenter = dcMo.checkIfVmAlreadyExistsInVcenter(vmNameOnVcenter, vmInternalCSName);\n            if (vmInVcenter != null) {\n                vmAlreadyExistsInVcenter = true;\n                String msg = \"VM with name: \" + vmNameOnVcenter + \" already exists in vCenter.\";\n                s_logger.error(msg);\n                throw new Exception(msg);\n            }\n\n            DiskTO[] specDisks = vmSpec.getDisks();\n            String guestOsId = getGuestOsIdFromVmSpec(vmSpec, deployAsIs);\n            DiskTO[] disks = validateDisks(vmSpec.getDisks());\n            assert (disks.length > 0);\n            NicTO[] nics = vmSpec.getNics();\n\n            HashMap<String, Pair<ManagedObjectReference, DatastoreMO>> dataStoresDetails = inferDatastoreDetailsFromDiskInfo(hyperHost, context, disks, cmd);\n            if ((dataStoresDetails == null) || (dataStoresDetails.isEmpty())) {\n                String msg = \"Unable to locate datastore details of the volumes to be attached\";\n                s_logger.error(msg);\n                throw new Exception(msg);\n            }\n\n            VirtualMachineDiskInfoBuilder diskInfoBuilder = null;\n            VirtualDevice[] nicDevices = null;\n            VirtualMachineMO vmMo = hyperHost.findVmOnHyperHost(vmInternalCSName);\n            DiskControllerType systemVmScsiControllerType = DiskControllerType.lsilogic;\n            int firstScsiControllerBusNum = 0;\n            int numScsiControllerForSystemVm = 1;\n            boolean hasSnapshot = false;\n\n            List<Pair<Integer, ManagedObjectReference>> diskDatastores = null;\n            if (vmMo != null) {\n                s_logger.info(\"VM \" + vmInternalCSName + \" already exists, tear down devices for reconfiguration\");\n                if (getVmPowerState(vmMo) != PowerState.PowerOff)\n                    vmMo.safePowerOff(_shutdownWaitMs);\n\n                \r\n                diskDatastores = vmMo.getAllDiskDatastores();\n                diskInfoBuilder = vmMo.getDiskInfoBuilder();\n                hasSnapshot = vmMo.hasSnapshot();\n                nicDevices = vmMo.getNicDevices();\n\n                tearDownVmDevices(vmMo, hasSnapshot, deployAsIs);\n                ensureDiskControllersInternal(vmMo, systemVm, controllerInfo, systemVmScsiControllerType,\n                        numScsiControllerForSystemVm, firstScsiControllerBusNum, deployAsIs);\n            } else {\n                ManagedObjectReference morDc = hyperHost.getHyperHostDatacenter();\n                assert (morDc != null);\n\n                vmMo = hyperHost.findVmOnPeerHyperHost(vmInternalCSName);\n                if (vmMo != null) {\n                    if (s_logger.isInfoEnabled()) {\n                        s_logger.info(\"Found vm \" + vmInternalCSName + \" at other host, relocate to \" + hyperHost.getHyperHostName());\n                    }\n\n                    takeVmFromOtherHyperHost(hyperHost, vmInternalCSName);\n\n                    if (getVmPowerState(vmMo) != PowerState.PowerOff)\n                        vmMo.safePowerOff(_shutdownWaitMs);\n\n                    diskInfoBuilder = vmMo.getDiskInfoBuilder();\n                    hasSnapshot = vmMo.hasSnapshot();\n                    diskDatastores = vmMo.getAllDiskDatastores();\n\n                    tearDownVmDevices(vmMo, hasSnapshot, deployAsIs);\n                    ensureDiskControllersInternal(vmMo, systemVm, controllerInfo, systemVmScsiControllerType,\n                            numScsiControllerForSystemVm, firstScsiControllerBusNum, deployAsIs);\n                } else {\n                    \r\n                    VirtualMachineMO existingVmInDc = dcMo.findVm(vmInternalCSName);\n                    if (existingVmInDc != null) {\n                        s_logger.debug(\"Found VM: \" + vmInternalCSName + \" on a host in a different cluster. Unregistering the exisitng VM.\");\n                        existingVmName = existingVmInDc.getName();\n                        existingVmFileInfo = existingVmInDc.getFileInfo();\n                        existingVmFileLayout = existingVmInDc.getFileLayout();\n                        existingDatastores = existingVmInDc.getAllDatastores();\n                        existingVmInDc.unregisterVm();\n                    }\n\n                    if (deployAsIs) {\n                        vmMo = hyperHost.findVmOnHyperHost(vmInternalCSName);\n                        if (vmMo == null) {\n                            s_logger.info(\"Cloned deploy-as-is VM \" + vmInternalCSName + \" is not in this host, relocating it\");\n                            vmMo = takeVmFromOtherHyperHost(hyperHost, vmInternalCSName);\n                        }\n                    } else {\n                        DiskTO rootDisk = null;\n                        for (DiskTO vol : disks) {\n                            if (vol.getType() == Volume.Type.ROOT) {\n                                rootDisk = vol;\n                            }\n                        }\n                        Pair<ManagedObjectReference, DatastoreMO> rootDiskDataStoreDetails = getDatastoreThatDiskIsOn(dataStoresDetails, rootDisk);\n                        assert (vmSpec.getMinSpeed() != null) && (rootDiskDataStoreDetails != null);\n                        DatastoreMO dsRootVolumeIsOn = rootDiskDataStoreDetails.second();\n                        if (dsRootVolumeIsOn == null) {\n                                String msg = \"Unable to locate datastore details of root volume\";\n                                s_logger.error(msg);\n                                throw new Exception(msg);\n                            }\n                        if (rootDisk.getDetails().get(DiskTO.PROTOCOL_TYPE) != null && rootDisk.getDetails().get(DiskTO.PROTOCOL_TYPE).equalsIgnoreCase(\"DatastoreCluster\")) {\n                            if (diskInfoBuilder != null) {\n                                DatastoreMO diskDatastoreMofromVM = getDataStoreWhereDiskExists(hyperHost, context, diskInfoBuilder, rootDisk, diskDatastores);\n                                if (diskDatastoreMofromVM != null) {\n                                    String actualPoolUuid = diskDatastoreMofromVM.getCustomFieldValue(CustomFieldConstants.CLOUD_UUID);\n                                    if (!actualPoolUuid.equalsIgnoreCase(rootDisk.getData().getDataStore().getUuid())) {\n                                        dsRootVolumeIsOn = diskDatastoreMofromVM;\n                                    }\n                                }\n                            }\n                        }\n\n                        boolean vmFolderExists = dsRootVolumeIsOn.folderExists(String.format(\"[%s]\", dsRootVolumeIsOn.getName()), vmNameOnVcenter);                        String vmxFileFullPath = dsRootVolumeIsOn.searchFileInSubFolders(vmNameOnVcenter + \".vmx\", false, VmwareManager.s_vmwareSearchExcludeFolder.value());\n                        if (vmFolderExists && vmxFileFullPath != null) { \r\n                            registerVm(vmNameOnVcenter, dsRootVolumeIsOn);\n                            vmMo = hyperHost.findVmOnHyperHost(vmInternalCSName);\n                            if (vmMo != null) {\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(\"Found registered vm \" + vmInternalCSName + \" at host \" + hyperHost.getHyperHostName());\n                                }\n                            }\n                            tearDownVm(vmMo);\n                        } else if (!hyperHost.createBlankVm(vmNameOnVcenter, vmInternalCSName, vmSpec.getCpus(), vmSpec.getMaxSpeed().intValue(), getReservedCpuMHZ(vmSpec),\n                                vmSpec.getLimitCpuUse(), (int) (vmSpec.getMaxRam() / ResourceType.bytesToMiB), getReservedMemoryMb(vmSpec), guestOsId, rootDiskDataStoreDetails.first(), false,\n                                controllerInfo, systemVm)) {\n                            throw new Exception(\"Failed to create VM. vmName: \" + vmInternalCSName);\n                        }\n                    }\n                }\n\n                vmMo = hyperHost.findVmOnHyperHost(vmInternalCSName);\n                if (vmMo == null) {\n                    throw new Exception(\"Failed to find the newly create or relocated VM. vmName: \" + vmInternalCSName);\n                }\n            }\n            if (deployAsIs) {\n                s_logger.info(\"Mapping VM disks to spec disks and tearing down datadisks (if any)\");\n                mapSpecDisksToClonedDisksAndTearDownDatadisks(vmMo, vmInternalCSName, specDisks);\n            }\n\n            int disksChanges = getDisksChangesNumberFromDisksSpec(disks, deployAsIs);\n            int totalChangeDevices = disksChanges + nics.length;\n            if (deployAsIsInfo != null && deployAsIsInfo.getProperties() != null) {\n                totalChangeDevices++;\n            }\n\n            DiskTO volIso = null;\n            if (vmSpec.getType() != VirtualMachine.Type.User) {\n                \r\n                totalChangeDevices++;\n            } else {\n                volIso = getIsoDiskTO(disks);\n                if (volIso == null && !deployAsIs) {\n                    totalChangeDevices++;\n                }\n            }\n\n            VirtualMachineConfigSpec vmConfigSpec = new VirtualMachineConfigSpec();\n\n            int i = 0;\n            int ideUnitNumber = !deployAsIs ? 0 : vmMo.getNextIDEDeviceNumber();\n            int scsiUnitNumber = !deployAsIs ? 0 : vmMo.getNextScsiDiskDeviceNumber();\n            int ideControllerKey = vmMo.getIDEDeviceControllerKey();\n            int scsiControllerKey = vmMo.getScsiDeviceControllerKeyNoException();\n            VirtualDeviceConfigSpec[] deviceConfigSpecArray = new VirtualDeviceConfigSpec[totalChangeDevices];\n            DiskTO[] sortedDisks = sortVolumesByDeviceId(disks);\n\n            VmwareHelper.setBasicVmConfig(vmConfigSpec, vmSpec.getCpus(), vmSpec.getMaxSpeed(), getReservedCpuMHZ(vmSpec), (int) (vmSpec.getMaxRam() / (1024 * 1024)),\n                    getReservedMemoryMb(vmSpec), guestOsId, vmSpec.getLimitCpuUse(), deployAsIs);\n\n            \r\n            int numCoresPerSocket = 1;\n            String coresPerSocket = vmSpec.getDetails().get(VmDetailConstants.CPU_CORE_PER_SOCKET);\n            if (coresPerSocket != null) {\n                String apiVersion = HypervisorHostHelper.getVcenterApiVersion(vmMo.getContext());\n                \r\n                if (apiVersion.compareTo(\"5.0\") >= 0) {\n                    numCoresPerSocket = NumbersUtil.parseInt(coresPerSocket, 1);\n                    vmConfigSpec.setNumCoresPerSocket(numCoresPerSocket);\n                }\n            }\n\n            \r\n            vmConfigSpec.setMemoryHotAddEnabled(vmMo.isMemoryHotAddSupported(guestOsId));\n\n            String hostApiVersion = ((HostMO) hyperHost).getHostAboutInfo().getApiVersion();\n            if (numCoresPerSocket > 1 && hostApiVersion.compareTo(\"5.0\") < 0) {\n                s_logger.warn(\"Dynamic scaling of CPU is not supported for Virtual Machines with multi-core vCPUs in case of ESXi hosts 4.1 and prior. Hence CpuHotAdd will not be\"\n                        + \" enabled for Virtual Machine: \" + vmInternalCSName);\n                vmConfigSpec.setCpuHotAddEnabled(false);\n            } else {\n                vmConfigSpec.setCpuHotAddEnabled(vmMo.isCpuHotAddSupported(guestOsId));\n            }\n\n            configNestedHVSupport(vmMo, vmSpec, vmConfigSpec);\n\n            \r\n            \r\n            \r\n\n            \r\n            if (vmSpec.getType() != VirtualMachine.Type.User) {\n                \r\n                Pair<String, Long> secStoreUrlAndId = mgr.getSecondaryStorageStoreUrlAndId(Long.parseLong(_dcId));\n                String secStoreUrl = secStoreUrlAndId.first();\n                Long secStoreId = secStoreUrlAndId.second();\n                if (secStoreUrl == null) {\n                    String msg = \"secondary storage for dc \" + _dcId + \" is not ready yet?\";\n                    throw new Exception(msg);\n                }\n                mgr.prepareSecondaryStorageStore(secStoreUrl, secStoreId);\n\n                ManagedObjectReference morSecDs = prepareSecondaryDatastoreOnHost(secStoreUrl);\n                if (morSecDs == null) {\n                    String msg = \"Failed to prepare secondary storage on host, secondary store url: \" + secStoreUrl;\n                    throw new Exception(msg);\n                }\n                DatastoreMO secDsMo = new DatastoreMO(hyperHost.getContext(), morSecDs);\n\n                deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n                Pair<VirtualDevice, Boolean> isoInfo = VmwareHelper.prepareIsoDevice(vmMo,\n                        String.format(\"[%s] systemvm/%s\", secDsMo.getName(), mgr.getSystemVMIsoFileNameOnDatastore()), secDsMo.getMor(), true, true, ideUnitNumber++, i + 1);\n                deviceConfigSpecArray[i].setDevice(isoInfo.first());\n                if (isoInfo.second()) {\n                    if (s_logger.isDebugEnabled())\n                        s_logger.debug(\"Prepare ISO volume at new device \" + _gson.toJson(isoInfo.first()));\n                    deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n                } else {\n                    if (s_logger.isDebugEnabled())\n                        s_logger.debug(\"Prepare ISO volume at existing device \" + _gson.toJson(isoInfo.first()));\n                    deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.EDIT);\n                }\n                i++;\n            } else if (!deployAsIs) {\n                \r\n                if (volIso != null) {\n                    for (DiskTO vol : disks) {\n                        if (vol.getType() == Volume.Type.ISO) {\n                            configureIso(hyperHost, vmMo, vol, deviceConfigSpecArray, ideUnitNumber++, i);\n                            i++;\n                        }\n                    }\n                } else {\n                    deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n                    Pair<VirtualDevice, Boolean> isoInfo = VmwareHelper.prepareIsoDevice(vmMo, null, null, true, true, ideUnitNumber++, i + 1);\n                    deviceConfigSpecArray[i].setDevice(isoInfo.first());\n                    if (isoInfo.second()) {\n                        if (s_logger.isDebugEnabled())\n                            s_logger.debug(\"Prepare ISO volume at existing device \" + _gson.toJson(isoInfo.first()));\n\n                        deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n                    } else {\n                        if (s_logger.isDebugEnabled())\n                            s_logger.debug(\"Prepare ISO volume at existing device \" + _gson.toJson(isoInfo.first()));\n\n                        deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.EDIT);\n                    }\n                    i++;\n                }\n            }\n\n            int controllerKey;\n\n            \r\n            \r\n            \r\n            if (multipleIsosAtached(sortedDisks) && deployAsIs) {\n                sortedDisks = getDisks(sortedDisks);\n            }\n\n            for (DiskTO vol : sortedDisks) {\n                if (vol.getType() == Volume.Type.ISO) {\n                    if (deployAsIs) {\n                        configureIso(hyperHost, vmMo, vol, deviceConfigSpecArray, ideUnitNumber++, i);\n                        i++;\n                    }\n                    continue;\n                }\n\n                if (deployAsIs && vol.getType() == Volume.Type.ROOT) {\n                    rootDiskTO = vol;\n                    resizeRootDiskOnVMStart(vmMo, rootDiskTO, hyperHost, context);\n                    continue;\n                }\n\n                VirtualMachineDiskInfo matchingExistingDisk = getMatchingExistingDisk(diskInfoBuilder, vol, hyperHost, context);\n                controllerKey = getDiskController(matchingExistingDisk, vol, vmSpec, ideControllerKey, scsiControllerKey);\n                String diskController = getDiskController(vmMo, matchingExistingDisk, vol, controllerInfo);\n\n                if (DiskControllerType.getType(diskController) == DiskControllerType.osdefault) {\n                    diskController = vmMo.getRecommendedDiskController(null);\n                }\n                if (DiskControllerType.getType(diskController) == DiskControllerType.ide) {\n                    controllerKey = vmMo.getIDEControllerKey(ideUnitNumber);\n                    if (vol.getType() == Volume.Type.DATADISK) {\n                        \r\n                        \r\n                        if (vmMo.getNumberOfVirtualDisks() > 3) {\n                            throw new CloudRuntimeException(\"Found more than 3 virtual disks attached to this VM [\" + vmMo.getVmName() + \"]. Unable to implement the disks over \"\n                                    + diskController + \" controller, as maximum number of devices supported over IDE controller is 4 includeing CDROM device.\");\n                        }\n                    }\n                } else {\n                    if (VmwareHelper.isReservedScsiDeviceNumber(scsiUnitNumber)) {\n                        scsiUnitNumber++;\n                    }\n\n                    controllerKey = vmMo.getScsiDiskControllerKeyNoException(diskController, scsiUnitNumber);\n                    if (controllerKey == -1) {\n                        \r\n                        \r\n                        Ternary<Integer, Integer, DiskControllerType> vmScsiControllerInfo = vmMo.getScsiControllerInfo();\n                        DiskControllerType existingControllerType = vmScsiControllerInfo.third();\n                        controllerKey = vmMo.getScsiDiskControllerKeyNoException(existingControllerType.toString(), scsiUnitNumber);\n                    }\n                }\n                if (!hasSnapshot) {\n                    deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n\n                    VolumeObjectTO volumeTO = (VolumeObjectTO) vol.getData();\n                    DataStoreTO primaryStore = volumeTO.getDataStore();\n                    Map<String, String> details = vol.getDetails();\n                    boolean managed = false;\n                    String iScsiName = null;\n\n                    if (details != null) {\n                        managed = Boolean.parseBoolean(details.get(DiskTO.MANAGED));\n                        iScsiName = details.get(DiskTO.IQN);\n                    }\n\n                    String primaryStoreUuid = primaryStore.getUuid();\n                    \r\n                    String datastoreName = managed ? VmwareResource.getDatastoreName(iScsiName) : primaryStoreUuid;\n                    Pair<ManagedObjectReference, DatastoreMO> volumeDsDetails = dataStoresDetails.get(datastoreName);\n\n                    assert (volumeDsDetails != null);\n                    if (volumeDsDetails == null) {\n                        throw new Exception(\"Primary datastore \" + primaryStore.getUuid() + \" is not mounted on host.\");\n                    }\n\n                    if (vol.getDetails().get(DiskTO.PROTOCOL_TYPE) != null && vol.getDetails().get(DiskTO.PROTOCOL_TYPE).equalsIgnoreCase(\"DatastoreCluster\")) {\n                        if (diskInfoBuilder != null && matchingExistingDisk != null) {\n                            String[] diskChain = matchingExistingDisk.getDiskChain();\n                            if (diskChain != null && diskChain.length > 0) {\n                                DatastoreFile file = new DatastoreFile(diskChain[0]);\n                                if (!file.getFileBaseName().equalsIgnoreCase(volumeTO.getPath())) {\n                                    if (s_logger.isInfoEnabled())\n                                        s_logger.info(\"Detected disk-chain top file change on volume: \" + volumeTO.getId() + \" \" + volumeTO.getPath() + \" -> \" + file.getFileBaseName());\n                                    volumeTO.setPath(file.getFileBaseName());\n                                }\n                            }\n                            DatastoreMO diskDatastoreMofromVM = getDataStoreWhereDiskExists(hyperHost, context, diskInfoBuilder, vol, diskDatastores);\n                            if (diskDatastoreMofromVM != null) {\n                                String actualPoolUuid = diskDatastoreMofromVM.getCustomFieldValue(CustomFieldConstants.CLOUD_UUID);\n                                if (actualPoolUuid != null && !actualPoolUuid.equalsIgnoreCase(primaryStore.getUuid())) {\n                                    volumeDsDetails = new Pair<>(diskDatastoreMofromVM.getMor(), diskDatastoreMofromVM);\n                                    if (s_logger.isInfoEnabled())\n                                        s_logger.info(\"Detected datastore uuid change on volume: \" + volumeTO.getId() + \" \" + primaryStore.getUuid() + \" -> \" + actualPoolUuid);\n                                    ((PrimaryDataStoreTO)primaryStore).setUuid(actualPoolUuid);\n                                }\n                            }\n                        }\n                    }\n\n                    String[] diskChain = syncDiskChain(dcMo, vmMo, vol, matchingExistingDisk, volumeDsDetails.second());\n\n                    int deviceNumber = -1;\n                    if (controllerKey == vmMo.getIDEControllerKey(ideUnitNumber)) {\n                        deviceNumber = ideUnitNumber % VmwareHelper.MAX_ALLOWED_DEVICES_IDE_CONTROLLER;\n                        ideUnitNumber++;\n                    } else {\n                        deviceNumber = scsiUnitNumber % VmwareHelper.MAX_ALLOWED_DEVICES_SCSI_CONTROLLER;\n                        scsiUnitNumber++;\n                    }\n\n                    VirtualDevice device = VmwareHelper.prepareDiskDevice(vmMo, null, controllerKey, diskChain, volumeDsDetails.first(), deviceNumber, i + 1);\n\n                    diskStoragePolicyId = volumeTO.getvSphereStoragePolicyId();\n                    if (!StringUtils.isEmpty(diskStoragePolicyId)) {\n                        PbmProfileManagerMO profMgrMo = new PbmProfileManagerMO(context);\n                        diskProfileSpec = profMgrMo.getProfileSpec(diskStoragePolicyId);\n                        deviceConfigSpecArray[i].getProfile().add(diskProfileSpec);\n                        if (s_logger.isDebugEnabled()) {\n                            s_logger.debug(String.format(\"Adding vSphere storage profile: %s to virtual disk [%s]\", diskStoragePolicyId, _gson.toJson(device)));\n                        }\n                    }\n                    if (vol.getType() == Volume.Type.ROOT) {\n                        rootDiskTO = vol;\n                        vmStoragePolicyId = diskStoragePolicyId;\n                        vmProfileSpec = diskProfileSpec;\n                    }\n                    deviceConfigSpecArray[i].setDevice(device);\n                    deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n\n                    if (s_logger.isDebugEnabled())\n                        s_logger.debug(\"Prepare volume at new device \" + _gson.toJson(device));\n\n                    i++;\n                } else {\n                    if (controllerKey == vmMo.getIDEControllerKey(ideUnitNumber))\n                        ideUnitNumber++;\n                    else\n                        scsiUnitNumber++;\n                }\n            }\n\n            \r\n            \r\n            \r\n            if (StringUtils.isNotBlank(guestOsId) && guestOsId.startsWith(\"darwin\")) { \r\n                VirtualDevice[] devices = vmMo.getMatchedDevices(new Class<?>[]{VirtualUSBController.class});\n                if (devices.length == 0) {\n                    s_logger.debug(\"No USB Controller device on VM Start. Add USB Controller device for Mac OS VM \" + vmInternalCSName);\n\n                    \r\n                    VirtualDevice usbControllerDevice = VmwareHelper.prepareUSBControllerDevice();\n                    deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n                    deviceConfigSpecArray[i].setDevice(usbControllerDevice);\n                    deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n\n                    if (s_logger.isDebugEnabled())\n                        s_logger.debug(\"Prepare USB controller at new device \" + _gson.toJson(deviceConfigSpecArray[i]));\n\n                    i++;\n                } else {\n                    s_logger.debug(\"USB Controller device exists on VM Start for Mac OS VM \" + vmInternalCSName);\n                }\n            }\n\n            \r\n            \r\n            \r\n            VirtualDevice nic;\n            int nicMask = 0;\n            int nicCount = 0;\n\n            if (vmSpec.getType() == VirtualMachine.Type.DomainRouter) {\n                int extraPublicNics = mgr.getRouterExtraPublicNics();\n                if (extraPublicNics > 0 && vmSpec.getDetails().containsKey(\"PeerRouterInstanceName\")) {\n                    \r\n                    String peerRouterInstanceName = vmSpec.getDetails().get(\"PeerRouterInstanceName\");\n\n                    VirtualMachineMO peerVmMo = hyperHost.findVmOnHyperHost(peerRouterInstanceName);\n                    if (peerVmMo == null) {\n                        peerVmMo = hyperHost.findVmOnPeerHyperHost(peerRouterInstanceName);\n                    }\n\n                    if (peerVmMo != null) {\n                        String oldMacSequence = generateMacSequence(nics);\n\n                        for (int nicIndex = nics.length - extraPublicNics; nicIndex < nics.length; nicIndex++) {\n                            VirtualDevice nicDevice = peerVmMo.getNicDeviceByIndex(nics[nicIndex].getDeviceId());\n                            if (nicDevice != null) {\n                                String mac = ((VirtualEthernetCard) nicDevice).getMacAddress();\n                                if (mac != null) {\n                                    s_logger.info(\"Use same MAC as previous RvR, the MAC is \" + mac + \" for extra NIC with device id: \" + nics[nicIndex].getDeviceId());\n                                    nics[nicIndex].setMac(mac);\n                                }\n                            }\n                        }\n\n                        if (!StringUtils.isBlank(vmSpec.getBootArgs())) {\n                            String newMacSequence = generateMacSequence(nics);\n                            vmSpec.setBootArgs(replaceNicsMacSequenceInBootArgs(oldMacSequence, newMacSequence, vmSpec));\n                        }\n                    }\n                }\n            }\n\n            VirtualEthernetCardType nicDeviceType;\n\n            NiciraNvpApiVersion.logNiciraApiVersion();\n\n            Map<String, String> nicUuidToDvSwitchUuid = new HashMap<String, String>();\n            for (NicTO nicTo : sortNicsByDeviceId(nics)) {\n                s_logger.info(\"Prepare NIC device based on NicTO: \" + _gson.toJson(nicTo));\n\n                String adapterTypeStr = deployAsIs ?\n                        mapAdapterType(deployAsIsInfo.getNicAdapterMap().get(nicTo.getDeviceId())) :\n                        vmSpec.getDetails().get(VmDetailConstants.NIC_ADAPTER);\n                nicDeviceType = VirtualEthernetCardType.valueOf(adapterTypeStr);\n\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"VM \" + vmInternalCSName + \" will be started with NIC device type: \" + nicDeviceType + \" on NIC device \" + nicTo.getDeviceId());\n                }\n                boolean configureVServiceInNexus = (nicTo.getType() == TrafficType.Guest) && (vmSpec.getDetails().containsKey(\"ConfigureVServiceInNexus\"));\n                VirtualMachine.Type vmType = cmd.getVirtualMachine().getType();\n                Pair<ManagedObjectReference, String> networkInfo = prepareNetworkFromNicInfo(vmMo.getRunningHost(), nicTo, configureVServiceInNexus, vmType);\n                if ((nicTo.getBroadcastType() != BroadcastDomainType.Lswitch)\n                        || (nicTo.getBroadcastType() == BroadcastDomainType.Lswitch && NiciraNvpApiVersion.isApiVersionLowerThan(\"4.2\"))) {\n                    if (VmwareHelper.isDvPortGroup(networkInfo.first())) {\n                        String dvSwitchUuid;\n                        ManagedObjectReference dcMor = hyperHost.getHyperHostDatacenter();\n                        DatacenterMO dataCenterMo = new DatacenterMO(context, dcMor);\n                        ManagedObjectReference dvsMor = dataCenterMo.getDvSwitchMor(networkInfo.first());\n                        dvSwitchUuid = dataCenterMo.getDvSwitchUuid(dvsMor);\n                        s_logger.info(\"Preparing NIC device on dvSwitch : \" + dvSwitchUuid);\n                        nic = VmwareHelper.prepareDvNicDevice(vmMo, networkInfo.first(), nicDeviceType, networkInfo.second(), dvSwitchUuid,\n                                nicTo.getMac(), i + 1, true, true);\n                        if (nicTo.getUuid() != null) {\n                            nicUuidToDvSwitchUuid.put(nicTo.getUuid(), dvSwitchUuid);\n                        }\n                    } else {\n                        s_logger.info(\"Preparing NIC device on network \" + networkInfo.second());\n                        nic = VmwareHelper.prepareNicDevice(vmMo, networkInfo.first(), nicDeviceType, networkInfo.second(),\n                                nicTo.getMac(), i + 1, true, true);\n                    }\n                } else {\n                    \r\n                    nic = VmwareHelper.prepareNicOpaque(vmMo, nicDeviceType, networkInfo.second(),\n                            nicTo.getMac(), i + 1, true, true);\n                }\n\n                deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n                deviceConfigSpecArray[i].setDevice(nic);\n                deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n\n                if (s_logger.isDebugEnabled())\n                    s_logger.debug(\"Prepare NIC at new device \" + _gson.toJson(deviceConfigSpecArray[i]));\n\n                \r\n                if (nicCount < 3)\n                    nicMask |= (1 << nicCount);\n\n                i++;\n                nicCount++;\n            }\n\n            for (int j = 0; j < i; j++)\n                vmConfigSpec.getDeviceChange().add(deviceConfigSpecArray[j]);\n\n            \r\n            \r\n            \r\n\n            \r\n            ArrayList<OptionValue> extraOptions = new ArrayList<OptionValue>();\n            configBasicExtraOption(extraOptions, vmSpec);\n\n            if (deployAsIs) {\n                setDeployAsIsProperties(vmMo, deployAsIsInfo, vmConfigSpec, hyperHost);\n            }\n\n            configNvpExtraOption(extraOptions, vmSpec, nicUuidToDvSwitchUuid);\n            configCustomExtraOption(extraOptions, vmSpec);\n\n            \r\n            VirtualMachine.Type vmType = cmd.getVirtualMachine().getType();\n            if (vmType.equals(VirtualMachine.Type.NetScalerVm)) {\n                NicTO mgmtNic = vmSpec.getNics()[0];\n                OptionValue option = new OptionValue();\n                option.setKey(\"machine.id\");\n                option.setValue(\"ip=\" + mgmtNic.getIp() + \"&netmask=\" + mgmtNic.getNetmask() + \"&gateway=\" + mgmtNic.getGateway());\n                extraOptions.add(option);\n            }\n\n            configureVNC(vmSpec, extraOptions, vmConfigSpec, hyperHost, vmInternalCSName);\n\n            \r\n            configureVideoCard(vmMo, vmSpec, vmConfigSpec);\n\n            setBootOptions(vmSpec, bootMode, vmConfigSpec);\n\n            if (!StringUtils.isEmpty(vmStoragePolicyId)) {\n                vmConfigSpec.getVmProfile().add(vmProfileSpec);\n                if (s_logger.isTraceEnabled()) {\n                    s_logger.trace(String.format(\"Configuring the VM %s with storage policy: %s\", vmInternalCSName, vmStoragePolicyId));\n                }\n            }\n            \r\n            \r\n            \r\n            if (!vmMo.configureVm(vmConfigSpec)) {\n                throw new Exception(\"Failed to configure VM before start. vmName: \" + vmInternalCSName);\n            }\n\n            if (vmSpec.getType() == VirtualMachine.Type.DomainRouter) {\n                hyperHost.setRestartPriorityForVM(vmMo, DasVmPriority.HIGH.value());\n            }\n\n            \r\n            final Map<String, String> vmDetails = cmd.getVirtualMachine().getDetails();\n            if (!deployAsIs && rootDiskTO != null && !hasSnapshot && (vmDetails != null && vmDetails.containsKey(ApiConstants.ROOT_DISK_SIZE))) {\n                resizeRootDiskOnVMStart(vmMo, rootDiskTO, hyperHost, context);\n            }\n\n            \r\n            \r\n            \r\n\n            vmMo.setCustomFieldValue(CustomFieldConstants.CLOUD_NIC_MASK, String.valueOf(nicMask));\n            postNvpConfigBeforeStart(vmMo, vmSpec);\n\n            Map<String, Map<String, String>> iqnToData = new HashMap<>();\n\n            postDiskConfigBeforeStart(vmMo, vmSpec, sortedDisks, ideControllerKey, scsiControllerKey, iqnToData, hyperHost, context);\n\n            \r\n            \r\n            \r\n            if (!vmMo.powerOn()) {\n                throw new Exception(\"Failed to start VM. vmName: \" + vmInternalCSName + \" with hostname \" + vmNameOnVcenter);\n            }\n\n            StartAnswer startAnswer = new StartAnswer(cmd);\n\n            startAnswer.setIqnToData(iqnToData);\n\n            \r\n            if (existingVmName != null && existingVmFileLayout != null) {\n                List<String> vmDatastoreNames = new ArrayList<String>();\n                for (DatastoreMO vmDatastore : vmMo.getAllDatastores()) {\n                    vmDatastoreNames.add(vmDatastore.getName());\n                }\n                \r\n                List<String> skipDatastores = new ArrayList<String>();\n                for (DatastoreMO existingDatastore : existingDatastores) {\n                    if (vmDatastoreNames.contains(existingDatastore.getName())) {\n                        skipDatastores.add(existingDatastore.getName());\n                    }\n                }\n                deleteUnregisteredVmFiles(existingVmFileLayout, dcMo, true, skipDatastores);\n            }\n\n            return startAnswer;\n        } catch (Throwable e) {\n            if (e instanceof RemoteException) {\n                s_logger.warn(\"Encounter remote exception to vCenter, invalidate VMware session context\");\n                invalidateServiceContext();\n            }\n\n            String msg = \"StartCommand failed due to \" + VmwareHelper.getExceptionMessage(e);\n            s_logger.warn(msg, e);\n            StartAnswer startAnswer = new StartAnswer(cmd, msg);\n            if (vmAlreadyExistsInVcenter) {\n                startAnswer.setContextParam(\"stopRetry\", \"true\");\n            }\n\n            \r\n            if (existingVmName != null && existingVmFileInfo != null) {\n                s_logger.debug(\"Since VM start failed, registering back an existing VM: \" + existingVmName + \" that was unregistered\");\n                try {\n                    DatastoreFile fileInDatastore = new DatastoreFile(existingVmFileInfo.getVmPathName());\n                    DatastoreMO existingVmDsMo = new DatastoreMO(dcMo.getContext(), dcMo.findDatastore(fileInDatastore.getDatastoreName()));\n                    registerVm(existingVmName, existingVmDsMo);\n                } catch (Exception ex) {\n                    String message = \"Failed to register an existing VM: \" + existingVmName + \" due to \" + VmwareHelper.getExceptionMessage(ex);\n                    s_logger.warn(message, ex);\n                }\n            }\n\n            return startAnswer;\n        } finally {\n        }\n    }\n","realPath":"plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/vmware/resource/VmwareResource.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1765,"status":"MB"},{"authorDate":"2021-04-30 00:20:40","commitOrder":13,"curCode":"    private void configureIso(VmwareHypervisorHost hyperHost, VirtualMachineMO vmMo, DiskTO vol,\n                              VirtualDeviceConfigSpec[] deviceConfigSpecArray, int ideUnitNumber, int i) throws Exception {\n        TemplateObjectTO iso = (TemplateObjectTO) vol.getData();\n\n        if (iso.getPath() != null && !iso.getPath().isEmpty()) {\n            DataStoreTO imageStore = iso.getDataStore();\n            if (!(imageStore instanceof NfsTO)) {\n                s_logger.debug(\"unsupported protocol\");\n                throw new Exception(\"unsupported protocol\");\n            }\n            NfsTO nfsImageStore = (NfsTO) imageStore;\n            String isoPath = nfsImageStore.getUrl() + File.separator + iso.getPath();\n            Pair<String, ManagedObjectReference> isoDatastoreInfo = getIsoDatastoreInfo(hyperHost, isoPath);\n            assert (isoDatastoreInfo != null);\n            assert (isoDatastoreInfo.second() != null);\n\n            deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n            Pair<VirtualDevice, Boolean> isoInfo =\n                    VmwareHelper.prepareIsoDevice(vmMo, isoDatastoreInfo.first(), isoDatastoreInfo.second(), true, true, ideUnitNumber, i + 1);\n            deviceConfigSpecArray[i].setDevice(isoInfo.first());\n            if (isoInfo.second()) {\n                if (s_logger.isDebugEnabled())\n                    s_logger.debug(\"Prepare ISO volume at new device \" + _gson.toJson(isoInfo.first()));\n                deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n            } else {\n                if (s_logger.isDebugEnabled())\n                    s_logger.debug(\"Prepare ISO volume at existing device \" + _gson.toJson(isoInfo.first()));\n                deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.EDIT);\n            }\n        }\n    }\n","date":"2021-04-30 00:20:40","endLine":2497,"groupId":"13505","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"configureIso","params":"(VmwareHypervisorHosthyperHost@VirtualMachineMOvmMo@DiskTOvol@VirtualDeviceConfigSpec[]deviceConfigSpecArray@intideUnitNumber@inti)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/20/35cc736ade3abdc2efce433dd904fa383c5f6a.src","preCode":"    private void configureIso(VmwareHypervisorHost hyperHost, VirtualMachineMO vmMo, DiskTO vol,\n                              VirtualDeviceConfigSpec[] deviceConfigSpecArray, int ideUnitNumber, int i) throws Exception {\n        TemplateObjectTO iso = (TemplateObjectTO) vol.getData();\n\n        if (iso.getPath() != null && !iso.getPath().isEmpty()) {\n            DataStoreTO imageStore = iso.getDataStore();\n            if (!(imageStore instanceof NfsTO)) {\n                s_logger.debug(\"unsupported protocol\");\n                throw new Exception(\"unsupported protocol\");\n            }\n            NfsTO nfsImageStore = (NfsTO) imageStore;\n            String isoPath = nfsImageStore.getUrl() + File.separator + iso.getPath();\n            Pair<String, ManagedObjectReference> isoDatastoreInfo = getIsoDatastoreInfo(hyperHost, isoPath);\n            assert (isoDatastoreInfo != null);\n            assert (isoDatastoreInfo.second() != null);\n\n            deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n            Pair<VirtualDevice, Boolean> isoInfo =\n                    VmwareHelper.prepareIsoDevice(vmMo, isoDatastoreInfo.first(), isoDatastoreInfo.second(), true, true, ideUnitNumber, i + 1);\n            deviceConfigSpecArray[i].setDevice(isoInfo.first());\n            if (isoInfo.second()) {\n                if (s_logger.isDebugEnabled())\n                    s_logger.debug(\"Prepare ISO volume at new device \" + _gson.toJson(isoInfo.first()));\n                deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n            } else {\n                if (s_logger.isDebugEnabled())\n                    s_logger.debug(\"Prepare ISO volume at existing device \" + _gson.toJson(isoInfo.first()));\n                deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.EDIT);\n            }\n        }\n    }\n","realPath":"plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/vmware/resource/VmwareResource.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":2467,"status":"B"}],"commitId":"4742ac15f7be5d3cf6f7e328133cb8589a7578ce","commitMessage":"@@@Merge remote-tracking branch 'origin/4.15'\n","date":"2021-04-30 00:20:40","modifiedFileCount":"19","status":"M","submitter":"Rohit Yadav"},{"authorTime":"2021-04-30 00:20:40","codes":[{"authorDate":"2021-05-24 19:13:53","commitOrder":14,"curCode":"    protected StartAnswer execute(StartCommand cmd) {\n        if (s_logger.isInfoEnabled()) {\n            s_logger.info(\"Executing resource StartCommand: \" + getHumanReadableBytesJson(_gson.toJson(cmd)));\n        }\n\n        VirtualMachineTO vmSpec = cmd.getVirtualMachine();\n        boolean vmAlreadyExistsInVcenter = false;\n\n        String existingVmName = null;\n        VirtualMachineFileInfo existingVmFileInfo = null;\n        VirtualMachineFileLayoutEx existingVmFileLayout = null;\n        List<DatastoreMO> existingDatastores = new ArrayList<DatastoreMO>();\n        String diskStoragePolicyId = null;\n        String vmStoragePolicyId = null;\n        VirtualMachineDefinedProfileSpec diskProfileSpec = null;\n        VirtualMachineDefinedProfileSpec vmProfileSpec = null;\n\n\n        DeployAsIsInfoTO deployAsIsInfo = vmSpec.getDeployAsIsInfo();\n        boolean deployAsIs = deployAsIsInfo != null;\n\n        Pair<String, String> names = composeVmNames(vmSpec);\n        String vmInternalCSName = names.first();\n        String vmNameOnVcenter = names.second();\n        DiskTO rootDiskTO = null;\n        String bootMode = getBootModeFromVmSpec(vmSpec, deployAsIs);\n        Pair<String, String> controllerInfo = getControllerInfoFromVmSpec(vmSpec);\n\n        Boolean systemVm = vmSpec.getType().isUsedBySystem();\n        \r\n        VmwareContext context = getServiceContext();\n        DatacenterMO dcMo = null;\n        try {\n            VmwareManager mgr = context.getStockObject(VmwareManager.CONTEXT_STOCK_NAME);\n\n            VmwareHypervisorHost hyperHost = getHyperHost(context);\n            dcMo = new DatacenterMO(hyperHost.getContext(), hyperHost.getHyperHostDatacenter());\n\n            \r\n            VirtualMachineMO vmInVcenter = dcMo.checkIfVmAlreadyExistsInVcenter(vmNameOnVcenter, vmInternalCSName);\n            if (vmInVcenter != null) {\n                vmAlreadyExistsInVcenter = true;\n                String msg = \"VM with name: \" + vmNameOnVcenter + \" already exists in vCenter.\";\n                s_logger.error(msg);\n                throw new Exception(msg);\n            }\n\n            DiskTO[] specDisks = vmSpec.getDisks();\n            String guestOsId = getGuestOsIdFromVmSpec(vmSpec, deployAsIs);\n            DiskTO[] disks = validateDisks(vmSpec.getDisks());\n            assert (disks.length > 0);\n            NicTO[] nics = vmSpec.getNics();\n\n            HashMap<String, Pair<ManagedObjectReference, DatastoreMO>> dataStoresDetails = inferDatastoreDetailsFromDiskInfo(hyperHost, context, disks, cmd);\n            if ((dataStoresDetails == null) || (dataStoresDetails.isEmpty())) {\n                String msg = \"Unable to locate datastore details of the volumes to be attached\";\n                s_logger.error(msg);\n                throw new Exception(msg);\n            }\n\n            VirtualMachineDiskInfoBuilder diskInfoBuilder = null;\n            VirtualDevice[] nicDevices = null;\n            VirtualMachineMO vmMo = hyperHost.findVmOnHyperHost(vmInternalCSName);\n            DiskControllerType systemVmScsiControllerType = DiskControllerType.lsilogic;\n            int firstScsiControllerBusNum = 0;\n            int numScsiControllerForSystemVm = 1;\n            boolean hasSnapshot = false;\n\n            List<Pair<Integer, ManagedObjectReference>> diskDatastores = null;\n            if (vmMo != null) {\n                s_logger.info(\"VM \" + vmInternalCSName + \" already exists, tear down devices for reconfiguration\");\n                if (getVmPowerState(vmMo) != PowerState.PowerOff)\n                    vmMo.safePowerOff(_shutdownWaitMs);\n\n                \r\n                diskDatastores = vmMo.getAllDiskDatastores();\n                diskInfoBuilder = vmMo.getDiskInfoBuilder();\n                hasSnapshot = vmMo.hasSnapshot();\n                nicDevices = vmMo.getNicDevices();\n\n                tearDownVmDevices(vmMo, hasSnapshot, deployAsIs);\n                ensureDiskControllersInternal(vmMo, systemVm, controllerInfo, systemVmScsiControllerType,\n                        numScsiControllerForSystemVm, firstScsiControllerBusNum, deployAsIs);\n            } else {\n                ManagedObjectReference morDc = hyperHost.getHyperHostDatacenter();\n                assert (morDc != null);\n\n                vmMo = hyperHost.findVmOnPeerHyperHost(vmInternalCSName);\n                if (vmMo != null) {\n                    if (s_logger.isInfoEnabled()) {\n                        s_logger.info(\"Found vm \" + vmInternalCSName + \" at other host, relocate to \" + hyperHost.getHyperHostName());\n                    }\n\n                    takeVmFromOtherHyperHost(hyperHost, vmInternalCSName);\n\n                    if (getVmPowerState(vmMo) != PowerState.PowerOff)\n                        vmMo.safePowerOff(_shutdownWaitMs);\n\n                    diskInfoBuilder = vmMo.getDiskInfoBuilder();\n                    hasSnapshot = vmMo.hasSnapshot();\n                    diskDatastores = vmMo.getAllDiskDatastores();\n\n                    tearDownVmDevices(vmMo, hasSnapshot, deployAsIs);\n                    ensureDiskControllersInternal(vmMo, systemVm, controllerInfo, systemVmScsiControllerType,\n                            numScsiControllerForSystemVm, firstScsiControllerBusNum, deployAsIs);\n                } else {\n                    \r\n                    VirtualMachineMO existingVmInDc = dcMo.findVm(vmInternalCSName);\n                    if (existingVmInDc != null) {\n                        s_logger.debug(\"Found VM: \" + vmInternalCSName + \" on a host in a different cluster. Unregistering the exisitng VM.\");\n                        existingVmName = existingVmInDc.getName();\n                        existingVmFileInfo = existingVmInDc.getFileInfo();\n                        existingVmFileLayout = existingVmInDc.getFileLayout();\n                        existingDatastores = existingVmInDc.getAllDatastores();\n                        existingVmInDc.unregisterVm();\n                    }\n\n                    if (deployAsIs) {\n                        vmMo = hyperHost.findVmOnHyperHost(vmInternalCSName);\n                        if (vmMo == null) {\n                            s_logger.info(\"Cloned deploy-as-is VM \" + vmInternalCSName + \" is not in this host, relocating it\");\n                            vmMo = takeVmFromOtherHyperHost(hyperHost, vmInternalCSName);\n                        }\n                    } else {\n                        DiskTO rootDisk = null;\n                        for (DiskTO vol : disks) {\n                            if (vol.getType() == Volume.Type.ROOT) {\n                                rootDisk = vol;\n                            }\n                        }\n                        Pair<ManagedObjectReference, DatastoreMO> rootDiskDataStoreDetails = getDatastoreThatDiskIsOn(dataStoresDetails, rootDisk);\n                        assert (vmSpec.getMinSpeed() != null) && (rootDiskDataStoreDetails != null);\n                        DatastoreMO dsRootVolumeIsOn = rootDiskDataStoreDetails.second();\n                        if (dsRootVolumeIsOn == null) {\n                                String msg = \"Unable to locate datastore details of root volume\";\n                                s_logger.error(msg);\n                                throw new Exception(msg);\n                            }\n                        if (rootDisk.getDetails().get(DiskTO.PROTOCOL_TYPE) != null && rootDisk.getDetails().get(DiskTO.PROTOCOL_TYPE).equalsIgnoreCase(\"DatastoreCluster\")) {\n                            if (diskInfoBuilder != null) {\n                                DatastoreMO diskDatastoreMofromVM = getDataStoreWhereDiskExists(hyperHost, context, diskInfoBuilder, rootDisk, diskDatastores);\n                                if (diskDatastoreMofromVM != null) {\n                                    String actualPoolUuid = diskDatastoreMofromVM.getCustomFieldValue(CustomFieldConstants.CLOUD_UUID);\n                                    if (!actualPoolUuid.equalsIgnoreCase(rootDisk.getData().getDataStore().getUuid())) {\n                                        dsRootVolumeIsOn = diskDatastoreMofromVM;\n                                    }\n                                }\n                            }\n                        }\n\n                        boolean vmFolderExists = dsRootVolumeIsOn.folderExists(String.format(\"[%s]\", dsRootVolumeIsOn.getName()), vmNameOnVcenter);                        String vmxFileFullPath = dsRootVolumeIsOn.searchFileInSubFolders(vmNameOnVcenter + \".vmx\", false, VmwareManager.s_vmwareSearchExcludeFolder.value());\n                        if (vmFolderExists && vmxFileFullPath != null) { \r\n                            registerVm(vmNameOnVcenter, dsRootVolumeIsOn);\n                            vmMo = hyperHost.findVmOnHyperHost(vmInternalCSName);\n                            if (vmMo != null) {\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(\"Found registered vm \" + vmInternalCSName + \" at host \" + hyperHost.getHyperHostName());\n                                }\n                            }\n                            tearDownVm(vmMo);\n                        } else if (!hyperHost.createBlankVm(vmNameOnVcenter, vmInternalCSName, vmSpec.getCpus(), vmSpec.getMaxSpeed().intValue(), getReservedCpuMHZ(vmSpec),\n                                vmSpec.getLimitCpuUse(), (int) (vmSpec.getMaxRam() / ResourceType.bytesToMiB), getReservedMemoryMb(vmSpec), guestOsId, rootDiskDataStoreDetails.first(), false,\n                                controllerInfo, systemVm)) {\n                            throw new Exception(\"Failed to create VM. vmName: \" + vmInternalCSName);\n                        }\n                    }\n                }\n\n                vmMo = hyperHost.findVmOnHyperHost(vmInternalCSName);\n                if (vmMo == null) {\n                    throw new Exception(\"Failed to find the newly create or relocated VM. vmName: \" + vmInternalCSName);\n                }\n            }\n            if (deployAsIs) {\n                s_logger.info(\"Mapping VM disks to spec disks and tearing down datadisks (if any)\");\n                mapSpecDisksToClonedDisksAndTearDownDatadisks(vmMo, vmInternalCSName, specDisks);\n            }\n\n            int disksChanges = getDisksChangesNumberFromDisksSpec(disks, deployAsIs);\n            int totalChangeDevices = disksChanges + nics.length;\n            if (deployAsIsInfo != null && deployAsIsInfo.getProperties() != null) {\n                totalChangeDevices++;\n            }\n\n            DiskTO volIso = null;\n            if (vmSpec.getType() != VirtualMachine.Type.User) {\n                \r\n                totalChangeDevices++;\n            } else {\n                volIso = getIsoDiskTO(disks);\n                if (volIso == null && !deployAsIs) {\n                    totalChangeDevices++;\n                }\n            }\n\n            VirtualMachineConfigSpec vmConfigSpec = new VirtualMachineConfigSpec();\n\n            int i = 0;\n            int ideUnitNumber = !deployAsIs ? 0 : vmMo.getNextIDEDeviceNumber();\n            int scsiUnitNumber = !deployAsIs ? 0 : vmMo.getNextScsiDiskDeviceNumber();\n            int ideControllerKey = vmMo.getIDEDeviceControllerKey();\n            int scsiControllerKey = vmMo.getScsiDeviceControllerKeyNoException();\n            VirtualDeviceConfigSpec[] deviceConfigSpecArray = new VirtualDeviceConfigSpec[totalChangeDevices];\n            DiskTO[] sortedDisks = sortVolumesByDeviceId(disks);\n\n            VmwareHelper.setBasicVmConfig(vmConfigSpec, vmSpec.getCpus(), vmSpec.getMaxSpeed(), getReservedCpuMHZ(vmSpec), (int) (vmSpec.getMaxRam() / (1024 * 1024)),\n                    getReservedMemoryMb(vmSpec), guestOsId, vmSpec.getLimitCpuUse(), deployAsIs);\n\n            \r\n            int numCoresPerSocket = 1;\n            String coresPerSocket = vmSpec.getDetails().get(VmDetailConstants.CPU_CORE_PER_SOCKET);\n            if (coresPerSocket != null) {\n                String apiVersion = HypervisorHostHelper.getVcenterApiVersion(vmMo.getContext());\n                \r\n                if (apiVersion.compareTo(\"5.0\") >= 0) {\n                    numCoresPerSocket = NumbersUtil.parseInt(coresPerSocket, 1);\n                    vmConfigSpec.setNumCoresPerSocket(numCoresPerSocket);\n                }\n            }\n\n            \r\n            vmConfigSpec.setMemoryHotAddEnabled(vmMo.isMemoryHotAddSupported(guestOsId));\n\n            String hostApiVersion = ((HostMO) hyperHost).getHostAboutInfo().getApiVersion();\n            if (numCoresPerSocket > 1 && hostApiVersion.compareTo(\"5.0\") < 0) {\n                s_logger.warn(\"Dynamic scaling of CPU is not supported for Virtual Machines with multi-core vCPUs in case of ESXi hosts 4.1 and prior. Hence CpuHotAdd will not be\"\n                        + \" enabled for Virtual Machine: \" + vmInternalCSName);\n                vmConfigSpec.setCpuHotAddEnabled(false);\n            } else {\n                vmConfigSpec.setCpuHotAddEnabled(vmMo.isCpuHotAddSupported(guestOsId));\n            }\n\n            configNestedHVSupport(vmMo, vmSpec, vmConfigSpec);\n\n            \r\n            \r\n            \r\n\n            \r\n            if (vmSpec.getType() != VirtualMachine.Type.User) {\n                \r\n                Pair<String, Long> secStoreUrlAndId = mgr.getSecondaryStorageStoreUrlAndId(Long.parseLong(_dcId));\n                String secStoreUrl = secStoreUrlAndId.first();\n                Long secStoreId = secStoreUrlAndId.second();\n                if (secStoreUrl == null) {\n                    String msg = \"secondary storage for dc \" + _dcId + \" is not ready yet?\";\n                    throw new Exception(msg);\n                }\n                mgr.prepareSecondaryStorageStore(secStoreUrl, secStoreId);\n\n                ManagedObjectReference morSecDs = prepareSecondaryDatastoreOnHost(secStoreUrl);\n                if (morSecDs == null) {\n                    String msg = \"Failed to prepare secondary storage on host, secondary store url: \" + secStoreUrl;\n                    throw new Exception(msg);\n                }\n                DatastoreMO secDsMo = new DatastoreMO(hyperHost.getContext(), morSecDs);\n\n                deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n                Pair<VirtualDevice, Boolean> isoInfo = VmwareHelper.prepareIsoDevice(vmMo,\n                        String.format(\"[%s] systemvm/%s\", secDsMo.getName(), mgr.getSystemVMIsoFileNameOnDatastore()), secDsMo.getMor(), true, true, ideUnitNumber++, i + 1);\n                deviceConfigSpecArray[i].setDevice(isoInfo.first());\n                if (isoInfo.second()) {\n                    if (s_logger.isDebugEnabled())\n                        s_logger.debug(\"Prepare ISO volume at new device \" + _gson.toJson(isoInfo.first()));\n                    deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n                } else {\n                    if (s_logger.isDebugEnabled())\n                        s_logger.debug(\"Prepare ISO volume at existing device \" + _gson.toJson(isoInfo.first()));\n                    deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.EDIT);\n                }\n                i++;\n            } else if (!deployAsIs) {\n                \r\n                if (volIso != null) {\n                    for (DiskTO vol : disks) {\n                        if (vol.getType() == Volume.Type.ISO) {\n                            configureIso(hyperHost, vmMo, vol, deviceConfigSpecArray, ideUnitNumber++, i);\n                            i++;\n                        }\n                    }\n                } else {\n                    deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n                    Pair<VirtualDevice, Boolean> isoInfo = VmwareHelper.prepareIsoDevice(vmMo, null, null, true, true, ideUnitNumber++, i + 1);\n                    deviceConfigSpecArray[i].setDevice(isoInfo.first());\n                    if (isoInfo.second()) {\n                        if (s_logger.isDebugEnabled())\n                            s_logger.debug(\"Prepare ISO volume at existing device \" + _gson.toJson(isoInfo.first()));\n\n                        deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n                    } else {\n                        if (s_logger.isDebugEnabled())\n                            s_logger.debug(\"Prepare ISO volume at existing device \" + _gson.toJson(isoInfo.first()));\n\n                        deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.EDIT);\n                    }\n                    i++;\n                }\n            }\n\n            int controllerKey;\n\n            \r\n            \r\n            \r\n            if (multipleIsosAtached(sortedDisks) && deployAsIs) {\n                sortedDisks = getDisks(sortedDisks);\n            }\n\n            for (DiskTO vol : sortedDisks) {\n                if (vol.getType() == Volume.Type.ISO) {\n                    if (deployAsIs) {\n                        configureIso(hyperHost, vmMo, vol, deviceConfigSpecArray, ideUnitNumber++, i);\n                        i++;\n                    }\n                    continue;\n                }\n\n                if (deployAsIs && vol.getType() == Volume.Type.ROOT) {\n                    rootDiskTO = vol;\n                    resizeRootDiskOnVMStart(vmMo, rootDiskTO, hyperHost, context);\n                    continue;\n                }\n\n                VirtualMachineDiskInfo matchingExistingDisk = getMatchingExistingDisk(diskInfoBuilder, vol, hyperHost, context);\n                String diskController = getDiskController(vmMo, matchingExistingDisk, vol, controllerInfo, deployAsIs);\n                if (DiskControllerType.getType(diskController) == DiskControllerType.osdefault) {\n                    diskController = vmMo.getRecommendedDiskController(null);\n                }\n                if (DiskControllerType.getType(diskController) == DiskControllerType.ide) {\n                    controllerKey = vmMo.getIDEControllerKey(ideUnitNumber);\n                    if (vol.getType() == Volume.Type.DATADISK) {\n                        \r\n                        \r\n                        if (vmMo.getNumberOfVirtualDisks() > 3) {\n                            throw new CloudRuntimeException(\"Found more than 3 virtual disks attached to this VM [\" + vmMo.getVmName() + \"]. Unable to implement the disks over \"\n                                    + diskController + \" controller, as maximum number of devices supported over IDE controller is 4 includeing CDROM device.\");\n                        }\n                    }\n                } else {\n                    if (VmwareHelper.isReservedScsiDeviceNumber(scsiUnitNumber)) {\n                        scsiUnitNumber++;\n                    }\n\n                    controllerKey = vmMo.getScsiDiskControllerKeyNoException(diskController, scsiUnitNumber);\n                    if (controllerKey == -1) {\n                        \r\n                        \r\n                        Ternary<Integer, Integer, DiskControllerType> vmScsiControllerInfo = vmMo.getScsiControllerInfo();\n                        DiskControllerType existingControllerType = vmScsiControllerInfo.third();\n                        controllerKey = vmMo.getScsiDiskControllerKeyNoException(existingControllerType.toString(), scsiUnitNumber);\n                    }\n                }\n                if (!hasSnapshot) {\n                    deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n\n                    VolumeObjectTO volumeTO = (VolumeObjectTO) vol.getData();\n                    DataStoreTO primaryStore = volumeTO.getDataStore();\n                    Map<String, String> details = vol.getDetails();\n                    boolean managed = false;\n                    String iScsiName = null;\n\n                    if (details != null) {\n                        managed = Boolean.parseBoolean(details.get(DiskTO.MANAGED));\n                        iScsiName = details.get(DiskTO.IQN);\n                    }\n\n                    String primaryStoreUuid = primaryStore.getUuid();\n                    \r\n                    String datastoreName = managed ? VmwareResource.getDatastoreName(iScsiName) : primaryStoreUuid;\n                    Pair<ManagedObjectReference, DatastoreMO> volumeDsDetails = dataStoresDetails.get(datastoreName);\n\n                    assert (volumeDsDetails != null);\n                    if (volumeDsDetails == null) {\n                        throw new Exception(\"Primary datastore \" + primaryStore.getUuid() + \" is not mounted on host.\");\n                    }\n\n                    if (vol.getDetails().get(DiskTO.PROTOCOL_TYPE) != null && vol.getDetails().get(DiskTO.PROTOCOL_TYPE).equalsIgnoreCase(\"DatastoreCluster\")) {\n                        if (diskInfoBuilder != null && matchingExistingDisk != null) {\n                            String[] diskChain = matchingExistingDisk.getDiskChain();\n                            if (diskChain != null && diskChain.length > 0) {\n                                DatastoreFile file = new DatastoreFile(diskChain[0]);\n                                if (!file.getFileBaseName().equalsIgnoreCase(volumeTO.getPath())) {\n                                    if (s_logger.isInfoEnabled())\n                                        s_logger.info(\"Detected disk-chain top file change on volume: \" + volumeTO.getId() + \" \" + volumeTO.getPath() + \" -> \" + file.getFileBaseName());\n                                    volumeTO.setPath(file.getFileBaseName());\n                                }\n                            }\n                            DatastoreMO diskDatastoreMofromVM = getDataStoreWhereDiskExists(hyperHost, context, diskInfoBuilder, vol, diskDatastores);\n                            if (diskDatastoreMofromVM != null) {\n                                String actualPoolUuid = diskDatastoreMofromVM.getCustomFieldValue(CustomFieldConstants.CLOUD_UUID);\n                                if (actualPoolUuid != null && !actualPoolUuid.equalsIgnoreCase(primaryStore.getUuid())) {\n                                    volumeDsDetails = new Pair<>(diskDatastoreMofromVM.getMor(), diskDatastoreMofromVM);\n                                    if (s_logger.isInfoEnabled())\n                                        s_logger.info(\"Detected datastore uuid change on volume: \" + volumeTO.getId() + \" \" + primaryStore.getUuid() + \" -> \" + actualPoolUuid);\n                                    ((PrimaryDataStoreTO)primaryStore).setUuid(actualPoolUuid);\n                                }\n                            }\n                        }\n                    }\n\n                    String[] diskChain = syncDiskChain(dcMo, vmMo, vol, matchingExistingDisk, volumeDsDetails.second());\n\n                    int deviceNumber = -1;\n                    if (controllerKey == vmMo.getIDEControllerKey(ideUnitNumber)) {\n                        deviceNumber = ideUnitNumber % VmwareHelper.MAX_ALLOWED_DEVICES_IDE_CONTROLLER;\n                        ideUnitNumber++;\n                    } else {\n                        deviceNumber = scsiUnitNumber % VmwareHelper.MAX_ALLOWED_DEVICES_SCSI_CONTROLLER;\n                        scsiUnitNumber++;\n                    }\n\n                    VirtualDevice device = VmwareHelper.prepareDiskDevice(vmMo, null, controllerKey, diskChain, volumeDsDetails.first(), deviceNumber, i + 1);\n\n                    diskStoragePolicyId = volumeTO.getvSphereStoragePolicyId();\n                    if (!StringUtils.isEmpty(diskStoragePolicyId)) {\n                        PbmProfileManagerMO profMgrMo = new PbmProfileManagerMO(context);\n                        diskProfileSpec = profMgrMo.getProfileSpec(diskStoragePolicyId);\n                        deviceConfigSpecArray[i].getProfile().add(diskProfileSpec);\n                        if (s_logger.isDebugEnabled()) {\n                            s_logger.debug(String.format(\"Adding vSphere storage profile: %s to virtual disk [%s]\", diskStoragePolicyId, _gson.toJson(device)));\n                        }\n                    }\n                    if (vol.getType() == Volume.Type.ROOT) {\n                        rootDiskTO = vol;\n                        vmStoragePolicyId = diskStoragePolicyId;\n                        vmProfileSpec = diskProfileSpec;\n                    }\n                    deviceConfigSpecArray[i].setDevice(device);\n                    deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n\n                    if (s_logger.isDebugEnabled())\n                        s_logger.debug(\"Prepare volume at new device \" + _gson.toJson(device));\n\n                    i++;\n                } else {\n                    if (controllerKey == vmMo.getIDEControllerKey(ideUnitNumber))\n                        ideUnitNumber++;\n                    else\n                        scsiUnitNumber++;\n                }\n            }\n\n            \r\n            \r\n            \r\n            if (StringUtils.isNotBlank(guestOsId) && guestOsId.startsWith(\"darwin\")) { \r\n                VirtualDevice[] devices = vmMo.getMatchedDevices(new Class<?>[]{VirtualUSBController.class});\n                if (devices.length == 0) {\n                    s_logger.debug(\"No USB Controller device on VM Start. Add USB Controller device for Mac OS VM \" + vmInternalCSName);\n\n                    \r\n                    VirtualDevice usbControllerDevice = VmwareHelper.prepareUSBControllerDevice();\n                    deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n                    deviceConfigSpecArray[i].setDevice(usbControllerDevice);\n                    deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n\n                    if (s_logger.isDebugEnabled())\n                        s_logger.debug(\"Prepare USB controller at new device \" + _gson.toJson(deviceConfigSpecArray[i]));\n\n                    i++;\n                } else {\n                    s_logger.debug(\"USB Controller device exists on VM Start for Mac OS VM \" + vmInternalCSName);\n                }\n            }\n\n            \r\n            \r\n            \r\n            VirtualDevice nic;\n            int nicMask = 0;\n            int nicCount = 0;\n\n            if (vmSpec.getType() == VirtualMachine.Type.DomainRouter) {\n                int extraPublicNics = mgr.getRouterExtraPublicNics();\n                if (extraPublicNics > 0 && vmSpec.getDetails().containsKey(\"PeerRouterInstanceName\")) {\n                    \r\n                    String peerRouterInstanceName = vmSpec.getDetails().get(\"PeerRouterInstanceName\");\n\n                    VirtualMachineMO peerVmMo = hyperHost.findVmOnHyperHost(peerRouterInstanceName);\n                    if (peerVmMo == null) {\n                        peerVmMo = hyperHost.findVmOnPeerHyperHost(peerRouterInstanceName);\n                    }\n\n                    if (peerVmMo != null) {\n                        String oldMacSequence = generateMacSequence(nics);\n\n                        for (int nicIndex = nics.length - extraPublicNics; nicIndex < nics.length; nicIndex++) {\n                            VirtualDevice nicDevice = peerVmMo.getNicDeviceByIndex(nics[nicIndex].getDeviceId());\n                            if (nicDevice != null) {\n                                String mac = ((VirtualEthernetCard) nicDevice).getMacAddress();\n                                if (mac != null) {\n                                    s_logger.info(\"Use same MAC as previous RvR, the MAC is \" + mac + \" for extra NIC with device id: \" + nics[nicIndex].getDeviceId());\n                                    nics[nicIndex].setMac(mac);\n                                }\n                            }\n                        }\n\n                        if (!StringUtils.isBlank(vmSpec.getBootArgs())) {\n                            String newMacSequence = generateMacSequence(nics);\n                            vmSpec.setBootArgs(replaceNicsMacSequenceInBootArgs(oldMacSequence, newMacSequence, vmSpec));\n                        }\n                    }\n                }\n            }\n\n            VirtualEthernetCardType nicDeviceType;\n\n            NiciraNvpApiVersion.logNiciraApiVersion();\n\n            Map<String, String> nicUuidToDvSwitchUuid = new HashMap<String, String>();\n            for (NicTO nicTo : sortNicsByDeviceId(nics)) {\n                s_logger.info(\"Prepare NIC device based on NicTO: \" + _gson.toJson(nicTo));\n\n                String adapterTypeStr = deployAsIs ?\n                        mapAdapterType(deployAsIsInfo.getNicAdapterMap().get(nicTo.getDeviceId())) :\n                        vmSpec.getDetails().get(VmDetailConstants.NIC_ADAPTER);\n                nicDeviceType = VirtualEthernetCardType.valueOf(adapterTypeStr);\n\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"VM \" + vmInternalCSName + \" will be started with NIC device type: \" + nicDeviceType + \" on NIC device \" + nicTo.getDeviceId());\n                }\n                boolean configureVServiceInNexus = (nicTo.getType() == TrafficType.Guest) && (vmSpec.getDetails().containsKey(\"ConfigureVServiceInNexus\"));\n                VirtualMachine.Type vmType = cmd.getVirtualMachine().getType();\n                Pair<ManagedObjectReference, String> networkInfo = prepareNetworkFromNicInfo(vmMo.getRunningHost(), nicTo, configureVServiceInNexus, vmType);\n                if ((nicTo.getBroadcastType() != BroadcastDomainType.Lswitch)\n                        || (nicTo.getBroadcastType() == BroadcastDomainType.Lswitch && NiciraNvpApiVersion.isApiVersionLowerThan(\"4.2\"))) {\n                    if (VmwareHelper.isDvPortGroup(networkInfo.first())) {\n                        String dvSwitchUuid;\n                        ManagedObjectReference dcMor = hyperHost.getHyperHostDatacenter();\n                        DatacenterMO dataCenterMo = new DatacenterMO(context, dcMor);\n                        ManagedObjectReference dvsMor = dataCenterMo.getDvSwitchMor(networkInfo.first());\n                        dvSwitchUuid = dataCenterMo.getDvSwitchUuid(dvsMor);\n                        s_logger.info(\"Preparing NIC device on dvSwitch : \" + dvSwitchUuid);\n                        nic = VmwareHelper.prepareDvNicDevice(vmMo, networkInfo.first(), nicDeviceType, networkInfo.second(), dvSwitchUuid,\n                                nicTo.getMac(), i + 1, true, true);\n                        if (nicTo.getUuid() != null) {\n                            nicUuidToDvSwitchUuid.put(nicTo.getUuid(), dvSwitchUuid);\n                        }\n                    } else {\n                        s_logger.info(\"Preparing NIC device on network \" + networkInfo.second());\n                        nic = VmwareHelper.prepareNicDevice(vmMo, networkInfo.first(), nicDeviceType, networkInfo.second(),\n                                nicTo.getMac(), i + 1, true, true);\n                    }\n                } else {\n                    \r\n                    nic = VmwareHelper.prepareNicOpaque(vmMo, nicDeviceType, networkInfo.second(),\n                            nicTo.getMac(), i + 1, true, true);\n                }\n\n                deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n                deviceConfigSpecArray[i].setDevice(nic);\n                deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n\n                if (s_logger.isDebugEnabled())\n                    s_logger.debug(\"Prepare NIC at new device \" + _gson.toJson(deviceConfigSpecArray[i]));\n\n                \r\n                if (nicCount < 3)\n                    nicMask |= (1 << nicCount);\n\n                i++;\n                nicCount++;\n            }\n\n            for (int j = 0; j < i; j++)\n                vmConfigSpec.getDeviceChange().add(deviceConfigSpecArray[j]);\n\n            \r\n            \r\n            \r\n\n            \r\n            ArrayList<OptionValue> extraOptions = new ArrayList<OptionValue>();\n            configBasicExtraOption(extraOptions, vmSpec);\n\n            if (deployAsIs) {\n                setDeployAsIsProperties(vmMo, deployAsIsInfo, vmConfigSpec, hyperHost);\n            }\n\n            configNvpExtraOption(extraOptions, vmSpec, nicUuidToDvSwitchUuid);\n            configCustomExtraOption(extraOptions, vmSpec);\n\n            \r\n            VirtualMachine.Type vmType = cmd.getVirtualMachine().getType();\n            if (vmType.equals(VirtualMachine.Type.NetScalerVm)) {\n                NicTO mgmtNic = vmSpec.getNics()[0];\n                OptionValue option = new OptionValue();\n                option.setKey(\"machine.id\");\n                option.setValue(\"ip=\" + mgmtNic.getIp() + \"&netmask=\" + mgmtNic.getNetmask() + \"&gateway=\" + mgmtNic.getGateway());\n                extraOptions.add(option);\n            }\n\n            configureVNC(vmSpec, extraOptions, vmConfigSpec, hyperHost, vmInternalCSName);\n\n            \r\n            configureVideoCard(vmMo, vmSpec, vmConfigSpec);\n\n            setBootOptions(vmSpec, bootMode, vmConfigSpec);\n\n            if (!StringUtils.isEmpty(vmStoragePolicyId)) {\n                vmConfigSpec.getVmProfile().add(vmProfileSpec);\n                if (s_logger.isTraceEnabled()) {\n                    s_logger.trace(String.format(\"Configuring the VM %s with storage policy: %s\", vmInternalCSName, vmStoragePolicyId));\n                }\n            }\n            \r\n            \r\n            \r\n            if (!vmMo.configureVm(vmConfigSpec)) {\n                throw new Exception(\"Failed to configure VM before start. vmName: \" + vmInternalCSName);\n            }\n\n            if (vmSpec.getType() == VirtualMachine.Type.DomainRouter) {\n                hyperHost.setRestartPriorityForVM(vmMo, DasVmPriority.HIGH.value());\n            }\n\n            \r\n            final Map<String, String> vmDetails = cmd.getVirtualMachine().getDetails();\n            if (!deployAsIs && rootDiskTO != null && !hasSnapshot && (vmDetails != null && vmDetails.containsKey(ApiConstants.ROOT_DISK_SIZE))) {\n                resizeRootDiskOnVMStart(vmMo, rootDiskTO, hyperHost, context);\n            }\n\n            \r\n            \r\n            \r\n\n            vmMo.setCustomFieldValue(CustomFieldConstants.CLOUD_NIC_MASK, String.valueOf(nicMask));\n            postNvpConfigBeforeStart(vmMo, vmSpec);\n\n            Map<String, Map<String, String>> iqnToData = new HashMap<>();\n\n            postDiskConfigBeforeStart(vmMo, vmSpec, sortedDisks, ideControllerKey, scsiControllerKey, iqnToData, hyperHost, context);\n\n            \r\n            \r\n            \r\n            if (!vmMo.powerOn()) {\n                throw new Exception(\"Failed to start VM. vmName: \" + vmInternalCSName + \" with hostname \" + vmNameOnVcenter);\n            }\n\n            StartAnswer startAnswer = new StartAnswer(cmd);\n\n            startAnswer.setIqnToData(iqnToData);\n\n            \r\n            if (existingVmName != null && existingVmFileLayout != null) {\n                List<String> vmDatastoreNames = new ArrayList<String>();\n                for (DatastoreMO vmDatastore : vmMo.getAllDatastores()) {\n                    vmDatastoreNames.add(vmDatastore.getName());\n                }\n                \r\n                List<String> skipDatastores = new ArrayList<String>();\n                for (DatastoreMO existingDatastore : existingDatastores) {\n                    if (vmDatastoreNames.contains(existingDatastore.getName())) {\n                        skipDatastores.add(existingDatastore.getName());\n                    }\n                }\n                deleteUnregisteredVmFiles(existingVmFileLayout, dcMo, true, skipDatastores);\n            }\n\n            return startAnswer;\n        } catch (Throwable e) {\n            if (e instanceof RemoteException) {\n                s_logger.warn(\"Encounter remote exception to vCenter, invalidate VMware session context\");\n                invalidateServiceContext();\n            }\n\n            String msg = \"StartCommand failed due to \" + VmwareHelper.getExceptionMessage(e);\n            s_logger.warn(msg, e);\n            StartAnswer startAnswer = new StartAnswer(cmd, msg);\n            if (vmAlreadyExistsInVcenter) {\n                startAnswer.setContextParam(\"stopRetry\", \"true\");\n            }\n\n            \r\n            if (existingVmName != null && existingVmFileInfo != null) {\n                s_logger.debug(\"Since VM start failed, registering back an existing VM: \" + existingVmName + \" that was unregistered\");\n                try {\n                    DatastoreFile fileInDatastore = new DatastoreFile(existingVmFileInfo.getVmPathName());\n                    DatastoreMO existingVmDsMo = new DatastoreMO(dcMo.getContext(), dcMo.findDatastore(fileInDatastore.getDatastoreName()));\n                    registerVm(existingVmName, existingVmDsMo);\n                } catch (Exception ex) {\n                    String message = \"Failed to register an existing VM: \" + existingVmName + \" due to \" + VmwareHelper.getExceptionMessage(ex);\n                    s_logger.warn(message, ex);\n                }\n            }\n\n            return startAnswer;\n        } finally {\n        }\n    }\n","date":"2021-05-24 19:13:53","endLine":2455,"groupId":"6083","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"execute","params":"(StartCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/38/79e69018a16623e710f7954029045b3cecd925.src","preCode":"    protected StartAnswer execute(StartCommand cmd) {\n        if (s_logger.isInfoEnabled()) {\n            s_logger.info(\"Executing resource StartCommand: \" + getHumanReadableBytesJson(_gson.toJson(cmd)));\n        }\n\n        VirtualMachineTO vmSpec = cmd.getVirtualMachine();\n        boolean vmAlreadyExistsInVcenter = false;\n\n        String existingVmName = null;\n        VirtualMachineFileInfo existingVmFileInfo = null;\n        VirtualMachineFileLayoutEx existingVmFileLayout = null;\n        List<DatastoreMO> existingDatastores = new ArrayList<DatastoreMO>();\n        String diskStoragePolicyId = null;\n        String vmStoragePolicyId = null;\n        VirtualMachineDefinedProfileSpec diskProfileSpec = null;\n        VirtualMachineDefinedProfileSpec vmProfileSpec = null;\n\n\n        DeployAsIsInfoTO deployAsIsInfo = vmSpec.getDeployAsIsInfo();\n        boolean deployAsIs = deployAsIsInfo != null;\n\n        Pair<String, String> names = composeVmNames(vmSpec);\n        String vmInternalCSName = names.first();\n        String vmNameOnVcenter = names.second();\n        DiskTO rootDiskTO = null;\n        String bootMode = getBootModeFromVmSpec(vmSpec, deployAsIs);\n        Pair<String, String> controllerInfo = getControllerInfoFromVmSpec(vmSpec);\n\n        Boolean systemVm = vmSpec.getType().isUsedBySystem();\n        \r\n        VmwareContext context = getServiceContext();\n        DatacenterMO dcMo = null;\n        try {\n            VmwareManager mgr = context.getStockObject(VmwareManager.CONTEXT_STOCK_NAME);\n\n            VmwareHypervisorHost hyperHost = getHyperHost(context);\n            dcMo = new DatacenterMO(hyperHost.getContext(), hyperHost.getHyperHostDatacenter());\n\n            \r\n            VirtualMachineMO vmInVcenter = dcMo.checkIfVmAlreadyExistsInVcenter(vmNameOnVcenter, vmInternalCSName);\n            if (vmInVcenter != null) {\n                vmAlreadyExistsInVcenter = true;\n                String msg = \"VM with name: \" + vmNameOnVcenter + \" already exists in vCenter.\";\n                s_logger.error(msg);\n                throw new Exception(msg);\n            }\n\n            DiskTO[] specDisks = vmSpec.getDisks();\n            String guestOsId = getGuestOsIdFromVmSpec(vmSpec, deployAsIs);\n            DiskTO[] disks = validateDisks(vmSpec.getDisks());\n            assert (disks.length > 0);\n            NicTO[] nics = vmSpec.getNics();\n\n            HashMap<String, Pair<ManagedObjectReference, DatastoreMO>> dataStoresDetails = inferDatastoreDetailsFromDiskInfo(hyperHost, context, disks, cmd);\n            if ((dataStoresDetails == null) || (dataStoresDetails.isEmpty())) {\n                String msg = \"Unable to locate datastore details of the volumes to be attached\";\n                s_logger.error(msg);\n                throw new Exception(msg);\n            }\n\n            VirtualMachineDiskInfoBuilder diskInfoBuilder = null;\n            VirtualDevice[] nicDevices = null;\n            VirtualMachineMO vmMo = hyperHost.findVmOnHyperHost(vmInternalCSName);\n            DiskControllerType systemVmScsiControllerType = DiskControllerType.lsilogic;\n            int firstScsiControllerBusNum = 0;\n            int numScsiControllerForSystemVm = 1;\n            boolean hasSnapshot = false;\n\n            List<Pair<Integer, ManagedObjectReference>> diskDatastores = null;\n            if (vmMo != null) {\n                s_logger.info(\"VM \" + vmInternalCSName + \" already exists, tear down devices for reconfiguration\");\n                if (getVmPowerState(vmMo) != PowerState.PowerOff)\n                    vmMo.safePowerOff(_shutdownWaitMs);\n\n                \r\n                diskDatastores = vmMo.getAllDiskDatastores();\n                diskInfoBuilder = vmMo.getDiskInfoBuilder();\n                hasSnapshot = vmMo.hasSnapshot();\n                nicDevices = vmMo.getNicDevices();\n\n                tearDownVmDevices(vmMo, hasSnapshot, deployAsIs);\n                ensureDiskControllersInternal(vmMo, systemVm, controllerInfo, systemVmScsiControllerType,\n                        numScsiControllerForSystemVm, firstScsiControllerBusNum, deployAsIs);\n            } else {\n                ManagedObjectReference morDc = hyperHost.getHyperHostDatacenter();\n                assert (morDc != null);\n\n                vmMo = hyperHost.findVmOnPeerHyperHost(vmInternalCSName);\n                if (vmMo != null) {\n                    if (s_logger.isInfoEnabled()) {\n                        s_logger.info(\"Found vm \" + vmInternalCSName + \" at other host, relocate to \" + hyperHost.getHyperHostName());\n                    }\n\n                    takeVmFromOtherHyperHost(hyperHost, vmInternalCSName);\n\n                    if (getVmPowerState(vmMo) != PowerState.PowerOff)\n                        vmMo.safePowerOff(_shutdownWaitMs);\n\n                    diskInfoBuilder = vmMo.getDiskInfoBuilder();\n                    hasSnapshot = vmMo.hasSnapshot();\n                    diskDatastores = vmMo.getAllDiskDatastores();\n\n                    tearDownVmDevices(vmMo, hasSnapshot, deployAsIs);\n                    ensureDiskControllersInternal(vmMo, systemVm, controllerInfo, systemVmScsiControllerType,\n                            numScsiControllerForSystemVm, firstScsiControllerBusNum, deployAsIs);\n                } else {\n                    \r\n                    VirtualMachineMO existingVmInDc = dcMo.findVm(vmInternalCSName);\n                    if (existingVmInDc != null) {\n                        s_logger.debug(\"Found VM: \" + vmInternalCSName + \" on a host in a different cluster. Unregistering the exisitng VM.\");\n                        existingVmName = existingVmInDc.getName();\n                        existingVmFileInfo = existingVmInDc.getFileInfo();\n                        existingVmFileLayout = existingVmInDc.getFileLayout();\n                        existingDatastores = existingVmInDc.getAllDatastores();\n                        existingVmInDc.unregisterVm();\n                    }\n\n                    if (deployAsIs) {\n                        vmMo = hyperHost.findVmOnHyperHost(vmInternalCSName);\n                        if (vmMo == null) {\n                            s_logger.info(\"Cloned deploy-as-is VM \" + vmInternalCSName + \" is not in this host, relocating it\");\n                            vmMo = takeVmFromOtherHyperHost(hyperHost, vmInternalCSName);\n                        }\n                    } else {\n                        DiskTO rootDisk = null;\n                        for (DiskTO vol : disks) {\n                            if (vol.getType() == Volume.Type.ROOT) {\n                                rootDisk = vol;\n                            }\n                        }\n                        Pair<ManagedObjectReference, DatastoreMO> rootDiskDataStoreDetails = getDatastoreThatDiskIsOn(dataStoresDetails, rootDisk);\n                        assert (vmSpec.getMinSpeed() != null) && (rootDiskDataStoreDetails != null);\n                        DatastoreMO dsRootVolumeIsOn = rootDiskDataStoreDetails.second();\n                        if (dsRootVolumeIsOn == null) {\n                                String msg = \"Unable to locate datastore details of root volume\";\n                                s_logger.error(msg);\n                                throw new Exception(msg);\n                            }\n                        if (rootDisk.getDetails().get(DiskTO.PROTOCOL_TYPE) != null && rootDisk.getDetails().get(DiskTO.PROTOCOL_TYPE).equalsIgnoreCase(\"DatastoreCluster\")) {\n                            if (diskInfoBuilder != null) {\n                                DatastoreMO diskDatastoreMofromVM = getDataStoreWhereDiskExists(hyperHost, context, diskInfoBuilder, rootDisk, diskDatastores);\n                                if (diskDatastoreMofromVM != null) {\n                                    String actualPoolUuid = diskDatastoreMofromVM.getCustomFieldValue(CustomFieldConstants.CLOUD_UUID);\n                                    if (!actualPoolUuid.equalsIgnoreCase(rootDisk.getData().getDataStore().getUuid())) {\n                                        dsRootVolumeIsOn = diskDatastoreMofromVM;\n                                    }\n                                }\n                            }\n                        }\n\n                        boolean vmFolderExists = dsRootVolumeIsOn.folderExists(String.format(\"[%s]\", dsRootVolumeIsOn.getName()), vmNameOnVcenter);                        String vmxFileFullPath = dsRootVolumeIsOn.searchFileInSubFolders(vmNameOnVcenter + \".vmx\", false, VmwareManager.s_vmwareSearchExcludeFolder.value());\n                        if (vmFolderExists && vmxFileFullPath != null) { \r\n                            registerVm(vmNameOnVcenter, dsRootVolumeIsOn);\n                            vmMo = hyperHost.findVmOnHyperHost(vmInternalCSName);\n                            if (vmMo != null) {\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(\"Found registered vm \" + vmInternalCSName + \" at host \" + hyperHost.getHyperHostName());\n                                }\n                            }\n                            tearDownVm(vmMo);\n                        } else if (!hyperHost.createBlankVm(vmNameOnVcenter, vmInternalCSName, vmSpec.getCpus(), vmSpec.getMaxSpeed().intValue(), getReservedCpuMHZ(vmSpec),\n                                vmSpec.getLimitCpuUse(), (int) (vmSpec.getMaxRam() / ResourceType.bytesToMiB), getReservedMemoryMb(vmSpec), guestOsId, rootDiskDataStoreDetails.first(), false,\n                                controllerInfo, systemVm)) {\n                            throw new Exception(\"Failed to create VM. vmName: \" + vmInternalCSName);\n                        }\n                    }\n                }\n\n                vmMo = hyperHost.findVmOnHyperHost(vmInternalCSName);\n                if (vmMo == null) {\n                    throw new Exception(\"Failed to find the newly create or relocated VM. vmName: \" + vmInternalCSName);\n                }\n            }\n            if (deployAsIs) {\n                s_logger.info(\"Mapping VM disks to spec disks and tearing down datadisks (if any)\");\n                mapSpecDisksToClonedDisksAndTearDownDatadisks(vmMo, vmInternalCSName, specDisks);\n            }\n\n            int disksChanges = getDisksChangesNumberFromDisksSpec(disks, deployAsIs);\n            int totalChangeDevices = disksChanges + nics.length;\n            if (deployAsIsInfo != null && deployAsIsInfo.getProperties() != null) {\n                totalChangeDevices++;\n            }\n\n            DiskTO volIso = null;\n            if (vmSpec.getType() != VirtualMachine.Type.User) {\n                \r\n                totalChangeDevices++;\n            } else {\n                volIso = getIsoDiskTO(disks);\n                if (volIso == null && !deployAsIs) {\n                    totalChangeDevices++;\n                }\n            }\n\n            VirtualMachineConfigSpec vmConfigSpec = new VirtualMachineConfigSpec();\n\n            int i = 0;\n            int ideUnitNumber = !deployAsIs ? 0 : vmMo.getNextIDEDeviceNumber();\n            int scsiUnitNumber = !deployAsIs ? 0 : vmMo.getNextScsiDiskDeviceNumber();\n            int ideControllerKey = vmMo.getIDEDeviceControllerKey();\n            int scsiControllerKey = vmMo.getScsiDeviceControllerKeyNoException();\n            VirtualDeviceConfigSpec[] deviceConfigSpecArray = new VirtualDeviceConfigSpec[totalChangeDevices];\n            DiskTO[] sortedDisks = sortVolumesByDeviceId(disks);\n\n            VmwareHelper.setBasicVmConfig(vmConfigSpec, vmSpec.getCpus(), vmSpec.getMaxSpeed(), getReservedCpuMHZ(vmSpec), (int) (vmSpec.getMaxRam() / (1024 * 1024)),\n                    getReservedMemoryMb(vmSpec), guestOsId, vmSpec.getLimitCpuUse(), deployAsIs);\n\n            \r\n            int numCoresPerSocket = 1;\n            String coresPerSocket = vmSpec.getDetails().get(VmDetailConstants.CPU_CORE_PER_SOCKET);\n            if (coresPerSocket != null) {\n                String apiVersion = HypervisorHostHelper.getVcenterApiVersion(vmMo.getContext());\n                \r\n                if (apiVersion.compareTo(\"5.0\") >= 0) {\n                    numCoresPerSocket = NumbersUtil.parseInt(coresPerSocket, 1);\n                    vmConfigSpec.setNumCoresPerSocket(numCoresPerSocket);\n                }\n            }\n\n            \r\n            vmConfigSpec.setMemoryHotAddEnabled(vmMo.isMemoryHotAddSupported(guestOsId));\n\n            String hostApiVersion = ((HostMO) hyperHost).getHostAboutInfo().getApiVersion();\n            if (numCoresPerSocket > 1 && hostApiVersion.compareTo(\"5.0\") < 0) {\n                s_logger.warn(\"Dynamic scaling of CPU is not supported for Virtual Machines with multi-core vCPUs in case of ESXi hosts 4.1 and prior. Hence CpuHotAdd will not be\"\n                        + \" enabled for Virtual Machine: \" + vmInternalCSName);\n                vmConfigSpec.setCpuHotAddEnabled(false);\n            } else {\n                vmConfigSpec.setCpuHotAddEnabled(vmMo.isCpuHotAddSupported(guestOsId));\n            }\n\n            configNestedHVSupport(vmMo, vmSpec, vmConfigSpec);\n\n            \r\n            \r\n            \r\n\n            \r\n            if (vmSpec.getType() != VirtualMachine.Type.User) {\n                \r\n                Pair<String, Long> secStoreUrlAndId = mgr.getSecondaryStorageStoreUrlAndId(Long.parseLong(_dcId));\n                String secStoreUrl = secStoreUrlAndId.first();\n                Long secStoreId = secStoreUrlAndId.second();\n                if (secStoreUrl == null) {\n                    String msg = \"secondary storage for dc \" + _dcId + \" is not ready yet?\";\n                    throw new Exception(msg);\n                }\n                mgr.prepareSecondaryStorageStore(secStoreUrl, secStoreId);\n\n                ManagedObjectReference morSecDs = prepareSecondaryDatastoreOnHost(secStoreUrl);\n                if (morSecDs == null) {\n                    String msg = \"Failed to prepare secondary storage on host, secondary store url: \" + secStoreUrl;\n                    throw new Exception(msg);\n                }\n                DatastoreMO secDsMo = new DatastoreMO(hyperHost.getContext(), morSecDs);\n\n                deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n                Pair<VirtualDevice, Boolean> isoInfo = VmwareHelper.prepareIsoDevice(vmMo,\n                        String.format(\"[%s] systemvm/%s\", secDsMo.getName(), mgr.getSystemVMIsoFileNameOnDatastore()), secDsMo.getMor(), true, true, ideUnitNumber++, i + 1);\n                deviceConfigSpecArray[i].setDevice(isoInfo.first());\n                if (isoInfo.second()) {\n                    if (s_logger.isDebugEnabled())\n                        s_logger.debug(\"Prepare ISO volume at new device \" + _gson.toJson(isoInfo.first()));\n                    deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n                } else {\n                    if (s_logger.isDebugEnabled())\n                        s_logger.debug(\"Prepare ISO volume at existing device \" + _gson.toJson(isoInfo.first()));\n                    deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.EDIT);\n                }\n                i++;\n            } else if (!deployAsIs) {\n                \r\n                if (volIso != null) {\n                    for (DiskTO vol : disks) {\n                        if (vol.getType() == Volume.Type.ISO) {\n                            configureIso(hyperHost, vmMo, vol, deviceConfigSpecArray, ideUnitNumber++, i);\n                            i++;\n                        }\n                    }\n                } else {\n                    deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n                    Pair<VirtualDevice, Boolean> isoInfo = VmwareHelper.prepareIsoDevice(vmMo, null, null, true, true, ideUnitNumber++, i + 1);\n                    deviceConfigSpecArray[i].setDevice(isoInfo.first());\n                    if (isoInfo.second()) {\n                        if (s_logger.isDebugEnabled())\n                            s_logger.debug(\"Prepare ISO volume at existing device \" + _gson.toJson(isoInfo.first()));\n\n                        deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n                    } else {\n                        if (s_logger.isDebugEnabled())\n                            s_logger.debug(\"Prepare ISO volume at existing device \" + _gson.toJson(isoInfo.first()));\n\n                        deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.EDIT);\n                    }\n                    i++;\n                }\n            }\n\n            int controllerKey;\n\n            \r\n            \r\n            \r\n            if (multipleIsosAtached(sortedDisks) && deployAsIs) {\n                sortedDisks = getDisks(sortedDisks);\n            }\n\n            for (DiskTO vol : sortedDisks) {\n                if (vol.getType() == Volume.Type.ISO) {\n                    if (deployAsIs) {\n                        configureIso(hyperHost, vmMo, vol, deviceConfigSpecArray, ideUnitNumber++, i);\n                        i++;\n                    }\n                    continue;\n                }\n\n                if (deployAsIs && vol.getType() == Volume.Type.ROOT) {\n                    rootDiskTO = vol;\n                    resizeRootDiskOnVMStart(vmMo, rootDiskTO, hyperHost, context);\n                    continue;\n                }\n\n                VirtualMachineDiskInfo matchingExistingDisk = getMatchingExistingDisk(diskInfoBuilder, vol, hyperHost, context);\n                controllerKey = getDiskController(matchingExistingDisk, vol, vmSpec, ideControllerKey, scsiControllerKey);\n                String diskController = getDiskController(vmMo, matchingExistingDisk, vol, controllerInfo);\n\n                if (DiskControllerType.getType(diskController) == DiskControllerType.osdefault) {\n                    diskController = vmMo.getRecommendedDiskController(null);\n                }\n                if (DiskControllerType.getType(diskController) == DiskControllerType.ide) {\n                    controllerKey = vmMo.getIDEControllerKey(ideUnitNumber);\n                    if (vol.getType() == Volume.Type.DATADISK) {\n                        \r\n                        \r\n                        if (vmMo.getNumberOfVirtualDisks() > 3) {\n                            throw new CloudRuntimeException(\"Found more than 3 virtual disks attached to this VM [\" + vmMo.getVmName() + \"]. Unable to implement the disks over \"\n                                    + diskController + \" controller, as maximum number of devices supported over IDE controller is 4 includeing CDROM device.\");\n                        }\n                    }\n                } else {\n                    if (VmwareHelper.isReservedScsiDeviceNumber(scsiUnitNumber)) {\n                        scsiUnitNumber++;\n                    }\n\n                    controllerKey = vmMo.getScsiDiskControllerKeyNoException(diskController, scsiUnitNumber);\n                    if (controllerKey == -1) {\n                        \r\n                        \r\n                        Ternary<Integer, Integer, DiskControllerType> vmScsiControllerInfo = vmMo.getScsiControllerInfo();\n                        DiskControllerType existingControllerType = vmScsiControllerInfo.third();\n                        controllerKey = vmMo.getScsiDiskControllerKeyNoException(existingControllerType.toString(), scsiUnitNumber);\n                    }\n                }\n                if (!hasSnapshot) {\n                    deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n\n                    VolumeObjectTO volumeTO = (VolumeObjectTO) vol.getData();\n                    DataStoreTO primaryStore = volumeTO.getDataStore();\n                    Map<String, String> details = vol.getDetails();\n                    boolean managed = false;\n                    String iScsiName = null;\n\n                    if (details != null) {\n                        managed = Boolean.parseBoolean(details.get(DiskTO.MANAGED));\n                        iScsiName = details.get(DiskTO.IQN);\n                    }\n\n                    String primaryStoreUuid = primaryStore.getUuid();\n                    \r\n                    String datastoreName = managed ? VmwareResource.getDatastoreName(iScsiName) : primaryStoreUuid;\n                    Pair<ManagedObjectReference, DatastoreMO> volumeDsDetails = dataStoresDetails.get(datastoreName);\n\n                    assert (volumeDsDetails != null);\n                    if (volumeDsDetails == null) {\n                        throw new Exception(\"Primary datastore \" + primaryStore.getUuid() + \" is not mounted on host.\");\n                    }\n\n                    if (vol.getDetails().get(DiskTO.PROTOCOL_TYPE) != null && vol.getDetails().get(DiskTO.PROTOCOL_TYPE).equalsIgnoreCase(\"DatastoreCluster\")) {\n                        if (diskInfoBuilder != null && matchingExistingDisk != null) {\n                            String[] diskChain = matchingExistingDisk.getDiskChain();\n                            if (diskChain != null && diskChain.length > 0) {\n                                DatastoreFile file = new DatastoreFile(diskChain[0]);\n                                if (!file.getFileBaseName().equalsIgnoreCase(volumeTO.getPath())) {\n                                    if (s_logger.isInfoEnabled())\n                                        s_logger.info(\"Detected disk-chain top file change on volume: \" + volumeTO.getId() + \" \" + volumeTO.getPath() + \" -> \" + file.getFileBaseName());\n                                    volumeTO.setPath(file.getFileBaseName());\n                                }\n                            }\n                            DatastoreMO diskDatastoreMofromVM = getDataStoreWhereDiskExists(hyperHost, context, diskInfoBuilder, vol, diskDatastores);\n                            if (diskDatastoreMofromVM != null) {\n                                String actualPoolUuid = diskDatastoreMofromVM.getCustomFieldValue(CustomFieldConstants.CLOUD_UUID);\n                                if (actualPoolUuid != null && !actualPoolUuid.equalsIgnoreCase(primaryStore.getUuid())) {\n                                    volumeDsDetails = new Pair<>(diskDatastoreMofromVM.getMor(), diskDatastoreMofromVM);\n                                    if (s_logger.isInfoEnabled())\n                                        s_logger.info(\"Detected datastore uuid change on volume: \" + volumeTO.getId() + \" \" + primaryStore.getUuid() + \" -> \" + actualPoolUuid);\n                                    ((PrimaryDataStoreTO)primaryStore).setUuid(actualPoolUuid);\n                                }\n                            }\n                        }\n                    }\n\n                    String[] diskChain = syncDiskChain(dcMo, vmMo, vol, matchingExistingDisk, volumeDsDetails.second());\n\n                    int deviceNumber = -1;\n                    if (controllerKey == vmMo.getIDEControllerKey(ideUnitNumber)) {\n                        deviceNumber = ideUnitNumber % VmwareHelper.MAX_ALLOWED_DEVICES_IDE_CONTROLLER;\n                        ideUnitNumber++;\n                    } else {\n                        deviceNumber = scsiUnitNumber % VmwareHelper.MAX_ALLOWED_DEVICES_SCSI_CONTROLLER;\n                        scsiUnitNumber++;\n                    }\n\n                    VirtualDevice device = VmwareHelper.prepareDiskDevice(vmMo, null, controllerKey, diskChain, volumeDsDetails.first(), deviceNumber, i + 1);\n\n                    diskStoragePolicyId = volumeTO.getvSphereStoragePolicyId();\n                    if (!StringUtils.isEmpty(diskStoragePolicyId)) {\n                        PbmProfileManagerMO profMgrMo = new PbmProfileManagerMO(context);\n                        diskProfileSpec = profMgrMo.getProfileSpec(diskStoragePolicyId);\n                        deviceConfigSpecArray[i].getProfile().add(diskProfileSpec);\n                        if (s_logger.isDebugEnabled()) {\n                            s_logger.debug(String.format(\"Adding vSphere storage profile: %s to virtual disk [%s]\", diskStoragePolicyId, _gson.toJson(device)));\n                        }\n                    }\n                    if (vol.getType() == Volume.Type.ROOT) {\n                        rootDiskTO = vol;\n                        vmStoragePolicyId = diskStoragePolicyId;\n                        vmProfileSpec = diskProfileSpec;\n                    }\n                    deviceConfigSpecArray[i].setDevice(device);\n                    deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n\n                    if (s_logger.isDebugEnabled())\n                        s_logger.debug(\"Prepare volume at new device \" + _gson.toJson(device));\n\n                    i++;\n                } else {\n                    if (controllerKey == vmMo.getIDEControllerKey(ideUnitNumber))\n                        ideUnitNumber++;\n                    else\n                        scsiUnitNumber++;\n                }\n            }\n\n            \r\n            \r\n            \r\n            if (StringUtils.isNotBlank(guestOsId) && guestOsId.startsWith(\"darwin\")) { \r\n                VirtualDevice[] devices = vmMo.getMatchedDevices(new Class<?>[]{VirtualUSBController.class});\n                if (devices.length == 0) {\n                    s_logger.debug(\"No USB Controller device on VM Start. Add USB Controller device for Mac OS VM \" + vmInternalCSName);\n\n                    \r\n                    VirtualDevice usbControllerDevice = VmwareHelper.prepareUSBControllerDevice();\n                    deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n                    deviceConfigSpecArray[i].setDevice(usbControllerDevice);\n                    deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n\n                    if (s_logger.isDebugEnabled())\n                        s_logger.debug(\"Prepare USB controller at new device \" + _gson.toJson(deviceConfigSpecArray[i]));\n\n                    i++;\n                } else {\n                    s_logger.debug(\"USB Controller device exists on VM Start for Mac OS VM \" + vmInternalCSName);\n                }\n            }\n\n            \r\n            \r\n            \r\n            VirtualDevice nic;\n            int nicMask = 0;\n            int nicCount = 0;\n\n            if (vmSpec.getType() == VirtualMachine.Type.DomainRouter) {\n                int extraPublicNics = mgr.getRouterExtraPublicNics();\n                if (extraPublicNics > 0 && vmSpec.getDetails().containsKey(\"PeerRouterInstanceName\")) {\n                    \r\n                    String peerRouterInstanceName = vmSpec.getDetails().get(\"PeerRouterInstanceName\");\n\n                    VirtualMachineMO peerVmMo = hyperHost.findVmOnHyperHost(peerRouterInstanceName);\n                    if (peerVmMo == null) {\n                        peerVmMo = hyperHost.findVmOnPeerHyperHost(peerRouterInstanceName);\n                    }\n\n                    if (peerVmMo != null) {\n                        String oldMacSequence = generateMacSequence(nics);\n\n                        for (int nicIndex = nics.length - extraPublicNics; nicIndex < nics.length; nicIndex++) {\n                            VirtualDevice nicDevice = peerVmMo.getNicDeviceByIndex(nics[nicIndex].getDeviceId());\n                            if (nicDevice != null) {\n                                String mac = ((VirtualEthernetCard) nicDevice).getMacAddress();\n                                if (mac != null) {\n                                    s_logger.info(\"Use same MAC as previous RvR, the MAC is \" + mac + \" for extra NIC with device id: \" + nics[nicIndex].getDeviceId());\n                                    nics[nicIndex].setMac(mac);\n                                }\n                            }\n                        }\n\n                        if (!StringUtils.isBlank(vmSpec.getBootArgs())) {\n                            String newMacSequence = generateMacSequence(nics);\n                            vmSpec.setBootArgs(replaceNicsMacSequenceInBootArgs(oldMacSequence, newMacSequence, vmSpec));\n                        }\n                    }\n                }\n            }\n\n            VirtualEthernetCardType nicDeviceType;\n\n            NiciraNvpApiVersion.logNiciraApiVersion();\n\n            Map<String, String> nicUuidToDvSwitchUuid = new HashMap<String, String>();\n            for (NicTO nicTo : sortNicsByDeviceId(nics)) {\n                s_logger.info(\"Prepare NIC device based on NicTO: \" + _gson.toJson(nicTo));\n\n                String adapterTypeStr = deployAsIs ?\n                        mapAdapterType(deployAsIsInfo.getNicAdapterMap().get(nicTo.getDeviceId())) :\n                        vmSpec.getDetails().get(VmDetailConstants.NIC_ADAPTER);\n                nicDeviceType = VirtualEthernetCardType.valueOf(adapterTypeStr);\n\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"VM \" + vmInternalCSName + \" will be started with NIC device type: \" + nicDeviceType + \" on NIC device \" + nicTo.getDeviceId());\n                }\n                boolean configureVServiceInNexus = (nicTo.getType() == TrafficType.Guest) && (vmSpec.getDetails().containsKey(\"ConfigureVServiceInNexus\"));\n                VirtualMachine.Type vmType = cmd.getVirtualMachine().getType();\n                Pair<ManagedObjectReference, String> networkInfo = prepareNetworkFromNicInfo(vmMo.getRunningHost(), nicTo, configureVServiceInNexus, vmType);\n                if ((nicTo.getBroadcastType() != BroadcastDomainType.Lswitch)\n                        || (nicTo.getBroadcastType() == BroadcastDomainType.Lswitch && NiciraNvpApiVersion.isApiVersionLowerThan(\"4.2\"))) {\n                    if (VmwareHelper.isDvPortGroup(networkInfo.first())) {\n                        String dvSwitchUuid;\n                        ManagedObjectReference dcMor = hyperHost.getHyperHostDatacenter();\n                        DatacenterMO dataCenterMo = new DatacenterMO(context, dcMor);\n                        ManagedObjectReference dvsMor = dataCenterMo.getDvSwitchMor(networkInfo.first());\n                        dvSwitchUuid = dataCenterMo.getDvSwitchUuid(dvsMor);\n                        s_logger.info(\"Preparing NIC device on dvSwitch : \" + dvSwitchUuid);\n                        nic = VmwareHelper.prepareDvNicDevice(vmMo, networkInfo.first(), nicDeviceType, networkInfo.second(), dvSwitchUuid,\n                                nicTo.getMac(), i + 1, true, true);\n                        if (nicTo.getUuid() != null) {\n                            nicUuidToDvSwitchUuid.put(nicTo.getUuid(), dvSwitchUuid);\n                        }\n                    } else {\n                        s_logger.info(\"Preparing NIC device on network \" + networkInfo.second());\n                        nic = VmwareHelper.prepareNicDevice(vmMo, networkInfo.first(), nicDeviceType, networkInfo.second(),\n                                nicTo.getMac(), i + 1, true, true);\n                    }\n                } else {\n                    \r\n                    nic = VmwareHelper.prepareNicOpaque(vmMo, nicDeviceType, networkInfo.second(),\n                            nicTo.getMac(), i + 1, true, true);\n                }\n\n                deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n                deviceConfigSpecArray[i].setDevice(nic);\n                deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n\n                if (s_logger.isDebugEnabled())\n                    s_logger.debug(\"Prepare NIC at new device \" + _gson.toJson(deviceConfigSpecArray[i]));\n\n                \r\n                if (nicCount < 3)\n                    nicMask |= (1 << nicCount);\n\n                i++;\n                nicCount++;\n            }\n\n            for (int j = 0; j < i; j++)\n                vmConfigSpec.getDeviceChange().add(deviceConfigSpecArray[j]);\n\n            \r\n            \r\n            \r\n\n            \r\n            ArrayList<OptionValue> extraOptions = new ArrayList<OptionValue>();\n            configBasicExtraOption(extraOptions, vmSpec);\n\n            if (deployAsIs) {\n                setDeployAsIsProperties(vmMo, deployAsIsInfo, vmConfigSpec, hyperHost);\n            }\n\n            configNvpExtraOption(extraOptions, vmSpec, nicUuidToDvSwitchUuid);\n            configCustomExtraOption(extraOptions, vmSpec);\n\n            \r\n            VirtualMachine.Type vmType = cmd.getVirtualMachine().getType();\n            if (vmType.equals(VirtualMachine.Type.NetScalerVm)) {\n                NicTO mgmtNic = vmSpec.getNics()[0];\n                OptionValue option = new OptionValue();\n                option.setKey(\"machine.id\");\n                option.setValue(\"ip=\" + mgmtNic.getIp() + \"&netmask=\" + mgmtNic.getNetmask() + \"&gateway=\" + mgmtNic.getGateway());\n                extraOptions.add(option);\n            }\n\n            configureVNC(vmSpec, extraOptions, vmConfigSpec, hyperHost, vmInternalCSName);\n\n            \r\n            configureVideoCard(vmMo, vmSpec, vmConfigSpec);\n\n            setBootOptions(vmSpec, bootMode, vmConfigSpec);\n\n            if (!StringUtils.isEmpty(vmStoragePolicyId)) {\n                vmConfigSpec.getVmProfile().add(vmProfileSpec);\n                if (s_logger.isTraceEnabled()) {\n                    s_logger.trace(String.format(\"Configuring the VM %s with storage policy: %s\", vmInternalCSName, vmStoragePolicyId));\n                }\n            }\n            \r\n            \r\n            \r\n            if (!vmMo.configureVm(vmConfigSpec)) {\n                throw new Exception(\"Failed to configure VM before start. vmName: \" + vmInternalCSName);\n            }\n\n            if (vmSpec.getType() == VirtualMachine.Type.DomainRouter) {\n                hyperHost.setRestartPriorityForVM(vmMo, DasVmPriority.HIGH.value());\n            }\n\n            \r\n            final Map<String, String> vmDetails = cmd.getVirtualMachine().getDetails();\n            if (!deployAsIs && rootDiskTO != null && !hasSnapshot && (vmDetails != null && vmDetails.containsKey(ApiConstants.ROOT_DISK_SIZE))) {\n                resizeRootDiskOnVMStart(vmMo, rootDiskTO, hyperHost, context);\n            }\n\n            \r\n            \r\n            \r\n\n            vmMo.setCustomFieldValue(CustomFieldConstants.CLOUD_NIC_MASK, String.valueOf(nicMask));\n            postNvpConfigBeforeStart(vmMo, vmSpec);\n\n            Map<String, Map<String, String>> iqnToData = new HashMap<>();\n\n            postDiskConfigBeforeStart(vmMo, vmSpec, sortedDisks, ideControllerKey, scsiControllerKey, iqnToData, hyperHost, context);\n\n            \r\n            \r\n            \r\n            if (!vmMo.powerOn()) {\n                throw new Exception(\"Failed to start VM. vmName: \" + vmInternalCSName + \" with hostname \" + vmNameOnVcenter);\n            }\n\n            StartAnswer startAnswer = new StartAnswer(cmd);\n\n            startAnswer.setIqnToData(iqnToData);\n\n            \r\n            if (existingVmName != null && existingVmFileLayout != null) {\n                List<String> vmDatastoreNames = new ArrayList<String>();\n                for (DatastoreMO vmDatastore : vmMo.getAllDatastores()) {\n                    vmDatastoreNames.add(vmDatastore.getName());\n                }\n                \r\n                List<String> skipDatastores = new ArrayList<String>();\n                for (DatastoreMO existingDatastore : existingDatastores) {\n                    if (vmDatastoreNames.contains(existingDatastore.getName())) {\n                        skipDatastores.add(existingDatastore.getName());\n                    }\n                }\n                deleteUnregisteredVmFiles(existingVmFileLayout, dcMo, true, skipDatastores);\n            }\n\n            return startAnswer;\n        } catch (Throwable e) {\n            if (e instanceof RemoteException) {\n                s_logger.warn(\"Encounter remote exception to vCenter, invalidate VMware session context\");\n                invalidateServiceContext();\n            }\n\n            String msg = \"StartCommand failed due to \" + VmwareHelper.getExceptionMessage(e);\n            s_logger.warn(msg, e);\n            StartAnswer startAnswer = new StartAnswer(cmd, msg);\n            if (vmAlreadyExistsInVcenter) {\n                startAnswer.setContextParam(\"stopRetry\", \"true\");\n            }\n\n            \r\n            if (existingVmName != null && existingVmFileInfo != null) {\n                s_logger.debug(\"Since VM start failed, registering back an existing VM: \" + existingVmName + \" that was unregistered\");\n                try {\n                    DatastoreFile fileInDatastore = new DatastoreFile(existingVmFileInfo.getVmPathName());\n                    DatastoreMO existingVmDsMo = new DatastoreMO(dcMo.getContext(), dcMo.findDatastore(fileInDatastore.getDatastoreName()));\n                    registerVm(existingVmName, existingVmDsMo);\n                } catch (Exception ex) {\n                    String message = \"Failed to register an existing VM: \" + existingVmName + \" due to \" + VmwareHelper.getExceptionMessage(ex);\n                    s_logger.warn(message, ex);\n                }\n            }\n\n            return startAnswer;\n        } finally {\n        }\n    }\n","realPath":"plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/vmware/resource/VmwareResource.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1765,"status":"M"},{"authorDate":"2021-04-30 00:20:40","commitOrder":14,"curCode":"    private void configureIso(VmwareHypervisorHost hyperHost, VirtualMachineMO vmMo, DiskTO vol,\n                              VirtualDeviceConfigSpec[] deviceConfigSpecArray, int ideUnitNumber, int i) throws Exception {\n        TemplateObjectTO iso = (TemplateObjectTO) vol.getData();\n\n        if (iso.getPath() != null && !iso.getPath().isEmpty()) {\n            DataStoreTO imageStore = iso.getDataStore();\n            if (!(imageStore instanceof NfsTO)) {\n                s_logger.debug(\"unsupported protocol\");\n                throw new Exception(\"unsupported protocol\");\n            }\n            NfsTO nfsImageStore = (NfsTO) imageStore;\n            String isoPath = nfsImageStore.getUrl() + File.separator + iso.getPath();\n            Pair<String, ManagedObjectReference> isoDatastoreInfo = getIsoDatastoreInfo(hyperHost, isoPath);\n            assert (isoDatastoreInfo != null);\n            assert (isoDatastoreInfo.second() != null);\n\n            deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n            Pair<VirtualDevice, Boolean> isoInfo =\n                    VmwareHelper.prepareIsoDevice(vmMo, isoDatastoreInfo.first(), isoDatastoreInfo.second(), true, true, ideUnitNumber, i + 1);\n            deviceConfigSpecArray[i].setDevice(isoInfo.first());\n            if (isoInfo.second()) {\n                if (s_logger.isDebugEnabled())\n                    s_logger.debug(\"Prepare ISO volume at new device \" + _gson.toJson(isoInfo.first()));\n                deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n            } else {\n                if (s_logger.isDebugEnabled())\n                    s_logger.debug(\"Prepare ISO volume at existing device \" + _gson.toJson(isoInfo.first()));\n                deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.EDIT);\n            }\n        }\n    }\n","date":"2021-04-30 00:20:40","endLine":2497,"groupId":"13505","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"configureIso","params":"(VmwareHypervisorHosthyperHost@VirtualMachineMOvmMo@DiskTOvol@VirtualDeviceConfigSpec[]deviceConfigSpecArray@intideUnitNumber@inti)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/20/35cc736ade3abdc2efce433dd904fa383c5f6a.src","preCode":"    private void configureIso(VmwareHypervisorHost hyperHost, VirtualMachineMO vmMo, DiskTO vol,\n                              VirtualDeviceConfigSpec[] deviceConfigSpecArray, int ideUnitNumber, int i) throws Exception {\n        TemplateObjectTO iso = (TemplateObjectTO) vol.getData();\n\n        if (iso.getPath() != null && !iso.getPath().isEmpty()) {\n            DataStoreTO imageStore = iso.getDataStore();\n            if (!(imageStore instanceof NfsTO)) {\n                s_logger.debug(\"unsupported protocol\");\n                throw new Exception(\"unsupported protocol\");\n            }\n            NfsTO nfsImageStore = (NfsTO) imageStore;\n            String isoPath = nfsImageStore.getUrl() + File.separator + iso.getPath();\n            Pair<String, ManagedObjectReference> isoDatastoreInfo = getIsoDatastoreInfo(hyperHost, isoPath);\n            assert (isoDatastoreInfo != null);\n            assert (isoDatastoreInfo.second() != null);\n\n            deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n            Pair<VirtualDevice, Boolean> isoInfo =\n                    VmwareHelper.prepareIsoDevice(vmMo, isoDatastoreInfo.first(), isoDatastoreInfo.second(), true, true, ideUnitNumber, i + 1);\n            deviceConfigSpecArray[i].setDevice(isoInfo.first());\n            if (isoInfo.second()) {\n                if (s_logger.isDebugEnabled())\n                    s_logger.debug(\"Prepare ISO volume at new device \" + _gson.toJson(isoInfo.first()));\n                deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n            } else {\n                if (s_logger.isDebugEnabled())\n                    s_logger.debug(\"Prepare ISO volume at existing device \" + _gson.toJson(isoInfo.first()));\n                deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.EDIT);\n            }\n        }\n    }\n","realPath":"plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/vmware/resource/VmwareResource.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":2467,"status":"N"}],"commitId":"4b7fa4e63060842ce4d9eac74c0f66988a83fe9a","commitMessage":"@@@Merge remote-tracking branch 'apache/4.15'\n\nSigned-off-by: Abhishek Kumar <abhishek.mrt22@gmail.com>\n","date":"2021-05-24 19:13:53","modifiedFileCount":"7","status":"M","submitter":"Abhishek Kumar"},{"authorTime":"2021-04-30 00:20:40","codes":[{"authorDate":"2021-08-13 22:54:06","commitOrder":15,"curCode":"    protected StartAnswer execute(StartCommand cmd) {\n        if (s_logger.isInfoEnabled()) {\n            s_logger.info(\"Executing resource StartCommand: \" + getHumanReadableBytesJson(_gson.toJson(cmd)));\n        }\n\n        VirtualMachineTO vmSpec = cmd.getVirtualMachine();\n        boolean vmAlreadyExistsInVcenter = false;\n\n        String existingVmName = null;\n        VirtualMachineFileInfo existingVmFileInfo = null;\n        VirtualMachineFileLayoutEx existingVmFileLayout = null;\n        List<DatastoreMO> existingDatastores = new ArrayList<DatastoreMO>();\n        String diskStoragePolicyId = null;\n        String vmStoragePolicyId = null;\n        VirtualMachineDefinedProfileSpec diskProfileSpec = null;\n        VirtualMachineDefinedProfileSpec vmProfileSpec = null;\n\n\n        DeployAsIsInfoTO deployAsIsInfo = vmSpec.getDeployAsIsInfo();\n        boolean deployAsIs = deployAsIsInfo != null;\n\n        Pair<String, String> names = composeVmNames(vmSpec);\n        String vmInternalCSName = names.first();\n        String vmNameOnVcenter = names.second();\n        DiskTO rootDiskTO = null;\n        String bootMode = getBootModeFromVmSpec(vmSpec, deployAsIs);\n        Pair<String, String> controllerInfo = getControllerInfoFromVmSpec(vmSpec);\n\n        Boolean systemVm = vmSpec.getType().isUsedBySystem();\n        \r\n        VmwareContext context = getServiceContext();\n        DatacenterMO dcMo = null;\n        try {\n            VmwareManager mgr = context.getStockObject(VmwareManager.CONTEXT_STOCK_NAME);\n\n            VmwareHypervisorHost hyperHost = getHyperHost(context);\n            dcMo = new DatacenterMO(hyperHost.getContext(), hyperHost.getHyperHostDatacenter());\n\n            \r\n            VirtualMachineMO vmInVcenter = dcMo.checkIfVmAlreadyExistsInVcenter(vmNameOnVcenter, vmInternalCSName);\n            if (vmInVcenter != null) {\n                vmAlreadyExistsInVcenter = true;\n                String msg = \"VM with name: \" + vmNameOnVcenter + \" already exists in vCenter.\";\n                s_logger.error(msg);\n                throw new Exception(msg);\n            }\n\n            DiskTO[] specDisks = vmSpec.getDisks();\n            String guestOsId = getGuestOsIdFromVmSpec(vmSpec, deployAsIs);\n            DiskTO[] disks = validateDisks(vmSpec.getDisks());\n            assert (disks.length > 0);\n            NicTO[] nics = vmSpec.getNics();\n\n            HashMap<String, Pair<ManagedObjectReference, DatastoreMO>> dataStoresDetails = inferDatastoreDetailsFromDiskInfo(hyperHost, context, disks, cmd);\n            if ((dataStoresDetails == null) || (dataStoresDetails.isEmpty())) {\n                String msg = \"Unable to locate datastore details of the volumes to be attached\";\n                s_logger.error(msg);\n                throw new Exception(msg);\n            }\n\n            VirtualMachineDiskInfoBuilder diskInfoBuilder = null;\n            VirtualDevice[] nicDevices = null;\n            VirtualMachineMO vmMo = hyperHost.findVmOnHyperHost(vmInternalCSName);\n            DiskControllerType systemVmScsiControllerType = DiskControllerType.lsilogic;\n            int firstScsiControllerBusNum = 0;\n            int numScsiControllerForSystemVm = 1;\n            boolean hasSnapshot = false;\n\n            List<Pair<Integer, ManagedObjectReference>> diskDatastores = null;\n            if (vmMo != null) {\n                s_logger.info(\"VM \" + vmInternalCSName + \" already exists, tear down devices for reconfiguration\");\n                if (getVmPowerState(vmMo) != PowerState.PowerOff)\n                    vmMo.safePowerOff(_shutdownWaitMs);\n\n                \r\n                diskDatastores = vmMo.getAllDiskDatastores();\n                diskInfoBuilder = vmMo.getDiskInfoBuilder();\n                hasSnapshot = vmMo.hasSnapshot();\n                nicDevices = vmMo.getNicDevices();\n\n                tearDownVmDevices(vmMo, hasSnapshot, deployAsIs);\n                ensureDiskControllersInternal(vmMo, systemVm, controllerInfo, systemVmScsiControllerType,\n                        numScsiControllerForSystemVm, firstScsiControllerBusNum, deployAsIs);\n            } else {\n                ManagedObjectReference morDc = hyperHost.getHyperHostDatacenter();\n                assert (morDc != null);\n\n                vmMo = hyperHost.findVmOnPeerHyperHost(vmInternalCSName);\n                if (vmMo != null) {\n                    if (s_logger.isInfoEnabled()) {\n                        s_logger.info(\"Found vm \" + vmInternalCSName + \" at other host, relocate to \" + hyperHost.getHyperHostName());\n                    }\n\n                    takeVmFromOtherHyperHost(hyperHost, vmInternalCSName);\n\n                    if (getVmPowerState(vmMo) != PowerState.PowerOff)\n                        vmMo.safePowerOff(_shutdownWaitMs);\n\n                    diskInfoBuilder = vmMo.getDiskInfoBuilder();\n                    hasSnapshot = vmMo.hasSnapshot();\n                    diskDatastores = vmMo.getAllDiskDatastores();\n\n                    tearDownVmDevices(vmMo, hasSnapshot, deployAsIs);\n                    ensureDiskControllersInternal(vmMo, systemVm, controllerInfo, systemVmScsiControllerType,\n                            numScsiControllerForSystemVm, firstScsiControllerBusNum, deployAsIs);\n                } else {\n                    \r\n                    VirtualMachineMO existingVmInDc = dcMo.findVm(vmInternalCSName);\n                    if (existingVmInDc != null) {\n                        s_logger.debug(\"Found VM: \" + vmInternalCSName + \" on a host in a different cluster. Unregistering the exisitng VM.\");\n                        existingVmName = existingVmInDc.getName();\n                        existingVmFileInfo = existingVmInDc.getFileInfo();\n                        existingVmFileLayout = existingVmInDc.getFileLayout();\n                        existingDatastores = existingVmInDc.getAllDatastores();\n                        existingVmInDc.unregisterVm();\n                    }\n\n                    if (deployAsIs) {\n                        vmMo = hyperHost.findVmOnHyperHost(vmInternalCSName);\n                        if (vmMo == null) {\n                            s_logger.info(\"Cloned deploy-as-is VM \" + vmInternalCSName + \" is not in this host, relocating it\");\n                            vmMo = takeVmFromOtherHyperHost(hyperHost, vmInternalCSName);\n                        }\n                    } else {\n                        DiskTO rootDisk = null;\n                        for (DiskTO vol : disks) {\n                            if (vol.getType() == Volume.Type.ROOT) {\n                                rootDisk = vol;\n                            }\n                        }\n                        Pair<ManagedObjectReference, DatastoreMO> rootDiskDataStoreDetails = getDatastoreThatDiskIsOn(dataStoresDetails, rootDisk);\n                        assert (vmSpec.getMinSpeed() != null) && (rootDiskDataStoreDetails != null);\n                        DatastoreMO dsRootVolumeIsOn = rootDiskDataStoreDetails.second();\n                        if (dsRootVolumeIsOn == null) {\n                                String msg = \"Unable to locate datastore details of root volume\";\n                                s_logger.error(msg);\n                                throw new Exception(msg);\n                            }\n                        if (rootDisk.getDetails().get(DiskTO.PROTOCOL_TYPE) != null && rootDisk.getDetails().get(DiskTO.PROTOCOL_TYPE).equalsIgnoreCase(\"DatastoreCluster\")) {\n                            if (diskInfoBuilder != null) {\n                                DatastoreMO diskDatastoreMofromVM = getDataStoreWhereDiskExists(hyperHost, context, diskInfoBuilder, rootDisk, diskDatastores);\n                                if (diskDatastoreMofromVM != null) {\n                                    String actualPoolUuid = diskDatastoreMofromVM.getCustomFieldValue(CustomFieldConstants.CLOUD_UUID);\n                                    if (!actualPoolUuid.equalsIgnoreCase(rootDisk.getData().getDataStore().getUuid())) {\n                                        dsRootVolumeIsOn = diskDatastoreMofromVM;\n                                    }\n                                }\n                            }\n                        }\n\n                        boolean vmFolderExists = dsRootVolumeIsOn.folderExists(String.format(\"[%s]\", dsRootVolumeIsOn.getName()), vmNameOnVcenter);                        String vmxFileFullPath = dsRootVolumeIsOn.searchFileInSubFolders(vmNameOnVcenter + \".vmx\", false, VmwareManager.s_vmwareSearchExcludeFolder.value());\n                        if (vmFolderExists && vmxFileFullPath != null) { \r\n                            registerVm(vmNameOnVcenter, dsRootVolumeIsOn);\n                            vmMo = hyperHost.findVmOnHyperHost(vmInternalCSName);\n                            if (vmMo != null) {\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(\"Found registered vm \" + vmInternalCSName + \" at host \" + hyperHost.getHyperHostName());\n                                }\n                            }\n                            tearDownVm(vmMo);\n                        } else if (!hyperHost.createBlankVm(vmNameOnVcenter, vmInternalCSName, vmSpec.getCpus(), vmSpec.getMaxSpeed().intValue(), getReservedCpuMHZ(vmSpec),\n                                vmSpec.getLimitCpuUse(), (int) (vmSpec.getMaxRam() / ResourceType.bytesToMiB), getReservedMemoryMb(vmSpec), guestOsId, rootDiskDataStoreDetails.first(), false,\n                                controllerInfo, systemVm)) {\n                            throw new Exception(\"Failed to create VM. vmName: \" + vmInternalCSName);\n                        }\n                    }\n                }\n\n                vmMo = hyperHost.findVmOnHyperHost(vmInternalCSName);\n                if (vmMo == null) {\n                    throw new Exception(\"Failed to find the newly create or relocated VM. vmName: \" + vmInternalCSName);\n                }\n            }\n            if (deployAsIs) {\n                s_logger.info(\"Mapping VM disks to spec disks and tearing down datadisks (if any)\");\n                mapSpecDisksToClonedDisksAndTearDownDatadisks(vmMo, vmInternalCSName, specDisks);\n            }\n\n            int disksChanges = getDisksChangesNumberFromDisksSpec(disks, deployAsIs);\n            int totalChangeDevices = disksChanges + nics.length;\n            if (deployAsIsInfo != null && deployAsIsInfo.getProperties() != null) {\n                totalChangeDevices++;\n            }\n\n            DiskTO volIso = null;\n            if (vmSpec.getType() != VirtualMachine.Type.User) {\n                \r\n                totalChangeDevices++;\n            } else {\n                volIso = getIsoDiskTO(disks);\n                if (volIso == null && !deployAsIs) {\n                    totalChangeDevices++;\n                }\n            }\n\n            VirtualMachineConfigSpec vmConfigSpec = new VirtualMachineConfigSpec();\n\n            int i = 0;\n            int ideUnitNumber = !deployAsIs ? 0 : vmMo.getNextIDEDeviceNumber();\n            int scsiUnitNumber = !deployAsIs ? 0 : vmMo.getNextScsiDiskDeviceNumber();\n            int ideControllerKey = vmMo.getIDEDeviceControllerKey();\n            int scsiControllerKey = vmMo.getScsiDeviceControllerKeyNoException();\n            VirtualDeviceConfigSpec[] deviceConfigSpecArray = new VirtualDeviceConfigSpec[totalChangeDevices];\n            DiskTO[] sortedDisks = sortVolumesByDeviceId(disks);\n\n            VmwareHelper.setBasicVmConfig(vmConfigSpec, vmSpec.getCpus(), vmSpec.getMaxSpeed(), getReservedCpuMHZ(vmSpec), (int) (vmSpec.getMaxRam() / (1024 * 1024)),\n                    getReservedMemoryMb(vmSpec), guestOsId, vmSpec.getLimitCpuUse(), deployAsIs);\n\n            \r\n            int numCoresPerSocket = 1;\n            String coresPerSocket = vmSpec.getDetails().get(VmDetailConstants.CPU_CORE_PER_SOCKET);\n            if (coresPerSocket != null) {\n                String apiVersion = HypervisorHostHelper.getVcenterApiVersion(vmMo.getContext());\n                \r\n                if (apiVersion.compareTo(\"5.0\") >= 0) {\n                    numCoresPerSocket = NumbersUtil.parseInt(coresPerSocket, 1);\n                    vmConfigSpec.setNumCoresPerSocket(numCoresPerSocket);\n                }\n            }\n\n            \r\n            vmConfigSpec.setMemoryHotAddEnabled(vmMo.isMemoryHotAddSupported(guestOsId) && vmSpec.isEnableDynamicallyScaleVm());\n            String hostApiVersion = ((HostMO) hyperHost).getHostAboutInfo().getApiVersion();\n            if (numCoresPerSocket > 1 && hostApiVersion.compareTo(\"5.0\") < 0) {\n                s_logger.warn(\"Dynamic scaling of CPU is not supported for Virtual Machines with multi-core vCPUs in case of ESXi hosts 4.1 and prior. Hence CpuHotAdd will not be\"\n                        + \" enabled for Virtual Machine: \" + vmInternalCSName);\n                vmConfigSpec.setCpuHotAddEnabled(false);\n            } else {\n                vmConfigSpec.setCpuHotAddEnabled(vmMo.isCpuHotAddSupported(guestOsId) && vmSpec.isEnableDynamicallyScaleVm());\n            }\n\n            if(!vmMo.isMemoryHotAddSupported(guestOsId) && vmSpec.isEnableDynamicallyScaleVm()){\n                s_logger.warn(\"hotadd of memory is not supported, dynamic scaling feature can not be applied to vm: \" + vmInternalCSName);\n            }\n\n            if(!vmMo.isCpuHotAddSupported(guestOsId) && vmSpec.isEnableDynamicallyScaleVm()){\n                s_logger.warn(\"hotadd of cpu is not supported, dynamic scaling feature can not be applied to vm: \" + vmInternalCSName);\n            }\n\n            configNestedHVSupport(vmMo, vmSpec, vmConfigSpec);\n\n            \r\n            \r\n            \r\n\n            \r\n            if (vmSpec.getType() != VirtualMachine.Type.User) {\n                \r\n                Pair<String, Long> secStoreUrlAndId = mgr.getSecondaryStorageStoreUrlAndId(Long.parseLong(_dcId));\n                String secStoreUrl = secStoreUrlAndId.first();\n                Long secStoreId = secStoreUrlAndId.second();\n                if (secStoreUrl == null) {\n                    String msg = \"secondary storage for dc \" + _dcId + \" is not ready yet?\";\n                    throw new Exception(msg);\n                }\n                mgr.prepareSecondaryStorageStore(secStoreUrl, secStoreId);\n\n                ManagedObjectReference morSecDs = prepareSecondaryDatastoreOnHost(secStoreUrl);\n                if (morSecDs == null) {\n                    String msg = \"Failed to prepare secondary storage on host, secondary store url: \" + secStoreUrl;\n                    throw new Exception(msg);\n                }\n                DatastoreMO secDsMo = new DatastoreMO(hyperHost.getContext(), morSecDs);\n\n                deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n                Pair<VirtualDevice, Boolean> isoInfo = VmwareHelper.prepareIsoDevice(vmMo,\n                        String.format(\"[%s] systemvm/%s\", secDsMo.getName(), mgr.getSystemVMIsoFileNameOnDatastore()), secDsMo.getMor(), true, true, ideUnitNumber++, i + 1);\n                deviceConfigSpecArray[i].setDevice(isoInfo.first());\n                if (isoInfo.second()) {\n                    if (s_logger.isDebugEnabled())\n                        s_logger.debug(\"Prepare ISO volume at new device \" + _gson.toJson(isoInfo.first()));\n                    deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n                } else {\n                    if (s_logger.isDebugEnabled())\n                        s_logger.debug(\"Prepare ISO volume at existing device \" + _gson.toJson(isoInfo.first()));\n                    deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.EDIT);\n                }\n                i++;\n            } else if (!deployAsIs) {\n                \r\n                if (volIso != null) {\n                    for (DiskTO vol : disks) {\n                        if (vol.getType() == Volume.Type.ISO) {\n                            configureIso(hyperHost, vmMo, vol, deviceConfigSpecArray, ideUnitNumber++, i);\n                            i++;\n                        }\n                    }\n                } else {\n                    deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n                    Pair<VirtualDevice, Boolean> isoInfo = VmwareHelper.prepareIsoDevice(vmMo, null, null, true, true, ideUnitNumber++, i + 1);\n                    deviceConfigSpecArray[i].setDevice(isoInfo.first());\n                    if (isoInfo.second()) {\n                        if (s_logger.isDebugEnabled())\n                            s_logger.debug(\"Prepare ISO volume at existing device \" + _gson.toJson(isoInfo.first()));\n\n                        deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n                    } else {\n                        if (s_logger.isDebugEnabled())\n                            s_logger.debug(\"Prepare ISO volume at existing device \" + _gson.toJson(isoInfo.first()));\n\n                        deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.EDIT);\n                    }\n                    i++;\n                }\n            }\n\n            int controllerKey;\n\n            \r\n            \r\n            \r\n            if (multipleIsosAtached(sortedDisks) && deployAsIs) {\n                sortedDisks = getDisks(sortedDisks);\n            }\n\n            for (DiskTO vol : sortedDisks) {\n                if (vol.getType() == Volume.Type.ISO) {\n                    if (deployAsIs) {\n                        configureIso(hyperHost, vmMo, vol, deviceConfigSpecArray, ideUnitNumber++, i);\n                        i++;\n                    }\n                    continue;\n                }\n\n                if (deployAsIs && vol.getType() == Volume.Type.ROOT) {\n                    rootDiskTO = vol;\n                    resizeRootDiskOnVMStart(vmMo, rootDiskTO, hyperHost, context);\n                    continue;\n                }\n\n                VirtualMachineDiskInfo matchingExistingDisk = getMatchingExistingDisk(diskInfoBuilder, vol, hyperHost, context);\n                String diskController = getDiskController(vmMo, matchingExistingDisk, vol, controllerInfo, deployAsIs);\n                if (DiskControllerType.getType(diskController) == DiskControllerType.osdefault) {\n                    diskController = vmMo.getRecommendedDiskController(null);\n                }\n                if (DiskControllerType.getType(diskController) == DiskControllerType.ide) {\n                    controllerKey = vmMo.getIDEControllerKey(ideUnitNumber);\n                    if (vol.getType() == Volume.Type.DATADISK) {\n                        \r\n                        \r\n                        if (vmMo.getNumberOfVirtualDisks() > 3) {\n                            throw new CloudRuntimeException(\"Found more than 3 virtual disks attached to this VM [\" + vmMo.getVmName() + \"]. Unable to implement the disks over \"\n                                    + diskController + \" controller, as maximum number of devices supported over IDE controller is 4 includeing CDROM device.\");\n                        }\n                    }\n                } else {\n                    if (VmwareHelper.isReservedScsiDeviceNumber(scsiUnitNumber)) {\n                        scsiUnitNumber++;\n                    }\n\n                    controllerKey = vmMo.getScsiDiskControllerKeyNoException(diskController, scsiUnitNumber);\n                    if (controllerKey == -1) {\n                        \r\n                        \r\n                        Ternary<Integer, Integer, DiskControllerType> vmScsiControllerInfo = vmMo.getScsiControllerInfo();\n                        DiskControllerType existingControllerType = vmScsiControllerInfo.third();\n                        controllerKey = vmMo.getScsiDiskControllerKeyNoException(existingControllerType.toString(), scsiUnitNumber);\n                    }\n                }\n                if (!hasSnapshot) {\n                    deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n\n                    VolumeObjectTO volumeTO = (VolumeObjectTO) vol.getData();\n                    DataStoreTO primaryStore = volumeTO.getDataStore();\n                    Map<String, String> details = vol.getDetails();\n                    boolean managed = false;\n                    String iScsiName = null;\n\n                    if (details != null) {\n                        managed = Boolean.parseBoolean(details.get(DiskTO.MANAGED));\n                        iScsiName = details.get(DiskTO.IQN);\n                    }\n\n                    String primaryStoreUuid = primaryStore.getUuid();\n                    \r\n                    String datastoreName = managed ? VmwareResource.getDatastoreName(iScsiName) : primaryStoreUuid;\n                    Pair<ManagedObjectReference, DatastoreMO> volumeDsDetails = dataStoresDetails.get(datastoreName);\n\n                    assert (volumeDsDetails != null);\n                    if (volumeDsDetails == null) {\n                        throw new Exception(\"Primary datastore \" + primaryStore.getUuid() + \" is not mounted on host.\");\n                    }\n\n                    if (vol.getDetails().get(DiskTO.PROTOCOL_TYPE) != null && vol.getDetails().get(DiskTO.PROTOCOL_TYPE).equalsIgnoreCase(\"DatastoreCluster\")) {\n                        if (diskInfoBuilder != null && matchingExistingDisk != null) {\n                            String[] diskChain = matchingExistingDisk.getDiskChain();\n                            if (diskChain != null && diskChain.length > 0) {\n                                DatastoreFile file = new DatastoreFile(diskChain[0]);\n                                if (!file.getFileBaseName().equalsIgnoreCase(volumeTO.getPath())) {\n                                    if (s_logger.isInfoEnabled())\n                                        s_logger.info(\"Detected disk-chain top file change on volume: \" + volumeTO.getId() + \" \" + volumeTO.getPath() + \" -> \" + file.getFileBaseName());\n                                    volumeTO.setPath(file.getFileBaseName());\n                                }\n                            }\n                            DatastoreMO diskDatastoreMofromVM = getDataStoreWhereDiskExists(hyperHost, context, diskInfoBuilder, vol, diskDatastores);\n                            if (diskDatastoreMofromVM != null) {\n                                String actualPoolUuid = diskDatastoreMofromVM.getCustomFieldValue(CustomFieldConstants.CLOUD_UUID);\n                                if (actualPoolUuid != null && !actualPoolUuid.equalsIgnoreCase(primaryStore.getUuid())) {\n                                    volumeDsDetails = new Pair<>(diskDatastoreMofromVM.getMor(), diskDatastoreMofromVM);\n                                    if (s_logger.isInfoEnabled())\n                                        s_logger.info(\"Detected datastore uuid change on volume: \" + volumeTO.getId() + \" \" + primaryStore.getUuid() + \" -> \" + actualPoolUuid);\n                                    ((PrimaryDataStoreTO)primaryStore).setUuid(actualPoolUuid);\n                                }\n                            }\n                        }\n                    }\n\n                    String[] diskChain = syncDiskChain(dcMo, vmMo, vol, matchingExistingDisk, volumeDsDetails.second());\n\n                    int deviceNumber = -1;\n                    if (controllerKey == vmMo.getIDEControllerKey(ideUnitNumber)) {\n                        deviceNumber = ideUnitNumber % VmwareHelper.MAX_ALLOWED_DEVICES_IDE_CONTROLLER;\n                        ideUnitNumber++;\n                    } else {\n                        deviceNumber = scsiUnitNumber % VmwareHelper.MAX_ALLOWED_DEVICES_SCSI_CONTROLLER;\n                        scsiUnitNumber++;\n                    }\n\n                    VirtualDevice device = VmwareHelper.prepareDiskDevice(vmMo, null, controllerKey, diskChain, volumeDsDetails.first(), deviceNumber, i + 1);\n\n                    diskStoragePolicyId = volumeTO.getvSphereStoragePolicyId();\n                    if (!StringUtils.isEmpty(diskStoragePolicyId)) {\n                        PbmProfileManagerMO profMgrMo = new PbmProfileManagerMO(context);\n                        diskProfileSpec = profMgrMo.getProfileSpec(diskStoragePolicyId);\n                        deviceConfigSpecArray[i].getProfile().add(diskProfileSpec);\n                        if (s_logger.isDebugEnabled()) {\n                            s_logger.debug(String.format(\"Adding vSphere storage profile: %s to virtual disk [%s]\", diskStoragePolicyId, _gson.toJson(device)));\n                        }\n                    }\n                    if (vol.getType() == Volume.Type.ROOT) {\n                        rootDiskTO = vol;\n                        vmStoragePolicyId = diskStoragePolicyId;\n                        vmProfileSpec = diskProfileSpec;\n                    }\n                    deviceConfigSpecArray[i].setDevice(device);\n                    deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n\n                    if (s_logger.isDebugEnabled())\n                        s_logger.debug(\"Prepare volume at new device \" + _gson.toJson(device));\n\n                    i++;\n                } else {\n                    if (controllerKey == vmMo.getIDEControllerKey(ideUnitNumber))\n                        ideUnitNumber++;\n                    else\n                        scsiUnitNumber++;\n                }\n            }\n\n            \r\n            \r\n            \r\n            if (StringUtils.isNotBlank(guestOsId) && guestOsId.startsWith(\"darwin\")) { \r\n                VirtualDevice[] devices = vmMo.getMatchedDevices(new Class<?>[]{VirtualUSBController.class});\n                if (devices.length == 0) {\n                    s_logger.debug(\"No USB Controller device on VM Start. Add USB Controller device for Mac OS VM \" + vmInternalCSName);\n\n                    \r\n                    VirtualDevice usbControllerDevice = VmwareHelper.prepareUSBControllerDevice();\n                    deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n                    deviceConfigSpecArray[i].setDevice(usbControllerDevice);\n                    deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n\n                    if (s_logger.isDebugEnabled())\n                        s_logger.debug(\"Prepare USB controller at new device \" + _gson.toJson(deviceConfigSpecArray[i]));\n\n                    i++;\n                } else {\n                    s_logger.debug(\"USB Controller device exists on VM Start for Mac OS VM \" + vmInternalCSName);\n                }\n            }\n\n            \r\n            \r\n            \r\n            VirtualDevice nic;\n            int nicMask = 0;\n            int nicCount = 0;\n\n            if (vmSpec.getType() == VirtualMachine.Type.DomainRouter) {\n                int extraPublicNics = mgr.getRouterExtraPublicNics();\n                if (extraPublicNics > 0 && vmSpec.getDetails().containsKey(\"PeerRouterInstanceName\")) {\n                    \r\n                    String peerRouterInstanceName = vmSpec.getDetails().get(\"PeerRouterInstanceName\");\n\n                    VirtualMachineMO peerVmMo = hyperHost.findVmOnHyperHost(peerRouterInstanceName);\n                    if (peerVmMo == null) {\n                        peerVmMo = hyperHost.findVmOnPeerHyperHost(peerRouterInstanceName);\n                    }\n\n                    if (peerVmMo != null) {\n                        String oldMacSequence = generateMacSequence(nics);\n\n                        for (int nicIndex = nics.length - extraPublicNics; nicIndex < nics.length; nicIndex++) {\n                            VirtualDevice nicDevice = peerVmMo.getNicDeviceByIndex(nics[nicIndex].getDeviceId());\n                            if (nicDevice != null) {\n                                String mac = ((VirtualEthernetCard) nicDevice).getMacAddress();\n                                if (mac != null) {\n                                    s_logger.info(\"Use same MAC as previous RvR, the MAC is \" + mac + \" for extra NIC with device id: \" + nics[nicIndex].getDeviceId());\n                                    nics[nicIndex].setMac(mac);\n                                }\n                            }\n                        }\n\n                        if (!StringUtils.isBlank(vmSpec.getBootArgs())) {\n                            String newMacSequence = generateMacSequence(nics);\n                            vmSpec.setBootArgs(replaceNicsMacSequenceInBootArgs(oldMacSequence, newMacSequence, vmSpec));\n                        }\n                    }\n                }\n            }\n\n            VirtualEthernetCardType nicDeviceType;\n\n            NiciraNvpApiVersion.logNiciraApiVersion();\n\n            Map<String, String> nicUuidToDvSwitchUuid = new HashMap<String, String>();\n            for (NicTO nicTo : sortNicsByDeviceId(nics)) {\n                s_logger.info(\"Prepare NIC device based on NicTO: \" + _gson.toJson(nicTo));\n\n                String adapterTypeStr = deployAsIs ?\n                        mapAdapterType(deployAsIsInfo.getNicAdapterMap().get(nicTo.getDeviceId())) :\n                        vmSpec.getDetails().get(VmDetailConstants.NIC_ADAPTER);\n                nicDeviceType = VirtualEthernetCardType.valueOf(adapterTypeStr);\n\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"VM \" + vmInternalCSName + \" will be started with NIC device type: \" + nicDeviceType + \" on NIC device \" + nicTo.getDeviceId());\n                }\n                boolean configureVServiceInNexus = (nicTo.getType() == TrafficType.Guest) && (vmSpec.getDetails().containsKey(\"ConfigureVServiceInNexus\"));\n                VirtualMachine.Type vmType = cmd.getVirtualMachine().getType();\n                Pair<ManagedObjectReference, String> networkInfo = prepareNetworkFromNicInfo(vmMo.getRunningHost(), nicTo, configureVServiceInNexus, vmType);\n                if ((nicTo.getBroadcastType() != BroadcastDomainType.Lswitch)\n                        || (nicTo.getBroadcastType() == BroadcastDomainType.Lswitch && NiciraNvpApiVersion.isApiVersionLowerThan(\"4.2\"))) {\n                    if (VmwareHelper.isDvPortGroup(networkInfo.first())) {\n                        String dvSwitchUuid;\n                        ManagedObjectReference dcMor = hyperHost.getHyperHostDatacenter();\n                        DatacenterMO dataCenterMo = new DatacenterMO(context, dcMor);\n                        ManagedObjectReference dvsMor = dataCenterMo.getDvSwitchMor(networkInfo.first());\n                        dvSwitchUuid = dataCenterMo.getDvSwitchUuid(dvsMor);\n                        s_logger.info(\"Preparing NIC device on dvSwitch : \" + dvSwitchUuid);\n                        nic = VmwareHelper.prepareDvNicDevice(vmMo, networkInfo.first(), nicDeviceType, networkInfo.second(), dvSwitchUuid,\n                                nicTo.getMac(), i + 1, true, true);\n                        if (nicTo.getUuid() != null) {\n                            nicUuidToDvSwitchUuid.put(nicTo.getUuid(), dvSwitchUuid);\n                        }\n                    } else {\n                        s_logger.info(\"Preparing NIC device on network \" + networkInfo.second());\n                        nic = VmwareHelper.prepareNicDevice(vmMo, networkInfo.first(), nicDeviceType, networkInfo.second(),\n                                nicTo.getMac(), i + 1, true, true);\n                    }\n                } else {\n                    \r\n                    nic = VmwareHelper.prepareNicOpaque(vmMo, nicDeviceType, networkInfo.second(),\n                            nicTo.getMac(), i + 1, true, true);\n                }\n\n                deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n                deviceConfigSpecArray[i].setDevice(nic);\n                deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n\n                if (s_logger.isDebugEnabled())\n                    s_logger.debug(\"Prepare NIC at new device \" + _gson.toJson(deviceConfigSpecArray[i]));\n\n                \r\n                if (nicCount < 3)\n                    nicMask |= (1 << nicCount);\n\n                i++;\n                nicCount++;\n            }\n\n            for (int j = 0; j < i; j++)\n                vmConfigSpec.getDeviceChange().add(deviceConfigSpecArray[j]);\n\n            \r\n            \r\n            \r\n\n            \r\n            ArrayList<OptionValue> extraOptions = new ArrayList<OptionValue>();\n            configBasicExtraOption(extraOptions, vmSpec);\n\n            if (deployAsIs) {\n                setDeployAsIsProperties(vmMo, deployAsIsInfo, vmConfigSpec, hyperHost);\n            }\n\n            configNvpExtraOption(extraOptions, vmSpec, nicUuidToDvSwitchUuid);\n            configCustomExtraOption(extraOptions, vmSpec);\n\n            \r\n            VirtualMachine.Type vmType = cmd.getVirtualMachine().getType();\n            if (vmType.equals(VirtualMachine.Type.NetScalerVm)) {\n                NicTO mgmtNic = vmSpec.getNics()[0];\n                OptionValue option = new OptionValue();\n                option.setKey(\"machine.id\");\n                option.setValue(\"ip=\" + mgmtNic.getIp() + \"&netmask=\" + mgmtNic.getNetmask() + \"&gateway=\" + mgmtNic.getGateway());\n                extraOptions.add(option);\n            }\n\n            configureVNC(vmSpec, extraOptions, vmConfigSpec, hyperHost, vmInternalCSName);\n\n            \r\n            configureVideoCard(vmMo, vmSpec, vmConfigSpec);\n\n            setBootOptions(vmSpec, bootMode, vmConfigSpec);\n\n            if (!StringUtils.isEmpty(vmStoragePolicyId)) {\n                vmConfigSpec.getVmProfile().add(vmProfileSpec);\n                if (s_logger.isTraceEnabled()) {\n                    s_logger.trace(String.format(\"Configuring the VM %s with storage policy: %s\", vmInternalCSName, vmStoragePolicyId));\n                }\n            }\n            \r\n            \r\n            \r\n            if (!vmMo.configureVm(vmConfigSpec)) {\n                throw new Exception(\"Failed to configure VM before start. vmName: \" + vmInternalCSName);\n            }\n\n            if (vmSpec.getType() == VirtualMachine.Type.DomainRouter) {\n                hyperHost.setRestartPriorityForVM(vmMo, DasVmPriority.HIGH.value());\n            }\n\n            \r\n            final Map<String, String> vmDetails = cmd.getVirtualMachine().getDetails();\n            if (!deployAsIs && rootDiskTO != null && !hasSnapshot && (vmDetails != null && vmDetails.containsKey(ApiConstants.ROOT_DISK_SIZE))) {\n                resizeRootDiskOnVMStart(vmMo, rootDiskTO, hyperHost, context);\n            }\n\n            \r\n            \r\n            \r\n\n            vmMo.setCustomFieldValue(CustomFieldConstants.CLOUD_NIC_MASK, String.valueOf(nicMask));\n            postNvpConfigBeforeStart(vmMo, vmSpec);\n\n            Map<String, Map<String, String>> iqnToData = new HashMap<>();\n\n            postDiskConfigBeforeStart(vmMo, vmSpec, sortedDisks, ideControllerKey, scsiControllerKey, iqnToData, hyperHost, context);\n\n            \r\n            \r\n            \r\n            if (!vmMo.powerOn()) {\n                throw new Exception(\"Failed to start VM. vmName: \" + vmInternalCSName + \" with hostname \" + vmNameOnVcenter);\n            }\n\n            StartAnswer startAnswer = new StartAnswer(cmd);\n\n            startAnswer.setIqnToData(iqnToData);\n\n            \r\n            if (existingVmName != null && existingVmFileLayout != null) {\n                List<String> vmDatastoreNames = new ArrayList<String>();\n                for (DatastoreMO vmDatastore : vmMo.getAllDatastores()) {\n                    vmDatastoreNames.add(vmDatastore.getName());\n                }\n                \r\n                List<String> skipDatastores = new ArrayList<String>();\n                for (DatastoreMO existingDatastore : existingDatastores) {\n                    if (vmDatastoreNames.contains(existingDatastore.getName())) {\n                        skipDatastores.add(existingDatastore.getName());\n                    }\n                }\n                deleteUnregisteredVmFiles(existingVmFileLayout, dcMo, true, skipDatastores);\n            }\n\n            return startAnswer;\n        } catch (Throwable e) {\n            if (e instanceof RemoteException) {\n                s_logger.warn(\"Encounter remote exception to vCenter, invalidate VMware session context\");\n                invalidateServiceContext();\n            }\n\n            String msg = \"StartCommand failed due to \" + VmwareHelper.getExceptionMessage(e);\n            s_logger.warn(msg, e);\n            StartAnswer startAnswer = new StartAnswer(cmd, msg);\n            if (vmAlreadyExistsInVcenter) {\n                startAnswer.setContextParam(\"stopRetry\", \"true\");\n            }\n\n            \r\n            if (existingVmName != null && existingVmFileInfo != null) {\n                s_logger.debug(\"Since VM start failed, registering back an existing VM: \" + existingVmName + \" that was unregistered\");\n                try {\n                    DatastoreFile fileInDatastore = new DatastoreFile(existingVmFileInfo.getVmPathName());\n                    DatastoreMO existingVmDsMo = new DatastoreMO(dcMo.getContext(), dcMo.findDatastore(fileInDatastore.getDatastoreName()));\n                    registerVm(existingVmName, existingVmDsMo);\n                } catch (Exception ex) {\n                    String message = \"Failed to register an existing VM: \" + existingVmName + \" due to \" + VmwareHelper.getExceptionMessage(ex);\n                    s_logger.warn(message, ex);\n                }\n            }\n\n            return startAnswer;\n        } finally {\n        }\n    }\n","date":"2021-08-13 22:54:06","endLine":2472,"groupId":"122980","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"execute","params":"(StartCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/db/277e3f1226d73f050d94eb746a716afef61777.src","preCode":"    protected StartAnswer execute(StartCommand cmd) {\n        if (s_logger.isInfoEnabled()) {\n            s_logger.info(\"Executing resource StartCommand: \" + getHumanReadableBytesJson(_gson.toJson(cmd)));\n        }\n\n        VirtualMachineTO vmSpec = cmd.getVirtualMachine();\n        boolean vmAlreadyExistsInVcenter = false;\n\n        String existingVmName = null;\n        VirtualMachineFileInfo existingVmFileInfo = null;\n        VirtualMachineFileLayoutEx existingVmFileLayout = null;\n        List<DatastoreMO> existingDatastores = new ArrayList<DatastoreMO>();\n        String diskStoragePolicyId = null;\n        String vmStoragePolicyId = null;\n        VirtualMachineDefinedProfileSpec diskProfileSpec = null;\n        VirtualMachineDefinedProfileSpec vmProfileSpec = null;\n\n\n        DeployAsIsInfoTO deployAsIsInfo = vmSpec.getDeployAsIsInfo();\n        boolean deployAsIs = deployAsIsInfo != null;\n\n        Pair<String, String> names = composeVmNames(vmSpec);\n        String vmInternalCSName = names.first();\n        String vmNameOnVcenter = names.second();\n        DiskTO rootDiskTO = null;\n        String bootMode = getBootModeFromVmSpec(vmSpec, deployAsIs);\n        Pair<String, String> controllerInfo = getControllerInfoFromVmSpec(vmSpec);\n\n        Boolean systemVm = vmSpec.getType().isUsedBySystem();\n        \r\n        VmwareContext context = getServiceContext();\n        DatacenterMO dcMo = null;\n        try {\n            VmwareManager mgr = context.getStockObject(VmwareManager.CONTEXT_STOCK_NAME);\n\n            VmwareHypervisorHost hyperHost = getHyperHost(context);\n            dcMo = new DatacenterMO(hyperHost.getContext(), hyperHost.getHyperHostDatacenter());\n\n            \r\n            VirtualMachineMO vmInVcenter = dcMo.checkIfVmAlreadyExistsInVcenter(vmNameOnVcenter, vmInternalCSName);\n            if (vmInVcenter != null) {\n                vmAlreadyExistsInVcenter = true;\n                String msg = \"VM with name: \" + vmNameOnVcenter + \" already exists in vCenter.\";\n                s_logger.error(msg);\n                throw new Exception(msg);\n            }\n\n            DiskTO[] specDisks = vmSpec.getDisks();\n            String guestOsId = getGuestOsIdFromVmSpec(vmSpec, deployAsIs);\n            DiskTO[] disks = validateDisks(vmSpec.getDisks());\n            assert (disks.length > 0);\n            NicTO[] nics = vmSpec.getNics();\n\n            HashMap<String, Pair<ManagedObjectReference, DatastoreMO>> dataStoresDetails = inferDatastoreDetailsFromDiskInfo(hyperHost, context, disks, cmd);\n            if ((dataStoresDetails == null) || (dataStoresDetails.isEmpty())) {\n                String msg = \"Unable to locate datastore details of the volumes to be attached\";\n                s_logger.error(msg);\n                throw new Exception(msg);\n            }\n\n            VirtualMachineDiskInfoBuilder diskInfoBuilder = null;\n            VirtualDevice[] nicDevices = null;\n            VirtualMachineMO vmMo = hyperHost.findVmOnHyperHost(vmInternalCSName);\n            DiskControllerType systemVmScsiControllerType = DiskControllerType.lsilogic;\n            int firstScsiControllerBusNum = 0;\n            int numScsiControllerForSystemVm = 1;\n            boolean hasSnapshot = false;\n\n            List<Pair<Integer, ManagedObjectReference>> diskDatastores = null;\n            if (vmMo != null) {\n                s_logger.info(\"VM \" + vmInternalCSName + \" already exists, tear down devices for reconfiguration\");\n                if (getVmPowerState(vmMo) != PowerState.PowerOff)\n                    vmMo.safePowerOff(_shutdownWaitMs);\n\n                \r\n                diskDatastores = vmMo.getAllDiskDatastores();\n                diskInfoBuilder = vmMo.getDiskInfoBuilder();\n                hasSnapshot = vmMo.hasSnapshot();\n                nicDevices = vmMo.getNicDevices();\n\n                tearDownVmDevices(vmMo, hasSnapshot, deployAsIs);\n                ensureDiskControllersInternal(vmMo, systemVm, controllerInfo, systemVmScsiControllerType,\n                        numScsiControllerForSystemVm, firstScsiControllerBusNum, deployAsIs);\n            } else {\n                ManagedObjectReference morDc = hyperHost.getHyperHostDatacenter();\n                assert (morDc != null);\n\n                vmMo = hyperHost.findVmOnPeerHyperHost(vmInternalCSName);\n                if (vmMo != null) {\n                    if (s_logger.isInfoEnabled()) {\n                        s_logger.info(\"Found vm \" + vmInternalCSName + \" at other host, relocate to \" + hyperHost.getHyperHostName());\n                    }\n\n                    takeVmFromOtherHyperHost(hyperHost, vmInternalCSName);\n\n                    if (getVmPowerState(vmMo) != PowerState.PowerOff)\n                        vmMo.safePowerOff(_shutdownWaitMs);\n\n                    diskInfoBuilder = vmMo.getDiskInfoBuilder();\n                    hasSnapshot = vmMo.hasSnapshot();\n                    diskDatastores = vmMo.getAllDiskDatastores();\n\n                    tearDownVmDevices(vmMo, hasSnapshot, deployAsIs);\n                    ensureDiskControllersInternal(vmMo, systemVm, controllerInfo, systemVmScsiControllerType,\n                            numScsiControllerForSystemVm, firstScsiControllerBusNum, deployAsIs);\n                } else {\n                    \r\n                    VirtualMachineMO existingVmInDc = dcMo.findVm(vmInternalCSName);\n                    if (existingVmInDc != null) {\n                        s_logger.debug(\"Found VM: \" + vmInternalCSName + \" on a host in a different cluster. Unregistering the exisitng VM.\");\n                        existingVmName = existingVmInDc.getName();\n                        existingVmFileInfo = existingVmInDc.getFileInfo();\n                        existingVmFileLayout = existingVmInDc.getFileLayout();\n                        existingDatastores = existingVmInDc.getAllDatastores();\n                        existingVmInDc.unregisterVm();\n                    }\n\n                    if (deployAsIs) {\n                        vmMo = hyperHost.findVmOnHyperHost(vmInternalCSName);\n                        if (vmMo == null) {\n                            s_logger.info(\"Cloned deploy-as-is VM \" + vmInternalCSName + \" is not in this host, relocating it\");\n                            vmMo = takeVmFromOtherHyperHost(hyperHost, vmInternalCSName);\n                        }\n                    } else {\n                        DiskTO rootDisk = null;\n                        for (DiskTO vol : disks) {\n                            if (vol.getType() == Volume.Type.ROOT) {\n                                rootDisk = vol;\n                            }\n                        }\n                        Pair<ManagedObjectReference, DatastoreMO> rootDiskDataStoreDetails = getDatastoreThatDiskIsOn(dataStoresDetails, rootDisk);\n                        assert (vmSpec.getMinSpeed() != null) && (rootDiskDataStoreDetails != null);\n                        DatastoreMO dsRootVolumeIsOn = rootDiskDataStoreDetails.second();\n                        if (dsRootVolumeIsOn == null) {\n                                String msg = \"Unable to locate datastore details of root volume\";\n                                s_logger.error(msg);\n                                throw new Exception(msg);\n                            }\n                        if (rootDisk.getDetails().get(DiskTO.PROTOCOL_TYPE) != null && rootDisk.getDetails().get(DiskTO.PROTOCOL_TYPE).equalsIgnoreCase(\"DatastoreCluster\")) {\n                            if (diskInfoBuilder != null) {\n                                DatastoreMO diskDatastoreMofromVM = getDataStoreWhereDiskExists(hyperHost, context, diskInfoBuilder, rootDisk, diskDatastores);\n                                if (diskDatastoreMofromVM != null) {\n                                    String actualPoolUuid = diskDatastoreMofromVM.getCustomFieldValue(CustomFieldConstants.CLOUD_UUID);\n                                    if (!actualPoolUuid.equalsIgnoreCase(rootDisk.getData().getDataStore().getUuid())) {\n                                        dsRootVolumeIsOn = diskDatastoreMofromVM;\n                                    }\n                                }\n                            }\n                        }\n\n                        boolean vmFolderExists = dsRootVolumeIsOn.folderExists(String.format(\"[%s]\", dsRootVolumeIsOn.getName()), vmNameOnVcenter);                        String vmxFileFullPath = dsRootVolumeIsOn.searchFileInSubFolders(vmNameOnVcenter + \".vmx\", false, VmwareManager.s_vmwareSearchExcludeFolder.value());\n                        if (vmFolderExists && vmxFileFullPath != null) { \r\n                            registerVm(vmNameOnVcenter, dsRootVolumeIsOn);\n                            vmMo = hyperHost.findVmOnHyperHost(vmInternalCSName);\n                            if (vmMo != null) {\n                                if (s_logger.isDebugEnabled()) {\n                                    s_logger.debug(\"Found registered vm \" + vmInternalCSName + \" at host \" + hyperHost.getHyperHostName());\n                                }\n                            }\n                            tearDownVm(vmMo);\n                        } else if (!hyperHost.createBlankVm(vmNameOnVcenter, vmInternalCSName, vmSpec.getCpus(), vmSpec.getMaxSpeed().intValue(), getReservedCpuMHZ(vmSpec),\n                                vmSpec.getLimitCpuUse(), (int) (vmSpec.getMaxRam() / ResourceType.bytesToMiB), getReservedMemoryMb(vmSpec), guestOsId, rootDiskDataStoreDetails.first(), false,\n                                controllerInfo, systemVm)) {\n                            throw new Exception(\"Failed to create VM. vmName: \" + vmInternalCSName);\n                        }\n                    }\n                }\n\n                vmMo = hyperHost.findVmOnHyperHost(vmInternalCSName);\n                if (vmMo == null) {\n                    throw new Exception(\"Failed to find the newly create or relocated VM. vmName: \" + vmInternalCSName);\n                }\n            }\n            if (deployAsIs) {\n                s_logger.info(\"Mapping VM disks to spec disks and tearing down datadisks (if any)\");\n                mapSpecDisksToClonedDisksAndTearDownDatadisks(vmMo, vmInternalCSName, specDisks);\n            }\n\n            int disksChanges = getDisksChangesNumberFromDisksSpec(disks, deployAsIs);\n            int totalChangeDevices = disksChanges + nics.length;\n            if (deployAsIsInfo != null && deployAsIsInfo.getProperties() != null) {\n                totalChangeDevices++;\n            }\n\n            DiskTO volIso = null;\n            if (vmSpec.getType() != VirtualMachine.Type.User) {\n                \r\n                totalChangeDevices++;\n            } else {\n                volIso = getIsoDiskTO(disks);\n                if (volIso == null && !deployAsIs) {\n                    totalChangeDevices++;\n                }\n            }\n\n            VirtualMachineConfigSpec vmConfigSpec = new VirtualMachineConfigSpec();\n\n            int i = 0;\n            int ideUnitNumber = !deployAsIs ? 0 : vmMo.getNextIDEDeviceNumber();\n            int scsiUnitNumber = !deployAsIs ? 0 : vmMo.getNextScsiDiskDeviceNumber();\n            int ideControllerKey = vmMo.getIDEDeviceControllerKey();\n            int scsiControllerKey = vmMo.getScsiDeviceControllerKeyNoException();\n            VirtualDeviceConfigSpec[] deviceConfigSpecArray = new VirtualDeviceConfigSpec[totalChangeDevices];\n            DiskTO[] sortedDisks = sortVolumesByDeviceId(disks);\n\n            VmwareHelper.setBasicVmConfig(vmConfigSpec, vmSpec.getCpus(), vmSpec.getMaxSpeed(), getReservedCpuMHZ(vmSpec), (int) (vmSpec.getMaxRam() / (1024 * 1024)),\n                    getReservedMemoryMb(vmSpec), guestOsId, vmSpec.getLimitCpuUse(), deployAsIs);\n\n            \r\n            int numCoresPerSocket = 1;\n            String coresPerSocket = vmSpec.getDetails().get(VmDetailConstants.CPU_CORE_PER_SOCKET);\n            if (coresPerSocket != null) {\n                String apiVersion = HypervisorHostHelper.getVcenterApiVersion(vmMo.getContext());\n                \r\n                if (apiVersion.compareTo(\"5.0\") >= 0) {\n                    numCoresPerSocket = NumbersUtil.parseInt(coresPerSocket, 1);\n                    vmConfigSpec.setNumCoresPerSocket(numCoresPerSocket);\n                }\n            }\n\n            \r\n            vmConfigSpec.setMemoryHotAddEnabled(vmMo.isMemoryHotAddSupported(guestOsId));\n\n            String hostApiVersion = ((HostMO) hyperHost).getHostAboutInfo().getApiVersion();\n            if (numCoresPerSocket > 1 && hostApiVersion.compareTo(\"5.0\") < 0) {\n                s_logger.warn(\"Dynamic scaling of CPU is not supported for Virtual Machines with multi-core vCPUs in case of ESXi hosts 4.1 and prior. Hence CpuHotAdd will not be\"\n                        + \" enabled for Virtual Machine: \" + vmInternalCSName);\n                vmConfigSpec.setCpuHotAddEnabled(false);\n            } else {\n                vmConfigSpec.setCpuHotAddEnabled(vmMo.isCpuHotAddSupported(guestOsId));\n            }\n\n            configNestedHVSupport(vmMo, vmSpec, vmConfigSpec);\n\n            \r\n            \r\n            \r\n\n            \r\n            if (vmSpec.getType() != VirtualMachine.Type.User) {\n                \r\n                Pair<String, Long> secStoreUrlAndId = mgr.getSecondaryStorageStoreUrlAndId(Long.parseLong(_dcId));\n                String secStoreUrl = secStoreUrlAndId.first();\n                Long secStoreId = secStoreUrlAndId.second();\n                if (secStoreUrl == null) {\n                    String msg = \"secondary storage for dc \" + _dcId + \" is not ready yet?\";\n                    throw new Exception(msg);\n                }\n                mgr.prepareSecondaryStorageStore(secStoreUrl, secStoreId);\n\n                ManagedObjectReference morSecDs = prepareSecondaryDatastoreOnHost(secStoreUrl);\n                if (morSecDs == null) {\n                    String msg = \"Failed to prepare secondary storage on host, secondary store url: \" + secStoreUrl;\n                    throw new Exception(msg);\n                }\n                DatastoreMO secDsMo = new DatastoreMO(hyperHost.getContext(), morSecDs);\n\n                deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n                Pair<VirtualDevice, Boolean> isoInfo = VmwareHelper.prepareIsoDevice(vmMo,\n                        String.format(\"[%s] systemvm/%s\", secDsMo.getName(), mgr.getSystemVMIsoFileNameOnDatastore()), secDsMo.getMor(), true, true, ideUnitNumber++, i + 1);\n                deviceConfigSpecArray[i].setDevice(isoInfo.first());\n                if (isoInfo.second()) {\n                    if (s_logger.isDebugEnabled())\n                        s_logger.debug(\"Prepare ISO volume at new device \" + _gson.toJson(isoInfo.first()));\n                    deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n                } else {\n                    if (s_logger.isDebugEnabled())\n                        s_logger.debug(\"Prepare ISO volume at existing device \" + _gson.toJson(isoInfo.first()));\n                    deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.EDIT);\n                }\n                i++;\n            } else if (!deployAsIs) {\n                \r\n                if (volIso != null) {\n                    for (DiskTO vol : disks) {\n                        if (vol.getType() == Volume.Type.ISO) {\n                            configureIso(hyperHost, vmMo, vol, deviceConfigSpecArray, ideUnitNumber++, i);\n                            i++;\n                        }\n                    }\n                } else {\n                    deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n                    Pair<VirtualDevice, Boolean> isoInfo = VmwareHelper.prepareIsoDevice(vmMo, null, null, true, true, ideUnitNumber++, i + 1);\n                    deviceConfigSpecArray[i].setDevice(isoInfo.first());\n                    if (isoInfo.second()) {\n                        if (s_logger.isDebugEnabled())\n                            s_logger.debug(\"Prepare ISO volume at existing device \" + _gson.toJson(isoInfo.first()));\n\n                        deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n                    } else {\n                        if (s_logger.isDebugEnabled())\n                            s_logger.debug(\"Prepare ISO volume at existing device \" + _gson.toJson(isoInfo.first()));\n\n                        deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.EDIT);\n                    }\n                    i++;\n                }\n            }\n\n            int controllerKey;\n\n            \r\n            \r\n            \r\n            if (multipleIsosAtached(sortedDisks) && deployAsIs) {\n                sortedDisks = getDisks(sortedDisks);\n            }\n\n            for (DiskTO vol : sortedDisks) {\n                if (vol.getType() == Volume.Type.ISO) {\n                    if (deployAsIs) {\n                        configureIso(hyperHost, vmMo, vol, deviceConfigSpecArray, ideUnitNumber++, i);\n                        i++;\n                    }\n                    continue;\n                }\n\n                if (deployAsIs && vol.getType() == Volume.Type.ROOT) {\n                    rootDiskTO = vol;\n                    resizeRootDiskOnVMStart(vmMo, rootDiskTO, hyperHost, context);\n                    continue;\n                }\n\n                VirtualMachineDiskInfo matchingExistingDisk = getMatchingExistingDisk(diskInfoBuilder, vol, hyperHost, context);\n                String diskController = getDiskController(vmMo, matchingExistingDisk, vol, controllerInfo, deployAsIs);\n                if (DiskControllerType.getType(diskController) == DiskControllerType.osdefault) {\n                    diskController = vmMo.getRecommendedDiskController(null);\n                }\n                if (DiskControllerType.getType(diskController) == DiskControllerType.ide) {\n                    controllerKey = vmMo.getIDEControllerKey(ideUnitNumber);\n                    if (vol.getType() == Volume.Type.DATADISK) {\n                        \r\n                        \r\n                        if (vmMo.getNumberOfVirtualDisks() > 3) {\n                            throw new CloudRuntimeException(\"Found more than 3 virtual disks attached to this VM [\" + vmMo.getVmName() + \"]. Unable to implement the disks over \"\n                                    + diskController + \" controller, as maximum number of devices supported over IDE controller is 4 includeing CDROM device.\");\n                        }\n                    }\n                } else {\n                    if (VmwareHelper.isReservedScsiDeviceNumber(scsiUnitNumber)) {\n                        scsiUnitNumber++;\n                    }\n\n                    controllerKey = vmMo.getScsiDiskControllerKeyNoException(diskController, scsiUnitNumber);\n                    if (controllerKey == -1) {\n                        \r\n                        \r\n                        Ternary<Integer, Integer, DiskControllerType> vmScsiControllerInfo = vmMo.getScsiControllerInfo();\n                        DiskControllerType existingControllerType = vmScsiControllerInfo.third();\n                        controllerKey = vmMo.getScsiDiskControllerKeyNoException(existingControllerType.toString(), scsiUnitNumber);\n                    }\n                }\n                if (!hasSnapshot) {\n                    deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n\n                    VolumeObjectTO volumeTO = (VolumeObjectTO) vol.getData();\n                    DataStoreTO primaryStore = volumeTO.getDataStore();\n                    Map<String, String> details = vol.getDetails();\n                    boolean managed = false;\n                    String iScsiName = null;\n\n                    if (details != null) {\n                        managed = Boolean.parseBoolean(details.get(DiskTO.MANAGED));\n                        iScsiName = details.get(DiskTO.IQN);\n                    }\n\n                    String primaryStoreUuid = primaryStore.getUuid();\n                    \r\n                    String datastoreName = managed ? VmwareResource.getDatastoreName(iScsiName) : primaryStoreUuid;\n                    Pair<ManagedObjectReference, DatastoreMO> volumeDsDetails = dataStoresDetails.get(datastoreName);\n\n                    assert (volumeDsDetails != null);\n                    if (volumeDsDetails == null) {\n                        throw new Exception(\"Primary datastore \" + primaryStore.getUuid() + \" is not mounted on host.\");\n                    }\n\n                    if (vol.getDetails().get(DiskTO.PROTOCOL_TYPE) != null && vol.getDetails().get(DiskTO.PROTOCOL_TYPE).equalsIgnoreCase(\"DatastoreCluster\")) {\n                        if (diskInfoBuilder != null && matchingExistingDisk != null) {\n                            String[] diskChain = matchingExistingDisk.getDiskChain();\n                            if (diskChain != null && diskChain.length > 0) {\n                                DatastoreFile file = new DatastoreFile(diskChain[0]);\n                                if (!file.getFileBaseName().equalsIgnoreCase(volumeTO.getPath())) {\n                                    if (s_logger.isInfoEnabled())\n                                        s_logger.info(\"Detected disk-chain top file change on volume: \" + volumeTO.getId() + \" \" + volumeTO.getPath() + \" -> \" + file.getFileBaseName());\n                                    volumeTO.setPath(file.getFileBaseName());\n                                }\n                            }\n                            DatastoreMO diskDatastoreMofromVM = getDataStoreWhereDiskExists(hyperHost, context, diskInfoBuilder, vol, diskDatastores);\n                            if (diskDatastoreMofromVM != null) {\n                                String actualPoolUuid = diskDatastoreMofromVM.getCustomFieldValue(CustomFieldConstants.CLOUD_UUID);\n                                if (actualPoolUuid != null && !actualPoolUuid.equalsIgnoreCase(primaryStore.getUuid())) {\n                                    volumeDsDetails = new Pair<>(diskDatastoreMofromVM.getMor(), diskDatastoreMofromVM);\n                                    if (s_logger.isInfoEnabled())\n                                        s_logger.info(\"Detected datastore uuid change on volume: \" + volumeTO.getId() + \" \" + primaryStore.getUuid() + \" -> \" + actualPoolUuid);\n                                    ((PrimaryDataStoreTO)primaryStore).setUuid(actualPoolUuid);\n                                }\n                            }\n                        }\n                    }\n\n                    String[] diskChain = syncDiskChain(dcMo, vmMo, vol, matchingExistingDisk, volumeDsDetails.second());\n\n                    int deviceNumber = -1;\n                    if (controllerKey == vmMo.getIDEControllerKey(ideUnitNumber)) {\n                        deviceNumber = ideUnitNumber % VmwareHelper.MAX_ALLOWED_DEVICES_IDE_CONTROLLER;\n                        ideUnitNumber++;\n                    } else {\n                        deviceNumber = scsiUnitNumber % VmwareHelper.MAX_ALLOWED_DEVICES_SCSI_CONTROLLER;\n                        scsiUnitNumber++;\n                    }\n\n                    VirtualDevice device = VmwareHelper.prepareDiskDevice(vmMo, null, controllerKey, diskChain, volumeDsDetails.first(), deviceNumber, i + 1);\n\n                    diskStoragePolicyId = volumeTO.getvSphereStoragePolicyId();\n                    if (!StringUtils.isEmpty(diskStoragePolicyId)) {\n                        PbmProfileManagerMO profMgrMo = new PbmProfileManagerMO(context);\n                        diskProfileSpec = profMgrMo.getProfileSpec(diskStoragePolicyId);\n                        deviceConfigSpecArray[i].getProfile().add(diskProfileSpec);\n                        if (s_logger.isDebugEnabled()) {\n                            s_logger.debug(String.format(\"Adding vSphere storage profile: %s to virtual disk [%s]\", diskStoragePolicyId, _gson.toJson(device)));\n                        }\n                    }\n                    if (vol.getType() == Volume.Type.ROOT) {\n                        rootDiskTO = vol;\n                        vmStoragePolicyId = diskStoragePolicyId;\n                        vmProfileSpec = diskProfileSpec;\n                    }\n                    deviceConfigSpecArray[i].setDevice(device);\n                    deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n\n                    if (s_logger.isDebugEnabled())\n                        s_logger.debug(\"Prepare volume at new device \" + _gson.toJson(device));\n\n                    i++;\n                } else {\n                    if (controllerKey == vmMo.getIDEControllerKey(ideUnitNumber))\n                        ideUnitNumber++;\n                    else\n                        scsiUnitNumber++;\n                }\n            }\n\n            \r\n            \r\n            \r\n            if (StringUtils.isNotBlank(guestOsId) && guestOsId.startsWith(\"darwin\")) { \r\n                VirtualDevice[] devices = vmMo.getMatchedDevices(new Class<?>[]{VirtualUSBController.class});\n                if (devices.length == 0) {\n                    s_logger.debug(\"No USB Controller device on VM Start. Add USB Controller device for Mac OS VM \" + vmInternalCSName);\n\n                    \r\n                    VirtualDevice usbControllerDevice = VmwareHelper.prepareUSBControllerDevice();\n                    deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n                    deviceConfigSpecArray[i].setDevice(usbControllerDevice);\n                    deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n\n                    if (s_logger.isDebugEnabled())\n                        s_logger.debug(\"Prepare USB controller at new device \" + _gson.toJson(deviceConfigSpecArray[i]));\n\n                    i++;\n                } else {\n                    s_logger.debug(\"USB Controller device exists on VM Start for Mac OS VM \" + vmInternalCSName);\n                }\n            }\n\n            \r\n            \r\n            \r\n            VirtualDevice nic;\n            int nicMask = 0;\n            int nicCount = 0;\n\n            if (vmSpec.getType() == VirtualMachine.Type.DomainRouter) {\n                int extraPublicNics = mgr.getRouterExtraPublicNics();\n                if (extraPublicNics > 0 && vmSpec.getDetails().containsKey(\"PeerRouterInstanceName\")) {\n                    \r\n                    String peerRouterInstanceName = vmSpec.getDetails().get(\"PeerRouterInstanceName\");\n\n                    VirtualMachineMO peerVmMo = hyperHost.findVmOnHyperHost(peerRouterInstanceName);\n                    if (peerVmMo == null) {\n                        peerVmMo = hyperHost.findVmOnPeerHyperHost(peerRouterInstanceName);\n                    }\n\n                    if (peerVmMo != null) {\n                        String oldMacSequence = generateMacSequence(nics);\n\n                        for (int nicIndex = nics.length - extraPublicNics; nicIndex < nics.length; nicIndex++) {\n                            VirtualDevice nicDevice = peerVmMo.getNicDeviceByIndex(nics[nicIndex].getDeviceId());\n                            if (nicDevice != null) {\n                                String mac = ((VirtualEthernetCard) nicDevice).getMacAddress();\n                                if (mac != null) {\n                                    s_logger.info(\"Use same MAC as previous RvR, the MAC is \" + mac + \" for extra NIC with device id: \" + nics[nicIndex].getDeviceId());\n                                    nics[nicIndex].setMac(mac);\n                                }\n                            }\n                        }\n\n                        if (!StringUtils.isBlank(vmSpec.getBootArgs())) {\n                            String newMacSequence = generateMacSequence(nics);\n                            vmSpec.setBootArgs(replaceNicsMacSequenceInBootArgs(oldMacSequence, newMacSequence, vmSpec));\n                        }\n                    }\n                }\n            }\n\n            VirtualEthernetCardType nicDeviceType;\n\n            NiciraNvpApiVersion.logNiciraApiVersion();\n\n            Map<String, String> nicUuidToDvSwitchUuid = new HashMap<String, String>();\n            for (NicTO nicTo : sortNicsByDeviceId(nics)) {\n                s_logger.info(\"Prepare NIC device based on NicTO: \" + _gson.toJson(nicTo));\n\n                String adapterTypeStr = deployAsIs ?\n                        mapAdapterType(deployAsIsInfo.getNicAdapterMap().get(nicTo.getDeviceId())) :\n                        vmSpec.getDetails().get(VmDetailConstants.NIC_ADAPTER);\n                nicDeviceType = VirtualEthernetCardType.valueOf(adapterTypeStr);\n\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"VM \" + vmInternalCSName + \" will be started with NIC device type: \" + nicDeviceType + \" on NIC device \" + nicTo.getDeviceId());\n                }\n                boolean configureVServiceInNexus = (nicTo.getType() == TrafficType.Guest) && (vmSpec.getDetails().containsKey(\"ConfigureVServiceInNexus\"));\n                VirtualMachine.Type vmType = cmd.getVirtualMachine().getType();\n                Pair<ManagedObjectReference, String> networkInfo = prepareNetworkFromNicInfo(vmMo.getRunningHost(), nicTo, configureVServiceInNexus, vmType);\n                if ((nicTo.getBroadcastType() != BroadcastDomainType.Lswitch)\n                        || (nicTo.getBroadcastType() == BroadcastDomainType.Lswitch && NiciraNvpApiVersion.isApiVersionLowerThan(\"4.2\"))) {\n                    if (VmwareHelper.isDvPortGroup(networkInfo.first())) {\n                        String dvSwitchUuid;\n                        ManagedObjectReference dcMor = hyperHost.getHyperHostDatacenter();\n                        DatacenterMO dataCenterMo = new DatacenterMO(context, dcMor);\n                        ManagedObjectReference dvsMor = dataCenterMo.getDvSwitchMor(networkInfo.first());\n                        dvSwitchUuid = dataCenterMo.getDvSwitchUuid(dvsMor);\n                        s_logger.info(\"Preparing NIC device on dvSwitch : \" + dvSwitchUuid);\n                        nic = VmwareHelper.prepareDvNicDevice(vmMo, networkInfo.first(), nicDeviceType, networkInfo.second(), dvSwitchUuid,\n                                nicTo.getMac(), i + 1, true, true);\n                        if (nicTo.getUuid() != null) {\n                            nicUuidToDvSwitchUuid.put(nicTo.getUuid(), dvSwitchUuid);\n                        }\n                    } else {\n                        s_logger.info(\"Preparing NIC device on network \" + networkInfo.second());\n                        nic = VmwareHelper.prepareNicDevice(vmMo, networkInfo.first(), nicDeviceType, networkInfo.second(),\n                                nicTo.getMac(), i + 1, true, true);\n                    }\n                } else {\n                    \r\n                    nic = VmwareHelper.prepareNicOpaque(vmMo, nicDeviceType, networkInfo.second(),\n                            nicTo.getMac(), i + 1, true, true);\n                }\n\n                deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n                deviceConfigSpecArray[i].setDevice(nic);\n                deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n\n                if (s_logger.isDebugEnabled())\n                    s_logger.debug(\"Prepare NIC at new device \" + _gson.toJson(deviceConfigSpecArray[i]));\n\n                \r\n                if (nicCount < 3)\n                    nicMask |= (1 << nicCount);\n\n                i++;\n                nicCount++;\n            }\n\n            for (int j = 0; j < i; j++)\n                vmConfigSpec.getDeviceChange().add(deviceConfigSpecArray[j]);\n\n            \r\n            \r\n            \r\n\n            \r\n            ArrayList<OptionValue> extraOptions = new ArrayList<OptionValue>();\n            configBasicExtraOption(extraOptions, vmSpec);\n\n            if (deployAsIs) {\n                setDeployAsIsProperties(vmMo, deployAsIsInfo, vmConfigSpec, hyperHost);\n            }\n\n            configNvpExtraOption(extraOptions, vmSpec, nicUuidToDvSwitchUuid);\n            configCustomExtraOption(extraOptions, vmSpec);\n\n            \r\n            VirtualMachine.Type vmType = cmd.getVirtualMachine().getType();\n            if (vmType.equals(VirtualMachine.Type.NetScalerVm)) {\n                NicTO mgmtNic = vmSpec.getNics()[0];\n                OptionValue option = new OptionValue();\n                option.setKey(\"machine.id\");\n                option.setValue(\"ip=\" + mgmtNic.getIp() + \"&netmask=\" + mgmtNic.getNetmask() + \"&gateway=\" + mgmtNic.getGateway());\n                extraOptions.add(option);\n            }\n\n            configureVNC(vmSpec, extraOptions, vmConfigSpec, hyperHost, vmInternalCSName);\n\n            \r\n            configureVideoCard(vmMo, vmSpec, vmConfigSpec);\n\n            setBootOptions(vmSpec, bootMode, vmConfigSpec);\n\n            if (!StringUtils.isEmpty(vmStoragePolicyId)) {\n                vmConfigSpec.getVmProfile().add(vmProfileSpec);\n                if (s_logger.isTraceEnabled()) {\n                    s_logger.trace(String.format(\"Configuring the VM %s with storage policy: %s\", vmInternalCSName, vmStoragePolicyId));\n                }\n            }\n            \r\n            \r\n            \r\n            if (!vmMo.configureVm(vmConfigSpec)) {\n                throw new Exception(\"Failed to configure VM before start. vmName: \" + vmInternalCSName);\n            }\n\n            if (vmSpec.getType() == VirtualMachine.Type.DomainRouter) {\n                hyperHost.setRestartPriorityForVM(vmMo, DasVmPriority.HIGH.value());\n            }\n\n            \r\n            final Map<String, String> vmDetails = cmd.getVirtualMachine().getDetails();\n            if (!deployAsIs && rootDiskTO != null && !hasSnapshot && (vmDetails != null && vmDetails.containsKey(ApiConstants.ROOT_DISK_SIZE))) {\n                resizeRootDiskOnVMStart(vmMo, rootDiskTO, hyperHost, context);\n            }\n\n            \r\n            \r\n            \r\n\n            vmMo.setCustomFieldValue(CustomFieldConstants.CLOUD_NIC_MASK, String.valueOf(nicMask));\n            postNvpConfigBeforeStart(vmMo, vmSpec);\n\n            Map<String, Map<String, String>> iqnToData = new HashMap<>();\n\n            postDiskConfigBeforeStart(vmMo, vmSpec, sortedDisks, ideControllerKey, scsiControllerKey, iqnToData, hyperHost, context);\n\n            \r\n            \r\n            \r\n            if (!vmMo.powerOn()) {\n                throw new Exception(\"Failed to start VM. vmName: \" + vmInternalCSName + \" with hostname \" + vmNameOnVcenter);\n            }\n\n            StartAnswer startAnswer = new StartAnswer(cmd);\n\n            startAnswer.setIqnToData(iqnToData);\n\n            \r\n            if (existingVmName != null && existingVmFileLayout != null) {\n                List<String> vmDatastoreNames = new ArrayList<String>();\n                for (DatastoreMO vmDatastore : vmMo.getAllDatastores()) {\n                    vmDatastoreNames.add(vmDatastore.getName());\n                }\n                \r\n                List<String> skipDatastores = new ArrayList<String>();\n                for (DatastoreMO existingDatastore : existingDatastores) {\n                    if (vmDatastoreNames.contains(existingDatastore.getName())) {\n                        skipDatastores.add(existingDatastore.getName());\n                    }\n                }\n                deleteUnregisteredVmFiles(existingVmFileLayout, dcMo, true, skipDatastores);\n            }\n\n            return startAnswer;\n        } catch (Throwable e) {\n            if (e instanceof RemoteException) {\n                s_logger.warn(\"Encounter remote exception to vCenter, invalidate VMware session context\");\n                invalidateServiceContext();\n            }\n\n            String msg = \"StartCommand failed due to \" + VmwareHelper.getExceptionMessage(e);\n            s_logger.warn(msg, e);\n            StartAnswer startAnswer = new StartAnswer(cmd, msg);\n            if (vmAlreadyExistsInVcenter) {\n                startAnswer.setContextParam(\"stopRetry\", \"true\");\n            }\n\n            \r\n            if (existingVmName != null && existingVmFileInfo != null) {\n                s_logger.debug(\"Since VM start failed, registering back an existing VM: \" + existingVmName + \" that was unregistered\");\n                try {\n                    DatastoreFile fileInDatastore = new DatastoreFile(existingVmFileInfo.getVmPathName());\n                    DatastoreMO existingVmDsMo = new DatastoreMO(dcMo.getContext(), dcMo.findDatastore(fileInDatastore.getDatastoreName()));\n                    registerVm(existingVmName, existingVmDsMo);\n                } catch (Exception ex) {\n                    String message = \"Failed to register an existing VM: \" + existingVmName + \" due to \" + VmwareHelper.getExceptionMessage(ex);\n                    s_logger.warn(message, ex);\n                }\n            }\n\n            return startAnswer;\n        } finally {\n        }\n    }\n","realPath":"plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/vmware/resource/VmwareResource.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1775,"status":"M"},{"authorDate":"2021-04-30 00:20:40","commitOrder":15,"curCode":"    private void configureIso(VmwareHypervisorHost hyperHost, VirtualMachineMO vmMo, DiskTO vol,\n                              VirtualDeviceConfigSpec[] deviceConfigSpecArray, int ideUnitNumber, int i) throws Exception {\n        TemplateObjectTO iso = (TemplateObjectTO) vol.getData();\n\n        if (iso.getPath() != null && !iso.getPath().isEmpty()) {\n            DataStoreTO imageStore = iso.getDataStore();\n            if (!(imageStore instanceof NfsTO)) {\n                s_logger.debug(\"unsupported protocol\");\n                throw new Exception(\"unsupported protocol\");\n            }\n            NfsTO nfsImageStore = (NfsTO) imageStore;\n            String isoPath = nfsImageStore.getUrl() + File.separator + iso.getPath();\n            Pair<String, ManagedObjectReference> isoDatastoreInfo = getIsoDatastoreInfo(hyperHost, isoPath);\n            assert (isoDatastoreInfo != null);\n            assert (isoDatastoreInfo.second() != null);\n\n            deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n            Pair<VirtualDevice, Boolean> isoInfo =\n                    VmwareHelper.prepareIsoDevice(vmMo, isoDatastoreInfo.first(), isoDatastoreInfo.second(), true, true, ideUnitNumber, i + 1);\n            deviceConfigSpecArray[i].setDevice(isoInfo.first());\n            if (isoInfo.second()) {\n                if (s_logger.isDebugEnabled())\n                    s_logger.debug(\"Prepare ISO volume at new device \" + _gson.toJson(isoInfo.first()));\n                deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n            } else {\n                if (s_logger.isDebugEnabled())\n                    s_logger.debug(\"Prepare ISO volume at existing device \" + _gson.toJson(isoInfo.first()));\n                deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.EDIT);\n            }\n        }\n    }\n","date":"2021-04-30 00:20:40","endLine":2497,"groupId":"122980","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"configureIso","params":"(VmwareHypervisorHosthyperHost@VirtualMachineMOvmMo@DiskTOvol@VirtualDeviceConfigSpec[]deviceConfigSpecArray@intideUnitNumber@inti)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/20/35cc736ade3abdc2efce433dd904fa383c5f6a.src","preCode":"    private void configureIso(VmwareHypervisorHost hyperHost, VirtualMachineMO vmMo, DiskTO vol,\n                              VirtualDeviceConfigSpec[] deviceConfigSpecArray, int ideUnitNumber, int i) throws Exception {\n        TemplateObjectTO iso = (TemplateObjectTO) vol.getData();\n\n        if (iso.getPath() != null && !iso.getPath().isEmpty()) {\n            DataStoreTO imageStore = iso.getDataStore();\n            if (!(imageStore instanceof NfsTO)) {\n                s_logger.debug(\"unsupported protocol\");\n                throw new Exception(\"unsupported protocol\");\n            }\n            NfsTO nfsImageStore = (NfsTO) imageStore;\n            String isoPath = nfsImageStore.getUrl() + File.separator + iso.getPath();\n            Pair<String, ManagedObjectReference> isoDatastoreInfo = getIsoDatastoreInfo(hyperHost, isoPath);\n            assert (isoDatastoreInfo != null);\n            assert (isoDatastoreInfo.second() != null);\n\n            deviceConfigSpecArray[i] = new VirtualDeviceConfigSpec();\n            Pair<VirtualDevice, Boolean> isoInfo =\n                    VmwareHelper.prepareIsoDevice(vmMo, isoDatastoreInfo.first(), isoDatastoreInfo.second(), true, true, ideUnitNumber, i + 1);\n            deviceConfigSpecArray[i].setDevice(isoInfo.first());\n            if (isoInfo.second()) {\n                if (s_logger.isDebugEnabled())\n                    s_logger.debug(\"Prepare ISO volume at new device \" + _gson.toJson(isoInfo.first()));\n                deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.ADD);\n            } else {\n                if (s_logger.isDebugEnabled())\n                    s_logger.debug(\"Prepare ISO volume at existing device \" + _gson.toJson(isoInfo.first()));\n                deviceConfigSpecArray[i].setOperation(VirtualDeviceConfigSpecOperation.EDIT);\n            }\n        }\n    }\n","realPath":"plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/vmware/resource/VmwareResource.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":2467,"status":"N"}],"commitId":"1bfb2f9fb15b0e547e0958fb9f37d8c1012aaacb","commitMessage":"@@@disable hot add memory and cpu via vm settings (#4630)\n\n* disable hot add memory and cpu via vm settings\n\n* add alternative implementation for hot add memory and cpu\n\n* add log entry\n\n* Modify and add log entry for hotadd\n\n* Update plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/vmware/resource/VmwareResource.java\n\nCo-authored-by: sureshanaparti <12028987+sureshanaparti@users.noreply.github.com>\n\n* Update plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/vmware/resource/VmwareResource.java\n\nCo-authored-by: sureshanaparti <12028987+sureshanaparti@users.noreply.github.com>\n\nCo-authored-by: DK101010 <dirk.klahre@itelligence.de>\nCo-authored-by: sureshanaparti <12028987+sureshanaparti@users.noreply.github.com>","date":"2021-08-13 22:54:06","modifiedFileCount":"1","status":"M","submitter":"DK101010"}]
