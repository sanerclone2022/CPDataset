[{"authorTime":"2020-02-07 22:43:01","codes":[{"authorDate":"2020-06-26 19:31:43","commitOrder":4,"curCode":"    private void postProcessingUnmanageVMVolumes(List<VolumeVO> volumes, UserVmVO vm) {\n        for (VolumeVO volume : volumes) {\n            if (volume.getVolumeType() == Volume.Type.ROOT) {\n                \r\n                UsageEventUtils.publishUsageEvent(EventTypes.EVENT_VOLUME_DELETE, volume.getAccountId(), volume.getDataCenterId(), volume.getId(), volume.getName(),\n                        Volume.class.getName(), volume.getUuid(), volume.isDisplayVolume());\n            }\n            _resourceLimitMgr.decrementResourceCount(vm.getAccountId(), ResourceType.volume);\n            _resourceLimitMgr.decrementResourceCount(vm.getAccountId(), ResourceType.primary_storage, new Long(volume.getSize()));\n        }\n    }\n","date":"2020-06-26 19:31:43","endLine":7236,"groupId":"8118","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"postProcessingUnmanageVMVolumes","params":"(List<VolumeVO>volumes@UserVmVOvm)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/4e/620443b0d6697027b553a81f854f05cd52e72f.src","preCode":"    private void postProcessingUnmanageVMVolumes(List<VolumeVO> volumes, UserVmVO vm) {\n        for (VolumeVO volume : volumes) {\n            if (volume.getVolumeType() == Volume.Type.ROOT) {\n                \r\n                UsageEventUtils.publishUsageEvent(EventTypes.EVENT_VOLUME_DELETE, volume.getAccountId(), volume.getDataCenterId(), volume.getId(), volume.getName(),\n                        Volume.class.getName(), volume.getUuid(), volume.isDisplayVolume());\n            }\n            _resourceLimitMgr.decrementResourceCount(vm.getAccountId(), ResourceType.volume);\n            _resourceLimitMgr.decrementResourceCount(vm.getAccountId(), ResourceType.primary_storage, new Long(volume.getSize()));\n        }\n    }\n","realPath":"server/src/main/java/com/cloud/vm/UserVmManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":7226,"status":"B"},{"authorDate":"2020-02-07 22:43:01","commitOrder":4,"curCode":"    public boolean associateIpAddressListToAccount(long userId, final long accountId, final long zoneId, final Long vlanId, final Network guestNetworkFinal)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException, ResourceAllocationException {\n        final Account owner = _accountMgr.getActiveAccountById(accountId);\n\n        if (guestNetworkFinal != null && guestNetworkFinal.getTrafficType() != TrafficType.Guest) {\n            throw new InvalidParameterValueException(\"Network \" + guestNetworkFinal + \" is not of a type \" + TrafficType.Guest);\n        }\n\n        Ternary<Boolean, List<NetworkOfferingVO>, Network> pair = null;\n        try {\n            pair = Transaction.execute(new TransactionCallbackWithException<Ternary<Boolean, List<NetworkOfferingVO>, Network>, Exception>() {\n                @Override\n                public Ternary<Boolean, List<NetworkOfferingVO>, Network> doInTransaction(TransactionStatus status) throws InsufficientCapacityException,\n                        ResourceAllocationException {\n                    boolean createNetwork = false;\n                    Network guestNetwork = guestNetworkFinal;\n\n                    if (guestNetwork == null) {\n                        List<? extends Network> networks = getIsolatedNetworksWithSourceNATOwnedByAccountInZone(zoneId, owner);\n                        if (networks.size() == 0) {\n                            createNetwork = true;\n                        } else if (networks.size() == 1) {\n                            guestNetwork = networks.get(0);\n                        } else {\n                            throw new InvalidParameterValueException(\"Error, more than 1 Guest Isolated Networks with SourceNAT \"\n                                    + \"service enabled found for this account, cannot assosiate the IP range, please provide the network ID\");\n                        }\n                    }\n\n                    \r\n                    List<NetworkOfferingVO> requiredOfferings = _networkOfferingDao.listByAvailability(Availability.Required, false);\n                    if (requiredOfferings.size() < 1) {\n                        throw new CloudRuntimeException(\"Unable to find network offering with availability=\" + Availability.Required\n                                + \" to automatically create the network as part of createVlanIpRange\");\n                    }\n                    if (createNetwork) {\n                        if (requiredOfferings.get(0).getState() == NetworkOffering.State.Enabled) {\n                            long physicalNetworkId = _networkModel.findPhysicalNetworkId(zoneId, requiredOfferings.get(0).getTags(), requiredOfferings.get(0).getTrafficType());\n                            \r\n                            PhysicalNetwork physicalNetwork = _physicalNetworkDao.findById(physicalNetworkId);\n                            if (physicalNetwork == null) {\n                                throw new InvalidParameterValueException(\"Unable to find physical network with id: \" + physicalNetworkId + \" and tag: \"\n                                        + requiredOfferings.get(0).getTags());\n                            }\n\n                            s_logger.debug(\"Creating network for account \" + owner + \" from the network offering id=\" + requiredOfferings.get(0).getId()\n                                    + \" as a part of createVlanIpRange process\");\n                            guestNetwork = _networkMgr.createGuestNetwork(requiredOfferings.get(0).getId(), owner.getAccountName() + \"-network\", owner.getAccountName()\n                                    + \"-network\", null, null, null, false, null, owner, null, physicalNetwork, zoneId, ACLType.Account, null, null, null, null, true, null, null, null);\n                            if (guestNetwork == null) {\n                                s_logger.warn(\"Failed to create default Virtual network for the account \" + accountId + \"in zone \" + zoneId);\n                                throw new CloudRuntimeException(\"Failed to create a Guest Isolated Networks with SourceNAT \"\n                                        + \"service enabled as a part of createVlanIpRange, for the account \" + accountId + \"in zone \" + zoneId);\n                            }\n                        } else {\n                            throw new CloudRuntimeException(\"Required network offering id=\" + requiredOfferings.get(0).getId() + \" is not in \" + NetworkOffering.State.Enabled);\n                        }\n                    }\n\n                    \r\n                    boolean allocateSourceNat = false;\n                    List<IPAddressVO> sourceNat = _ipAddressDao.listByAssociatedNetwork(guestNetwork.getId(), true);\n                    if (sourceNat.isEmpty()) {\n                        allocateSourceNat = true;\n                    }\n\n                    \r\n                    List<IPAddressVO> ips = _ipAddressDao.listByVlanId(vlanId);\n                    boolean isSourceNatAllocated = false;\n                    for (IPAddressVO addr : ips) {\n                        if (addr.getState() != State.Allocated) {\n                            if (!isSourceNatAllocated && allocateSourceNat) {\n                                addr.setSourceNat(true);\n                                isSourceNatAllocated = true;\n                            } else {\n                                addr.setSourceNat(false);\n                            }\n                            addr.setAssociatedWithNetworkId(guestNetwork.getId());\n                            addr.setVpcId(guestNetwork.getVpcId());\n                            addr.setAllocatedTime(new Date());\n                            addr.setAllocatedInDomainId(owner.getDomainId());\n                            addr.setAllocatedToAccountId(owner.getId());\n                            addr.setSystem(false);\n                            addr.setState(IpAddress.State.Allocating);\n                            markPublicIpAsAllocated(addr);\n                        }\n                    }\n                    return new Ternary<Boolean, List<NetworkOfferingVO>, Network>(createNetwork, requiredOfferings, guestNetwork);\n                }\n            });\n        } catch (Exception e1) {\n            ExceptionUtil.rethrowRuntime(e1);\n            ExceptionUtil.rethrow(e1, InsufficientCapacityException.class);\n            ExceptionUtil.rethrow(e1, ResourceAllocationException.class);\n            throw new IllegalStateException(e1);\n        }\n\n        boolean createNetwork = pair.first();\n        List<NetworkOfferingVO> requiredOfferings = pair.second();\n        Network guestNetwork = pair.third();\n\n        \r\n        if (createNetwork && requiredOfferings.get(0).isPersistent()) {\n            DataCenter zone = _dcDao.findById(zoneId);\n            DeployDestination dest = new DeployDestination(zone, null, null, null);\n            Account callerAccount = CallContext.current().getCallingAccount();\n            UserVO callerUser = _userDao.findById(CallContext.current().getCallingUserId());\n            Journal journal = new Journal.LogJournal(\"Implementing \" + guestNetwork, s_logger);\n            ReservationContext context = new ReservationContextImpl(UUID.randomUUID().toString(), journal, callerUser, callerAccount);\n            s_logger.debug(\"Implementing network \" + guestNetwork + \" as a part of network provision for persistent network\");\n            try {\n                Pair<? extends NetworkGuru, ? extends Network> implementedNetwork = _networkMgr.implementNetwork(guestNetwork.getId(), dest, context);\n                if (implementedNetwork == null || implementedNetwork.first() == null) {\n                    s_logger.warn(\"Failed to implement the network \" + guestNetwork);\n                }\n                if (implementedNetwork != null) {\n                    guestNetwork = implementedNetwork.second();\n                }\n            } catch (Exception ex) {\n                s_logger.warn(\"Failed to implement network \" + guestNetwork + \" elements and resources as a part of\" + \" network provision due to \", ex);\n                CloudRuntimeException e = new CloudRuntimeException(\"Failed to implement network (with specified id)\"\n                        + \" elements and resources as a part of network provision for persistent network\");\n                e.addProxyObject(guestNetwork.getUuid(), \"networkId\");\n                throw e;\n            }\n        }\n        return true;\n    }\n","date":"2020-02-07 22:43:01","endLine":1775,"groupId":"22576","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"associateIpAddressListToAccount","params":"(longuserId@finallongaccountId@finallongzoneId@finalLongvlanId@finalNetworkguestNetworkFinal)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/40/9b88f53c4f7f7169b29b7434b37dfee9c79a5c.src","preCode":"    public boolean associateIpAddressListToAccount(long userId, final long accountId, final long zoneId, final Long vlanId, final Network guestNetworkFinal)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException, ResourceAllocationException {\n        final Account owner = _accountMgr.getActiveAccountById(accountId);\n\n        if (guestNetworkFinal != null && guestNetworkFinal.getTrafficType() != TrafficType.Guest) {\n            throw new InvalidParameterValueException(\"Network \" + guestNetworkFinal + \" is not of a type \" + TrafficType.Guest);\n        }\n\n        Ternary<Boolean, List<NetworkOfferingVO>, Network> pair = null;\n        try {\n            pair = Transaction.execute(new TransactionCallbackWithException<Ternary<Boolean, List<NetworkOfferingVO>, Network>, Exception>() {\n                @Override\n                public Ternary<Boolean, List<NetworkOfferingVO>, Network> doInTransaction(TransactionStatus status) throws InsufficientCapacityException,\n                        ResourceAllocationException {\n                    boolean createNetwork = false;\n                    Network guestNetwork = guestNetworkFinal;\n\n                    if (guestNetwork == null) {\n                        List<? extends Network> networks = getIsolatedNetworksWithSourceNATOwnedByAccountInZone(zoneId, owner);\n                        if (networks.size() == 0) {\n                            createNetwork = true;\n                        } else if (networks.size() == 1) {\n                            guestNetwork = networks.get(0);\n                        } else {\n                            throw new InvalidParameterValueException(\"Error, more than 1 Guest Isolated Networks with SourceNAT \"\n                                    + \"service enabled found for this account, cannot assosiate the IP range, please provide the network ID\");\n                        }\n                    }\n\n                    \r\n                    List<NetworkOfferingVO> requiredOfferings = _networkOfferingDao.listByAvailability(Availability.Required, false);\n                    if (requiredOfferings.size() < 1) {\n                        throw new CloudRuntimeException(\"Unable to find network offering with availability=\" + Availability.Required\n                                + \" to automatically create the network as part of createVlanIpRange\");\n                    }\n                    if (createNetwork) {\n                        if (requiredOfferings.get(0).getState() == NetworkOffering.State.Enabled) {\n                            long physicalNetworkId = _networkModel.findPhysicalNetworkId(zoneId, requiredOfferings.get(0).getTags(), requiredOfferings.get(0).getTrafficType());\n                            \r\n                            PhysicalNetwork physicalNetwork = _physicalNetworkDao.findById(physicalNetworkId);\n                            if (physicalNetwork == null) {\n                                throw new InvalidParameterValueException(\"Unable to find physical network with id: \" + physicalNetworkId + \" and tag: \"\n                                        + requiredOfferings.get(0).getTags());\n                            }\n\n                            s_logger.debug(\"Creating network for account \" + owner + \" from the network offering id=\" + requiredOfferings.get(0).getId()\n                                    + \" as a part of createVlanIpRange process\");\n                            guestNetwork = _networkMgr.createGuestNetwork(requiredOfferings.get(0).getId(), owner.getAccountName() + \"-network\", owner.getAccountName()\n                                    + \"-network\", null, null, null, false, null, owner, null, physicalNetwork, zoneId, ACLType.Account, null, null, null, null, true, null, null, null);\n                            if (guestNetwork == null) {\n                                s_logger.warn(\"Failed to create default Virtual network for the account \" + accountId + \"in zone \" + zoneId);\n                                throw new CloudRuntimeException(\"Failed to create a Guest Isolated Networks with SourceNAT \"\n                                        + \"service enabled as a part of createVlanIpRange, for the account \" + accountId + \"in zone \" + zoneId);\n                            }\n                        } else {\n                            throw new CloudRuntimeException(\"Required network offering id=\" + requiredOfferings.get(0).getId() + \" is not in \" + NetworkOffering.State.Enabled);\n                        }\n                    }\n\n                    \r\n                    boolean allocateSourceNat = false;\n                    List<IPAddressVO> sourceNat = _ipAddressDao.listByAssociatedNetwork(guestNetwork.getId(), true);\n                    if (sourceNat.isEmpty()) {\n                        allocateSourceNat = true;\n                    }\n\n                    \r\n                    List<IPAddressVO> ips = _ipAddressDao.listByVlanId(vlanId);\n                    boolean isSourceNatAllocated = false;\n                    for (IPAddressVO addr : ips) {\n                        if (addr.getState() != State.Allocated) {\n                            if (!isSourceNatAllocated && allocateSourceNat) {\n                                addr.setSourceNat(true);\n                                isSourceNatAllocated = true;\n                            } else {\n                                addr.setSourceNat(false);\n                            }\n                            addr.setAssociatedWithNetworkId(guestNetwork.getId());\n                            addr.setVpcId(guestNetwork.getVpcId());\n                            addr.setAllocatedTime(new Date());\n                            addr.setAllocatedInDomainId(owner.getDomainId());\n                            addr.setAllocatedToAccountId(owner.getId());\n                            addr.setSystem(false);\n                            addr.setState(IpAddress.State.Allocating);\n                            markPublicIpAsAllocated(addr);\n                        }\n                    }\n                    return new Ternary<Boolean, List<NetworkOfferingVO>, Network>(createNetwork, requiredOfferings, guestNetwork);\n                }\n            });\n        } catch (Exception e1) {\n            ExceptionUtil.rethrowRuntime(e1);\n            ExceptionUtil.rethrow(e1, InsufficientCapacityException.class);\n            ExceptionUtil.rethrow(e1, ResourceAllocationException.class);\n            throw new IllegalStateException(e1);\n        }\n\n        boolean createNetwork = pair.first();\n        List<NetworkOfferingVO> requiredOfferings = pair.second();\n        Network guestNetwork = pair.third();\n\n        \r\n        if (createNetwork && requiredOfferings.get(0).isPersistent()) {\n            DataCenter zone = _dcDao.findById(zoneId);\n            DeployDestination dest = new DeployDestination(zone, null, null, null);\n            Account callerAccount = CallContext.current().getCallingAccount();\n            UserVO callerUser = _userDao.findById(CallContext.current().getCallingUserId());\n            Journal journal = new Journal.LogJournal(\"Implementing \" + guestNetwork, s_logger);\n            ReservationContext context = new ReservationContextImpl(UUID.randomUUID().toString(), journal, callerUser, callerAccount);\n            s_logger.debug(\"Implementing network \" + guestNetwork + \" as a part of network provision for persistent network\");\n            try {\n                Pair<? extends NetworkGuru, ? extends Network> implementedNetwork = _networkMgr.implementNetwork(guestNetwork.getId(), dest, context);\n                if (implementedNetwork == null || implementedNetwork.first() == null) {\n                    s_logger.warn(\"Failed to implement the network \" + guestNetwork);\n                }\n                if (implementedNetwork != null) {\n                    guestNetwork = implementedNetwork.second();\n                }\n            } catch (Exception ex) {\n                s_logger.warn(\"Failed to implement network \" + guestNetwork + \" elements and resources as a part of\" + \" network provision due to \", ex);\n                CloudRuntimeException e = new CloudRuntimeException(\"Failed to implement network (with specified id)\"\n                        + \" elements and resources as a part of network provision for persistent network\");\n                e.addProxyObject(guestNetwork.getUuid(), \"networkId\");\n                throw e;\n            }\n        }\n        return true;\n    }\n","realPath":"server/src/main/java/com/cloud/network/IpAddressManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1648,"status":"NB"}],"commitId":"8c1d749360657a4909c558c3df5dec57ca66c977","commitMessage":"@@@[VMware] Enable unmanaging guest VMs (#4103)\n\n* Enable unmanaging guest VMs\n\n* Minor fixes\n\n* Fix stop usage event only if VM is not stopped when unmanaging\n\n* Rename unmanaged VMs manager\n\n* Generate netofferingremove usage event if VM is not stopped\n\n* Generate usage event VM snapshot primary off when unmanaging","date":"2020-06-26 19:31:43","modifiedFileCount":"28","status":"M","submitter":"Nicolas Vazquez"},{"authorTime":"2021-02-18 16:24:09","codes":[{"authorDate":"2020-06-26 19:31:43","commitOrder":5,"curCode":"    private void postProcessingUnmanageVMVolumes(List<VolumeVO> volumes, UserVmVO vm) {\n        for (VolumeVO volume : volumes) {\n            if (volume.getVolumeType() == Volume.Type.ROOT) {\n                \r\n                UsageEventUtils.publishUsageEvent(EventTypes.EVENT_VOLUME_DELETE, volume.getAccountId(), volume.getDataCenterId(), volume.getId(), volume.getName(),\n                        Volume.class.getName(), volume.getUuid(), volume.isDisplayVolume());\n            }\n            _resourceLimitMgr.decrementResourceCount(vm.getAccountId(), ResourceType.volume);\n            _resourceLimitMgr.decrementResourceCount(vm.getAccountId(), ResourceType.primary_storage, new Long(volume.getSize()));\n        }\n    }\n","date":"2020-06-26 19:31:43","endLine":7236,"groupId":"101356","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"postProcessingUnmanageVMVolumes","params":"(List<VolumeVO>volumes@UserVmVOvm)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/4e/620443b0d6697027b553a81f854f05cd52e72f.src","preCode":"    private void postProcessingUnmanageVMVolumes(List<VolumeVO> volumes, UserVmVO vm) {\n        for (VolumeVO volume : volumes) {\n            if (volume.getVolumeType() == Volume.Type.ROOT) {\n                \r\n                UsageEventUtils.publishUsageEvent(EventTypes.EVENT_VOLUME_DELETE, volume.getAccountId(), volume.getDataCenterId(), volume.getId(), volume.getName(),\n                        Volume.class.getName(), volume.getUuid(), volume.isDisplayVolume());\n            }\n            _resourceLimitMgr.decrementResourceCount(vm.getAccountId(), ResourceType.volume);\n            _resourceLimitMgr.decrementResourceCount(vm.getAccountId(), ResourceType.primary_storage, new Long(volume.getSize()));\n        }\n    }\n","realPath":"server/src/main/java/com/cloud/vm/UserVmManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":7226,"status":"N"},{"authorDate":"2021-02-18 16:24:09","commitOrder":5,"curCode":"    public boolean associateIpAddressListToAccount(long userId, final long accountId, final long zoneId, final Long vlanId, final Network guestNetworkFinal)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException, ResourceAllocationException {\n        final Account owner = _accountMgr.getActiveAccountById(accountId);\n\n        if (guestNetworkFinal != null && guestNetworkFinal.getTrafficType() != TrafficType.Guest) {\n            throw new InvalidParameterValueException(\"Network \" + guestNetworkFinal + \" is not of a type \" + TrafficType.Guest);\n        }\n\n        Ternary<Boolean, List<NetworkOfferingVO>, Network> pair = null;\n        try {\n            pair = Transaction.execute(new TransactionCallbackWithException<Ternary<Boolean, List<NetworkOfferingVO>, Network>, Exception>() {\n                @Override\n                public Ternary<Boolean, List<NetworkOfferingVO>, Network> doInTransaction(TransactionStatus status) throws InsufficientCapacityException,\n                        ResourceAllocationException {\n                    boolean createNetwork = false;\n                    Network guestNetwork = guestNetworkFinal;\n\n                    if (guestNetwork == null) {\n                        List<? extends Network> networks = getIsolatedNetworksWithSourceNATOwnedByAccountInZone(zoneId, owner);\n                        if (networks.size() == 0) {\n                            createNetwork = true;\n                        } else if (networks.size() == 1) {\n                            guestNetwork = networks.get(0);\n                        } else {\n                            throw new InvalidParameterValueException(\"Error, more than 1 Guest Isolated Networks with SourceNAT \"\n                                    + \"service enabled found for this account, cannot assosiate the IP range, please provide the network ID\");\n                        }\n                    }\n\n                    \r\n                    List<NetworkOfferingVO> requiredOfferings = _networkOfferingDao.listByAvailability(Availability.Required, false);\n                    if (requiredOfferings.size() < 1) {\n                        throw new CloudRuntimeException(\"Unable to find network offering with availability=\" + Availability.Required\n                                + \" to automatically create the network as part of createVlanIpRange\");\n                    }\n                    if (createNetwork) {\n                        if (requiredOfferings.get(0).getState() == NetworkOffering.State.Enabled) {\n                            long physicalNetworkId = _networkModel.findPhysicalNetworkId(zoneId, requiredOfferings.get(0).getTags(), requiredOfferings.get(0).getTrafficType());\n                            \r\n                            PhysicalNetwork physicalNetwork = _physicalNetworkDao.findById(physicalNetworkId);\n                            if (physicalNetwork == null) {\n                                throw new InvalidParameterValueException(\"Unable to find physical network with id: \" + physicalNetworkId + \" and tag: \"\n                                        + requiredOfferings.get(0).getTags());\n                            }\n\n                            s_logger.debug(\"Creating network for account \" + owner + \" from the network offering id=\" + requiredOfferings.get(0).getId()\n                                    + \" as a part of createVlanIpRange process\");\n                            guestNetwork = _networkMgr.createGuestNetwork(requiredOfferings.get(0).getId(), owner.getAccountName() + \"-network\", owner.getAccountName()\n                                    + \"-network\", null, null, null, false, null, owner, null, physicalNetwork, zoneId, ACLType.Account, null, null, null, null, true, null, null, null, null, null);\n                            if (guestNetwork == null) {\n                                s_logger.warn(\"Failed to create default Virtual network for the account \" + accountId + \"in zone \" + zoneId);\n                                throw new CloudRuntimeException(\"Failed to create a Guest Isolated Networks with SourceNAT \"\n                                        + \"service enabled as a part of createVlanIpRange, for the account \" + accountId + \"in zone \" + zoneId);\n                            }\n                        } else {\n                            throw new CloudRuntimeException(\"Required network offering id=\" + requiredOfferings.get(0).getId() + \" is not in \" + NetworkOffering.State.Enabled);\n                        }\n                    }\n\n                    \r\n                    boolean allocateSourceNat = false;\n                    List<IPAddressVO> sourceNat = _ipAddressDao.listByAssociatedNetwork(guestNetwork.getId(), true);\n                    if (sourceNat.isEmpty()) {\n                        allocateSourceNat = true;\n                    }\n\n                    \r\n                    List<IPAddressVO> ips = _ipAddressDao.listByVlanId(vlanId);\n                    boolean isSourceNatAllocated = false;\n                    for (IPAddressVO addr : ips) {\n                        if (addr.getState() != State.Allocated) {\n                            if (!isSourceNatAllocated && allocateSourceNat) {\n                                addr.setSourceNat(true);\n                                isSourceNatAllocated = true;\n                            } else {\n                                addr.setSourceNat(false);\n                            }\n                            addr.setAssociatedWithNetworkId(guestNetwork.getId());\n                            addr.setVpcId(guestNetwork.getVpcId());\n                            addr.setAllocatedTime(new Date());\n                            addr.setAllocatedInDomainId(owner.getDomainId());\n                            addr.setAllocatedToAccountId(owner.getId());\n                            addr.setSystem(false);\n                            addr.setState(IpAddress.State.Allocating);\n                            markPublicIpAsAllocated(addr);\n                        }\n                    }\n                    return new Ternary<Boolean, List<NetworkOfferingVO>, Network>(createNetwork, requiredOfferings, guestNetwork);\n                }\n            });\n        } catch (Exception e1) {\n            ExceptionUtil.rethrowRuntime(e1);\n            ExceptionUtil.rethrow(e1, InsufficientCapacityException.class);\n            ExceptionUtil.rethrow(e1, ResourceAllocationException.class);\n            throw new IllegalStateException(e1);\n        }\n\n        boolean createNetwork = pair.first();\n        List<NetworkOfferingVO> requiredOfferings = pair.second();\n        Network guestNetwork = pair.third();\n\n        \r\n        if (createNetwork && requiredOfferings.get(0).isPersistent()) {\n            DataCenter zone = _dcDao.findById(zoneId);\n            DeployDestination dest = new DeployDestination(zone, null, null, null);\n            Account callerAccount = CallContext.current().getCallingAccount();\n            UserVO callerUser = _userDao.findById(CallContext.current().getCallingUserId());\n            Journal journal = new Journal.LogJournal(\"Implementing \" + guestNetwork, s_logger);\n            ReservationContext context = new ReservationContextImpl(UUID.randomUUID().toString(), journal, callerUser, callerAccount);\n            s_logger.debug(\"Implementing network \" + guestNetwork + \" as a part of network provision for persistent network\");\n            try {\n                Pair<? extends NetworkGuru, ? extends Network> implementedNetwork = _networkMgr.implementNetwork(guestNetwork.getId(), dest, context);\n                if (implementedNetwork == null || implementedNetwork.first() == null) {\n                    s_logger.warn(\"Failed to implement the network \" + guestNetwork);\n                }\n                if (implementedNetwork != null) {\n                    guestNetwork = implementedNetwork.second();\n                }\n            } catch (Exception ex) {\n                s_logger.warn(\"Failed to implement network \" + guestNetwork + \" elements and resources as a part of\" + \" network provision due to \", ex);\n                CloudRuntimeException e = new CloudRuntimeException(\"Failed to implement network (with specified id)\"\n                        + \" elements and resources as a part of network provision for persistent network\");\n                e.addProxyObject(guestNetwork.getUuid(), \"networkId\");\n                throw e;\n            }\n        }\n        return true;\n    }\n","date":"2021-02-18 16:24:09","endLine":1818,"groupId":"101356","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"associateIpAddressListToAccount","params":"(longuserId@finallongaccountId@finallongzoneId@finalLongvlanId@finalNetworkguestNetworkFinal)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/51/af56a887a20dd4a8ab1b428a978173356acec0.src","preCode":"    public boolean associateIpAddressListToAccount(long userId, final long accountId, final long zoneId, final Long vlanId, final Network guestNetworkFinal)\n            throws InsufficientCapacityException, ConcurrentOperationException, ResourceUnavailableException, ResourceAllocationException {\n        final Account owner = _accountMgr.getActiveAccountById(accountId);\n\n        if (guestNetworkFinal != null && guestNetworkFinal.getTrafficType() != TrafficType.Guest) {\n            throw new InvalidParameterValueException(\"Network \" + guestNetworkFinal + \" is not of a type \" + TrafficType.Guest);\n        }\n\n        Ternary<Boolean, List<NetworkOfferingVO>, Network> pair = null;\n        try {\n            pair = Transaction.execute(new TransactionCallbackWithException<Ternary<Boolean, List<NetworkOfferingVO>, Network>, Exception>() {\n                @Override\n                public Ternary<Boolean, List<NetworkOfferingVO>, Network> doInTransaction(TransactionStatus status) throws InsufficientCapacityException,\n                        ResourceAllocationException {\n                    boolean createNetwork = false;\n                    Network guestNetwork = guestNetworkFinal;\n\n                    if (guestNetwork == null) {\n                        List<? extends Network> networks = getIsolatedNetworksWithSourceNATOwnedByAccountInZone(zoneId, owner);\n                        if (networks.size() == 0) {\n                            createNetwork = true;\n                        } else if (networks.size() == 1) {\n                            guestNetwork = networks.get(0);\n                        } else {\n                            throw new InvalidParameterValueException(\"Error, more than 1 Guest Isolated Networks with SourceNAT \"\n                                    + \"service enabled found for this account, cannot assosiate the IP range, please provide the network ID\");\n                        }\n                    }\n\n                    \r\n                    List<NetworkOfferingVO> requiredOfferings = _networkOfferingDao.listByAvailability(Availability.Required, false);\n                    if (requiredOfferings.size() < 1) {\n                        throw new CloudRuntimeException(\"Unable to find network offering with availability=\" + Availability.Required\n                                + \" to automatically create the network as part of createVlanIpRange\");\n                    }\n                    if (createNetwork) {\n                        if (requiredOfferings.get(0).getState() == NetworkOffering.State.Enabled) {\n                            long physicalNetworkId = _networkModel.findPhysicalNetworkId(zoneId, requiredOfferings.get(0).getTags(), requiredOfferings.get(0).getTrafficType());\n                            \r\n                            PhysicalNetwork physicalNetwork = _physicalNetworkDao.findById(physicalNetworkId);\n                            if (physicalNetwork == null) {\n                                throw new InvalidParameterValueException(\"Unable to find physical network with id: \" + physicalNetworkId + \" and tag: \"\n                                        + requiredOfferings.get(0).getTags());\n                            }\n\n                            s_logger.debug(\"Creating network for account \" + owner + \" from the network offering id=\" + requiredOfferings.get(0).getId()\n                                    + \" as a part of createVlanIpRange process\");\n                            guestNetwork = _networkMgr.createGuestNetwork(requiredOfferings.get(0).getId(), owner.getAccountName() + \"-network\", owner.getAccountName()\n                                    + \"-network\", null, null, null, false, null, owner, null, physicalNetwork, zoneId, ACLType.Account, null, null, null, null, true, null, null, null);\n                            if (guestNetwork == null) {\n                                s_logger.warn(\"Failed to create default Virtual network for the account \" + accountId + \"in zone \" + zoneId);\n                                throw new CloudRuntimeException(\"Failed to create a Guest Isolated Networks with SourceNAT \"\n                                        + \"service enabled as a part of createVlanIpRange, for the account \" + accountId + \"in zone \" + zoneId);\n                            }\n                        } else {\n                            throw new CloudRuntimeException(\"Required network offering id=\" + requiredOfferings.get(0).getId() + \" is not in \" + NetworkOffering.State.Enabled);\n                        }\n                    }\n\n                    \r\n                    boolean allocateSourceNat = false;\n                    List<IPAddressVO> sourceNat = _ipAddressDao.listByAssociatedNetwork(guestNetwork.getId(), true);\n                    if (sourceNat.isEmpty()) {\n                        allocateSourceNat = true;\n                    }\n\n                    \r\n                    List<IPAddressVO> ips = _ipAddressDao.listByVlanId(vlanId);\n                    boolean isSourceNatAllocated = false;\n                    for (IPAddressVO addr : ips) {\n                        if (addr.getState() != State.Allocated) {\n                            if (!isSourceNatAllocated && allocateSourceNat) {\n                                addr.setSourceNat(true);\n                                isSourceNatAllocated = true;\n                            } else {\n                                addr.setSourceNat(false);\n                            }\n                            addr.setAssociatedWithNetworkId(guestNetwork.getId());\n                            addr.setVpcId(guestNetwork.getVpcId());\n                            addr.setAllocatedTime(new Date());\n                            addr.setAllocatedInDomainId(owner.getDomainId());\n                            addr.setAllocatedToAccountId(owner.getId());\n                            addr.setSystem(false);\n                            addr.setState(IpAddress.State.Allocating);\n                            markPublicIpAsAllocated(addr);\n                        }\n                    }\n                    return new Ternary<Boolean, List<NetworkOfferingVO>, Network>(createNetwork, requiredOfferings, guestNetwork);\n                }\n            });\n        } catch (Exception e1) {\n            ExceptionUtil.rethrowRuntime(e1);\n            ExceptionUtil.rethrow(e1, InsufficientCapacityException.class);\n            ExceptionUtil.rethrow(e1, ResourceAllocationException.class);\n            throw new IllegalStateException(e1);\n        }\n\n        boolean createNetwork = pair.first();\n        List<NetworkOfferingVO> requiredOfferings = pair.second();\n        Network guestNetwork = pair.third();\n\n        \r\n        if (createNetwork && requiredOfferings.get(0).isPersistent()) {\n            DataCenter zone = _dcDao.findById(zoneId);\n            DeployDestination dest = new DeployDestination(zone, null, null, null);\n            Account callerAccount = CallContext.current().getCallingAccount();\n            UserVO callerUser = _userDao.findById(CallContext.current().getCallingUserId());\n            Journal journal = new Journal.LogJournal(\"Implementing \" + guestNetwork, s_logger);\n            ReservationContext context = new ReservationContextImpl(UUID.randomUUID().toString(), journal, callerUser, callerAccount);\n            s_logger.debug(\"Implementing network \" + guestNetwork + \" as a part of network provision for persistent network\");\n            try {\n                Pair<? extends NetworkGuru, ? extends Network> implementedNetwork = _networkMgr.implementNetwork(guestNetwork.getId(), dest, context);\n                if (implementedNetwork == null || implementedNetwork.first() == null) {\n                    s_logger.warn(\"Failed to implement the network \" + guestNetwork);\n                }\n                if (implementedNetwork != null) {\n                    guestNetwork = implementedNetwork.second();\n                }\n            } catch (Exception ex) {\n                s_logger.warn(\"Failed to implement network \" + guestNetwork + \" elements and resources as a part of\" + \" network provision due to \", ex);\n                CloudRuntimeException e = new CloudRuntimeException(\"Failed to implement network (with specified id)\"\n                        + \" elements and resources as a part of network provision for persistent network\");\n                e.addProxyObject(guestNetwork.getUuid(), \"networkId\");\n                throw e;\n            }\n        }\n        return true;\n    }\n","realPath":"server/src/main/java/com/cloud/network/IpAddressManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1691,"status":"M"}],"commitId":"aa01580381c931512d62edbc658865f776ce2efa","commitMessage":"@@@network: Specify IP for VR in shared networks (#4503)\n\nThis PR enables admins to specify IP for a VR in a shared network.","date":"2021-02-18 16:24:09","modifiedFileCount":"16","status":"M","submitter":"Pearl Dsilva"}]
