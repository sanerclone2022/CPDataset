[{"authorTime":"2020-03-06 15:51:23","codes":[{"authorDate":"2020-03-06 15:51:23","commitOrder":1,"curCode":"    public boolean startKubernetesClusterOnCreate() {\n        init();\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Starting Kubernetes cluster ID: %s\", kubernetesCluster.getUuid()));\n        }\n        final long startTimeoutTime = System.currentTimeMillis() + KubernetesClusterService.KubernetesClusterStartTimeout.value() * 1000;\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.StartRequested);\n        DeployDestination dest = null;\n        try {\n            dest = plan();\n        } catch (InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning the cluster failed due to insufficient capacity in the Kubernetes cluster: %s\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        Network network = null;\n        try {\n            network = startKubernetesClusterNetwork(dest);\n        } catch (ManagementServerException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster ID: %s as its network cannot be started\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        Pair<String, Integer> publicIpSshPort = getKubernetesClusterServerIpSshPort(null);\n        publicIpAddress = publicIpSshPort.first();\n        if (Strings.isNullOrEmpty(publicIpAddress) &&\n                (Network.GuestType.Isolated.equals(network.getGuestType()) || kubernetesCluster.getMasterNodeCount() > 1)) { \r\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster ID: %s as no public IP found for the cluster\" , kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n        }\n        List<UserVm> clusterVMs = new ArrayList<>();\n        UserVm k8sMasterVM = null;\n        try {\n            k8sMasterVM = provisionKubernetesClusterMasterVm(network, publicIpAddress);\n        } catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning the master VM failed in the Kubernetes cluster ID: %s\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        clusterVMs.add(k8sMasterVM);\n        if (Strings.isNullOrEmpty(publicIpAddress)) {\n            publicIpSshPort = getKubernetesClusterServerIpSshPort(k8sMasterVM);\n            publicIpAddress = publicIpSshPort.first();\n            if (Strings.isNullOrEmpty(publicIpAddress)) {\n                logTransitStateAndThrow(Level.WARN, String.format(\"Failed to start Kubernetes cluster ID: %s as no public IP found for the cluster\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n            }\n        }\n        try {\n            List<UserVm> additionalMasterVMs = provisionKubernetesClusterAdditionalMasterVms(publicIpAddress);\n            clusterVMs.addAll(additionalMasterVMs);\n        }  catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning additional master VM failed in the Kubernetes cluster ID: %s\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        try {\n            List<UserVm> nodeVMs = provisionKubernetesClusterNodeVms(kubernetesCluster.getNodeCount(), publicIpAddress);\n            clusterVMs.addAll(nodeVMs);\n        }  catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning node VM failed in the Kubernetes cluster ID: %s\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Kubernetes cluster ID: %s VMs successfully provisioned\", kubernetesCluster.getUuid()));\n        }\n        try {\n            setupKubernetesClusterNetworkRules(network, clusterVMs);\n        } catch (ManagementServerException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster ID: %s, unable to setup network rules\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        attachIsoKubernetesVMs(clusterVMs);\n        if (!KubernetesClusterUtil.isKubernetesClusterMasterVmRunning(kubernetesCluster, publicIpAddress, publicIpSshPort.second(), startTimeoutTime)) {\n            String msg = String.format(\"Failed to setup Kubernetes cluster ID: %s in usable state as unable to access master node VMs of the cluster\", kubernetesCluster.getUuid());\n            if (kubernetesCluster.getMasterNodeCount() > 1 && Network.GuestType.Shared.equals(network.getGuestType())) {\n                msg = String.format(\"%s. Make sure external load-balancer has port forwarding rules for SSH access on ports %d-%d and API access on port %d\",\n                        msg,\n                        CLUSTER_NODES_DEFAULT_START_SSH_PORT,\n                        CLUSTER_NODES_DEFAULT_START_SSH_PORT + kubernetesCluster.getTotalNodeCount() - 1,\n                        CLUSTER_API_PORT);\n            }\n            logTransitStateDetachIsoAndThrow(Level.ERROR, msg, kubernetesCluster, clusterVMs, KubernetesCluster.Event.CreateFailed, null);\n        }\n        boolean k8sApiServerSetup = KubernetesClusterUtil.isKubernetesClusterServerRunning(kubernetesCluster, publicIpAddress, CLUSTER_API_PORT, startTimeoutTime, 15000);\n        if (!k8sApiServerSetup) {\n            logTransitStateDetachIsoAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster ID: %s in usable state as unable to provision API endpoint for the cluster\", kubernetesCluster.getUuid()), kubernetesCluster, clusterVMs, KubernetesCluster.Event.CreateFailed, null);\n        }\n        sshPort = publicIpSshPort.second();\n        updateKubernetesClusterEntryEndpoint();\n        boolean readyNodesCountValid = KubernetesClusterUtil.validateKubernetesClusterReadyNodesCount(kubernetesCluster, publicIpAddress, sshPort,\n                CLUSTER_NODE_VM_USER, sshKeyFile, startTimeoutTime, 15000);\n        detachIsoKubernetesVMs(clusterVMs);\n        if (!readyNodesCountValid) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster ID: %s as it does not have desired number of nodes in ready state\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n        }\n        if (!isKubernetesClusterKubeConfigAvailable(startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster ID: %s in usable state as unable to retrieve kube-config for the cluster\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterDashboardServiceRunning(true, startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster ID: %s in usable state as unable to get Dashboard service running for the cluster\", kubernetesCluster.getUuid()), kubernetesCluster.getId(),KubernetesCluster.Event.OperationFailed);\n        }\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.OperationSucceeded);\n        return true;\n    }\n","date":"2020-03-06 15:51:23","endLine":562,"groupId":"22412","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"startKubernetesClusterOnCreate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/d4/525630196c58de083fa2a670e53e82804f3764.src","preCode":"    public boolean startKubernetesClusterOnCreate() {\n        init();\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Starting Kubernetes cluster ID: %s\", kubernetesCluster.getUuid()));\n        }\n        final long startTimeoutTime = System.currentTimeMillis() + KubernetesClusterService.KubernetesClusterStartTimeout.value() * 1000;\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.StartRequested);\n        DeployDestination dest = null;\n        try {\n            dest = plan();\n        } catch (InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning the cluster failed due to insufficient capacity in the Kubernetes cluster: %s\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        Network network = null;\n        try {\n            network = startKubernetesClusterNetwork(dest);\n        } catch (ManagementServerException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster ID: %s as its network cannot be started\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        Pair<String, Integer> publicIpSshPort = getKubernetesClusterServerIpSshPort(null);\n        publicIpAddress = publicIpSshPort.first();\n        if (Strings.isNullOrEmpty(publicIpAddress) &&\n                (Network.GuestType.Isolated.equals(network.getGuestType()) || kubernetesCluster.getMasterNodeCount() > 1)) { \r\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster ID: %s as no public IP found for the cluster\" , kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n        }\n        List<UserVm> clusterVMs = new ArrayList<>();\n        UserVm k8sMasterVM = null;\n        try {\n            k8sMasterVM = provisionKubernetesClusterMasterVm(network, publicIpAddress);\n        } catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning the master VM failed in the Kubernetes cluster ID: %s\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        clusterVMs.add(k8sMasterVM);\n        if (Strings.isNullOrEmpty(publicIpAddress)) {\n            publicIpSshPort = getKubernetesClusterServerIpSshPort(k8sMasterVM);\n            publicIpAddress = publicIpSshPort.first();\n            if (Strings.isNullOrEmpty(publicIpAddress)) {\n                logTransitStateAndThrow(Level.WARN, String.format(\"Failed to start Kubernetes cluster ID: %s as no public IP found for the cluster\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n            }\n        }\n        try {\n            List<UserVm> additionalMasterVMs = provisionKubernetesClusterAdditionalMasterVms(publicIpAddress);\n            clusterVMs.addAll(additionalMasterVMs);\n        }  catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning additional master VM failed in the Kubernetes cluster ID: %s\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        try {\n            List<UserVm> nodeVMs = provisionKubernetesClusterNodeVms(kubernetesCluster.getNodeCount(), publicIpAddress);\n            clusterVMs.addAll(nodeVMs);\n        }  catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning node VM failed in the Kubernetes cluster ID: %s\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Kubernetes cluster ID: %s VMs successfully provisioned\", kubernetesCluster.getUuid()));\n        }\n        try {\n            setupKubernetesClusterNetworkRules(network, clusterVMs);\n        } catch (ManagementServerException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster ID: %s, unable to setup network rules\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        attachIsoKubernetesVMs(clusterVMs);\n        if (!KubernetesClusterUtil.isKubernetesClusterMasterVmRunning(kubernetesCluster, publicIpAddress, publicIpSshPort.second(), startTimeoutTime)) {\n            String msg = String.format(\"Failed to setup Kubernetes cluster ID: %s in usable state as unable to access master node VMs of the cluster\", kubernetesCluster.getUuid());\n            if (kubernetesCluster.getMasterNodeCount() > 1 && Network.GuestType.Shared.equals(network.getGuestType())) {\n                msg = String.format(\"%s. Make sure external load-balancer has port forwarding rules for SSH access on ports %d-%d and API access on port %d\",\n                        msg,\n                        CLUSTER_NODES_DEFAULT_START_SSH_PORT,\n                        CLUSTER_NODES_DEFAULT_START_SSH_PORT + kubernetesCluster.getTotalNodeCount() - 1,\n                        CLUSTER_API_PORT);\n            }\n            logTransitStateDetachIsoAndThrow(Level.ERROR, msg, kubernetesCluster, clusterVMs, KubernetesCluster.Event.CreateFailed, null);\n        }\n        boolean k8sApiServerSetup = KubernetesClusterUtil.isKubernetesClusterServerRunning(kubernetesCluster, publicIpAddress, CLUSTER_API_PORT, startTimeoutTime, 15000);\n        if (!k8sApiServerSetup) {\n            logTransitStateDetachIsoAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster ID: %s in usable state as unable to provision API endpoint for the cluster\", kubernetesCluster.getUuid()), kubernetesCluster, clusterVMs, KubernetesCluster.Event.CreateFailed, null);\n        }\n        sshPort = publicIpSshPort.second();\n        updateKubernetesClusterEntryEndpoint();\n        boolean readyNodesCountValid = KubernetesClusterUtil.validateKubernetesClusterReadyNodesCount(kubernetesCluster, publicIpAddress, sshPort,\n                CLUSTER_NODE_VM_USER, sshKeyFile, startTimeoutTime, 15000);\n        detachIsoKubernetesVMs(clusterVMs);\n        if (!readyNodesCountValid) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster ID: %s as it does not have desired number of nodes in ready state\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n        }\n        if (!isKubernetesClusterKubeConfigAvailable(startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster ID: %s in usable state as unable to retrieve kube-config for the cluster\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterDashboardServiceRunning(true, startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster ID: %s in usable state as unable to get Dashboard service running for the cluster\", kubernetesCluster.getUuid()), kubernetesCluster.getId(),KubernetesCluster.Event.OperationFailed);\n        }\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.OperationSucceeded);\n        return true;\n    }\n","realPath":"plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterStartWorker.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":470,"status":"B"},{"authorDate":"2020-03-06 15:51:23","commitOrder":1,"curCode":"    public boolean startStoppedKubernetesCluster() throws CloudRuntimeException {\n        init();\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Starting Kubernetes cluster ID: %s\", kubernetesCluster.getUuid()));\n        }\n        final long startTimeoutTime = System.currentTimeMillis() + KubernetesClusterService.KubernetesClusterStartTimeout.value() * 1000;\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.StartRequested);\n        startKubernetesClusterVMs();\n        try {\n            InetAddress address = InetAddress.getByName(new URL(kubernetesCluster.getEndpoint()).getHost());\n        } catch (MalformedURLException | UnknownHostException ex) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Kubernetes cluster ID: %s has invalid API endpoint. Can not verify if cluster is in ready state\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        Pair<String, Integer> sshIpPort =  getKubernetesClusterServerIpSshPort(null);\n        publicIpAddress = sshIpPort.first();\n        sshPort = sshIpPort.second();\n        if (Strings.isNullOrEmpty(publicIpAddress)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster ID: %s as no public IP found for the cluster\" , kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!KubernetesClusterUtil.isKubernetesClusterServerRunning(kubernetesCluster, publicIpAddress, CLUSTER_API_PORT, startTimeoutTime, 15000)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster ID: %s in usable state\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterKubeConfigAvailable(startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster ID: %s in usable state as unable to retrieve kube-config for the cluster\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterDashboardServiceRunning(false, startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster ID: %s in usable state as unable to get Dashboard service running for the cluster\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.OperationSucceeded);\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Kubernetes cluster ID: %s successfully started\", kubernetesCluster.getUuid()));\n        }\n        return true;\n    }\n","date":"2020-03-06 15:51:23","endLine":597,"groupId":"22410","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"startStoppedKubernetesCluster","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/d4/525630196c58de083fa2a670e53e82804f3764.src","preCode":"    public boolean startStoppedKubernetesCluster() throws CloudRuntimeException {\n        init();\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Starting Kubernetes cluster ID: %s\", kubernetesCluster.getUuid()));\n        }\n        final long startTimeoutTime = System.currentTimeMillis() + KubernetesClusterService.KubernetesClusterStartTimeout.value() * 1000;\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.StartRequested);\n        startKubernetesClusterVMs();\n        try {\n            InetAddress address = InetAddress.getByName(new URL(kubernetesCluster.getEndpoint()).getHost());\n        } catch (MalformedURLException | UnknownHostException ex) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Kubernetes cluster ID: %s has invalid API endpoint. Can not verify if cluster is in ready state\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        Pair<String, Integer> sshIpPort =  getKubernetesClusterServerIpSshPort(null);\n        publicIpAddress = sshIpPort.first();\n        sshPort = sshIpPort.second();\n        if (Strings.isNullOrEmpty(publicIpAddress)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster ID: %s as no public IP found for the cluster\" , kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!KubernetesClusterUtil.isKubernetesClusterServerRunning(kubernetesCluster, publicIpAddress, CLUSTER_API_PORT, startTimeoutTime, 15000)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster ID: %s in usable state\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterKubeConfigAvailable(startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster ID: %s in usable state as unable to retrieve kube-config for the cluster\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterDashboardServiceRunning(false, startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster ID: %s in usable state as unable to get Dashboard service running for the cluster\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.OperationSucceeded);\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Kubernetes cluster ID: %s successfully started\", kubernetesCluster.getUuid()));\n        }\n        return true;\n    }\n","realPath":"plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterStartWorker.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":564,"status":"B"}],"commitId":"8cc70c7d8725319ba5455c5fe17ede275e372f1c","commitMessage":"@@@CloudStack Kubernetes Service (#3680)\n\n","date":"2020-03-06 15:51:23","modifiedFileCount":"10","status":"B","submitter":"Abhishek Kumar"},{"authorTime":"2020-10-21 20:01:56","codes":[{"authorDate":"2020-03-06 15:51:23","commitOrder":2,"curCode":"    public boolean startKubernetesClusterOnCreate() {\n        init();\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Starting Kubernetes cluster ID: %s\", kubernetesCluster.getUuid()));\n        }\n        final long startTimeoutTime = System.currentTimeMillis() + KubernetesClusterService.KubernetesClusterStartTimeout.value() * 1000;\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.StartRequested);\n        DeployDestination dest = null;\n        try {\n            dest = plan();\n        } catch (InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning the cluster failed due to insufficient capacity in the Kubernetes cluster: %s\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        Network network = null;\n        try {\n            network = startKubernetesClusterNetwork(dest);\n        } catch (ManagementServerException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster ID: %s as its network cannot be started\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        Pair<String, Integer> publicIpSshPort = getKubernetesClusterServerIpSshPort(null);\n        publicIpAddress = publicIpSshPort.first();\n        if (Strings.isNullOrEmpty(publicIpAddress) &&\n                (Network.GuestType.Isolated.equals(network.getGuestType()) || kubernetesCluster.getMasterNodeCount() > 1)) { \r\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster ID: %s as no public IP found for the cluster\" , kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n        }\n        List<UserVm> clusterVMs = new ArrayList<>();\n        UserVm k8sMasterVM = null;\n        try {\n            k8sMasterVM = provisionKubernetesClusterMasterVm(network, publicIpAddress);\n        } catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning the master VM failed in the Kubernetes cluster ID: %s\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        clusterVMs.add(k8sMasterVM);\n        if (Strings.isNullOrEmpty(publicIpAddress)) {\n            publicIpSshPort = getKubernetesClusterServerIpSshPort(k8sMasterVM);\n            publicIpAddress = publicIpSshPort.first();\n            if (Strings.isNullOrEmpty(publicIpAddress)) {\n                logTransitStateAndThrow(Level.WARN, String.format(\"Failed to start Kubernetes cluster ID: %s as no public IP found for the cluster\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n            }\n        }\n        try {\n            List<UserVm> additionalMasterVMs = provisionKubernetesClusterAdditionalMasterVms(publicIpAddress);\n            clusterVMs.addAll(additionalMasterVMs);\n        }  catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning additional master VM failed in the Kubernetes cluster ID: %s\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        try {\n            List<UserVm> nodeVMs = provisionKubernetesClusterNodeVms(kubernetesCluster.getNodeCount(), publicIpAddress);\n            clusterVMs.addAll(nodeVMs);\n        }  catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning node VM failed in the Kubernetes cluster ID: %s\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Kubernetes cluster ID: %s VMs successfully provisioned\", kubernetesCluster.getUuid()));\n        }\n        try {\n            setupKubernetesClusterNetworkRules(network, clusterVMs);\n        } catch (ManagementServerException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster ID: %s, unable to setup network rules\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        attachIsoKubernetesVMs(clusterVMs);\n        if (!KubernetesClusterUtil.isKubernetesClusterMasterVmRunning(kubernetesCluster, publicIpAddress, publicIpSshPort.second(), startTimeoutTime)) {\n            String msg = String.format(\"Failed to setup Kubernetes cluster ID: %s in usable state as unable to access master node VMs of the cluster\", kubernetesCluster.getUuid());\n            if (kubernetesCluster.getMasterNodeCount() > 1 && Network.GuestType.Shared.equals(network.getGuestType())) {\n                msg = String.format(\"%s. Make sure external load-balancer has port forwarding rules for SSH access on ports %d-%d and API access on port %d\",\n                        msg,\n                        CLUSTER_NODES_DEFAULT_START_SSH_PORT,\n                        CLUSTER_NODES_DEFAULT_START_SSH_PORT + kubernetesCluster.getTotalNodeCount() - 1,\n                        CLUSTER_API_PORT);\n            }\n            logTransitStateDetachIsoAndThrow(Level.ERROR, msg, kubernetesCluster, clusterVMs, KubernetesCluster.Event.CreateFailed, null);\n        }\n        boolean k8sApiServerSetup = KubernetesClusterUtil.isKubernetesClusterServerRunning(kubernetesCluster, publicIpAddress, CLUSTER_API_PORT, startTimeoutTime, 15000);\n        if (!k8sApiServerSetup) {\n            logTransitStateDetachIsoAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster ID: %s in usable state as unable to provision API endpoint for the cluster\", kubernetesCluster.getUuid()), kubernetesCluster, clusterVMs, KubernetesCluster.Event.CreateFailed, null);\n        }\n        sshPort = publicIpSshPort.second();\n        updateKubernetesClusterEntryEndpoint();\n        boolean readyNodesCountValid = KubernetesClusterUtil.validateKubernetesClusterReadyNodesCount(kubernetesCluster, publicIpAddress, sshPort,\n                CLUSTER_NODE_VM_USER, sshKeyFile, startTimeoutTime, 15000);\n        detachIsoKubernetesVMs(clusterVMs);\n        if (!readyNodesCountValid) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster ID: %s as it does not have desired number of nodes in ready state\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n        }\n        if (!isKubernetesClusterKubeConfigAvailable(startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster ID: %s in usable state as unable to retrieve kube-config for the cluster\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterDashboardServiceRunning(true, startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster ID: %s in usable state as unable to get Dashboard service running for the cluster\", kubernetesCluster.getUuid()), kubernetesCluster.getId(),KubernetesCluster.Event.OperationFailed);\n        }\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.OperationSucceeded);\n        return true;\n    }\n","date":"2020-03-06 15:51:23","endLine":562,"groupId":"22412","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"startKubernetesClusterOnCreate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/d4/525630196c58de083fa2a670e53e82804f3764.src","preCode":"    public boolean startKubernetesClusterOnCreate() {\n        init();\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Starting Kubernetes cluster ID: %s\", kubernetesCluster.getUuid()));\n        }\n        final long startTimeoutTime = System.currentTimeMillis() + KubernetesClusterService.KubernetesClusterStartTimeout.value() * 1000;\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.StartRequested);\n        DeployDestination dest = null;\n        try {\n            dest = plan();\n        } catch (InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning the cluster failed due to insufficient capacity in the Kubernetes cluster: %s\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        Network network = null;\n        try {\n            network = startKubernetesClusterNetwork(dest);\n        } catch (ManagementServerException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster ID: %s as its network cannot be started\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        Pair<String, Integer> publicIpSshPort = getKubernetesClusterServerIpSshPort(null);\n        publicIpAddress = publicIpSshPort.first();\n        if (Strings.isNullOrEmpty(publicIpAddress) &&\n                (Network.GuestType.Isolated.equals(network.getGuestType()) || kubernetesCluster.getMasterNodeCount() > 1)) { \r\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster ID: %s as no public IP found for the cluster\" , kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n        }\n        List<UserVm> clusterVMs = new ArrayList<>();\n        UserVm k8sMasterVM = null;\n        try {\n            k8sMasterVM = provisionKubernetesClusterMasterVm(network, publicIpAddress);\n        } catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning the master VM failed in the Kubernetes cluster ID: %s\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        clusterVMs.add(k8sMasterVM);\n        if (Strings.isNullOrEmpty(publicIpAddress)) {\n            publicIpSshPort = getKubernetesClusterServerIpSshPort(k8sMasterVM);\n            publicIpAddress = publicIpSshPort.first();\n            if (Strings.isNullOrEmpty(publicIpAddress)) {\n                logTransitStateAndThrow(Level.WARN, String.format(\"Failed to start Kubernetes cluster ID: %s as no public IP found for the cluster\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n            }\n        }\n        try {\n            List<UserVm> additionalMasterVMs = provisionKubernetesClusterAdditionalMasterVms(publicIpAddress);\n            clusterVMs.addAll(additionalMasterVMs);\n        }  catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning additional master VM failed in the Kubernetes cluster ID: %s\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        try {\n            List<UserVm> nodeVMs = provisionKubernetesClusterNodeVms(kubernetesCluster.getNodeCount(), publicIpAddress);\n            clusterVMs.addAll(nodeVMs);\n        }  catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning node VM failed in the Kubernetes cluster ID: %s\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Kubernetes cluster ID: %s VMs successfully provisioned\", kubernetesCluster.getUuid()));\n        }\n        try {\n            setupKubernetesClusterNetworkRules(network, clusterVMs);\n        } catch (ManagementServerException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster ID: %s, unable to setup network rules\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        attachIsoKubernetesVMs(clusterVMs);\n        if (!KubernetesClusterUtil.isKubernetesClusterMasterVmRunning(kubernetesCluster, publicIpAddress, publicIpSshPort.second(), startTimeoutTime)) {\n            String msg = String.format(\"Failed to setup Kubernetes cluster ID: %s in usable state as unable to access master node VMs of the cluster\", kubernetesCluster.getUuid());\n            if (kubernetesCluster.getMasterNodeCount() > 1 && Network.GuestType.Shared.equals(network.getGuestType())) {\n                msg = String.format(\"%s. Make sure external load-balancer has port forwarding rules for SSH access on ports %d-%d and API access on port %d\",\n                        msg,\n                        CLUSTER_NODES_DEFAULT_START_SSH_PORT,\n                        CLUSTER_NODES_DEFAULT_START_SSH_PORT + kubernetesCluster.getTotalNodeCount() - 1,\n                        CLUSTER_API_PORT);\n            }\n            logTransitStateDetachIsoAndThrow(Level.ERROR, msg, kubernetesCluster, clusterVMs, KubernetesCluster.Event.CreateFailed, null);\n        }\n        boolean k8sApiServerSetup = KubernetesClusterUtil.isKubernetesClusterServerRunning(kubernetesCluster, publicIpAddress, CLUSTER_API_PORT, startTimeoutTime, 15000);\n        if (!k8sApiServerSetup) {\n            logTransitStateDetachIsoAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster ID: %s in usable state as unable to provision API endpoint for the cluster\", kubernetesCluster.getUuid()), kubernetesCluster, clusterVMs, KubernetesCluster.Event.CreateFailed, null);\n        }\n        sshPort = publicIpSshPort.second();\n        updateKubernetesClusterEntryEndpoint();\n        boolean readyNodesCountValid = KubernetesClusterUtil.validateKubernetesClusterReadyNodesCount(kubernetesCluster, publicIpAddress, sshPort,\n                CLUSTER_NODE_VM_USER, sshKeyFile, startTimeoutTime, 15000);\n        detachIsoKubernetesVMs(clusterVMs);\n        if (!readyNodesCountValid) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster ID: %s as it does not have desired number of nodes in ready state\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n        }\n        if (!isKubernetesClusterKubeConfigAvailable(startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster ID: %s in usable state as unable to retrieve kube-config for the cluster\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterDashboardServiceRunning(true, startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster ID: %s in usable state as unable to get Dashboard service running for the cluster\", kubernetesCluster.getUuid()), kubernetesCluster.getId(),KubernetesCluster.Event.OperationFailed);\n        }\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.OperationSucceeded);\n        return true;\n    }\n","realPath":"plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterStartWorker.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":470,"status":"N"},{"authorDate":"2020-10-21 20:01:56","commitOrder":2,"curCode":"    public boolean startStoppedKubernetesCluster() throws CloudRuntimeException {\n        init();\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Starting Kubernetes cluster ID: %s\", kubernetesCluster.getUuid()));\n        }\n        final long startTimeoutTime = System.currentTimeMillis() + KubernetesClusterService.KubernetesClusterStartTimeout.value() * 1000;\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.StartRequested);\n        startKubernetesClusterVMs();\n        try {\n            InetAddress address = InetAddress.getByName(new URL(kubernetesCluster.getEndpoint()).getHost());\n        } catch (MalformedURLException | UnknownHostException ex) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Kubernetes cluster : %s has invalid API endpoint. Can not verify if cluster is in ready state\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        Pair<String, Integer> sshIpPort =  getKubernetesClusterServerIpSshPort(null);\n        publicIpAddress = sshIpPort.first();\n        sshPort = sshIpPort.second();\n        if (Strings.isNullOrEmpty(publicIpAddress)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s as no public IP found for the cluster\" , kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!KubernetesClusterUtil.isKubernetesClusterServerRunning(kubernetesCluster, publicIpAddress, CLUSTER_API_PORT, startTimeoutTime, 15000)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s in usable state\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterKubeConfigAvailable(startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s in usable state as unable to retrieve kube-config for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterDashboardServiceRunning(false, startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s in usable state as unable to get Dashboard service running for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.OperationSucceeded);\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Kubernetes cluster ID: %s successfully started\", kubernetesCluster.getUuid()));\n        }\n        return true;\n    }\n","date":"2020-10-21 20:01:56","endLine":604,"groupId":"22410","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"startStoppedKubernetesCluster","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/20/f509e32703c250b9a1dd86273e1a2633f86b6f.src","preCode":"    public boolean startStoppedKubernetesCluster() throws CloudRuntimeException {\n        init();\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Starting Kubernetes cluster ID: %s\", kubernetesCluster.getUuid()));\n        }\n        final long startTimeoutTime = System.currentTimeMillis() + KubernetesClusterService.KubernetesClusterStartTimeout.value() * 1000;\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.StartRequested);\n        startKubernetesClusterVMs();\n        try {\n            InetAddress address = InetAddress.getByName(new URL(kubernetesCluster.getEndpoint()).getHost());\n        } catch (MalformedURLException | UnknownHostException ex) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Kubernetes cluster ID: %s has invalid API endpoint. Can not verify if cluster is in ready state\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        Pair<String, Integer> sshIpPort =  getKubernetesClusterServerIpSshPort(null);\n        publicIpAddress = sshIpPort.first();\n        sshPort = sshIpPort.second();\n        if (Strings.isNullOrEmpty(publicIpAddress)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster ID: %s as no public IP found for the cluster\" , kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!KubernetesClusterUtil.isKubernetesClusterServerRunning(kubernetesCluster, publicIpAddress, CLUSTER_API_PORT, startTimeoutTime, 15000)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster ID: %s in usable state\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterKubeConfigAvailable(startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster ID: %s in usable state as unable to retrieve kube-config for the cluster\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterDashboardServiceRunning(false, startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster ID: %s in usable state as unable to get Dashboard service running for the cluster\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.OperationSucceeded);\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Kubernetes cluster ID: %s successfully started\", kubernetesCluster.getUuid()));\n        }\n        return true;\n    }\n","realPath":"plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterStartWorker.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":571,"status":"M"}],"commitId":"a5d4bd5f5a0a87509fe258ee4856c2b4d27ba746","commitMessage":"@@@Display Kubernetes cluster name instead of uuid (#4411)\n\n","date":"2020-10-21 20:01:56","modifiedFileCount":"2","status":"M","submitter":"Rakesh"},{"authorTime":"2020-10-27 14:45:43","codes":[{"authorDate":"2020-10-27 14:45:43","commitOrder":3,"curCode":"    public boolean startKubernetesClusterOnCreate() {\n        init();\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Starting Kubernetes cluster : %s\", kubernetesCluster.getName()));\n        }\n        final long startTimeoutTime = System.currentTimeMillis() + KubernetesClusterService.KubernetesClusterStartTimeout.value() * 1000;\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.StartRequested);\n        DeployDestination dest = null;\n        try {\n            dest = plan();\n        } catch (InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning the cluster failed due to insufficient capacity in the Kubernetes cluster: %s\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        Network network = null;\n        try {\n            network = startKubernetesClusterNetwork(dest);\n        } catch (ManagementServerException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s as its network cannot be started\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        Pair<String, Integer> publicIpSshPort = getKubernetesClusterServerIpSshPort(null);\n        publicIpAddress = publicIpSshPort.first();\n        if (Strings.isNullOrEmpty(publicIpAddress) &&\n                (Network.GuestType.Isolated.equals(network.getGuestType()) || kubernetesCluster.getMasterNodeCount() > 1)) { \r\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s as no public IP found for the cluster\" , kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n        }\n        List<UserVm> clusterVMs = new ArrayList<>();\n        UserVm k8sMasterVM = null;\n        try {\n            k8sMasterVM = provisionKubernetesClusterMasterVm(network, publicIpAddress);\n        } catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning the master VM failed in the Kubernetes cluster : %s\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        clusterVMs.add(k8sMasterVM);\n        if (Strings.isNullOrEmpty(publicIpAddress)) {\n            publicIpSshPort = getKubernetesClusterServerIpSshPort(k8sMasterVM);\n            publicIpAddress = publicIpSshPort.first();\n            if (Strings.isNullOrEmpty(publicIpAddress)) {\n                logTransitStateAndThrow(Level.WARN, String.format(\"Failed to start Kubernetes cluster : %s as no public IP found for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n            }\n        }\n        try {\n            List<UserVm> additionalMasterVMs = provisionKubernetesClusterAdditionalMasterVms(publicIpAddress);\n            clusterVMs.addAll(additionalMasterVMs);\n        }  catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning additional master VM failed in the Kubernetes cluster : %s\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        try {\n            List<UserVm> nodeVMs = provisionKubernetesClusterNodeVms(kubernetesCluster.getNodeCount(), publicIpAddress);\n            clusterVMs.addAll(nodeVMs);\n        }  catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning node VM failed in the Kubernetes cluster : %s\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Kubernetes cluster : %s VMs successfully provisioned\", kubernetesCluster.getName()));\n        }\n        try {\n            setupKubernetesClusterNetworkRules(network, clusterVMs);\n        } catch (ManagementServerException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster : %s, unable to setup network rules\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        attachIsoKubernetesVMs(clusterVMs);\n        if (!KubernetesClusterUtil.isKubernetesClusterMasterVmRunning(kubernetesCluster, publicIpAddress, publicIpSshPort.second(), startTimeoutTime)) {\n            String msg = String.format(\"Failed to setup Kubernetes cluster : %s in usable state as unable to access master node VMs of the cluster\", kubernetesCluster.getName());\n            if (kubernetesCluster.getMasterNodeCount() > 1 && Network.GuestType.Shared.equals(network.getGuestType())) {\n                msg = String.format(\"%s. Make sure external load-balancer has port forwarding rules for SSH access on ports %d-%d and API access on port %d\",\n                        msg,\n                        CLUSTER_NODES_DEFAULT_START_SSH_PORT,\n                        CLUSTER_NODES_DEFAULT_START_SSH_PORT + kubernetesCluster.getTotalNodeCount() - 1,\n                        CLUSTER_API_PORT);\n            }\n            logTransitStateDetachIsoAndThrow(Level.ERROR, msg, kubernetesCluster, clusterVMs, KubernetesCluster.Event.CreateFailed, null);\n        }\n        boolean k8sApiServerSetup = KubernetesClusterUtil.isKubernetesClusterServerRunning(kubernetesCluster, publicIpAddress, CLUSTER_API_PORT, startTimeoutTime, 15000);\n        if (!k8sApiServerSetup) {\n            logTransitStateDetachIsoAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster : %s in usable state as unable to provision API endpoint for the cluster\", kubernetesCluster.getName()), kubernetesCluster, clusterVMs, KubernetesCluster.Event.CreateFailed, null);\n        }\n        sshPort = publicIpSshPort.second();\n        updateKubernetesClusterEntryEndpoint();\n        boolean readyNodesCountValid = KubernetesClusterUtil.validateKubernetesClusterReadyNodesCount(kubernetesCluster, publicIpAddress, sshPort,\n                CLUSTER_NODE_VM_USER, sshKeyFile, startTimeoutTime, 15000);\n        detachIsoKubernetesVMs(clusterVMs);\n        if (!readyNodesCountValid) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster : %s as it does not have desired number of nodes in ready state\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n        }\n        if (!isKubernetesClusterKubeConfigAvailable(startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster : %s in usable state as unable to retrieve kube-config for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterDashboardServiceRunning(true, startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster : %s in usable state as unable to get Dashboard service running for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(),KubernetesCluster.Event.OperationFailed);\n        }\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.OperationSucceeded);\n        return true;\n    }\n","date":"2020-10-27 14:45:43","endLine":570,"groupId":"22412","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"startKubernetesClusterOnCreate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/85/5c264d6906f9beb7a3ef517cfe9586ff7fff0e.src","preCode":"    public boolean startKubernetesClusterOnCreate() {\n        init();\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Starting Kubernetes cluster ID: %s\", kubernetesCluster.getUuid()));\n        }\n        final long startTimeoutTime = System.currentTimeMillis() + KubernetesClusterService.KubernetesClusterStartTimeout.value() * 1000;\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.StartRequested);\n        DeployDestination dest = null;\n        try {\n            dest = plan();\n        } catch (InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning the cluster failed due to insufficient capacity in the Kubernetes cluster: %s\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        Network network = null;\n        try {\n            network = startKubernetesClusterNetwork(dest);\n        } catch (ManagementServerException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster ID: %s as its network cannot be started\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        Pair<String, Integer> publicIpSshPort = getKubernetesClusterServerIpSshPort(null);\n        publicIpAddress = publicIpSshPort.first();\n        if (Strings.isNullOrEmpty(publicIpAddress) &&\n                (Network.GuestType.Isolated.equals(network.getGuestType()) || kubernetesCluster.getMasterNodeCount() > 1)) { \r\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster ID: %s as no public IP found for the cluster\" , kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n        }\n        List<UserVm> clusterVMs = new ArrayList<>();\n        UserVm k8sMasterVM = null;\n        try {\n            k8sMasterVM = provisionKubernetesClusterMasterVm(network, publicIpAddress);\n        } catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning the master VM failed in the Kubernetes cluster ID: %s\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        clusterVMs.add(k8sMasterVM);\n        if (Strings.isNullOrEmpty(publicIpAddress)) {\n            publicIpSshPort = getKubernetesClusterServerIpSshPort(k8sMasterVM);\n            publicIpAddress = publicIpSshPort.first();\n            if (Strings.isNullOrEmpty(publicIpAddress)) {\n                logTransitStateAndThrow(Level.WARN, String.format(\"Failed to start Kubernetes cluster ID: %s as no public IP found for the cluster\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n            }\n        }\n        try {\n            List<UserVm> additionalMasterVMs = provisionKubernetesClusterAdditionalMasterVms(publicIpAddress);\n            clusterVMs.addAll(additionalMasterVMs);\n        }  catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning additional master VM failed in the Kubernetes cluster ID: %s\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        try {\n            List<UserVm> nodeVMs = provisionKubernetesClusterNodeVms(kubernetesCluster.getNodeCount(), publicIpAddress);\n            clusterVMs.addAll(nodeVMs);\n        }  catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning node VM failed in the Kubernetes cluster ID: %s\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Kubernetes cluster ID: %s VMs successfully provisioned\", kubernetesCluster.getUuid()));\n        }\n        try {\n            setupKubernetesClusterNetworkRules(network, clusterVMs);\n        } catch (ManagementServerException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster ID: %s, unable to setup network rules\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        attachIsoKubernetesVMs(clusterVMs);\n        if (!KubernetesClusterUtil.isKubernetesClusterMasterVmRunning(kubernetesCluster, publicIpAddress, publicIpSshPort.second(), startTimeoutTime)) {\n            String msg = String.format(\"Failed to setup Kubernetes cluster ID: %s in usable state as unable to access master node VMs of the cluster\", kubernetesCluster.getUuid());\n            if (kubernetesCluster.getMasterNodeCount() > 1 && Network.GuestType.Shared.equals(network.getGuestType())) {\n                msg = String.format(\"%s. Make sure external load-balancer has port forwarding rules for SSH access on ports %d-%d and API access on port %d\",\n                        msg,\n                        CLUSTER_NODES_DEFAULT_START_SSH_PORT,\n                        CLUSTER_NODES_DEFAULT_START_SSH_PORT + kubernetesCluster.getTotalNodeCount() - 1,\n                        CLUSTER_API_PORT);\n            }\n            logTransitStateDetachIsoAndThrow(Level.ERROR, msg, kubernetesCluster, clusterVMs, KubernetesCluster.Event.CreateFailed, null);\n        }\n        boolean k8sApiServerSetup = KubernetesClusterUtil.isKubernetesClusterServerRunning(kubernetesCluster, publicIpAddress, CLUSTER_API_PORT, startTimeoutTime, 15000);\n        if (!k8sApiServerSetup) {\n            logTransitStateDetachIsoAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster ID: %s in usable state as unable to provision API endpoint for the cluster\", kubernetesCluster.getUuid()), kubernetesCluster, clusterVMs, KubernetesCluster.Event.CreateFailed, null);\n        }\n        sshPort = publicIpSshPort.second();\n        updateKubernetesClusterEntryEndpoint();\n        boolean readyNodesCountValid = KubernetesClusterUtil.validateKubernetesClusterReadyNodesCount(kubernetesCluster, publicIpAddress, sshPort,\n                CLUSTER_NODE_VM_USER, sshKeyFile, startTimeoutTime, 15000);\n        detachIsoKubernetesVMs(clusterVMs);\n        if (!readyNodesCountValid) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster ID: %s as it does not have desired number of nodes in ready state\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n        }\n        if (!isKubernetesClusterKubeConfigAvailable(startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster ID: %s in usable state as unable to retrieve kube-config for the cluster\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterDashboardServiceRunning(true, startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster ID: %s in usable state as unable to get Dashboard service running for the cluster\", kubernetesCluster.getUuid()), kubernetesCluster.getId(),KubernetesCluster.Event.OperationFailed);\n        }\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.OperationSucceeded);\n        return true;\n    }\n","realPath":"plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterStartWorker.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":478,"status":"M"},{"authorDate":"2020-10-27 14:45:43","commitOrder":3,"curCode":"    public boolean startStoppedKubernetesCluster() throws CloudRuntimeException {\n        init();\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Starting Kubernetes cluster : %s\", kubernetesCluster.getName()));\n        }\n        final long startTimeoutTime = System.currentTimeMillis() + KubernetesClusterService.KubernetesClusterStartTimeout.value() * 1000;\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.StartRequested);\n        startKubernetesClusterVMs();\n        try {\n            InetAddress address = InetAddress.getByName(new URL(kubernetesCluster.getEndpoint()).getHost());\n        } catch (MalformedURLException | UnknownHostException ex) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Kubernetes cluster : %s has invalid API endpoint. Can not verify if cluster is in ready state\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        Pair<String, Integer> sshIpPort =  getKubernetesClusterServerIpSshPort(null);\n        publicIpAddress = sshIpPort.first();\n        sshPort = sshIpPort.second();\n        if (Strings.isNullOrEmpty(publicIpAddress)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s as no public IP found for the cluster\" , kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!KubernetesClusterUtil.isKubernetesClusterServerRunning(kubernetesCluster, publicIpAddress, CLUSTER_API_PORT, startTimeoutTime, 15000)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s in usable state\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterKubeConfigAvailable(startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s in usable state as unable to retrieve kube-config for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterDashboardServiceRunning(false, startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s in usable state as unable to get Dashboard service running for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.OperationSucceeded);\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Kubernetes cluster : %s successfully started\", kubernetesCluster.getName()));\n        }\n        return true;\n    }\n","date":"2020-10-27 14:45:43","endLine":605,"groupId":"22410","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"startStoppedKubernetesCluster","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/85/5c264d6906f9beb7a3ef517cfe9586ff7fff0e.src","preCode":"    public boolean startStoppedKubernetesCluster() throws CloudRuntimeException {\n        init();\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Starting Kubernetes cluster ID: %s\", kubernetesCluster.getUuid()));\n        }\n        final long startTimeoutTime = System.currentTimeMillis() + KubernetesClusterService.KubernetesClusterStartTimeout.value() * 1000;\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.StartRequested);\n        startKubernetesClusterVMs();\n        try {\n            InetAddress address = InetAddress.getByName(new URL(kubernetesCluster.getEndpoint()).getHost());\n        } catch (MalformedURLException | UnknownHostException ex) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Kubernetes cluster : %s has invalid API endpoint. Can not verify if cluster is in ready state\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        Pair<String, Integer> sshIpPort =  getKubernetesClusterServerIpSshPort(null);\n        publicIpAddress = sshIpPort.first();\n        sshPort = sshIpPort.second();\n        if (Strings.isNullOrEmpty(publicIpAddress)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s as no public IP found for the cluster\" , kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!KubernetesClusterUtil.isKubernetesClusterServerRunning(kubernetesCluster, publicIpAddress, CLUSTER_API_PORT, startTimeoutTime, 15000)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s in usable state\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterKubeConfigAvailable(startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s in usable state as unable to retrieve kube-config for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterDashboardServiceRunning(false, startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s in usable state as unable to get Dashboard service running for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.OperationSucceeded);\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Kubernetes cluster ID: %s successfully started\", kubernetesCluster.getUuid()));\n        }\n        return true;\n    }\n","realPath":"plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterStartWorker.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":572,"status":"M"}],"commitId":"86f2b796cfd4d6758dff322ce31ae880a9c4e02b","commitMessage":"@@@CKS : More log changes from uuid to name (#4415)\n\n","date":"2020-10-27 14:45:43","modifiedFileCount":"9","status":"M","submitter":"davidjumani"},{"authorTime":"2020-10-27 14:45:43","codes":[{"authorDate":"2021-06-08 18:14:53","commitOrder":4,"curCode":"    public boolean startKubernetesClusterOnCreate() {\n        init();\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Starting Kubernetes cluster : %s\", kubernetesCluster.getName()));\n        }\n        final long startTimeoutTime = System.currentTimeMillis() + KubernetesClusterService.KubernetesClusterStartTimeout.value() * 1000;\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.StartRequested);\n        DeployDestination dest = null;\n        try {\n            dest = plan();\n        } catch (InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning the cluster failed due to insufficient capacity in the Kubernetes cluster: %s\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        Network network = null;\n        try {\n            network = startKubernetesClusterNetwork(dest);\n        } catch (ManagementServerException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s as its network cannot be started\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        Pair<String, Integer> publicIpSshPort = getKubernetesClusterServerIpSshPort(null);\n        publicIpAddress = publicIpSshPort.first();\n        if (Strings.isNullOrEmpty(publicIpAddress) &&\n                (Network.GuestType.Isolated.equals(network.getGuestType()) || kubernetesCluster.getControlNodeCount() > 1)) { \r\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s as no public IP found for the cluster\" , kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n        }\n        List<UserVm> clusterVMs = new ArrayList<>();\n        UserVm k8sControlVM = null;\n        try {\n            k8sControlVM = provisionKubernetesClusterControlVm(network, publicIpAddress);\n        } catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning the control VM failed in the Kubernetes cluster : %s\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        clusterVMs.add(k8sControlVM);\n        if (Strings.isNullOrEmpty(publicIpAddress)) {\n            publicIpSshPort = getKubernetesClusterServerIpSshPort(k8sControlVM);\n            publicIpAddress = publicIpSshPort.first();\n            if (Strings.isNullOrEmpty(publicIpAddress)) {\n                logTransitStateAndThrow(Level.WARN, String.format(\"Failed to start Kubernetes cluster : %s as no public IP found for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n            }\n        }\n        try {\n            List<UserVm> additionalControlVMs = provisionKubernetesClusterAdditionalControlVms(publicIpAddress);\n            clusterVMs.addAll(additionalControlVMs);\n        }  catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning additional control VM failed in the Kubernetes cluster : %s\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        try {\n            List<UserVm> nodeVMs = provisionKubernetesClusterNodeVms(kubernetesCluster.getNodeCount(), publicIpAddress);\n            clusterVMs.addAll(nodeVMs);\n        }  catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning node VM failed in the Kubernetes cluster : %s\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Kubernetes cluster : %s VMs successfully provisioned\", kubernetesCluster.getName()));\n        }\n        try {\n            setupKubernetesClusterNetworkRules(network, clusterVMs);\n        } catch (ManagementServerException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster : %s, unable to setup network rules\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        attachIsoKubernetesVMs(clusterVMs);\n        if (!KubernetesClusterUtil.isKubernetesClusterControlVmRunning(kubernetesCluster, publicIpAddress, publicIpSshPort.second(), startTimeoutTime)) {\n            String msg = String.format(\"Failed to setup Kubernetes cluster : %s in usable state as unable to access control node VMs of the cluster\", kubernetesCluster.getName());\n            if (kubernetesCluster.getControlNodeCount() > 1 && Network.GuestType.Shared.equals(network.getGuestType())) {\n                msg = String.format(\"%s. Make sure external load-balancer has port forwarding rules for SSH access on ports %d-%d and API access on port %d\",\n                        msg,\n                        CLUSTER_NODES_DEFAULT_START_SSH_PORT,\n                        CLUSTER_NODES_DEFAULT_START_SSH_PORT + kubernetesCluster.getTotalNodeCount() - 1,\n                        CLUSTER_API_PORT);\n            }\n            logTransitStateDetachIsoAndThrow(Level.ERROR, msg, kubernetesCluster, clusterVMs, KubernetesCluster.Event.CreateFailed, null);\n        }\n        boolean k8sApiServerSetup = KubernetesClusterUtil.isKubernetesClusterServerRunning(kubernetesCluster, publicIpAddress, CLUSTER_API_PORT, startTimeoutTime, 15000);\n        if (!k8sApiServerSetup) {\n            logTransitStateDetachIsoAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster : %s in usable state as unable to provision API endpoint for the cluster\", kubernetesCluster.getName()), kubernetesCluster, clusterVMs, KubernetesCluster.Event.CreateFailed, null);\n        }\n        sshPort = publicIpSshPort.second();\n        updateKubernetesClusterEntryEndpoint();\n        boolean readyNodesCountValid = KubernetesClusterUtil.validateKubernetesClusterReadyNodesCount(kubernetesCluster, publicIpAddress, sshPort,\n                CLUSTER_NODE_VM_USER, sshKeyFile, startTimeoutTime, 15000);\n        detachIsoKubernetesVMs(clusterVMs);\n        if (!readyNodesCountValid) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster : %s as it does not have desired number of nodes in ready state\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n        }\n        if (!isKubernetesClusterKubeConfigAvailable(startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster : %s in usable state as unable to retrieve kube-config for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterDashboardServiceRunning(true, startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster : %s in usable state as unable to get Dashboard service running for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(),KubernetesCluster.Event.OperationFailed);\n        }\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.OperationSucceeded);\n        return true;\n    }\n","date":"2021-06-08 18:17:20","endLine":576,"groupId":"22412","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"startKubernetesClusterOnCreate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/54/c3a6228d132dfd6751cf45008521c577829de9.src","preCode":"    public boolean startKubernetesClusterOnCreate() {\n        init();\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Starting Kubernetes cluster : %s\", kubernetesCluster.getName()));\n        }\n        final long startTimeoutTime = System.currentTimeMillis() + KubernetesClusterService.KubernetesClusterStartTimeout.value() * 1000;\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.StartRequested);\n        DeployDestination dest = null;\n        try {\n            dest = plan();\n        } catch (InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning the cluster failed due to insufficient capacity in the Kubernetes cluster: %s\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        Network network = null;\n        try {\n            network = startKubernetesClusterNetwork(dest);\n        } catch (ManagementServerException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s as its network cannot be started\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        Pair<String, Integer> publicIpSshPort = getKubernetesClusterServerIpSshPort(null);\n        publicIpAddress = publicIpSshPort.first();\n        if (Strings.isNullOrEmpty(publicIpAddress) &&\n                (Network.GuestType.Isolated.equals(network.getGuestType()) || kubernetesCluster.getMasterNodeCount() > 1)) { \r\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s as no public IP found for the cluster\" , kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n        }\n        List<UserVm> clusterVMs = new ArrayList<>();\n        UserVm k8sMasterVM = null;\n        try {\n            k8sMasterVM = provisionKubernetesClusterMasterVm(network, publicIpAddress);\n        } catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning the master VM failed in the Kubernetes cluster : %s\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        clusterVMs.add(k8sMasterVM);\n        if (Strings.isNullOrEmpty(publicIpAddress)) {\n            publicIpSshPort = getKubernetesClusterServerIpSshPort(k8sMasterVM);\n            publicIpAddress = publicIpSshPort.first();\n            if (Strings.isNullOrEmpty(publicIpAddress)) {\n                logTransitStateAndThrow(Level.WARN, String.format(\"Failed to start Kubernetes cluster : %s as no public IP found for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n            }\n        }\n        try {\n            List<UserVm> additionalMasterVMs = provisionKubernetesClusterAdditionalMasterVms(publicIpAddress);\n            clusterVMs.addAll(additionalMasterVMs);\n        }  catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning additional master VM failed in the Kubernetes cluster : %s\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        try {\n            List<UserVm> nodeVMs = provisionKubernetesClusterNodeVms(kubernetesCluster.getNodeCount(), publicIpAddress);\n            clusterVMs.addAll(nodeVMs);\n        }  catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning node VM failed in the Kubernetes cluster : %s\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Kubernetes cluster : %s VMs successfully provisioned\", kubernetesCluster.getName()));\n        }\n        try {\n            setupKubernetesClusterNetworkRules(network, clusterVMs);\n        } catch (ManagementServerException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster : %s, unable to setup network rules\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        attachIsoKubernetesVMs(clusterVMs);\n        if (!KubernetesClusterUtil.isKubernetesClusterMasterVmRunning(kubernetesCluster, publicIpAddress, publicIpSshPort.second(), startTimeoutTime)) {\n            String msg = String.format(\"Failed to setup Kubernetes cluster : %s in usable state as unable to access master node VMs of the cluster\", kubernetesCluster.getName());\n            if (kubernetesCluster.getMasterNodeCount() > 1 && Network.GuestType.Shared.equals(network.getGuestType())) {\n                msg = String.format(\"%s. Make sure external load-balancer has port forwarding rules for SSH access on ports %d-%d and API access on port %d\",\n                        msg,\n                        CLUSTER_NODES_DEFAULT_START_SSH_PORT,\n                        CLUSTER_NODES_DEFAULT_START_SSH_PORT + kubernetesCluster.getTotalNodeCount() - 1,\n                        CLUSTER_API_PORT);\n            }\n            logTransitStateDetachIsoAndThrow(Level.ERROR, msg, kubernetesCluster, clusterVMs, KubernetesCluster.Event.CreateFailed, null);\n        }\n        boolean k8sApiServerSetup = KubernetesClusterUtil.isKubernetesClusterServerRunning(kubernetesCluster, publicIpAddress, CLUSTER_API_PORT, startTimeoutTime, 15000);\n        if (!k8sApiServerSetup) {\n            logTransitStateDetachIsoAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster : %s in usable state as unable to provision API endpoint for the cluster\", kubernetesCluster.getName()), kubernetesCluster, clusterVMs, KubernetesCluster.Event.CreateFailed, null);\n        }\n        sshPort = publicIpSshPort.second();\n        updateKubernetesClusterEntryEndpoint();\n        boolean readyNodesCountValid = KubernetesClusterUtil.validateKubernetesClusterReadyNodesCount(kubernetesCluster, publicIpAddress, sshPort,\n                CLUSTER_NODE_VM_USER, sshKeyFile, startTimeoutTime, 15000);\n        detachIsoKubernetesVMs(clusterVMs);\n        if (!readyNodesCountValid) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster : %s as it does not have desired number of nodes in ready state\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n        }\n        if (!isKubernetesClusterKubeConfigAvailable(startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster : %s in usable state as unable to retrieve kube-config for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterDashboardServiceRunning(true, startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster : %s in usable state as unable to get Dashboard service running for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(),KubernetesCluster.Event.OperationFailed);\n        }\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.OperationSucceeded);\n        return true;\n    }\n","realPath":"plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterStartWorker.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":484,"status":"M"},{"authorDate":"2020-10-27 14:45:43","commitOrder":4,"curCode":"    public boolean startStoppedKubernetesCluster() throws CloudRuntimeException {\n        init();\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Starting Kubernetes cluster : %s\", kubernetesCluster.getName()));\n        }\n        final long startTimeoutTime = System.currentTimeMillis() + KubernetesClusterService.KubernetesClusterStartTimeout.value() * 1000;\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.StartRequested);\n        startKubernetesClusterVMs();\n        try {\n            InetAddress address = InetAddress.getByName(new URL(kubernetesCluster.getEndpoint()).getHost());\n        } catch (MalformedURLException | UnknownHostException ex) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Kubernetes cluster : %s has invalid API endpoint. Can not verify if cluster is in ready state\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        Pair<String, Integer> sshIpPort =  getKubernetesClusterServerIpSshPort(null);\n        publicIpAddress = sshIpPort.first();\n        sshPort = sshIpPort.second();\n        if (Strings.isNullOrEmpty(publicIpAddress)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s as no public IP found for the cluster\" , kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!KubernetesClusterUtil.isKubernetesClusterServerRunning(kubernetesCluster, publicIpAddress, CLUSTER_API_PORT, startTimeoutTime, 15000)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s in usable state\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterKubeConfigAvailable(startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s in usable state as unable to retrieve kube-config for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterDashboardServiceRunning(false, startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s in usable state as unable to get Dashboard service running for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.OperationSucceeded);\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Kubernetes cluster : %s successfully started\", kubernetesCluster.getName()));\n        }\n        return true;\n    }\n","date":"2020-10-27 14:45:43","endLine":605,"groupId":"22410","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"startStoppedKubernetesCluster","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/85/5c264d6906f9beb7a3ef517cfe9586ff7fff0e.src","preCode":"    public boolean startStoppedKubernetesCluster() throws CloudRuntimeException {\n        init();\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Starting Kubernetes cluster : %s\", kubernetesCluster.getName()));\n        }\n        final long startTimeoutTime = System.currentTimeMillis() + KubernetesClusterService.KubernetesClusterStartTimeout.value() * 1000;\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.StartRequested);\n        startKubernetesClusterVMs();\n        try {\n            InetAddress address = InetAddress.getByName(new URL(kubernetesCluster.getEndpoint()).getHost());\n        } catch (MalformedURLException | UnknownHostException ex) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Kubernetes cluster : %s has invalid API endpoint. Can not verify if cluster is in ready state\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        Pair<String, Integer> sshIpPort =  getKubernetesClusterServerIpSshPort(null);\n        publicIpAddress = sshIpPort.first();\n        sshPort = sshIpPort.second();\n        if (Strings.isNullOrEmpty(publicIpAddress)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s as no public IP found for the cluster\" , kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!KubernetesClusterUtil.isKubernetesClusterServerRunning(kubernetesCluster, publicIpAddress, CLUSTER_API_PORT, startTimeoutTime, 15000)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s in usable state\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterKubeConfigAvailable(startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s in usable state as unable to retrieve kube-config for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterDashboardServiceRunning(false, startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s in usable state as unable to get Dashboard service running for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.OperationSucceeded);\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Kubernetes cluster : %s successfully started\", kubernetesCluster.getName()));\n        }\n        return true;\n    }\n","realPath":"plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterStartWorker.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":572,"status":"N"}],"commitId":"958182481e200afa95f04022fe37044393085265","commitMessage":"@@@cloudstack: make code more inclusive\n\nInclusivity changes for CloudStack\n\n- Change default git branch name from 'master' to 'main' (post renaming/changing default git branch to 'main' in git repo)\n- Rename some offensive words/terms as appropriate for inclusiveness.\n\nThis PR updates the default git branch to 'main'.  as part of #4887.\n\nSigned-off-by: Suresh Kumar Anaparti <suresh.anaparti@shapeblue.com>\nSigned-off-by: Rohit Yadav <rohit.yadav@shapeblue.com>\n","date":"2021-06-08 18:17:20","modifiedFileCount":"68","status":"M","submitter":"Suresh Kumar Anaparti"},{"authorTime":"2020-10-27 14:45:43","codes":[{"authorDate":"2021-08-09 17:15:20","commitOrder":5,"curCode":"    public boolean startKubernetesClusterOnCreate() {\n        init();\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Starting Kubernetes cluster : %s\", kubernetesCluster.getName()));\n        }\n        final long startTimeoutTime = System.currentTimeMillis() + KubernetesClusterService.KubernetesClusterStartTimeout.value() * 1000;\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.StartRequested);\n        DeployDestination dest = null;\n        try {\n            dest = plan();\n        } catch (InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning the cluster failed due to insufficient capacity in the Kubernetes cluster: %s\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        Network network = null;\n        try {\n            network = startKubernetesClusterNetwork(dest);\n        } catch (ManagementServerException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s as its network cannot be started\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        Pair<String, Integer> publicIpSshPort = getKubernetesClusterServerIpSshPort(null);\n        publicIpAddress = publicIpSshPort.first();\n        if (Strings.isNullOrEmpty(publicIpAddress) &&\n                (Network.GuestType.Isolated.equals(network.getGuestType()) || kubernetesCluster.getControlNodeCount() > 1)) { \r\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s as no public IP found for the cluster\" , kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n        }\n        List<UserVm> clusterVMs = new ArrayList<>();\n        UserVm k8sControlVM = null;\n        try {\n            k8sControlVM = provisionKubernetesClusterControlVm(network, publicIpAddress);\n        } catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning the control VM failed in the Kubernetes cluster : %s\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        clusterVMs.add(k8sControlVM);\n        if (Strings.isNullOrEmpty(publicIpAddress)) {\n            publicIpSshPort = getKubernetesClusterServerIpSshPort(k8sControlVM);\n            publicIpAddress = publicIpSshPort.first();\n            if (Strings.isNullOrEmpty(publicIpAddress)) {\n                logTransitStateAndThrow(Level.WARN, String.format(\"Failed to start Kubernetes cluster : %s as no public IP found for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n            }\n        }\n        try {\n            List<UserVm> additionalControlVMs = provisionKubernetesClusterAdditionalControlVms(publicIpAddress);\n            clusterVMs.addAll(additionalControlVMs);\n        }  catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning additional control VM failed in the Kubernetes cluster : %s\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        try {\n            List<UserVm> nodeVMs = provisionKubernetesClusterNodeVms(kubernetesCluster.getNodeCount(), publicIpAddress);\n            clusterVMs.addAll(nodeVMs);\n        }  catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning node VM failed in the Kubernetes cluster : %s\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Kubernetes cluster : %s VMs successfully provisioned\", kubernetesCluster.getName()));\n        }\n        try {\n            setupKubernetesClusterNetworkRules(network, clusterVMs);\n        } catch (ManagementServerException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster : %s, unable to setup network rules\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        attachIsoKubernetesVMs(clusterVMs);\n        if (!KubernetesClusterUtil.isKubernetesClusterControlVmRunning(kubernetesCluster, publicIpAddress, publicIpSshPort.second(), startTimeoutTime)) {\n            String msg = String.format(\"Failed to setup Kubernetes cluster : %s in usable state as unable to access control node VMs of the cluster\", kubernetesCluster.getName());\n            if (kubernetesCluster.getControlNodeCount() > 1 && Network.GuestType.Shared.equals(network.getGuestType())) {\n                msg = String.format(\"%s. Make sure external load-balancer has port forwarding rules for SSH access on ports %d-%d and API access on port %d\",\n                        msg,\n                        CLUSTER_NODES_DEFAULT_START_SSH_PORT,\n                        CLUSTER_NODES_DEFAULT_START_SSH_PORT + kubernetesCluster.getTotalNodeCount() - 1,\n                        CLUSTER_API_PORT);\n            }\n            logTransitStateDetachIsoAndThrow(Level.ERROR, msg, kubernetesCluster, clusterVMs, KubernetesCluster.Event.CreateFailed, null);\n        }\n        boolean k8sApiServerSetup = KubernetesClusterUtil.isKubernetesClusterServerRunning(kubernetesCluster, publicIpAddress, CLUSTER_API_PORT, startTimeoutTime, 15000);\n        if (!k8sApiServerSetup) {\n            logTransitStateDetachIsoAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster : %s in usable state as unable to provision API endpoint for the cluster\", kubernetesCluster.getName()), kubernetesCluster, clusterVMs, KubernetesCluster.Event.CreateFailed, null);\n        }\n        sshPort = publicIpSshPort.second();\n        updateKubernetesClusterEntryEndpoint();\n        boolean readyNodesCountValid = KubernetesClusterUtil.validateKubernetesClusterReadyNodesCount(kubernetesCluster, publicIpAddress, sshPort,\n                CLUSTER_NODE_VM_USER, sshKeyFile, startTimeoutTime, 15000);\n        detachIsoKubernetesVMs(clusterVMs);\n        if (!readyNodesCountValid) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster : %s as it does not have desired number of nodes in ready state\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n        }\n        if (!isKubernetesClusterKubeConfigAvailable(startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster : %s in usable state as unable to retrieve kube-config for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterDashboardServiceRunning(true, startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster : %s in usable state as unable to get Dashboard service running for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(),KubernetesCluster.Event.OperationFailed);\n        }\n        deployProvider();\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.OperationSucceeded);\n        return true;\n    }\n","date":"2021-08-09 17:15:20","endLine":577,"groupId":"104224","id":9,"instanceNumber":1,"isCurCommit":1,"methodName":"startKubernetesClusterOnCreate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/07/2094e7c031714772264de94046b733ada2a89d.src","preCode":"    public boolean startKubernetesClusterOnCreate() {\n        init();\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Starting Kubernetes cluster : %s\", kubernetesCluster.getName()));\n        }\n        final long startTimeoutTime = System.currentTimeMillis() + KubernetesClusterService.KubernetesClusterStartTimeout.value() * 1000;\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.StartRequested);\n        DeployDestination dest = null;\n        try {\n            dest = plan();\n        } catch (InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning the cluster failed due to insufficient capacity in the Kubernetes cluster: %s\", kubernetesCluster.getUuid()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        Network network = null;\n        try {\n            network = startKubernetesClusterNetwork(dest);\n        } catch (ManagementServerException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s as its network cannot be started\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        Pair<String, Integer> publicIpSshPort = getKubernetesClusterServerIpSshPort(null);\n        publicIpAddress = publicIpSshPort.first();\n        if (Strings.isNullOrEmpty(publicIpAddress) &&\n                (Network.GuestType.Isolated.equals(network.getGuestType()) || kubernetesCluster.getControlNodeCount() > 1)) { \r\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s as no public IP found for the cluster\" , kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n        }\n        List<UserVm> clusterVMs = new ArrayList<>();\n        UserVm k8sControlVM = null;\n        try {\n            k8sControlVM = provisionKubernetesClusterControlVm(network, publicIpAddress);\n        } catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning the control VM failed in the Kubernetes cluster : %s\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        clusterVMs.add(k8sControlVM);\n        if (Strings.isNullOrEmpty(publicIpAddress)) {\n            publicIpSshPort = getKubernetesClusterServerIpSshPort(k8sControlVM);\n            publicIpAddress = publicIpSshPort.first();\n            if (Strings.isNullOrEmpty(publicIpAddress)) {\n                logTransitStateAndThrow(Level.WARN, String.format(\"Failed to start Kubernetes cluster : %s as no public IP found for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n            }\n        }\n        try {\n            List<UserVm> additionalControlVMs = provisionKubernetesClusterAdditionalControlVms(publicIpAddress);\n            clusterVMs.addAll(additionalControlVMs);\n        }  catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning additional control VM failed in the Kubernetes cluster : %s\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        try {\n            List<UserVm> nodeVMs = provisionKubernetesClusterNodeVms(kubernetesCluster.getNodeCount(), publicIpAddress);\n            clusterVMs.addAll(nodeVMs);\n        }  catch (CloudRuntimeException | ManagementServerException | ResourceUnavailableException | InsufficientCapacityException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Provisioning node VM failed in the Kubernetes cluster : %s\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Kubernetes cluster : %s VMs successfully provisioned\", kubernetesCluster.getName()));\n        }\n        try {\n            setupKubernetesClusterNetworkRules(network, clusterVMs);\n        } catch (ManagementServerException e) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster : %s, unable to setup network rules\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed, e);\n        }\n        attachIsoKubernetesVMs(clusterVMs);\n        if (!KubernetesClusterUtil.isKubernetesClusterControlVmRunning(kubernetesCluster, publicIpAddress, publicIpSshPort.second(), startTimeoutTime)) {\n            String msg = String.format(\"Failed to setup Kubernetes cluster : %s in usable state as unable to access control node VMs of the cluster\", kubernetesCluster.getName());\n            if (kubernetesCluster.getControlNodeCount() > 1 && Network.GuestType.Shared.equals(network.getGuestType())) {\n                msg = String.format(\"%s. Make sure external load-balancer has port forwarding rules for SSH access on ports %d-%d and API access on port %d\",\n                        msg,\n                        CLUSTER_NODES_DEFAULT_START_SSH_PORT,\n                        CLUSTER_NODES_DEFAULT_START_SSH_PORT + kubernetesCluster.getTotalNodeCount() - 1,\n                        CLUSTER_API_PORT);\n            }\n            logTransitStateDetachIsoAndThrow(Level.ERROR, msg, kubernetesCluster, clusterVMs, KubernetesCluster.Event.CreateFailed, null);\n        }\n        boolean k8sApiServerSetup = KubernetesClusterUtil.isKubernetesClusterServerRunning(kubernetesCluster, publicIpAddress, CLUSTER_API_PORT, startTimeoutTime, 15000);\n        if (!k8sApiServerSetup) {\n            logTransitStateDetachIsoAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster : %s in usable state as unable to provision API endpoint for the cluster\", kubernetesCluster.getName()), kubernetesCluster, clusterVMs, KubernetesCluster.Event.CreateFailed, null);\n        }\n        sshPort = publicIpSshPort.second();\n        updateKubernetesClusterEntryEndpoint();\n        boolean readyNodesCountValid = KubernetesClusterUtil.validateKubernetesClusterReadyNodesCount(kubernetesCluster, publicIpAddress, sshPort,\n                CLUSTER_NODE_VM_USER, sshKeyFile, startTimeoutTime, 15000);\n        detachIsoKubernetesVMs(clusterVMs);\n        if (!readyNodesCountValid) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster : %s as it does not have desired number of nodes in ready state\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.CreateFailed);\n        }\n        if (!isKubernetesClusterKubeConfigAvailable(startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster : %s in usable state as unable to retrieve kube-config for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterDashboardServiceRunning(true, startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster : %s in usable state as unable to get Dashboard service running for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(),KubernetesCluster.Event.OperationFailed);\n        }\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.OperationSucceeded);\n        return true;\n    }\n","realPath":"plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterStartWorker.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":484,"status":"M"},{"authorDate":"2020-10-27 14:45:43","commitOrder":5,"curCode":"    public boolean startStoppedKubernetesCluster() throws CloudRuntimeException {\n        init();\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Starting Kubernetes cluster : %s\", kubernetesCluster.getName()));\n        }\n        final long startTimeoutTime = System.currentTimeMillis() + KubernetesClusterService.KubernetesClusterStartTimeout.value() * 1000;\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.StartRequested);\n        startKubernetesClusterVMs();\n        try {\n            InetAddress address = InetAddress.getByName(new URL(kubernetesCluster.getEndpoint()).getHost());\n        } catch (MalformedURLException | UnknownHostException ex) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Kubernetes cluster : %s has invalid API endpoint. Can not verify if cluster is in ready state\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        Pair<String, Integer> sshIpPort =  getKubernetesClusterServerIpSshPort(null);\n        publicIpAddress = sshIpPort.first();\n        sshPort = sshIpPort.second();\n        if (Strings.isNullOrEmpty(publicIpAddress)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s as no public IP found for the cluster\" , kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!KubernetesClusterUtil.isKubernetesClusterServerRunning(kubernetesCluster, publicIpAddress, CLUSTER_API_PORT, startTimeoutTime, 15000)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s in usable state\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterKubeConfigAvailable(startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s in usable state as unable to retrieve kube-config for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterDashboardServiceRunning(false, startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s in usable state as unable to get Dashboard service running for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.OperationSucceeded);\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Kubernetes cluster : %s successfully started\", kubernetesCluster.getName()));\n        }\n        return true;\n    }\n","date":"2020-10-27 14:45:43","endLine":605,"groupId":"104224","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"startStoppedKubernetesCluster","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/85/5c264d6906f9beb7a3ef517cfe9586ff7fff0e.src","preCode":"    public boolean startStoppedKubernetesCluster() throws CloudRuntimeException {\n        init();\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Starting Kubernetes cluster : %s\", kubernetesCluster.getName()));\n        }\n        final long startTimeoutTime = System.currentTimeMillis() + KubernetesClusterService.KubernetesClusterStartTimeout.value() * 1000;\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.StartRequested);\n        startKubernetesClusterVMs();\n        try {\n            InetAddress address = InetAddress.getByName(new URL(kubernetesCluster.getEndpoint()).getHost());\n        } catch (MalformedURLException | UnknownHostException ex) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Kubernetes cluster : %s has invalid API endpoint. Can not verify if cluster is in ready state\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        Pair<String, Integer> sshIpPort =  getKubernetesClusterServerIpSshPort(null);\n        publicIpAddress = sshIpPort.first();\n        sshPort = sshIpPort.second();\n        if (Strings.isNullOrEmpty(publicIpAddress)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s as no public IP found for the cluster\" , kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!KubernetesClusterUtil.isKubernetesClusterServerRunning(kubernetesCluster, publicIpAddress, CLUSTER_API_PORT, startTimeoutTime, 15000)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s in usable state\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterKubeConfigAvailable(startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s in usable state as unable to retrieve kube-config for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        if (!isKubernetesClusterDashboardServiceRunning(false, startTimeoutTime)) {\n            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to start Kubernetes cluster : %s in usable state as unable to get Dashboard service running for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n        }\n        stateTransitTo(kubernetesCluster.getId(), KubernetesCluster.Event.OperationSucceeded);\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(String.format(\"Kubernetes cluster : %s successfully started\", kubernetesCluster.getName()));\n        }\n        return true;\n    }\n","realPath":"plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterStartWorker.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":572,"status":"N"}],"commitId":"3c8c704df3e132472a2b42306b9f4814451c5854","commitMessage":"@@@kubernetes: Deploy kubernetes-provider when creating a cluster (#5254)\n\n* kubernetes: Deploy kubernetes-provider when creating a cluster\n\nCo-authored-by: Abhishek Kumar <abhishek.mrt22@gmail.com>","date":"2021-08-09 17:15:20","modifiedFileCount":"9","status":"M","submitter":"davidjumani"}]
