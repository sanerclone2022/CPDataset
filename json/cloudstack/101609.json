[{"authorTime":"2018-01-20 05:49:27","codes":[{"authorDate":"2018-01-20 05:49:27","commitOrder":1,"curCode":"    protected Pair<List<Long>, Map<Long, Double>> listClustersByCapacity(long id, int requiredCpu, long requiredRam, ExcludeList avoid, boolean isZone) {\n        \r\n        \r\n\n        \r\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Listing clusters in order of aggregate capacity, that have (atleast one host with) enough CPU and RAM capacity under this \" +\n                (isZone ? \"Zone: \" : \"Pod: \") + id);\n        }\n        String capacityTypeToOrder = configDao.getValue(Config.HostCapacityTypeToOrderClusters.key());\n        short capacityType = Capacity.CAPACITY_TYPE_CPU;\n        if (\"RAM\".equalsIgnoreCase(capacityTypeToOrder)) {\n            capacityType = Capacity.CAPACITY_TYPE_MEMORY;\n        }\n\n        List<Long> clusterIdswithEnoughCapacity = capacityDao.listClustersInZoneOrPodByHostCapacities(id, requiredCpu, requiredRam, capacityType, isZone);\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"ClusterId List having enough CPU and RAM capacity: \" + clusterIdswithEnoughCapacity);\n        }\n        Pair<List<Long>, Map<Long, Double>> result = capacityDao.orderClustersByAggregateCapacity(id, capacityType, isZone);\n        List<Long> clusterIdsOrderedByAggregateCapacity = result.first();\n        \r\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"ClusterId List in order of aggregate capacity: \" + clusterIdsOrderedByAggregateCapacity);\n        }\n        clusterIdsOrderedByAggregateCapacity.retainAll(clusterIdswithEnoughCapacity);\n\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"ClusterId List having enough CPU and RAM capacity & in order of aggregate capacity: \" + clusterIdsOrderedByAggregateCapacity);\n        }\n\n        return result;\n\n    }\n","date":"2018-01-20 05:49:27","endLine":491,"groupId":"16037","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"listClustersByCapacity","params":"(longid@intrequiredCpu@longrequiredRam@ExcludeListavoid@booleanisZone)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/57/60e24ce4d332db9246669745d9330b71fc4faa.src","preCode":"    protected Pair<List<Long>, Map<Long, Double>> listClustersByCapacity(long id, int requiredCpu, long requiredRam, ExcludeList avoid, boolean isZone) {\n        \r\n        \r\n\n        \r\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Listing clusters in order of aggregate capacity, that have (atleast one host with) enough CPU and RAM capacity under this \" +\n                (isZone ? \"Zone: \" : \"Pod: \") + id);\n        }\n        String capacityTypeToOrder = configDao.getValue(Config.HostCapacityTypeToOrderClusters.key());\n        short capacityType = Capacity.CAPACITY_TYPE_CPU;\n        if (\"RAM\".equalsIgnoreCase(capacityTypeToOrder)) {\n            capacityType = Capacity.CAPACITY_TYPE_MEMORY;\n        }\n\n        List<Long> clusterIdswithEnoughCapacity = capacityDao.listClustersInZoneOrPodByHostCapacities(id, requiredCpu, requiredRam, capacityType, isZone);\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"ClusterId List having enough CPU and RAM capacity: \" + clusterIdswithEnoughCapacity);\n        }\n        Pair<List<Long>, Map<Long, Double>> result = capacityDao.orderClustersByAggregateCapacity(id, capacityType, isZone);\n        List<Long> clusterIdsOrderedByAggregateCapacity = result.first();\n        \r\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"ClusterId List in order of aggregate capacity: \" + clusterIdsOrderedByAggregateCapacity);\n        }\n        clusterIdsOrderedByAggregateCapacity.retainAll(clusterIdswithEnoughCapacity);\n\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"ClusterId List having enough CPU and RAM capacity & in order of aggregate capacity: \" + clusterIdsOrderedByAggregateCapacity);\n        }\n\n        return result;\n\n    }\n","realPath":"server/src/main/java/com/cloud/deploy/FirstFitPlanner.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":458,"status":"B"},{"authorDate":"2018-01-20 05:49:27","commitOrder":1,"curCode":"    protected Pair<List<Long>, Map<Long, Double>> listPodsByCapacity(long zoneId, int requiredCpu, long requiredRam) {\n        \r\n        \r\n\n        \r\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Listing pods in order of aggregate capacity, that have (atleast one host with) enough CPU and RAM capacity under this Zone: \" + zoneId);\n        }\n        String capacityTypeToOrder = configDao.getValue(Config.HostCapacityTypeToOrderClusters.key());\n        short capacityType = Capacity.CAPACITY_TYPE_CPU;\n        if (\"RAM\".equalsIgnoreCase(capacityTypeToOrder)) {\n            capacityType = Capacity.CAPACITY_TYPE_MEMORY;\n        }\n\n        List<Long> podIdswithEnoughCapacity = capacityDao.listPodsByHostCapacities(zoneId, requiredCpu, requiredRam, capacityType);\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"PodId List having enough CPU and RAM capacity: \" + podIdswithEnoughCapacity);\n        }\n        Pair<List<Long>, Map<Long, Double>> result = capacityDao.orderPodsByAggregateCapacity(zoneId, capacityType);\n        List<Long> podIdsOrderedByAggregateCapacity = result.first();\n        \r\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"PodId List in order of aggregate capacity: \" + podIdsOrderedByAggregateCapacity);\n        }\n        podIdsOrderedByAggregateCapacity.retainAll(podIdswithEnoughCapacity);\n\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"PodId List having enough CPU and RAM capacity & in order of aggregate capacity: \" + podIdsOrderedByAggregateCapacity);\n        }\n\n        return result;\n\n    }\n","date":"2018-01-20 05:49:27","endLine":525,"groupId":"8743","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"listPodsByCapacity","params":"(longzoneId@intrequiredCpu@longrequiredRam)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/57/60e24ce4d332db9246669745d9330b71fc4faa.src","preCode":"    protected Pair<List<Long>, Map<Long, Double>> listPodsByCapacity(long zoneId, int requiredCpu, long requiredRam) {\n        \r\n        \r\n\n        \r\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Listing pods in order of aggregate capacity, that have (atleast one host with) enough CPU and RAM capacity under this Zone: \" + zoneId);\n        }\n        String capacityTypeToOrder = configDao.getValue(Config.HostCapacityTypeToOrderClusters.key());\n        short capacityType = Capacity.CAPACITY_TYPE_CPU;\n        if (\"RAM\".equalsIgnoreCase(capacityTypeToOrder)) {\n            capacityType = Capacity.CAPACITY_TYPE_MEMORY;\n        }\n\n        List<Long> podIdswithEnoughCapacity = capacityDao.listPodsByHostCapacities(zoneId, requiredCpu, requiredRam, capacityType);\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"PodId List having enough CPU and RAM capacity: \" + podIdswithEnoughCapacity);\n        }\n        Pair<List<Long>, Map<Long, Double>> result = capacityDao.orderPodsByAggregateCapacity(zoneId, capacityType);\n        List<Long> podIdsOrderedByAggregateCapacity = result.first();\n        \r\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"PodId List in order of aggregate capacity: \" + podIdsOrderedByAggregateCapacity);\n        }\n        podIdsOrderedByAggregateCapacity.retainAll(podIdswithEnoughCapacity);\n\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"PodId List having enough CPU and RAM capacity & in order of aggregate capacity: \" + podIdsOrderedByAggregateCapacity);\n        }\n\n        return result;\n\n    }\n","realPath":"server/src/main/java/com/cloud/deploy/FirstFitPlanner.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":493,"status":"B"}],"commitId":"893a88d225276e45f12f9490e6af2c94a81c2965","commitMessage":"@@@CLOUDSTACK-10105: Use maven standard project structure in all projects (#2283)\n\nRemove maven standard module (which only a few were using) and get ride of maven customization for the projects structure.\n\n- moved all directories to src/main/java.  src/main/resources.  src/main/scripts.  src/test/java.  src/test/resources\n- grep scan to search for src/com and src/org left over\n- grep for <project>/scripts to fix pom.xml configuration\n- remove custom <build> configuration in pom.xml\n\nSigned-off-by: Marc-Aur?le Brothier <m@brothier.org>","date":"2018-01-20 05:49:27","modifiedFileCount":"1","status":"B","submitter":"Marc-Aur?le Brothier"},{"authorTime":"2018-01-20 05:49:27","codes":[{"authorDate":"2021-09-08 08:50:29","commitOrder":2,"curCode":"    protected Pair<List<Long>, Map<Long, Double>> listClustersByCapacity(long id, long vmId, int requiredCpu, long requiredRam, ExcludeList avoid, boolean isZone) {\n        \r\n        \r\n\n        \r\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Listing clusters in order of aggregate capacity, that have (at least one host with) enough CPU and RAM capacity under this \" +\n                (isZone ? \"Zone: \" : \"Pod: \") + id);\n        }\n        String capacityTypeToOrder = configDao.getValue(Config.HostCapacityTypeToOrderClusters.key());\n        short capacityType = Capacity.CAPACITY_TYPE_CPU;\n        if (\"RAM\".equalsIgnoreCase(capacityTypeToOrder)) {\n            capacityType = Capacity.CAPACITY_TYPE_MEMORY;\n        }\n\n        List<Long> clusterIdswithEnoughCapacity = capacityDao.listClustersInZoneOrPodByHostCapacities(id, vmId, requiredCpu, requiredRam, capacityType, isZone);\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"ClusterId List having enough CPU and RAM capacity: \" + clusterIdswithEnoughCapacity);\n        }\n        Pair<List<Long>, Map<Long, Double>> result = capacityDao.orderClustersByAggregateCapacity(id, vmId, capacityType, isZone);\n        List<Long> clusterIdsOrderedByAggregateCapacity = result.first();\n        \r\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"ClusterId List in order of aggregate capacity: \" + clusterIdsOrderedByAggregateCapacity);\n        }\n        clusterIdsOrderedByAggregateCapacity.retainAll(clusterIdswithEnoughCapacity);\n\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"ClusterId List having enough CPU and RAM capacity & in order of aggregate capacity: \" + clusterIdsOrderedByAggregateCapacity);\n        }\n\n        return result;\n\n    }\n","date":"2021-09-08 08:50:29","endLine":477,"groupId":"101609","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"listClustersByCapacity","params":"(longid@longvmId@intrequiredCpu@longrequiredRam@ExcludeListavoid@booleanisZone)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/f5/263e210459ef9e7bdaa0e5b8272020a35f2e9c.src","preCode":"    protected Pair<List<Long>, Map<Long, Double>> listClustersByCapacity(long id, int requiredCpu, long requiredRam, ExcludeList avoid, boolean isZone) {\n        \r\n        \r\n\n        \r\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Listing clusters in order of aggregate capacity, that have (at least one host with) enough CPU and RAM capacity under this \" +\n                (isZone ? \"Zone: \" : \"Pod: \") + id);\n        }\n        String capacityTypeToOrder = configDao.getValue(Config.HostCapacityTypeToOrderClusters.key());\n        short capacityType = Capacity.CAPACITY_TYPE_CPU;\n        if (\"RAM\".equalsIgnoreCase(capacityTypeToOrder)) {\n            capacityType = Capacity.CAPACITY_TYPE_MEMORY;\n        }\n\n        List<Long> clusterIdswithEnoughCapacity = capacityDao.listClustersInZoneOrPodByHostCapacities(id, requiredCpu, requiredRam, capacityType, isZone);\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"ClusterId List having enough CPU and RAM capacity: \" + clusterIdswithEnoughCapacity);\n        }\n        Pair<List<Long>, Map<Long, Double>> result = capacityDao.orderClustersByAggregateCapacity(id, capacityType, isZone);\n        List<Long> clusterIdsOrderedByAggregateCapacity = result.first();\n        \r\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"ClusterId List in order of aggregate capacity: \" + clusterIdsOrderedByAggregateCapacity);\n        }\n        clusterIdsOrderedByAggregateCapacity.retainAll(clusterIdswithEnoughCapacity);\n\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"ClusterId List having enough CPU and RAM capacity & in order of aggregate capacity: \" + clusterIdsOrderedByAggregateCapacity);\n        }\n\n        return result;\n\n    }\n","realPath":"server/src/main/java/com/cloud/deploy/FirstFitPlanner.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":444,"status":"M"},{"authorDate":"2018-01-20 05:49:27","commitOrder":2,"curCode":"    protected Pair<List<Long>, Map<Long, Double>> listPodsByCapacity(long zoneId, int requiredCpu, long requiredRam) {\n        \r\n        \r\n\n        \r\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Listing pods in order of aggregate capacity, that have (atleast one host with) enough CPU and RAM capacity under this Zone: \" + zoneId);\n        }\n        String capacityTypeToOrder = configDao.getValue(Config.HostCapacityTypeToOrderClusters.key());\n        short capacityType = Capacity.CAPACITY_TYPE_CPU;\n        if (\"RAM\".equalsIgnoreCase(capacityTypeToOrder)) {\n            capacityType = Capacity.CAPACITY_TYPE_MEMORY;\n        }\n\n        List<Long> podIdswithEnoughCapacity = capacityDao.listPodsByHostCapacities(zoneId, requiredCpu, requiredRam, capacityType);\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"PodId List having enough CPU and RAM capacity: \" + podIdswithEnoughCapacity);\n        }\n        Pair<List<Long>, Map<Long, Double>> result = capacityDao.orderPodsByAggregateCapacity(zoneId, capacityType);\n        List<Long> podIdsOrderedByAggregateCapacity = result.first();\n        \r\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"PodId List in order of aggregate capacity: \" + podIdsOrderedByAggregateCapacity);\n        }\n        podIdsOrderedByAggregateCapacity.retainAll(podIdswithEnoughCapacity);\n\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"PodId List having enough CPU and RAM capacity & in order of aggregate capacity: \" + podIdsOrderedByAggregateCapacity);\n        }\n\n        return result;\n\n    }\n","date":"2018-01-20 05:49:27","endLine":525,"groupId":"101609","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"listPodsByCapacity","params":"(longzoneId@intrequiredCpu@longrequiredRam)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/57/60e24ce4d332db9246669745d9330b71fc4faa.src","preCode":"    protected Pair<List<Long>, Map<Long, Double>> listPodsByCapacity(long zoneId, int requiredCpu, long requiredRam) {\n        \r\n        \r\n\n        \r\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Listing pods in order of aggregate capacity, that have (atleast one host with) enough CPU and RAM capacity under this Zone: \" + zoneId);\n        }\n        String capacityTypeToOrder = configDao.getValue(Config.HostCapacityTypeToOrderClusters.key());\n        short capacityType = Capacity.CAPACITY_TYPE_CPU;\n        if (\"RAM\".equalsIgnoreCase(capacityTypeToOrder)) {\n            capacityType = Capacity.CAPACITY_TYPE_MEMORY;\n        }\n\n        List<Long> podIdswithEnoughCapacity = capacityDao.listPodsByHostCapacities(zoneId, requiredCpu, requiredRam, capacityType);\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"PodId List having enough CPU and RAM capacity: \" + podIdswithEnoughCapacity);\n        }\n        Pair<List<Long>, Map<Long, Double>> result = capacityDao.orderPodsByAggregateCapacity(zoneId, capacityType);\n        List<Long> podIdsOrderedByAggregateCapacity = result.first();\n        \r\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"PodId List in order of aggregate capacity: \" + podIdsOrderedByAggregateCapacity);\n        }\n        podIdsOrderedByAggregateCapacity.retainAll(podIdswithEnoughCapacity);\n\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"PodId List having enough CPU and RAM capacity & in order of aggregate capacity: \" + podIdsOrderedByAggregateCapacity);\n        }\n\n        return result;\n\n    }\n","realPath":"server/src/main/java/com/cloud/deploy/FirstFitPlanner.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":493,"status":"N"}],"commitId":"a755ecfce857cdf525f3d2895d68917ea6f905f3","commitMessage":"@@@Migrate vm across clusters (#4534)\n\n* server: Optional destination host when migrate a vm\n\n* #4378: migrate systemvms/routers with optional host\n\n* Migrate vms across clusters\n\nAfter enabling maintenance mode on host.  if no suitable hosts\nare found in the same cluster then search for hosts in\ndifferent clusters having the same hypervisor type\n\nset global setting migrate.vm.across.clusters to true\n\n* search all clusters in zone when migrate vm across clusters if applicable\n\n* Honor migrate.vm.across.clusters when migrate vm without destination\n\n* Check MIGRATE_VM_ACROSS_CLUSTERS in zone setting\n\n* #4534 Fix Vms are migrated to same clusters in CloudStack caused by dedicated resources.\n\n* #4534 extract some codes to methods\n\n* fix #4534: an error in 'git merge'\n\n* fix #4534: remove useless methods in FirstFitPlanner.java\n\n* fix #4534: vms are stopped in host maintenance\n\n* fix #4534: across-cluster migration of vms with cluster-scoped pools is supported by vmware vmotion\n\n* fix #4534: migrate systemvms is only possible across clusters in same pod to avoid potential network errors.\n\n* fix #4534: code optimization\n\nCo-authored-by: Rakesh Venkatesh <r.venkatesh@global.leaseweb.com>\nCo-authored-by: Sina Kashipazha <s.kashipazha@global.leaseweb.com>\nCo-authored-by: Wei Zhou <weizhou@apache.org>\nCo-authored-by: Sina Kashipazha <soreana@users.noreply.github.com>","date":"2021-09-08 08:50:29","modifiedFileCount":"10","status":"M","submitter":"Wei Zhou"}]
