[{"authorTime":"2020-06-26 19:31:43","codes":[{"authorDate":"2018-01-20 05:49:27","commitOrder":2,"curCode":"    public void cleanupVolumes(long vmId) throws ConcurrentOperationException {\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Cleaning storage for vm: \" + vmId);\n        }\n        final List<VolumeVO> volumesForVm = _volsDao.findByInstance(vmId);\n        final List<VolumeVO> toBeExpunged = new ArrayList<VolumeVO>();\n\n        Transaction.execute(new TransactionCallbackNoReturn() {\n            @Override\n            public void doInTransactionWithoutResult(TransactionStatus status) {\n                for (VolumeVO vol : volumesForVm) {\n                    if (vol.getVolumeType().equals(Type.ROOT)) {\n                        \r\n                        boolean volumeAlreadyDestroyed = (vol.getState() == Volume.State.Destroy || vol.getState() == Volume.State.Expunged || vol.getState() == Volume.State.Expunging);\n                        if (!volumeAlreadyDestroyed) {\n                            volService.destroyVolume(vol.getId());\n                        } else {\n                            s_logger.debug(\"Skipping destroy for the volume \" + vol + \" as its in state \" + vol.getState().toString());\n                        }\n                        toBeExpunged.add(vol);\n                    } else {\n                        if (s_logger.isDebugEnabled()) {\n                            s_logger.debug(\"Detaching \" + vol);\n                        }\n                        _volsDao.detachVolume(vol.getId());\n                    }\n                }\n            }\n        });\n\n        AsyncCallFuture<VolumeApiResult> future = null;\n        for (VolumeVO expunge : toBeExpunged) {\n            future = volService.expungeVolumeAsync(volFactory.getVolume(expunge.getId()));\n            try {\n                future.get();\n            } catch (InterruptedException e) {\n                s_logger.debug(\"failed expunge volume\" + expunge.getId(), e);\n            } catch (ExecutionException e) {\n                s_logger.debug(\"failed expunge volume\" + expunge.getId(), e);\n            }\n        }\n    }\n","date":"2018-01-20 05:49:27","endLine":954,"groupId":"8256","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"cleanupVolumes","params":"(longvmId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/f0/2fdc495f9b5b891e53b7718e224d5f4b8d28d3.src","preCode":"    public void cleanupVolumes(long vmId) throws ConcurrentOperationException {\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Cleaning storage for vm: \" + vmId);\n        }\n        final List<VolumeVO> volumesForVm = _volsDao.findByInstance(vmId);\n        final List<VolumeVO> toBeExpunged = new ArrayList<VolumeVO>();\n\n        Transaction.execute(new TransactionCallbackNoReturn() {\n            @Override\n            public void doInTransactionWithoutResult(TransactionStatus status) {\n                for (VolumeVO vol : volumesForVm) {\n                    if (vol.getVolumeType().equals(Type.ROOT)) {\n                        \r\n                        boolean volumeAlreadyDestroyed = (vol.getState() == Volume.State.Destroy || vol.getState() == Volume.State.Expunged || vol.getState() == Volume.State.Expunging);\n                        if (!volumeAlreadyDestroyed) {\n                            volService.destroyVolume(vol.getId());\n                        } else {\n                            s_logger.debug(\"Skipping destroy for the volume \" + vol + \" as its in state \" + vol.getState().toString());\n                        }\n                        toBeExpunged.add(vol);\n                    } else {\n                        if (s_logger.isDebugEnabled()) {\n                            s_logger.debug(\"Detaching \" + vol);\n                        }\n                        _volsDao.detachVolume(vol.getId());\n                    }\n                }\n            }\n        });\n\n        AsyncCallFuture<VolumeApiResult> future = null;\n        for (VolumeVO expunge : toBeExpunged) {\n            future = volService.expungeVolumeAsync(volFactory.getVolume(expunge.getId()));\n            try {\n                future.get();\n            } catch (InterruptedException e) {\n                s_logger.debug(\"failed expunge volume\" + expunge.getId(), e);\n            } catch (ExecutionException e) {\n                s_logger.debug(\"failed expunge volume\" + expunge.getId(), e);\n            }\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/VolumeOrchestrator.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":913,"status":"NB"},{"authorDate":"2020-06-26 19:31:43","commitOrder":2,"curCode":"    public void unmanageVolumes(long vmId) {\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Unmanaging storage for vm: \" + vmId);\n        }\n        final List<VolumeVO> volumesForVm = _volsDao.findByInstance(vmId);\n\n        Transaction.execute(new TransactionCallbackNoReturn() {\n            @Override\n            public void doInTransactionWithoutResult(TransactionStatus status) {\n                for (VolumeVO vol : volumesForVm) {\n                    boolean volumeAlreadyDestroyed = (vol.getState() == Volume.State.Destroy || vol.getState() == Volume.State.Expunged\n                            || vol.getState() == Volume.State.Expunging);\n                    if (volumeAlreadyDestroyed) {\n                        s_logger.debug(\"Skipping destroy for the volume \" + vol + \" as its in state \" + vol.getState().toString());\n                    } else {\n                        volService.unmanageVolume(vol.getId());\n                    }\n                }\n            }\n        });\n    }\n","date":"2020-06-26 19:31:43","endLine":1705,"groupId":"14224","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"unmanageVolumes","params":"(longvmId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/c1/816750937734c0a78dadaf8f2a55b7fcaa953e.src","preCode":"    public void unmanageVolumes(long vmId) {\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Unmanaging storage for vm: \" + vmId);\n        }\n        final List<VolumeVO> volumesForVm = _volsDao.findByInstance(vmId);\n\n        Transaction.execute(new TransactionCallbackNoReturn() {\n            @Override\n            public void doInTransactionWithoutResult(TransactionStatus status) {\n                for (VolumeVO vol : volumesForVm) {\n                    boolean volumeAlreadyDestroyed = (vol.getState() == Volume.State.Destroy || vol.getState() == Volume.State.Expunged\n                            || vol.getState() == Volume.State.Expunging);\n                    if (volumeAlreadyDestroyed) {\n                        s_logger.debug(\"Skipping destroy for the volume \" + vol + \" as its in state \" + vol.getState().toString());\n                    } else {\n                        volService.unmanageVolume(vol.getId());\n                    }\n                }\n            }\n        });\n    }\n","realPath":"engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/VolumeOrchestrator.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1685,"status":"B"}],"commitId":"8c1d749360657a4909c558c3df5dec57ca66c977","commitMessage":"@@@[VMware] Enable unmanaging guest VMs (#4103)\n\n* Enable unmanaging guest VMs\n\n* Minor fixes\n\n* Fix stop usage event only if VM is not stopped when unmanaging\n\n* Rename unmanaged VMs manager\n\n* Generate netofferingremove usage event if VM is not stopped\n\n* Generate usage event VM snapshot primary off when unmanaging","date":"2020-06-26 19:31:43","modifiedFileCount":"28","status":"M","submitter":"Nicolas Vazquez"},{"authorTime":"2020-06-26 19:31:43","codes":[{"authorDate":"2021-04-15 18:47:13","commitOrder":3,"curCode":"    public void cleanupVolumes(long vmId) throws ConcurrentOperationException {\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Cleaning storage for vm: \" + vmId);\n        }\n        final List<VolumeVO> volumesForVm = _volsDao.findByInstance(vmId);\n        final List<VolumeVO> toBeExpunged = new ArrayList<VolumeVO>();\n\n        Transaction.execute(new TransactionCallbackNoReturn() {\n            @Override\n            public void doInTransactionWithoutResult(TransactionStatus status) {\n                for (VolumeVO vol : volumesForVm) {\n                    if (vol.getVolumeType().equals(Type.ROOT)) {\n                        \r\n                        boolean volumeAlreadyDestroyed = (vol.getState() == Volume.State.Destroy || vol.getState() == Volume.State.Expunged || vol.getState() == Volume.State.Expunging);\n                        if (!volumeAlreadyDestroyed) {\n                            volService.destroyVolume(vol.getId());\n                        } else {\n                            s_logger.debug(\"Skipping destroy for the volume \" + vol + \" as its in state \" + vol.getState().toString());\n                        }\n                        toBeExpunged.add(vol);\n                    } else {\n                        if (s_logger.isDebugEnabled()) {\n                            s_logger.debug(\"Detaching \" + vol);\n                        }\n                        VMInstanceVO vm = _userVmDao.findById(vmId);\n                        if (vm.getHypervisorType().equals(HypervisorType.VMware)) {\n                            _volumeApiService.detachVolumeViaDestroyVM(vmId, vol.getId());\n                        }\n                        _volsDao.detachVolume(vol.getId());\n                    }\n                }\n            }\n        });\n\n        AsyncCallFuture<VolumeApiResult> future = null;\n        for (VolumeVO expunge : toBeExpunged) {\n            future = volService.expungeVolumeAsync(volFactory.getVolume(expunge.getId()));\n            try {\n                future.get();\n            } catch (InterruptedException e) {\n                s_logger.debug(\"failed expunge volume\" + expunge.getId(), e);\n            } catch (ExecutionException e) {\n                s_logger.debug(\"failed expunge volume\" + expunge.getId(), e);\n            }\n        }\n    }\n","date":"2021-04-15 18:47:13","endLine":1129,"groupId":"10643","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"cleanupVolumes","params":"(longvmId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/1c/4aead5941f83efab1d35332dfcf50f59a5f0b6.src","preCode":"    public void cleanupVolumes(long vmId) throws ConcurrentOperationException {\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Cleaning storage for vm: \" + vmId);\n        }\n        final List<VolumeVO> volumesForVm = _volsDao.findByInstance(vmId);\n        final List<VolumeVO> toBeExpunged = new ArrayList<VolumeVO>();\n\n        Transaction.execute(new TransactionCallbackNoReturn() {\n            @Override\n            public void doInTransactionWithoutResult(TransactionStatus status) {\n                for (VolumeVO vol : volumesForVm) {\n                    if (vol.getVolumeType().equals(Type.ROOT)) {\n                        \r\n                        boolean volumeAlreadyDestroyed = (vol.getState() == Volume.State.Destroy || vol.getState() == Volume.State.Expunged || vol.getState() == Volume.State.Expunging);\n                        if (!volumeAlreadyDestroyed) {\n                            volService.destroyVolume(vol.getId());\n                        } else {\n                            s_logger.debug(\"Skipping destroy for the volume \" + vol + \" as its in state \" + vol.getState().toString());\n                        }\n                        toBeExpunged.add(vol);\n                    } else {\n                        if (s_logger.isDebugEnabled()) {\n                            s_logger.debug(\"Detaching \" + vol);\n                        }\n                        _volsDao.detachVolume(vol.getId());\n                    }\n                }\n            }\n        });\n\n        AsyncCallFuture<VolumeApiResult> future = null;\n        for (VolumeVO expunge : toBeExpunged) {\n            future = volService.expungeVolumeAsync(volFactory.getVolume(expunge.getId()));\n            try {\n                future.get();\n            } catch (InterruptedException e) {\n                s_logger.debug(\"failed expunge volume\" + expunge.getId(), e);\n            } catch (ExecutionException e) {\n                s_logger.debug(\"failed expunge volume\" + expunge.getId(), e);\n            }\n        }\n    }\n","realPath":"engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/VolumeOrchestrator.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1084,"status":"M"},{"authorDate":"2020-06-26 19:31:43","commitOrder":3,"curCode":"    public void unmanageVolumes(long vmId) {\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Unmanaging storage for vm: \" + vmId);\n        }\n        final List<VolumeVO> volumesForVm = _volsDao.findByInstance(vmId);\n\n        Transaction.execute(new TransactionCallbackNoReturn() {\n            @Override\n            public void doInTransactionWithoutResult(TransactionStatus status) {\n                for (VolumeVO vol : volumesForVm) {\n                    boolean volumeAlreadyDestroyed = (vol.getState() == Volume.State.Destroy || vol.getState() == Volume.State.Expunged\n                            || vol.getState() == Volume.State.Expunging);\n                    if (volumeAlreadyDestroyed) {\n                        s_logger.debug(\"Skipping destroy for the volume \" + vol + \" as its in state \" + vol.getState().toString());\n                    } else {\n                        volService.unmanageVolume(vol.getId());\n                    }\n                }\n            }\n        });\n    }\n","date":"2020-06-26 19:31:43","endLine":1705,"groupId":"10643","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"unmanageVolumes","params":"(longvmId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/c1/816750937734c0a78dadaf8f2a55b7fcaa953e.src","preCode":"    public void unmanageVolumes(long vmId) {\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Unmanaging storage for vm: \" + vmId);\n        }\n        final List<VolumeVO> volumesForVm = _volsDao.findByInstance(vmId);\n\n        Transaction.execute(new TransactionCallbackNoReturn() {\n            @Override\n            public void doInTransactionWithoutResult(TransactionStatus status) {\n                for (VolumeVO vol : volumesForVm) {\n                    boolean volumeAlreadyDestroyed = (vol.getState() == Volume.State.Destroy || vol.getState() == Volume.State.Expunged\n                            || vol.getState() == Volume.State.Expunging);\n                    if (volumeAlreadyDestroyed) {\n                        s_logger.debug(\"Skipping destroy for the volume \" + vol + \" as its in state \" + vol.getState().toString());\n                    } else {\n                        volService.unmanageVolume(vol.getId());\n                    }\n                }\n            }\n        });\n    }\n","realPath":"engine/orchestration/src/main/java/org/apache/cloudstack/engine/orchestration/VolumeOrchestrator.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":1685,"status":"N"}],"commitId":"f42024714c39eacc004af0b61e016fc7d16e459a","commitMessage":"@@@Merge remote-tracking branch 'origin/4.15'\n\nSigned-off-by: Rohit Yadav <rohit.yadav@shapeblue.com>\n","date":"2021-04-15 18:47:13","modifiedFileCount":"12","status":"M","submitter":"Rohit Yadav"}]
