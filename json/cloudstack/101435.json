[{"authorTime":"2018-01-20 05:49:27","codes":[{"authorDate":"2018-01-20 05:49:27","commitOrder":1,"curCode":"    public boolean verifyRequest(final Map<String, Object[]> requestParameters, final Long userId, InetAddress remoteAddress) throws ServerApiException {\n        try {\n            String apiKey = null;\n            String secretKey = null;\n            String signature = null;\n            String unsignedRequest = null;\n\n            final String[] command = (String[])requestParameters.get(ApiConstants.COMMAND);\n            if (command == null) {\n                s_logger.info(\"missing command, ignoring request...\");\n                return false;\n            }\n\n            final String commandName = command[0];\n\n            \r\n            if (userId != null) {\n                final User user = ApiDBUtils.findUserById(userId);\n\n                if (!commandAvailable(remoteAddress, commandName, user)) {\n                    return false;\n                }\n\n                return true;\n            } else {\n                \r\n                if (!s_apiNameCmdClassMap.containsKey(commandName) && !commandName.equals(\"login\") && !commandName.equals(\"logout\")) {\n                    final String errorMessage = \"The given command \" + commandName + \" either does not exist, is not available\" +\n                            \" for user, or not available from ip address '\" + remoteAddress.getHostAddress() + \"'.\";\n                    s_logger.debug(errorMessage);\n                    return false;\n                }\n            }\n\n            \r\n            \r\n            final List<String> parameterNames = new ArrayList<String>();\n\n            for (final Object paramNameObj : requestParameters.keySet()) {\n                parameterNames.add((String)paramNameObj); \r\n            }\n\n            Collections.sort(parameterNames);\n\n            String signatureVersion = null;\n            String expires = null;\n\n            for (final String paramName : parameterNames) {\n                \r\n                final String paramValue = ((String[])requestParameters.get(paramName))[0];\n\n                if (ApiConstants.SIGNATURE.equalsIgnoreCase(paramName)) {\n                    signature = paramValue;\n                } else {\n                    if (ApiConstants.API_KEY.equalsIgnoreCase(paramName)) {\n                        apiKey = paramValue;\n                    } else if (ApiConstants.SIGNATURE_VERSION.equalsIgnoreCase(paramName)) {\n                        signatureVersion = paramValue;\n                    } else if (ApiConstants.EXPIRES.equalsIgnoreCase(paramName)) {\n                        expires = paramValue;\n                    }\n\n                    if (unsignedRequest == null) {\n                        unsignedRequest = paramName + \"=\" + URLEncoder.encode(paramValue, HttpUtils.UTF_8).replaceAll(\"\\\\+\", \"%20\");\n                    } else {\n                        unsignedRequest = unsignedRequest + \"&\" + paramName + \"=\" + URLEncoder.encode(paramValue, HttpUtils.UTF_8).replaceAll(\"\\\\+\", \"%20\");\n                    }\n                }\n            }\n\n            \r\n            if ((signature == null) || (apiKey == null)) {\n                s_logger.debug(\"Expired session, missing signature, or missing apiKey -- ignoring request. Signature: \" + signature + \", apiKey: \" + apiKey);\n                return false; \r\n            }\n\n            Date expiresTS = null;\n            \r\n            if (\"3\".equals(signatureVersion)) {\n                \r\n                if (expires == null) {\n                    s_logger.debug(\"Missing Expires parameter -- ignoring request. Signature: \" + signature + \", apiKey: \" + apiKey);\n                    return false;\n                }\n                synchronized (DateFormatToUse) {\n                    try {\n                        expiresTS = DateFormatToUse.parse(expires);\n                    } catch (final ParseException pe) {\n                        s_logger.debug(\"Incorrect date format for Expires parameter\", pe);\n                        return false;\n                    }\n                }\n                final Date now = new Date(System.currentTimeMillis());\n                if (expiresTS.before(now)) {\n                    s_logger.debug(\"Request expired -- ignoring ...sig: \" + signature + \", apiKey: \" + apiKey);\n                    return false;\n                }\n            }\n\n            final TransactionLegacy txn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\n            txn.close();\n            User user = null;\n            \r\n            final Pair<User, Account> userAcctPair = accountMgr.findUserByApiKey(apiKey);\n            if (userAcctPair == null) {\n                s_logger.debug(\"apiKey does not map to a valid user -- ignoring request, apiKey: \" + apiKey);\n                return false;\n            }\n\n            user = userAcctPair.first();\n            final Account account = userAcctPair.second();\n\n            if (user.getState() != Account.State.enabled || !account.getState().equals(Account.State.enabled)) {\n                s_logger.info(\"disabled or locked user accessing the api, userid = \" + user.getId() + \"; name = \" + user.getUsername() + \"; state: \" + user.getState() +\n                        \"; accountState: \" + account.getState());\n                return false;\n            }\n\n            if (!commandAvailable(remoteAddress, commandName, user)) {\n                return false;\n            }\n\n            \r\n            secretKey = user.getSecretKey();\n            if (secretKey == null) {\n                s_logger.info(\"User does not have a secret key associated with the account -- ignoring request, username: \" + user.getUsername());\n                return false;\n            }\n\n            unsignedRequest = unsignedRequest.toLowerCase();\n\n            final Mac mac = Mac.getInstance(\"HmacSHA1\");\n            final SecretKeySpec keySpec = new SecretKeySpec(secretKey.getBytes(), \"HmacSHA1\");\n            mac.init(keySpec);\n            mac.update(unsignedRequest.getBytes());\n\n            final byte[] encryptedBytes = mac.doFinal();\n            final String computedSignature = Base64.encodeBase64String(encryptedBytes);\n            final boolean equalSig = ConstantTimeComparator.compareStrings(signature, computedSignature);\n\n            if (!equalSig) {\n                s_logger.info(\"User signature: \" + signature + \" is not equaled to computed signature: \" + computedSignature);\n            } else {\n                CallContext.register(user, account);\n            }\n            return equalSig;\n        } catch (final ServerApiException ex) {\n            throw ex;\n        } catch (final Exception ex) {\n            s_logger.error(\"unable to verify request signature\");\n        }\n        return false;\n    }\n","date":"2018-01-20 05:49:27","endLine":953,"groupId":"3269","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"verifyRequest","params":"(finalMap<String@Object[]>requestParameters@finalLonguserId@InetAddressremoteAddress)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/64/11fe073675a10a7f1bee009e3ce36ebd0ea522.src","preCode":"    public boolean verifyRequest(final Map<String, Object[]> requestParameters, final Long userId, InetAddress remoteAddress) throws ServerApiException {\n        try {\n            String apiKey = null;\n            String secretKey = null;\n            String signature = null;\n            String unsignedRequest = null;\n\n            final String[] command = (String[])requestParameters.get(ApiConstants.COMMAND);\n            if (command == null) {\n                s_logger.info(\"missing command, ignoring request...\");\n                return false;\n            }\n\n            final String commandName = command[0];\n\n            \r\n            if (userId != null) {\n                final User user = ApiDBUtils.findUserById(userId);\n\n                if (!commandAvailable(remoteAddress, commandName, user)) {\n                    return false;\n                }\n\n                return true;\n            } else {\n                \r\n                if (!s_apiNameCmdClassMap.containsKey(commandName) && !commandName.equals(\"login\") && !commandName.equals(\"logout\")) {\n                    final String errorMessage = \"The given command \" + commandName + \" either does not exist, is not available\" +\n                            \" for user, or not available from ip address '\" + remoteAddress.getHostAddress() + \"'.\";\n                    s_logger.debug(errorMessage);\n                    return false;\n                }\n            }\n\n            \r\n            \r\n            final List<String> parameterNames = new ArrayList<String>();\n\n            for (final Object paramNameObj : requestParameters.keySet()) {\n                parameterNames.add((String)paramNameObj); \r\n            }\n\n            Collections.sort(parameterNames);\n\n            String signatureVersion = null;\n            String expires = null;\n\n            for (final String paramName : parameterNames) {\n                \r\n                final String paramValue = ((String[])requestParameters.get(paramName))[0];\n\n                if (ApiConstants.SIGNATURE.equalsIgnoreCase(paramName)) {\n                    signature = paramValue;\n                } else {\n                    if (ApiConstants.API_KEY.equalsIgnoreCase(paramName)) {\n                        apiKey = paramValue;\n                    } else if (ApiConstants.SIGNATURE_VERSION.equalsIgnoreCase(paramName)) {\n                        signatureVersion = paramValue;\n                    } else if (ApiConstants.EXPIRES.equalsIgnoreCase(paramName)) {\n                        expires = paramValue;\n                    }\n\n                    if (unsignedRequest == null) {\n                        unsignedRequest = paramName + \"=\" + URLEncoder.encode(paramValue, HttpUtils.UTF_8).replaceAll(\"\\\\+\", \"%20\");\n                    } else {\n                        unsignedRequest = unsignedRequest + \"&\" + paramName + \"=\" + URLEncoder.encode(paramValue, HttpUtils.UTF_8).replaceAll(\"\\\\+\", \"%20\");\n                    }\n                }\n            }\n\n            \r\n            if ((signature == null) || (apiKey == null)) {\n                s_logger.debug(\"Expired session, missing signature, or missing apiKey -- ignoring request. Signature: \" + signature + \", apiKey: \" + apiKey);\n                return false; \r\n            }\n\n            Date expiresTS = null;\n            \r\n            if (\"3\".equals(signatureVersion)) {\n                \r\n                if (expires == null) {\n                    s_logger.debug(\"Missing Expires parameter -- ignoring request. Signature: \" + signature + \", apiKey: \" + apiKey);\n                    return false;\n                }\n                synchronized (DateFormatToUse) {\n                    try {\n                        expiresTS = DateFormatToUse.parse(expires);\n                    } catch (final ParseException pe) {\n                        s_logger.debug(\"Incorrect date format for Expires parameter\", pe);\n                        return false;\n                    }\n                }\n                final Date now = new Date(System.currentTimeMillis());\n                if (expiresTS.before(now)) {\n                    s_logger.debug(\"Request expired -- ignoring ...sig: \" + signature + \", apiKey: \" + apiKey);\n                    return false;\n                }\n            }\n\n            final TransactionLegacy txn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\n            txn.close();\n            User user = null;\n            \r\n            final Pair<User, Account> userAcctPair = accountMgr.findUserByApiKey(apiKey);\n            if (userAcctPair == null) {\n                s_logger.debug(\"apiKey does not map to a valid user -- ignoring request, apiKey: \" + apiKey);\n                return false;\n            }\n\n            user = userAcctPair.first();\n            final Account account = userAcctPair.second();\n\n            if (user.getState() != Account.State.enabled || !account.getState().equals(Account.State.enabled)) {\n                s_logger.info(\"disabled or locked user accessing the api, userid = \" + user.getId() + \"; name = \" + user.getUsername() + \"; state: \" + user.getState() +\n                        \"; accountState: \" + account.getState());\n                return false;\n            }\n\n            if (!commandAvailable(remoteAddress, commandName, user)) {\n                return false;\n            }\n\n            \r\n            secretKey = user.getSecretKey();\n            if (secretKey == null) {\n                s_logger.info(\"User does not have a secret key associated with the account -- ignoring request, username: \" + user.getUsername());\n                return false;\n            }\n\n            unsignedRequest = unsignedRequest.toLowerCase();\n\n            final Mac mac = Mac.getInstance(\"HmacSHA1\");\n            final SecretKeySpec keySpec = new SecretKeySpec(secretKey.getBytes(), \"HmacSHA1\");\n            mac.init(keySpec);\n            mac.update(unsignedRequest.getBytes());\n\n            final byte[] encryptedBytes = mac.doFinal();\n            final String computedSignature = Base64.encodeBase64String(encryptedBytes);\n            final boolean equalSig = ConstantTimeComparator.compareStrings(signature, computedSignature);\n\n            if (!equalSig) {\n                s_logger.info(\"User signature: \" + signature + \" is not equaled to computed signature: \" + computedSignature);\n            } else {\n                CallContext.register(user, account);\n            }\n            return equalSig;\n        } catch (final ServerApiException ex) {\n            throw ex;\n        } catch (final Exception ex) {\n            s_logger.error(\"unable to verify request signature\");\n        }\n        return false;\n    }\n","realPath":"server/src/main/java/com/cloud/api/ApiServer.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":801,"status":"B"},{"authorDate":"2018-01-20 05:49:27","commitOrder":1,"curCode":"    private boolean verifyRequest(Map<String, Object[]> requestParameters) {\n        try {\n            String apiKey = null;\n            String secretKey = null;\n            String signature = null;\n            String unsignedRequest = null;\n\n            \r\n            \r\n            List<String> parameterNames = new ArrayList<String>();\n\n            for (Object paramNameObj : requestParameters.keySet()) {\n                parameterNames.add((String)paramNameObj); \r\n            }\n\n            Collections.sort(parameterNames);\n\n            for (String paramName : parameterNames) {\n                \r\n                String paramValue = ((String[])requestParameters.get(paramName))[0];\n\n                if (\"signature\".equalsIgnoreCase(paramName)) {\n                    signature = paramValue;\n                } else {\n                    if (\"apikey\".equalsIgnoreCase(paramName)) {\n                        apiKey = paramValue;\n                    }\n\n                    if (unsignedRequest == null) {\n                        unsignedRequest = paramName + \"=\" + URLEncoder.encode(paramValue, \"UTF-8\").replaceAll(\"\\\\+\", \"%20\");\n                    } else {\n                        unsignedRequest = unsignedRequest + \"&\" + paramName + \"=\" + URLEncoder.encode(paramValue, \"UTF-8\").replaceAll(\"\\\\+\", \"%20\");\n                    }\n                }\n            }\n\n            \r\n            if ((signature == null) || (apiKey == null)) {\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"expired session, missing signature, or missing apiKey -- ignoring request...sig: \" + signature + \", apiKey: \" + apiKey);\n                }\n                return false; \r\n            }\n\n            TransactionLegacy txn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\n            txn.close();\n            User user = null;\n            \r\n            Pair<User, Account> userAcctPair = _accountMgr.findUserByApiKey(apiKey);\n            if (userAcctPair == null) {\n                s_logger.debug(\"apiKey does not map to a valid user -- ignoring request, apiKey: \" + apiKey);\n                return false;\n            }\n\n            user = userAcctPair.first();\n            Account account = userAcctPair.second();\n\n            if (!user.getState().equals(Account.State.enabled) || !account.getState().equals(Account.State.enabled)) {\n                s_logger.debug(\"disabled or locked user accessing the api, userid = \" + user.getId() + \"; name = \" + user.getUsername() + \"; state: \" + user.getState() +\n                    \"; accountState: \" + account.getState());\n                return false;\n            }\n\n            \r\n            secretKey = user.getSecretKey();\n            if (secretKey == null) {\n                s_logger.debug(\"User does not have a secret key associated with the account -- ignoring request, username: \" + user.getUsername());\n                return false;\n            }\n\n            unsignedRequest = unsignedRequest.toLowerCase();\n\n            Mac mac = Mac.getInstance(\"HmacSHA1\");\n            SecretKeySpec keySpec = new SecretKeySpec(secretKey.getBytes(), \"HmacSHA1\");\n            mac.init(keySpec);\n            mac.update(unsignedRequest.getBytes());\n            byte[] encryptedBytes = mac.doFinal();\n            String computedSignature = Base64.encodeBase64String(encryptedBytes);\n            boolean equalSig = ConstantTimeComparator.compareStrings(signature, computedSignature);\n            if (!equalSig) {\n                s_logger.debug(\"User signature: \" + signature + \" is not equaled to computed signature: \" + computedSignature);\n            }\n\n            if (equalSig) {\n                requestParameters.put(\"userid\", new Object[] {String.valueOf(user.getId())});\n                requestParameters.put(\"account\", new Object[] {account.getAccountName()});\n                requestParameters.put(\"accountobj\", new Object[] {account});\n            }\n            return equalSig;\n        } catch (Exception ex) {\n            s_logger.error(\"unable to verifty request signature\", ex);\n        }\n        return false;\n    }\n","date":"2018-01-20 05:49:27","endLine":680,"groupId":"10147","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"verifyRequest","params":"(Map<String@Object[]>requestParameters)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/cc/788c7b118383cb78ed4f1aa17672dba0eff3c5.src","preCode":"    private boolean verifyRequest(Map<String, Object[]> requestParameters) {\n        try {\n            String apiKey = null;\n            String secretKey = null;\n            String signature = null;\n            String unsignedRequest = null;\n\n            \r\n            \r\n            List<String> parameterNames = new ArrayList<String>();\n\n            for (Object paramNameObj : requestParameters.keySet()) {\n                parameterNames.add((String)paramNameObj); \r\n            }\n\n            Collections.sort(parameterNames);\n\n            for (String paramName : parameterNames) {\n                \r\n                String paramValue = ((String[])requestParameters.get(paramName))[0];\n\n                if (\"signature\".equalsIgnoreCase(paramName)) {\n                    signature = paramValue;\n                } else {\n                    if (\"apikey\".equalsIgnoreCase(paramName)) {\n                        apiKey = paramValue;\n                    }\n\n                    if (unsignedRequest == null) {\n                        unsignedRequest = paramName + \"=\" + URLEncoder.encode(paramValue, \"UTF-8\").replaceAll(\"\\\\+\", \"%20\");\n                    } else {\n                        unsignedRequest = unsignedRequest + \"&\" + paramName + \"=\" + URLEncoder.encode(paramValue, \"UTF-8\").replaceAll(\"\\\\+\", \"%20\");\n                    }\n                }\n            }\n\n            \r\n            if ((signature == null) || (apiKey == null)) {\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"expired session, missing signature, or missing apiKey -- ignoring request...sig: \" + signature + \", apiKey: \" + apiKey);\n                }\n                return false; \r\n            }\n\n            TransactionLegacy txn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\n            txn.close();\n            User user = null;\n            \r\n            Pair<User, Account> userAcctPair = _accountMgr.findUserByApiKey(apiKey);\n            if (userAcctPair == null) {\n                s_logger.debug(\"apiKey does not map to a valid user -- ignoring request, apiKey: \" + apiKey);\n                return false;\n            }\n\n            user = userAcctPair.first();\n            Account account = userAcctPair.second();\n\n            if (!user.getState().equals(Account.State.enabled) || !account.getState().equals(Account.State.enabled)) {\n                s_logger.debug(\"disabled or locked user accessing the api, userid = \" + user.getId() + \"; name = \" + user.getUsername() + \"; state: \" + user.getState() +\n                    \"; accountState: \" + account.getState());\n                return false;\n            }\n\n            \r\n            secretKey = user.getSecretKey();\n            if (secretKey == null) {\n                s_logger.debug(\"User does not have a secret key associated with the account -- ignoring request, username: \" + user.getUsername());\n                return false;\n            }\n\n            unsignedRequest = unsignedRequest.toLowerCase();\n\n            Mac mac = Mac.getInstance(\"HmacSHA1\");\n            SecretKeySpec keySpec = new SecretKeySpec(secretKey.getBytes(), \"HmacSHA1\");\n            mac.init(keySpec);\n            mac.update(unsignedRequest.getBytes());\n            byte[] encryptedBytes = mac.doFinal();\n            String computedSignature = Base64.encodeBase64String(encryptedBytes);\n            boolean equalSig = ConstantTimeComparator.compareStrings(signature, computedSignature);\n            if (!equalSig) {\n                s_logger.debug(\"User signature: \" + signature + \" is not equaled to computed signature: \" + computedSignature);\n            }\n\n            if (equalSig) {\n                requestParameters.put(\"userid\", new Object[] {String.valueOf(user.getId())});\n                requestParameters.put(\"account\", new Object[] {account.getAccountName()});\n                requestParameters.put(\"accountobj\", new Object[] {account});\n            }\n            return equalSig;\n        } catch (Exception ex) {\n            s_logger.error(\"unable to verifty request signature\", ex);\n        }\n        return false;\n    }\n","realPath":"server/src/main/java/com/cloud/servlet/ConsoleProxyServlet.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":587,"status":"B"}],"commitId":"893a88d225276e45f12f9490e6af2c94a81c2965","commitMessage":"@@@CLOUDSTACK-10105: Use maven standard project structure in all projects (#2283)\n\nRemove maven standard module (which only a few were using) and get ride of maven customization for the projects structure.\n\n- moved all directories to src/main/java.  src/main/resources.  src/main/scripts.  src/test/java.  src/test/resources\n- grep scan to search for src/com and src/org left over\n- grep for <project>/scripts to fix pom.xml configuration\n- remove custom <build> configuration in pom.xml\n\nSigned-off-by: Marc-Aur?le Brothier <m@brothier.org>","date":"2018-01-20 05:49:27","modifiedFileCount":"1","status":"B","submitter":"Marc-Aur?le Brothier"},{"authorTime":"2018-01-20 05:49:27","codes":[{"authorDate":"2018-10-31 19:27:48","commitOrder":2,"curCode":"    public boolean verifyRequest(final Map<String, Object[]> requestParameters, final Long userId, InetAddress remoteAddress) throws ServerApiException {\n        try {\n            String apiKey = null;\n            String secretKey = null;\n            String signature = null;\n            String unsignedRequest = null;\n\n            final String[] command = (String[])requestParameters.get(ApiConstants.COMMAND);\n            if (command == null) {\n                s_logger.info(\"missing command, ignoring request...\");\n                return false;\n            }\n\n            final String commandName = command[0];\n\n            \r\n            if (userId != null) {\n                final User user = ApiDBUtils.findUserById(userId);\n\n                if (!commandAvailable(remoteAddress, commandName, user)) {\n                    return false;\n                }\n\n                return true;\n            } else {\n                \r\n                if (!s_apiNameCmdClassMap.containsKey(commandName) && !commandName.equals(\"login\") && !commandName.equals(\"logout\")) {\n                    final String errorMessage = \"The given command \" + commandName + \" either does not exist, is not available\" +\n                            \" for user, or not available from ip address '\" + remoteAddress.getHostAddress() + \"'.\";\n                    s_logger.debug(errorMessage);\n                    return false;\n                }\n            }\n\n            \r\n            \r\n            final List<String> parameterNames = new ArrayList<String>();\n\n            for (final Object paramNameObj : requestParameters.keySet()) {\n                parameterNames.add((String)paramNameObj); \r\n            }\n\n            Collections.sort(parameterNames);\n\n            String signatureVersion = null;\n            String expires = null;\n\n            for (final String paramName : parameterNames) {\n                \r\n                final String paramValue = ((String[])requestParameters.get(paramName))[0];\n\n                if (ApiConstants.SIGNATURE.equalsIgnoreCase(paramName)) {\n                    signature = paramValue;\n                } else {\n                    if (ApiConstants.API_KEY.equalsIgnoreCase(paramName)) {\n                        apiKey = paramValue;\n                    } else if (ApiConstants.SIGNATURE_VERSION.equalsIgnoreCase(paramName)) {\n                        signatureVersion = paramValue;\n                    } else if (ApiConstants.EXPIRES.equalsIgnoreCase(paramName)) {\n                        expires = paramValue;\n                    }\n\n                    if (unsignedRequest == null) {\n                        unsignedRequest = paramName + \"=\" + URLEncoder.encode(paramValue, HttpUtils.UTF_8).replaceAll(\"\\\\+\", \"%20\");\n                    } else {\n                        unsignedRequest = unsignedRequest + \"&\" + paramName + \"=\" + URLEncoder.encode(paramValue, HttpUtils.UTF_8).replaceAll(\"\\\\+\", \"%20\");\n                    }\n                }\n            }\n\n            \r\n            if ((signature == null) || (apiKey == null)) {\n                s_logger.debug(\"Expired session, missing signature, or missing apiKey -- ignoring request. Signature: \" + signature + \", apiKey: \" + apiKey);\n                return false; \r\n            }\n\n            Date expiresTS = null;\n            \r\n            if (\"3\".equals(signatureVersion)) {\n                \r\n                if (expires == null) {\n                    s_logger.debug(\"Missing Expires parameter -- ignoring request. Signature: \" + signature + \", apiKey: \" + apiKey);\n                    return false;\n                }\n\n                try {\n                    expiresTS = DateUtil.parseTZDateString(expires);\n                } catch (final ParseException pe) {\n                    s_logger.debug(\"Incorrect date format for Expires parameter\", pe);\n                    return false;\n                }\n\n                final Date now = new Date(System.currentTimeMillis());\n                if (expiresTS.before(now)) {\n                    s_logger.debug(\"Request expired -- ignoring ...sig: \" + signature + \", apiKey: \" + apiKey);\n                    return false;\n                }\n            }\n\n            final TransactionLegacy txn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\n            txn.close();\n            User user = null;\n            \r\n            final Pair<User, Account> userAcctPair = accountMgr.findUserByApiKey(apiKey);\n            if (userAcctPair == null) {\n                s_logger.debug(\"apiKey does not map to a valid user -- ignoring request, apiKey: \" + apiKey);\n                return false;\n            }\n\n            user = userAcctPair.first();\n            final Account account = userAcctPair.second();\n\n            if (user.getState() != Account.State.enabled || !account.getState().equals(Account.State.enabled)) {\n                s_logger.info(\"disabled or locked user accessing the api, userid = \" + user.getId() + \"; name = \" + user.getUsername() + \"; state: \" + user.getState() +\n                        \"; accountState: \" + account.getState());\n                return false;\n            }\n\n            if (!commandAvailable(remoteAddress, commandName, user)) {\n                return false;\n            }\n\n            \r\n            secretKey = user.getSecretKey();\n            if (secretKey == null) {\n                s_logger.info(\"User does not have a secret key associated with the account -- ignoring request, username: \" + user.getUsername());\n                return false;\n            }\n\n            unsignedRequest = unsignedRequest.toLowerCase();\n\n            final Mac mac = Mac.getInstance(\"HmacSHA1\");\n            final SecretKeySpec keySpec = new SecretKeySpec(secretKey.getBytes(), \"HmacSHA1\");\n            mac.init(keySpec);\n            mac.update(unsignedRequest.getBytes());\n\n            final byte[] encryptedBytes = mac.doFinal();\n            final String computedSignature = Base64.encodeBase64String(encryptedBytes);\n            final boolean equalSig = ConstantTimeComparator.compareStrings(signature, computedSignature);\n\n            if (!equalSig) {\n                s_logger.info(\"User signature: \" + signature + \" is not equaled to computed signature: \" + computedSignature);\n            } else {\n                CallContext.register(user, account);\n            }\n            return equalSig;\n        } catch (final ServerApiException ex) {\n            throw ex;\n        } catch (final Exception ex) {\n            s_logger.error(\"unable to verify request signature\");\n        }\n        return false;\n    }\n","date":"2018-10-31 19:27:48","endLine":952,"groupId":"3269","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"verifyRequest","params":"(finalMap<String@Object[]>requestParameters@finalLonguserId@InetAddressremoteAddress)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/a3/0718b0650c06a0ed976f2444cb4bb46b4b59eb.src","preCode":"    public boolean verifyRequest(final Map<String, Object[]> requestParameters, final Long userId, InetAddress remoteAddress) throws ServerApiException {\n        try {\n            String apiKey = null;\n            String secretKey = null;\n            String signature = null;\n            String unsignedRequest = null;\n\n            final String[] command = (String[])requestParameters.get(ApiConstants.COMMAND);\n            if (command == null) {\n                s_logger.info(\"missing command, ignoring request...\");\n                return false;\n            }\n\n            final String commandName = command[0];\n\n            \r\n            if (userId != null) {\n                final User user = ApiDBUtils.findUserById(userId);\n\n                if (!commandAvailable(remoteAddress, commandName, user)) {\n                    return false;\n                }\n\n                return true;\n            } else {\n                \r\n                if (!s_apiNameCmdClassMap.containsKey(commandName) && !commandName.equals(\"login\") && !commandName.equals(\"logout\")) {\n                    final String errorMessage = \"The given command \" + commandName + \" either does not exist, is not available\" +\n                            \" for user, or not available from ip address '\" + remoteAddress.getHostAddress() + \"'.\";\n                    s_logger.debug(errorMessage);\n                    return false;\n                }\n            }\n\n            \r\n            \r\n            final List<String> parameterNames = new ArrayList<String>();\n\n            for (final Object paramNameObj : requestParameters.keySet()) {\n                parameterNames.add((String)paramNameObj); \r\n            }\n\n            Collections.sort(parameterNames);\n\n            String signatureVersion = null;\n            String expires = null;\n\n            for (final String paramName : parameterNames) {\n                \r\n                final String paramValue = ((String[])requestParameters.get(paramName))[0];\n\n                if (ApiConstants.SIGNATURE.equalsIgnoreCase(paramName)) {\n                    signature = paramValue;\n                } else {\n                    if (ApiConstants.API_KEY.equalsIgnoreCase(paramName)) {\n                        apiKey = paramValue;\n                    } else if (ApiConstants.SIGNATURE_VERSION.equalsIgnoreCase(paramName)) {\n                        signatureVersion = paramValue;\n                    } else if (ApiConstants.EXPIRES.equalsIgnoreCase(paramName)) {\n                        expires = paramValue;\n                    }\n\n                    if (unsignedRequest == null) {\n                        unsignedRequest = paramName + \"=\" + URLEncoder.encode(paramValue, HttpUtils.UTF_8).replaceAll(\"\\\\+\", \"%20\");\n                    } else {\n                        unsignedRequest = unsignedRequest + \"&\" + paramName + \"=\" + URLEncoder.encode(paramValue, HttpUtils.UTF_8).replaceAll(\"\\\\+\", \"%20\");\n                    }\n                }\n            }\n\n            \r\n            if ((signature == null) || (apiKey == null)) {\n                s_logger.debug(\"Expired session, missing signature, or missing apiKey -- ignoring request. Signature: \" + signature + \", apiKey: \" + apiKey);\n                return false; \r\n            }\n\n            Date expiresTS = null;\n            \r\n            if (\"3\".equals(signatureVersion)) {\n                \r\n                if (expires == null) {\n                    s_logger.debug(\"Missing Expires parameter -- ignoring request. Signature: \" + signature + \", apiKey: \" + apiKey);\n                    return false;\n                }\n                synchronized (DateFormatToUse) {\n                    try {\n                        expiresTS = DateFormatToUse.parse(expires);\n                    } catch (final ParseException pe) {\n                        s_logger.debug(\"Incorrect date format for Expires parameter\", pe);\n                        return false;\n                    }\n                }\n                final Date now = new Date(System.currentTimeMillis());\n                if (expiresTS.before(now)) {\n                    s_logger.debug(\"Request expired -- ignoring ...sig: \" + signature + \", apiKey: \" + apiKey);\n                    return false;\n                }\n            }\n\n            final TransactionLegacy txn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\n            txn.close();\n            User user = null;\n            \r\n            final Pair<User, Account> userAcctPair = accountMgr.findUserByApiKey(apiKey);\n            if (userAcctPair == null) {\n                s_logger.debug(\"apiKey does not map to a valid user -- ignoring request, apiKey: \" + apiKey);\n                return false;\n            }\n\n            user = userAcctPair.first();\n            final Account account = userAcctPair.second();\n\n            if (user.getState() != Account.State.enabled || !account.getState().equals(Account.State.enabled)) {\n                s_logger.info(\"disabled or locked user accessing the api, userid = \" + user.getId() + \"; name = \" + user.getUsername() + \"; state: \" + user.getState() +\n                        \"; accountState: \" + account.getState());\n                return false;\n            }\n\n            if (!commandAvailable(remoteAddress, commandName, user)) {\n                return false;\n            }\n\n            \r\n            secretKey = user.getSecretKey();\n            if (secretKey == null) {\n                s_logger.info(\"User does not have a secret key associated with the account -- ignoring request, username: \" + user.getUsername());\n                return false;\n            }\n\n            unsignedRequest = unsignedRequest.toLowerCase();\n\n            final Mac mac = Mac.getInstance(\"HmacSHA1\");\n            final SecretKeySpec keySpec = new SecretKeySpec(secretKey.getBytes(), \"HmacSHA1\");\n            mac.init(keySpec);\n            mac.update(unsignedRequest.getBytes());\n\n            final byte[] encryptedBytes = mac.doFinal();\n            final String computedSignature = Base64.encodeBase64String(encryptedBytes);\n            final boolean equalSig = ConstantTimeComparator.compareStrings(signature, computedSignature);\n\n            if (!equalSig) {\n                s_logger.info(\"User signature: \" + signature + \" is not equaled to computed signature: \" + computedSignature);\n            } else {\n                CallContext.register(user, account);\n            }\n            return equalSig;\n        } catch (final ServerApiException ex) {\n            throw ex;\n        } catch (final Exception ex) {\n            s_logger.error(\"unable to verify request signature\");\n        }\n        return false;\n    }\n","realPath":"server/src/main/java/com/cloud/api/ApiServer.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":800,"status":"M"},{"authorDate":"2018-01-20 05:49:27","commitOrder":2,"curCode":"    private boolean verifyRequest(Map<String, Object[]> requestParameters) {\n        try {\n            String apiKey = null;\n            String secretKey = null;\n            String signature = null;\n            String unsignedRequest = null;\n\n            \r\n            \r\n            List<String> parameterNames = new ArrayList<String>();\n\n            for (Object paramNameObj : requestParameters.keySet()) {\n                parameterNames.add((String)paramNameObj); \r\n            }\n\n            Collections.sort(parameterNames);\n\n            for (String paramName : parameterNames) {\n                \r\n                String paramValue = ((String[])requestParameters.get(paramName))[0];\n\n                if (\"signature\".equalsIgnoreCase(paramName)) {\n                    signature = paramValue;\n                } else {\n                    if (\"apikey\".equalsIgnoreCase(paramName)) {\n                        apiKey = paramValue;\n                    }\n\n                    if (unsignedRequest == null) {\n                        unsignedRequest = paramName + \"=\" + URLEncoder.encode(paramValue, \"UTF-8\").replaceAll(\"\\\\+\", \"%20\");\n                    } else {\n                        unsignedRequest = unsignedRequest + \"&\" + paramName + \"=\" + URLEncoder.encode(paramValue, \"UTF-8\").replaceAll(\"\\\\+\", \"%20\");\n                    }\n                }\n            }\n\n            \r\n            if ((signature == null) || (apiKey == null)) {\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"expired session, missing signature, or missing apiKey -- ignoring request...sig: \" + signature + \", apiKey: \" + apiKey);\n                }\n                return false; \r\n            }\n\n            TransactionLegacy txn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\n            txn.close();\n            User user = null;\n            \r\n            Pair<User, Account> userAcctPair = _accountMgr.findUserByApiKey(apiKey);\n            if (userAcctPair == null) {\n                s_logger.debug(\"apiKey does not map to a valid user -- ignoring request, apiKey: \" + apiKey);\n                return false;\n            }\n\n            user = userAcctPair.first();\n            Account account = userAcctPair.second();\n\n            if (!user.getState().equals(Account.State.enabled) || !account.getState().equals(Account.State.enabled)) {\n                s_logger.debug(\"disabled or locked user accessing the api, userid = \" + user.getId() + \"; name = \" + user.getUsername() + \"; state: \" + user.getState() +\n                    \"; accountState: \" + account.getState());\n                return false;\n            }\n\n            \r\n            secretKey = user.getSecretKey();\n            if (secretKey == null) {\n                s_logger.debug(\"User does not have a secret key associated with the account -- ignoring request, username: \" + user.getUsername());\n                return false;\n            }\n\n            unsignedRequest = unsignedRequest.toLowerCase();\n\n            Mac mac = Mac.getInstance(\"HmacSHA1\");\n            SecretKeySpec keySpec = new SecretKeySpec(secretKey.getBytes(), \"HmacSHA1\");\n            mac.init(keySpec);\n            mac.update(unsignedRequest.getBytes());\n            byte[] encryptedBytes = mac.doFinal();\n            String computedSignature = Base64.encodeBase64String(encryptedBytes);\n            boolean equalSig = ConstantTimeComparator.compareStrings(signature, computedSignature);\n            if (!equalSig) {\n                s_logger.debug(\"User signature: \" + signature + \" is not equaled to computed signature: \" + computedSignature);\n            }\n\n            if (equalSig) {\n                requestParameters.put(\"userid\", new Object[] {String.valueOf(user.getId())});\n                requestParameters.put(\"account\", new Object[] {account.getAccountName()});\n                requestParameters.put(\"accountobj\", new Object[] {account});\n            }\n            return equalSig;\n        } catch (Exception ex) {\n            s_logger.error(\"unable to verifty request signature\", ex);\n        }\n        return false;\n    }\n","date":"2018-01-20 05:49:27","endLine":680,"groupId":"10147","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"verifyRequest","params":"(Map<String@Object[]>requestParameters)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/cc/788c7b118383cb78ed4f1aa17672dba0eff3c5.src","preCode":"    private boolean verifyRequest(Map<String, Object[]> requestParameters) {\n        try {\n            String apiKey = null;\n            String secretKey = null;\n            String signature = null;\n            String unsignedRequest = null;\n\n            \r\n            \r\n            List<String> parameterNames = new ArrayList<String>();\n\n            for (Object paramNameObj : requestParameters.keySet()) {\n                parameterNames.add((String)paramNameObj); \r\n            }\n\n            Collections.sort(parameterNames);\n\n            for (String paramName : parameterNames) {\n                \r\n                String paramValue = ((String[])requestParameters.get(paramName))[0];\n\n                if (\"signature\".equalsIgnoreCase(paramName)) {\n                    signature = paramValue;\n                } else {\n                    if (\"apikey\".equalsIgnoreCase(paramName)) {\n                        apiKey = paramValue;\n                    }\n\n                    if (unsignedRequest == null) {\n                        unsignedRequest = paramName + \"=\" + URLEncoder.encode(paramValue, \"UTF-8\").replaceAll(\"\\\\+\", \"%20\");\n                    } else {\n                        unsignedRequest = unsignedRequest + \"&\" + paramName + \"=\" + URLEncoder.encode(paramValue, \"UTF-8\").replaceAll(\"\\\\+\", \"%20\");\n                    }\n                }\n            }\n\n            \r\n            if ((signature == null) || (apiKey == null)) {\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"expired session, missing signature, or missing apiKey -- ignoring request...sig: \" + signature + \", apiKey: \" + apiKey);\n                }\n                return false; \r\n            }\n\n            TransactionLegacy txn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\n            txn.close();\n            User user = null;\n            \r\n            Pair<User, Account> userAcctPair = _accountMgr.findUserByApiKey(apiKey);\n            if (userAcctPair == null) {\n                s_logger.debug(\"apiKey does not map to a valid user -- ignoring request, apiKey: \" + apiKey);\n                return false;\n            }\n\n            user = userAcctPair.first();\n            Account account = userAcctPair.second();\n\n            if (!user.getState().equals(Account.State.enabled) || !account.getState().equals(Account.State.enabled)) {\n                s_logger.debug(\"disabled or locked user accessing the api, userid = \" + user.getId() + \"; name = \" + user.getUsername() + \"; state: \" + user.getState() +\n                    \"; accountState: \" + account.getState());\n                return false;\n            }\n\n            \r\n            secretKey = user.getSecretKey();\n            if (secretKey == null) {\n                s_logger.debug(\"User does not have a secret key associated with the account -- ignoring request, username: \" + user.getUsername());\n                return false;\n            }\n\n            unsignedRequest = unsignedRequest.toLowerCase();\n\n            Mac mac = Mac.getInstance(\"HmacSHA1\");\n            SecretKeySpec keySpec = new SecretKeySpec(secretKey.getBytes(), \"HmacSHA1\");\n            mac.init(keySpec);\n            mac.update(unsignedRequest.getBytes());\n            byte[] encryptedBytes = mac.doFinal();\n            String computedSignature = Base64.encodeBase64String(encryptedBytes);\n            boolean equalSig = ConstantTimeComparator.compareStrings(signature, computedSignature);\n            if (!equalSig) {\n                s_logger.debug(\"User signature: \" + signature + \" is not equaled to computed signature: \" + computedSignature);\n            }\n\n            if (equalSig) {\n                requestParameters.put(\"userid\", new Object[] {String.valueOf(user.getId())});\n                requestParameters.put(\"account\", new Object[] {account.getAccountName()});\n                requestParameters.put(\"accountobj\", new Object[] {account});\n            }\n            return equalSig;\n        } catch (Exception ex) {\n            s_logger.error(\"unable to verifty request signature\", ex);\n        }\n        return false;\n    }\n","realPath":"server/src/main/java/com/cloud/servlet/ConsoleProxyServlet.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":587,"status":"N"}],"commitId":"17c164d59a218675f25f1faf583260032e535d80","commitMessage":"@@@api: signature v3 to accept more formats (#2893)\n\nIt does it by reusing the DateUtil helpers. DateUtil uses java.time.* as that one knows how to deal\nwith timezones correctly.\n\nThe format expected by signatureVersion=3&expires=.... is quite limited.\n\nIt should accept the following formats that are containing a timezone and/or milliseconds.\n\n2018-10-01T08:12:14Z\n2018-10-01T08:12:14+01:00\n2018-10-01T08:12:14+0100\n2018-10-01T08:12:14.000Z\n2018-10-01T08:12:14.000+01:00\n2018-10-01T08:12:14.000+0100\nafaik only 2018-10-01T08:12:14+0100 is accepted by the current codebase.\n\nThis PR echoes other pull requests I made earlier this year. #2392 and #2867\n\nSigned-off-by: Yoan Blanc <yoan.blanc@exoscale.ch>","date":"2018-10-31 19:27:48","modifiedFileCount":"3","status":"M","submitter":"Yoan Blanc"},{"authorTime":"2018-01-20 05:49:27","codes":[{"authorDate":"2019-12-24 17:24:09","commitOrder":3,"curCode":"    public boolean verifyRequest(final Map<String, Object[]> requestParameters, final Long userId, InetAddress remoteAddress) throws ServerApiException {\n        try {\n            String apiKey = null;\n            String secretKey = null;\n            String signature = null;\n            String unsignedRequest = null;\n\n            final String[] command = (String[])requestParameters.get(ApiConstants.COMMAND);\n            if (command == null) {\n                s_logger.info(\"missing command, ignoring request...\");\n                return false;\n            }\n\n            final String commandName = command[0];\n\n            \r\n            if (userId != null) {\n                final User user = ApiDBUtils.findUserById(userId);\n\n                return commandAvailable(remoteAddress, commandName, user);\n            } else {\n                \r\n                if (!s_apiNameCmdClassMap.containsKey(commandName) && !commandName.equals(\"login\") && !commandName.equals(\"logout\")) {\n                    final String errorMessage = \"The given command \" + commandName + \" either does not exist, is not available\" +\n                            \" for user, or not available from ip address '\" + remoteAddress.getHostAddress() + \"'.\";\n                    s_logger.debug(errorMessage);\n                    return false;\n                }\n            }\n\n            \r\n            \r\n            final List<String> parameterNames = new ArrayList<String>();\n\n            for (final Object paramNameObj : requestParameters.keySet()) {\n                parameterNames.add((String)paramNameObj); \r\n            }\n\n            Collections.sort(parameterNames);\n\n            String signatureVersion = null;\n            String expires = null;\n\n            for (final String paramName : parameterNames) {\n                \r\n                final String paramValue = ((String[])requestParameters.get(paramName))[0];\n\n                if (ApiConstants.SIGNATURE.equalsIgnoreCase(paramName)) {\n                    signature = paramValue;\n                } else {\n                    if (ApiConstants.API_KEY.equalsIgnoreCase(paramName)) {\n                        apiKey = paramValue;\n                    } else if (ApiConstants.SIGNATURE_VERSION.equalsIgnoreCase(paramName)) {\n                        signatureVersion = paramValue;\n                    } else if (ApiConstants.EXPIRES.equalsIgnoreCase(paramName)) {\n                        expires = paramValue;\n                    }\n\n                    if (unsignedRequest == null) {\n                        unsignedRequest = paramName + \"=\" + URLEncoder.encode(paramValue, HttpUtils.UTF_8).replaceAll(\"\\\\+\", \"%20\");\n                    } else {\n                        unsignedRequest = unsignedRequest + \"&\" + paramName + \"=\" + URLEncoder.encode(paramValue, HttpUtils.UTF_8).replaceAll(\"\\\\+\", \"%20\");\n                    }\n                }\n            }\n\n            \r\n            if ((signature == null) || (apiKey == null)) {\n                s_logger.debug(\"Expired session, missing signature, or missing apiKey -- ignoring request. Signature: \" + signature + \", apiKey: \" + apiKey);\n                return false; \r\n            }\n\n            Date expiresTS = null;\n            \r\n            if (\"3\".equals(signatureVersion)) {\n                \r\n                if (expires == null) {\n                    s_logger.debug(\"Missing Expires parameter -- ignoring request. Signature: \" + signature + \", apiKey: \" + apiKey);\n                    return false;\n                }\n\n                try {\n                    expiresTS = DateUtil.parseTZDateString(expires);\n                } catch (final ParseException pe) {\n                    s_logger.debug(\"Incorrect date format for Expires parameter\", pe);\n                    return false;\n                }\n\n                final Date now = new Date(System.currentTimeMillis());\n                if (expiresTS.before(now)) {\n                    s_logger.debug(\"Request expired -- ignoring ...sig: \" + signature + \", apiKey: \" + apiKey);\n                    return false;\n                }\n            }\n\n            final TransactionLegacy txn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\n            txn.close();\n            User user = null;\n            \r\n            final Pair<User, Account> userAcctPair = accountMgr.findUserByApiKey(apiKey);\n            if (userAcctPair == null) {\n                s_logger.debug(\"apiKey does not map to a valid user -- ignoring request, apiKey: \" + apiKey);\n                return false;\n            }\n\n            user = userAcctPair.first();\n            final Account account = userAcctPair.second();\n\n            if (user.getState() != Account.State.enabled || !account.getState().equals(Account.State.enabled)) {\n                s_logger.info(\"disabled or locked user accessing the api, userid = \" + user.getId() + \"; name = \" + user.getUsername() + \"; state: \" + user.getState() +\n                        \"; accountState: \" + account.getState());\n                return false;\n            }\n\n            if (!commandAvailable(remoteAddress, commandName, user)) {\n                return false;\n            }\n\n            \r\n            secretKey = user.getSecretKey();\n            if (secretKey == null) {\n                s_logger.info(\"User does not have a secret key associated with the account -- ignoring request, username: \" + user.getUsername());\n                return false;\n            }\n\n            unsignedRequest = unsignedRequest.toLowerCase();\n\n            final Mac mac = Mac.getInstance(\"HmacSHA1\");\n            final SecretKeySpec keySpec = new SecretKeySpec(secretKey.getBytes(), \"HmacSHA1\");\n            mac.init(keySpec);\n            mac.update(unsignedRequest.getBytes());\n\n            final byte[] encryptedBytes = mac.doFinal();\n            final String computedSignature = Base64.encodeBase64String(encryptedBytes);\n            final boolean equalSig = ConstantTimeComparator.compareStrings(signature, computedSignature);\n\n            if (!equalSig) {\n                s_logger.info(\"User signature: \" + signature + \" is not equaled to computed signature: \" + computedSignature);\n            } else {\n                CallContext.register(user, account);\n            }\n            return equalSig;\n        } catch (final ServerApiException ex) {\n            throw ex;\n        } catch (final Exception ex) {\n            s_logger.error(\"unable to verify request signature\");\n        }\n        return false;\n    }\n","date":"2019-12-24 17:24:09","endLine":976,"groupId":"101435","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"verifyRequest","params":"(finalMap<String@Object[]>requestParameters@finalLonguserId@InetAddressremoteAddress)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/7d/096b869a8f31e21b65e2de69ad5db157e1df8b.src","preCode":"    public boolean verifyRequest(final Map<String, Object[]> requestParameters, final Long userId, InetAddress remoteAddress) throws ServerApiException {\n        try {\n            String apiKey = null;\n            String secretKey = null;\n            String signature = null;\n            String unsignedRequest = null;\n\n            final String[] command = (String[])requestParameters.get(ApiConstants.COMMAND);\n            if (command == null) {\n                s_logger.info(\"missing command, ignoring request...\");\n                return false;\n            }\n\n            final String commandName = command[0];\n\n            \r\n            if (userId != null) {\n                final User user = ApiDBUtils.findUserById(userId);\n\n                if (!commandAvailable(remoteAddress, commandName, user)) {\n                    return false;\n                }\n\n                return true;\n            } else {\n                \r\n                if (!s_apiNameCmdClassMap.containsKey(commandName) && !commandName.equals(\"login\") && !commandName.equals(\"logout\")) {\n                    final String errorMessage = \"The given command \" + commandName + \" either does not exist, is not available\" +\n                            \" for user, or not available from ip address '\" + remoteAddress.getHostAddress() + \"'.\";\n                    s_logger.debug(errorMessage);\n                    return false;\n                }\n            }\n\n            \r\n            \r\n            final List<String> parameterNames = new ArrayList<String>();\n\n            for (final Object paramNameObj : requestParameters.keySet()) {\n                parameterNames.add((String)paramNameObj); \r\n            }\n\n            Collections.sort(parameterNames);\n\n            String signatureVersion = null;\n            String expires = null;\n\n            for (final String paramName : parameterNames) {\n                \r\n                final String paramValue = ((String[])requestParameters.get(paramName))[0];\n\n                if (ApiConstants.SIGNATURE.equalsIgnoreCase(paramName)) {\n                    signature = paramValue;\n                } else {\n                    if (ApiConstants.API_KEY.equalsIgnoreCase(paramName)) {\n                        apiKey = paramValue;\n                    } else if (ApiConstants.SIGNATURE_VERSION.equalsIgnoreCase(paramName)) {\n                        signatureVersion = paramValue;\n                    } else if (ApiConstants.EXPIRES.equalsIgnoreCase(paramName)) {\n                        expires = paramValue;\n                    }\n\n                    if (unsignedRequest == null) {\n                        unsignedRequest = paramName + \"=\" + URLEncoder.encode(paramValue, HttpUtils.UTF_8).replaceAll(\"\\\\+\", \"%20\");\n                    } else {\n                        unsignedRequest = unsignedRequest + \"&\" + paramName + \"=\" + URLEncoder.encode(paramValue, HttpUtils.UTF_8).replaceAll(\"\\\\+\", \"%20\");\n                    }\n                }\n            }\n\n            \r\n            if ((signature == null) || (apiKey == null)) {\n                s_logger.debug(\"Expired session, missing signature, or missing apiKey -- ignoring request. Signature: \" + signature + \", apiKey: \" + apiKey);\n                return false; \r\n            }\n\n            Date expiresTS = null;\n            \r\n            if (\"3\".equals(signatureVersion)) {\n                \r\n                if (expires == null) {\n                    s_logger.debug(\"Missing Expires parameter -- ignoring request. Signature: \" + signature + \", apiKey: \" + apiKey);\n                    return false;\n                }\n\n                try {\n                    expiresTS = DateUtil.parseTZDateString(expires);\n                } catch (final ParseException pe) {\n                    s_logger.debug(\"Incorrect date format for Expires parameter\", pe);\n                    return false;\n                }\n\n                final Date now = new Date(System.currentTimeMillis());\n                if (expiresTS.before(now)) {\n                    s_logger.debug(\"Request expired -- ignoring ...sig: \" + signature + \", apiKey: \" + apiKey);\n                    return false;\n                }\n            }\n\n            final TransactionLegacy txn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\n            txn.close();\n            User user = null;\n            \r\n            final Pair<User, Account> userAcctPair = accountMgr.findUserByApiKey(apiKey);\n            if (userAcctPair == null) {\n                s_logger.debug(\"apiKey does not map to a valid user -- ignoring request, apiKey: \" + apiKey);\n                return false;\n            }\n\n            user = userAcctPair.first();\n            final Account account = userAcctPair.second();\n\n            if (user.getState() != Account.State.enabled || !account.getState().equals(Account.State.enabled)) {\n                s_logger.info(\"disabled or locked user accessing the api, userid = \" + user.getId() + \"; name = \" + user.getUsername() + \"; state: \" + user.getState() +\n                        \"; accountState: \" + account.getState());\n                return false;\n            }\n\n            if (!commandAvailable(remoteAddress, commandName, user)) {\n                return false;\n            }\n\n            \r\n            secretKey = user.getSecretKey();\n            if (secretKey == null) {\n                s_logger.info(\"User does not have a secret key associated with the account -- ignoring request, username: \" + user.getUsername());\n                return false;\n            }\n\n            unsignedRequest = unsignedRequest.toLowerCase();\n\n            final Mac mac = Mac.getInstance(\"HmacSHA1\");\n            final SecretKeySpec keySpec = new SecretKeySpec(secretKey.getBytes(), \"HmacSHA1\");\n            mac.init(keySpec);\n            mac.update(unsignedRequest.getBytes());\n\n            final byte[] encryptedBytes = mac.doFinal();\n            final String computedSignature = Base64.encodeBase64String(encryptedBytes);\n            final boolean equalSig = ConstantTimeComparator.compareStrings(signature, computedSignature);\n\n            if (!equalSig) {\n                s_logger.info(\"User signature: \" + signature + \" is not equaled to computed signature: \" + computedSignature);\n            } else {\n                CallContext.register(user, account);\n            }\n            return equalSig;\n        } catch (final ServerApiException ex) {\n            throw ex;\n        } catch (final Exception ex) {\n            s_logger.error(\"unable to verify request signature\");\n        }\n        return false;\n    }\n","realPath":"server/src/main/java/com/cloud/api/ApiServer.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":828,"status":"M"},{"authorDate":"2018-01-20 05:49:27","commitOrder":3,"curCode":"    private boolean verifyRequest(Map<String, Object[]> requestParameters) {\n        try {\n            String apiKey = null;\n            String secretKey = null;\n            String signature = null;\n            String unsignedRequest = null;\n\n            \r\n            \r\n            List<String> parameterNames = new ArrayList<String>();\n\n            for (Object paramNameObj : requestParameters.keySet()) {\n                parameterNames.add((String)paramNameObj); \r\n            }\n\n            Collections.sort(parameterNames);\n\n            for (String paramName : parameterNames) {\n                \r\n                String paramValue = ((String[])requestParameters.get(paramName))[0];\n\n                if (\"signature\".equalsIgnoreCase(paramName)) {\n                    signature = paramValue;\n                } else {\n                    if (\"apikey\".equalsIgnoreCase(paramName)) {\n                        apiKey = paramValue;\n                    }\n\n                    if (unsignedRequest == null) {\n                        unsignedRequest = paramName + \"=\" + URLEncoder.encode(paramValue, \"UTF-8\").replaceAll(\"\\\\+\", \"%20\");\n                    } else {\n                        unsignedRequest = unsignedRequest + \"&\" + paramName + \"=\" + URLEncoder.encode(paramValue, \"UTF-8\").replaceAll(\"\\\\+\", \"%20\");\n                    }\n                }\n            }\n\n            \r\n            if ((signature == null) || (apiKey == null)) {\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"expired session, missing signature, or missing apiKey -- ignoring request...sig: \" + signature + \", apiKey: \" + apiKey);\n                }\n                return false; \r\n            }\n\n            TransactionLegacy txn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\n            txn.close();\n            User user = null;\n            \r\n            Pair<User, Account> userAcctPair = _accountMgr.findUserByApiKey(apiKey);\n            if (userAcctPair == null) {\n                s_logger.debug(\"apiKey does not map to a valid user -- ignoring request, apiKey: \" + apiKey);\n                return false;\n            }\n\n            user = userAcctPair.first();\n            Account account = userAcctPair.second();\n\n            if (!user.getState().equals(Account.State.enabled) || !account.getState().equals(Account.State.enabled)) {\n                s_logger.debug(\"disabled or locked user accessing the api, userid = \" + user.getId() + \"; name = \" + user.getUsername() + \"; state: \" + user.getState() +\n                    \"; accountState: \" + account.getState());\n                return false;\n            }\n\n            \r\n            secretKey = user.getSecretKey();\n            if (secretKey == null) {\n                s_logger.debug(\"User does not have a secret key associated with the account -- ignoring request, username: \" + user.getUsername());\n                return false;\n            }\n\n            unsignedRequest = unsignedRequest.toLowerCase();\n\n            Mac mac = Mac.getInstance(\"HmacSHA1\");\n            SecretKeySpec keySpec = new SecretKeySpec(secretKey.getBytes(), \"HmacSHA1\");\n            mac.init(keySpec);\n            mac.update(unsignedRequest.getBytes());\n            byte[] encryptedBytes = mac.doFinal();\n            String computedSignature = Base64.encodeBase64String(encryptedBytes);\n            boolean equalSig = ConstantTimeComparator.compareStrings(signature, computedSignature);\n            if (!equalSig) {\n                s_logger.debug(\"User signature: \" + signature + \" is not equaled to computed signature: \" + computedSignature);\n            }\n\n            if (equalSig) {\n                requestParameters.put(\"userid\", new Object[] {String.valueOf(user.getId())});\n                requestParameters.put(\"account\", new Object[] {account.getAccountName()});\n                requestParameters.put(\"accountobj\", new Object[] {account});\n            }\n            return equalSig;\n        } catch (Exception ex) {\n            s_logger.error(\"unable to verifty request signature\", ex);\n        }\n        return false;\n    }\n","date":"2018-01-20 05:49:27","endLine":680,"groupId":"101435","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"verifyRequest","params":"(Map<String@Object[]>requestParameters)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/cc/788c7b118383cb78ed4f1aa17672dba0eff3c5.src","preCode":"    private boolean verifyRequest(Map<String, Object[]> requestParameters) {\n        try {\n            String apiKey = null;\n            String secretKey = null;\n            String signature = null;\n            String unsignedRequest = null;\n\n            \r\n            \r\n            List<String> parameterNames = new ArrayList<String>();\n\n            for (Object paramNameObj : requestParameters.keySet()) {\n                parameterNames.add((String)paramNameObj); \r\n            }\n\n            Collections.sort(parameterNames);\n\n            for (String paramName : parameterNames) {\n                \r\n                String paramValue = ((String[])requestParameters.get(paramName))[0];\n\n                if (\"signature\".equalsIgnoreCase(paramName)) {\n                    signature = paramValue;\n                } else {\n                    if (\"apikey\".equalsIgnoreCase(paramName)) {\n                        apiKey = paramValue;\n                    }\n\n                    if (unsignedRequest == null) {\n                        unsignedRequest = paramName + \"=\" + URLEncoder.encode(paramValue, \"UTF-8\").replaceAll(\"\\\\+\", \"%20\");\n                    } else {\n                        unsignedRequest = unsignedRequest + \"&\" + paramName + \"=\" + URLEncoder.encode(paramValue, \"UTF-8\").replaceAll(\"\\\\+\", \"%20\");\n                    }\n                }\n            }\n\n            \r\n            if ((signature == null) || (apiKey == null)) {\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"expired session, missing signature, or missing apiKey -- ignoring request...sig: \" + signature + \", apiKey: \" + apiKey);\n                }\n                return false; \r\n            }\n\n            TransactionLegacy txn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\n            txn.close();\n            User user = null;\n            \r\n            Pair<User, Account> userAcctPair = _accountMgr.findUserByApiKey(apiKey);\n            if (userAcctPair == null) {\n                s_logger.debug(\"apiKey does not map to a valid user -- ignoring request, apiKey: \" + apiKey);\n                return false;\n            }\n\n            user = userAcctPair.first();\n            Account account = userAcctPair.second();\n\n            if (!user.getState().equals(Account.State.enabled) || !account.getState().equals(Account.State.enabled)) {\n                s_logger.debug(\"disabled or locked user accessing the api, userid = \" + user.getId() + \"; name = \" + user.getUsername() + \"; state: \" + user.getState() +\n                    \"; accountState: \" + account.getState());\n                return false;\n            }\n\n            \r\n            secretKey = user.getSecretKey();\n            if (secretKey == null) {\n                s_logger.debug(\"User does not have a secret key associated with the account -- ignoring request, username: \" + user.getUsername());\n                return false;\n            }\n\n            unsignedRequest = unsignedRequest.toLowerCase();\n\n            Mac mac = Mac.getInstance(\"HmacSHA1\");\n            SecretKeySpec keySpec = new SecretKeySpec(secretKey.getBytes(), \"HmacSHA1\");\n            mac.init(keySpec);\n            mac.update(unsignedRequest.getBytes());\n            byte[] encryptedBytes = mac.doFinal();\n            String computedSignature = Base64.encodeBase64String(encryptedBytes);\n            boolean equalSig = ConstantTimeComparator.compareStrings(signature, computedSignature);\n            if (!equalSig) {\n                s_logger.debug(\"User signature: \" + signature + \" is not equaled to computed signature: \" + computedSignature);\n            }\n\n            if (equalSig) {\n                requestParameters.put(\"userid\", new Object[] {String.valueOf(user.getId())});\n                requestParameters.put(\"account\", new Object[] {account.getAccountName()});\n                requestParameters.put(\"accountobj\", new Object[] {account});\n            }\n            return equalSig;\n        } catch (Exception ex) {\n            s_logger.error(\"unable to verifty request signature\", ex);\n        }\n        return false;\n    }\n","realPath":"server/src/main/java/com/cloud/servlet/ConsoleProxyServlet.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":587,"status":"N"}],"commitId":"4fa7fadd210bd93fdc92f58a44729139b3f4a659","commitMessage":"@@@Merge release branch 4.13 to master\n\n* 4.13:\n  break session only on illegal origin (#3715)\n","date":"2019-12-24 17:24:09","modifiedFileCount":"2","status":"M","submitter":"Daan Hoogland"}]
