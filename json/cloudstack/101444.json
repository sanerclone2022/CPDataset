[{"authorTime":"2018-01-20 05:49:27","codes":[{"authorDate":"2018-01-20 05:49:27","commitOrder":1,"curCode":"    private boolean isForSystemVms(long vlanId){\n        SearchBuilder<IPAddressVO> sb = userIpAddressDao.createSearchBuilder();\n        sb.and(\"vlanId\", sb.entity().getVlanId(), SearchCriteria.Op.EQ);\n        SearchCriteria<IPAddressVO> sc = sb.create();\n        sc.setParameters(\"vlanId\", vlanId);\n        IPAddressVO userIpAddresVO = userIpAddressDao.findOneBy(sc);\n        return userIpAddresVO.isForSystemVms();\n    }\n","date":"2018-01-20 05:49:27","endLine":773,"groupId":"25198","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"isForSystemVms","params":"(longvlanId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/88/da6342b81c2d0bce453fe1373aa836d5b6a569.src","preCode":"    private boolean isForSystemVms(long vlanId){\n        SearchBuilder<IPAddressVO> sb = userIpAddressDao.createSearchBuilder();\n        sb.and(\"vlanId\", sb.entity().getVlanId(), SearchCriteria.Op.EQ);\n        SearchCriteria<IPAddressVO> sc = sb.create();\n        sc.setParameters(\"vlanId\", vlanId);\n        IPAddressVO userIpAddresVO = userIpAddressDao.findOneBy(sc);\n        return userIpAddresVO.isForSystemVms();\n    }\n","realPath":"server/src/main/java/com/cloud/api/ApiResponseHelper.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":766,"status":"B"},{"authorDate":"2018-01-20 05:49:27","commitOrder":1,"curCode":"    public boolean deleteVlanAndPublicIpRange(final long userId, final long vlanDbId, final Account caller) {\n        VlanVO vlanRange = _vlanDao.findById(vlanDbId);\n        if (vlanRange == null) {\n            throw new InvalidParameterValueException(\"Please specify a valid IP range id.\");\n        }\n\n        boolean isAccountSpecific = false;\n        final List<AccountVlanMapVO> acctVln = _accountVlanMapDao.listAccountVlanMapsByVlan(vlanRange.getId());\n        \r\n        \r\n        if (acctVln != null && !acctVln.isEmpty()) {\n            isAccountSpecific = true;\n        }\n\n        boolean isDomainSpecific = false;\n        List<DomainVlanMapVO> domainVln = _domainVlanMapDao.listDomainVlanMapsByVlan(vlanRange.getId());\n        \r\n        if (domainVln != null && !domainVln.isEmpty()) {\n            isDomainSpecific = true;\n        }\n\n        \r\n        final List<IPAddressVO> ips = _publicIpAddressDao.listByVlanId(vlanDbId);\n        if (isAccountSpecific) {\n            int resourceCountToBeDecrement = 0;\n            try {\n                vlanRange = _vlanDao.acquireInLockTable(vlanDbId, 30);\n                if (vlanRange == null) {\n                    throw new CloudRuntimeException(\"Unable to acquire vlan configuration: \" + vlanDbId);\n                }\n\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"lock vlan \" + vlanDbId + \" is acquired\");\n                }\n                for (final IPAddressVO ip : ips) {\n                    boolean success = true;\n                    if (ip.isOneToOneNat()) {\n                        throw new InvalidParameterValueException(\"Can't delete account specific vlan \" + vlanDbId + \" as ip \" + ip\n                                + \" belonging to the range is used for static nat purposes. Cleanup the rules first\");\n                    }\n\n                    if (ip.isSourceNat()) {\n                        throw new InvalidParameterValueException(\"Can't delete account specific vlan \" + vlanDbId + \" as ip \" + ip\n                                + \" belonging to the range is a source nat ip for the network id=\" + ip.getSourceNetworkId()\n                                + \". IP range with the source nat ip address can be removed either as a part of Network, or account removal\");\n                    }\n\n                    if (_firewallDao.countRulesByIpId(ip.getId()) > 0) {\n                        throw new InvalidParameterValueException(\"Can't delete account specific vlan \" + vlanDbId + \" as ip \" + ip\n                                + \" belonging to the range has firewall rules applied. Cleanup the rules first\");\n                    }\n                    if (ip.getAllocatedTime() != null) {\r\n                        \r\n                        success = _ipAddrMgr.disassociatePublicIpAddress(ip.getId(), userId, caller);\n                    }\n                    if (!success) {\n                        s_logger.warn(\"Some ip addresses failed to be released as a part of vlan \" + vlanDbId + \" removal\");\n                    } else {\n                        resourceCountToBeDecrement++;\n                        UsageEventUtils.publishUsageEvent(EventTypes.EVENT_NET_IP_RELEASE, acctVln.get(0).getAccountId(), ip.getDataCenterId(), ip.getId(),\n                                ip.getAddress().toString(), ip.isSourceNat(), vlanRange.getVlanType().toString(), ip.getSystem(), ip.getClass().getName(), ip.getUuid());\n                    }\n                }\n            } finally {\n                _vlanDao.releaseFromLockTable(vlanDbId);\n                if (resourceCountToBeDecrement > 0) {  \r\n                    _resourceLimitMgr.decrementResourceCount(acctVln.get(0).getAccountId(), ResourceType.public_ip, new Long(resourceCountToBeDecrement));\n                }\n            }\n        } else {   \r\n            final NicIpAliasVO ipAlias = _nicIpAliasDao.findByGatewayAndNetworkIdAndState(vlanRange.getVlanGateway(), vlanRange.getNetworkId(), NicIpAlias.State.active);\n            \r\n            if (ipAlias != null && vlanDbId == _publicIpAddressDao.findByIpAndSourceNetworkId(vlanRange.getNetworkId(), ipAlias.getIp4Address()).getVlanId()) {\n                throw new InvalidParameterValueException(\"Cannot delete vlan range \" + vlanDbId + \" as \" + ipAlias.getIp4Address()\n                        + \"is being used for providing dhcp service in this subnet. Delete all VMs in this subnet and try again\");\n            }\n            final long allocIpCount = _publicIpAddressDao.countIPs(vlanRange.getDataCenterId(), vlanDbId, true);\n            if (allocIpCount > 0) {\n                throw new InvalidParameterValueException(allocIpCount + \"  Ips are in use. Cannot delete this vlan\");\n            }\n        }\n\n        Transaction.execute(new TransactionCallbackNoReturn() {\n            @Override\n            public void doInTransactionWithoutResult(final TransactionStatus status) {\n                _publicIpAddressDao.deletePublicIPRange(vlanDbId);\n                _vlanDao.remove(vlanDbId);\n            }\n        });\n\n        return true;\n    }\n","date":"2018-01-20 05:49:27","endLine":3675,"groupId":"25198","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteVlanAndPublicIpRange","params":"(finallonguserId@finallongvlanDbId@finalAccountcaller)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/16/32da95f95466df841e198f84f058240ae8968b.src","preCode":"    public boolean deleteVlanAndPublicIpRange(final long userId, final long vlanDbId, final Account caller) {\n        VlanVO vlanRange = _vlanDao.findById(vlanDbId);\n        if (vlanRange == null) {\n            throw new InvalidParameterValueException(\"Please specify a valid IP range id.\");\n        }\n\n        boolean isAccountSpecific = false;\n        final List<AccountVlanMapVO> acctVln = _accountVlanMapDao.listAccountVlanMapsByVlan(vlanRange.getId());\n        \r\n        \r\n        if (acctVln != null && !acctVln.isEmpty()) {\n            isAccountSpecific = true;\n        }\n\n        boolean isDomainSpecific = false;\n        List<DomainVlanMapVO> domainVln = _domainVlanMapDao.listDomainVlanMapsByVlan(vlanRange.getId());\n        \r\n        if (domainVln != null && !domainVln.isEmpty()) {\n            isDomainSpecific = true;\n        }\n\n        \r\n        final List<IPAddressVO> ips = _publicIpAddressDao.listByVlanId(vlanDbId);\n        if (isAccountSpecific) {\n            int resourceCountToBeDecrement = 0;\n            try {\n                vlanRange = _vlanDao.acquireInLockTable(vlanDbId, 30);\n                if (vlanRange == null) {\n                    throw new CloudRuntimeException(\"Unable to acquire vlan configuration: \" + vlanDbId);\n                }\n\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"lock vlan \" + vlanDbId + \" is acquired\");\n                }\n                for (final IPAddressVO ip : ips) {\n                    boolean success = true;\n                    if (ip.isOneToOneNat()) {\n                        throw new InvalidParameterValueException(\"Can't delete account specific vlan \" + vlanDbId + \" as ip \" + ip\n                                + \" belonging to the range is used for static nat purposes. Cleanup the rules first\");\n                    }\n\n                    if (ip.isSourceNat()) {\n                        throw new InvalidParameterValueException(\"Can't delete account specific vlan \" + vlanDbId + \" as ip \" + ip\n                                + \" belonging to the range is a source nat ip for the network id=\" + ip.getSourceNetworkId()\n                                + \". IP range with the source nat ip address can be removed either as a part of Network, or account removal\");\n                    }\n\n                    if (_firewallDao.countRulesByIpId(ip.getId()) > 0) {\n                        throw new InvalidParameterValueException(\"Can't delete account specific vlan \" + vlanDbId + \" as ip \" + ip\n                                + \" belonging to the range has firewall rules applied. Cleanup the rules first\");\n                    }\n                    if (ip.getAllocatedTime() != null) {\r\n                        \r\n                        success = _ipAddrMgr.disassociatePublicIpAddress(ip.getId(), userId, caller);\n                    }\n                    if (!success) {\n                        s_logger.warn(\"Some ip addresses failed to be released as a part of vlan \" + vlanDbId + \" removal\");\n                    } else {\n                        resourceCountToBeDecrement++;\n                        UsageEventUtils.publishUsageEvent(EventTypes.EVENT_NET_IP_RELEASE, acctVln.get(0).getAccountId(), ip.getDataCenterId(), ip.getId(),\n                                ip.getAddress().toString(), ip.isSourceNat(), vlanRange.getVlanType().toString(), ip.getSystem(), ip.getClass().getName(), ip.getUuid());\n                    }\n                }\n            } finally {\n                _vlanDao.releaseFromLockTable(vlanDbId);\n                if (resourceCountToBeDecrement > 0) {  \r\n                    _resourceLimitMgr.decrementResourceCount(acctVln.get(0).getAccountId(), ResourceType.public_ip, new Long(resourceCountToBeDecrement));\n                }\n            }\n        } else {   \r\n            final NicIpAliasVO ipAlias = _nicIpAliasDao.findByGatewayAndNetworkIdAndState(vlanRange.getVlanGateway(), vlanRange.getNetworkId(), NicIpAlias.State.active);\n            \r\n            if (ipAlias != null && vlanDbId == _publicIpAddressDao.findByIpAndSourceNetworkId(vlanRange.getNetworkId(), ipAlias.getIp4Address()).getVlanId()) {\n                throw new InvalidParameterValueException(\"Cannot delete vlan range \" + vlanDbId + \" as \" + ipAlias.getIp4Address()\n                        + \"is being used for providing dhcp service in this subnet. Delete all VMs in this subnet and try again\");\n            }\n            final long allocIpCount = _publicIpAddressDao.countIPs(vlanRange.getDataCenterId(), vlanDbId, true);\n            if (allocIpCount > 0) {\n                throw new InvalidParameterValueException(allocIpCount + \"  Ips are in use. Cannot delete this vlan\");\n            }\n        }\n\n        Transaction.execute(new TransactionCallbackNoReturn() {\n            @Override\n            public void doInTransactionWithoutResult(final TransactionStatus status) {\n                _publicIpAddressDao.deletePublicIPRange(vlanDbId);\n                _vlanDao.remove(vlanDbId);\n            }\n        });\n\n        return true;\n    }\n","realPath":"server/src/main/java/com/cloud/configuration/ConfigurationManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":3584,"status":"B"}],"commitId":"893a88d225276e45f12f9490e6af2c94a81c2965","commitMessage":"@@@CLOUDSTACK-10105: Use maven standard project structure in all projects (#2283)\n\nRemove maven standard module (which only a few were using) and get ride of maven customization for the projects structure.\n\n- moved all directories to src/main/java.  src/main/resources.  src/main/scripts.  src/test/java.  src/test/resources\n- grep scan to search for src/com and src/org left over\n- grep for <project>/scripts to fix pom.xml configuration\n- remove custom <build> configuration in pom.xml\n\nSigned-off-by: Marc-Aur?le Brothier <m@brothier.org>","date":"2018-01-20 05:49:27","modifiedFileCount":"1","status":"B","submitter":"Marc-Aur?le Brothier"},{"authorTime":"2019-05-31 15:02:11","codes":[{"authorDate":"2018-01-20 05:49:27","commitOrder":2,"curCode":"    private boolean isForSystemVms(long vlanId){\n        SearchBuilder<IPAddressVO> sb = userIpAddressDao.createSearchBuilder();\n        sb.and(\"vlanId\", sb.entity().getVlanId(), SearchCriteria.Op.EQ);\n        SearchCriteria<IPAddressVO> sc = sb.create();\n        sc.setParameters(\"vlanId\", vlanId);\n        IPAddressVO userIpAddresVO = userIpAddressDao.findOneBy(sc);\n        return userIpAddresVO.isForSystemVms();\n    }\n","date":"2018-01-20 05:49:27","endLine":773,"groupId":"25198","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"isForSystemVms","params":"(longvlanId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/88/da6342b81c2d0bce453fe1373aa836d5b6a569.src","preCode":"    private boolean isForSystemVms(long vlanId){\n        SearchBuilder<IPAddressVO> sb = userIpAddressDao.createSearchBuilder();\n        sb.and(\"vlanId\", sb.entity().getVlanId(), SearchCriteria.Op.EQ);\n        SearchCriteria<IPAddressVO> sc = sb.create();\n        sc.setParameters(\"vlanId\", vlanId);\n        IPAddressVO userIpAddresVO = userIpAddressDao.findOneBy(sc);\n        return userIpAddresVO.isForSystemVms();\n    }\n","realPath":"server/src/main/java/com/cloud/api/ApiResponseHelper.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":766,"status":"N"},{"authorDate":"2019-05-31 15:02:11","commitOrder":2,"curCode":"    public boolean deleteVlanAndPublicIpRange(final long userId, final long vlanDbId, final Account caller) {\n        VlanVO vlanRange = _vlanDao.findById(vlanDbId);\n        if (vlanRange == null) {\n            throw new InvalidParameterValueException(\"Please specify a valid IP range id.\");\n        }\n\n        boolean isAccountSpecific = false;\n        final List<AccountVlanMapVO> acctVln = _accountVlanMapDao.listAccountVlanMapsByVlan(vlanRange.getId());\n        \r\n        \r\n        if (acctVln != null && !acctVln.isEmpty()) {\n            isAccountSpecific = true;\n        }\n\n        boolean isDomainSpecific = false;\n        List<DomainVlanMapVO> domainVlan = _domainVlanMapDao.listDomainVlanMapsByVlan(vlanRange.getId());\n        \r\n        if (domainVlan != null && !domainVlan.isEmpty()) {\n            isDomainSpecific = true;\n        }\n\n        \r\n        final List<IPAddressVO> ips = _publicIpAddressDao.listByVlanId(vlanDbId);\n        if (isAccountSpecific) {\n            int resourceCountToBeDecrement = 0;\n            try {\n                vlanRange = _vlanDao.acquireInLockTable(vlanDbId, 30);\n                if (vlanRange == null) {\n                    throw new CloudRuntimeException(\"Unable to acquire vlan configuration: \" + vlanDbId);\n                }\n\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"lock vlan \" + vlanDbId + \" is acquired\");\n                }\n                for (final IPAddressVO ip : ips) {\n                    boolean success = true;\n                    if (ip.isOneToOneNat()) {\n                        throw new InvalidParameterValueException(\"Can't delete account specific vlan \" + vlanDbId + \" as ip \" + ip\n                                + \" belonging to the range is used for static nat purposes. Cleanup the rules first\");\n                    }\n\n                    if (ip.isSourceNat()) {\n                        throw new InvalidParameterValueException(\"Can't delete account specific vlan \" + vlanDbId + \" as ip \" + ip\n                                + \" belonging to the range is a source nat ip for the network id=\" + ip.getSourceNetworkId()\n                                + \". IP range with the source nat ip address can be removed either as a part of Network, or account removal\");\n                    }\n\n                    if (_firewallDao.countRulesByIpId(ip.getId()) > 0) {\n                        throw new InvalidParameterValueException(\"Can't delete account specific vlan \" + vlanDbId + \" as ip \" + ip\n                                + \" belonging to the range has firewall rules applied. Cleanup the rules first\");\n                    }\n                    if (ip.getAllocatedTime() != null) {\r\n                        \r\n                        success = _ipAddrMgr.disassociatePublicIpAddress(ip.getId(), userId, caller);\n                    }\n                    if (!success) {\n                        s_logger.warn(\"Some ip addresses failed to be released as a part of vlan \" + vlanDbId + \" removal\");\n                    } else {\n                        resourceCountToBeDecrement++;\n                        UsageEventUtils.publishUsageEvent(EventTypes.EVENT_NET_IP_RELEASE, acctVln.get(0).getAccountId(), ip.getDataCenterId(), ip.getId(),\n                                ip.getAddress().toString(), ip.isSourceNat(), vlanRange.getVlanType().toString(), ip.getSystem(), ip.getClass().getName(), ip.getUuid());\n                    }\n                }\n            } finally {\n                _vlanDao.releaseFromLockTable(vlanDbId);\n                if (resourceCountToBeDecrement > 0) {  \r\n                    _resourceLimitMgr.decrementResourceCount(acctVln.get(0).getAccountId(), ResourceType.public_ip, new Long(resourceCountToBeDecrement));\n                }\n            }\n        } else {   \r\n            final NicIpAliasVO ipAlias = _nicIpAliasDao.findByGatewayAndNetworkIdAndState(vlanRange.getVlanGateway(), vlanRange.getNetworkId(), NicIpAlias.State.active);\n            \r\n            if (ipAlias != null && vlanDbId == _publicIpAddressDao.findByIpAndSourceNetworkId(vlanRange.getNetworkId(), ipAlias.getIp4Address()).getVlanId()) {\n                throw new InvalidParameterValueException(\"Cannot delete vlan range \" + vlanDbId + \" as \" + ipAlias.getIp4Address()\n                        + \"is being used for providing dhcp service in this subnet. Delete all VMs in this subnet and try again\");\n            }\n            final long allocIpCount = _publicIpAddressDao.countIPs(vlanRange.getDataCenterId(), vlanDbId, true);\n            if (allocIpCount > 0) {\n                throw new InvalidParameterValueException(allocIpCount + \"  Ips are in use. Cannot delete this vlan\");\n            }\n        }\n\n        Transaction.execute(new TransactionCallbackNoReturn() {\n            @Override\n            public void doInTransactionWithoutResult(final TransactionStatus status) {\n                _publicIpAddressDao.deletePublicIPRange(vlanDbId);\n                _vlanDao.remove(vlanDbId);\n            }\n        });\n\n        return true;\n    }\n","date":"2019-05-31 15:02:11","endLine":3777,"groupId":"25198","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteVlanAndPublicIpRange","params":"(finallonguserId@finallongvlanDbId@finalAccountcaller)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/88/b2aed9786bf1019fba3327446c55c48d6be01f.src","preCode":"    public boolean deleteVlanAndPublicIpRange(final long userId, final long vlanDbId, final Account caller) {\n        VlanVO vlanRange = _vlanDao.findById(vlanDbId);\n        if (vlanRange == null) {\n            throw new InvalidParameterValueException(\"Please specify a valid IP range id.\");\n        }\n\n        boolean isAccountSpecific = false;\n        final List<AccountVlanMapVO> acctVln = _accountVlanMapDao.listAccountVlanMapsByVlan(vlanRange.getId());\n        \r\n        \r\n        if (acctVln != null && !acctVln.isEmpty()) {\n            isAccountSpecific = true;\n        }\n\n        boolean isDomainSpecific = false;\n        List<DomainVlanMapVO> domainVln = _domainVlanMapDao.listDomainVlanMapsByVlan(vlanRange.getId());\n        \r\n        if (domainVln != null && !domainVln.isEmpty()) {\n            isDomainSpecific = true;\n        }\n\n        \r\n        final List<IPAddressVO> ips = _publicIpAddressDao.listByVlanId(vlanDbId);\n        if (isAccountSpecific) {\n            int resourceCountToBeDecrement = 0;\n            try {\n                vlanRange = _vlanDao.acquireInLockTable(vlanDbId, 30);\n                if (vlanRange == null) {\n                    throw new CloudRuntimeException(\"Unable to acquire vlan configuration: \" + vlanDbId);\n                }\n\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"lock vlan \" + vlanDbId + \" is acquired\");\n                }\n                for (final IPAddressVO ip : ips) {\n                    boolean success = true;\n                    if (ip.isOneToOneNat()) {\n                        throw new InvalidParameterValueException(\"Can't delete account specific vlan \" + vlanDbId + \" as ip \" + ip\n                                + \" belonging to the range is used for static nat purposes. Cleanup the rules first\");\n                    }\n\n                    if (ip.isSourceNat()) {\n                        throw new InvalidParameterValueException(\"Can't delete account specific vlan \" + vlanDbId + \" as ip \" + ip\n                                + \" belonging to the range is a source nat ip for the network id=\" + ip.getSourceNetworkId()\n                                + \". IP range with the source nat ip address can be removed either as a part of Network, or account removal\");\n                    }\n\n                    if (_firewallDao.countRulesByIpId(ip.getId()) > 0) {\n                        throw new InvalidParameterValueException(\"Can't delete account specific vlan \" + vlanDbId + \" as ip \" + ip\n                                + \" belonging to the range has firewall rules applied. Cleanup the rules first\");\n                    }\n                    if (ip.getAllocatedTime() != null) {\r\n                        \r\n                        success = _ipAddrMgr.disassociatePublicIpAddress(ip.getId(), userId, caller);\n                    }\n                    if (!success) {\n                        s_logger.warn(\"Some ip addresses failed to be released as a part of vlan \" + vlanDbId + \" removal\");\n                    } else {\n                        resourceCountToBeDecrement++;\n                        UsageEventUtils.publishUsageEvent(EventTypes.EVENT_NET_IP_RELEASE, acctVln.get(0).getAccountId(), ip.getDataCenterId(), ip.getId(),\n                                ip.getAddress().toString(), ip.isSourceNat(), vlanRange.getVlanType().toString(), ip.getSystem(), ip.getClass().getName(), ip.getUuid());\n                    }\n                }\n            } finally {\n                _vlanDao.releaseFromLockTable(vlanDbId);\n                if (resourceCountToBeDecrement > 0) {  \r\n                    _resourceLimitMgr.decrementResourceCount(acctVln.get(0).getAccountId(), ResourceType.public_ip, new Long(resourceCountToBeDecrement));\n                }\n            }\n        } else {   \r\n            final NicIpAliasVO ipAlias = _nicIpAliasDao.findByGatewayAndNetworkIdAndState(vlanRange.getVlanGateway(), vlanRange.getNetworkId(), NicIpAlias.State.active);\n            \r\n            if (ipAlias != null && vlanDbId == _publicIpAddressDao.findByIpAndSourceNetworkId(vlanRange.getNetworkId(), ipAlias.getIp4Address()).getVlanId()) {\n                throw new InvalidParameterValueException(\"Cannot delete vlan range \" + vlanDbId + \" as \" + ipAlias.getIp4Address()\n                        + \"is being used for providing dhcp service in this subnet. Delete all VMs in this subnet and try again\");\n            }\n            final long allocIpCount = _publicIpAddressDao.countIPs(vlanRange.getDataCenterId(), vlanDbId, true);\n            if (allocIpCount > 0) {\n                throw new InvalidParameterValueException(allocIpCount + \"  Ips are in use. Cannot delete this vlan\");\n            }\n        }\n\n        Transaction.execute(new TransactionCallbackNoReturn() {\n            @Override\n            public void doInTransactionWithoutResult(final TransactionStatus status) {\n                _publicIpAddressDao.deletePublicIPRange(vlanDbId);\n                _vlanDao.remove(vlanDbId);\n            }\n        });\n\n        return true;\n    }\n","realPath":"server/src/main/java/com/cloud/configuration/ConfigurationManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":3686,"status":"M"}],"commitId":"4ba67b4c59c152dc297d45ffd367e9c5a00593d2","commitMessage":"@@@Merge remote-tracking branch 'origin/4.12'\n","date":"2019-05-31 15:02:11","modifiedFileCount":"3","status":"M","submitter":"Rohit Yadav"},{"authorTime":"2019-08-15 16:05:58","codes":[{"authorDate":"2018-01-20 05:49:27","commitOrder":3,"curCode":"    private boolean isForSystemVms(long vlanId){\n        SearchBuilder<IPAddressVO> sb = userIpAddressDao.createSearchBuilder();\n        sb.and(\"vlanId\", sb.entity().getVlanId(), SearchCriteria.Op.EQ);\n        SearchCriteria<IPAddressVO> sc = sb.create();\n        sc.setParameters(\"vlanId\", vlanId);\n        IPAddressVO userIpAddresVO = userIpAddressDao.findOneBy(sc);\n        return userIpAddresVO.isForSystemVms();\n    }\n","date":"2018-01-20 05:49:27","endLine":773,"groupId":"25198","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"isForSystemVms","params":"(longvlanId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/88/da6342b81c2d0bce453fe1373aa836d5b6a569.src","preCode":"    private boolean isForSystemVms(long vlanId){\n        SearchBuilder<IPAddressVO> sb = userIpAddressDao.createSearchBuilder();\n        sb.and(\"vlanId\", sb.entity().getVlanId(), SearchCriteria.Op.EQ);\n        SearchCriteria<IPAddressVO> sc = sb.create();\n        sc.setParameters(\"vlanId\", vlanId);\n        IPAddressVO userIpAddresVO = userIpAddressDao.findOneBy(sc);\n        return userIpAddresVO.isForSystemVms();\n    }\n","realPath":"server/src/main/java/com/cloud/api/ApiResponseHelper.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":766,"status":"N"},{"authorDate":"2019-08-15 16:05:58","commitOrder":3,"curCode":"    public boolean deleteVlanAndPublicIpRange(final long userId, final long vlanDbId, final Account caller) {\n        VlanVO vlanRange = _vlanDao.findById(vlanDbId);\n        if (vlanRange == null) {\n            throw new InvalidParameterValueException(\"Please specify a valid IP range id.\");\n        }\n\n        boolean isAccountSpecific = false;\n        final List<AccountVlanMapVO> acctVln = _accountVlanMapDao.listAccountVlanMapsByVlan(vlanRange.getId());\n        \r\n        \r\n        if (acctVln != null && !acctVln.isEmpty()) {\n            isAccountSpecific = true;\n        }\n\n        boolean isDomainSpecific = false;\n        List<DomainVlanMapVO> domainVlan = _domainVlanMapDao.listDomainVlanMapsByVlan(vlanRange.getId());\n        \r\n        if (domainVlan != null && !domainVlan.isEmpty()) {\n            isDomainSpecific = true;\n        }\n\n        \r\n        final List<IPAddressVO> ips = _publicIpAddressDao.listByVlanId(vlanDbId);\n        if (isAccountSpecific) {\n            int resourceCountToBeDecrement = 0;\n            try {\n                vlanRange = _vlanDao.acquireInLockTable(vlanDbId, 30);\n                if (vlanRange == null) {\n                    throw new CloudRuntimeException(\"Unable to acquire vlan configuration: \" + vlanDbId);\n                }\n\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"lock vlan \" + vlanDbId + \" is acquired\");\n                }\n                for (final IPAddressVO ip : ips) {\n                    boolean success = true;\n                    if (ip.isOneToOneNat()) {\n                        throw new InvalidParameterValueException(\"Can't delete account specific vlan \" + vlanDbId + \" as ip \" + ip\n                                + \" belonging to the range is used for static nat purposes. Cleanup the rules first\");\n                    }\n\n                    if (ip.isSourceNat()) {\n                        throw new InvalidParameterValueException(\"Can't delete account specific vlan \" + vlanDbId + \" as ip \" + ip\n                                + \" belonging to the range is a source nat ip for the network id=\" + ip.getSourceNetworkId()\n                                + \". IP range with the source nat ip address can be removed either as a part of Network, or account removal\");\n                    }\n\n                    if (_firewallDao.countRulesByIpId(ip.getId()) > 0) {\n                        throw new InvalidParameterValueException(\"Can't delete account specific vlan \" + vlanDbId + \" as ip \" + ip\n                                + \" belonging to the range has firewall rules applied. Cleanup the rules first\");\n                    }\n                    if (ip.getAllocatedTime() != null) {\r\n                        \r\n                        success = _ipAddrMgr.disassociatePublicIpAddress(ip.getId(), userId, caller);\n                    }\n                    if (!success) {\n                        s_logger.warn(\"Some ip addresses failed to be released as a part of vlan \" + vlanDbId + \" removal\");\n                    } else {\n                        resourceCountToBeDecrement++;\n                        UsageEventUtils.publishUsageEvent(EventTypes.EVENT_NET_IP_RELEASE, acctVln.get(0).getAccountId(), ip.getDataCenterId(), ip.getId(),\n                                ip.getAddress().toString(), ip.isSourceNat(), vlanRange.getVlanType().toString(), ip.getSystem(), ip.getClass().getName(), ip.getUuid());\n                    }\n                }\n            } finally {\n                _vlanDao.releaseFromLockTable(vlanDbId);\n                if (resourceCountToBeDecrement > 0) {  \r\n                    _resourceLimitMgr.decrementResourceCount(acctVln.get(0).getAccountId(), ResourceType.public_ip, new Long(resourceCountToBeDecrement));\n                }\n            }\n        } else {   \r\n            final NicIpAliasVO ipAlias = _nicIpAliasDao.findByGatewayAndNetworkIdAndState(vlanRange.getVlanGateway(), vlanRange.getNetworkId(), NicIpAlias.State.active);\n            \r\n            if (ipAlias != null && vlanDbId == _publicIpAddressDao.findByIpAndSourceNetworkId(vlanRange.getNetworkId(), ipAlias.getIp4Address()).getVlanId()) {\n                throw new InvalidParameterValueException(\"Cannot delete vlan range \" + vlanDbId + \" as \" + ipAlias.getIp4Address()\n                        + \"is being used for providing dhcp service in this subnet. Delete all VMs in this subnet and try again\");\n            }\n            final long allocIpCount = _publicIpAddressDao.countIPs(vlanRange.getDataCenterId(), vlanDbId, true);\n            if (allocIpCount > 0) {\n                throw new InvalidParameterValueException(allocIpCount + \"  Ips are in use. Cannot delete this vlan\");\n            }\n        }\n\n        Transaction.execute(new TransactionCallbackNoReturn() {\n            @Override\n            public void doInTransactionWithoutResult(final TransactionStatus status) {\n                _publicIpAddressDao.deletePublicIPRange(vlanDbId);\n                s_logger.debug(String.format(\"Delete Public IP Range (from user_ip_address, where vlan_db_d=%s)\", vlanDbId));\n\n                _vlanDao.remove(vlanDbId);\n                s_logger.debug(String.format(\"Mark vlan as Remove vlan (vlan_db_id=%s)\", vlanDbId));\n\n                SearchBuilder<PodVlanMapVO> sb = podVlanMapDao.createSearchBuilder();\n                sb.and(\"vlan_db_id\", sb.entity().getVlanDbId(), SearchCriteria.Op.EQ);\n                SearchCriteria<PodVlanMapVO> sc = sb.create();\n                sc.setParameters(\"vlan_db_id\", vlanDbId);\n                podVlanMapDao.remove(sc);\n                s_logger.debug(String.format(\"Delete vlan_db_id=%s in pod_vlan_map\", vlanDbId));\n            }\n        });\n\n        return true;\n    }\n","date":"2019-08-15 16:05:58","endLine":4064,"groupId":"25198","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteVlanAndPublicIpRange","params":"(finallonguserId@finallongvlanDbId@finalAccountcaller)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/61/f828b0c31c146092d0091f3047837fb6218307.src","preCode":"    public boolean deleteVlanAndPublicIpRange(final long userId, final long vlanDbId, final Account caller) {\n        VlanVO vlanRange = _vlanDao.findById(vlanDbId);\n        if (vlanRange == null) {\n            throw new InvalidParameterValueException(\"Please specify a valid IP range id.\");\n        }\n\n        boolean isAccountSpecific = false;\n        final List<AccountVlanMapVO> acctVln = _accountVlanMapDao.listAccountVlanMapsByVlan(vlanRange.getId());\n        \r\n        \r\n        if (acctVln != null && !acctVln.isEmpty()) {\n            isAccountSpecific = true;\n        }\n\n        boolean isDomainSpecific = false;\n        List<DomainVlanMapVO> domainVlan = _domainVlanMapDao.listDomainVlanMapsByVlan(vlanRange.getId());\n        \r\n        if (domainVlan != null && !domainVlan.isEmpty()) {\n            isDomainSpecific = true;\n        }\n\n        \r\n        final List<IPAddressVO> ips = _publicIpAddressDao.listByVlanId(vlanDbId);\n        if (isAccountSpecific) {\n            int resourceCountToBeDecrement = 0;\n            try {\n                vlanRange = _vlanDao.acquireInLockTable(vlanDbId, 30);\n                if (vlanRange == null) {\n                    throw new CloudRuntimeException(\"Unable to acquire vlan configuration: \" + vlanDbId);\n                }\n\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"lock vlan \" + vlanDbId + \" is acquired\");\n                }\n                for (final IPAddressVO ip : ips) {\n                    boolean success = true;\n                    if (ip.isOneToOneNat()) {\n                        throw new InvalidParameterValueException(\"Can't delete account specific vlan \" + vlanDbId + \" as ip \" + ip\n                                + \" belonging to the range is used for static nat purposes. Cleanup the rules first\");\n                    }\n\n                    if (ip.isSourceNat()) {\n                        throw new InvalidParameterValueException(\"Can't delete account specific vlan \" + vlanDbId + \" as ip \" + ip\n                                + \" belonging to the range is a source nat ip for the network id=\" + ip.getSourceNetworkId()\n                                + \". IP range with the source nat ip address can be removed either as a part of Network, or account removal\");\n                    }\n\n                    if (_firewallDao.countRulesByIpId(ip.getId()) > 0) {\n                        throw new InvalidParameterValueException(\"Can't delete account specific vlan \" + vlanDbId + \" as ip \" + ip\n                                + \" belonging to the range has firewall rules applied. Cleanup the rules first\");\n                    }\n                    if (ip.getAllocatedTime() != null) {\r\n                        \r\n                        success = _ipAddrMgr.disassociatePublicIpAddress(ip.getId(), userId, caller);\n                    }\n                    if (!success) {\n                        s_logger.warn(\"Some ip addresses failed to be released as a part of vlan \" + vlanDbId + \" removal\");\n                    } else {\n                        resourceCountToBeDecrement++;\n                        UsageEventUtils.publishUsageEvent(EventTypes.EVENT_NET_IP_RELEASE, acctVln.get(0).getAccountId(), ip.getDataCenterId(), ip.getId(),\n                                ip.getAddress().toString(), ip.isSourceNat(), vlanRange.getVlanType().toString(), ip.getSystem(), ip.getClass().getName(), ip.getUuid());\n                    }\n                }\n            } finally {\n                _vlanDao.releaseFromLockTable(vlanDbId);\n                if (resourceCountToBeDecrement > 0) {  \r\n                    _resourceLimitMgr.decrementResourceCount(acctVln.get(0).getAccountId(), ResourceType.public_ip, new Long(resourceCountToBeDecrement));\n                }\n            }\n        } else {   \r\n            final NicIpAliasVO ipAlias = _nicIpAliasDao.findByGatewayAndNetworkIdAndState(vlanRange.getVlanGateway(), vlanRange.getNetworkId(), NicIpAlias.State.active);\n            \r\n            if (ipAlias != null && vlanDbId == _publicIpAddressDao.findByIpAndSourceNetworkId(vlanRange.getNetworkId(), ipAlias.getIp4Address()).getVlanId()) {\n                throw new InvalidParameterValueException(\"Cannot delete vlan range \" + vlanDbId + \" as \" + ipAlias.getIp4Address()\n                        + \"is being used for providing dhcp service in this subnet. Delete all VMs in this subnet and try again\");\n            }\n            final long allocIpCount = _publicIpAddressDao.countIPs(vlanRange.getDataCenterId(), vlanDbId, true);\n            if (allocIpCount > 0) {\n                throw new InvalidParameterValueException(allocIpCount + \"  Ips are in use. Cannot delete this vlan\");\n            }\n        }\n\n        Transaction.execute(new TransactionCallbackNoReturn() {\n            @Override\n            public void doInTransactionWithoutResult(final TransactionStatus status) {\n                _publicIpAddressDao.deletePublicIPRange(vlanDbId);\n                _vlanDao.remove(vlanDbId);\n            }\n        });\n\n        return true;\n    }\n","realPath":"server/src/main/java/com/cloud/configuration/ConfigurationManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":3963,"status":"M"}],"commitId":"d7aa0a2718381fcf57fc1f9df8296a4478d31d00","commitMessage":"@@@server: Prevent NullPointer on a network with removed IP ranges/\"VLANs\" (#3551)\n\nWhen a network IP range is removed.  the \"vlan\" stays mapped on pod_vlan_map; therefore.  the method that lists the VLANs by pod id will return null VLANS.\n\nThis PR adds proper verifications to avoid null pointer exception when deploying VRs on a pod with removed VLANs. The exception was caused on getPlaceholderNicForRouter. ","date":"2019-08-15 16:05:58","modifiedFileCount":"2","status":"M","submitter":"Gabriel Beims Br?scher"},{"authorTime":"2020-11-07 17:42:44","codes":[{"authorDate":"2018-01-20 05:49:27","commitOrder":4,"curCode":"    private boolean isForSystemVms(long vlanId){\n        SearchBuilder<IPAddressVO> sb = userIpAddressDao.createSearchBuilder();\n        sb.and(\"vlanId\", sb.entity().getVlanId(), SearchCriteria.Op.EQ);\n        SearchCriteria<IPAddressVO> sc = sb.create();\n        sc.setParameters(\"vlanId\", vlanId);\n        IPAddressVO userIpAddresVO = userIpAddressDao.findOneBy(sc);\n        return userIpAddresVO.isForSystemVms();\n    }\n","date":"2018-01-20 05:49:27","endLine":773,"groupId":"101444","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"isForSystemVms","params":"(longvlanId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/88/da6342b81c2d0bce453fe1373aa836d5b6a569.src","preCode":"    private boolean isForSystemVms(long vlanId){\n        SearchBuilder<IPAddressVO> sb = userIpAddressDao.createSearchBuilder();\n        sb.and(\"vlanId\", sb.entity().getVlanId(), SearchCriteria.Op.EQ);\n        SearchCriteria<IPAddressVO> sc = sb.create();\n        sc.setParameters(\"vlanId\", vlanId);\n        IPAddressVO userIpAddresVO = userIpAddressDao.findOneBy(sc);\n        return userIpAddresVO.isForSystemVms();\n    }\n","realPath":"server/src/main/java/com/cloud/api/ApiResponseHelper.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":766,"status":"N"},{"authorDate":"2020-11-07 17:42:44","commitOrder":4,"curCode":"    public boolean deleteVlanAndPublicIpRange(final long userId, final long vlanDbId, final Account caller) {\n        VlanVO vlanRange = _vlanDao.findById(vlanDbId);\n        if (vlanRange == null) {\n            throw new InvalidParameterValueException(\"Please specify a valid IP range id.\");\n        }\n\n        boolean isAccountSpecific = false;\n        final List<AccountVlanMapVO> acctVln = _accountVlanMapDao.listAccountVlanMapsByVlan(vlanRange.getId());\n        \r\n        \r\n        if (acctVln != null && !acctVln.isEmpty()) {\n            isAccountSpecific = true;\n        }\n\n        boolean isDomainSpecific = false;\n        List<DomainVlanMapVO> domainVlan = _domainVlanMapDao.listDomainVlanMapsByVlan(vlanRange.getId());\n        \r\n        if (domainVlan != null && !domainVlan.isEmpty()) {\n            isDomainSpecific = true;\n        }\n\n        \r\n        final List<IPAddressVO> ips = _publicIpAddressDao.listByVlanId(vlanDbId);\n        if (isAccountSpecific) {\n            int resourceCountToBeDecrement = 0;\n            try {\n                vlanRange = _vlanDao.acquireInLockTable(vlanDbId, 30);\n                if (vlanRange == null) {\n                    throw new CloudRuntimeException(\"Unable to acquire vlan configuration: \" + vlanDbId);\n                }\n\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"lock vlan \" + vlanDbId + \" is acquired\");\n                }\n                for (final IPAddressVO ip : ips) {\n                    boolean success = true;\n                    if (ip.isOneToOneNat()) {\n                        throw new InvalidParameterValueException(\"Can't delete account specific vlan \" + vlanDbId + \" as ip \" + ip\n                                + \" belonging to the range is used for static nat purposes. Cleanup the rules first\");\n                    }\n\n                    if (ip.isSourceNat()) {\n                        throw new InvalidParameterValueException(\"Can't delete account specific vlan \" + vlanDbId + \" as ip \" + ip\n                                + \" belonging to the range is a source nat ip for the network id=\" + ip.getSourceNetworkId()\n                                + \". IP range with the source nat ip address can be removed either as a part of Network, or account removal\");\n                    }\n\n                    if (_firewallDao.countRulesByIpId(ip.getId()) > 0) {\n                        throw new InvalidParameterValueException(\"Can't delete account specific vlan \" + vlanDbId + \" as ip \" + ip\n                                + \" belonging to the range has firewall rules applied. Cleanup the rules first\");\n                    }\n                    if (ip.getAllocatedTime() != null) {\r\n                        \r\n                        success = _ipAddrMgr.disassociatePublicIpAddress(ip.getId(), userId, caller);\n                    }\n                    if (!success) {\n                        s_logger.warn(\"Some ip addresses failed to be released as a part of vlan \" + vlanDbId + \" removal\");\n                    } else {\n                        resourceCountToBeDecrement++;\n                        final boolean usageHidden = _ipAddrMgr.isUsageHidden(ip);\n                        UsageEventUtils.publishUsageEvent(EventTypes.EVENT_NET_IP_RELEASE, acctVln.get(0).getAccountId(), ip.getDataCenterId(), ip.getId(),\n                                ip.getAddress().toString(), ip.isSourceNat(), vlanRange.getVlanType().toString(), ip.getSystem(), usageHidden, ip.getClass().getName(), ip.getUuid());\n                    }\n                }\n            } finally {\n                _vlanDao.releaseFromLockTable(vlanDbId);\n                if (resourceCountToBeDecrement > 0) {  \r\n                    _resourceLimitMgr.decrementResourceCount(acctVln.get(0).getAccountId(), ResourceType.public_ip, new Long(resourceCountToBeDecrement));\n                }\n            }\n        } else {   \r\n            final NicIpAliasVO ipAlias = _nicIpAliasDao.findByGatewayAndNetworkIdAndState(vlanRange.getVlanGateway(), vlanRange.getNetworkId(), NicIpAlias.State.active);\n            \r\n            if (ipAlias != null && vlanDbId == _publicIpAddressDao.findByIpAndSourceNetworkId(vlanRange.getNetworkId(), ipAlias.getIp4Address()).getVlanId()) {\n                throw new InvalidParameterValueException(\"Cannot delete vlan range \" + vlanDbId + \" as \" + ipAlias.getIp4Address()\n                        + \"is being used for providing dhcp service in this subnet. Delete all VMs in this subnet and try again\");\n            }\n            final long allocIpCount = _publicIpAddressDao.countIPs(vlanRange.getDataCenterId(), vlanDbId, true);\n            if (allocIpCount > 0) {\n                throw new InvalidParameterValueException(allocIpCount + \"  Ips are in use. Cannot delete this vlan\");\n            }\n        }\n\n        Transaction.execute(new TransactionCallbackNoReturn() {\n            @Override\n            public void doInTransactionWithoutResult(final TransactionStatus status) {\n                _publicIpAddressDao.deletePublicIPRange(vlanDbId);\n                s_logger.debug(String.format(\"Delete Public IP Range (from user_ip_address, where vlan_db_d=%s)\", vlanDbId));\n\n                _vlanDao.remove(vlanDbId);\n                s_logger.debug(String.format(\"Mark vlan as Remove vlan (vlan_db_id=%s)\", vlanDbId));\n\n                SearchBuilder<PodVlanMapVO> sb = podVlanMapDao.createSearchBuilder();\n                sb.and(\"vlan_db_id\", sb.entity().getVlanDbId(), SearchCriteria.Op.EQ);\n                SearchCriteria<PodVlanMapVO> sc = sb.create();\n                sc.setParameters(\"vlan_db_id\", vlanDbId);\n                podVlanMapDao.remove(sc);\n                s_logger.debug(String.format(\"Delete vlan_db_id=%s in pod_vlan_map\", vlanDbId));\n            }\n        });\n\n        return true;\n    }\n","date":"2020-11-07 17:42:44","endLine":4251,"groupId":"101444","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteVlanAndPublicIpRange","params":"(finallonguserId@finallongvlanDbId@finalAccountcaller)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-cloudstack-10-0.7/blobInfo/CC_OUT/blobs/1d/b461d2b22a4d5435c7bee535a6baa52f8a4d2e.src","preCode":"    public boolean deleteVlanAndPublicIpRange(final long userId, final long vlanDbId, final Account caller) {\n        VlanVO vlanRange = _vlanDao.findById(vlanDbId);\n        if (vlanRange == null) {\n            throw new InvalidParameterValueException(\"Please specify a valid IP range id.\");\n        }\n\n        boolean isAccountSpecific = false;\n        final List<AccountVlanMapVO> acctVln = _accountVlanMapDao.listAccountVlanMapsByVlan(vlanRange.getId());\n        \r\n        \r\n        if (acctVln != null && !acctVln.isEmpty()) {\n            isAccountSpecific = true;\n        }\n\n        boolean isDomainSpecific = false;\n        List<DomainVlanMapVO> domainVlan = _domainVlanMapDao.listDomainVlanMapsByVlan(vlanRange.getId());\n        \r\n        if (domainVlan != null && !domainVlan.isEmpty()) {\n            isDomainSpecific = true;\n        }\n\n        \r\n        final List<IPAddressVO> ips = _publicIpAddressDao.listByVlanId(vlanDbId);\n        if (isAccountSpecific) {\n            int resourceCountToBeDecrement = 0;\n            try {\n                vlanRange = _vlanDao.acquireInLockTable(vlanDbId, 30);\n                if (vlanRange == null) {\n                    throw new CloudRuntimeException(\"Unable to acquire vlan configuration: \" + vlanDbId);\n                }\n\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"lock vlan \" + vlanDbId + \" is acquired\");\n                }\n                for (final IPAddressVO ip : ips) {\n                    boolean success = true;\n                    if (ip.isOneToOneNat()) {\n                        throw new InvalidParameterValueException(\"Can't delete account specific vlan \" + vlanDbId + \" as ip \" + ip\n                                + \" belonging to the range is used for static nat purposes. Cleanup the rules first\");\n                    }\n\n                    if (ip.isSourceNat()) {\n                        throw new InvalidParameterValueException(\"Can't delete account specific vlan \" + vlanDbId + \" as ip \" + ip\n                                + \" belonging to the range is a source nat ip for the network id=\" + ip.getSourceNetworkId()\n                                + \". IP range with the source nat ip address can be removed either as a part of Network, or account removal\");\n                    }\n\n                    if (_firewallDao.countRulesByIpId(ip.getId()) > 0) {\n                        throw new InvalidParameterValueException(\"Can't delete account specific vlan \" + vlanDbId + \" as ip \" + ip\n                                + \" belonging to the range has firewall rules applied. Cleanup the rules first\");\n                    }\n                    if (ip.getAllocatedTime() != null) {\r\n                        \r\n                        success = _ipAddrMgr.disassociatePublicIpAddress(ip.getId(), userId, caller);\n                    }\n                    if (!success) {\n                        s_logger.warn(\"Some ip addresses failed to be released as a part of vlan \" + vlanDbId + \" removal\");\n                    } else {\n                        resourceCountToBeDecrement++;\n                        UsageEventUtils.publishUsageEvent(EventTypes.EVENT_NET_IP_RELEASE, acctVln.get(0).getAccountId(), ip.getDataCenterId(), ip.getId(),\n                                ip.getAddress().toString(), ip.isSourceNat(), vlanRange.getVlanType().toString(), ip.getSystem(), ip.getClass().getName(), ip.getUuid());\n                    }\n                }\n            } finally {\n                _vlanDao.releaseFromLockTable(vlanDbId);\n                if (resourceCountToBeDecrement > 0) {  \r\n                    _resourceLimitMgr.decrementResourceCount(acctVln.get(0).getAccountId(), ResourceType.public_ip, new Long(resourceCountToBeDecrement));\n                }\n            }\n        } else {   \r\n            final NicIpAliasVO ipAlias = _nicIpAliasDao.findByGatewayAndNetworkIdAndState(vlanRange.getVlanGateway(), vlanRange.getNetworkId(), NicIpAlias.State.active);\n            \r\n            if (ipAlias != null && vlanDbId == _publicIpAddressDao.findByIpAndSourceNetworkId(vlanRange.getNetworkId(), ipAlias.getIp4Address()).getVlanId()) {\n                throw new InvalidParameterValueException(\"Cannot delete vlan range \" + vlanDbId + \" as \" + ipAlias.getIp4Address()\n                        + \"is being used for providing dhcp service in this subnet. Delete all VMs in this subnet and try again\");\n            }\n            final long allocIpCount = _publicIpAddressDao.countIPs(vlanRange.getDataCenterId(), vlanDbId, true);\n            if (allocIpCount > 0) {\n                throw new InvalidParameterValueException(allocIpCount + \"  Ips are in use. Cannot delete this vlan\");\n            }\n        }\n\n        Transaction.execute(new TransactionCallbackNoReturn() {\n            @Override\n            public void doInTransactionWithoutResult(final TransactionStatus status) {\n                _publicIpAddressDao.deletePublicIPRange(vlanDbId);\n                s_logger.debug(String.format(\"Delete Public IP Range (from user_ip_address, where vlan_db_d=%s)\", vlanDbId));\n\n                _vlanDao.remove(vlanDbId);\n                s_logger.debug(String.format(\"Mark vlan as Remove vlan (vlan_db_id=%s)\", vlanDbId));\n\n                SearchBuilder<PodVlanMapVO> sb = podVlanMapDao.createSearchBuilder();\n                sb.and(\"vlan_db_id\", sb.entity().getVlanDbId(), SearchCriteria.Op.EQ);\n                SearchCriteria<PodVlanMapVO> sc = sb.create();\n                sc.setParameters(\"vlan_db_id\", vlanDbId);\n                podVlanMapDao.remove(sc);\n                s_logger.debug(String.format(\"Delete vlan_db_id=%s in pod_vlan_map\", vlanDbId));\n            }\n        });\n\n        return true;\n    }\n","realPath":"server/src/main/java/com/cloud/configuration/ConfigurationManagerImpl.java","repoName":"cloudstack","snippetEndLine":0,"snippetStartLine":0,"startLine":4149,"status":"M"}],"commitId":"5f8289ffe90fd829493bf4e0d23c64ef50313627","commitMessage":"@@@Re-enable IP address usage hiding (#4327)\n\n","date":"2020-11-07 17:42:44","modifiedFileCount":"11","status":"M","submitter":"Olivier Lemasle"}]
